\documentclass[a4paper,12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{xltxtra}
%\usepackage[francais]{babel}
\usepackage{fancyhdr}
%\usepackage[utf8]{inputenc}
\usepackage{epsfig}
\usepackage{calc}
\usepackage{color}
\usepackage{url}
\usepackage{boxedminipage}

\usepackage{fontspec}
%% \setmainfont{Adobe Garamond Pro}

%% \usepackage[language=french]{csquotes}

\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{amsmath,amssymb,amsthm} % For including math equations, theorems, symbols, etc

\usepackage{listings}
\linespread{1.05}
\lstset{numbers=left,firstnumber=1,numberfirstline=true, language=C}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Définitions à personnaliser 

%% Pour les noms, utilisez la première lettre du prénom suivi du 
%% nom de famille (première lettre majuscule, reste en minuscule).


%%%% Indiquer le nom de l'encadrant ci-dessous:

\def\nomEncad{Julia \textsc{Lawall} \& Gilles \textsc{Müller}}

%% Si le projet est co-encadré indiquer les deux noms à la suite dans 
%% Le même champs


%%%% Indiquer les noms des étudiants participant ci-dessous:

\def\nomEtudA{Louisa \textsc{Bessad}}

%% Si le projet est encadré par moins de 4 étudiants laissez
%% les variables inutiles vides


%%%% Indiquer la référence (numero) et le nom du sujet ci-dessous:

\def\titreProjetLong{Handling hardware device failures}

%% Le titre court ne doit pas faire plus d'une vingtaine de caractère
%% résumez le à quelques mots essenciels


%%%% Indiquer le type de document et sa version ci-dessous:

\def\typeDoc{Report}
 
%% - Rapport intermédaire
%% - Rapport final

%\let\origsec\section
%\renewcommand{\section}[1]{\newpage\origsec{#1}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Définitions à ne pas modifier
 
%%%% ||| Mise en page verticale ||| 
\setlength{\voffset}{-1in} % a4:reste 297mm pour les 5 suivants:
\setlength{\topmargin}{15mm}         % avant l'en-tête
\setlength{\headheight}{20mm}        % hauteur de l'en-tête 
\setlength{\headsep}{10mm}            % entre l'en-tête et le corps
\setlength{\textheight}{220mm}       % hauteur du corps
\setlength{\footskip}{12mm}          % pied de page par rapport au corps 
%\setlength{\footlength}{2em}

%%%%% --- Mise en page horizontale ---
\setlength{\hoffset}{-1in} % a4:reste 210mm 
\setlength{\oddsidemargin}{25mm}     % entre hoffset et le corps
\setlength{\evensidemargin}{25mm}    % entre hoffset et le corps
\setlength{\marginparwidth}{0mm}     % largeur de la marge
\setlength{\marginparsep}{0mm}       % séparateur corps marge
\setlength{\textwidth}{160mm}        % largeur du corps

%\usepackage{fullpage}
%\setlength{\headheight}{20mm}        % hauteur de l'en-tête 
%\setlength{\headsep}{10mm}            % entre l'en-tête et le corps
%\setlength{\textheight}{200mm}
%\setlength{\footskip}{0mm}          % pied de page par rapport au corps 

\def\annee{2013-14}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Début du document

\begin{document}

%\selectlanguage{francais}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Définition des en-têtes et pied de pages
\pagestyle{fancyplain}
%\fancyhead{}
%\fancyfoot{}
%
\fancyhead[L]{\textsc{Université Pierre et Marie Curie}\\
          Master Informatique \\ \nomEncad}
%% \fancyhead[C]{\textbf{Stage Magistère}}
\fancyhead[R]{\textsc{Stage Magistère}\\{\color{white}Jean Pierre macht einen guten Kafe !}\\\nomEtudA}

\fancyfoot[L]{\includegraphics[width=3cm]{UPMC_sorbonne}}
\fancyfoot[C]{\textbf{\thepage/\pageref{fin}}}
\fancyfoot[R]{\typeDoc}

%\lhead[\fancyplain{}{\texttt{Université Pierre et Marie Curie}\\
%          Master Informatique\\ UE \textbf{PSAR} fév. \annee \\ \nomEncad}]
%      {\fancyplain{}{\textsc{Université Pierre et Marie Curie}\\
%          Master Informatique\\ UE \textbf{PSAR} \annee \\ \nomEncad}}
%\chead[\fancyplain{}{\textbf{Projet \refProjet\\\titreProjetCourt}}]
%      {\fancyplain{}{\textbf{Projet \refProjet\\\titreProjetCourt}}}
%\rhead[\fancyplain{}{\nomEtudA\\\nomEtudB}]
%      {\fancyplain{}{\nomEtudA\\\nomEtudB}}
%\lfoot[\fancyplain{}{\epsfig{figure=UPMC_sorbonne.eps,width=3cm}}]
%      {\fancyplain{}{\epsfig{figure=UPMC_sorbonne.eps,width=3cm}}}
%\cfoot[\fancyplain{}{\textbf{\thepage/\pageref{fin}}}]
%      {\fancyplain{}{\textbf{\thepage/\pageref{fin}}}}
%\rfoot[\fancyplain{}{\typeDoc}]
%      {\fancyplain{}{\typeDoc}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      \begin{center}
        \begin{boxedminipage}{12cm}{
            \begin{center}
              ~\\\LARGE\textbf{\titreProjetLong}\\
              ~\\\large Tutors: \textbf{\nomEncad}\vspace{0.5em}\\
              ~\large Student: \textbf{\nomEtudA}\\
              ~
            \end{center}
            }
        \end{boxedminipage}
      \end{center}

\vfill

%\newpage

\tableofcontents
\vfill
%\newpage


%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\newpage\section{Introduction}

Systems need to use drivers to be able to access devices. But when a device fails, this can cause driver to crash or hang. It has been demonstrated that most system failures are due to hardware device failures. Most of the time these failures are transient. By tolerating device failures drivers can prevent the system from crashing or hanging. In this way the reliability of the system can be improved. Most approaches for research on drivers failures fall into two categories. The first is the static bug finding ; it analyzes the interface between the driver and the kernel to find incoherences. The second is the runtime fault tolerance. Most of the time these approaches need new operating sytem or new driver models ; it is not the case for static analysis. Usually these approaches find the failure but do not fix it. While they try to reduce faults on the interface between driver and device, they need specific interfaces and languages.

This project fall in the first category. The goal is to find every unchecked inputs from drivers and fix those failures. In this way different types of code need to be searched. First, we look for functions that are known to perform I/O and verify that the return value is checked. Second, we want to find variables used as pointers or indexies of an array and check that they do not reference a forbidden memory area. Third, we search structures dependant on input from the device that could be corrupted by a bad allocation. Fourth, calls to panic function are searched. Finally, we look for loops that wait for a specific hardware device state without timeout.

We will study the loop without timeout and propose a solution to this problem. Then we will present the results bring by our solution, and we will compare these to anothers from a previous analysis using a different tool.

\newpage
%----------------------------------------------------------------------------------------
%	SOLUTION
%----------------------------------------------------------------------------------------

\section{The choosen problem and its solution}

When the terminating condition of a loop is never reached, we stay in the loop infinitely. This could cause the crash or hanging of the system, it is the behaviour of a loop without timeout. So the existence of a timeout in a loop is really important as its definition. We consider as a timeout a variable that is incremented or decremented in the loop or another assignment (such as $ \ll= $ or $ \gg= $ ). Moreover it has to be used as  exit condition of the loop, or a part of this condition. Furthermore it cannot be used as a pointer or index of an arrray. In this way every loop that does not respect these conditions will be considered as a loop without timeout, also called infinite loop.


\subsection{Types of infinite loops}
By studiing the source of a kernel we can find two types of loop without timeout. The first type correponds to loops with an exit condition which is not a timeout variable. In this case the therminating condition can be a function that call drivers, a pointer value that assigns the return of one of these functions, a variable or metavariable defined in another file. But if the function never returns a value that allows to exit of the loop, the system will stay infinitely in the loop Listing 1. The problem is the same if the pointer or the variable from another file used as exit condition of a loop have always a bad allocation.

\lstset{frame=lines,caption={This loop calls the readl function which will ask a data, referenced as the argument of the function, to a driver which is a keyboard controller in this case.},captionpos=t}
%/input/keyboard/nomadik-ske-keypad.c 2010
\begin{lstlisting}
  while ((readl(keypad->reg_base + SKE_CR) & SKE_KPASON) 
  && --retries)
  msleep(5);
\end{lstlisting}

\vspace{0.5cm}
The second kind of loops without timeout uses an infinite exit condition: ``for(;;)''or ``while(1)''. For instance:
%/base/devtmpfs.c 2009
\lstset{frame=lines,caption={This loop does not have an exit condition. Whereas it is a part of the code that handle the register of every driver during bootup.},captionpos=t}
\begin{lstlisting}
  while (1) {
    spin_lock(&req_lock);
    /.../
    set_current_state(TASK_INTERRUPTIBLE);
    spin_unlock(&req_lock);
    schedule();
    __set_current_state(TASK_RUNNING);
}
\end{lstlisting}

\vspace{0.5cm}
Sometimes to ensure a possible exit of the infinite loop, the body of the loop contains an alternative. Usually the alternative's condition is based on variables' value, but there are also alternatives whitch use a call to a driver function as condition. However this function could never return the right value to exit the loop, in this case the alternative is useless. For the alternative which the condition can besatisfied, there are alternatives with a break, Listing 3, or another way to exit the loop Listing 4. 
%firmware/efivars.c 2001 -> 2004, 2004
\lstset{frame=lines,caption={This loop of an Intel driver has two possibilities to exit of this infinite loop.},captionpos=t}
\begin{lstlisting}
  while (1) {
    variable_name_size = 1024;
    status = efivars->ops->get_next_variable(
    &variable_name_size,
    variable_name,
    &vendor);
    if (status != EFI_SUCCESS) {
      break;
    } else {
      if (!variable_is_present(variable_name,
      &vendor)) {
	found = true;
	break;
      }
    }
  }
\end{lstlisting}

%tty/serial/8250\_early.c 2004
\lstset{frame=lines,caption={In this loop we can notice the presence of an alternative without any break. If the condition never come true the program will never exit this loop. Moreover if alternative's condition is satifsied the code following the loop will never be executed. This loop is contained in a fonction of a console driver for a printer device},captionpos=t}
\begin{lstlisting}
  for (;;) {
    status = serial_in(port, UART_LSR);
    if ((status & BOTH_EMPTY) == BOTH_EMPTY)
    return;
    cpu_relax();
}
\end{lstlisting}
\vspace{0.5cm}
So even when the infinite loop has a possibility to exit the loop with an alternative containing a ``break'' or a ``return'', it stays very dangerous. Because the possibility could never occur or segment of code are skipped. 
So most of the time the alternatives are not a solution to solve the second type of infinite loops.


%These infinite loops could cause the same problems than the previous type of infinte loops.

To avoid these two types of infinite loop we will insert a segment of code in the body of the loop. This segment will contain the addition of a timeout, its allocation and the exit condition of the loop will be modified.


\subsection{Proposed solution}

To find and fix these loops we used a bug finding tool called Coccinelle. This uses patches that contain rules, a rule will transform the code by the deletion and the addition of code. In this way, Coccinelle scans the code to find lines matching with the searching condition and applies the transformation. In our case there is two patches; one for the ``while'' infinite loops and another one for the ``for'' infinite loops. The condition rule will be an infinite loop and the transformation will be the addition and allocation of a timeout and the modification of the exit condition of the loop. Furthermore our patches  will contain several rules, because there is many ways to write a same loop with C programming.

Mettre un exemple de deux boucles identique ++E1 ou E1++ 

Nevertheless Coccinelle does not allow to match the loop: do{...}while(...), so we chose not to handle this type of loop.

%----------------------------------------------------------------------------------------
%	RESULTS AND COMMENTS
%----------------------------------------------------------------------------------------

\section{Results and Comments}
\subsection{With Coccinelle}
The Linux3.2.59 Kernel had been used as testing platform. Firstly we wanted to know the pourcentage of loop and infinite loop in the kernel. However during the execution of patches some files have been skipped by Coccinelle to avoid a very long execution time. It appeared that whatever the computer used to execute the patches without the timeout option of Coccinelle, the execution could never end. For those files the analysis must be made by a programer. The following array shows the result of these executions, the ``EXN'' column correspond to the number of skipped files:


\vspace*{5mm}
\begin{tabular}{|c|c|c|c|}
  \hline
    & Total loop & Infinite loop & EXN files \\
  \hline
  while & 9342 &  4509  & 97 \\
  \hline
  for   &  27616 & 468 & 87 \\
  \hline
\end{tabular} 
\vspace*{5mm}

We can see that 48\% of the ``while'' loop does not have a timeout whereas only 2\% of the ``for'' loop are infinite loop. / These infinite loops concern drivers. Nevertheless these drivers are old, in the recent kernel these bugs had been corrected. /

\subsection{With another tool: Carburizer}

Another study had been made by /blablablabla/, it uses an automatic code manipulation-tool :''Carburizer'' created specificly for finding hardware device failures. In this way it takes a driver and scans its code. Then it lists bugs that can occur in it and suggests fixes for these bugs according to their type. In the case of infinite loop, Carburizer finds 2383 locations where drivers detect failures by timeouts on the Linux3.2.59 Kernel.

\subsection{Comparison}
We can that Carburizer finds 2594 infinite loops less. Given these results we can think, there is a problem with ours. But it is not the case, this is due to the fact that we have not the same definition of an infinite loop. Looking at Kadav's results we can see that only: blabla list des resultats ou tableau comparif.
%\begin{center}
%Algorithme Mécanisme d'arrêt :
%\end{center}

%\begin{algorithmic}
 % \State $quota\_memoire \gets QUOTA\_DISPONIBLE$
  %\State $envoye \gets faux$
  %\State $nouvelle\_fenetre \gets NB\_APPELS\_TIMER$
  %\Function{handler\_timer}{}
%	\State $consommation \gets recuperer\_les\_valeurs\_du compteur\_materiel\_avec\_PAPI$
%	\State $quota\_memoire \gets quota\_memoire - consommation$
%	\If {$quota\_memoire\leq 0 ET envoye = faux$}
%		\State $envoyer\_SIGSTOP\_aux\_attaquants$
%		\State $envoye \gets vrai$
%	\EndIf	
%	\State $nouvelle\_fenetre \gets nouvelle\_fenetre - 1$	
%	\If {$nouvelle\_fenetre = 0$}
%		\State $envoyer\_SIGCONT\_aux\_attaquants$
%		\State $nouvelle\_fenetre \gets NB\_APPELS\_TIMER$
%		\State $quota\_memoire \gets QUOTA\_DISPONIBLE$
%		\State $envoye \gets faux$
%	\EndIf
%	\EndFunction
%\end{algorithmic}


%\begin{center}
%\includegraphics[width=12cm, height=7.5cm]{benchmark_1_performance.png}
%\end{center}


\section{Conclusion}

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

%\renewcommand{\refname}{\spacedlowsmallcaps{References}} % For modifying the bibliography heading

%\bibliographystyle{unsrt}

%\bibliography{sample.bib} % The file containing the bibliography

%----------------------------------------------------------------------------------------



\label{fin}

\end{document}
