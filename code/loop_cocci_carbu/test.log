 	while (i != stop) {
 		add_event_entry(buf[i++]);
 
 		if (i >= max)
 			i = 0;
+			if (_cur < timeout) {
--
 	while (vq->vring.desc[i].flags & VRING_DESC_F_NEXT) {
 		i = vq->vring.desc[i].next;
 		vq->num_free++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		s64 diff;
 
 		try_to_freeze();
@@ -277,6 +282,12 @@ static int balloon(void *_vballoon)
 		 * and always have work to do.  Be nice if preempt disabled.
--
 	while (1) {
 		spin_lock(&req_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (requests) {
 			struct req *req = requests;
 			requests = NULL;
 			spin_unlock(&req_lock);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
--
 			while (req) {
 				struct req *next = req->next;
 				req->err = handle(req->name, req->mode, req->dev);
 				complete(&req->done);
 				req = next;
+				if (_cur < timeout) {
--
 	while (cur != end) {
 		struct devres_node *node;
 		struct devres_group *grp;
@@ -356,6 +361,12 @@ static int remove_nodes(struct device *d
 			list_move_tail(&node->entry, todo);
 			cnt++;
--
 	while (cur != end) {
 		struct devres_node *node;
 		struct devres_group *grp;
@@ -390,6 +406,12 @@ static int remove_nodes(struct device *d
 			list_move_tail(&grp->node[0].entry, todo);
 			list_del_init(&grp->node[1].entry);
--
 	while (dev) {
 		struct device *tmp = to_isa_dev(dev)->next;
 		device_unregister(dev);
 		dev = tmp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		knode = klist_next(&iter->ki);
 		if (!knode)
@@ -337,6 +342,12 @@ struct device *class_dev_iter_next(struc
 		dev = container_of(knode, struct device, knode_class);
 		if (!iter->type || iter->type == dev->type)
--
 	while (id->name[0]) {
 		if (strcmp(pdev->name, id->name) == 0) {
 			pdev->id_entry = id;
 			return id;
 		}
 		id++;
--
 	while (count) {
 		void *page_data;
 		int page_nr = offset >> PAGE_SHIFT;
@@ -318,6 +323,12 @@ static ssize_t firmware_data_read(struct
 		buffer += page_cnt;
 		offset += page_cnt;
--
-	while (fw_priv->nr_pages < pages_needed) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (fw_priv->nr_pages < pages_needed) {
 		fw_priv->pages[fw_priv->nr_pages] =
 			alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
 
@@ -358,6 +374,12 @@ static int fw_realloc_buffer(struct firm
 			return -ENOMEM;
--
 	while (count) {
 		void *page_data;
 		int page_nr = offset >> PAGE_SHIFT;
@@ -412,6 +439,12 @@ static ssize_t firmware_data_write(struc
 		buffer += page_cnt;
 		offset += page_cnt;
--
 	while (node) {
 		rbnode = container_of(node, struct regcache_rbtree_node, node);
 		regcache_rbtree_get_base_top_reg(rbnode, &base_reg, &top_reg);
@@ -83,6 +88,12 @@ static struct regcache_rbtree_node *regc
 		} else if (reg < base_reg) {
 			node = node->rb_left;
--
-	while (*new) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*new) {
 		rbnode_tmp = container_of(*new, struct regcache_rbtree_node,
 					  node);
 		/* base and top registers of the current rbnode */
@@ -115,6 +131,12 @@ static int regcache_rbtree_insert(struct
 			new = &((*new)->rb_right);
--
 	while (next) {
 		rbtree_node = rb_entry(next, struct regcache_rbtree_node, node);
 		next = rb_next(&rbtree_node->node);
 		rb_erase(&rbtree_node->node, &rbtree_ctx->root);
 		kfree(rbtree_node->block);
 		kfree(rbtree_node);
--
 	while (ws->active) {
 		spin_unlock_irq(&ws->lock);
 
 		schedule_timeout_interruptible(msecs_to_jiffies(TIMEOUT));
 
 		spin_lock_irq(&ws->lock);
--
 	while (entry != &dpm_list) {
 		struct device * dev = to_device(entry);
 		unsigned int hash = hash_string(DEVSEED, dev_name(dev), DEVHASH);
@@ -201,6 +206,12 @@ static int show_dev_hash(unsigned int va
 			match++;
 		}
--
-	while (size && entry != &dpm_list) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size && entry != &dpm_list) {
 		struct device *dev = to_device(entry);
 		unsigned int hash = hash_string(DEVSEED, dev_name(dev),
 						DEVHASH);
@@ -234,6 +250,12 @@ int show_trace_dev_match(char *buf, size
 			size -= len;
--
 	while (!list_empty(&dpm_noirq_list)) {
 		struct device *dev = to_device(dpm_noirq_list.next);
 		int error;
@@ -478,6 +483,12 @@ void dpm_resume_noirq(pm_message_t state
 
 		mutex_lock(&dpm_list_mtx);
--
 	while (!list_empty(&dpm_suspended_list)) {
 		dev = to_device(dpm_suspended_list.next);
 		get_device(dev);
@@ -647,6 +663,12 @@ void dpm_resume(pm_message_t state)
 		if (!list_empty(&dev->power.entry))
 			list_move_tail(&dev->power.entry, &dpm_prepared_list);
--
 	while (!list_empty(&dpm_prepared_list)) {
 		struct device *dev = to_device(dpm_prepared_list.prev);
 
@@ -710,6 +737,12 @@ void dpm_complete(pm_message_t state)
 
 		mutex_lock(&dpm_list_mtx);
--
-	while (!list_empty(&devices_kset->list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&devices_kset->list)) {
 		dev = list_entry(devices_kset->list.prev, struct device,
 				kobj.entry);
 		get_device(dev);
@@ -1758,6 +1763,12 @@ void device_shutdown(void)
 		put_device(dev);
--
-	while (vaddr > fault_vaddr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (vaddr > fault_vaddr) {
 		ret = gru_vtop(gts, vaddr, write, atomic, &gpa, &pageshift);
 		if (ret || tfh_write_only(tfh, gpa, GAA_RAM, vaddr, asid, write,
 					  GRU_PAGESIZE(pageshift)))
@@ -348,6 +353,12 @@ static void gru_preload_tlb(struct gru_s
 			vaddr, asid, write, pageshift, gpa);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		wait_event(gms->ms_wait_queue,
 			   atomic_read(&gms->ms_range_active) == 0);
 		prefetchw(tfh);	/* Helps on hdw, required for emulator */
@@ -635,6 +651,12 @@ static int gru_user_dropin(struct gru_th
 		if (ret <= 0)
--
 		while (!gru_assign_gru_context(kgts)) {
 			msleep(1);
 			gru_steal_context(kgts);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 	while (n--) {
 		i = find_first_bit(p, mmax);
 		if (i == mmax)
@@ -178,6 +183,12 @@ static unsigned long reserve_resources(u
 		__set_bit(i, &bits);
 		if (idx)
--
 	while (count) {
 		if (kim_gdata->rx_count) {
 			len = min_t(unsigned int, kim_gdata->rx_count, count);
@@ -190,6 +195,12 @@ void kim_int_recv(struct kim_data_s *kim
 		kim_gdata->rx_skb->cb[0] = 4;
 		kim_gdata->rx_skb->cb[1] = 0;
--
 	while (count) {
 		if (st_gdata->rx_count) {
 			len = min_t(unsigned int, st_gdata->rx_count, count);
@@ -359,6 +364,12 @@ void st_int_recv(void *disc_data,
 		};
 		ptr++;
--
 		while (parent) {
 			if (parent == dev) {
 				get_device(&edev->edev);
@@ -72,6 +77,12 @@ struct enclosure_device *enclosure_find(
 				return edev;
 			}
--
 	while (time_before(jiffies, start + HZ)) {
 		if (fpga_power_good(priv))
 			return 0;
 
 		usleep_range(5000, 10000);
+		if (_cur < timeout) {
--
 		while (true) {
 
 			if (fpga_fifo_empty(priv->regs)) {
@@ -392,6 +408,12 @@ static int fpga_program_block(struct fpg
 			}
 
--
 	while (list_empty(used)) {
 		spin_unlock_irq(&priv->lock);
 
@@ -1104,6 +1109,12 @@ static ssize_t data_read(struct file *fi
 			return ret;
 
--
 		while (ids->type) {
 			if (tifm_dev_match(sock, ids))
 				return 1;
 			++ids;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (!xpc_exiting) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!xpc_exiting) {
 
 		dev_dbg(xpc_part, "woke up with %d ticks rem; %d IRQs have "
 			"been received\n",
@@ -303,6 +308,12 @@ xpc_hb_checker(void *ignore)
 						xpc_hb_check_timeout) ||
--
-	while ((ret = xpc_pull_remote_vars_part_sn2(part)) != xpSuccess) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((ret = xpc_pull_remote_vars_part_sn2(part)) != xpSuccess) {
 		if (ret != xpRetry) {
 			XPC_DEACTIVATE_PARTITION(part, ret);
 			return ret;
@@ -1491,6 +1496,12 @@ xpc_make_first_contact_sn2(struct xpc_pa
 
--
 	while (get >= ch_sn2->next_msg_to_pull) {
 
 		/* pull as many messages as are ready and able to be pulled */
@@ -1957,6 +1973,12 @@ xpc_pull_remote_msg_sn2(struct xpc_chann
 		}
 
--
 	while (id->name && id->name[0]) {
 		if (strcmp(name, id->name) == 0)
 			return id;
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (reader != writer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (reader != writer) {
 		memcpy_fromio(&input, get_queue_entry(sp, reader),
 				sizeof(struct remote_input));
 
@@ -204,6 +209,12 @@ void ibmasm_handle_mouse_interrupt(struc
 
--
 	while (event->serial_number < reader->next_serial_number) {
 		index = (index + 1) % IBMASM_NUM_EVENTS;
 		event = &buffer->events[index];
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 	while ((ch = buf[count])) {
 		checksum += ch;
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (parser->cur_pos + sizeof(struct iwmct_fw_sec_hdr)
 		<= parser->file_size) {
 
@@ -150,6 +155,12 @@ static int iwmct_parse_next_section(stru
 		parser->cur_pos += le32_to_cpu(sec_hdr->data_size);
 		LOG_INFO(priv, FW_DOWNLOAD,
--
-	while (iwmct_parse_next_section(priv, &pdata, &len, &addr)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (iwmct_parse_next_section(priv, &pdata, &len, &addr)) {
 		ret = iwmct_download_section(priv, pdata, len, addr);
 		if (ret) {
 			LOG_ERROR(priv, FW_DOWNLOAD,
 				  "%s download section failed\n", fw_name);
 			goto exit;
--
-	while (!list_empty(&priv->read_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&priv->read_req_list)) {
 		read_req = list_entry(priv->read_req_list.next,
 			struct iwmct_work_struct, list);
 
 		list_del(&read_req->list);
 		kfree(read_req);
--
 	while (irqstat) {
 		struct pwm_channel *ch;
 		void (*handler)(struct pwm_channel *ch);
@@ -297,6 +302,12 @@ static irqreturn_t pwm_irq(int id, void
 			spin_lock(&p->lock);
 			handled = IRQ_HANDLED;
--
 	while (i < data_length) {
 		/* A 0 bit indicates literal data. */
 		if (altera_read_packed(in, 1, &bits_avail,
@@ -136,6 +141,12 @@ u32 altera_shrink(u8 *in, u32 in_length,
 				}
 			}
--
-		while (count--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (count--) {
 			/* Exchange TxDummy for location (keymap[kbddata]) */
 			kbd_data = jornada_ssp_byte(TXDUMMY);
 			scan_code = kbd_data & 0x7f;
@@ -84,6 +89,12 @@ static irqreturn_t jornada720_kbd_interr
 			input_report_key(input, jornadakbd->keymap[scan_code],
--
-		while (count--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (count--) {
 			int data;
 
 			error = i2c_smbus_write_byte(client, inireg + idx);
@@ -103,6 +108,12 @@ static int qt2160_read_block(struct i2c_
 			}
--
 	while ((pp = of_get_next_child(node, pp))) {
 		enum of_gpio_flags flags;
 
@@ -518,6 +523,12 @@ static int gpio_keys_get_devtree_pdata(s
 			buttons[i].debounce_interval = 5;
 
--
 	while (cnt < idx - 1) {
 		unsigned int btn = ptr->data[cnt++];
 		int up = btn & 1;
@@ -260,6 +265,12 @@ static void hil_dev_handle_ptr_events(st
 		btn = (btn - 0x80) >> 1;
 		btn = ptr->btnmap[btn];
--
 	while (hil_busy())
 		/* wait */;
 	hil_command(cmd);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (len--) {
 		while (hil_busy())
 			/* wait */;
 		hil_write_data(*(data++));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((event = key_fifo[i++])) {
 		u8 key = lm8323_whichkey(event);
 		int isdown = lm8323_ispress(event);
@@ -293,6 +298,12 @@ static void process_keys(struct lm8323_c
 			lm->keys_down++;
 		else
--
 	while (steps) {
 		int s;
 
 		s = min(126, steps);
 		pwm_cmds[num_cmds++] = PWM_RAMP(div512, perstep, s, up);
 		steps -= s;
--
 		while (change) {
 			bit     = fls(change) - 1;
 			change ^= BIT(bit);
@@ -98,6 +103,12 @@ static irqreturn_t keypad_irq(int irq, v
 			input_event(kp->input_dev, EV_MSC, MSC_SCAN, code);
 			input_report_key(kp->input_dev, kp->keycodes[code],
--
 	while (size != ix) {
 		len = size - ix;
 		if (len > sizeof(p->data))
@@ -320,6 +325,12 @@ static int yealink_set_ringtone(struct y
 		memcpy(p->data, &buf[ix], len);
 		yealink_cmd(yld, p);
--
 	while (udev->head != udev->tail && retval + input_event_size() <= count) {
 		if (input_event_to_user(buffer + retval, &udev->buff[udev->tail])) {
 			retval = -EFAULT;
@@ -484,6 +489,12 @@ static ssize_t uinput_read(struct file *
 		}
 		udev->tail = (udev->tail + 1) % UINPUT_BUFFER_SIZE;
--
 	while ((dev->data.bits_left + 7 < (sizeof(dev->data.tester) * 8)) &&
 	       (dev->data.pos < dev->data.len)) {
 		dev->data.tester += (dev->data.buffer[dev->data.pos++] << dev->data.bits_left);
 		dev->data.bits_left += 8;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (memcmp(&tm, &tm_last, sizeof(struct rtc_time))) {
 		if (i++ > 4) return -1;
 		memcpy(&tm_last, &tm, sizeof(struct rtc_time));
 		if (hp_sdc_rtc_do_read_bbrtc(&tm)) return -1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (ids->type || ids->proto) {
 		if ((ids->type == SERIO_ANY || ids->type == serio->id.type) &&
 		    (ids->proto == SERIO_ANY || ids->proto == serio->id.proto) &&
@@ -97,6 +102,12 @@ static int serio_match_port(const struct
 		    (ids->id == SERIO_ANY || ids->id == serio->id.id))
 			return 1;
--
-	while ((event = serio_get_event())) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((event = serio_get_event())) {
 
 		switch (event->type) {
 
@@ -248,6 +264,12 @@ static void serio_handle_event(struct wo
 
--
 	while (!list_empty(&serio->children)) {
 
 		/* Locate a leaf */
@@ -669,6 +696,12 @@ static void serio_disconnect_port(struct
 
 			s = parent;
--
-	while ((inb(CT82C710_STATUS) & (CT82C710_RX_FULL | CT82C710_TX_IDLE | CT82C710_DEV_IDLE))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((inb(CT82C710_STATUS) & (CT82C710_RX_FULL | CT82C710_TX_IDLE | CT82C710_DEV_IDLE))
 		       != (CT82C710_DEV_IDLE | CT82C710_TX_IDLE) && timeout) {
 
 		if (inb_p(CT82C710_STATUS) & CT82C710_RX_FULL) inb_p(CT82C710_DATA);
 
 		udelay(1);
--
 	while (ct82c170_wait()) {
 		printk(KERN_ERR "ct82c710: Device busy in open()\n");
 		status &= ~(CT82C710_ENABLE | CT82C710_INTS_ON);
 		outb_p(status, CT82C710_STATUS);
 		free_irq(CT82C710_IRQ, NULL);
 		return -EBUSY;
--
 	while (status & KMIIR_RXINTR) {
 		serio_interrupt(kmi->io, readb(KMIDATA), 0);
 		status = readb(KMIIR);
 		handled = IRQ_HANDLED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((status = readl(ps2if->base)) & 0xffff0000) {
 		serio_interrupt(ps2if->io, status & 0xff, 0);
 		handled = IRQ_HANDLED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (gscps2_readb_status(addr) & GSC_STAT_TBNE) {
 		if (!--timeout)
 			return 0;	/* This should not happen */
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	  while ( (ps2port->buffer[ps2port->append].str =
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	  unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ( (ps2port->buffer[ps2port->append].str =
 		   gscps2_readb_status(ps2port->addr)) & GSC_STAT_RBNE ) {
 		ps2port->buffer[ps2port->append].data =
 				gscps2_readb_input(ps2port->addr);
 		ps2port->append = ((ps2port->append+1) & BUFFER_SIZE);
+		if (_cur < timeout) {
--
 	  while (ps2port->act != ps2port->append) {
 
 	    unsigned int rxflags;
@@ -270,6 +297,12 @@ static irqreturn_t gscps2_interrupt(int
 
 	    serio_interrupt(ps2port->port, data, rxflags);
--
 	  } /* while() */
 
 	} /* list_for_each_entry */
diff -u -p a/input/serio/rpckbd.c b/input/serio/rpckbd.c
--- a/input/serio/rpckbd.c
+++ b/input/serio/rpckbd.c
--
 	while (iomd_readb(IOMD_KCTRL) & (1 << 5)) {
 		byte = iomd_readb(IOMD_KARTRX);
 
 		serio_interrupt(port, byte, 0);
 		handled = IRQ_HANDLED;
+		if (_cur < timeout) {
--
 	while (retval < count && serio_raw_fetch_byte(serio_raw, &c)) {
 		if (put_user(c, buffer++))
 			return -EFAULT;
 		retval++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count--) {
 		if (get_user(c, buffer++)) {
 			retval = -EFAULT;
@@ -220,6 +236,12 @@ static ssize_t serio_raw_write(struct fi
 			goto out;
 		}
--
 	while (mlc->icount < 15 - i) {
 		hil_packet p;
 
@@ -199,6 +204,12 @@ static void hil_mlc_send_polls(hil_mlc *
 			drv->interrupt(serio, (p >> 8) & ~HIL_PKT_ADDR_MASK, 0);
 			drv->interrupt(serio, p & 0xff, 0);
--
 	while (nextidx & HILSEN_SCHED) {
 		struct timeval tv;
 
@@ -748,6 +764,12 @@ static int hilse_donode(hil_mlc *mlc)
 	sched:
 		tasklet_schedule(&hil_mlcs_tasklet);
--
 	while ((last != idx) && (*last == 0))
 		last--;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (idx != last) {
 		drv->interrupt(serio, 0, 0);
 		drv->interrupt(serio, HIL_ERR_INT >> 16, 0);
 		drv->interrupt(serio, 0, 0);
 		drv->interrupt(serio, *idx, 0);
 		idx++;
--
-	while (sdc_readb(hp_sdc.status_io) & HP_SDC_STATUS_IBF)
-		{ }
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
--
+		while (sdc_readb(hp_sdc.status_io) & HP_SDC_STATUS_IBF)
+		{ if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
--
 	while (status & PS2STAT_RXF) {
 		if (status & PS2STAT_STP)
 			sa1111_writel(PS2STAT_STP, ps2if->base + SA1111_PS2STAT);
@@ -61,6 +66,12 @@ static irqreturn_t ps2_rxint(int irq, vo
 		serio_interrupt(ps2if->io, scancode, flag);
 
--
 	while (retval + input_event_size() <= count &&
 	       evdev_fetch_next_event(client, &event)) {
 
@@ -410,6 +415,12 @@ static ssize_t evdev_read(struct file *f
 			return -EFAULT;
 
--
 	while (num--) {
 		data |= (__u64)((buf[i] >> tri++) & 1) << bit++;	/* Transfer bit */
 		if (tri == bits) {
 			i++;						/* Next triplet */
 			tri = 0;
 		}
--
 	while (t) {						/* Sum */
 		sum += t & 0xf;
 		t >>= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	j = jiffies; while (j == jiffies);
-	j = jiffies; while (j == jiffies) { t++; gameport_read(gameport); }
+	j = jiffies; unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (j == jiffies) { t++; gameport_read(gameport); if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
--
 	while (i < length) {
 		prefix = report[i];
 
@@ -528,6 +533,12 @@ static void parse_hid_report_descriptor(
 
 			break;
--
-			while (raw_n--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (raw_n--) {
 				ptest = int2bound(&c->p,
 						  raw2int(f->force_major));
 				if (ptest > PRESSURE_LOW)
@@ -547,6 +552,12 @@ static int report_tp_state(struct bcm597
 				if (ptest > PRESSURE_HIGH)
--
-	while (!list_empty(&serio->children)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&serio->children)) {
 		if (++retry > 3) {
 			psmouse_warn(psmouse,
 				     "failed to destroy children ports, protocol change aborted.\n");
@@ -1617,6 +1622,12 @@ static ssize_t psmouse_attr_set_protocol
 			input_free_device(new_dev);
--
-	while (pos < buf_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pos < buf_len) {
 		/* get packet len */
 		pkt_len = usbtouch->type->get_pkt_len(buffer + pos,
 							buf_len - pos);
@@ -1238,6 +1243,12 @@ static void usbtouch_process_multi(struc
 			return;
--
 	while (!kthread_should_stop()) {
 		unsigned int x, y, p;
 		long timeout;
@@ -231,6 +236,12 @@ static int ucb1400_ts_thread(void *_ucb)
 		wait_event_freezable_timeout(ucb->ts_wait,
 			ucb->irq_pending || ucb->ts_restart ||
--
-	while (!(ucb1400_reg_read(ucb->ac97, UCB_ADC_DATA) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(ucb1400_reg_read(ucb->ac97, UCB_ADC_DATA) &
 						UCB_ADC_DAT_VALID)) {
 		cpu_relax();
 		if (time_after(jiffies, timeout)) {
@@ -325,6 +341,12 @@ static int ucb1400_ts_detect_irq(struct
 			probe_irq_off(mask);
--
 	while (msg_idx < ts->msg_count) {
 
 		ts->wait_for_sync();
@@ -763,6 +768,12 @@ static void ads7846_read_state(struct ad
 		} else {
 			msg_idx++;
--
 	while (!ts->stopped && get_pendown_state(ts)) {
 
 		/* pen is down, continue with the measurement */
@@ -889,6 +905,12 @@ static irqreturn_t ads7846_irq(int irq,
 
 		wait_event_timeout(ts->wait, ts->stopped,
--
 	while ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((wm97xx_reg_read(wm, AC97_WM9713_DIG1) & WM9713_POLL) &&
 		timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((wm97xx_reg_read(wm, AC97_WM9713_DIG1) & WM9713_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (val & TPS6507X_REG_TSC_INT) {
 		mdelay(10);
 		ret = tps6507x_read_u8(tsc, TPS6507X_REG_INT, &val);
 		if (ret)
 			return ret;
 		loops++;
--
-	while (pos < fw->size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pos < fw->size) {
 		ret = mxt_check_bootloader(client,
 						MXT_WAITING_FRAME_DATA);
 		if (ret)
@@ -1001,7 +1006,13 @@ static int mxt_load_fw(struct device *de
 		pos += frame_size;
--
 	while (retval + sizeof(struct js_event) <= count &&
 	       joydev_generate_startup_event(client, input, &event)) {
 
@@ -431,8 +436,19 @@ static ssize_t joydev_read(struct file *
 			return -EFAULT;
 
--
 	while (retval + sizeof(struct js_event) <= count &&
 	       joydev_fetch_next_event(client, &event)) {
 
@@ -440,6 +456,12 @@ static ssize_t joydev_read(struct file *
 			return -EFAULT;
 
--
-	while (atomic_read(&sl->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&sl->refcnt)) {
 		dev_dbg(dev, "Waiting for %s to become free: refcnt=%d.\n",
 				sl->name, atomic_read(&sl->refcnt));
 		if (msleep_interruptible(1000))
 			flush_signals(current);
+			if (_cur < timeout) {
--
-	while (atomic_read(&fent->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&fent->refcnt)) {
 		printk(KERN_INFO "Waiting for family %u to become free: refcnt=%d.\n",
 				fent->fid, atomic_read(&fent->refcnt));
 
 		if (msleep_interruptible(1000))
 			flush_signals(current);
--
-	while (atomic_read(&dev->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&dev->refcnt)) {
 		dev_info(&dev->dev, "Waiting for %s to become free: refcnt=%d.\n",
 				dev->name, atomic_read(&dev->refcnt));
 
 		if (msleep_interruptible(1000))
 			flush_signals(current);
--
 	while (retries--) {
 		w1_buf[0] = W1_F29_FUNC_CHANN_ACCESS_WRITE;
 		w1_buf[1] = *buf;
@@ -205,6 +210,12 @@ static ssize_t w1_f29_write_output(
 				"mutex unlocked, retries:%d", retries);
 			return 1;
--
 	while (retries--) {
 		w1_write_8(sl->master, W1_F29_FUNC_RESET_ACTIVITY_LATCHES);
 		if (w1_read_8(sl->master) == W1_F29_SUCCESS_CONFIRM_BYTE) {
@@ -241,6 +257,12 @@ static ssize_t w1_f29_write_activity(
 		}
 		if (w1_reset_resume_command(sl->master))
--
 	while (retries--) {
 		w1_buf[0] = W1_F29_FUNC_WRITE_COND_SEARCH_REG;
 		w1_buf[1] = W1_F29_REG_CONTROL_AND_STATUS;
@@ -288,6 +315,12 @@ static ssize_t w1_f29_write_status_contr
 			mutex_unlock(&sl->master->mutex);
 			return 1;
--
 	while (idx < count) {
 		addr = off + idx;
 		len = W1_PAGE_SIZE - (addr & W1_PAGE_MASK);
@@ -248,6 +253,12 @@ static ssize_t w1_f23_write_bin(struct f
 			goto out_up;
 		}
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		reg_val = __raw_readb(dev->regs + MXC_W1_CONTROL);
 
 		if (((reg_val >> 7) & 0x1) == 0 ||
@@ -74,6 +79,12 @@ static u8 mxc_w1_ds2_reset_bus(void *dat
 			timeout_cnt++;
--
 		while (((*status = hdq_reg_in(hdq_data, offset)) & flag)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (!((*status = hdq_reg_in(hdq_data, offset)) & flag)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (!(hdq_data->hdq_irqstatus
 			& OMAP_HDQ_INT_STATUS_RXCOMPLETE)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (hdr) {
 		next = hdr->next;
 		kfree(hdr);
 		hdr = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (data_itr < data_top) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (data_itr < data_top) {
 		result = -ENOMEM;
 		hdr = kmalloc(sizeof(*hdr), GFP_KERNEL);
 		if (hdr == NULL) {
@@ -138,6 +154,12 @@ int fw_hdrs_load(struct i1480 *i1480, st
 		*prev_hdr = hdr;
--
 	while (itr < top) {
 		val <<= 8;
 		val |= array[top - 1];
 		top--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (itr < buffer_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (itr < buffer_size) {
 		len = buffer_size - itr >= sizeof(val) ?
 			sizeof(val) : buffer_size - itr;
 		val = get_val(buffer, itr, len);
 		bmp_itr[itr / sizeof(val)] = val;
 		itr += sizeof(val);
--
 	while(pohThis != &memheap->oh_free) {
 		if(pohThis->offset == ulUpper) {
 			poh_next = pohThis;
@@ -3354,6 +3359,12 @@ sisfb_poh_free(struct SIS_HEAP *memheap,
 			poh_prev = pohThis;
 		}
--
    while(delay--) {
       SiS_GenericDelay(SiS_Pr, 6623);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
--
    while(delay--) {
       SiS_GenericDelay(SiS_Pr, 66);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
--
   while(*dataptr) {
      dataptr = SiS_SetTrumpBlockLoop(SiS_Pr, dataptr);
      if(!dataptr) return false;
+     if (_cur < timeout) {
+       rdstcll(_cur);
+     }
--
 	while (i--) {
 		WAIT_FIFO(p, 3);
 		pm2_WR(p, PM2R_RD_PALETTE_DATA, 0);
 		pm2_WR(p, PM2R_RD_PALETTE_DATA, 0);
 		pm2_WR(p, PM2R_RD_PALETTE_DATA, 0);
+		if (_cur < timeout) {
--
 	while (height--) {
 		int width = ((image->width + 7) >> 3)
 				+ info->pixmap.scan_align - 1;
 		width >>= 2;
 		WAIT_FIFO(par, width);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (width--) {
 			pm2_WR(par, PM2R_BIT_MASK_PATTERN, *src);
 			src++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 		while (pos < (1024 + PM2VI_RD_CURSOR_PATTERN)) {
 			pm2_WR(par, PM2VR_RD_INDEX_HIGH, pos >> 8);
 			pm2v_RDAC_WR(par, pos++, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-		while (tmio_ioread16(par->lcr + LCR_CCS) > ccs) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (tmio_ioread16(par->lcr + LCR_CCS) > ccs) {
 			udelay(1);
 			i++;
 			if (i > 10000) {
@@ -374,6 +379,12 @@ tmiofb_acc_wait(struct fb_info *info, un
 				return -ETIMEDOUT;
--
 	while (tmio_ioread16(par->lcr + LCR_BBES) & 2) { /* blit active */
 		udelay(1);
 		i++ ;
@@ -428,6 +444,12 @@ static int tmiofb_sync(struct fb_info *f
 			printk(KERN_ERR "timeout waiting for blit to end!\n");
 			return -ETIMEDOUT;
--
-		while (n--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (n--) {
 			if (p->fix.visual == FB_VISUAL_TRUECOLOR ||
 			    p->fix.visual == FB_VISUAL_DIRECTCOLOR )
 				color = palette[*src];
@@ -90,6 +95,12 @@ static void color_imageblit(const struct
 			shift += bpp;
--
 		while (j--) {
 			l--;
 			color = (*s & (1 << l)) ? fgcolor : bgcolor;
@@ -153,7 +169,13 @@ static void slow_imageblit(const struct
 			shift += bpp;
 			shift &= (32 - 1);
--
 	while (!kthread_should_stop()) {
 		try_to_freeze();
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -908,6 +913,12 @@ static int ps3fbd(void *arg)
 			console_unlock();
 		}
--
-			while (height--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (height--) {
 #if defined(__BIG_ENDIAN)
 				fb_writel((*chardata) << 24, mmio.vaddr);
 #else
 				fb_writel(*chardata, mmio.vaddr);
 #endif
--
-			while (height--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (height--) {
 #if defined(__BIG_ENDIAN)
 				fb_writel((*(u_int16_t*)chardata) << 16, mmio.vaddr);
 #else
 				fb_writel(*(u_int16_t*)chardata, mmio.vaddr);
 #endif
--
 			while (height--) {
 				size_t i;
 				
@@ -487,6 +514,12 @@ static void matroxfb_1bpp_imageblit(stru
 					fb_writel(get_unaligned((u_int32_t*)(chardata + i)),mmio.vaddr);
 				}
--
 			while ((nl = mga_inl(0x3C48) & 0xFFF) >= lastl) {
 				lastl = nl;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 	while (divider & 3) {
 		hd >>= 1;
 		hs >>= 1;
 		he >>= 1;
 		ht >>= 1;
 		divider <<= 1;
--
 			while (m1) {
 				int t;
 
@@ -598,6 +603,12 @@ static int matroxfb_decode_var(const str
 				t = m1;
 				m1 = m2;
--
 		while (p && (tvco > vcomax)) {
 			p--;
 			tvco >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (sptr >= sarray) {
 			unsigned int mnp = *sptr--;
 		
@@ -291,6 +307,12 @@ static inline unsigned int g450_findwork
 				mnpfound = mnp;
 				found = 1;
--
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -1046,6 +1051,12 @@ static int __init pvr2fb_setup(char *opt
 		} else {
 			mode_option = this_opt;
--
 		while (n--) {
 			*dst++ = pat;
 			pat = pat << left | pat >> right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (n--) {
 			*dst ^= pat;
 			pat = pat << left | pat >> right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (height--) {
 			dst += dst_idx >> (ffs(bits) - 1);
 			dst_idx &= (bits - 1);
 			fill_op32(p, dst, dst_idx, pat, width*bpp, bits);
 			dst_idx += p->fix.line_length*8;
+			if (_cur < timeout) {
--
 		while (height--) {
 			dst += dst_idx / bits;
 			dst_idx &= (bits - 1);
@@ -324,6 +362,12 @@ void sys_fillrect(struct fb_info *p, con
 			fill_op(p, dst, dst_idx, pat2, left, right,
 				width*bpp, bits);
--
 	while (!kthread_should_stop()) {
 
 		if (try_to_freeze())
@@ -1282,6 +1287,12 @@ static int pxafb_smart_thread(void *arg)
 
 		set_current_state(TASK_INTERRUPTIBLE);
--
 	while (next) {
 		next = false;
 		for (i = 0; i < ARRAY_SIZE(device_mapping); i++) {
@@ -929,6 +934,12 @@ u32 via_parse_odev(char *input, char **e
 				}
 			}
--
 	while (regset->regnum != VGA_REGSET_END_VAL) {
 		regval = vga_rcrt(regbase, regset->regnum);
 		bitnum = regset->lowbit;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (bitnum <= regset->highbit) {
 			bitval = 1 << bitnum;
 			regval = regval & ~bitval;
 			if (value & 1) regval = regval | bitval;
 			bitnum ++;
 			value = value >> 1;
--
 	while (regset->regnum != VGA_REGSET_END_VAL) {
 		regval = vga_rseq(regbase, regset->regnum);
 		bitnum = regset->lowbit;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (bitnum <= regset->highbit) {
 			bitval = 1 << bitnum;
 			regval = regval & ~bitval;
 			if (value & 1) regval = regval | bitval;
 			bitnum ++;
 			value = value >> 1;
--
 	while ((ar > pll->r_min) && (f_vco > pll->f_vco_max)) {
 		ar--;
 		f_vco = f_vco >> 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((am <= pll->m_max) && (an <= pll->n_max)) {
 		f_current = (pll->f_base * am) / an;
 		delta_current = abs_diff (f_current, f_vco);
@@ -427,6 +465,12 @@ int svga_compute_pll(const struct svga_p
 		} else {
 			an ++;
--
-			while (i < priv->used_meram_cache_regions - 1) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (i < priv->used_meram_cache_regions - 1) {
 				priv->used_meram_cache[i] =
 					priv->used_meram_cache[i + 1] ;
 				i++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (actual_count--) {
 		lv =	 ((lv << 1) |
 			(((lv >> 15) ^ (lv >> 4) ^ (lv >> 2) ^ (lv >> 1)) & 1))
 			& 0xFFFF;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((pixel_end > pixel) &&
 	       (cmd_buffer_end - MIN_RLX_CMD_BYTES > cmd)) {
 		uint8_t *raw_pixels_count_byte = 0;
@@ -455,6 +471,11 @@ static void dlfb_compress_hline(
 
 		prefetch_range((void *) pixel, (cmd_pixel_end - pixel) * bpp);
--
 		while (pixel < cmd_pixel_end) {
 			const uint16_t * const repeating_pixel = pixel;
 
@@ -468,9 +489,20 @@ static void dlfb_compress_hline(
 				*raw_pixels_count_byte = ((repeating_pixel -
 						raw_pixel_start) + 1) & 0xFF;
--
 				while ((pixel < cmd_pixel_end)
 				       && (*pixel == *repeating_pixel)) {
 					pixel++;
+					if (_cur < timeout) {
+									rdstcll(_cur);
+					}
--
-	while (next_pixel < line_end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (next_pixel < line_end) {
 
 		dlfb_compress_hline((const uint16_t **) &next_pixel,
 			     (const uint16_t *) line_end, &dev_addr,
@@ -562,6 +611,12 @@ static int dlfb_render_hline(struct dlfb
 			cmd = urb->transfer_buffer;
--
 		while (desc < desc_end) {
 			u8 length;
 			u16 key;
@@ -1555,6 +1615,12 @@ static int dlfb_parse_vendor_descriptor(
 				break;
 			}
--
 		while (n--) {
 			FB_WRITEL(pat, dst++);
 			pat = pat << left | pat >> right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (n--) {
 			FB_WRITEL(FB_READL(dst) ^ val, dst);
 			dst++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (n--) {
 			FB_WRITEL(FB_READL(dst) ^ pat, dst);
 			dst++;
 			pat = pat << left | pat >> right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-		while (height--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (height--) {
 			dst += dst_idx >> (ffs(bits) - 1);
 			dst_idx &= (bits - 1);
 			fill_op32(p, dst, dst_idx, pat, width*bpp, bits,
 				  bswapmask);
 			dst_idx += p->fix.line_length*8;
--
 		while (height--) {
 			dst += dst_idx / bits;
 			dst_idx &= (bits - 1);
@@ -360,6 +409,12 @@ void cfb_fillrect(struct fb_info *p, con
 			fill_op(p, dst, dst_idx, pat2, left, right,
 				width*bpp, bits);
--
 	while (t_inb(par, STATUS) & 0x80) {
 		count++;
 		if (count == 10000000) {
@@ -302,6 +307,12 @@ static void xp_wait_engine(struct triden
 			}
 		}
--
 	while (left <= right) {
 		val = 0;
 		for (i = 0; i < 8; i++) {
@@ -287,6 +292,12 @@ static void arcfb_lcd_update_page(struct
 			bitmask <<= 1;
 			rightshift++;
--
 		while (p < buf + len) {
 			int found;
 			if (num_ovls == OMAPFB_MAX_OVL_PER_FB) {
@@ -241,6 +246,12 @@ static ssize_t store_overlays(struct dev
 				ovls[num_ovls++] = fbdev->overlays[ovlnum];
 
--
 		while (p < buf + len) {
 			int rot;
 
@@ -395,6 +411,12 @@ static ssize_t store_overlays_rotate(str
 			rotation[num_ovls++] = rot;
 
--
-	while (!gpio_get_value(picodlp_pdata->emu_done_gpio)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!gpio_get_value(picodlp_pdata->emu_done_gpio)) {
 		if (!trial--) {
 			dev_err(&dssdev->dev, "emu_done signal not"
 						" going high\n");
 			return -ETIMEDOUT;
 		}
--
 	while (dss_read_reg(DSS_SDI_STATUS) & (1 << 6)) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("PLL lock request timed out\n");
 			goto err1;
 		}
+		if (_cur < timeout) {
--
 	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 5))) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("PLL lock timed out\n");
 			goto err1;
 		}
+		if (_cur < timeout) {
--
 	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 2))) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("SDI reset timed out\n");
 			goto err2;
 		}
+		if (_cur < timeout) {
--
 	while (REG_GET(dsidev, idx, bitnum, bitnum) != value) {
 		if (--t == 0)
 			return !value;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-	while (FLD_GET(dsi_read_reg(dsidev, DSI_CLK_CTRL), 29, 28) != state) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (FLD_GET(dsi_read_reg(dsidev, DSI_CLK_CTRL), 29, 28) != state) {
 		if (++t > 1000) {
 			DSSERR("Failed to set DSI PLL power mode to %d\n",
 					state);
 			return -ENODEV;
 		}
--
-	while (FLD_GET(dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1),
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (FLD_GET(dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1),
 			26, 25) != state) {
 		if (++t > 1000) {
 			DSSERR("failed to set complexio power state to "
@@ -2024,6 +2051,12 @@ static int dsi_cio_power(struct platform
 			return -ENODEV;
--
 	while (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {
 		u32 val;
 		val = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));
@@ -2826,6 +2864,12 @@ static void dsi_vc_flush_long_data(struc
 				(val >> 8) & 0xff,
 				(val >> 16) & 0xff,
--
 	while (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {
 		u32 val;
 		u8 dt;
@@ -2892,6 +2941,12 @@ static u16 dsi_vc_flush_receive_data(str
 		} else {
 			DSSERR("\tunknown datatype 0x%02x\n", dt);
--
-	while (!list_empty(&manager_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&manager_list)) {
 		mgr = list_first_entry(&manager_list,
 				struct omap_overlay_manager, list);
 		list_del(&mgr->list);
 		kobject_del(&mgr->kobj);
 		kobject_put(&mgr->kobj);
--
 	while (venc_read_reg(VENC_F_CONTROL) & (1<<8)) {
 		if (--t == 0) {
 			DSSERR("Failed to reset venc\n");
 			return;
 		}
+		if (_cur < timeout) {
--
 	while (val != REG_GET(base_addr, idx, b2, b1)) {
 		udelay(1);
 		if (t++ > 10000)
 			return !val;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (!list_empty(&overlay_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&overlay_list)) {
 		ovl = list_first_entry(&overlay_list,
 				struct omap_overlay, list);
 		list_del(&ovl->list);
 		kobject_del(&ovl->kobj);
 		kobject_put(&ovl->kobj);
--
 			while (n--) {
 				d1 = *src++;
 				*dst++ = d0 << left | d1 >> right;
 				d0 = d1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (n--) {
 				d1 = *src--;
 				*dst-- = d0 >> right | d1 << left;
 				d0 = d1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 		while (height--) {
 			dst_idx -= bits_per_line;
 			src_idx -= bits_per_line;
@@ -354,8 +381,19 @@ void sys_copyarea(struct fb_info *p, con
 			src_idx &= (bytes - 1);
 			bitcpy_rev(p, dst, dst_idx, src, src_idx, bits,
--
 		while (height--) {
 			dst += dst_idx >> (ffs(bits) - 1);
 			dst_idx &= (bytes - 1);
@@ -365,6 +403,12 @@ void sys_copyarea(struct fb_info *p, con
 				width*p->var.bits_per_pixel);
 			dst_idx += bits_per_line;
--
 	while (running) {
 		next = running->next;
 		running->next = priv->free;
 		priv->free = running;
 		running = next;
+		if (_cur < timeout) {
--
 	while (ready) {
 		shared->buffer[num++] = 0x00000001;
 		shared->buffer[num++] = ready->phys;
 		ready = ready->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (buffer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (buffer) {
 		next = buffer->next;
 
 		dma_free_coherent(&dev->dev, PXA3XX_GCU_BATCH_WORDS * 4,
@@ -572,6 +599,12 @@ free_buffers(struct platform_device *dev
 		kfree(buffer);
--
 	while (len) {
 		sossi_write_reg8(SOSSI_FIFO_REG, *(const u8 *) data);
 		len--;
 		data++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len) {
 		*(u8 *) data = sossi_read_reg8(SOSSI_FIFO_REG);
 		len--;
 		data++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (!(dispc_read_reg(DISPC_SYSSTATUS) & 1)) {
 			if (!--tmo) {
 				dev_err(dispc.fbdev->dev, "soft reset failed\n");
@@ -1423,6 +1428,12 @@ static int omap_dispc_init(struct omapfb
 				enable_digit_clocks(0);
 				goto fail1;
--
-	while (!list_empty(&hwa742.pending_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&hwa742.pending_req_list)) {
 		struct hwa742_request *req;
 		void (*complete)(void *);
 		void *complete_data;
@@ -302,6 +307,12 @@ static void process_pending_requests(voi
 			complete(complete_data);
--
-	while (!list_empty(&blizzard.pending_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&blizzard.pending_req_list)) {
 		struct blizzard_request *req;
 		void (*complete)(void *);
 		void *complete_data;
@@ -430,6 +435,12 @@ static void process_pending_requests(voi
 			complete(complete_data);
--
 	while (start_line < height) {
 		struct urb *urb = ufx_get_urb(dev);
 		if (!urb) {
@@ -885,6 +890,12 @@ int ufx_handle_damage(struct ufx_data *d
 		check_warn_return(status, "Error submitting URB");
 
--
-	while (bytecount) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (bytecount) {
 		cur_addr = wfm_addr + offset;
 		maxlen = roundup(cur_addr, sector_size) - cur_addr;
 		writecount = min(bytecount, maxlen);
@@ -705,6 +710,12 @@ static int broadsheet_write_spiflash(str
 
--
 	while (par->dmaFree < size && --count && !par->lockup) {
 		dmaGet = READ_GET(par);
 
@@ -144,6 +149,12 @@ static void NVDmaWait(struct fb_info *in
 			}
 		} else
--
 	while (count--) {
 		head = i810_readl(IRING + 4, mmio) & RBUFFER_HEAD_MASK;	
 		if ((tail == head) || 
@@ -71,6 +76,12 @@ static inline int wait_for_space(struct
 		    (tail < head && (head - tail) >= space)) {
 			return 0;	
--
 	while (diff_min && mod_min && (n_target < n_target_max)) {
 		f_out = (p_divisor * n_reg * 1000000)/(4 * 24 * m_reg);
 		mod = (p_divisor * n_reg * 1000000) % (4 * 24 * m_reg);
@@ -750,6 +755,12 @@ static void i810_calc_dclk(u32 freq, u32
 			n_best = n_target;
 			m_best = m_target;
--
 			while (n--) {
 				d1 = *src++;
 				*dst++ = d0 << left | d1 >> right;
 				d0 = d1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (n--) {
 				d1 = *src--;
 				*dst-- = d0 >> right | d1 << left;
 				d0 = d1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (n--) {
 				d1 = ~*src++;
 				*dst++ = d0 << left | d1 >> right;
 				d0 = d1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
-	while (height--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		    while (height--) {
 		switch (rect->rop) {
 		    case ROP_COPY:
 			fill_one_line(info->var.bits_per_pixel,
@@ -1989,6 +2027,12 @@ static void amifb_fillrect(struct fb_inf
 			break;
--
 		while (height--) {
 			dst_idx -= par->next_line*8;
 			src_idx -= par->next_line*8;
 			copy_one_line_rev(info->var.bits_per_pixel,
 					  par->next_plane, dst, dst_idx, src,
 					  src_idx, width);
--
-		while (height--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (height--) {
 			copy_one_line(info->var.bits_per_pixel,
 				      par->next_plane, dst, dst_idx, src,
 				      src_idx, width);
 			dst_idx += par->next_line*8;
 			src_idx += par->next_line*8;
--
-		while (height--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (height--) {
 			expand_one_line(info->var.bits_per_pixel,
 					par->next_plane, dst, dst_idx, width,
 					src, image->bg_color,
 					image->fg_color);
 			dst_idx += par->next_line*8;
--
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -424,6 +429,12 @@ static void __init gx1fb_setup(char *opt
 			strlcpy(panel_option, this_opt + 6, sizeof(panel_option));
 		else
--
 	while(1) {
 		if (__sst_read(vbase, STATUS) & STATUS_FBI_BUSY) {
 			f_dddprintk("status: busy\n");
@@ -231,6 +236,12 @@ static int __sst_wait_idle(u8 __iomem *v
 		}
 		if (count >= 5) return 1;
--
 	while (dinfo->ring_space < n) {
 		dinfo->ring_head = INREG(PRI_RING_HEAD) & RING_HEAD_MASK;
 		dinfo->ring_space = get_ring_space(dinfo);
@@ -1543,6 +1548,12 @@ static int wait_ring(struct intelfb_info
 			}
 		}
--
 	while (ndwords--) {
 		dat = 0;
 		for (j = 0; j < 2; ++j) {
@@ -1828,6 +1844,12 @@ int intelfbhw_do_drawglyph(struct intelf
 			}
 		}
--
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -370,6 +375,12 @@ static int __init intelfb_setup(char *op
 			mode = get_opt_string(this_opt, "mode=");
 		else
--
 		while (dvo) {
 			if (dvo & 1) {
 				s = intelfbhw_dvo_to_string(1 << i);
@@ -811,6 +827,12 @@ static int __devinit intelfb_pci_registe
 			}
 			dvo >>= 1;
--
 	while (height--) {
 		int width = ((image->width + 7) >> 3)
 				+ info->pixmap.scan_align - 1;
@@ -592,17 +597,45 @@ static void pm3fb_imageblit(struct fb_in
 			int i = PM3_FIFO_SIZE - 1;
 
--
 			while (i--) {
 				PM3_WRITE_REG(par, PM3BitMaskPattern, *src);
 				src++;
+				if (_cur < timeout) {
+	rdstcll(_cur);
+				}
--
 		while (width--) {
 			PM3_WRITE_REG(par, PM3BitMaskPattern, *src);
 			src++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 			while (n--) {
 				d1 = FB_READL(src++);
 				d1 = fb_rev_pixels_in_long(d1, bswapmask);
@@ -183,6 +188,12 @@ bitcpy(struct fb_info *p, unsigned long
 				d0 = fb_rev_pixels_in_long(d0, bswapmask);
 				FB_WRITEL(d0, dst++);
--
 			while (n--) {
 				d1 = FB_READL(src--);
 				d1 = fb_rev_pixels_in_long(d1, bswapmask);
@@ -354,6 +370,12 @@ bitcpy_rev(struct fb_info *p, unsigned l
 				d0 = fb_rev_pixels_in_long(d0, bswapmask);
 				FB_WRITEL(d0, dst--);
--
 		while (height--) {
 			dst_idx -= bits_per_line;
 			src_idx -= bits_per_line;
 			bitcpy_rev(p, base + (dst_idx / bits), dst_idx % bits,
 				base + (src_idx / bits), src_idx % bits, bits,
 				width*p->var.bits_per_pixel, bswapmask);
--
-		while (height--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (height--) {
 			bitcpy(p, base + (dst_idx / bits), dst_idx % bits,
 				base + (src_idx / bits), src_idx % bits, bits,
 				width*p->var.bits_per_pixel, bswapmask);
 			dst_idx += bits_per_line;
 			src_idx += bits_per_line;
--
 	while (ulBits) {
 		if (!(ulPattern & 1))
 			ulCount++;
 		ulBits--;
 		ulPattern = ulPattern >> 1;
+		if (_cur < timeout) {
--
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -577,6 +582,12 @@ static int __init kyrofb_setup(char *opt
 		} else {
 			mode_option = this_opt;
--
 	while (list != &global_no_mode) {
 		list_del_init(list);
 		entry = list_entry(list, struct vml_info, head);
@@ -1144,6 +1149,12 @@ int vmlfb_register_subsys(struct vml_sys
 		}
 		vmlfb_blank_locked(entry);
--
 	while (virtual_start < virtual_end) {
 		struct page *page;
 
@@ -1211,6 +1216,12 @@ free_unused_pages(unsigned int virtual_s
 
 		virtual_start += PAGE_SIZE;
--
 	while (height--) {
 		c = src;
 		p = dst;
@@ -149,6 +154,12 @@ void c2p_planar(void *dst, const void *s
 		}
 		src += src_nextline;
--
-		while (n--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (n--) {
 			if (p->fix.visual == FB_VISUAL_TRUECOLOR ||
 			    p->fix.visual == FB_VISUAL_DIRECTCOLOR )
 				color = palette[*src];
@@ -116,6 +121,12 @@ static inline void color_imageblit(const
 			shift += bpp;
--
 		while (j--) {
 			l--;
 			color = (*s & (1 << l)) ? fgcolor : bgcolor;
@@ -182,7 +198,13 @@ static inline void slow_imageblit(const
 			shift += bpp;
 			shift &= (32 - 1);
--
 	while ((ndev = nubus_find_type(NUBUS_CAT_DISPLAY,
 				       NUBUS_TYPE_VIDEO, ndev)))
 	{
@@ -708,6 +713,12 @@ static int __init macfb_init(void)
 			strcpy(macfb_fix.id, "Generic NuBus");
 			break;
--
 		while (mhz100 < (mach64MinFreq << 3)) {
 			mhz100 <<= 1;
 			divider += 0x20;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (mhz100 < (mach64MinFreq << 3)) {
 			mhz100 <<= 1;
 			k++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (mhz100 < (mach64MinFreq << 3)) {
 			mhz100 <<= 1;
 			divider += 0x40;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((Remainder = Multiplier % Divider)) {
 		Multiplier = Divider;
 		Divider = Remainder;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (db) {
 		for (i = 0; i < dbsize; i++) {
 			int d;
@@ -1001,6 +1006,12 @@ int  radeon_match_mode(struct radeonfb_i
 			dbsize = 34;
 			native_db = 0;
--
 	while (x) {
 		x >>= 1;
 		b++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (*name) {
 			if (!strcmp(vname, *name))
 				return i + 1;
 			name++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (height--) {
 
 			if (info->var.bits_per_pixel == 1)
@@ -2650,6 +2666,12 @@ static void atafb_imageblit(struct fb_in
 							image->bg_color, image->fg_color);
 			dy++;
--
 	while (count--) {
 		unsigned short *start;
 		unsigned short *le;
@@ -1649,6 +1654,12 @@ static void fbcon_redraw_softback(struct
 			s = (u16 *) softback_buf;
 		if (s == (u16 *) softback_in)
--
 	while (count--) {
 		unsigned short *start = s;
 		unsigned short *le = advance_row(s, 1);
@@ -1683,6 +1699,12 @@ static void fbcon_redraw_move(struct vc_
 			fbcon_putcs(vc, start, s - start, dy, x);
 		console_conditional_schedule();
--
 	while (count--) {
 		unsigned short *start = s;
 		unsigned short *le = advance_row(s, 1);
@@ -1733,6 +1760,12 @@ static void fbcon_redraw_blit(struct vc_
 			s -= vc->vc_size_row;
 			d -= vc->vc_size_row;
--
 	while (count--) {
 		unsigned short *start = s;
 		unsigned short *le = advance_row(s, 1);
@@ -1788,6 +1826,12 @@ static void fbcon_redraw(struct vc_data
 			s -= vc->vc_size_row;
 			d -= vc->vc_size_row;
--
 	while (count) {
 		scr_memcpyw((u16 *) softback_in, p, vc->vc_size_row);
 		count--;
@@ -1812,6 +1861,12 @@ static inline void fbcon_softback_note(s
 			if (softback_top == softback_end)
 				softback_top = softback_buf;
--
 	while (cnt--) {
 		u16 a = scr_readw(p);
 		if (!vc->vc_can_do_color)
@@ -2782,6 +2842,12 @@ static void fbcon_invert_region(struct v
 			p = (u16 *) softback_buf;
 		if (p == (u16 *) softback_in)
--
 	while (cnt--) {
 		src = ops->fontbuffer + (scr_readw(s++) & charmask)*cellsize;
 
@@ -107,6 +112,12 @@ static inline void cw_putcs_aligned(stru
 					      vc->vc_font.width);
 
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -162,6 +178,12 @@ static void cw_putcs(struct vc_data *vc,
 		image.dy += image.height;
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count--) {
 		scr_memcpyw(vgacon_scrollback + vgacon_scrollback_tail,
 			    p, c->vc_size_row);
 		vgacon_scrollback_cnt++;
@@ -232,6 +237,12 @@ static void vgacon_scrollback_update(str
 			vgacon_scrollback_cnt = vgacon_scrollback_rows;
--
 	while (count--) {
 		u16 a = scr_readw(p);
 		if (col)
@@ -647,6 +663,12 @@ static void vgacon_invert_region(struct
 		else
 			a ^= ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;
--
 	while (cnt--) {
 		src = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;
 
@@ -121,6 +126,12 @@ static inline void ccw_putcs_aligned(str
 					      vc->vc_font.width);
 
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -178,6 +194,12 @@ static void ccw_putcs(struct vc_data *vc
 		image.dy += image.height;
--
     while (count--) {
 	sti_putc(sticon_sti, scr_readw(s++), ypos, xpos++);
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	    }
+	    else {
--
     while (count--) {
 	u16 a = scr_readw(p);
 
@@ -338,6 +354,12 @@ static void sticon_invert_region(struct
 		a = ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;
 
--
 	while (cnt--) {
 		src = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;
 
@@ -108,6 +113,12 @@ static inline void ud_putcs_aligned(stru
 					      image->height);
 
--
 	while (cnt--) {
 		src = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;
 
@@ -142,6 +158,12 @@ static inline void ud_putcs_unaligned(st
 		dst += (shift_low >= 8) ? s_pitch : s_pitch - 1;
 		shift_low &= 7;
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -209,6 +236,12 @@ static void ud_putcs(struct vc_data *vc,
 		count -= cnt;
--
-	while (cnt--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cnt--) {
 		src = vc->vc_font.data + (scr_readw(s++)&
 					  charmask)*cellsize;
 
@@ -100,6 +105,12 @@ static inline void bit_putcs_aligned(str
 					      image->height);
--
-	while (cnt--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cnt--) {
 		src = vc->vc_font.data + (scr_readw(s++)&
 					  charmask)*cellsize;
 
@@ -134,6 +150,12 @@ static inline void bit_putcs_unaligned(s
 		dst += (shift_low >= 8) ? s_pitch : s_pitch - 1;
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -192,6 +219,12 @@ static void bit_putcs(struct vc_data *vc
 		image.dx += cnt * vc->vc_font.width;
--
 		while (count--) {
 			chattr = scr_readw(s++);
 			if (chattr != scr_readw(d)) {
@@ -629,6 +634,12 @@ static int newport_scroll(struct vc_data
 				x = 0;
 				y++;
--
 		while (count--) {
 			chattr = scr_readw(s--);
 			if (chattr != scr_readw(d)) {
@@ -664,6 +680,12 @@ static int newport_scroll(struct vc_data
 				x = vc->vc_cols - 1;
 				y--;
--
 	while (count) {
 		count--;
 		*(u8 *)dest = gsc_readb(base);
 		base++;
 		dest++;
+		if (_cur < timeout) {
--
 	while (raw_font->next_font) {
 		raw_font = ((void *)font_start) + (raw_font->next_font);
 
@@ -613,6 +629,12 @@ sti_cook_fonts(struct sti_cooked_rom *co
 		cooked_font = cooked_font->next_font;
 
--
 	while (size--) {
 		*p = *q++;
 		p+=4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (count) {
 		count--;
 		*(u8 *)dest = gsc_readl(base);
 		base += 4;
 		dest++;
+		if (_cur < timeout) {
--
 		while (raw_font->next_font) {
 			BMODE_RELOCATE (raw_font->next_font);
 			raw_font = ((void *)font_start) + raw_font->next_font;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((inreg(dram_ctrl, GC_DCTL_RSV0_STATES) & GC_DCTL_STATES_MSK)) {
 		udelay(GC_DCTL_INIT_WAIT_INTERVAL);
 		if (i++ > GC_DCTL_INIT_WAIT_CNT) {
 			dev_err(par->dev, "VRAM init failed.\n");
 			return -EINVAL;
 		}
--
 	while (total < count) {
 		if (free) {
 			outreg(geo, GDC_GEO_REG_INPUT_FIFO, data[total]);
@@ -40,6 +45,12 @@ static void mb862xxfb_write_fifo(u32 cou
 		} else {
 			free = (u32) inreg(draw, GDC_REG_FIFO_COUNT);
--
-	while (i < height) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (i < height) {
 		memcpy(&cmd[9 + i * step], line, step << 2);
 #ifdef __LITTLE_ENDIAN
 		{
@@ -114,6 +130,12 @@ static void mb86290fb_imageblit1(u32 *cm
 #endif
--
 	while (i < height) {
 		ptr = line;
 		for (j = 0; j < step; j++) {
@@ -153,6 +180,12 @@ static void mb86290fb_imageblit8(u32 *cm
 
 		line += bytes;
--
 	while (i < height) {
 		memcpy(&cmd[3 + i * step], line, step);
 		line += bytes;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (height--) {
 		c = src;
 		p = dst;
@@ -146,6 +151,12 @@ void c2p_iplan2(void *dst, const void *s
 		}
 		src += src_nextline;
--
                 while (height--) {
                         int x;
 
@@ -856,6 +861,12 @@ static void vga_8planes_fillrect(struct
                                 where++;
                         }
--
 				while (height--) {
 					for (x = 0; x < width; x++) {
 						writeb(0, dst);
 						dst++;
 					}
 					dst += line_ofs;
--
 				while (height--) {
 					for (x = 0; x < width; x++) {
 						rmw(dst);
 						dst++;
 					}
 					dst += line_ofs;
--
                 while (height--) {
                         for (x = 0; x < width; x++) {
                                 readb(src);
@@ -983,6 +1021,12 @@ static void vga_8planes_copyarea(struct
                         }
                         src += line_ofs;
--
                 while (height--) {
                         for (x = 0; x < width; x++) {
                                 --src;
@@ -999,6 +1048,12 @@ static void vga_8planes_copyarea(struct
                         }
                         src -= line_ofs;
--
 				while (height--) {
 					for (x = 0; x < width; x++) {
 						readb(src);
@@ -1074,12 +1134,23 @@ static void vga16fb_copyarea(struct fb_i
 					}
 					src += line_ofs;
--
 				while (height--) {
 					for (x = 0; x < width; x++) {
 						dst--;
@@ -1089,6 +1160,12 @@ static void vga16fb_copyarea(struct fb_i
 					}
 					src -= line_ofs;
--
 	while (pos < edid[2]) {
 		u8 len = edid[pos] & 0x1f, type = (edid[pos] >> 5) & 7;
 		pr_debug("Data block %u of %u bytes\n", type, len);
@@ -1018,6 +1023,12 @@ void fb_edid_add_monspecs(unsigned char
 					 edid[pos + i] & 0x80 ? "" : "on-n", idx);
 			}
--
 		while ((this_opt = strsep(&arg, ","))) {
 			if (!*this_opt)
 				continue;
@@ -1582,6 +1587,12 @@ tgafb_setup(char *arg)
 				printk(KERN_ERR
 				       "tgafb: unknown parameter %s\n",
--
 	while(len)
 	{
 		v <<= 8;
@@ -94,6 +99,12 @@ static unsigned long nubus_get_rom(unsig
 			p++;
 		v |= *p++;
--
 	while(len)
 	{
 		do
@@ -114,6 +130,12 @@ static void nubus_rewind(unsigned char *
 		}
 		while(not_useful(p, map));
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while(len)
 	{
 		while(not_useful(p,map))
 			p++;
 		p++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(len)
 	{
 		*t++ = nubus_get_rom(&p, 1, dirent->mask);
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (itor) {
 		if (itor->category == category
 		    && itor->type == type
@@ -310,6 +359,12 @@ nubus_find_device(unsigned short categor
 		    && itor->dr_sw == dr_sw)
 			return itor;
--
 	while (itor) {
 		if (itor->category == category
 		    && itor->type == type)
 			return itor;
 		itor = itor->next;
+		if (_cur < timeout) {
--
 	while (itor) {
 		if (itor->board->slot == slot)
 			return itor;
 		itor = itor->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (dev) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (dev) {
 		seq_printf(m, "%x\t%04x %04x %04x %04x",
 			      dev->board->slot,
 			      dev->category,
@@ -42,6 +47,12 @@ nubus_devices_proc_show(struct seq_file
 			      dev->dr_hw);
--
-	while (*c) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*c) {
 		if (*c == '"')
 			fprintf(f, "\\\"");
 		else
 			fputc(*c, f);
 		c++;
--
 	while (fgets(line, sizeof(line)-1, stdin)) {
 		lino++;
 		if ((c = strchr(line, '\n')))
@@ -94,6 +110,12 @@ main(void)
 			fprintf(stderr, "Line %d: Syntax error in mode %d: %s\n", lino, mode, line);
 			return 1;
--
 	while (ids->id) {
 		if (ids->id == ZORRO_WILDCARD || ids->id == z->id)
 			return ids;
 		ids++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (ids->id) {
 		if (ids->id == ZORRO_WILDCARD || ids->id == z->id)
 			return 1;
 		ids++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (start < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (start < end) {
 		u32 chunk = start>>Z2RAM_CHUNKSHIFT;
 		if (flag)
 			set_bit(chunk, zorro_unused_z2ram);
 		else
 			clear_bit(chunk, zorro_unused_z2ram);
--
-	while (!pvt->branchmap_werrors || !pvt->fsb_error_regs) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!pvt->branchmap_werrors || !pvt->fsb_error_regs) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_5400_ERR, pdev);
 		if (!pdev) {
@@ -759,6 +764,12 @@ static int i5400_get_devices(struct mem_
 			pvt->fsb_error_regs = pdev;
--
-	while ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7300_MCH_ERR,
 				      pdev))) {
 		/* Store device 16 funcs 1 and 2 */
@@ -978,6 +983,12 @@ static int __devinit i7300_get_devices(s
 							pci_dev_get(pdev);
--
 	while (sysfs_attrib) {
 		debugf4("%s() sysfs_attrib = %p\n",__func__, sysfs_attrib);
 		if (sysfs_attrib->grp) {
@@ -829,6 +834,12 @@ static int edac_create_mci_instance_attr
 			break;
 
--
 	while (sysfs_attrib) {
 		debugf4("%s() sysfs_attrib = %p\n",__func__, sysfs_attrib);
 		if (sysfs_attrib->grp) {
@@ -877,6 +893,12 @@ static void edac_remove_mci_instance_att
 		} else
 			break;
--
 	while (table && table->descr) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL, table->descr[0].dev_id, NULL);
 		if (unlikely(!pdev)) {
@@ -1319,6 +1324,12 @@ static void __init i7core_xeon_pci_fixup
 		}
 		pci_dev_put(pdev);
--
 	while (table && table->descr) {
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
@@ -1488,6 +1504,12 @@ static int i7core_get_all_devices(void)
 			} while (pdev);
 		}
 		table++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (table && table->descr) {
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
@@ -1276,6 +1281,12 @@ static int sbridge_get_all_devices(u8 *n
 			} while (pdev);
 		}
 		table++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (count && pos < sel->area_length) {
 		count--;
 		*(buf++) = io_reader(sel, pos++);
 		wrote++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count && pos < sel->area_length) {
 		count--;
 		*(buf++) = readb(mapped + pos++);
 		wrote++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!packet_data_temp_buf) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!packet_data_temp_buf) {
 		packet_data_temp_buf = (unsigned char *)
 			__get_free_pages(GFP_KERNEL, ordernum);
 		if (!packet_data_temp_buf) {
@@ -180,6 +185,12 @@ static int create_packet(void *data, siz
 			invalid_addr_packet_array[idx++] = packet_data_temp_buf;
--
 	while (!done) {
 		if ((temp + rbu_data.packetsize) < end)
 			packet_length = rbu_data.packetsize;
@@ -252,6 +268,12 @@ static int packetize_data(const u8 *data
 
 		pr_debug("%p:%td\n", temp, (end - temp));
--
-	while (!list_empty(ptemp_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(ptemp_list)) {
 		newpacket =
 			list_entry(ptemp_list, struct packet_data, list);
 		pnext_list = ptemp_list->next;
@@ -352,6 +379,12 @@ static void packet_empty_list(void)
 		free_pages((unsigned long) newpacket->data,
--
 	while (1) {
 		if (len == 0)
 			return 0;
@@ -203,6 +208,12 @@ utf16_strncmp(const efi_char16_t *a, con
 		a++;
 		b++;
--
 	while (&efivars->walk_entry->list != &efivars->list) {
 		if (!efi_guidcmp(efivars->walk_entry->var.VendorGuid,
 				 vendor)) {
@@ -753,6 +769,12 @@ static ssize_t efi_pstore_read(u64 *id,
 		}
 		efivars->walk_entry = list_entry(efivars->walk_entry->list.next,
--
 	while (1) {
 		variable_name = kzalloc(variable_name_size, GFP_KERNEL);
 		if (!variable_name) {
@@ -1107,6 +1134,12 @@ static void efivar_update_sysfs_entries(
 						  variable_name_size,
 						  variable_name, &vendor);
--
 	while ((i < num) && (data - buf + sizeof(struct dmi_header)) <= len) {
 		const struct dmi_header *dm = (const struct dmi_header *)data;
 
@@ -95,6 +100,12 @@ static void dmi_table(u8 *buf, int len,
 			decode(dm, private_data);
 		data += 2;
--
 	while (*mode) {
 		if (rdev->constraints->valid_modes_mask & *mode)
 			return 0;
 		*mode /= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (prop) {
 		struct property *next = prop->next;
 		kfree(prop->name);
@@ -143,6 +148,12 @@ static void of_node_release(struct kref
 			prop = node->deadprops;
 			node->deadprops = NULL;
--
 	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
 		int match = 1;
 		if (matches->name[0])
@@ -538,6 +554,12 @@ const struct of_device_id *of_match_node
 		if (match)
 			return matches;
--
 	while (*next) {
 		if (strcmp(prop->name, (*next)->name) == 0) {
 			/* duplicate ! don't insert it */
@@ -958,6 +985,12 @@ int prom_add_property(struct device_node
 			return -1;
 		}
--
-	while(tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(tail) {
 		tail->next = of_pdt_build_one_prop(node, tail->name,
 					    NULL, NULL, 0);
 		tail = tail->next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (*compat) {
 		tmp = of_fdt_is_compatible(blob, node, *compat);
 		if (tmp && (score == 0 || (tmp < score)))
 			score = tmp;
 		compat++;
+		if (_cur < timeout) {
--
 		while (*p1) {
 			if ((*p1) == '@')
 				pa = p1;
 			if ((*p1) == '/')
 				ps = p1 + 1;
 			p1++;
--
 	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
 		u64 base, size;
 
@@ -659,6 +686,12 @@ int __init early_init_dt_scan_memory(uns
 		    (unsigned long long)size);
 
--
 	while (dn) {
 		if (of_address_to_resource(dn, 0, &res))
 			continue;
 		if (res.start == base_address)
 			return dn;
 		dn = of_find_matching_node(dn, matches);
--
 		while (imaplen > (addrsize + intsize + 1) && !match) {
 			/* Compare specifiers */
 			match = 1;
@@ -242,6 +247,12 @@ int of_irq_map_raw(struct device_node *p
 			imaplen -= newaddrsize + newintsize;
 
--
 	while (num--) {
 		list_add_tail(&cl->node, &clocks);
 		cl++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cnt < sprom_size_words) {
 		memcpy(tmp, dump, 4);
 		dump += 4;
@@ -58,6 +63,12 @@ static int hex2sprom(u16 *sprom, const c
 		if (err)
 			return err;
--
 	while (tuple) {
 		switch (tuple->code) {
 		case 0x22: /* extended function */
@@ -583,6 +588,12 @@ int ssb_sdio_get_invariants(struct ssb_b
 			break;
 		}
--
 		while (count) {
 			*buf = __raw_readb(addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le32)__raw_readl(addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writeb(*buf, addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writel((__force u32)(*buf), addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = __raw_readb(addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			*buf = (__force __le16)__raw_readw(addr + 2);
 			buf++;
 			count -= 4;
--
 		while (count) {
 			__raw_writeb(*buf, addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			__raw_writew((__force u16)(*buf), addr + 2);
 			buf++;
 			count -= 4;
--
 	while (j < 7*cmd->cmd_num) {
 		for (i = 0; i < 7; i++)
 			report->field[0]->value[i] = cmd->cmd[j++];
 
 		usbhid_submit_report(hid, report, USB_DIR_OUT);
+		if (_cur < timeout) {
--
 		while (list != &report_enum->report_list) {
 			report = (struct hid_report *) list;
 			tab(2, f);
@@ -561,6 +566,12 @@ void hid_dump_device(struct hid_device *
 				hid_dump_field(report->field[k], 6, f);
 			}
--
 		while (list->head != list->tail &&
 		       retval + event_size <= count) {
 			if ((list->flags & HIDDEV_FLAG_UREF) == 0) {
@@ -418,6 +423,12 @@ static ssize_t hiddev_read(struct file *
 				}
 			}
--
 	while (ret) {
 		err |= ret;
 		if (test_bit(HID_CTRL_RUNNING, &usbhid->iofl))
@@ -720,6 +725,12 @@ void usbhid_init_reports(struct hid_devi
 		if (test_bit(HID_OUT_RUNNING, &usbhid->iofl))
 			usb_kill_urb(usbhid->urbout);
--
-	while (wdata->head != wdata->tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (wdata->head != wdata->tail) {
 		spin_unlock_irqrestore(&wdata->qlock, flags);
 		wiimote_hid_send(wdata->hdev, wdata->outq[wdata->tail].data,
 						wdata->outq[wdata->tail].size);
 		spin_lock_irqsave(&wdata->qlock, flags);
 
--
-	while (n--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (n--) {
 		if (*array++ == value)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (count) {
 		struct sk_buff *skb = data->rx_skb[queue];
 		struct { __u8 type; int expect; } *scb;
@@ -159,6 +164,12 @@ static int bpa10x_recv(struct hci_dev *h
 		}
 
--
 	while (count) {
 		if (bcsp->rx_count) {
 			if (*ptr == 0xc0) {
@@ -660,6 +665,12 @@ static int bcsp_recv(struct hci_uart *hu
 			}
 			break;
--
 	while (count) {
 		size = min_t(uint, count, BULK_SIZE);
 		pipe = usb_sndbulkpipe(udev, 0x02);
@@ -193,6 +198,12 @@ static int ath3k_load_firmware(struct us
 
 		sent  += size;
--
 	while (count) {
 		size = min_t(uint, count, BULK_SIZE);
 		pipe = usb_sndbulkpipe(udev, 0x02);
@@ -269,6 +285,12 @@ static int ath3k_load_fwfile(struct usb_
 		}
 		sent  += size;
--
 	while (actual < len) {
 		/* Transmit next byte */
 		bt3c_put(iobase, buf[actual]);
 		actual++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (size < avail) {
 		size++;
 		info->hdev->stat.byte_rx++;
@@ -329,6 +345,12 @@ static void bt3c_receive(bt3c_info_t *in
 
 		}
--
 	while (count) {
 		if (ptr[0] != 'S') {
 			BT_ERR("Bad address in firmware");
@@ -536,6 +563,12 @@ static int bt3c_load_firmware(bt3c_info_
 
 		ptr   += (size * 2) + 6;
--
 	while (tuple) {
 		BT_DBG("code 0x%x size %d", tuple->code, tuple->size);
 		tuple = tuple->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (n < len) {
 
 		if (i == 16) {
@@ -361,6 +366,12 @@ static int bluecard_read(unsigned int io
 		n++;
 		i++;
--
 	while ((skb = skb_dequeue(&data->pending_q))) {
 		urb = ((struct bfusb_data_scb *) skb->cb)->urb;
 		usb_kill_urb(urb);
 		skb_queue_tail(&data->completed_q, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((urb = bfusb_get_completed(data)))
@@ -362,6 +373,11 @@ static void bfusb_rx_complete(struct urb
 
 	skb_put(skb, count);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
--
 	while (count) {
 		hdr = buf[0] | (buf[1] << 8);
 
@@ -385,6 +401,12 @@ static void bfusb_rx_complete(struct urb
 
 		count -= len;
--
 	while (count) {
 		size = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE);
 
@@ -523,6 +550,12 @@ static int bfusb_send_frame(struct sk_bu
 
 		sent  += size;
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count) {
 		size = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE + 3);
 
 		memcpy(buf, firmware + sent, size);
@@ -602,6 +640,12 @@ static int bfusb_load_firmware(struct bf
 
--
 		while (wait_remove_device == devfreq) {
 			mutex_unlock(&devfreq_list_lock);
 			schedule();
 			mutex_lock(&devfreq_list_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		path = rb_entry(n, struct ipoib_path, rb_node);
 
 		ret = memcmp(gid, path->pathrec.dgid.raw,
@@ -227,6 +232,12 @@ static struct ipoib_path *__path_find(st
 			n = n->rb_right;
--
-	while (*n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*n) {
 		pn = *n;
 		tpath = rb_entry(pn, struct ipoib_path, rb_node);
 
@@ -252,6 +268,12 @@ static int __path_add(struct net_device
 			n = &pn->rb_right;
--
 	while ((skb = __skb_dequeue(&skqueue))) {
 		skb->dev = dev;
 		if (dev_queue_xmit(skb))
 			ipoib_warn(priv, "dev_queue_xmit failed "
 				   "to requeue packet\n");
+			if (_cur < timeout) {
--
 	while ((skb = __skb_dequeue(&neigh->queue))) {
 		++dev->stats.tx_dropped;
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&priv->cm.passive_ids)) {
 		p = list_entry(priv->cm.passive_ids.next, typeof(*p), list);
 		list_move(&p->list, &priv->cm.rx_error_list);
@@ -913,6 +918,12 @@ void ipoib_cm_dev_stop(struct net_device
 		if (ret)
 			ipoib_warn(priv, "unable to move qp to error state: %d\n", ret);
--
 	while ((skb = __skb_dequeue(&skqueue))) {
 		skb->dev = p->dev;
 		if (dev_queue_xmit(skb))
 			ipoib_warn(priv, "dev_queue_xmit failed "
 				   "to requeue packet\n");
+			if (_cur < timeout) {
--
 	while (!list_empty(&priv->cm.start_list)) {
 		p = list_entry(priv->cm.start_list.next, typeof(*p), list);
 		list_del_init(&p->list);
@@ -1331,6 +1358,12 @@ static void ipoib_cm_tx_start(struct wor
 			list_del(&p->list);
 			kfree(p);
--
 	while (!list_empty(&priv->cm.reap_list)) {
 		p = list_entry(priv->cm.reap_list.next, typeof(*p), list);
 		list_del(&p->list);
@@ -1356,6 +1394,12 @@ static void ipoib_cm_tx_reap(struct work
 		ipoib_cm_tx_destroy(p);
 		netif_tx_lock_bh(dev);
--
 	while ((skb = skb_dequeue(&priv->cm.skb_queue))) {
 		spin_unlock_irqrestore(&priv->lock, flags);
 		netif_tx_unlock_bh(dev);
@@ -1388,6 +1437,12 @@ static void ipoib_cm_skb_reap(struct wor
 
 		netif_tx_lock_bh(dev);
--
 	while (!skb_queue_empty(&mcast->pkt_queue)) {
 		++tx_dropped;
 		dev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		struct ipoib_mcast *mcast;
 		int ret;
 
@@ -146,6 +162,12 @@ static struct ipoib_mcast *__ipoib_mcast
 			n = n->rb_right;
--
 	while (*n) {
 		struct ipoib_mcast *tmcast;
 		int ret;
@@ -171,6 +198,12 @@ static int __ipoib_mcast_add(struct net_
 			n = &pn->rb_right;
 		else
--
 	while (!skb_queue_empty(&mcast->pkt_queue)) {
 		struct sk_buff *skb = skb_dequeue(&mcast->pkt_queue);
 
@@ -280,6 +318,12 @@ static int ipoib_mcast_join_finish(struc
 			ipoib_warn(priv, "dev_queue_xmit failed to requeue packet\n");
 
--
 		while (!skb_queue_empty(&mcast->pkt_queue)) {
 			++dev->stats.tx_dropped;
 			dev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (n--) {
 		if (ipoib_mcast_iter_next(iter)) {
 			kfree(iter);
 			return NULL;
 		}
+		if (_cur < timeout) {
--
 	while (n--) {
 		if (ipoib_path_iter_next(iter)) {
 			kfree(iter);
 			return NULL;
 		}
+		if (_cur < timeout) {
--
 	while (priv->tx_head != priv->tx_tail || recvs_pending(dev)) {
 		if (time_after(jiffies, begin + 5 * HZ)) {
 			ipoib_warn(priv, "timing out; %d sends %d receives not completed\n",
@@ -866,6 +871,12 @@ int ipoib_ib_dev_stop(struct net_device
 		ipoib_drain_cq(dev);
 
--
 	/* Send data-out PDUs while there's still unsolicited data to send */
-	while (iscsi_task_has_unsol_data(task)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (iscsi_task_has_unsol_data(task)) {
 		iscsi_prep_data_out_pdu(task, r2t, &hdr);
 		iser_dbg("Sending data-out: itt 0x%x, data count %d\n",
 			   hdr.itt, r2t->data_count);
@@ -231,6 +236,12 @@ iscsi_iser_task_xmit_unsol_data(struct i
 		r2t->sent += r2t->data_count;
--
 	while (start < end) {
 		if (avail) {
 			unsigned long dma;
@@ -1719,6 +1724,12 @@ void ipath_chg_pioavailkernel(struct ipa
 			__clear_bit(start, dd->ipath_pioavailkernel);
 		}
--
 	while (clock_cycles_left--) {
 		scl_out(dd, i2c_line_high);
 
@@ -396,6 +401,12 @@ static int eeprom_reset(struct ipath_dev
 		}
 
--
-		while (i2c_startcmd(dd, icd->eeprom_dev | READ_CMD)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i2c_startcmd(dd, icd->eeprom_dev | READ_CMD)) {
 			stop_cmd(dd);
 			if (!--max_wait_time) {
 				ipath_dbg("Did not get successful read to "
 					  "complete write\n");
 				goto failed_write;
--
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		int ret;
 
 		mcast = rb_entry(n, struct ipath_mcast, rb_node);
@@ -142,6 +147,12 @@ struct ipath_mcast *ipath_mcast_find(uni
 			spin_unlock_irqrestore(&mcast_lock, flags);
--
 	while (*n) {
 		struct ipath_mcast *tmcast;
 		struct ipath_mcast_qp *p;
@@ -205,6 +221,12 @@ static int ipath_mcast_add(struct ipath_
 		list_add_tail_rcu(&mqp->list, &tmcast->qp_list);
 		ret = EEXIST;
--
 	while (1) {
 		if (n == NULL) {
 			spin_unlock_irq(&mcast_lock);
@@ -312,6 +339,12 @@ int ipath_multicast_detach(struct ib_qp
 			n = n->rb_right;
 		else
--
 		while (tail != head) {
 			wc.wr_id = get_rwqe_ptr(&qp->r_rq, tail)->wr_id;
 			if (++tail >= qp->r_rq.size)
 				tail = 0;
 			ipath_cq_enter(to_icq(qp->ibqp.recv_cq), &wc, 1);
+			if (_cur < timeout) {
--
 		while (tail != head) {
 			struct ipath_rwqe *wqe;
 			int i;
@@ -295,6 +300,12 @@ int ipath_modify_srq(struct ib_srq *ibsr
 			p = (struct ipath_rwqe *)((char *) p + sz);
 			if (++tail >= srq->rq.size)
--
 	while (reg_addr < reg_end) {
 		u64 data = readq(reg_addr);
 		if (copy_to_user(uaddr, &data, sizeof(u64))) {
@@ -155,6 +160,12 @@ static int ipath_read_umem64(struct ipat
 		}
 		reg_addr++;
--
 	while (reg_addr < reg_end) {
 		u64 data;
 		if (copy_from_user(&data, uaddr, sizeof(data))) {
@@ -194,6 +210,12 @@ static int ipath_write_umem64(struct ipa
 
 		reg_addr++;
--
 	while (reg_addr < reg_end) {
 		u32 data = readl(reg_addr);
 		if (copy_to_user(uaddr, &data, sizeof(data))) {
@@ -233,6 +260,12 @@ static int ipath_read_umem32(struct ipat
 		reg_addr++;
 		uaddr += sizeof(u32);
--
 	while (reg_addr < reg_end) {
 		u32 data;
 		if (copy_from_user(&data, uaddr, sizeof(data))) {
@@ -272,6 +310,12 @@ static int ipath_write_umem32(struct ipa
 
 		reg_addr++;
--
 	while (i) {
 		i--;
 		kfree(mr->mr.map[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (i) {
 		i--;
 		kfree(mr->mr.map[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (off >= mr->map[m]->segs[n].length) {
 		off -= mr->map[m]->segs[n].length;
 		n++;
@@ -171,6 +176,12 @@ int ipath_lkey_ok(struct ipath_qp *qp, s
 			m++;
 			n = 0;
--
 	while (off >= mr->map[m]->segs[n].length) {
 		off -= mr->map[m]->segs[n].length;
 		n++;
@@ -253,6 +269,12 @@ int ipath_rkey_ok(struct ipath_qp *qp, s
 			m++;
 			n = 0;
--
 	while (dd->ipath_sdma_descq_head != dmahead) {
 		if (txp && txp->flags & IPATH_SDMA_TXREQ_F_FREEDESC &&
 		    dd->ipath_sdma_descq_head == start_idx) {
@@ -147,6 +152,12 @@ int ipath_sdma_make_progress(struct ipat
 			}
 		}
--
-	while (tail != dd->ipath_sdma_descq_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tail != dd->ipath_sdma_descq_tail) {
 		if (!tail)
 			tail = dd->ipath_sdma_descq_cnt - 1;
 		else
 			tail--;
 		unmap_desc(dd, tail);
--
 	while (j) {
 		struct qib_sge *sge = --j ? &ss->sg_list[j - 1] : &ss->sge;
 
 		atomic_dec(&sge->mr->refcount);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-		while (qp->r_sge.num_sge) {
-			atomic_dec(&qp->r_sge.sge.mr->refcount);
-			if (--qp->r_sge.num_sge)
+	if (release) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
--
+			while (qp->r_sge.num_sge) {
+				atomic_dec(&qp->r_sge.sge.mr->refcount);
+				if (--qp->r_sge.num_sge)
 				qp->r_sge.sge = *qp->r_sge.sg_list++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!(piobuf = get_7220_link_buf(ppd, &pnum))) {
 		if (i++ > 5)
 			return;
 		udelay(2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		int ret;
 
 		mcast = rb_entry(n, struct qib_mcast, rb_node);
@@ -132,6 +137,12 @@ struct qib_mcast *qib_mcast_find(struct
 			spin_unlock_irqrestore(&ibp->lock, flags);
--
 	while (*n) {
 		struct qib_mcast *tmcast;
 		struct qib_mcast_qp *p;
@@ -194,6 +210,12 @@ static int qib_mcast_add(struct qib_ibde
 		list_add_tail_rcu(&mqp->list, &tmcast->qp_list);
 		ret = EEXIST;
--
 	while (1) {
 		if (n == NULL) {
 			spin_unlock_irq(&ibp->lock);
@@ -316,6 +343,12 @@ int qib_multicast_detach(struct ib_qp *i
 			n = n->rb_right;
 		else
--
 		while (off >= mr->map[m]->segs[n].length) {
 			off -= mr->map[m]->segs[n].length;
 			n++;
@@ -197,6 +202,12 @@ int qib_lkey_ok(struct qib_lkey_table *r
 				m++;
 				n = 0;
--
 		while (off >= mr->map[m]->segs[n].length) {
 			off -= mr->map[m]->segs[n].length;
 			n++;
@@ -291,6 +307,12 @@ int qib_rkey_ok(struct qib_qp *qp, struc
 				m++;
 				n = 0;
--
 	while (qp->r_sge.num_sge) {
 		atomic_dec(&qp->r_sge.sge.mr->refcount);
 		if (--qp->r_sge.num_sge)
 			qp->r_sge.sge = *qp->r_sge.sg_list++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (qp->r_sge.num_sge) {
 		atomic_dec(&qp->r_sge.sge.mr->refcount);
 		if (--qp->r_sge.num_sge)
 			qp->r_sge.sge = *qp->r_sge.sg_list++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (cnt < len) {
 		unsigned in_page;
 		int wlen = len - cnt;
@@ -113,6 +118,12 @@ static int qsfp_read(struct qib_pportdat
 		}
 		addr += wlen;
--
 	while (cnt < len) {
 		unsigned in_page;
 		int wlen = len - cnt;
@@ -217,6 +233,12 @@ static int qib_qsfp_write(struct qib_ppo
 		}
 		addr += wlen;
--
 	while (first < next) {
 		ret = qsfp_read(ppd, first, &bval, 1);
 		if (ret < 0)
 			goto bail;
 		cks += bval;
 		++first;
--
 		while (tail != head) {
 			struct qib_rwqe *wqe;
 			int i;
@@ -291,6 +296,12 @@ int qib_modify_srq(struct ib_srq *ibsrq,
 			p = (struct qib_rwqe *)((char *) p + sz);
 			if (++tail >= srq->rq.size)
--
 	while (clock_cycles_left--) {
 		scl_out(dd, 0);
 		scl_out(dd, 1);
 		/* Note if SDA is high, but keep clocking to sync slave */
 		was_high |= sda_in(dd, 0);
+		if (_cur < timeout) {
--
 		while (qib_twsi_wr(dd, dev | READ_CMD, QIB_TWSI_START)) {
 			stop_cmd(dd);
 			if (!--max_wait_time)
 				goto failed_write;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
-			while (idx != txp->next_descq_idx) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+		while (idx != txp->next_descq_idx) {
 				unmap_desc(ppd, idx);
 				if (++idx == ppd->sdma_descq_cnt)
 					idx = 0;
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (ppd->sdma_descq_head != hwhead) {
 		/* if desc is part of this txp, unmap if needed */
 		if (txp && (txp->flags & QIB_SDMA_TXREQ_F_FREEDESC) &&
@@ -400,6 +416,12 @@ int qib_sdma_make_progress(struct qib_pp
 			}
 		}
--
 	while (client_pool) {
 		dc = client_pool;
 		client_pool = dc->next;
 		kfree(dc);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (reg_addr < reg_end) {
 		u64 data = readq(reg_addr);
 
@@ -358,6 +374,12 @@ static int qib_read_umem64(struct qib_de
 		}
 		reg_addr++;
--
 	while (reg_addr < reg_end) {
 		u64 data;
 		if (copy_from_user(&data, uaddr, sizeof(data))) {
@@ -403,6 +430,12 @@ static int qib_write_umem64(struct qib_d
 
 		reg_addr++;
--
 	while (reg_addr < reg_end) {
 		u32 data = readl(reg_addr);
 
@@ -448,6 +486,12 @@ static int qib_read_umem32(struct qib_de
 		reg_addr++;
 		uaddr += sizeof(u32);
--
 	while (reg_addr < reg_end) {
 		u32 data;
 
@@ -493,6 +542,12 @@ static int qib_write_umem32(struct qib_d
 
 		reg_addr++;
--
 	while (olp) {
 		/* Pop one observer, let go of lock */
 		dd->diag_observer_list = olp->next;
@@ -726,6 +786,12 @@ static void qib_unregister_observers(str
 		/* try again. */
 		spin_lock_irqsave(&dd->qib_diag_trans_lock, flags);
--
 		while (qp->r_sge.num_sge) {
 			atomic_dec(&qp->r_sge.sge.mr->refcount);
 			if (--qp->r_sge.num_sge)
 				qp->r_sge.sge = *qp->r_sge.sg_list++;
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (start < end) {
 		if (avail) {
 			unsigned long dma;
@@ -428,6 +433,12 @@ void qib_chg_pioavailkernel(struct qib_d
 			__clear_bit(start, dd->pioavailkernel);
 		}
--
 	while (errs && msp && msp->mask) {
 		multi = (msp->mask & (msp->mask - 1));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (errs & msp->mask) {
 			these = (errs & msp->mask);
 			lmask = (these & (these - 1)) ^ these;
@@ -1324,16 +1334,39 @@ static void err_decode(char *msg, size_t
 				/* More than one bit this mask */
 				int idx = -1;
--
 				while (lmask & msp->mask) {
 					++idx;
 					lmask >>= 1;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
--
 	while (!(piobuf = qib_7322_getsendbuf(ppd, pbc, &pnum))) {
 		if (i++ > 15)
 			return;
 		udelay(2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (chan_done &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (chan_done &&
 	       !time_after64(get_jiffies_64(),
 			tstart + msecs_to_jiffies(500))) {
 		msleep(20);
@@ -7631,6 +7680,12 @@ static int serdes_7322_init_new(struct q
 			    (~chan_done & (1 << chan)) == 0)
--
-		while (qp->s_rdma_read_sge.num_sge) {
-			atomic_dec(&qp->s_rdma_read_sge.sge.mr->refcount);
-			if (--qp->s_rdma_read_sge.num_sge)
-				qp->s_rdma_read_sge.sge =
-					*qp->s_rdma_read_sge.sg_list++;
+	if (test_and_clear_bit(QIB_R_REWIND_SGE, &qp->r_aflags)) {
--
+			while (qp->s_rdma_read_sge.num_sge) {
+				atomic_dec(&qp->s_rdma_read_sge.sge.mr->refcount);
+				if (--qp->s_rdma_read_sge.num_sge)
+			qp->s_rdma_read_sge.sge =
+			*qp->s_rdma_read_sge.sg_list++;
+			if (_cur < timeout) {
--
 	while (qp->r_sge.num_sge) {
 		atomic_dec(&qp->r_sge.sge.mr->refcount);
 		if (--qp->r_sge.num_sge)
 			qp->r_sge.sge = *qp->r_sge.sg_list++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (qp->s_last != qp->s_head) {
 			struct qib_swqe *wqe = get_swqe_ptr(qp, qp->s_last);
 			unsigned i;
@@ -435,6 +463,12 @@ static void clear_mr_refs(struct qib_qp
 				atomic_dec(&to_iah(wqe->wr.wr.ud.ah)->refcount);
 			if (++qp->s_last >= qp->s_size)
--
 		while (tail != head) {
 			wc.wr_id = get_rwqe_ptr(&qp->r_rq, tail)->wr_id;
 			if (++tail >= qp->r_rq.size)
 				tail = 0;
 			qib_cq_enter(to_icq(qp->ibqp.recv_cq), &wc, 1);
+			if (_cur < timeout) {
--
 		while (priv != be16_to_cpu(*q->shared)) {
 			msg = (struct c2wr_ce *)
 				(q->msg_pool.host + priv * q->msg_size);
@@ -101,6 +106,12 @@ void c2_cq_clean(struct c2_dev *c2dev, s
 				msg->qp_user_context = (u64) 0;
 			}
--
 	while (pbl_depth) {
 		count = min(pbe_count, pbl_depth);
 		wr->addrs_length = cpu_to_be32(count);
@@ -142,6 +147,12 @@ send_pbl_messages(struct c2_dev *c2dev,
 		}
 		pbl_depth -= count;
--
-	while (root) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (root) {
 		next = root->next;
 		dma_free_coherent(&c2dev->pcidev->dev, PAGE_SIZE, root,
 				  dma_unmap_addr(root, mapping));
 		root = next;
+		if (_cur < timeout) {
--
 	while (head) {
 		mqsp = head->head;
 		if (mqsp != 0xFFFF) {
@@ -107,6 +123,12 @@ __be16 *c2_alloc_mqsp(struct c2_dev *c2d
 				return NULL;
 		} else
--
 	while (wqe_count--) {
 		BUG_ON(c2_mq_empty(q));
 		*q->shared = cpu_to_be16((be16_to_cpu(*q->shared)+1) % q->q_size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (offset < optionsize) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset < optionsize) {
 		all_options = (union all_known_options *)(optionsloc + offset);
 		switch (all_options->as_base.optionnum) {
 		case OPTION_NUMBER_END:
@@ -1587,6 +1592,12 @@ static int process_options(struct nes_cm
 			break;
--
 	while (nesvnic->nic.rq_head != nesvnic->nic.rq_tail) {
 		rx_skb = nesvnic->nic.rx_skb[nesvnic->nic.rq_tail];
 		cb = (struct nes_rskb_cb *)&rx_skb->cb[0];
@@ -1942,9 +1947,20 @@ void nes_destroy_nic_qp(struct nes_vnic
 
 		dev_kfree_skb(nesvnic->nic.rx_skb[nesvnic->nic.rq_tail++]);
--
 	while (nesvnic->nic.sq_head != nesvnic->nic.sq_tail) {
 		nic_sqe = &nesvnic->nic.sq_vbase[nesvnic->nic.sq_tail];
 		wqe_fragment_index = 1;
@@ -1995,6 +2011,12 @@ void nes_destroy_nic_qp(struct nes_vnic
 
 		nesvnic->nic.sq_tail = (nesvnic->nic.sq_tail + 1)
--
 	while (1) {
 		rc = get_fpdu_info(nesdev, nesqp, &fpdu_info);
 		if (fpdu_info == NULL)
@@ -475,6 +480,12 @@ static int forward_fpdus(struct nes_vnic
 
 		atomic_set(&cqp_request->refcount, 1);
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		wait_event_interruptible(nesvnic->mgt_wait_queue,
 					 skb_queue_len(&nesvnic->mgt_skb_list) || kthread_should_stop());
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while ((skb_queue_len(&nesvnic->mgt_skb_list)) && !kthread_should_stop()) {
 			skb = skb_dequeue(&nesvnic->mgt_skb_list);
 			cb = (struct nes_rskb_cb *)&skb->cb[0];
@@ -591,15 +612,38 @@ static int mgt_thread(void *context)
 			cb->busaddr = pci_map_single(nesvnic->nesdev->pcidev, cb->data_start,
 						     nesvnic->max_frame_size, PCI_DMA_TODEVICE);
--
 	while (skb_queue_len(&nesvnic->mgt_skb_list)) {
 		skb = skb_dequeue(&nesvnic->mgt_skb_list);
 		cb = (struct nes_rskb_cb *)&skb->cb[0];
 		nes_rem_ref_cm_node(cb->nesqp->cm_node);
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
--
 	while (skb_queue_len(&nesqp->pau_list)) {
 		skb = skb_dequeue(&nesqp->pau_list);
 		nes_mgt_free_skb(nesdev, skb, PCI_DMA_TODEVICE);
 		nes_rem_ref_cm_node(nesqp->cm_node);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (mgtvnic->mgt.rq_head != mgtvnic->mgt.rq_tail) {
 			rx_skb = mgtvnic->mgt.rx_skb[mgtvnic->mgt.rq_tail];
 			nes_mgt_free_skb(nesdev, rx_skb, PCI_DMA_FROMDEVICE);
 			mgtvnic->mgt.rq_tail++;
 			mgtvnic->mgt.rq_tail &= (mgtvnic->mgt.rq_size - 1);
+			if (_cur < timeout) {
--
 	while (le32_to_cpu(nescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_OPCODE_IDX]) & NES_CQE_VALID) {
 		rmb();
 		lo = le32_to_cpu(nescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_COMP_COMP_CTX_LOW_IDX]);
@@ -1444,6 +1449,12 @@ static void nes_clean_cq(struct nes_qp *
 
 		if (++cq_head >= nescq->hw_cq.cq_size)
--
 	while (wqe_count) {
 		counter = min(wqe_count, ((u32)255));
 		wqe_count -= counter;
 		nes_write32(nesdev->regs + NES_WQE_ALLOC,
 				(counter << 24) | 0x00800000 | nesqp->hwqp.qp_id);
+		if (_cur < timeout) {
--
 	while (wqe_count) {
 		counter = min(wqe_count, ((u32)255));
 		wqe_count -= counter;
 		nes_write32(nesdev->regs+NES_WQE_ALLOC, (counter<<24) | nesqp->hwqp.qp_id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((skb = skb_dequeue(&rxq))) {
 		ep = *((void **) (skb->cb));
 		tdev = *((struct t3cdev **) (skb->cb + sizeof(void *)));
@@ -2188,6 +2193,12 @@ static void process_work(struct work_str
 		 * ep was referenced in sched(), and is freed here.
 		 */
--
-	while (pbl_start < rdev_p->rnic_info.pbl_top) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pbl_start < rdev_p->rnic_info.pbl_top) {
 		pbl_chunk = min(rdev_p->rnic_info.pbl_top - pbl_start + 1,
 				pbl_chunk);
 		if (gen_pool_add(rdev_p->pbl_pool, pbl_start, pbl_chunk, -1)) {
@@ -295,6 +300,12 @@ int cxio_hal_pblpool_create(struct cxio_
 			     __func__, pbl_start, pbl_chunk);
--
-		while (!CQ_VLD_ENTRY(rptr, cq->size_log2, cqe)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!CQ_VLD_ENTRY(rptr, cq->size_log2, cqe)) {
 			udelay(1);
 			if (i++ > 1000000) {
 				printk(KERN_ERR "%s: stalled rnic\n",
 				       rdev_p->dev_name);
 				return -EIO;
--
 	while (ptr++ != wq->rq_wptr) {
 		insert_recv_cqe(wq, cq);
 		flushed++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (ptr != wq->sq_wptr) {
 		sqp->signaled = 0;
 		insert_sq_cqe(wq, cq, sqp);
 		ptr++;
 		sqp = wq->sq + Q_PTR2IDX(ptr, wq->sq_size_log2);
 		flushed++;
--
-	while (cqe) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cqe) {
 		PDBG("%s flushing hwcq rptr 0x%x to swcq wptr 0x%x\n",
 		     __func__, cq->rptr, cq->sw_wptr);
 		swcqe = cq->sw_queue + Q_PTR2IDX(cq->sw_wptr, cq->size_log2);
@@ -440,6 +478,12 @@ void cxio_flush_hw_cq(struct t3_cq *cq)
 		cq->sw_wptr++;
--
 	while (!Q_EMPTY(ptr, cq->sw_wptr)) {
 		cqe = cq->sw_queue + (Q_PTR2IDX(ptr, cq->size_log2));
 		if ((SQ_TYPE(*cqe) ||
@@ -475,6 +524,12 @@ void cxio_count_scqes(struct t3_cq *cq,
 		    (CQE_QPID(*cqe) == wq->qpid))
 			(*count)++;
--
 	while (!Q_EMPTY(ptr, cq->sw_wptr)) {
 		cqe = cq->sw_queue + (Q_PTR2IDX(ptr, cq->size_log2));
 		if (RQ_TYPE(*cqe) && (CQE_OPCODE(*cqe) != T3_READ_RESP) &&
 		    (CQE_QPID(*cqe) == wq->qpid) && cqe_completes_wr(cqe, wq))
 			(*count)++;
 		ptr++;
--
 	while (Q_PTR2IDX(rptr, wq->sq_size_log2) != wptr) {
 		wq->oldest_read = wq->sq + Q_PTR2IDX(rptr, wq->sq_size_log2);
 
 		if (wq->oldest_read->opcode == T3_READ_REQ)
 			return;
 		rptr++;
--
 		while (rem) {
 			if (dstp == (u8 *)&sq->queue[sq->size])
 				dstp = (u8 *)sq->queue;
@@ -312,6 +317,12 @@ static int build_immd(struct t4_sq *sq,
 			dstp += len;
 			srcp += len;
--
 	while (rem) {
 		*p = 0;
 		rem -= sizeof *p;
 		if (++p == (__be64 *)&sq->queue[sq->size])
 			p = (__be64 *)sq->queue;
+			if (_cur < timeout) {
--
 	while (pbl_start < pbl_top) {
 		pbl_chunk = min(pbl_top - pbl_start + 1, pbl_chunk);
 		if (gen_pool_add(rdev->pbl_pool, pbl_start, pbl_chunk, -1)) {
@@ -354,6 +359,12 @@ int c4iw_pblpool_create(struct c4iw_rdev
 			     __func__, pbl_start, pbl_chunk);
 			pbl_start += pbl_chunk;
--
 	while (rqt_start < rqt_top) {
 		rqt_chunk = min(rqt_top - rqt_start + 1, rqt_chunk);
 		if (gen_pool_add(rdev->rqt_pool, rqt_start, rqt_chunk, -1)) {
@@ -415,6 +431,12 @@ int c4iw_rqtpool_create(struct c4iw_rdev
 			     __func__, rqt_start, rqt_chunk);
 			rqt_start += rqt_chunk;
--
 	while (start < top) {
 		chunk = min(top - start + 1, chunk);
 		if (gen_pool_add(rdev->ocqp_pool, start, chunk, -1)) {
@@ -471,6 +498,12 @@ int c4iw_ocqp_pool_create(struct c4iw_rd
 			     __func__, start, chunk);
 			start += chunk;
--
 	while (in_use--) {
 		insert_recv_cqe(wq, cq);
 		flushed++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (in_use--) {
 		swsqe->signaled = 0;
 		insert_sq_cqe(wq, cq, swsqe);
@@ -239,6 +255,12 @@ int c4iw_flush_sq(struct t4_wq *wq, stru
 		if (swsqe == (wq->sq.sw_sq + wq->sq.size))
 			swsqe = wq->sq.sw_sq;
--
-	while (!ret) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!ret) {
 		PDBG("%s flushing hwcq cidx 0x%x swcq pidx 0x%x\n",
 		     __func__, cq->cidx, cq->sw_pidx);
 		swcqe = &cq->sw_queue[cq->sw_pidx];
@@ -262,6 +289,12 @@ void c4iw_flush_hw_cq(struct t4_cq *cq)
 		t4_swcq_produce(cq);
--
 	while (ptr != cq->sw_pidx) {
 		cqe = &cq->sw_queue[ptr];
 		if ((SQ_TYPE(cqe) || ((CQE_OPCODE(cqe) == FW_RI_READ_RESP) &&
@@ -296,6 +334,12 @@ void c4iw_count_scqes(struct t4_cq *cq,
 			(*count)++;
 		if (++ptr == cq->size)
--
 	while (ptr != cq->sw_pidx) {
 		cqe = &cq->sw_queue[ptr];
 		if (RQ_TYPE(cqe) && (CQE_OPCODE(cqe) != FW_RI_READ_RESP) &&
@@ -315,6 +364,12 @@ void c4iw_count_rcqes(struct t4_cq *cq,
 			(*count)++;
 		if (++ptr == cq->size)
--
 	while (rptr != wq->sq.pidx) {
 		wq->sq.oldest_read = &wq->sq.sw_sq[rptr];
 
@@ -379,6 +439,12 @@ static void advance_oldest_read(struct t
 			return;
 		if (++rptr == wq->sq.size)
--
 	while (!list_empty(&timeout_list)) {
 		struct list_head *tmp;
 
@@ -2609,6 +2614,12 @@ static void process_timedout_eps(void)
 		ep = list_entry(tmp, struct c4iw_ep, entry);
 		process_timeout(ep);
--
 	while ((skb = skb_dequeue(&rxq))) {
 		rpl = cplhdr(skb);
 		dev = *((struct c4iw_dev **) (skb->cb + sizeof(void *)));
@@ -2630,6 +2646,12 @@ static void process_work(struct work_str
 		ret = work_handlers[opcode](dev, skb);
 		if (!ret)
--
 		while (t & ((1 << shift) - 1)) {
 			--shift;
 			npages *= 2;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (o > order) {
 		--o;
 		seg <<= 1;
 		set_bit(seg ^ 1, buddy->bits[o]);
 		++buddy->num_free[o];
+		if (_cur < timeout) {
--
 	while (test_bit(seg ^ 1, buddy->bits[order])) {
 		clear_bit(seg ^ 1, buddy->bits[order]);
 		--buddy->num_free[order];
 		seg >>= 1;
 		++order;
+		if (_cur < timeout) {
--
 	while ((eqe = next_eqe_sw(eq))) {
 		/*
 		 * Make sure we read EQ entry contents after we've
@@ -379,6 +384,12 @@ static int mthca_eq_int(struct mthca_dev
 			set_eq_ci(dev, eq, eq->cons_index);
 			set_ci = 0;
--
 		while (go_bit(dev) && time_before(jiffies, end)) {
 			set_current_state(TASK_RUNNING);
 			schedule();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (go_bit(dev) && time_before(jiffies, end)) {
 		set_current_state(TASK_RUNNING);
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (i > start) {
 		i -= inc;
 		mthca_table_put(dev, table, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (send_wr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (send_wr) {
 		struct ib_mad_hdr *mad_hdr = send_wr->wr.ud.mad_hdr;
 		struct ib_sge *sge = send_wr->sg_list;
 		ehca_gen_dbg("send_wr#%x wr_id=%lx num_sge=%x "
@@ -147,6 +152,12 @@ static void trace_send_wr_ud(const struc
 		} /* eof for j */
--
 	} /* eof while send_wr */
 }
 
@@ -478,6 +489,11 @@ int ehca_post_send(struct ib_qp *qp,
 	}
 
--
 	while (send_wr) {
 		ret = post_one_send(my_qp, send_wr, 0);
 		if (unlikely(ret)) {
@@ -485,6 +501,12 @@ int ehca_post_send(struct ib_qp *qp,
 		}
 		wqe_cnt++;
--
 	while (recv_wr) {
 		u64 start_offset = my_qp->ipz_rqueue.current_q_offset;
 		/* get pointer next to free WQE */
@@ -564,6 +591,12 @@ static int internal_post_recv(struct ehc
 
 		wqe_cnt++;
--
 	while (f < nr_of_pages) {
 		kpage = (u8 *)get_zeroed_page(GFP_KERNEL);
 		if (!kpage)
@@ -114,6 +119,12 @@ static int alloc_queue_pages(struct ipz_
 			kpage += EHCA_PAGESIZE;
 			f++;
--
 	while (eqe) {
 		if (!EHCA_BMASK_GET(NEQE_COMPLETION_EVENT, eqe->entry))
 			parse_ec(shca, eqe->entry);
 
 		eqe = ehca_poll_eq(shca, &shca->neq);
+		if (_cur < timeout) {
--
 	while (!list_empty(&cct->cq_list)) {
 		cq = list_entry(cct->cq_list.next, struct ehca_cq, entry);
 		spin_unlock_irqrestore(&cct->task_lock, flags);
@@ -739,6 +755,12 @@ static void run_comp_task(struct ehca_cp
 			cct->cq_jobs--;
 		}
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		add_wait_queue(&cct->wait_queue, &wait);
 
 		spin_lock_irq(&cct->task_lock);
@@ -771,6 +798,12 @@ static int comp_task(void *__cct)
 			run_comp_task(__cct);
--
 	while (!list_empty(&list)) {
 		cq = list_entry(cct->cq_list.next, struct ehca_cq, entry);
 
 		list_del(&cq->entry);
 		__queue_comp_task(cq, this_cpu_ptr(pool->cpu_comp_tasks));
+		if (_cur < timeout) {
--
 	while (tail_idx != wqe_idx) {
 		if (qmap->map[tail_idx].cqe_req)
 			qmap->left_to_poll++;
 		tail_idx = next_index(tail_idx, qmap->entries);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (page < page_count) {
 		u64 rnum;
 		for (rnum = 0; (rnum < MAX_RPAGES) && (page < page_count);
@@ -1564,6 +1569,12 @@ static u64 ehca_reg_mr_section(int top,
 			ehca_err(&shca->ib_device, "register_rpage_mr failed");
 			return h_ret;
--
-	while (i < number) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < number) {
 		pbuf   = pginfo->u.phy.phys_buf_array + pginfo->u.phy.next_buf;
 		num_hw  = NUM_CHUNKS((pbuf->addr % pginfo->hwpage_size) +
 				     pbuf->size, pginfo->hwpage_size);
@@ -2110,6 +2126,12 @@ static int ehca_set_pagebuf_phys(struct
 			(pginfo->u.phy.next_buf)++;
--
 	while (pfn < end_pfn) {
 		if (ehca_is_hugepage(pfn)) {
 			/* Add mem found in front of the hugepage */
@@ -2447,6 +2474,12 @@ static int ehca_create_busmap_callback(u
 			start_pfn = pfn;
 		} else
--
-	while (list_empty(&file->recv_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->recv_list)) {
 		mutex_unlock(&file->mutex);
 
 		if (filp->f_flags & O_NONBLOCK)
@@ -344,6 +349,12 @@ static ssize_t ib_umad_read(struct file
 			return -ERESTARTSYS;
--
 	while (new_buf && (get_seg_num(new_buf) == rmpp_recv->seg_num + 1)) {
 		rmpp_recv->cur_seg_buf = new_buf;
 		rmpp_recv->seg_num++;
 		new_buf = get_next_seg(rmpp_list, new_buf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count--) {
 		work = kmalloc(sizeof(struct iwcm_work), GFP_KERNEL);
 		if (!work) {
@@ -128,6 +133,12 @@ static int alloc_work_entries(struct iwc
 		work->cm_id = cm_id_priv;
 		INIT_LIST_HEAD(&work->list);
--
-	while (!empty) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!empty) {
 		work = list_entry(cm_id_priv->work_list.next,
 				  struct iwcm_work, list);
 		list_del_init(&work->list);
@@ -877,6 +893,12 @@ static void cm_work_handler(struct work_
 			return;
--
 	while (!list_empty(&xrcd->tgt_qp_list)) {
 		qp = list_entry(xrcd->tgt_qp_list.next, struct ib_qp, xrcd_list);
 		ret = ib_destroy_qp(qp);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
--
-	while (!list_empty(&ctx->events)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ctx->events)) {
 
 		uevent = list_entry(ctx->events.next,
 				    struct ib_ucm_event, ctx_list);
@@ -172,6 +177,12 @@ static void ib_ucm_cleanup_events(struct
 
--
-	while (list_empty(&file->events)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->events)) {
 		mutex_unlock(&file->file_mutex);
 
 		if (file->filp->f_flags & O_NONBLOCK)
@@ -420,6 +436,12 @@ static ssize_t ib_ucm_event(struct ib_uc
 			return -ERESTARTSYS;
--
-	while (!list_empty(&file->ctxs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&file->ctxs)) {
 		ctx = list_entry(file->ctxs.next,
 				 struct ib_ucm_context, file_list);
 		mutex_unlock(&file->file_mutex);
@@ -1199,6 +1226,12 @@ static int ib_ucm_close(struct inode *in
 		kfree(ctx);
--
-	while (list_empty(&file->event_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->event_list)) {
 		spin_unlock_irq(&file->lock);
 
 		if (filp->f_flags & O_NONBLOCK)
@@ -305,6 +310,12 @@ static ssize_t ib_uverbs_event_read(stru
 			return -ERESTARTSYS;
--
 	while (node) {
 		group = rb_entry(node, struct mcast_group, node);
 		ret = memcmp(mgid->raw, group->rec.mgid.raw, sizeof *mgid);
@@ -144,6 +149,12 @@ static struct mcast_group *mcast_find(st
 			node = node->rb_left;
 		else
--
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_group = rb_entry(parent, struct mcast_group, node);
 
@@ -171,6 +187,12 @@ static struct mcast_group *mcast_insert(
 			link = &(*link)->rb_left;
--
-	while (!list_empty(&group->active_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&group->active_list)) {
 		member = list_entry(group->active_list.next,
 				    struct mcast_member, list);
 		atomic_inc(&member->refcount);
@@ -421,6 +448,12 @@ static void process_group_error(struct m
 		if (ret)
--
-	while (list_empty(&file->event_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->event_list)) {
 		mutex_unlock(&file->mut);
 
 		if (file->filp->f_flags & O_NONBLOCK)
@@ -336,6 +341,12 @@ static ssize_t ucma_get_event(struct ucm
 			return -ERESTARTSYS;
--
 	while (*p) {
 		parent = *p;
 		scan = rb_entry(parent, struct xrcd_table_entry, node);
@@ -639,6 +644,12 @@ static int xrcd_table_insert(struct ib_u
 			kfree(entry);
 			return -EEXIST;
--
 	while (p) {
 		entry = rb_entry(p, struct xrcd_table_entry, node);
 
@@ -662,6 +678,12 @@ static struct xrcd_table_entry *xrcd_tab
 			p = p->rb_right;
 		else
--
 	while (wr) {
 		if (is_ud && wr->wr.ud.ah)
 			put_ah_read(wr->wr.ud.ah);
 		next = wr->next;
 		kfree(wr);
 		wr = next;
--
 	while (wr) {
 		next = wr->next;
 		kfree(wr);
 		wr = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (wr) {
 		next = wr->next;
 		kfree(wr);
 		wr = next;
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (wr) {
 		next = wr->next;
 		kfree(wr);
 		wr = next;
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
-	while (!list_empty(&id_priv->listen_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&id_priv->listen_list)) {
 		dev_id_priv = list_entry(id_priv->listen_list.next,
 					 struct rdma_id_private, listen_list);
 		/* sync with device removal to avoid duplicate destruction */
@@ -840,6 +845,12 @@ static void cma_cancel_listens(struct rd
 
--
-	while (!list_empty(&id_priv->mc_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&id_priv->mc_list)) {
 		mc = container_of(id_priv->mc_list.next,
 				  struct cma_multicast, list);
 		list_del(&mc->list);
@@ -899,6 +915,12 @@ static void cma_leave_mc_groups(struct r
 		default:
--
-	while (!list_empty(&cma_dev->id_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cma_dev->id_list)) {
 		id_priv = list_entry(cma_dev->id_list.next,
 				     struct rdma_id_private, list);
 
@@ -3337,6 +3364,12 @@ static void cma_process_remove(struct cm
 			rdma_destroy_id(&id_priv->id);
--
-	while (npages) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (npages) {
 		ret = get_user_pages(current, current->mm, cur_base,
 				     min_t(unsigned long, npages,
 					   PAGE_SIZE / sizeof (struct page *)),
@@ -162,7 +167,12 @@ struct ib_umem *ib_umem_get(struct ib_uc
 
--
-		while (ret) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (ret) {
 			chunk = kmalloc(sizeof *chunk + sizeof (struct scatterlist) *
 					min_t(int, ret, IB_UMEM_MAX_PAGE_CHUNK),
 					GFP_KERNEL);
@@ -197,10 +207,22 @@ struct ib_umem *ib_umem_get(struct ib_uc
 			ret -= chunk->nents;
--
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_cm_id_priv = rb_entry(parent, struct cm_id_private,
 					  service_node);
@@ -526,6 +531,12 @@ static struct cm_id_private * cm_insert_
 			link = &(*link)->rb_left;
--
-	while (node) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (node) {
 		cm_id_priv = rb_entry(node, struct cm_id_private, service_node);
 		data_cmp = cm_compare_private_data(private_data,
 						   cm_id_priv->compare_data);
@@ -561,6 +577,12 @@ static struct cm_id_private * cm_find_li
 			node = node->rb_left;
--
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_timewait_info = rb_entry(parent, struct cm_timewait_info,
 					     remote_id_node);
@@ -588,6 +615,12 @@ static struct cm_timewait_info * cm_inse
 			link = &(*link)->rb_right;
--
-	while (node) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (node) {
 		timewait_info = rb_entry(node, struct cm_timewait_info,
 					 remote_id_node);
 		if (be32_lt(remote_id, timewait_info->work.remote_id))
@@ -614,6 +652,12 @@ static struct cm_timewait_info * cm_find
 			node = node->rb_right;
--
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_timewait_info = rb_entry(parent, struct cm_timewait_info,
 					     remote_qp_node);
@@ -641,6 +690,12 @@ static struct cm_timewait_info * cm_inse
 			link = &(*link)->rb_right;
--
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_cm_id_priv = rb_entry(parent, struct cm_id_private,
 					  sidr_id_node);
@@ -676,6 +736,12 @@ static struct cm_id_private * cm_insert_
 			else
--
 	while (!ret && !atomic_add_negative(-1, &cm_id_priv->work_count)) {
 		spin_lock_irq(&cm_id_priv->lock);
 		work = cm_dequeue_work(cm_id_priv);
@@ -1326,6 +1397,12 @@ static void cm_process_work(struct cm_id
 		ret = cm_id_priv->id.cm_handler(&cm_id_priv->id,
 						&work->cm_event);
--
 	while (--i) {
 		port = cm_dev->port[i-1];
 		ib_modify_port(ib_device, port->port_num, 0, &port_modify);
 		ib_unregister_mad_agent(port->mad_agent);
 		cm_remove_port_fs(port);
+		if (_cur < timeout) {
--
-	while (!list_empty(&mad_agent_priv->local_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mad_agent_priv->local_list)) {
 		local = list_entry(mad_agent_priv->local_list.next,
 				   struct ib_mad_local_private,
 				   completion_list);
@@ -2432,6 +2437,12 @@ local_send_completion:
 		if (free_mad)
--
-	while (!list_empty(&qp_info->recv_queue.list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&qp_info->recv_queue.list)) {
 
 		mad_list = list_entry(qp_info->recv_queue.list.next,
 				      struct ib_mad_list_head, list);
@@ -2631,6 +2647,12 @@ static void cleanup_recv_queue(struct ib
 				      sizeof(struct ib_mad_private_header),
--
 	while (i >= start) {
 		if (ib_agent_port_close(device, i))
 			printk(KERN_ERR PFX "Couldn't close %s port %d "
@@ -2975,6 +3002,12 @@ error:
 			printk(KERN_ERR PFX "Couldn't close %s port %d\n",
 			       device->name, i);
--
 	while (nents) {
 		sg_dma_address(sglist) = ccio_map_single(dev, sglist->address, sglist->length, direction);
 		sg_dma_len(sglist) = sglist->length;
 		nents--;
 		sglist++;
+		if (_cur < timeout) {
--
 	while(card->next) {
 		card = card->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while(byte_cnt > chain_size) {
 		WRITE_U32(CMD_TLB_PURGE | iovp, &ioc->ioc_regs->io_command);
 		iovp += chain_size;
 		byte_cnt -= chain_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while(sg_dma_len(sglist) && nents--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(sg_dma_len(sglist) && nents--) {
 
 #ifdef CCIO_COLLECT_STATS
 		ioc->usg_pages += sg_dma_len(sglist) >> PAGE_SHIFT;
@@ -998,6 +1014,12 @@ ccio_unmap_sg(struct device *dev, struct
 		ccio_unmap_single(dev, sg_dma_address(sglist),
--
-	while (idx < ioc->res_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (idx < ioc->res_size) {
  		res_ptr[idx] |= 0xff;
 		idx += PDIR_INDEX(CUJO_20_STEP) >> 3;
+		if (_cur < timeout) {
+ 		rdstcll(_cur);
+		}
--
 	while (rptr < rptr_end) {
 		u32 rval = *rptr;
 		int rcnt = 32;	/* number of bits we might check */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
--
 		while (rcnt) {
 			/* Get last byte and highest bit from that */
 			u32 pde = ((u32) (((char *)pptr)[7])) << 24;
@@ -253,8 +263,20 @@ sba_check_pdir(struct ioc *ioc, char *ms
 			rval <<= 1;	/* try the next bit */
 			pptr++;
--
 		while (cnt--) {
 			sba_free_range(ioc, d->iova, d->size);
 			d--;
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
--
-	while (sg_dma_len(sglist) && nents--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (sg_dma_len(sglist) && nents--) {
 
 		sba_unmap_single(dev, sg_dma_address(sglist), sg_dma_len(sglist), direction);
 #ifdef SBA_COLLECT_STATS
@@ -1046,6 +1084,12 @@ sba_unmap_sg(struct device *dev, struct
 		ioc->usingle_calls--;	/* kluge since call is unmap_sg() */
--
 			while (pdir_order < (19-12)) {
 				new_pdir += pdir_size;
 				free_pages(new_pdir, pdir_order);
 				pdir_order +=1;
 				pdir_size <<=1;
+				if (_cur < timeout) {
--
 	while (host->io_pos && length) {
 		buf[off++] = host->io_word[0] & 0xff;
 		host->io_word[0] >>= 8;
 		length--;
 		host->io_pos--;
+		if (_cur < timeout) {
--
 	while (host->io_pos && length) {
 		buf[off++] = host->io_word[1] & 0xff;
 		host->io_word[1] >>= 8;
 		length--;
 		host->io_pos--;
+		if (_cur < timeout) {
--
 	while (host->io_pos && length) {
 		buf[off++] = host->io_word & 0xff;
 		host->io_word >>= 8;
 		length--;
 		host->io_pos--;
+		if (_cur < timeout) {
--
 	while (time_before(jiffies, timeout)) {
 
 		reg = r592_read_reg(dev, R592_STATUS);
@@ -126,6 +131,12 @@ static int r592_wait_status(struct r592_
 			return -EIO;
 
--
 	while (!kthread_should_stop()) {
 		spin_lock_irqsave(&dev->io_thread_lock, flags);
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -589,6 +605,12 @@ static int r592_process_thread(void *dat
 			set_current_state(TASK_RUNNING);
 			r592_execute_tpc(dev);
--
 	while (!error && dev->req) {
 		dev->req->error = -ETIME;
 		error = memstick_next_req(dev->host, &dev->req);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (chunk) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (chunk) {
 		msb->current_page = 0;
 		msb->current_seg = 0;
 		msb->seg_count = blk_rq_map_sg(msb->block_req->q,
@@ -728,6 +733,12 @@ try_again:
 
--
 		while (ids->match_flags) {
 			if (memstick_dev_match(card, ids))
 				return 1;
 			++ids;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (1) {
 		if (!idr_pre_get(&memstick_host_idr, GFP_KERNEL))
 			return -ENOMEM;
@@ -523,6 +539,12 @@ int memstick_add_host(struct memstick_ho
 			break;
 		else if (rc != -EAGAIN)
--
 	while(inb(G2STAT(base)) & G2STAT_INTPEND) {
 		handled = 1;
 		DEB(printk("aha1740_intr top of loop.\n"));
@@ -325,6 +330,12 @@ static irqreturn_t aha1740_intr_handle(i
 			break;
 		}
--
 	while (!in_irq() && falcon_got_lock && stdma_others_waiting())
 		sleep_on(&falcon_fairness_wait);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (!falcon_got_lock) {
 		if (in_irq())
 			panic("Falcon SCSI hasn't ST-DMA lock in interrupt");
@@ -564,6 +569,12 @@ static void falcon_get_lock(void)
 		} else {
 			sleep_on(&falcon_try_wait);
--
 	while (d < h->buff + len) {
 		switch (d[1] & 0xf) {
 		case 0x4:
@@ -389,6 +394,12 @@ static int alua_vpd_inquiry(struct scsi_
 			break;
 		}
--
 	/* while there are valid entries */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->hba_index != q->host_index) {
 		temp_eqe = q->qe[q->host_index].eqe;
 		bf_set_le32(lpfc_eqe_valid, temp_eqe, 0);
 		released++;
 		q->host_index = ((q->host_index + 1) % q->entry_count);
+		if (_cur < timeout) {
--
 	/* while there are valid entries */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->hba_index != q->host_index) {
 		temp_qe = q->qe[q->host_index].cqe;
 		bf_set_le32(lpfc_cqe_valid, temp_qe, 0);
 		released++;
 		q->host_index = ((q->host_index + 1) % q->entry_count);
+		if (_cur < timeout) {
--
 	while (!found) {
 		if (!sglq)
 			return NULL;
@@ -875,6 +902,12 @@ __lpfc_sli_get_sglq(struct lpfc_hba *phb
 		found = 1;
 		phba->sli4_hba.lpfc_sglq_active_list[sglq->sli4_lxritag] = sglq;
--
 	while (!list_empty(iocblist)) {
 		list_remove_head(iocblist, piocb, struct lpfc_iocbq, list);
 
@@ -1052,6 +1090,12 @@ lpfc_sli_cancel_iocbs(struct lpfc_hba *p
 			piocb->iocb.un.ulpWord[4] = ulpWord4;
 			(piocb->iocb_cmpl) (phba, piocb, piocb);
--
-	while (!list_empty(&hbq_buf_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&hbq_buf_list)) {
 		list_remove_head(&hbq_buf_list, hbq_buffer, struct hbq_dmabuf,
 				 dbuf.list);
 		hbq_buffer->tag = (phba->hbqs[hbqno].buffer_count |
@@ -1818,15 +1867,32 @@ lpfc_sli_hbqbuf_fill_hbqs(struct lpfc_hb
 			posted++;
--
-	while (!list_empty(&hbq_buf_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&hbq_buf_list)) {
 		list_remove_head(&hbq_buf_list, hbq_buffer, struct hbq_dmabuf,
 				 dbuf.list);
 		(phba->hbqs[hbqno].hbq_free_buffer)(phba, hbq_buffer);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (pring->rspidx != portRspPut) {
 		/*
 		 * Fetch an entry off the ring and copy it into a local data
@@ -2971,6 +3042,12 @@ lpfc_sli_handle_fast_ring_event(struct l
 
 		if (pring->rspidx == portRspPut)
--
-	while (!list_empty(&phba->sli4_hba.sp_queue_event)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->sli4_hba.sp_queue_event)) {
 		/* Get the response iocb from the head of work queue */
 		spin_lock_irqsave(&phba->hbalock, iflag);
 		list_remove_head(&phba->sli4_hba.sp_queue_event,
@@ -3370,6 +3452,12 @@ lpfc_sli_handle_slow_ring_event_s4(struc
 		default:
--
 	while ((status & (HS_FFRDY | HS_MBRDY)) != (HS_FFRDY | HS_MBRDY)) {
 
 		/* Check every 10ms for 10 retries, then every 100ms for 90
@@ -4105,6 +4198,12 @@ lpfc_sli_chipset_init(struct lpfc_hba *p
 		/* Read the HBA Host Status Register */
 		if (lpfc_readl(phba->HSregaddr, &status))
--
 		while (rsrc_id < (rsrc_start + rsrc_size)) {
 			ids[j] = rsrc_id;
 			rsrc_id++;
 			j++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&completions)) {
 		list_remove_head(&completions, pmb, LPFC_MBOXQ_t, list);
 		pmb->u.mb.mbxStatus = MBX_NOT_FINISHED;
 		if (pmb->mbox_cmpl)
 			pmb->mbox_cmpl(phba, pmb);
+			if (_cur < timeout) {
--
-	while (!list_empty(&completions)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&completions)) {
 		list_remove_head(&completions, buf_ptr,
 			struct lpfc_dmabuf, list);
 		lpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);
 		kfree(buf_ptr);
+		if (_cur < timeout) {
--
-	while (!list_empty(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue)) {
 		/* Get the first event from the head of the event queue */
 		spin_lock_irq(&phba->hbalock);
 		list_remove_head(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue,
@@ -10424,6 +10561,12 @@ void lpfc_sli4_fcp_xri_abort_event_proc(
 		lpfc_sli4_fcp_xri_aborted(phba, &cq_event->cqe.wcqe_axri);
--
-	while (!list_empty(&phba->sli4_hba.sp_els_xri_aborted_work_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->sli4_hba.sp_els_xri_aborted_work_queue)) {
 		/* Get the first event from the head of the event queue */
 		spin_lock_irq(&phba->hbalock);
 		list_remove_head(&phba->sli4_hba.sp_els_xri_aborted_work_queue,
@@ -10453,6 +10601,12 @@ void lpfc_sli4_els_xri_abort_event_proc(
 		lpfc_sli4_els_xri_aborted(phba, &cq_event->cqe.wcqe_axri);
--
 		while ((cqe = lpfc_sli4_cq_get(cq))) {
 			workposted |= lpfc_sli4_sp_handle_mcqe(phba, cqe);
 			if (!(++ecount % cq->entry_repost))
 				lpfc_sli4_cq_release(cq, LPFC_QUEUE_NOARM);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
-		while ((cqe = lpfc_sli4_cq_get(cq))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((cqe = lpfc_sli4_cq_get(cq))) {
 			if (cq->subtype == LPFC_FCP)
 				workposted |= lpfc_sli4_fp_handle_wcqe(phba, cq,
 								       cqe);
@@ -11033,6 +11203,12 @@ lpfc_sli4_sp_handle_eqe(struct lpfc_hba
 								      cqe);
--
 	while ((cqe = lpfc_sli4_cq_get(cq))) {
 		workposted |= lpfc_sli4_fp_handle_wcqe(phba, cq, cqe);
 		if (!(++ecount % cq->entry_repost))
 			lpfc_sli4_cq_release(cq, LPFC_QUEUE_NOARM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((eqe = lpfc_sli4_eq_get(speq))) {
 		lpfc_sli4_sp_handle_eqe(phba, eqe);
 		if (!(++ecount % speq->entry_repost))
 			lpfc_sli4_eq_release(speq, LPFC_QUEUE_NOARM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((eqe = lpfc_sli4_eq_get(fpeq))) {
 		lpfc_sli4_fp_handle_eqe(phba, eqe, fcp_eqidx);
 		if (!(++ecount % fpeq->entry_repost))
 			lpfc_sli4_eq_release(fpeq, LPFC_QUEUE_NOARM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&queue->page_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&queue->page_list)) {
 		list_remove_head(&queue->page_list, dmabuf, struct lpfc_dmabuf,
 				 list);
 		dma_free_coherent(&queue->phba->pcidev->dev, SLI4_PAGE_SIZE,
 				  dmabuf->virt, dmabuf->phys);
 		kfree(dmabuf);
--
 	while (!list_empty(&mbox_cmd_list)) {
 		list_remove_head(&mbox_cmd_list, mb, LPFC_MBOXQ_t, list);
 		if (mb->u.mb.mbxCommand == MBX_REG_LOGIN64) {
@@ -15571,6 +15796,12 @@ lpfc_cleanup_pending_mbox(struct lpfc_vp
 			}
 		}
--
 		while (payload_len) {
 			rscn_did.un.word = be32_to_cpu(*lp++);
 			payload_len -= sizeof(uint32_t);
@@ -4429,6 +4434,12 @@ lpfc_rscn_payload_check(struct lpfc_vpor
 			case RSCN_ADDRESS_FORMAT_FABRIC:
 				goto return_did_out;
--
 	while (time_before(jiffies, wait_time_max)) {
 		if ((vport->num_disc_nodes > 0)    ||
 		    (vport->fc_flag & wait_flags)  ||
@@ -277,6 +282,12 @@ static void lpfc_discovery_wait(struct l
 						- start_time));
 			break;
--
 	while (!list_empty(&evt->events_to_get)) {
 		ed = list_entry(evt->events_to_get.next, typeof(*ed), node);
 		list_del(&ed->node);
 		kfree(ed->data);
 		kfree(ed);
+		if (_cur < timeout) {
--
 	while (!list_empty(&evt->events_to_see)) {
 		ed = list_entry(evt->events_to_see.next, typeof(*ed), node);
 		list_del(&ed->node);
 		kfree(ed->data);
 		kfree(ed);
+		if (_cur < timeout) {
--
-	while (size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size) {
 		/* We get chunks of 4K */
 		if (size > BUF_SZ_4K)
 			cnt = BUF_SZ_4K;
@@ -2456,6 +2483,12 @@ diag_cmd_data_alloc(struct lpfc_hba *phb
 		i++;
--
 	while (size) {
 		/* Allocate buffer for rsp payload */
 		mp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);
@@ -262,6 +267,12 @@ lpfc_alloc_ct_rsp(struct lpfc_hba *phba,
 
 		i++;
--
 	while (sgde) {
 		src = sg_virt(sgde);
 		memcpy(dst, src, sgde->length);
 		dst += sgde->length;
 		sgde = sg_next(sgde);
+		if (_cur < timeout) {
--
 	while (sgde) {
 		src = sg_virt(sgde);
 		memcpy(dst, src, sgde->length);
 		dst += sgde->length;
 		sgde = sg_next(sgde);
+		if (_cur < timeout) {
--
-		while (!list_empty(&sblist)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&sblist)) {
 			list_remove_head(&sblist, psb, struct lpfc_scsi_buf,
 					 list);
 			if (status) {
@@ -774,6 +801,12 @@ lpfc_sli4_repost_scsi_sgl_list(struct lp
 			}
--
-		while (!list_empty(&sblist)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&sblist)) {
 			list_remove_head(&sblist, psb, struct lpfc_scsi_buf,
 				 list);
 			if (status) {
@@ -961,6 +999,12 @@ lpfc_new_scsi_buf_s4(struct lpfc_vport *
 			}
--
 	while (time_after(later, jiffies)) {
 		if (!pnode || !NLP_CHK_NODE_ACT(pnode))
 			return FAILED;
@@ -3658,6 +3707,12 @@ lpfc_chk_tgt_mapped(struct lpfc_vport *v
 		if (!rdata)
 			return FAILED;
--
 	while (time_after(later, jiffies) && cnt) {
 		schedule_timeout_uninterruptible(msecs_to_jiffies(20));
 		cnt = lpfc_sli_sum_iocb(vport, tgt_id, lun_id, context);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&phba->work_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->work_list)) {
 		list_remove_head((&phba->work_list), evtp, typeof(*evtp),
 				 evt_listp);
 		spin_unlock_irq(&phba->hbalock);
@@ -572,6 +577,12 @@ lpfc_work_list_done(struct lpfc_hba *phb
 		if (free_evt)
--
 			while (!((new_fcf_record->vlan_bitmap[i] >> j) & 1)) {
 				j++;
 				fcf_vlan_id++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 				while (j < numalpa) {
 					memset(un.pamap, 0, 16);
 					for (k = 1; j < numalpa; k++) {
@@ -2997,6 +3024,12 @@ lpfc_mbx_process_link_up(struct lpfc_hba
 							"x%x x%x x%x\n",
 							un.pa.wd1, un.pa.wd2,
--
 	while ((offset + rec_length * sizeof(uint32_t) + sizeof(uint32_t))
 		<= size) {
 		if (buff[offset] == rec_type)
@@ -6004,6 +6042,12 @@ lpfc_get_rec_conf23(uint8_t *buff, uint3
 
 		offset += rec_length * sizeof(uint32_t) + sizeof(uint32_t);
--
 	while ((skb = skb_dequeue(&fnic->frame_queue))) {
 
 		spin_lock_irqsave(&fnic->fnic_lock, flags);
@@ -125,6 +130,12 @@ void fnic_handle_frame(struct work_struc
 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 
--
 	while ((skb = skb_dequeue(&fnic->tx_queue))) {
 		fp = (struct fc_frame *)skb;
 		fnic_send_frame(fnic, fp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while(len && timeout)
 	{
 		bytes_left = inb(base + PIO_FIFO_CNT); /* Number of bytes in the PIO FIFO */
@@ -277,6 +282,12 @@ static __inline__ unsigned int sym53c416
 			if(inb(base + PIO_INT_REG) & EMPTY)
 				timeout = 0;
--
 	while(len && timeout)
 	{
 		bufferfree = PIO_SIZE - inb(base + PIO_FIFO_CNT);
@@ -320,6 +336,12 @@ static __inline__ unsigned int sym53c416
 			if(inb(base + PIO_INT_REG) & FULL)
 				timeout = 0;
--
 	while (!list_empty(&shost->free_list)) {
 		struct scsi_cmnd *cmd;
 
 		cmd = list_entry(shost->free_list.next, struct scsi_cmnd, list);
 		list_del_init(&cmd->list);
 		scsi_pool_free_command(shost->cmd_pool, cmd);
--
-	while (kfifo_out(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (kfifo_out(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {
 		kfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,
 			    sizeof(void*));
 		ISCSI_DBG_TCP(task->conn, "pending r2t dropped\n");
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (1) {
 		unsigned int avail;
 		const u8 *ptr;
@@ -921,6 +937,12 @@ int iscsi_tcp_recv_skb(struct iscsi_conn
 			skb_abort_seq_read(&seq);
 			goto segment_done;
--
 	while (count && qe) {
 		qe_next = bfa_q_next(qe);
 		lps = (struct bfa_lps_s *)qe;
@@ -1614,6 +1619,12 @@ bfa_lps_no_res(struct bfa_lps_s *first_l
 		bfa_sm_send_event(lps, BFA_LPS_SM_FWRSP);
 		qe = qe_next;
--
 	while ((qe != qh) && (i < *nrports)) {
 		rport = (struct bfa_fcs_rport_s *) qe;
 		if (bfa_ntoh3b(rport->pid) > 0xFFF000) {
@@ -4924,6 +4929,12 @@ bfa_fcs_lport_get_rports(struct bfa_fcs_
 
 		i++;
--
 	while (qe != qh) {
 		rport = (struct bfa_fcs_rport_s *) qe;
 		if ((bfa_ntoh3b(rport->pid) > 0xFFF000) ||
@@ -4982,6 +4998,12 @@ bfa_fcs_lport_get_rport_max_speed(bfa_fc
 			max_speed = rport_speed;
 
--
-	while (i < iocmd->attr.total_vc_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i < iocmd->attr.total_vc_count) {
 		iocmd->attr.vc_info[i].vc_credit =
 				bfa_vc_attr->vc_info[i].vc_credit;
 		iocmd->attr.vc_info[i].borrow_credit =
@@ -2289,6 +2294,12 @@ bfad_iocmd_qos_get_vc_attr(struct bfad_s
 		iocmd->attr.vc_info[i].priority =
--
 	while ((struct bfa_ioim_s *) cmnd->host_scribble == hal_io) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(timeout);
 		if (timeout < 4 * HZ)
 			timeout *= 2;
+			if (_cur < timeout) {
--
 	while (!list_empty(&bfad->active_aen_q)) {
 		spin_lock_irqsave(&bfad->bfad_aen_spinlock, flags);
 		bfa_q_deq(&bfad->active_aen_q, &aen_entry);
@@ -680,6 +696,12 @@ static void bfad_aen_im_notify_handler(s
 		spin_lock_irqsave(&bfad->bfad_aen_spinlock, flags);
 		list_add_tail(&aen_entry->qe, &bfad->free_aen_q);
--
 	while (qe != qh) {
 		qe_next = bfa_q_next(qe);
 
@@ -3003,14 +3008,31 @@ bfa_timer_beat(struct bfa_timer_mod_s *m
 		}
 
--
 	while (!list_empty(&timedout_q)) {
 		bfa_q_deq(&timedout_q, &elem);
 		elem->timercb(elem->arg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!kthread_should_stop()) {
 
 		/* Send event BFAD_E_INIT_SUCCESS */
@@ -1132,6 +1137,12 @@ bfad_worker(void *ptr)
 		spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 
--
 	while (ci != pi) {
 		m = bfa_rspq_elem(bfa, qid, ci);
 		WARN_ON(m->mhdr.msg_class >= BFI_MC_MAX);
 
 		bfa_isrs[m->mhdr.msg_class] (bfa, m);
 		CQ_INCR(ci, bfa->iocfc.cfg.drvcfg.num_rspq_elems);
--
 	while (!list_empty(comp_q)) {
 		bfa_q_deq(comp_q, &qe);
 		hcb_qe = (struct bfa_cb_qe_s *) qe;
 		WARN_ON(hcb_qe->pre_rmv);
 		hcb_qe->cbfn(hcb_qe->cbarg, BFA_FALSE);
+		if (_cur < timeout) {
--
 	while (!list_empty(&itnim->pending_q)) {
 		bfa_q_deq(&itnim->pending_q, &ioim);
 		list_add_tail(&ioim->qe, &itnim->io_q);
 		bfa_ioim_start(ioim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&itnim->pending_q)) {
 		bfa_q_deq(&itnim->pending_q, &ioim);
 		list_add_tail(&ioim->qe, &ioim->fcpim->ioim_comp_q);
 		bfa_ioim_tov(ioim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (desc < buf + vpd_len) {
 		enum scsi_protocol proto = desc[0] >> 4;
 		u8 code_set = desc[0] & 0x0f;
@@ -488,6 +493,12 @@ static void ses_match_to_enclosure(struc
 				(u64)desc[11];
 
--
 	while(time_before(jiffies, end))
 	{
 		r = NCR5380_read(reg);
@@ -349,6 +354,12 @@ static int NCR5380_poll_politely(struct
 			cond_resched();
 		else
--
-	while (sges_in_segment) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sges_in_segment) {
 		if (sges_in_segment == 1)
 			ioc->base_add_sg_single(sg_local,
 			    sgl_flags_last_element | sg_dma_len(sg_scmd),
@@ -1096,6 +1101,12 @@ _scsih_build_scatter_gather(struct MPT2S
 		sg_local += ioc->sge_size;
--
-		while (sges_in_segment) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (sges_in_segment) {
 			if (sges_in_segment == 1)
 				ioc->base_add_sg_single(sg_local,
 				    sgl_flags_last_element |
@@ -1138,6 +1154,12 @@ _scsih_build_scatter_gather(struct MPT2S
 			sg_local += ioc->sge_size;
--
-	while (sges_left) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sges_left) {
 		if (sges_left == 1)
 			ioc->base_add_sg_single(sg_local, sgl_flags_end_buffer |
 			    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));
@@ -1161,6 +1188,12 @@ _scsih_build_scatter_gather(struct MPT2S
 		sg_scmd = sg_next(sg_scmd);
--
 			while (_scsih_add_device(ioc, handle, retry_count++,
 				1)) {
 					ssleep(1);
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 			while (_scsih_add_device(ioc, handle, retry_count++,
 				0)) {
 					ssleep(1);
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		mpi_request.PageAddress = cpu_to_le32(config_num +
 		    MPI2_RAID_PGAD_FORM_GET_NEXT_CONFIGNUM);
 		r = _config_request(ioc, &mpi_request, &mpi_reply,
@@ -1421,6 +1426,12 @@ mpt2sas_config_get_volume_handle(struct
 			}
--
 	while (!list_empty(cmd_list)) {
 		scmd = list_entry(cmd_list->next, struct scsi_cmnd, eh_entry);
 		sdev = scmd->device;
@@ -1003,6 +1008,12 @@ static int scsi_eh_test_devices(struct l
 				else
 					list_move_tail(&scmd->eh_entry, work_q);
--
 	while (!list_empty(&tmp_list)) {
 		struct scsi_cmnd *next, *scmd;
 		int rtn;
@@ -1232,6 +1248,12 @@ static int scsi_eh_target_reset(struct S
 				/* push back on work queue for further processing */
 				list_move(&scmd->eh_entry, work_q);
--
 	while (!kthread_should_stop()) {
 		if ((shost->host_failed == 0 && shost->host_eh_scheduled == 0) ||
 		    shost->host_failed != shost->host_busy) {
@@ -1859,6 +1886,12 @@ int scsi_error_handler(void *data)
 		scsi_restart_operations(shost);
 		scsi_autopm_put_host(shost);
--
-	while (s->cmpConsIdx != s->cmpProdIdx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (s->cmpConsIdx != s->cmpProdIdx) {
 		struct PVSCSIRingCmpDesc *e = ring + (s->cmpConsIdx &
 						      MASK(cmp_entries));
 		/*
@@ -610,6 +615,12 @@ static void pvscsi_process_completion_ri
 		 */
--
-	while (pvscsi_msg_pending(adapter)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pvscsi_msg_pending(adapter)) {
 		struct PVSCSIRingMsgDesc *e = ring + (s->msgConsIdx &
 						      MASK(msg_entries));
 
@@ -996,6 +1012,12 @@ static void pvscsi_process_msg_ring(cons
 		pvscsi_process_msg(adapter, e);
--
 	while (time_before_eq(jiffies, WAITtimeout)) {
 		WAITbits = inb(port) & mask;
 
 		if (((WAITbits & allof) == allof) && ((WAITbits & noneof) == 0))
 			return (0);
+			if (_cur < timeout) {
--
 		while (len--) {
 			do {
 				outb(*cmd, host->iobase + ASC_COMMAND);
@@ -785,6 +801,12 @@ static inline int command_out(Adapter *
 			} while (inb(host->iobase + ASC_STAT) & CMD_REJ);
 
 			cmd++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (freescbs < needed) {
 		timeout = jiffies + WAITnexttimeout;
 		do {
@@ -835,6 +862,12 @@ static inline Scb *alloc_scbs(struct Scs
 			printk(KERN_ERR "wd7000: can't get enough free SCBs.\n");
 			return (NULL);
--
 	while (icb.phase) {
 		cpu_relax();	/* wait for completion */
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 			while ((inb(tmport) & 0x01) != j) {
 				outb(j,tmport);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 	while (tmp) {
 		if (tmp == cmd) {
 			if (prev)
@@ -1644,6 +1649,12 @@ wd33c93_abort(struct scsi_cmnd * cmd)
 		}
 		prev = tmp;
--
-	while (tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (tmp) {
 		if (tmp == cmd) {
 			printk
 			    ("scsi%d: Abort - command found on disconnected_Q - ",
@@ -1735,6 +1751,12 @@ wd33c93_abort(struct scsi_cmnd * cmd)
 			return FAILED;
--
-		while (cmd) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)",
 				cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (struct scsi_cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
--
-		while (cmd) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)",
 				cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (struct scsi_cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
--
 	while(ptr) {
 		Scsi_Cmnd *next;
 
@@ -1241,6 +1246,12 @@ static void free_hard_reset_SCs(struct S
 		}
 
--
 	while(ptr) {
 		Scsi_Cmnd *next = SCNEXT(ptr);
 
@@ -2494,6 +2510,12 @@ static void rsti_run(struct Scsi_Host *s
 		}
 
--
 		while ( setup_count<ARRAY_SIZE(setup) &&
 			(dev=pnp_find_dev(NULL, id_table[i].vendor, id_table[i].function, dev)) ) {
 			if (pnp_device_attach(dev) < 0)
@@ -3824,6 +3851,12 @@ static int __init aha152x_init(void)
 				"aha152x: found ISAPnP adapter at io=0x%03x, irq=%d\n",
 				setup[setup_count].io_port, setup[setup_count].irq);
--
 		while (tag_mask & dcb->tag_mask
 		       && tag_number < dcb->max_command) {
 			tag_mask = tag_mask << 1;
 			tag_number++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (left_io) {
 				unsigned char *virt, *base = NULL;
 				unsigned long flags = 0;
@@ -2325,6 +2341,12 @@ static void data_in_phase0(struct Adapte
 
 				scsi_kunmap_atomic_sg(base);
--
 			while (left_io) {
 				unsigned char *virt, *base = NULL;
 				unsigned long flags = 0;
@@ -2503,6 +2530,11 @@ static void data_io_transfer(struct Adap
 
 				left_io -= len;
--
 				while (len--) {
 					if (debug_enabled(DBG_PIO))
 						printk(" %02x", *virt);
@@ -2510,10 +2542,22 @@ static void data_io_transfer(struct Adap
 					DC395x_write8(acb, TRM_S1040_SCSI_FIFO, *virt++);
 
--
-	while (pages--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (pages--) {
 		ptr = kmalloc(PAGE_SIZE, GFP_KERNEL);
 		if (!ptr) {
 			adapter_sg_tables_free(acb);
@@ -4286,6 +4335,12 @@ static int __devinit adapter_sg_tables_a
 		while (i < srbs_per_page && srb_idx < DC395x_MAX_SRB_CNT)
 			acb->srb_array[srb_idx++].segment_x =
 			    ptr + (i++ * DC395x_MAX_SG_LISTENTRY);
+			    if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((status_reg_value & flag) != flag) {
 		status_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));
 
@@ -1494,6 +1499,12 @@ static int twa_poll_status(TW_Device_Ext
 			goto out;
 
--
 	while ((status_reg_value & flag) != flag) {
 		status_reg_value = inl(TW_STATUS_REG_ADDR(tw_dev));
 
@@ -318,6 +323,12 @@ static int tw_poll_status(TW_Device_Exte
 			goto out;
 
--
 	while (phy != &mvi->phy[phy_no]) {
 		phy_no++;
 		if (phy_no >= MVS_MAX_PHYS)
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (mvi->rx_cons != rx_prod_idx) {
 		/* increment our internal RX consumer pointer */
 		rx_prod_idx = (rx_prod_idx + 1) & (MVS_RX_RING_SZ - 1);
@@ -2190,6 +2206,12 @@ int mvs_int_rx(struct mvs_info *mvi, boo
 		} else if (rx_desc & RXQ_SLOT_RESET) {
 			mvs_slot_free(mvi, rx_desc);
--
 	while (waits--) {
 		if (atomic_read(&pinstance->outstanding_cmds) <=
 		    PMCRAID_MAX_HCAM_CMD)
 			return SUCCESS;
 		msleep(interval);
+		if (_cur < timeout) {
--
 	while ((resp & HRRQ_TOGGLE_BIT) ==
 		pinstance->host_toggle_bit[id]) {
 
@@ -4649,6 +4665,12 @@ static void pmcraid_tasklet_function(uns
 		/* loop over until we are done with all responses */
 		spin_lock_irqsave(lockp, hrrq_lock_flags);
--
 	while ((key = strsep(&ips_str, ",."))) {
 		if (!*key)
 			continue;
@@ -539,6 +544,12 @@ ips_setup(char *ips_str)
 				break;
 			}
--
 		while ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {
 			scb->scsi_cmd->result = DID_ERROR << 16;
 			scb->scsi_cmd->scsi_done(scb->scsi_cmd);
 			ips_freescb(ha, scb);
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while ((scsi_cmd = ips_removeq_wait_head(&ha->scb_waitlist))) {
 			scsi_cmd->result = DID_ERROR;
 			scsi_cmd->scsi_done(scsi_cmd);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {
 			scb->scsi_cmd->result = DID_ERROR << 16;
 			scb->scsi_cmd->scsi_done(scb->scsi_cmd);
 			ips_freescb(ha, scb);
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while ((scsi_cmd = ips_removeq_wait_head(&ha->scb_waitlist))) {
 			scsi_cmd->result = DID_ERROR << 16;
 			scsi_cmd->scsi_done(scsi_cmd);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {
 		scb->scsi_cmd->result = DID_RESET << 16;
 		scb->scsi_cmd->scsi_done(scb->scsi_cmd);
 		ips_freescb(ha, scb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (TRUE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (TRUE) {
 		sp = &ha->sp;
 
 		intrstatus = (*ha->func.isintr) (ha);
@@ -1321,6 +1392,12 @@ ips_intr_copperhead(ips_ha_t * ha)
 		 * NOTE: interrupts are OFF for this
--
 	}			/* end while */
 	return 1;
 }
@@ -2717,6 +2794,11 @@ ips_next(ips_ha_t * ha, int intr)
 	 */
 
--
 	while ((p) && (scb = ips_getscb(ha))) {
 		if ((scmd_channel(p) > 0)
 		    && (ha->
@@ -2824,6 +2906,12 @@ ips_next(ips_ha_t * ha, int intr)
 
 		p = (struct scsi_cmnd *) p->host_scribble;
--
 	}			/* end while */
 
 	if (intr == IPS_INTR_ON)
diff -u -p a/scsi/in2000.c b/scsi/in2000.c
--- a/scsi/in2000.c
+++ b/scsi/in2000.c
--
 	while (tmp) {
 		if (tmp == cmd) {
 			if (prev)
@@ -1709,6 +1714,12 @@ static int __in2000_abort(Scsi_Cmnd * cm
 		}
 		prev = tmp;
--
 		while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)", cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (Scsi_Cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)", cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (Scsi_Cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&cmds)) {
 		tcmd = list_entry(cmds.next, struct scsi_tgt_cmd, hash_list);
 		list_del(&tcmd->hash_list);
@@ -288,6 +293,12 @@ void scsi_tgt_free_queue(struct Scsi_Hos
 
 		shost->hostt->eh_abort_handler(cmd);
--
 	while (!done) {
 		/* Pull all the valid messages off the CRQ */
 		while ((crq = crq_queue_next_crq(&hostdata->queue)) != NULL) {
@@ -151,6 +156,12 @@ static void rpavscsi_task(void *data)
 		} else {
 			done = 1;
 		}
+		if (_cur < timeout) {
--
 	while (!list_empty(&hostdata->sent)) {
 		evt = list_first_entry(&hostdata->sent, struct srp_event_struct, list);
 		list_del(&evt->list);
@@ -494,6 +499,12 @@ static void purge_requests(struct ibmvsc
 			evt->done(evt);
 		free_event_struct(&evt->hostdata->pool, evt);
--
 	while (!done) {
 		/* Pull all the valid messages off the async CRQ */
 		while ((async = ibmvfc_next_async_crq(vhost)) != NULL) {
@@ -3172,6 +3177,12 @@ static void ibmvfc_tasklet(void *data)
 			wmb();
 		} else
 			done = 1;
+			if (_cur < timeout) {
--
 	while (!done) {
 		while ((crq = next_crq(&vport->crq_queue)) != NULL) {
 			process_crq(crq, target);
@@ -717,6 +722,12 @@ static void handle_crq(struct work_struc
 			crq->valid = 0x00;
 		} else
 			done = 1;
--
 	while((siop = ffz(sir)) < p->siops) {
 		sir |= 1<<siop;
 		ncr53c8xx_intr(irq, p->hosts[siop]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-   while (pDCB->TargetID != id || pDCB->TargetLUN != lun)
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
+     while (pDCB->TargetID != id || pDCB->TargetLUN != lun)
      {
 	pDCB = pDCB->pNextDCB;
 	if (pDCB == pACB->pLinkDCB)
 	     return NULL;
+	     if (_cur < timeout) {
--
-		while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
-		    spin_unlock_irq(pACB->pScsiHost->host_lock);
-		    udelay(50);
-		    spin_lock_irq(pACB->pScsiHost->host_lock);
+	    if (pSRB->SGToBeXferLen) {
+		    unsigned long long delta = (cpu / khz / HZ) * 2;
--
+		    while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
+		        spin_unlock_irq(pACB->pScsiHost->host_lock);
+		        udelay(50);
+		        spin_lock_irq(pACB->pScsiHost->host_lock);
+		        if (_cur < timeout) {
+		            rdstcll(_cur);
--
-		while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
-		    spin_unlock_irq(pACB->pScsiHost->host_lock);
-		    udelay(50);
-		    spin_lock_irq(pACB->pScsiHost->host_lock);
+	    if (pSRB->SGToBeXferLen) {
+		    unsigned long long delta = (cpu / khz / HZ) * 2;
--
+		    while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
+			    spin_unlock_irq(pACB->pScsiHost->host_lock);
+			    udelay(50);
+			    spin_lock_irq(pACB->pScsiHost->host_lock);
+			    if (_cur < timeout) {
+			        rdstcll(_cur);
--
 	    while( bval & 0x1f )
 	    {
 		DEBUG1(printk (KERN_DEBUG "Check for residuals,"));
@@ -882,6 +922,12 @@ dc390_DataIn_0(struct dc390_acb* pACB, s
 		}
 		else
--
 	while (pSRB->TotalXferredLen + (unsigned long) sg_dma_len(psgl) < pSRB->Saved_Ptr)
 	{
 	    pSRB->TotalXferredLen += (unsigned long) sg_dma_len(psgl);
@@ -1160,6 +1211,12 @@ dc390_restore_ptr (struct dc390_acb* pAC
 	    }
 	    else
--
-#define ACCEPT_MSG(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
+#define ACCEPT_MSG(port) {unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
--
-#define ACCEPT_MSG_ATN(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
+#define ACCEPT_MSG_ATN(port) {unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
--
 		while (RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST) {
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
--
 		while (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {
 			if (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {
 
 				WRW_HARPOON((port + hp_intstat), PHASE);
 				return;
 			}
--
 	while (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {
 		if (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {
 
 			WRW_HARPOON((port + hp_intstat), PHASE);
 			return;
 		}
--
 			while (!
 			       (RDW_HARPOON((port + hp_intstat)) &
 				(BUS_FREE | PHASE))) {
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
 			       (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))
 			{
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
 			       (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))
 			{
+				if (_cur < timeout) {
+				    rdstcll(_cur);
+				}
--
 	while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (!(RDW_HARPOON((port + hp_intstat)) & TIMEOUT)) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET)) &&
 	       (curr_phz ==
 		(RD_HARPOON(p_port + hp_scsisig) & (unsigned char)S_SCSI_PHZ)))
@@ -3783,6 +3909,12 @@ static void FPT_sxfrp(unsigned long p_po
 				WR_HARPOON(p_port + hp_fifodata_0, 0xFA);
 			}
--
 	while (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET))) {
@@ -3792,14 +3924,36 @@ static void FPT_sxfrp(unsigned long p_po
 
 	WR_HARPOON(p_port + hp_portctrl_0,
 		   (SCSI_PORT | HOST_PORT | SCSI_INBIT));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
--
 	while (!(RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY)) {
 		RD_HARPOON(p_port + hp_fifodata_0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 		while (!(RDW_HARPOON((p_port + hp_intstat)) & AUTO_INT)) {
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
--
 	while (RD_HARPOON(port + hp_scsisig) & SCSI_ACK) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 		while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | PHASE))) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
--
 		while ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) &&
 		       (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 			while ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY))
 			       && (RD_HARPOON(port + hp_ext_status) &
 				   BM_CMD_BUSY)) {
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while ((!(RD_HARPOON(p_port + hp_ext_status) & CMD_ABORTED))
 	       && timeout--) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 		while ((RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY)
 		       && timeout--) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 			while ((RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)
 			       && timeout--) {
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
--
 				while ((RD_HARPOON(port + hp_ext_status) &
 					BM_CMD_BUSY) && timeout--) {
+						if (_cur < timeout) {
+					rdstcll(_cur);
+						}
+						else {
--
 			while ((RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)
 			       && timeout--) {
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 		while (data_count < currSCCB->Sccb_ATC) {
 
 			sg_index++;
 			data_count += *(sg_ptr + (sg_index * 2));
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (RD_HARPOON(p_port + hp_scsisig) & (SCSI_SEL | SCSI_BSY)) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
--
 	while (!i) {
 
 		for (k = 0; k < ID_STRING_LENGTH; k++) {
@@ -5866,6 +6146,12 @@ static void FPT_scasid(unsigned char p_c
 			i = 1;
 		}
--
 	}			/*End while */
 
 	FPT_scxferc(p_port, SYNC_PTRN);
@@ -6181,8 +6467,19 @@ static unsigned char FPT_scsell(unsigned
 	WR_HARPOON(p_port + hp_autostart_3, (SELECT | CMD_ONLY_STRT));
 	WR_HARPOON(p_port + hp_scsictrl_0, (SEL_TAR | ENA_RESEL));
--
 	while (!(RDW_HARPOON((p_port + hp_intstat)) &
 		 (RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
-		while (!(RDW_HARPOON((p_port + hp_intstat)) & BUS_FREE)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!(RDW_HARPOON((p_port + hp_intstat)) & BUS_FREE)) {
 			if (RD_HARPOON(p_port + hp_scsisig) & SCSI_REQ) {
 				WR_HARPOON(p_port + hp_scsisig,
 					   (SCSI_ACK + S_ILL_PH));
 				ACCEPT_MSG(p_port);
 			}
--
 	while (!(RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL)) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 		while (((unsigned long)sg_index *
 			(unsigned long)SG_ELEMENT_SIZE) < p_SCCB->DataLength) {
 
 			partial_cnt += *(sg_ptr + (sg_index * 2));
 			sg_index++;
+			if (_cur < timeout) {
--
 	while (!kthread_should_stop()) {
 		schedule();
 		spin_lock_bh(&bg->fcoe_rx_list.lock);
@@ -471,6 +476,12 @@ static int bnx2fc_l2_rcv_thread(void *ar
 		}
 		__set_current_state(TASK_INTERRUPTIBLE);
--
 	while (!kthread_should_stop()) {
 		schedule();
 		spin_lock_bh(&p->fp_work_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (!list_empty(&p->work_list)) {
 			list_splice_init(&p->work_list, &work_list);
 			spin_unlock_bh(&p->fp_work_lock);
@@ -614,9 +635,21 @@ int bnx2fc_percpu_io_thread(void *arg)
 			}
 
--
-	while (sg_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (sg_len) {
 		if (sg_len >= BNX2FC_BD_SPLIT_SZ)
 			frag_size = BNX2FC_BD_SPLIT_SZ;
 		else
@@ -1598,6 +1603,12 @@ static int bnx2fc_split_bd(struct bnx2fc
 		addr += (u64) frag_size;
--
 	while (((wqe = cqe->wqe) & FCOE_CQE_TOGGLE_BIT) ==
 	       (tgt->cq_curr_toggle_bit <<
 	       FCOE_CQE_TOGGLE_BIT_SHIFT)) {
@@ -1071,6 +1076,12 @@ unlock:
 			tgt->cq_curr_toggle_bit =
 				1 - tgt->cq_curr_toggle_bit;
--
 	while (i < num_cqe) {
 		kcqe = (struct fcoe_kcqe *) kcq[i++];
 
@@ -1384,6 +1400,12 @@ void bnx2fc_indicate_kcqe(void *context,
 			printk(KERN_ERR PFX "unknown opcode 0x%x\n",
 								kcqe->op_code);
--
 	while (*pbl && *(pbl + 1)) {
 		u32 lo;
 		u32 hi;
@@ -2076,6 +2103,12 @@ static int bnx2fc_allocate_hash_table(st
 		hi = *pbl;
 		++pbl;
--
 	while (num_pages--) {
 		*pbl = (u32)page;
 		pbl++;
 		*pbl = (u32)((u64)page >> 32);
 		pbl++;
 		page += PAGE_SIZE;
--
 	while (num_pages--) {
 		*pbl = (u32)page;
 		pbl++;
 		*pbl = (u32)((u64)page >> 32);
 		pbl++;
 		page += PAGE_SIZE;
--
 	while (inb(iobase + REG_AUX_STATUS) & ABSY_ASSERTED) {
 		udelay(1L);
 		if (--loop == 0)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (!(inb(iobase + REG_STATUS) & DRQ_ASSERTED)) {
 			udelay(1L);
 			if (--loop == 0)
 				return 1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
-	while ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {
 		addr = pci_resource_start(dev, 0);
 
 #if defined(DEBUG_PCI_DETECT)
@@ -1048,6 +1075,12 @@ static struct pci_dev *get_pci_dev(unsig
 		pci_dev_put(dev);
--
-	while ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {
 #if defined(DEBUG_PCI_DETECT)
 		printk("%s: enable_pci_ports, bus %d, devfn 0x%x.\n",
 		       driver_name, dev->bus->number, dev->devfn);
@@ -1068,6 +1106,12 @@ static void enable_pci_ports(void)
 			printk
--
 	while (cur && (pc = strchr(cur, ':'))) {
 		int val = 0, c = *++pc;
 
@@ -1498,6 +1547,12 @@ static void internal_setup(char *str, in
 
 		if ((cur = strchr(cur, ',')))
--
 			while (ld(shpnt)[next_ldn(shpnt)].cmd) {	/* search for a occupied, but not in */
 				/* command-processing ldn. */
 				next_ldn(shpnt)++;
@@ -1745,6 +1750,12 @@ static int ibmmca_queuecommand_lck(Scsi_
 						done(cmd);
 					return 0;
--
 	while (!iscsi_tcp_segment_done(tcp_conn, segment, 0, r)) {
 		struct scatterlist *sg;
 		unsigned int offset, copy;
@@ -301,6 +306,12 @@ static int iscsi_sw_tcp_xmit_segment(str
 			return r;
 		}
--
 	while (iscsi_sw_tcp_xmit_qlen(conn)) {
 		rc = iscsi_sw_tcp_xmit(conn);
 		if (rc == 0)
 			return -EAGAIN;
 		if (rc < 0)
 			return rc;
--
 	while (reqlen) {
 		i = inb(base + PIO_STATUS);
 		/* VDEB(printk("pio_status=%x\n", i)); */
@@ -286,12 +291,29 @@ SYM53C500_pio_read(int fast_pio, int bas
 				request += len & 0xfc; 
 				reqlen -= len & 0xfc; 
--
 				while (len--) {
 					*request++ = inb(base + PIO_FIFO);
 					reqlen--;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 	while (reqlen && !(i & 0x40)) {
 		i = inb(base + PIO_STATUS);
 		/* VDEB(printk("pio_status=%x\n", i)); */
@@ -337,12 +364,29 @@ SYM53C500_pio_write(int fast_pio, int ba
 				request += len & 0xfc;
 				reqlen -= len & 0xfc;
--
 				while (len--) {
 					outb(*request++, base + PIO_FIFO);
 					reqlen--;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 		while (fifo && info->scsi.SCp.ptr) {
 			*info->scsi.SCp.ptr = fas216_readb(info, REG_FF);
 			fas216_updateptrs(info, 1);
 			fifo--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!info->internal_done) {
 		/*
 		 * If we don't have an IRQ, then we must poll the card for
@@ -2303,6 +2319,12 @@ static int fas216_noqueue_command_lck(st
 			fas216_intr(info);
 			spin_unlock_irq(info->host->host_lock);
--
   while(1)
   {
     int status;
     while (((status = readw(base + STAT)) & 0x100)==0);
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
--
-	while (time_before(jiffies, i) && !priv->qabort &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, i) && !priv->qabort &&
 					!((k = inb(qbase + 4)) & 0xe0)) {
 		barrier();
 		cpu_relax();
+		if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (len >= plen) {
 		rdata->spp_type = rspp->spp_type;
 		spp->spp_type = rspp->spp_type;
@@ -1765,6 +1770,12 @@ static void fc_rport_recv_prli_req(struc
 		len -= plen;
 		rspp = (struct fc_els_spp *)((char *)rspp + plen);
--
 	while (fc_exch_ptr_get(pool, index)) {
 		index = index == mp->pool_max_index ? 0 : index + 1;
 		if (index == pool->next_index)
 			goto err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (fc_cpu_mask < nr_cpu_ids) {
 		fc_cpu_mask <<= 1;
 		fc_cpu_order++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (hba->status_tail != hba->status_head) {
 		resp = stex_get_status(hba);
 		tag = le16_to_cpu(resp->tag);
@@ -846,6 +851,12 @@ static void stex_mu_intr(struct st_hba *
 			stex_scsi_done(ccb);
 		} else
--
 	while (count < hba->sts_count) {
 		scratch = hba->scratch + hba->status_tail;
 		value = le32_to_cpu(*scratch);
@@ -951,6 +967,12 @@ static void stex_ss_mu_intr(struct st_hb
 			stex_scsi_done(ccb);
 		} else
--
 	while (hba->ccb[tag].req_type & PASSTHRU_REQ_TYPE) {
 		if (time_after(jiffies, before + ST_INTERNAL_TIMEOUT * HZ)) {
 			hba->ccb[tag].req_type = 0;
 			return;
 		}
 		msleep(1);
--
-		while (!list_empty(&fc_host_rport_bindings(shost))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&fc_host_rport_bindings(shost))) {
 			get_list_head_entry(rport,
 				&fc_host_rport_bindings(shost), peers);
 			list_del(&rport->peers);
 			rport->port_state = FC_PORTSTATE_DELETED;
 			fc_queue_work(shost, &rport->rport_delete_work);
--
-	while (!list_empty(&conn->mgmtqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&conn->mgmtqueue)) {
 		conn->task = list_entry(conn->mgmtqueue.next,
 					 struct iscsi_task, running);
 		list_del_init(&conn->task->running);
@@ -1473,10 +1478,21 @@ check_mgmt:
 		rc = iscsi_xmit_task(conn);
--
-	while (!list_empty(&conn->cmdqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&conn->cmdqueue)) {
 		conn->task = list_entry(conn->cmdqueue.next, struct iscsi_task,
 					running);
 		list_del_init(&conn->task->running);
@@ -1505,6 +1521,12 @@ check_mgmt:
 		 */
--
 	while (!list_empty(&conn->requeue)) {
diff -u -p a/scsi/mvumi.c b/scsi/mvumi.c
--- a/scsi/mvumi.c
+++ b/scsi/mvumi.c
@@ -370,12 +370,23 @@ static void mvumi_free_cmds(struct mvumi
 {
--
-	while (!list_empty(&mhba->cmd_pool)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->cmd_pool)) {
 		cmd = list_first_entry(&mhba->cmd_pool, struct mvumi_cmd,
 							queue_pointer);
 		list_del(&cmd->queue_pointer);
 		kfree(cmd->frame);
 		kfree(cmd);
--
-	while (!list_empty(&mhba->cmd_pool)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->cmd_pool)) {
 		cmd = list_first_entry(&mhba->cmd_pool, struct mvumi_cmd,
 						queue_pointer);
 		list_del(&cmd->queue_pointer);
 		kfree(cmd->frame);
 		kfree(cmd);
--
-	while (!list_empty(&mhba->free_ob_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->free_ob_list)) {
 		pool = list_first_entry(&mhba->free_ob_list,
 						struct mvumi_ob_data, list);
 		list_del_init(&pool->list);
@@ -1307,6 +1334,12 @@ static void mvumi_handle_clob(struct mvu
 			mvumi_complete_cmd(mhba, cmd, ob_frame);
--
-	while (!list_empty(&mhba->waiting_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->waiting_req_list)) {
 		cmd = list_first_entry(&mhba->waiting_req_list,
 					 struct mvumi_cmd, queue_pointer);
 		list_del_init(&cmd->queue_pointer);
@@ -1395,6 +1433,12 @@ static void mvumi_fire_cmd(struct mvumi_
 
--
 	while (len) {
 		/*
 		 * even cntinfo could be up to 16383, without
@@ -86,6 +91,12 @@ void fill_hpc_entries(struct ip22_hostda
 		hcp++;
 		len -= count;
--
 	while (start < end) {
 		hcp->desc.pnext = (u32) (dma + sizeof(struct hpc_chunk));
 		hcp->desc.cntinfo = HPCDMA_EOX;
 		hcp++;
 		dma += sizeof(struct hpc_chunk);
 		start += sizeof(struct hpc_chunk);
--
 	while (sdev->device_busy) {
 		msleep_interruptible(200);
 		scsi_run_queue(sdev->request_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (reqlen) {
 		i = inb(PIO_STATUS);
 		/*    VDEB(printk("pio_status=%x\n", i)); */
@@ -387,12 +392,29 @@ static __inline__ int NCR53c406a_pio_rea
 				request += len & 0xfc;
 				reqlen -= len & 0xfc;
--
 				while (len--) {
 					*request++ = inb(PIO_FIFO);
 					reqlen--;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 	while (reqlen && !(i & 0x40)) {
 		i = inb(PIO_STATUS);
 		/*    VDEB(printk("pio_status=%x\n", i)); */
@@ -437,12 +464,29 @@ static __inline__ int NCR53c406a_pio_wri
 				request += len & 0xfc;
 				reqlen -= len & 0xfc;
--
 				while (len--) {
 					outb(*request++, PIO_FIFO);
 					reqlen--;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 	while (count){
 		*acb_firm_model = readb(iop_firm_model);
 		acb_firm_model++;
 		iop_firm_model++;
 		count--;
+		if (_cur < timeout) {
--
 	while (count){
 		*acb_firm_version = readb(iop_firm_version);
 		acb_firm_version++;
 		iop_firm_version++;
 		count--;
+		if (_cur < timeout) {
--
 	while(count){
 		*acb_device_map = readb(iop_device_map);
 		acb_device_map++;
 		iop_device_map++;
 		count--;
+		if (_cur < timeout) {
--
 	while (count) {
 		*acb_firm_model = readb(iop_firm_model);
 		acb_firm_model++;
 		iop_firm_model++;
 		count--;
+		if (_cur < timeout) {
--
 	while (count) {
 		*acb_firm_version = readb(iop_firm_version);
 		acb_firm_version++;
 		iop_firm_version++;
 		count--;
+		if (_cur < timeout) {
--
 	while (ms->phase == idle) {
 		prev = NULL;
 		for (cmd = ms->request_q; ; cmd = (struct scsi_cmnd *) cmd->host_scribble) {
@@ -583,6 +588,12 @@ static void mesh_start(struct mesh_state
 			ms->request_qtail = prev;
 
--
 	while(ms->phase != idle) {
 		spin_unlock_irqrestore(ms->host->host_lock, flags);
 		msleep(10);
 		spin_lock_irqsave(ms->host->host_lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while (!list_empty(&list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&list)) {
 		struct isci_request *ireq = list_entry(list.next, typeof(*ireq), dev_node);
 
 		/* Change state to "terminating" if it is currently
@@ -829,6 +834,12 @@ void isci_terminate_pending_requests(str
 		 */
--
-	while (
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (
 		NORMALIZE_GET_POINTER_CYCLE_BIT(get_cycle)
 		== COMPLETION_QUEUE_CYCLE_BIT(ihost->completion_queue[get_index])
 		) {
@@ -550,6 +555,12 @@ static void sci_controller_process_compl
 				 ent);
--
 		while (sg) {
 			scu_sg = to_sgl_element_pair(ireq, sg_idx);
 			init_sgl_element(&scu_sg->A, sg);
@@ -135,6 +140,12 @@ static void sci_request_build_sgl(struct
 
 			prev_sg = scu_sg;
--
 		while (i--) {
 			id = i / SCI_NUM_MSI_X_INT;
 			ihost = pci_info->hosts[id];
 			msix = &pci_info->msix_entries[i];
 			devm_free_irq(&pdev->dev, msix->vector, ihost);
+			if (_cur < timeout) {
--
 	while (fcnt--) {
 		esp->fifo[idx++] = esp_read8(ESP_FDATA);
 		esp->fifo[idx++] = esp_read8(ESP_FDATA);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((compl = be_mcc_compl_get(phba))) {
 		if (compl->flags & CQE_FLAGS_ASYNC_MASK) {
 			/* Interpret flags as an async trailer */
@@ -287,6 +292,12 @@ int beiscsi_process_mcc(struct beiscsi_h
 		}
 		be_mcc_compl_use(compl);
--
-	while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 				& EQE_VALID_MASK) {
 		if (((eqe->dw[offsetof(struct amap_eq_entry,
 		     resource_id) / 32] &
@@ -640,6 +645,12 @@ static irqreturn_t be_isr_mcc(int irq, v
 		queue_tail_inc(eq);
--
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 					& EQE_VALID_MASK) {
 			if (!blk_iopoll_sched_prep(&pbe_eq->iopoll))
 				blk_iopoll_sched(&pbe_eq->iopoll);
@@ -683,13 +699,24 @@ static irqreturn_t be_isr_msix(int irq,
 			queue_tail_inc(eq);
--
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 						& EQE_VALID_MASK) {
 			spin_lock_irqsave(&phba->isr_lock, flags);
 			phba->todo_cq = 1;
@@ -698,6 +725,12 @@ static irqreturn_t be_isr_msix(int irq,
 			queue_tail_inc(eq);
--
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 					& EQE_VALID_MASK) {
 			if (((eqe->dw[offsetof(struct amap_eq_entry,
 			     resource_id) / 32] &
@@ -767,6 +805,12 @@ static irqreturn_t be_isr(int irq, void
 			AMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);
--
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 						& EQE_VALID_MASK) {
 
 			if (((eqe->dw[offsetof(struct amap_eq_entry,
@@ -804,6 +853,12 @@ static irqreturn_t be_isr(int irq, void
 			queue_tail_inc(eq);
--
-	while ((*pep_read_ptr) != cq_index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((*pep_read_ptr) != cq_index) {
 		(*pep_read_ptr)++;
 		*pep_read_ptr = (*pep_read_ptr) % num_entries;
 
@@ -1477,6 +1537,12 @@ hwi_update_async_writables(struct hwi_as
 		}
--
-	while (mcc_compl->flags & CQE_FLAGS_VALID_MASK) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (mcc_compl->flags & CQE_FLAGS_VALID_MASK) {
 
 		if (num_processed >= 32) {
 			hwi_ring_cq_db(phba, mcc_cq->id,
@@ -1810,6 +1881,12 @@ static void  beiscsi_process_mcc_isr(str
 		mcc_compl = queue_tail_node(mcc_cq);
--
 	while (sol->dw[offsetof(struct amap_sol_cqe, valid) / 32] &
 	       CQE_VALID_MASK) {
 		be_dws_le_to_cpu(sol, sizeof(struct sol_cqe));
@@ -1949,6 +2031,12 @@ static unsigned int beiscsi_process_cq(s
 		queue_tail_inc(cq);
 		sol = queue_tail_node(cq);
--
 	while ((i) || (j)) {
 		for (j = mem_descr->num_elements; j > 0; j--) {
 			pci_free_consistent(phba->pcidev,
@@ -2310,6 +2403,12 @@ free_mem:
 			kfree(mem_descr->mem_array);
 			mem_descr--;
--
 	while (idx < mem_descr_sglh->num_elements) {
 		psgl_handle = mem_descr_sglh->mem_array[idx].virtual_address;
 
@@ -3349,6 +3453,12 @@ static int beiscsi_init_sgl_handle(struc
 			psgl_handle++;
 		}
--
 	while (idx < mem_descr_sg->num_elements) {
 		pfrag = mem_descr_sg->mem_array[idx].virtual_address;
 
@@ -3381,6 +3496,12 @@ static int beiscsi_init_sgl_handle(struc
 				phba->fw_config.iscsi_icd_start + arr_index++;
 		}
--
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 					& EQE_VALID_MASK) {
 			AMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);
 			queue_tail_inc(eq);
 			eqe = queue_tail_node(eq);
 			num_processed++;
--
 		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
 		{
 			// FIXME - no timeout
-		}
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while ( !( HostDiag & DIAG_WRITE_ENABLE) ) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ( !( HostDiag & DIAG_WRITE_ENABLE) ) {
 		msleep(100);
 		HostDiag = (u32)readl(hostdiag_offset);
 		printk(KERN_NOTICE "RESETGEN2: retry=%x, hostdiag=%x\n",
@@ -780,6 +785,12 @@ megasas_adp_reset_gen2(struct megasas_in
 		if (retry++ >= 100)
--
-	while ( ( HostDiag & DIAG_RESET_ADAPTER) ) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ( ( HostDiag & DIAG_RESET_ADAPTER) ) {
 		msleep(100);
 		HostDiag = (u32)readl(hostdiag_offset);
 		printk(KERN_NOTICE "RESET_GEN2: retry=%x, hostdiag=%x\n",
@@ -798,6 +814,12 @@ megasas_adp_reset_gen2(struct megasas_in
 		if (retry++ >= 1000)
--
-	while (consumer != producer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (consumer != producer) {
 		context = instance->reply_queue[consumer];
 		if (context >= instance->max_fw_cmds) {
 			printk(KERN_ERR "Unexpected context value %x\n",
@@ -1668,6 +1695,12 @@ static void megasas_complete_cmd_dpc(uns
 		if (consumer == (instance->max_fw_cmds + 1)) {
--
-		while (!list_empty(&clist_local)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&clist_local)) {
 			reset_cmd	= list_entry((&clist_local)->next,
 						struct megasas_cmd, list);
 			list_del_init(&reset_cmd->list);
@@ -1780,6 +1818,12 @@ static int megasas_wait_for_outstanding(
 					reset_cmd);
--
-	while (!list_empty(&clist_local)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&clist_local)) {
 		cmd	= list_entry((&clist_local)->next,
 					struct megasas_cmd, list);
 		list_del_init(&cmd->list);
@@ -2393,6 +2442,12 @@ megasas_issue_pending_cmds_again(struct
 				"internal reset defer list while re-issue!!\n",
 				cmd);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&adapter->pend_list)) {
 
 		assert_spin_locked(PENDING_LIST_LOCK(adapter));
@@ -1964,6 +1969,12 @@ megaraid_mbox_runpendq(adapter_t *adapte
 		}
 
--
 				while ( !flag && time_before(jiffies, startwait + 60*HZ) ) {
 
 					memset(cmd, 0, MAX_COMMAND_SIZE);
@@ -1621,6 +1626,12 @@ static int osst_read_back_buffer_and_rew
 					if (STp->buffer->syscall_result)
 						flag = 1;
--
 	while (cnt != mt_count) {
 		last_mark_ppos = ntohl(STp->buffer->aux->last_mark_ppos);
 		if (last_mark_ppos == -1)
@@ -1927,7 +1943,13 @@ static int osst_space_over_filemarks_bac
 					 name, last_mark_ppos);
 			return (-EIO);
--
 		while (cnt != mt_count) {
 			next_mark_ppos = ntohl(STp->buffer->aux->next_mark_ppos);
 			if (!next_mark_ppos || next_mark_ppos > STp->eod_frame_ppos) {
@@ -2132,6 +2159,12 @@ static int osst_space_over_filemarks_for
 						 name, next_mark_ppos);
 				return (-EIO);
--
 	while (count--) {
 		memcpy(STp->buffer->b_data, "Filler", 6);
 		STp->buffer->buffer_bytes = 6;
@@ -2250,6 +2288,12 @@ static int osst_write_filler(struct osst
 			printk(KERN_INFO "%s:I: Couldn't write filler frame\n", name);
 			return (-EIO);
--
 	while (count--) {
 		osst_copy_to_buffer(STp->buffer, (unsigned char *)STp->header_cache);
 		STp->buffer->buffer_bytes = sizeof(os_header_t);
@@ -2276,6 +2325,12 @@ static int __osst_write_header(struct os
 			printk(KERN_INFO "%s:I: Couldn't write header frame\n", name);
 			return (-EIO);
--
 	while ((STp->buffer)->buffer_bytes + count > write_threshold)
 	{
 		doing_write = 1;
@@ -3634,6 +3694,12 @@ if (SRpnt) printk(KERN_ERR "%s:A: Not su
 		}
 		STp->buffer->buffer_bytes = 0;
--
 	}  /* end while write threshold exceeded */
 
 	if (count != 0) {
diff -u -p a/scsi/fcoe/fcoe.c b/scsi/fcoe/fcoe.c
--- a/scsi/fcoe/fcoe.c
+++ b/scsi/fcoe/fcoe.c
--
 	while (!kthread_should_stop()) {
 
 		spin_lock_bh(&p->fcoe_rx_list.lock);
@@ -1749,6 +1754,12 @@ int fcoe_percpu_receive_thread(void *arg
 		}
 		spin_unlock_bh(&p->fcoe_rx_list.lock);
--
 	while (--loop_count && (sbus_readw(qpti->qregs + HCCTRL) & HCCTRL_HIRQ)) {
 		barrier();
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (out_ptr != in_ptr) {
 		u_int cmd_slot;
 
@@ -1184,6 +1200,12 @@ static struct scsi_cmnd *qlogicpti_intr_
 		sbus_writew(out_ptr, qpti->qregs + MBOX5);
 		Cmnd->host_scribble = (unsigned char *) done_queue;
--
 	while (!time_after_eq(jiffies, wtime)) {
 		spin_lock_irqsave(&ha->hardware_lock, flags);
 		/* Find a command that hasn't completed. */
@@ -2219,6 +2224,12 @@ static int qla4xxx_cmd_wait(struct scsi_
 			return QLA_SUCCESS;
 
--
 	while (time_before(jiffies, wait_online)) {
 
 		if (adapter_up(ha))
 			return QLA_SUCCESS;
 
 		msleep(2000);
--
 	while (1) {
 		qla4_8xxx_idc_lock(ha);
 
@@ -1860,6 +1865,12 @@ int qla4_8xxx_device_state_handler(struc
 			rval = QLA_ERROR;
 			goto exit;
--
 	while (ha->aen_out != ha->aen_in) {
 		aen = &ha->aen_q[ha->aen_out];
 		/* copy aen information to local structure */
@@ -1083,6 +1088,12 @@ void qla4xxx_process_aen(struct scsi_qla
 			}
 		}
--
 	while (drvr_wait) {
 		if (ql4xxx_lock_drvr(a) == 0) {
 			ssleep(QL4_LOCK_DRVR_SLEEP);
@@ -645,6 +650,12 @@ int ql4xxx_lock_drvr_wait(struct scsi_ql
 				      "acquired\n", a->host_no, __func__));
 			return QLA_SUCCESS;
--
 	while (!kthread_should_stop() &&
 	       !list_empty(&core->task_queue)) {
 
@@ -907,6 +912,12 @@ static void sas_queue(struct sas_ha_stru
 			list_splice_init(&q, &core->task_queue); /*at head*/
 			core->task_queue_size += can_queue;
--
 	while (delay < max_delay) {
 		pcii_reg = readl(ioa_cfg->regs.sense_interrupt_reg);
 
@@ -2582,6 +2587,12 @@ static int ipr_wait_iodbg_ack(struct ipr
 			udelay(delay);
 
--
 	while (bytes_copied < length &&
 	       (ioa_dump->hdr.len + bytes_copied) < max_dump_size) {
 		if (ioa_dump->page_offset >= PAGE_SIZE ||
@@ -2768,6 +2784,12 @@ static int ipr_sdt_copy(struct ipr_ioa_c
 			break;
 		}
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count) {
 		if ((off & PAGE_MASK) != ((off + count) & PAGE_MASK))
 			len = PAGE_ALIGN(off) - off;
 		else
@@ -3926,6 +3975,12 @@ static ssize_t ipr_read_dump(struct file
 		buf += len;
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		ipr_cmd = NULL;
 
-		while ((be32_to_cpu(*ioa_cfg->hrrq_curr) & IPR_HRRQ_TOGGLE_BIT) ==
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((be32_to_cpu(*ioa_cfg->hrrq_curr) & IPR_HRRQ_TOGGLE_BIT) ==
 		       ioa_cfg->toggle_bit) {
 
 			cmd_index = (be32_to_cpu(*ioa_cfg->hrrq_curr) &
@@ -5139,6 +5215,12 @@ static irqreturn_t ipr_isr(int irq, void
 				ioa_cfg->hrrq_curr = ioa_cfg->hrrq_start;
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (length) {
 		if (IPR_GET_MODE_PAGE_CODE(mode_hdr) == page_code) {
 			if (mode_hdr->page_length >= (len - sizeof(struct ipr_mode_page_hdr)))
@@ -6512,6 +6627,12 @@ static void *ipr_get_mode_page(struct ip
 			mode_hdr = (struct ipr_mode_page_hdr *)
 				((unsigned long)mode_hdr + page_length);
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!found) {
 		if (sizeof(dma_addr_t) > 4) {
 			regh = readl(TWL_HOBQPH_REG_ADDR(tw_dev));
@@ -583,6 +588,12 @@ static int twl_poll_response(TW_Device_E
 			goto out;
 
--
 	while (reg & TWL_HISTATUS_RESPONSE_INTERRUPT) {
 		if (sizeof(dma_addr_t) > 4) {
 			regh = readl(TWL_HOBQPH_REG_ADDR(tw_dev));
@@ -1274,6 +1290,12 @@ static irqreturn_t twl_interrupt(int irq
 
 		/* Check for another response interrupt */
--
-        while ((reg_value & value) != result) {
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+	while ((reg_value & value) != result) {
 		reg_value = readl(reg);
 		if (time_after(jiffies, before + HZ * seconds))
 			goto out;
 		msleep(50);
+		if (_cur < timeout) {
--
 	while (&devinfo_table->scsi_dev_info_list == dl->bottom) {
 		dl->top = dl->top->next;
 		if (dl->top == &scsi_dev_info_list) {
@@ -692,6 +697,12 @@ static void *devinfo_seq_next(struct seq
 					   struct scsi_dev_info_list_table,
 					   node);
--
 	while (pdev) {
 		struct domain_device *pdev_p = pdev->parent;
 		if (!pdev_p)
 			return pdev->port->id;
 		pdev = pdev->parent;
+		if (_cur < timeout) {
--
 	while (skb->len >= NLMSG_SPACE(0)) {
 		err = 0;
 
@@ -147,6 +152,12 @@ next_msg:
 			netlink_ack(skb, nlh, err);
 
--
-	while (skb) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (skb) {
 		int frags = skb_shinfo(skb)->nr_frags +
 				(skb->len != skb->data_len);
 
@@ -914,7 +919,13 @@ static int cxgbi_sock_send_pdus(struct c
 		csk->write_seq += skb->len +
--
 	while (i < ddp->nppods) {
 		struct cxgbi_gather_list *gl = ddp->gl_map[i];
 
@@ -1348,6 +1364,12 @@ static void ddp_destroy(struct kref *kre
 			i += npods;
 		} else
--
 	while (i < h->ndevices) {
 		csd = h->dev[i];
 		device_change = hpsa_scsi_find_entry(csd, sd, nsds, &entry);
@@ -906,6 +911,12 @@ static void adjust_hpsa_scsi_table(struc
 			sd[entry] = NULL;
 		}
--
 	while (left) {
 		sz = (left > ioc->malloc_size) ? ioc->malloc_size : left;
 		buff_size[sg_used] = sz;
@@ -2777,6 +2793,12 @@ static int hpsa_big_passthru_ioctl(struc
 		left -= sz;
 		data_ptr += sz;
--
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
 		while (raw_tag != FIFO_EMPTY)
 			raw_tag = next_command(h);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
 		while (raw_tag != FIFO_EMPTY) {
@@ -3217,6 +3255,12 @@ static irqreturn_t do_hpsa_intr_intx(int
 			else
 				raw_tag = process_nonindexed_cmd(h, raw_tag);
 		}
+		if (_cur < timeout) {
--
 	while (!list_empty(list)) {
 		c = list_entry(list->next, struct CommandList, list);
 		c->err_info->CommandStatus = CMD_HARDWARE_ERR;
 		finish_cmd(c, c->Header.Tag.lower);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (qinpos != qintail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (qinpos != qintail) {
 		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinpos]);
 		if (scb == NULL) {
 			printk("qinpos = %d, SCB index = %d\n",
@@ -5944,6 +5949,12 @@ ahc_search_qinfifo(struct ahc_softc *ahc
 			prev_scb = scb;
--
 	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
 
 		if (cur_patch->patch_func(ahc) == 0) {
@@ -6982,6 +6998,12 @@ ahc_check_patch(struct ahc_softc *ahc, c
 			 */
 			cur_patch++;
--
 	while (qinpos != qintail) {
 		printk("%d ", ahc->qinfifo[qinpos]);
 		qinpos++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 		while (line < cur_instr->srcline) {
 			fgets(buf, sizeof(buf), ifile);
 				fprintf(listfile, "             \t%s", buf);
 				line++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!SCBID_IS_NULL(scbid)) {
 		uint8_t *hscb_ptr;
 		u_int	 i;
@@ -1349,11 +1354,22 @@ rescan_fifos:
 
 		ahd_complete_scb(ahd, scb);
--
 	while (!SCBID_IS_NULL(scbid)) {
 
 		ahd_set_scbptr(ahd, scbid);
@@ -1367,10 +1383,21 @@ rescan_fifos:
 
 		ahd_complete_scb(ahd, scb);
--
 	while (!SCBID_IS_NULL(scbid)) {
 
 		ahd_set_scbptr(ahd, scbid);
@@ -1384,6 +1411,12 @@ rescan_fifos:
 
 		ahd_complete_scb(ahd, scb);
--
-	while (qinpos != qintail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (qinpos != qintail) {
 		scb = ahd_lookup_scb(ahd, ahd->qinfifo[qinpos]);
 		if (scb == NULL) {
 			printk("qinpos = %d, SCB index = %d\n",
@@ -8283,6 +8321,12 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 			prev_scb = scb;
--
 	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
 
 		if (cur_patch->patch_func(ahd) == 0) {
@@ -9534,6 +9583,12 @@ ahd_check_patch(struct ahd_softc *ahd, c
 			 */
 			cur_patch++;
--
 	while (1) {
 		int i;
 
@@ -9672,6 +9732,12 @@ ahd_probe_stack_size(struct ahd_softc *a
 				goto sized;
 		}
--
 	while (!done) {
 		switch (*opt_arg) {
 		case '{':
@@ -1129,6 +1134,12 @@ ahd_parse_brace_option(char *opt_name, c
 			opt_arg = tok_end;
 			break;
--
 	while (!done) {
 		switch (*opt_arg) {
 		case '{':
@@ -1018,6 +1023,12 @@ ahc_parse_brace_option(char *opt_name, c
 			opt_arg = tok_end;
 			break;
--
 	while (!list_empty(&adapter_list)) {
 		hba = list_entry(adapter_list.next, struct bnx2i_hba, link);
 		list_del(&hba->link);
@@ -548,6 +553,12 @@ static void __exit bnx2i_mod_exit(void)
 		}
 
--
 		while (buf_off >= (cur_offset + bd_tbl->buffer_length)) {
 			cur_offset += bd_tbl->buffer_length;
 			cur_bd_idx++;
 			bd_tbl++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (lpcnt--) {
 		memcpy(&dword, (const void *) srcp, 4);
 		*dstp = cpu_to_be32(dword);
 		srcp += 4;
 		dstp++;
+		if (_cur < timeout) {
--
 	while (val) {
 		val = val >> 1;
 		power++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (num_pages--) {
 		if (cnic_dev_10g) {
 			/* PTE is written in little endian format for 57710 */
@@ -983,6 +999,12 @@ static void setup_qp_page_tables(struct
 			ptbl++;
 			page += PAGE_SIZE;
--
 	while (num_pages--) {
 		if (cnic_dev_10g) {
 			/* PTE is written in little endian format for 57710 */
@@ -1011,6 +1038,12 @@ static void setup_qp_page_tables(struct
 			ptbl++;
 			page += PAGE_SIZE;
--
 	while (num_pages--) {
 		if (cnic_dev_10g) {
 			/* PTE is written in little endian format for 57710 */
@@ -1039,6 +1077,12 @@ static void setup_qp_page_tables(struct
 			ptbl++;
 			page += PAGE_SIZE;
--
 	while (!kthread_should_stop()) {
 		spin_lock_bh(&p->p_work_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (!list_empty(&p->work_list)) {
 			list_splice_init(&p->work_list, &work_list);
 			spin_unlock_bh(&p->p_work_lock);
@@ -1873,10 +1927,22 @@ int bnx2i_percpu_io_thread(void *arg)
 				kfree(work);
 			}
--
 	while (i < num_cqe) {
 		ikcqe = (struct iscsi_kcqe *) kcqe[i++];
 
@@ -2517,6 +2588,12 @@ static void bnx2i_indicate_kcqe(void *co
 		else
 			printk(KERN_ALERT "bnx2i: unknown opcode 0x%x\n",
--
 	while (!list_empty(done_q)) {
 		sp = list_entry(done_q->next, struct srb, list);
 
@@ -1319,6 +1324,12 @@ qla1280_done(struct scsi_qla_host *ha)
 			(*(cmd)->scsi_done)(cmd);
 		else
--
-	while (ha->rsp_ring_index != mailbox[5]) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ha->rsp_ring_index != mailbox[5]) {
 		pkt = ha->response_ring_ptr;
 
 		dprintk(5, "qla1280_isr: ha->rsp_ring_index = 0x%x, mailbox[5]"
@@ -3626,6 +3642,12 @@ qla1280_isr(struct scsi_qla_host *ha, st
 				ha->response_ring_ptr++;
--
 		while (ha->flags.reset_marker) {
 			/* Issue marker command. */
 			ha->flags.reset_marker = 0;
@@ -3660,6 +3687,12 @@ qla1280_rst_aen(struct scsi_qla_host *ha
 						       MK_SYNC_ALL);
 				}
--
 	while (cp && (ptr = strchr(cp, ':'))) {
 		ptr++;
 		if (!strcmp(ptr, "yes")) {
@@ -4184,6 +4222,12 @@ qla1280_setup(char *s)
 		else {
 			break;
--
 		while (offset < len) {
 			u8 page_code = buffer[offset] & 0x3F;
 			u8 spf       = buffer[offset] & 0x40;
@@ -2134,6 +2139,12 @@ sd_read_cache_type(struct scsi_disk *sdk
 					goto defaults;
 				}
--
 		while (entry != &dev->fib_list) {
 			context = list_entry(entry, struct aac_fib_context, next);
 			if (context->unique == fibctx->unique) {
@@ -216,6 +221,12 @@ static int open_getadapter_fib(struct aa
 			} else {
 				entry = entry->next;
--
 	while (!list_empty(&fibctx->fib_list)) {
 		struct list_head * entry;
 		/*
@@ -358,6 +374,12 @@ int aac_close_fib_context(struct aac_dev
 		 */
 		kfree(fib->hw_fib_va);
--
 	while (!((status = src_readl(dev, MUnit.OMR)) &
 		KERNEL_UP_AND_RUNNING)) {
 		if ((restart &&
@@ -535,6 +540,12 @@ int aac_src_init(struct aac_dev *dev)
 			++restart;
 		}
--
 	while (!((status = rx_readl(dev, MUnit.OMRx[0])) & KERNEL_UP_AND_RUNNING))
 	{
 		if ((restart &&
@@ -618,6 +623,12 @@ int _aac_rx_init(struct aac_dev *dev)
 			++restart;
 		}
--
 	while(aac_consumer_get(dev, q, &entry))
 	{
 		int fast;
@@ -147,6 +152,12 @@ unsigned int aac_response_normal(struct
 		}
 		consumed++;
--
 	while(aac_consumer_get(dev, q, &entry))
 	{
 		struct fib fibctx;
@@ -224,6 +240,12 @@ unsigned int aac_command_normal(struct a
 			aac_fib_adapter_complete(fib, sizeof(u32));
 			spin_lock_irqsave(q->lock, flags);
--
-	while (!(sa_readl(dev, Mailbox7) & KERNEL_UP_AND_RUNNING)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(sa_readl(dev, Mailbox7) & KERNEL_UP_AND_RUNNING)) {
 		if (time_after(jiffies, start+startup_timeout*HZ)) {
 			status = sa_readl(dev, Mailbox7);
 			printk(KERN_WARNING "%s%d: adapter kernel failed to start, init status = %lx.\n", 
@@ -359,6 +364,12 @@ int aac_sa_init(struct aac_dev *dev)
 			goto error_iounmap;
--
         while (nscp && gdth_cmnd_priv(nscp)->priority <= priority) {
             pscp = nscp;
             nscp = (Scsi_Cmnd *)pscp->SCp.ptr;
+            if (_cur < timeout) {
+                rdstcll(_cur);
+            }
--
 	while ((pDev = pci_get_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
 		if(pDev->device == PCI_DPT_DEVICE_ID ||
 		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
@@ -206,6 +211,12 @@ static int adpt_detect(struct scsi_host_
 			}
 			pci_dev_get(pDev);
--
 			while(d){
 				len += sprintf(buffer+len,"\t%-24.24s", d->pScsi_dev->vendor);
 				len += sprintf(buffer+len," Rev: %-8.8s\n", d->pScsi_dev->rev);
@@ -653,6 +669,12 @@ static int adpt_proc_info(struct Scsi_Ho
 				}
 
--
 		while(sg_index) {
 			if(sg_list[--sg_index]) {
 				dma_free_coherent(&pHba->pDev->dev,
@@ -1978,6 +2005,12 @@ cleanup:
 					sg_list[sg_index],
 					sg[sg_index].addr_bus);
--
 	while( readl(pHba->irq_mask) & I2O_INTERRUPT_PENDING_B) {
 		m = readl(pHba->reply_port);
 		if(m == EMPTY_QUEUE){
@@ -2295,6 +2333,12 @@ static irqreturn_t adpt_isr(int irq, voi
 		writel(m, pHba->reply_port);
 		wmb();
--
 					while (pDev->next_lun) {
 						pDev = pDev->next_lun;
+						if (_cur < timeout) {
+					rdstcll(_cur);
+						}
+						else {
--
 		while (data & NVR_BUSY) {
 			udelay(100);
 			data = RD_REG_WORD(&reg->nvram);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while ((iter < iend) && !do_next) {
 			iter++;
 			if (qla2x00_read_flash_byte(ha, iter) == '/') {
@@ -2502,16 +2518,33 @@ qla2x00_get_fcode_version(struct qla_hw_
 				    iter + 3) == '/')
 					do_next++;
--
 		while ((iter > istart) && !do_next) {
 			iter--;
 			if (qla2x00_read_flash_byte(ha, iter) == ' ')
 				do_next++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while ((iter > istart) && !do_next) {
 			iter--;
 			rbyte = qla2x00_read_flash_byte(ha, iter);
 			if (rbyte == ' ' || rbyte == 0xd || rbyte == 0x10)
 				do_next++;
+				if (_cur < timeout) {
--
 			while (iter <= vend) {
 				*vbyte++ = qla2x00_read_flash_byte(ha, iter);
 				iter++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-	while (tot_dsds) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tot_dsds) {
 		avail_dsds = (tot_dsds > QLA_DSDS_PER_IOCB) ?
 		    QLA_DSDS_PER_IOCB : tot_dsds;
 		tot_dsds -= avail_dsds;
@@ -2616,6 +2621,11 @@ qla2xx_build_scsi_type_6_iocbs(srb_t *sp
 			*cur_dsd++ = cpu_to_le32(dsd_list_len);
--
 		while (avail_dsds) {
 			dma_addr_t	sle_dma;
 
@@ -2625,6 +2635,18 @@ qla2xx_build_scsi_type_6_iocbs(srb_t *sp
 			*cur_dsd++ = cpu_to_le32(sg_dma_len(cur_seg));
 			cur_seg = sg_next(cur_seg);
--
-		while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
 			WRT_REG_DWORD(
 				(unsigned long __iomem *)ha->nxdb_wr_ptr,
 				dbval);
 			wmb();
+			if (_cur < timeout) {
--
-		while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
 			WRT_REG_DWORD((unsigned long  __iomem *)ha->nxdb_wr_ptr,
 				dbval);
 			wmb();
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (drv_state != drv_active) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (drv_state != drv_active) {
 
 		if (time_after_eq(jiffies, reset_timeout)) {
 			/* quiescence timeout, other functions didn't ack
@@ -3468,6 +3517,12 @@ qla82xx_need_qsnt_handler(scsi_qla_host_
 		drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
--
 	while (vha->rscn_out_ptr != vha->rscn_in_ptr ||
 	    vha->flags.rscn_queue_overflow) {
 
@@ -3588,6 +3593,12 @@ qla2x00_device_resync(scsi_qla_host_t *v
 				}
 			}
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		memcpy(sfp, &image->field_info, sizeof(image->field_info));
 		rval = qla2x00_write_sfp(vha, sfp_dma, sfp,
 		    image->field_address.device, image->field_address.offset,
@@ -1482,6 +1487,12 @@ qla2x00_update_fru_versions(struct fc_bs
 			goto dealloc;
--
-			while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
 				WRT_REG_DWORD((unsigned long __iomem *)
 					ha->nxdb_wr_ptr, dbval);
 				wmb();
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (qla24xx_get_one_block_sg(prot_int, &sgx, &partial)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (qla24xx_get_one_block_sg(prot_int, &sgx, &partial)) {
 
 		sle_dma = sgx.dma_addr;
 		sle_dma_len = sgx.dma_len;
@@ -940,6 +956,12 @@ alloc_and_fill:
 			partial = 1; /* So as to not re-enter this block */
--
 	while (CMD_SP(cmd) && wait_iter--) {
 		msleep(ABORT_POLLING_PERIOD);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
 	while (((test_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags)) ||
 	    test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags) ||
 	    test_bit(ISP_ABORT_RETRY, &base_vha->dpc_flags) ||
 	    ha->dpc_active) && time_before(jiffies, wait_online)) {
 
 		msleep(1000);
--
 	while (ha->cur_vport_count) {
 		struct Scsi_Host *scsi_host;
 
@@ -2502,6 +2529,12 @@ qla2x00_remove_one(struct pci_dev *pdev)
 		scsi_host_put(vha->host);
 
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		ql_dbg(ql_dbg_dpc, base_vha, 0x4000,
 		    "DPC handler sleeping.\n");
 
@@ -3623,6 +3661,12 @@ qla2x00_do_dpc(void *data)
 
--
 	} /* End of while(1) */
 	__set_current_state(TASK_RUNNING);
 
diff -u -p a/scsi/qla2xxx/qla_mid.c b/scsi/qla2xxx/qla_mid.c
--- a/scsi/qla2xxx/qla_mid.c
+++ b/scsi/qla2xxx/qla_mid.c
--
 	while (atomic_read(&vha->vref_count)) {
 		spin_unlock_irqrestore(&ha->vport_slock, flags);
 
 		msleep(500);
 
 		spin_lock_irqsave(&ha->vport_slock, flags);
--
 	while (lba < end) {
 		sector_t block, rem;
 
@@ -2028,6 +2033,12 @@ static void map_region(sector_t lba, uns
 			set_bit(block, map_storep);
 
--
 	while (lba < end) {
 		sector_t block, rem;
 
@@ -2049,6 +2065,12 @@ static void unmap_region(sector_t lba, u
 			clear_bit(block, map_storep);
 
--
-   while (inb(iobase + REG_LCL_INTR) & BSY_ASSERTED) {
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (inb(iobase + REG_LCL_INTR) & BSY_ASSERTED) {
       udelay(1L);
       if (--loop == 0) return TRUE;
+      if (_cur < timeout) {
+            rdstcll(_cur);
+      }
--
    while (cur && (pc = strchr(cur, ':'))) {
       int val = 0, c = *++pc;
 
@@ -1061,6 +1077,12 @@ static void internal_setup(char *str, in
       else if (!strncmp(cur, "et:", 3))  ext_tran = val;
 
--
-	while (i != np->squeueput) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (i != np->squeueput) {
 		cp = sym_ccb_from_dsa(np, scr_to_cpu(np->squeue[i]));
 		assert(cp);
 #ifdef SYM_CONF_IARB_SUPPORT
@@ -3010,6 +3015,12 @@ sym_dequeue_from_squeue(struct sym_hcb *
 			if ((j += 2) >= MAX_QUEUE*2) j = 0;
--
 	while (size > s) {
 		s <<= 1;
 		++i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (j > i) {
 			j -= 1;
 			s >>= 1;
 			h[j].next = (m_link_p) (a+s);
 			h[j].next->next = NULL;
+			if (_cur < timeout) {
--
 	while (size > s) {
 		s <<= 1;
 		++i;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 		while (q->next && q->next != (m_link_p) b) {
 			q = q->next;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
--
 	while (len < memsize) {
 		AdvWriteWordAutoIncLram(iop_base, 0);
 		len += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (TRUE) {
 		AscSetChipEEPData(iop_base, data_reg);
 		mdelay(1);
@@ -9912,6 +9928,12 @@ static int __devinit AscWriteEEPDataReg(
 		if (retry++ > ASC_EEP_MAX_RETRY) {
 			return (0);
--
 	while (board->adv_sgblkp) {
 		adv_sgblk_t *sgp = board->adv_sgblkp;
 		board->adv_sgblkp = sgp->next_sgblkp;
 		kfree(sgp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (sector_addr < flash_addr+size) {
 		switch (asd_ha->hw_prof.flash.method) {
 		case FLASH_METHOD_A:
@@ -1306,6 +1311,12 @@ int asd_erase_nv_sector(struct asd_ha_st
 			return FAIL_ERASE_FLASH;
 
--
 	while ((l1 || l2) && cnt) {
 
 		if (l1) {
@@ -899,6 +904,12 @@ static enum BC_STATUS crystalhd_stop_tx_
 		msleep_interruptible(100);
 
--
 	while ((l0y || l0uv || l1y || l1uv) && count) {
 
 		if (l0y) {
@@ -1160,6 +1176,12 @@ static void crystalhd_stop_rx_dma_engine
 		}
 		msleep_interruptible(100);
--
 	while (reg_data != BC_BIT(4)) {
 		reg_data = crystalhd_reg_rd(adp, DCI_STATUS);
 		reg_data &= BC_BIT(4);
@@ -1657,6 +1684,12 @@ enum BC_STATUS crystalhd_download_fw(str
 			BCMLOG_ERR("Firmware Download RDY Timeout.\n");
 			return BC_STS_TIMEOUT;
--
 	while (reg_queue) {
 		if (reg_queue == reg->reg_last)
 			reg->reg_last = NULL;
@@ -521,6 +526,12 @@ void Wb35Reg_destroy(struct hw_data *pHw
 		spin_lock_irq(&reg->EP0VM_spin_lock);
 
--
 	while (SizeLeft) {
 		pT00 = (struct T00_descriptor *)buffer;
 		CopySize = SizeLeft;
@@ -235,6 +240,11 @@ static u16 Mds_BodyCopy(struct wbsoft_pr
 		stmp &= ~0x03; /* 4n Alignment */
 		Size += stmp; /* Current 4n offset of mpdu */
--
 		while (CopySize) {
 			/* Copy body */
 			src_buffer = pDes->buffer_address[buf_index];
@@ -255,6 +265,12 @@ static u16 Mds_BodyCopy(struct wbsoft_pr
 			memcpy(buffer, src_buffer, CopyLeft);
 			buffer += CopyLeft;
--
-	while ((copy_out_done == false) && (copy_in_done == false)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((copy_out_done == false) && (copy_in_done == false)) {
 		in_copied = 0;
 		new_entry_flag = false;
 		retval = sst_prepare_input_buffers(str_info,\
@@ -1199,7 +1204,12 @@ int sst_decode(int str_id, struct snd_ss
 							bytes_left);
--
-					while (bytes_left) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+						unsigned long long timeout;
+						timeout = rdstcll(start) + delta;
+						while (bytes_left) {
 						struct snd_sst_buffs *ibufs;
 						struct snd_sst_buff_entry
 								*buff_entry;
@@ -1227,6 +1237,12 @@ int sst_decode(int str_id, struct snd_ss
 							input_index_valid_size =
--
 	while (retry) {
 		if (!sst_drv_ctx->lpe_stalled)
 			return 0;
@@ -104,6 +109,12 @@ int sst_stalled(void)
 		msleep(1);
 
--
 	while (size) {
 		cmd = data;
 		cmd_cmd = __be16_to_cpu(cmd->cmd);
@@ -312,6 +317,12 @@ static int pohmelfs_trans_iter(struct ne
 		err = iterator(e, &sg_dst, &sg_src);
 		if (err)
--
 	while (!list_empty(head)) {
 		struct pohmelfs_crypto_thread *t = NULL;
 
@@ -580,15 +596,32 @@ static void pohmelfs_crypto_flush(struct
 
 		if (t)
--
 	while (!list_empty(&psb->crypto_active_list) || !list_empty(&psb->crypto_ready_list)) {
 		dprintk("%s: crypto_thread_num: %u.\n", __func__, psb->crypto_thread_num);
 		pohmelfs_crypto_flush(psb, &psb->crypto_active_list);
 		pohmelfs_crypto_flush(psb, &psb->crypto_ready_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!t) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!t) {
 		err = wait_event_interruptible_timeout(psb->wait,
 				!list_empty(&psb->crypto_ready_list),
 				psb->wait_on_page_timeout);
@@ -805,6 +843,12 @@ static int pohmelfs_crypto_thread_get(st
 
--
 	while (n) {
 		tmp = rb_entry(n, struct pohmelfs_mcache, mcache_entry);
 
@@ -51,6 +56,12 @@ struct pohmelfs_mcache *pohmelfs_mcache_
 			pohmelfs_mcache_get(ret);
 			break;
--
 	while (*n) {
 		parent = *n;
 
@@ -77,6 +93,12 @@ static int pohmelfs_mcache_insert(struct
 			ret = tmp;
 			break;
--
 	while (size && !err) {
 		revents = netfs_state_poll(st);
 
@@ -148,6 +153,12 @@ static int pohmelfs_data_recv(struct net
 					"should_stop: %d, size: %u, err: %d.\n",
 				__func__, st->socket, st->read_socket,
--
 	while (!kthread_should_stop()) {
 		/*
 		 * If socket will be reset after this statement, then
@@ -969,6 +985,12 @@ static int pohmelfs_recv(void *data)
 				netfs_state_reset(st);
 				break;
--
 	while (!kthread_should_stop())
diff -u -p a/staging/pohmelfs/dir.c b/staging/pohmelfs/dir.c
--- a/staging/pohmelfs/dir.c
+++ b/staging/pohmelfs/dir.c
@@ -38,6 +38,11 @@ static struct pohmelfs_name *pohmelfs_se
 	struct pohmelfs_name *tmp = NULL;
--
 	while (n) {
 		tmp = rb_entry(n, struct pohmelfs_name, hash_node);
 
@@ -49,6 +54,12 @@ static struct pohmelfs_name *pohmelfs_se
 		else
 			break;
--
 	while (*n) {
 		parent = *n;
 
@@ -101,6 +117,12 @@ static struct pohmelfs_name *pohmelfs_in
 			ret = tmp;
 			break;
--
 	while (n) {
 		tmp = rb_entry(n, struct netfs_trans_dst, state_entry);
 		t = tmp->trans;
@@ -220,6 +225,12 @@ struct netfs_trans_dst *netfs_trans_sear
 			ret = tmp;
 			break;
--
 	while (*n) {
 		parent = *n;
 
@@ -248,6 +264,12 @@ static int netfs_trans_insert(struct net
 			ret = tmp;
 			break;
--
 	while (d && d != root && !IS_ROOT(d)) {
 		len += d->d_name.len + 1; /* Plus slash */
 		d = d->d_parent;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (offs < count && odev->buf_offs < max_offs) {
 		int ret = 0;
 
@@ -588,6 +593,12 @@ static ssize_t odev_set_picture(struct a
 		}
 
--
-		while ((end_of_queue_search(sta_phead, sta_plist)) == false) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((end_of_queue_search(sta_phead, sta_plist)) == false) {
 			ptxservq = LIST_CONTAINOR(sta_plist, struct tx_servq,
 				  tx_pending);
 			pframe_queue = &ptxservq->sta_pending;
@@ -229,6 +234,12 @@ static struct xmit_frame *dequeue_xframe
 				/*must be done after get_next and before break*/
--
 	while (end_of_queue_search(phead, plist) == false) {
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		plist = get_next(plist);
 		_free_network(pmlmepriv, pnetwork);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		if (end_of_queue_search(phead, pmlmepriv->pscanned) == true) {
 			if ((pmlmepriv->assoc_by_rssi == true) &&
@@ -1206,6 +1222,12 @@ int r8712_select_and_join_from_scan(stru
 				goto ask_for_joinbss;
 			}
--
 	while (bContinual && efuse_one_byte_read(padapter, efuse_addr,
 	       &efuse_data) && (efuse_addr < efuse_available_max_size)) {
 		if (efuse_data != 0xFF) {
@@ -232,6 +237,12 @@ u16 r8712_efuse_get_current_size(struct
 			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
 		} else
--
 	while (end_of_queue_search(phead, plist) == false) {
 		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		plist = get_next(plist);
 		r8712_free_recvframe(precvframe, pfree_recv_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (cnt < ielen) {
 				eid = buf[cnt];
 
@@ -629,6 +634,12 @@ static int r871x_set_wpa_ie(struct _adap
 					break;
 				} else
--
 	while (end_of_queue_search(phead, plist) == false) {
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 		plist = get_next(plist);
 		r8712_free_xmitframe(pxmitpriv, pxmitframe);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((end_of_queue_search(phead, plist)) == false) {
 		psta = LIST_CONTAINOR(plist, struct sta_info, list);
 		plist = get_next(plist);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while ((end_of_queue_search(phead, plist)) == false) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((end_of_queue_search(phead, plist)) == false) {
 			psta = LIST_CONTAINOR(plist,
 					      struct sta_info, hash_list);
 			plist = get_next(plist);
 			if (pbcmc_stainfo != psta)
 				r8712_free_stainfo(padapter , psta);
--
 	while (end_of_queue_search(phead, plist) == false) {
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pnfhdr = &pnextrframe->u.hdr;
@@ -254,6 +259,12 @@ static union recv_frame *recvframe_defra
 		recvframe_put(prframe, pnfhdr->len);
 		pfhdr->attrib.icv_len = pnfhdr->attrib.icv_len;
--
 	while (end_of_queue_search(phead, plist) == false) {
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pnextattrib = &pnextrframe->u.hdr.attrib;
@@ -517,6 +533,12 @@ static int enqueue_reorder_recvframe(str
 			return false;
 		else
--
 	while (!is_list_empty(phead)) {
 		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pattrib = &prframe->u.hdr.attrib;
@@ -579,6 +606,12 @@ int r8712_recv_indicatepkts_in_order(str
 			bPktInBuf = true;
 			break;
--
 	while (cnt < in_len) {
 		authmode = in_ie[cnt];
 		if ((authmode == _WPA_IE_ID_) &&
@@ -393,6 +398,12 @@ int r8712_get_sec_ie(u8 *in_ie, uint in_
 			} else
 				cnt += in_ie[cnt+1] + 2;   /*get next*/
--
 	while (cnt < in_len) {
 		eid = in_ie[cnt];
 		if ((eid == _WPA_IE_ID_) &&
@@ -416,6 +432,12 @@ int r8712_get_wps_ie(u8 *in_ie, uint in_
 			break;
 		} else
--
 	while ((val = dc_read(sc->addr, SBE_2T3E3_21143_REG_STATUS)) &
 	       (SBE_2T3E3_21143_VAL_RECEIVE_PROCESS_STOPPED |
 		SBE_2T3E3_21143_VAL_RECEIVE_BUFFER_UNAVAILABLE |
@@ -107,6 +112,12 @@ void dc_intr(struct channel *sc)
 					"Transmit process stopped\n");
 			dc_intr_tx(sc);
--
-		while (!(sc->ether.rx_ring[current_read].rdes0 &
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!(sc->ether.rx_ring[current_read].rdes0 &
 			 SBE_2T3E3_RX_DESC_21143_OWN)) {
 			current_desc = &sc->ether.rx_ring[current_read];
 			current_desc->rdes1 &= SBE_2T3E3_RX_DESC_END_OF_RING |
@@ -137,12 +153,23 @@ void dc_intr_rx(struct channel *sc)
 			current_desc->rdes1 |= SBE_2T3E3_MTU;
--
-	while (!(sc->ether.rx_ring[current_read].rdes0 &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(sc->ether.rx_ring[current_read].rdes0 &
 		 SBE_2T3E3_RX_DESC_21143_OWN)) {
 		current_desc = &sc->ether.rx_ring[current_read];
 
@@ -281,6 +308,12 @@ void dc_intr_rx(struct channel *sc)
 		}
--
 		while (port < num_ports) {
 			union cvmx_srxx_spi4_calx srxx_spi4_calx;
 			srxx_spi4_calx.u64 = 0;
@@ -338,6 +343,12 @@ int cvmx_spi_calendar_setup_cb(int inter
 			cvmx_write_csr(CVMX_SRXX_SPI4_CALX(index, interface),
 				       srxx_spi4_calx.u64);
--
 		while (port < num_ports) {
 			union cvmx_stxx_spi4_calx stxx_spi4_calx;
 			stxx_spi4_calx.u64 = 0;
@@ -401,6 +417,12 @@ int cvmx_spi_calendar_setup_cb(int inter
 			cvmx_write_csr(CVMX_STXX_SPI4_CALX(index, interface),
 				       stxx_spi4_calx.u64);
--
 			while (to_free_list) {
 				struct sk_buff *t = to_free_list;
 				to_free_list = to_free_list->next;
 				dev_kfree_skb_any(t);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (to_free_list) {
 		struct sk_buff *t = to_free_list;
 		to_free_list = to_free_list->next;
 		dev_kfree_skb_any(t);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (segments--) {
 		union cvmx_buf_ptr next_ptr = *(union cvmx_buf_ptr *)
 			cvmx_phys_to_ptr(segment_ptr.s.addr - 8);
@@ -216,6 +221,12 @@ int cvm_oct_free_work(void *work_queue_e
 				      DONT_WRITEBACK(CVMX_FPA_PACKET_POOL_SIZE /
 						     128));
--
 	while (num_blocks--) {
 		cvmx_fpa_free(ptr, pool, 0);
 		ptr += block_size;
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
--
-	while (remaining_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (remaining_bytes) {
 		start_of_buffer =
 		    ((buffer_ptr.s.addr >> 7) - buffer_ptr.s.back) << 7;
 		cvmx_dprintf("    Buffer Start:%llx\n",
@@ -145,7 +150,12 @@ int cvmx_helper_dump_packet(cvmx_wqe_t *
 		data_address = (uint8_t *) cvmx_phys_to_ptr(buffer_ptr.s.addr);
--
-		while (data_address < end_of_data) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (data_address < end_of_data) {
 			if (remaining_bytes == 0)
 				break;
 			else
@@ -157,12 +167,24 @@ int cvmx_helper_dump_packet(cvmx_wqe_t *
 				count = 0;
--
 	while (num_ports--) {
 		__cvmx_helper_port_setup_ipd(ipd_port);
 		ipd_port++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (num_ports--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_ports--) {
 		/*
 		 * Give the user a chance to override the per queue
 		 * priorities.
@@ -403,6 +419,12 @@ static int __cvmx_helper_interface_setup
 				     cvmx_pko_get_num_queues(ipd_port),
--
-				while (segments--) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (segments--) {
 					union cvmx_buf_ptr next_ptr =
 					    *(union cvmx_buf_ptr *)cvmx_phys_to_ptr(segment_ptr.s.addr - 8);
 
@@ -393,6 +398,12 @@ static int cvm_oct_napi_poll(struct napi
 					       segment_size);
--
-				while (true) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (true) {
 					u8 tmp24F = read_nic_byte(dev, 0x24f);
 
 					if ((tmp24F == 0x01) ||
@@ -954,6 +959,12 @@ bool SetZebraRFPowerState8185(struct net
 						} else
--
 	while (true)	{
 		spin_lock_irqsave(&priv->rf_ps_lock, flag);
 		if (priv->RFChangeInProgress)	{
 			spin_unlock_irqrestore(&priv->rf_ps_lock, flag);
 			/*  Set RF after the previous action is done.	*/
+			unsigned long long delta = (cpu / khz / HZ) * 2;
--
 			while (priv->RFChangeInProgress)	{
 				RFWaitCounter++;
 				udelay(1000); /* 1 ms	*/
@@ -1429,12 +1439,24 @@ MgntActSet_RF_State(
 					/* TODO: Reset RF state?	*/
 					return false;
--
 	while(1)
 	{
 
@@ -492,6 +497,12 @@ void ieee80211_softmac_scan_syncro(struc
 
 		msleep_interruptible_rtl(IEEE80211_SOFTMAC_SCAN_TIME);
--
-     	while(1)
+     	unsigned long long delta = (cpu / khz / HZ) * 2;
+     	unsigned long long _start = 0;
+     	unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while(1)
         {
                 /* this function can be called in two situations
                  * 1- We have switched to ad-hoc mode and we are
@@ -564,6 +580,12 @@ void ieee80211_softmac_ips_scan_syncro(s
 
--
 		}while(!channel_map[ieee->current_network.channel]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){
 
 			header = (struct ieee80211_hdr_3addr  *) skb->data;
@@ -2077,6 +2104,12 @@ void ieee80211_rtl_wake_queue(struct iee
 			//printk(KERN_ALERT "ieee80211_wake_queue \n");
 			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
--
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID) {
@@ -223,6 +228,12 @@ vMgrDecodeBeacon(
 
         }
--
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
         switch (pItem->byElementID) {
         case WLAN_EID_SSID:
@@ -417,6 +433,12 @@ vMgrDecodeAssocRequest(
             break;
         }
--
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID) {
@@ -594,6 +621,12 @@ vMgrDecodeReassocRequest(
             break;
         }
--
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID) {
@@ -669,6 +707,12 @@ vMgrDecodeProbeRequest(
         }
 
--
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
         switch (pItem->byElementID) {
         case WLAN_EID_SSID:
@@ -817,6 +866,12 @@ vMgrDecodeProbeResponse(
         }
 
--
-                while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                    timeout = rdstcll(start) + delta;
+                    while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
                         pMgmt->uScanChannel <= pDevice->byMaxChannel ){
                     pMgmt->uScanChannel++;
+                    if (_cur < timeout) {
+                    rdstcll(_cur);
+                    }
--
-  while (str1_len >= str2_len) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (str1_len >= str2_len) {
        str1_len--;
       if(memcmp(str1,str2,str2_len)==0)
 	return (unsigned char *) str1;
         str1++;
+        if (_cur < timeout) {
--
-	while (cbByte--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cbByte--) {
 		dwCrc = s_adwCrc32Table[(BYTE)((dwCrc ^ (*pbyData)) & 0xFF)] ^
 			(dwCrc >> 8);
 		pbyData++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
     while ((pdev = pci_get_device (PCI_VENDOR_ID_CONEXANT,
                                     PCI_DEVICE_ID_CN8474,
                                     pdev)))
     {
         if (c4_hdw_init (pdev, found))
             found++;
--
     while (ci)
     {
         next = ci->next;            /* protect <next> from upcoming <free> */
@@ -569,6 +574,12 @@ c4_cleanup (void)
         OS_kfree (ci->iqd_p_saved);
         OS_kfree (ci);
--
 	while ((priv = stub_priv_pop(sdev))) {
 		urb = priv->urb;
 		dev_dbg(&sdev->udev->dev, "free urb %p\n", urb);
@@ -239,6 +244,12 @@ void stub_device_cleanup_urbs(struct stu
 		kfree(urb->transfer_buffer);
 		kfree(urb->setup_packet);
--
 	while (usbip_event_happened(ud)) {
 		usbip_dbg_eh("pending event %lx\n", ud->event);
 
@@ -56,6 +61,12 @@ static int event_handler(struct usbip_de
 		/* Stop the error handler. */
 		if (ud->event & USBIP_EH_BYE)
--
 	while (bit) {
 		u32 prev = prev_status & bit;
 		u32 new = new_status & bit;
@@ -114,6 +119,12 @@ static void dump_port_status_diff(u32 pr
 			pr_debug(" %c%s\n", change, bit_desc[i]);
 		bit <<= 1;
--
-	while (dev->ring_head == dev->ring_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (dev->ring_head == dev->ring_tail) {
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EAGAIN;
 			goto unlock_exit;
@@ -509,6 +514,12 @@ static ssize_t usb_alphatrack_read(struc
 					     dev->interrupt_in_done);
--
 	while ((c < count) && (dev->ring_tail != dev->ring_head)) {
 		if (copy_to_user
 		    (&buffer[c], &(*dev->ring_buffer)[dev->ring_tail],
@@ -527,6 +543,12 @@ static ssize_t usb_alphatrack_read(struc
 		c += INPUT_CMD_SIZE;
 		dbg_info(&dev->intf->dev, "%s: head, tail are %x, %x\n",
--
 	while (i < (MAX_DEFECTIVE_BLOCK + 2)) {
 		if (monitor_card_cd(chip, MS_CARD) == CD_NOT_EXIST)
 			TRACE_RET(chip, STATUS_FAIL);
@@ -2070,6 +2075,12 @@ RE_SEARCH:
 
 		ms_card->boot_block = i;
--
 	while (desc_cnt) {
 		if (check_card_ready(chip, lun)) {
 			buf[i++] = (unsigned char)((chip->capacity[lun]) >> 24);
@@ -971,6 +976,12 @@ static int read_format_capacity(struct s
 		buf[i++] = 0x00;
 
--
-	while (cnt < buflen && sg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt < buflen && sg) {
 		struct page *page = sg_page(sg) +
 		    ((sg->offset + *offset) >> PAGE_SHIFT);
 		unsigned int poff = (sg->offset + *offset) & (PAGE_SIZE - 1);
@@ -113,6 +118,12 @@ unsigned int rts51x_access_sglist(unsign
 			cnt += plen;
--
 	while (i < entries && !io->status) {
 		int retval;
 
@@ -661,6 +677,12 @@ int rts51x_sg_wait(struct usb_sg_request
 		spin_lock_irq(&io->lock);
 		if (retval && (io->status == 0 || io->status == -ECONNRESET))
--
 	while ( n-- ) {
 		p = (hcf_16 FAR *)dst;
 		*p++ = (hcf_16)_inpw( prt );
@@ -170,6 +175,12 @@ void IN_PORT_STRING_32( hcf_io prt, hcf_
 			fprintf( log_file, "%s%08lx ", i++ % 0x08 ? " " : "\n", *dst);
 		}
--
 	while ( n-- ) {
 		*p =(hcf_16)_inpw( prt);
 		if ( log_file ) {
@@ -190,6 +206,12 @@ void IN_PORT_STRING_8_16( hcf_io prt, hc
 			}
 		}
--
 	while ( n-- ) {
 		p = (hcf_16 FAR *)src;
 		_outpw( prt, *p++ );
@@ -208,6 +235,12 @@ void OUT_PORT_STRING_32( hcf_io prt, hcf
 			fprintf( log_file, "%s%08lx ", i++ % 0x08 ? " " : "\n", *src);
 		}
--
 	while ( n-- ) {
 		(void)_outpw( prt, *p);
 		if ( log_file ) {
@@ -227,6 +265,12 @@ void OUT_PORT_STRING_8_16( hcf_io prt, h
 			}
 		}
--
 					while ( p ) {
 						//p->buf_cntl.cntl_stat |= DESC_DMA_OWNED;
 						p->BUF_CNT |= DESC_DMA_OWNED;
 						p = p->next_desc_addr;
+						if (_cur < timeout) {
+							rdstcll(_cur);
--
 		while (p->len) {
 			p->host_addr = (char *)p->host_addr + (hcf_32)fw;
 			p++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 	while (1) {
 		while (!ioread32(FlashReg + intr_status))
 			;
@@ -2186,6 +2191,12 @@ u16 NAND_Multiplane_Write(u8 *write_data
 				(~INTR_STATUS0__DMA_CMD_COMP),
 				FlashReg + intr_status);
 		}
--
 	while (1) {
 		while (!ioread32(FlashReg + intr_status))
 			;
@@ -2313,6 +2329,12 @@ static void handle_nand_int_write(struct
 				(~INTR_STATUS0__DMA_CMD_COMP),
 				FlashReg + intr_status);
 		}
--
 	while (!kthread_should_stop()) {
 		int res;
 
@@ -450,6 +455,12 @@ static int spectra_trans_thread(void *ar
 
 		if (!__blk_end_request_cur(req, res))
--
-	while (PageCount) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (PageCount) {
 		ret = spectra_mtd->write(spectra_mtd,
 					 (Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),
 					 DeviceInfo.wPageDataSize, &retlen, write_data);
@@ -243,6 +248,12 @@ u16 mtd_Write_Page_Main(u8 *write_data,
 		write_data += DeviceInfo.wPageDataSize;
--
-	while (PageCount) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (PageCount) {
 		ret = spectra_mtd->read(spectra_mtd,
 					(Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),
 					DeviceInfo.wPageDataSize, &retlen, read_data);
@@ -293,6 +309,12 @@ u16 mtd_Read_Page_Main(u8 *read_data, u3
 		read_data += DeviceInfo.wPageDataSize;
--
 	while (PageCount) {
 		struct mtd_oob_ops ops;
 		int ret;
@@ -357,6 +384,12 @@ u16 mtd_Read_Page_Main_Spare(u8 *read_da
 		read_data += DeviceInfo.wPageSize;
 		Page++;
--
 	while (page_count) {
 		struct mtd_oob_ops ops;
 		int ret;
@@ -417,6 +455,12 @@ u16 mtd_Write_Page_Main_Spare(u8 *write_
 		write_data += DeviceInfo.wPageSize;
 		Page++;
--
 	while (PageCount) {
 		struct mtd_oob_ops ops;
 		int ret;
@@ -491,6 +540,12 @@ u16 mtd_Read_Page_Spare(u8 *read_data, u
 		read_data += DeviceInfo.wPageSize;
 		Page++;
--
 		while (nbytes > walk->len_this_page) {
 			memcpy_dir(buf, walk->data, walk->len_this_page, out);
 			buf += walk->len_this_page;
@@ -114,6 +119,12 @@ int scatterwalk_copychunks(void *buf, st
 			crypto_kunmap(walk->data, out);
 			scatterwalk_pagedone(walk, out, 1);
--
 	while(1)
 	{
 
@@ -477,7 +482,13 @@ void ieee80211_softmac_scan_syncro(struc
 
 		msleep_interruptible_rsl(IEEE80211_SOFTMAC_SCAN_TIME);
--
 		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){
 
 			header = (struct ieee80211_hdr_3addr  *) skb->data;
@@ -2253,6 +2269,12 @@ void ieee80211_wake_queue(struct ieee802
 
 			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
--
 	while(pList->next != &pTS->RxPendingPktList)
 	{
 		if( SN_LESS(pReorderEntry->SeqNum, ((PRX_REORDER_ENTRY)list_entry(pList->next,RX_REORDER_ENTRY,List))->SeqNum) )
@@ -539,6 +544,12 @@ AddReorderEntry(
 		{
 			break;
--
 		while(!list_empty(&pRxTs->RxPendingPktList))
 		{
 			pReorderEntry = (PRX_REORDER_ENTRY)list_entry(pRxTs->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
@@ -67,6 +72,12 @@ void RxPktPendingTimeout(unsigned long d
 				bPktInBuf = true;
 				break;
--
 		while(!list_empty(&pRxTS->RxPendingPktList))
 		{
 		//      PlatformAcquireSpinLock(Adapter, RT_RX_SPINLOCK);
@@ -516,6 +532,12 @@ void RemoveTsEntry(
 			list_add_tail(&pRxReorderEntry->List,&ieee->RxReorder_Unused_List);
 			//PlatformReleaseSpinLock(Adapter, RT_RX_SPINLOCK);
--
 	while (read_nic_dword(dev, QPNR)&0x80000000)
 	{
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
@@ -404,10 +409,21 @@ phy_FwRFSerialRead(
 		}
 		else
--
 	while (read_nic_dword(dev, QPNR)&0x80000000)
 	{
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
@@ -418,6 +434,12 @@ phy_FwRFSerialRead(
 		}
 		else
--
 	while (read_nic_dword(dev, QPNR)&0x80000000)
 	{
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
@@ -468,6 +495,12 @@ phy_FwRFSerialWrite(
 		}
 		else
--
 	while ((skb = __skb_dequeue(&priv->rx_queue))) {
 		info = (struct rtl8192_rx_info *) skb->cb;
 		if (!info->urb)
@@ -1048,6 +1053,12 @@ void rtl8192_rtx_disable(struct net_devi
 
 		usb_kill_urb(info->urb);
--
 			while (1) {
 				interruptible_sleep_on(&info->delta_msr_wait);
 				/* see if a signal did it */
@@ -1495,6 +1500,12 @@ static int rs_360_ioctl(struct tty_struc
 					return 0;
 				}
--
 	while (*ptr) {
 		if (*ptr == data) {
 			*ptr = (*ptr)->next;
@@ -192,6 +197,12 @@ static void quickstart_btnlst_del(struct
 			return;
 		}
--
 	while (ptr) {
 		lptr = ptr;
 		ptr = ptr->next;
 		kfree(lptr->name);
 		kfree(lptr);
+		if (_cur < timeout) {
--
 	while (*ptr) {
 		count++;
 		set_bit(EV_KEY, quickstart_input->evbit);
 		set_bit((*ptr)->id, quickstart_input->keybit);
 		ptr = &((*ptr)->next);
+		if (_cur < timeout) {
--
 	while (!pt) {
 		spin_unlock(lock);
 		pt = psb_mmu_alloc_pt(pd);
@@ -386,6 +391,12 @@ struct psb_mmu_pt *psb_mmu_pt_alloc_map_
 			psb_mmu_clflush(pd->driver, (void *) &v[index]);
 			atomic_set(&pd->driver->needs_tlbflush, 1);
--
 	while (gtt_pages--) {
 		*v++ = gtt_start | pd->pd_mask;
 		gtt_start += PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (true) {
 		pwr_sts = inl(dev_priv->ospm_base + PSB_PM_SSS);
 		if ((pwr_sts & pwr_mask) == pwr_mask)
 			break;
 		else
 			udelay(10);
--
 	while (true) {
 		pwr_sts = inl(dev_priv->ospm_base + PSB_PM_SSS);
 		if ((pwr_sts & pwr_mask) == 0)
 			break;
 		else
 			udelay(10);
--
 	while (index < total) {
 		current_id = *(base + index);
 		index++;
@@ -47,6 +52,12 @@ static void *find_section(struct bdb_hea
 		if (current_id == section_id)
 			return base + index;
--
 	while (avail < size) {
 		avail = PSB_RSGX32(PSB_CR_2D_SOCIF);
 		if (time_after(jiffies, t)) {
 			psb_spank(dev_priv);
 			return -EIO;
 		}
--
 	while (status & 1) {
 		udelay(1); /* scu processing time is in few u secods */
 		status = readl(scu_base + 0x04);
@@ -147,6 +152,12 @@ static void scu_busy_loop(void *scu_base
 			DRM_DEBUG_KMS("SCU IPC timed out");
 			return;
--
 	while (retry--) {
 		if ((mask & REG_READ(gen_fifo_stat_reg)) == mask)
 			return 0;
 		udelay(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&sender->pkg_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&sender->pkg_list)) {
 		pkg = list_first_entry(&sender->pkg_list,
 					struct mdfld_dsi_pkg, entry);
 		send_pkg(sender, pkg);
 		list_del_init(&pkg->entry);
 		pkg_sender_put_pkg_locked(sender, pkg);
--
 	while (retry && !(REG_READ(sender->mipi_intr_stat_reg) & (1 << 29))) {
 		udelay(100);
 		retry--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (retry &&
 		    !(REG_READ(sender->mipi_gen_fifo_stat_reg) & (1 << 27))) {
 			udelay(500);
 			retry--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (retry &&
 			(REG_READ(sender->mipi_cmd_addr_reg) & (1 << 0))) {
 			udelay(1);
 			retry--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (retry--) {
 		/* Read the command response */
 		for (i = 0; i < response_len; i++) {
@@ -281,6 +286,12 @@ static u8 psb_intel_sdvo_read_response(
 			return status;
 
--
 	while (1) {
 
 		count = qt_chars_in_buffer(tty);
@@ -1042,6 +1047,12 @@ static void qt_block_until_empty(struct
 		} else {
 			wait = 30;
--
-	while (cnt < buflen && sg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt < buflen && sg) {
 		struct page *page = sg_page(sg) +
 					((sg->offset + *offset) >> PAGE_SHIFT);
 		unsigned int poff = (sg->offset + *offset) & (PAGE_SIZE-1);
@@ -453,6 +458,12 @@ unsigned int usb_stor_access_xfer_buf(st
 			cnt += plen;
--
 	while (d) { /* If d=0 finish counting */
 		if (d&BIT0)
 			++i; /* Count number of 1 bit */
 		d >>= 1; /* Right shift */
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (kp->nr < ARRAY_SIZE(kp->objnodes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (kp->nr < ARRAY_SIZE(kp->objnodes)) {
 		preempt_enable_no_resched();
 		objnode = kmem_cache_alloc(zcache_objnode_cache,
 				ZCACHE_GFP_MASK);
@@ -1015,6 +1020,12 @@ static int zcache_do_preload(struct tmem
 			kp->objnodes[kp->nr++] = objnode;
--
-		while (kp->nr) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (kp->nr) {
 			kmem_cache_free(zcache_objnode_cache,
 					kp->objnodes[kp->nr - 1]);
 			kp->objnodes[kp->nr - 1] = NULL;
 			kp->nr--;
+			if (_cur < timeout) {
--
 	while (rbnode) {
 		BUG_ON(RB_EMPTY_NODE(rbnode));
 		obj = rb_entry(rbnode, struct tmem_obj, rb_tree_node);
@@ -93,6 +98,12 @@ static struct tmem_obj *tmem_obj_find(st
 			rbnode = rbnode->rb_right;
 			break;
--
 	while (*new) {
 		BUG_ON(RB_EMPTY_NODE(*new));
 		this = rb_entry(*new, struct tmem_obj, rb_tree_node);
@@ -159,6 +175,12 @@ static void tmem_obj_init(struct tmem_ob
 			new = &(*new)->rb_right;
 			break;
--
 	} while (height > 0);
 	if (slot == NULL)
 		goto out;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (pathp->objnode) {
 		pathp->objnode->slots[pathp->offset] = NULL;
 		pathp->objnode->slots_in_use--;
@@ -456,6 +483,12 @@ static void *tmem_pampd_delete_from_obj(
 		}
 		tmem_objnode_free(pathp->objnode); /* 0 slots used, free it */
--
-	while (!list_empty(&rx_ring->recv_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&rx_ring->recv_list)) {
 		rfd = (struct rfd *) list_entry(rx_ring->recv_list.next,
 				struct rfd, list_node);
 
 		list_del(&rfd->list_node);
 		rfd->skb = NULL;
--
 	while (tcb &&
 	       ((serviced ^ tcb->index) & ET_DMA10_WRAP) &&
 	       index < INDEX10(tcb->index)) {
@@ -3774,7 +3790,18 @@ void et131x_handle_send_interrupt(struct
 
 		/* Goto the next packet */
--
 	while (tcb &&
 	       !((serviced ^ tcb->index) & ET_DMA10_WRAP)
 	       && index > (tcb->index & ET_DMA10_MASK)) {
@@ -3789,6 +3816,12 @@ void et131x_handle_send_interrupt(struct
 
 		/* Goto the next packet */
--
-	while (*name) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (*name) {
 		int in, out, bit, neg;
 		for (in = 0; (in < sizeof(sigtab)) &&
 			     (sigtab[in] != *name); in++)
@@ -1968,6 +1973,12 @@ static int input_name2mask(char *name, p
 		if (!neg)
--
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (1) {
 			add_wait_queue(&port_extra->wait, &wait);
 			schedule();
 			dbg("%s(): port %d, cmd == TIOCMIWAIT here\n",
@@ -948,6 +953,12 @@ static int qt2_ioctl(struct tty_struct *
 				__set_current_state(TASK_RUNNING);
--
 		} /* end inifinite while */
 		/* FIXME: This while loop needs a way to break out if the device
 		 * is disconnected while a process is waiting for the MSR to
diff -u -p a/staging/bcm/Qos.c b/staging/bcm/Qos.c
--- a/staging/bcm/Qos.c
+++ b/staging/bcm/Qos.c
@@ -406,6 +406,11 @@ VOID flush_all_queues(PMINI_ADAPTER Adap
 		struct net_device_stats *netstats = &Adapter->dev->stats;
--
 		while(Adapter->PackInfo[iQIndex].FirstTxQueue)
 		{
 			PacketToDrop = Adapter->PackInfo[iQIndex].FirstTxQueue;
@@ -435,6 +440,12 @@ VOID flush_all_queues(PMINI_ADAPTER Adap
 					Adapter->PackInfo[iQIndex].uiDroppedCountBytes,
 					Adapter->PackInfo[iQIndex].uiDroppedCountPackets);
--
 	while (pkt) {
 		npkt = pkt->next;
 		kfree_skb(pkt);
 		pkt = npkt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(RxDescCount)
 	{
 		pRcb = GetBulkInRcb(psIntfAdapter);
@@ -258,7 +263,13 @@ BOOLEAN InterfaceRx (PS_INTERFACE_ADAPTE
 		//atomic_inc(&psIntfAdapter->uNumRcbUsed);
 		ReceiveRcb(psIntfAdapter, pRcb);
--
-	while (psIntfAdapter->psAdapter->DeviceAccess) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (psIntfAdapter->psAdapter->DeviceAccess) {
 		BCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,
 			"Device is being accessed.\n");
 		msleep(100);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while(1)
 	{
 		wait_event_interruptible(Adapter->process_rx_cntrlpkt,
@@ -178,6 +183,11 @@ int control_packet_handler  (PMINI_ADAPT
 			continue;
 		}
--
 		while(atomic_read(&Adapter->cntrlpktCnt))
 		{
 			spin_lock_irqsave(&Adapter->control_queue_lock, flags);
@@ -191,9 +201,21 @@ int control_packet_handler  (PMINI_ADAPT
 			spin_unlock_irqrestore (&Adapter->control_queue_lock, flags);
 		 	handle_rx_control_packet(Adapter, ctrl_packet);
--
 		while(uiTemp)
 		{
 			 if(IsOffsetWritable(Adapter, uiOffsetFromSectStart + index * Adapter->uiSectorSize ) == FALSE)
@@ -1207,6 +1212,12 @@ static INT BeceemFlashBulkWrite(
 			 }
 			 uiTemp = uiTemp - 1;
--
 		while(uiTemp)
 		{
 			 if(IsOffsetWritable(Adapter,uiOffsetFromSectStart + index * Adapter->uiSectorSize ) == FALSE)
@@ -1421,10 +1437,21 @@ static INT BeceemFlashBulkWriteStatus(
 			 }
 			 uiTemp = uiTemp - 1;
--
 	while(uiNumSectTobeRead)
 	{
 		uiPartOffset = (uiSectAlignAddr & (FLASH_PART_SIZE - 1)) + GetFlashBaseAddr(Adapter);
@@ -1505,7 +1532,13 @@ static INT BeceemFlashBulkWriteStatus(
 		uiSectBoundary += Adapter->uiSectorSize;
 		uiOffsetFromSectStart += Adapter->uiSectorSize;
--
 	while(uiNumBytes)
 	{
 		if(Adapter->device_removed )
@@ -1757,6 +1795,12 @@ static INT BeceemEEPROMReadBackandVerify
 			uiNumBytes = 0;
 		}
--
 	while(uiBytesToCopy)
 	{
 		if(Adapter->device_removed)
@@ -2003,6 +2052,12 @@ INT BeceemEEPROMBulkWrite(
 			uiBytesToCopy = 0;
 		}
--
 			while(uiNumBytes)
 			{
 				if(uiNumBytes > BUFFER_4K)
@@ -2156,6 +2216,12 @@ INT BeceemNVMWrite(
 					uiNumBytes = 0;
 					break;
--
 				while(uiNumBytes)
 				{
 					if(uiNumBytes > BUFFER_4K)
@@ -2181,6 +2252,12 @@ INT BeceemNVMWrite(
 						uiNumBytes = 0;
 						break;
--
 			while (len) {
 				if (*(unsigned int *)&buff_readback[len] != *(unsigned int *)&buff[len]) {
 					BCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Firmware Download is not proper %d", fw_down);
@@ -119,6 +124,12 @@ int InterfaceFileReadbackFromChip(PVOID
 					goto exit;
 				}
--
 	while (atomic_read(&Adapter->ApplicationRunning)) {
 		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Waiting for Application to close.. %d\n", atomic_read(&Adapter->ApplicationRunning));
 		msleep(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (Adapter->PackInfo[iQIndex].FirstTxQueue && atomic_read(&Adapter->TotalPacketCount)) {
 		PacketToDrop = Adapter->PackInfo[iQIndex].FirstTxQueue;
 		if (PacketToDrop && PacketToDrop->len) {
@@ -1614,6 +1630,12 @@ void flush_queue(PMINI_ADAPTER Adapter,
 			dev_kfree_skb(PacketToDrop);
 			atomic_dec(&Adapter->TotalPacketCount);
--
-	while (curr_table_data_size < table_data_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (curr_table_data_size < table_data_size) {
 		/* Update the number of entries in table */
 		(*num_table_entries_ptr)++;
 
@@ -1291,6 +1296,12 @@ static void sep_build_lli_table(struct s
 
--
-	while (current_entry < sep_lli_entries) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (current_entry < sep_lli_entries) {
 
 		/* Set the new input and output tables */
 		in_lli_table_ptr =
@@ -1614,6 +1630,12 @@ static int sep_prepare_input_dma_table(s
 		}
--
-	while (current_in_entry < sep_in_lli_entries) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (current_in_entry < sep_in_lli_entries) {
 		/* Set the new input and output tables */
 		in_lli_table_ptr =
 			(struct sep_lli_entry *)lli_table_alloc_addr;
@@ -1855,6 +1882,12 @@ static int sep_construct_dma_tables_from
 		dev_dbg(&sep->pdev->dev,
--
 		while (true) {
 			spin_lock_irqsave(&priv->rf_ps_lock, flag);
 			if (priv->RFChangeInProgress) {
@@ -342,7 +347,12 @@ bool MgntActSet_RF_State(struct net_devi
 					 "progress! Wait to set..StateToSet"
 					 "(%d).\n", StateToSet);
--
-				while (priv->RFChangeInProgress) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (priv->RFChangeInProgress) {
 					RFWaitCounter++;
 					RT_TRACE((COMP_PS | COMP_RF),
 						 "MgntActSet_RF_State(): Wait 1"
@@ -356,13 +366,25 @@ bool MgntActSet_RF_State(struct net_devi
 							 "logn to set RF\n");
--
 	while (skb_queue_len(&ring->queue)) {
 		struct tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb = __skb_dequeue(&ring->queue);
@@ -1854,6 +1881,12 @@ static void rtl8192_free_tx_ring(struct
 			skb->len, PCI_DMA_TODEVICE);
 		kfree_skb(skb);
--
 	while (skb_queue_len(&ring->queue)) {
 		struct tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb;
@@ -1965,6 +2003,12 @@ static void rtl8192_tx_isr(struct net_de
 		skb->len, PCI_DMA_TODEVICE);
 
--
-			while (skb_queue_len(&ring->queue)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (skb_queue_len(&ring->queue)) {
 				struct tx_desc *entry = &ring->desc[ring->idx];
 				struct sk_buff *skb =
 						 __skb_dequeue(&ring->queue);
@@ -2210,6 +2259,12 @@ void rtl8192_pci_resetdescring(struct ne
 						 skb->len, PCI_DMA_TODEVICE);
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count--) {
 		struct rx_desc *pdesc = &priv->rx_ring[rx_queue_idx]
 					[priv->rx_idx[rx_queue_idx]];
 		struct sk_buff *skb = priv->rx_buf[rx_queue_idx]
@@ -2412,6 +2472,12 @@ done:
 			pdesc->EOR = 1;
--
 	while (pList->next != &pTS->RxPendingPktList) {
 		if (SN_LESS(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)
 		    list_entry(pList->next, struct rx_reorder_entry,
@@ -458,6 +463,12 @@ static bool AddReorderEntry(struct rx_ts
 				return false;
 		else
--
 	while (read_nic_dword(dev, QPNR)&0x80000000) {
 		if (time++ < 100)
 			udelay(10);
 		else
 			break;
+			if (_cur < timeout) {
--
 	while (read_nic_dword(dev, QPNR) & 0x80000000) {
 		if (time++ < 100)
 			udelay(10);
 		else
 			return 0;
+			if (_cur < timeout) {
--
 	while (read_nic_dword(dev, QPNR) & 0x80000000) {
 		if (time++ < 100)
 			udelay(10);
 		else
 			break;
+			if (_cur < timeout) {
--
 		while (!list_empty(&pRxTs->RxPendingPktList)) {
 			pReorderEntry = (struct rx_reorder_entry *)
 					list_entry(pRxTs->RxPendingPktList.prev,
@@ -71,6 +76,12 @@ static void RxPktPendingTimeout(unsigned
 				bPktInBuf = true;
 				break;
--
-		while (!list_empty(&pRxTS->RxPendingPktList)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!list_empty(&pRxTS->RxPendingPktList)) {
 			pRxReorderEntry = (struct rx_reorder_entry *)
 					list_entry(pRxTS->RxPendingPktList.prev,
 					struct rx_reorder_entry, List);
@@ -452,6 +468,12 @@ static void RemoveTsEntry(struct rtllib_
 			}
--
 	while (1) {
 		do {
 			ch++;
@@ -576,6 +581,12 @@ void rtllib_softmac_scan_syncro(struct r
 		 * need to wait for a syncro scan to end..
 		 */
--
 		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))) {
 
 			header = (struct rtllib_hdr_3addr  *) skb->data;
@@ -2568,6 +2584,12 @@ void rtllib_wake_queue(struct rtllib_dev
 
 			ieee->softmac_data_hard_start_xmit(skb, ieee->dev,
--
     while( ((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len) ){
 
         switch (pItem->byElementID) {
@@ -224,6 +229,12 @@ vMgrDecodeBeacon(
 
         }
--
     while (((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len)) {
         switch (pItem->byElementID){
             case WLAN_EID_SSID:
@@ -419,6 +435,12 @@ vMgrDecodeAssocRequest(
                 break;
         }
--
     while(((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID){
@@ -599,6 +626,12 @@ vMgrDecodeReassocRequest(
                 break;
         }
--
     while( ((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len) ) {
 
         switch (pItem->byElementID) {
@@ -674,6 +712,12 @@ vMgrDecodeProbeRequest(
         }
 
--
     while( ((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len) ) {
         switch (pItem->byElementID) {
             case WLAN_EID_SSID:
@@ -823,6 +872,12 @@ vMgrDecodeProbeResponse(
         }
 
--
     while (cbByte--) {
         dwCrc = s_adwCrc32Table[(unsigned char)((dwCrc ^ (*pbyData)) & 0xFF)] ^ (dwCrc >> 8);
         pbyData++;
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
--
-		while (cnt < buflen && *index < scsi_sg_count(srb)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (cnt < buflen && *index < scsi_sg_count(srb)) {
 			struct page *page = sg_page(sg) +
 					((sg->offset + *offset) >> PAGE_SHIFT);
 			unsigned int poff =
@@ -120,6 +125,12 @@ unsigned int rtsx_stor_access_xfer_buf(u
 				cnt += plen;
--
 	while (desc_cnt) {
 		if (check_card_ready(chip, lun)) {
 			card_size = get_card_size(chip, lun);
@@ -887,6 +892,12 @@ static int read_format_capacity(struct s
 		buf[i++] = 0x00;
 
--
 	while (len) {
 		u16 pagelen = SF_PAGE_LEN - (u8)addr;
 
@@ -553,6 +558,12 @@ int spi_read_flash(struct scsi_cmnd *srb
 
 		addr += pagelen;
--
 		while (len) {
 			retval = sf_enable_write(chip, SPI_WREN);
 			if (retval != STATUS_SUCCESS) {
@@ -619,6 +635,12 @@ int spi_write_flash(struct scsi_cmnd *sr
 
 			addr++;
--
 		while (len) {
 			rtsx_stor_access_xfer_buf(buf, 1, srb, &index, &offset, FROM_XFER_BUF);
 
@@ -663,6 +690,12 @@ int spi_write_flash(struct scsi_cmnd *sr
 			}
 
--
 		while (len) {
 			u16 pagelen = SF_PAGE_LEN - (u8)addr;
 
@@ -716,6 +754,12 @@ int spi_write_flash(struct scsi_cmnd *sr
 
 			addr += pagelen;
--
-			while (mcaddr) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (mcaddr) {
 				if (!compare_ether_addr(mcaddr->address,
 							ether_frame->ether_dhost)) {
 					adapter->rcv_multicasts++;
@@ -894,6 +899,12 @@ static bool slic_mac_filter(struct adapt
 					return true;
--
 	while (cmd) {
 		if (cmd->busy) {
 			struct sk_buff *tempskb;
@@ -1564,6 +1580,12 @@ static void slic_cmdq_free(struct adapte
 			}
 		}
--
 	while (hcmd) {
 		if (hcmd->busy) {
 			skb = hcmd->skb;
@@ -1688,6 +1715,12 @@ static void slic_cmdq_reset(struct adapt
 			dev_kfree_skb_irq(skb);
 		}
--
 	while (hcmd) {
 		adapter->cmdq_free.count++;
 		hcmd->next = hcmd->next_all;
 		hcmd = hcmd->next_all;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (rcvq->head) {
 		skb = rcvq->head;
 		rcvq->head = rcvq->head->next;
 		dev_kfree_skb(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (i) {
 		count += slic_rcvqueue_fill(adapter);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (mlist) {
 		if (!compare_ether_addr(mlist->address, address))
 			return 0;
 		mlist = mlist->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (mlist) {
 		mcaddr = mlist;
 		mlist = mlist->next;
 		kfree(mcaddr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (still_comparing && valid) {
 		template_ptr = next_specifier(template_ptr);
 		user_ptr = next_specifier(user_ptr);
@@ -523,6 +528,12 @@ static int fmt_validate(char *template,
 			if (template_ptr || user_ptr)
 				valid = 0;
--
 	while (!kthread_should_stop()) {
 		/* if no ctl-a in 4, send data anyway */
 		spin_lock_irqsave(&flush_lock, flags);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (is_flushing && timeout) {
 			prepare_to_wait(&flush, &wait, TASK_INTERRUPTIBLE);
 			spin_unlock_irqrestore(&flush_lock, flags);
 			timeout = schedule_timeout(timeout);
 			spin_lock_irqsave(&flush_lock, flags);
+			if (_cur < timeout) {
--
-	while ((ch = *buff)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((ch = *buff)) {
 		if (ch == '\n')
 			ch = synth->procspeech;
 		if (wait_for_xmitr())
@@ -144,6 +149,12 @@ const char *spk_synth_immediate(struct s
 		else
--
 	while (*kp++) {
 		/* count occurrences of each function */
 		for (i = 0; i < nstates; i++, kp++) {
@@ -77,6 +82,12 @@ static void build_key_data(void)
 				continue;
 			counters[*kp]++;
--
 	while ((ch = *kp++)) {
 		for (i = 0; i < nstates; i++) {
 			ch1 = *kp++;
@@ -106,6 +122,12 @@ static void build_key_data(void)
 			p_key = key_data + offset + counters[ch1];
 			*p_key = key;
--
 	while ((p = strchr(p, '\\'))) {
 		p1 = p+1;
 		p2 = strchr(finds, *p1);
@@ -399,6 +404,12 @@ char *xlate(char *s)
 		while (*p1)
 			*p2++ = *p1++;
 		*p2 = '\0';
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((ch = *buf)) {
 		if (ch == '\n')
 			ch = PROCSPEECH;
@@ -167,6 +172,12 @@ static const char *synth_immediate(struc
 		outb_p(ch, synth_port);
 		udelay(70);
--
 	while ((ch = *buf)) {
 		if (ch == '\n')
 			ch = PROCSPEECH;
 		if (dt_sendchar(ch))
 			return buf;
 		buf++;
--
 	while ((ch = *buf)) {
 		int timeout = SPK_XMITR_TIMEOUT;
 		if (ch == '\n')
 			ch = PROCSPEECH;
 		if (synth_full())
 			return buf;
--
 		while (synth_writable()) {
 			if (!--timeout)
 				return buf;
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (chars_sent < count) {
 		if (speakup_info.flushing) {
 			speakup_info.flushing = 0;
@@ -250,6 +255,12 @@ static ssize_t softsynth_read(struct fil
 		spk_lock(flags);
 		chars_sent++;
--
 	while (inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR) {
 
 		c = inb_p(speakup_info.port_tts+UART_RX);
 		synth->read_buff_add((u_char) c);
 /*printk(KERN_ERR "c = %d\n", c); */
 /*pr_warn("C = %d\n", c); */
--
 	while (spk_serial_tx_busy()) {
 		if (--tmout == 0) {
 			pr_warn("%s: timed out (tx busy)\n", synth->long_name);
@@ -152,8 +168,19 @@ int wait_for_xmitr(void)
 			return 0;
 		}
--
 	while (!((inb_p(speakup_info.port_tts + UART_MSR)) & UART_MSR_CTS)) {
 		/* CTS */
 		if (--tmout == 0) {
@@ -163,6 +190,12 @@ int wait_for_xmitr(void)
 			return 0;
 		}
--
 	while (!(inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR)) {
 		if (--tmout == 0) {
 			pr_warn("time out while waiting for input.\n");
 			return 0xff;
 		}
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((ch = (u_char)*buf)) {
 		if (synth_full())
 			return buf;
@@ -253,6 +258,12 @@ static const char *synth_immediate(struc
 			ch = PROCSPEECH;
 		spk_out(ch);
--
 	while ((ch = (u_char) *cp)) {
 		if (cp != buf)
 			synth_printf(" %s ", delay_str[spell_delay]);
@@ -719,6 +724,12 @@ static void spell_word(struct vc_data *v
 		}
 		synth_printf("%s", cp1);
--
 	while (start <= end) {
 		from = start + (win_left * 2);
 		to = start + (win_right * 2);
 		say_from_to(vc, from, to, 1);
 		start += vc->vc_size_row;
+		if (_cur < timeout) {
--
 	while (count--) {
 		if (cursor_track == read_all_mode) {
 			/* Insert Sentence Index */
@@ -1106,6 +1133,12 @@ static void spkup_write(const char *in_b
 		}
 		old_ch = ch;
--
 	while ((ch = *cp1)) {
 		if (ch >= MAX_KEY)
 			return -4;
 		our_keys[ch] = cp1;
 		cp1 += states + 1;
+		if (_cur < timeout) {
--
 	while (status & UTSR0_EIF) {
 		int bstat;
 
@@ -583,6 +588,12 @@ static irqreturn_t sir_interrupt(int irq
 		bstat = Ser2UTDR;
 		n++;
--
 	while ((iir = inb(io + UART_IIR) & UART_IIR_ID)) {
 		switch (iir&UART_IIR_ID) { /* FIXME toto treba preriedit */
 		case UART_IIR_MSI:
@@ -695,6 +711,12 @@ static irqreturn_t sir_interrupt(int irq
 		default:
 			break;
--
-	while (bytes_out--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (bytes_out--) {
 		outb(PULSE, io + UART_TX);
 		/* FIXME treba seriozne cakanie z char/serial.c */
 		while (!(inb(io + UART_LSR) & UART_LSR_THRE))
 			;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while ((now - start) < length) {
 		/* Delay till flip time */
 		do {
@@ -516,6 +521,12 @@ static long send_pulse_homebrew_softcarr
 			target += pulse_width;
 		}
--
 	while (actual < length) {
 		if (flag) {
 			off();
@@ -555,6 +571,12 @@ static long send_pulse_homebrew_softcarr
 		udelay(d);
 		actual += (d << 8) + LIRC_SERIAL_TRANSMITTER_LATENCY;
--
-	while (i < max) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < max) {
 		/* 1 Igor-tick = 85.333333 us */
 		code = (unsigned int)ir->buf_in[i] * 85 +
 			(unsigned int)ir->buf_in[i] / 3;
@@ -293,6 +298,12 @@ static void send_fragment(struct igorplu
 		/* 1 chunk = CODE_LENGTH bytes */
--
 	while (count--) {
 		**out <<= 1;
 		**out |= !!(value & (1 << 31)); /* MSB */
 		value <<= 1;
 		if (++(*bits) % 8 == 0)
 			(*out)++;
--
 	while (value > max) {
 		max = (max + 2) * 2 - 2;
 		cnt++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (solo_dev->enc_idx != cur_q) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (solo_dev->enc_idx != cur_q) {
 		mpeg_current = solo_reg_read(solo_dev,
 					SOLO_VE_MPEG4_QUE(solo_dev->enc_idx));
 		jpeg_current = solo_reg_read(solo_dev,
@@ -895,6 +922,12 @@ void solo_enc_v4l2_isr(struct solo_dev *
 					SOLO_NR_RING_BUFS;
--
 	while (!list_empty(&pd->dmaq)) {
 		vb = list_first_entry(&pd->dmaq, typeof(*vb), done_entry);
 		list_del(&vb->done_entry);
 		vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (*p2) {
 			p1 = p2;
 			while (*p2 && ('.' != *p2))
@@ -1050,6 +1055,12 @@ long easycap_unlocked_ioctl(struct file
 				k[i] = (int)lng;
 			}
 			i++;
+			if (_cur < timeout) {
--
 			while (p1 < &bfbar[barwidth]) {
 				*p1++ = uyvy[0] ;
 				*p1++ = uyvy[1] ;
 				*p1++ = uyvy[2] ;
 				*p1++ = uyvy[3] ;
 				total += 4;
--
 			while (more) {
 				if ((FIELD_BUFFER_SIZE/PAGE_SIZE) <= m) {
 					SAM("ERROR:  bad m reached\n");
@@ -148,6 +164,12 @@ easycap_testcard(struct easycap *peasyca
 					m++;
 					n = 0;
--
 		while (more) {
 			much = dma_bytes - peasycap->dma_fill;
 			if (0 > much) {
@@ -249,6 +254,12 @@ easycap_alsa_complete(struct urb *purb)
 					snd_pcm_period_elapsed(pss);
 				}
--
 			while (elem) {
 				callback(&elem->data, user_data);
 				elem = elem->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (shift <= fieldsz) {
 		dp += direction;
 		objval += (rvalue) *dp << shift;
 		shift += TGTAU_BITS;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (mask) {
 		dp += direction;
 		*dp = (*dp & ~mask) + objval;
 		objval >>= TGTAU_BITS;
 		mask >>= TGTAU_BITS;
+		if (_cur < timeout) {
--
 	while (rop_map1[rx] != rp->TYPE) {
 		rx = HASH_L(rop_map2[rx]);
 		if (rx < 0) {
@@ -210,6 +237,12 @@ void dload_relocate(struct dload_state *
 #endif
 			return;
--
 	while (*name) {
 		hash <<= 1;
 		hash ^= *name++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (i < chunk->region_size) {
 			if (chunk[i].mapped) {
 				/* Remove mapping from the page tables. */
@@ -384,6 +389,12 @@ int dmm_un_reserve_memory(struct dmm_obj
 				i += chunk_size;
 			} else
--
 	while ((vma) && (ul_mpu_addr + ul_num_bytes > vma->vm_end)) {
 		/* jump to the next VMA region */
 		vma = find_vma(mm, vma->vm_end + 1);
@@ -1240,6 +1245,12 @@ static int bridge_brd_mem_map(struct bri
 			"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n", ul_mpu_addr,
 			ul_num_bytes, vma->vm_start, vma->vm_end,
--
 	while (rem_bytes && !status) {
 		u32 va_curr_orig = va_curr;
 		/* Find whether the L1 PTE points to a valid L2 PT */
@@ -1439,6 +1455,11 @@ static int bridge_brd_mem_un_map(struct
 			else
 				numof4k_pages = 1;
--
 			while (temp++ < numof4k_pages) {
 				if (!pfn_valid(__phys_to_pfn(paddr))) {
 					paddr += HW_PAGE_SIZE4KB;
@@ -1455,6 +1476,12 @@ static int bridge_brd_mem_un_map(struct
 					page_cache_release(pg);
 				}
--
 		while (temp++ < numof4k_pages) {
 			if (pfn_valid(__phys_to_pfn(paddr))) {
 				pg = PHYS_TO_PAGE(paddr);
@@ -1518,6 +1550,12 @@ skip_coarse_page:
 				}
 			}
--
 	while (num_bytes && !status) {
 		/* To find the max. page size with which both PA & VA are
 		 * aligned */
@@ -1610,6 +1659,12 @@ static int pte_update(struct bridge_dev_
 				break;
 			}
--
-		while (++i < num_pages) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (++i < num_pages) {
 			page[0] =
 			    vmalloc_to_page((void *)(va_curr + size_curr));
 			pa_next = page_to_phys(page[0]);
@@ -1761,6 +1821,12 @@ static int mem_map_vmalloc(struct bridge
 			else
--
 		while (temp++ < num_of4k_pages) {
 			get_page(PHYS_TO_PAGE(pa));
 			pa += HW_PAGE_SIZE4KB;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (io_msg_pend) {
 		/* Unblock thread */
 		sync_set_event(msg_queue_obj->sync_done);
 		/* Wait for acknowledgement */
 		sync_wait_on_event(msg_queue_obj->sync_done_ack, SYNC_INFINITE);
 		io_msg_pend = msg_queue_obj->io_msg_pend;
--
-	while (num_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_bytes) {
 		/*
 		 * To find the max. page size with which both PA & VA are
 		 * aligned.
@@ -501,6 +506,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 				break;
--
-	while (num_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_bytes) {
 		/*
 		 * To find the max. page size with which both PA & VA are
 		 * aligned.
@@ -573,6 +589,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 			 */
--
-	while (l4_peripheral_table[i].phys_addr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l4_peripheral_table[i].phys_addr) {
 		status = hio_mgr->intf_fxns->brd_mem_map
 		    (hio_mgr->bridge_context, l4_peripheral_table[i].phys_addr,
 		     l4_peripheral_table[i].dsp_virt_addr, HW_PAGE_SIZE4KB,
@@ -644,6 +671,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 		if (status)
--
-	while (true) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (true) {
 		/* Get the DSP current pointer */
 		ul_gpp_cur_pointer =
 		    *(u32 *) (hio_mgr->trace_buffer_current);
@@ -1740,6 +1778,12 @@ void print_dsp_debug_trace(struct io_mgr
 			/* Print the trace messages */
--
-			while (str_beg < buf_end) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (str_beg < buf_end) {
 				new_line = strnchr(str_beg, ul_num_bytes,
 								'\n');
 				if (new_line && new_line < buf_end) {
@@ -1877,6 +1926,12 @@ int print_dsp_trace_buffer(struct bridge
 					str_beg = buf_end;
--
 			while (str_beg < trace_end) {
 				new_line = strnchr(str_beg, ul_num_bytes, '\n');
 				if (new_line != NULL && new_line < trace_end) {
@@ -1905,6 +1965,12 @@ int print_dsp_trace_buffer(struct bridge
 					str_beg = trace_end;
 					ul_num_bytes = 0;
--
-			while (!list_empty(&pchnl->io_requests) && !status) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&pchnl->io_requests) && !status) {
 				status = bridge_chnl_get_ioc(chnl_obj,
 						timeout, &chnl_ioc_obj);
 				if (status)
@@ -484,6 +489,12 @@ int bridge_chnl_flush_io(struct chnl_obj
 				if (chnl_ioc_obj.status & CHNL_IOCSTATTIMEOUT)
--
 	while ((pwr_state != target_pwr_state) && --timeout) {
 		if (msleep_interruptible(10)) {
 			pr_err("Waiting for DSP to Suspend interrupted\n");
@@ -210,6 +215,12 @@ int sleep_dsp(struct bridge_dev_context
 		}
 		pwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD,
--
 			while (next) {
 				hptr = next;
 				next = hptr->next;
 				kfree(hptr);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (ovly_section && i < alloc_num) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ovly_section && i < alloc_num) {
 		/* 'Deallocate' */
 		/* segid - page not supported yet */
 		/* Reserved memory */
@@ -1132,6 +1181,12 @@ static void free_sects(struct nldr_objec
 		DBC_ASSERT(ret);
--
-	while (ovly_section) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ovly_section) {
 		/* allocate *//* page not supported yet */
 		/* reserve *//* align */
 		status = rmm_alloc(nldr_obj->rmm, 0, ovly_section->size, 0,
@@ -1523,13 +1583,24 @@ static int load_ovly(struct nldr_nodeobj
 		} else {
--
-			while (ovly_section) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (ovly_section) {
 				/* page not supported *//* align */
 				/* reserve */
 				status =
@@ -1543,6 +1614,12 @@ static int load_ovly(struct nldr_nodeobj
 				} else {
--
-			while (ovly_section && !status) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (ovly_section && !status) {
 				bytes =
 				    (*nldr_obj->ovly_fxn) (nldr_node_obj->
 							   priv_ref,
@@ -1564,6 +1646,12 @@ static int load_ovly(struct nldr_nodeobj
 					status = -EPERM;
--
-			while (ovly_section && !status) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (ovly_section && !status) {
 				bytes =
 				    (*nldr_obj->ovly_fxn) (nldr_node_obj->
 							   priv_ref,
@@ -1585,6 +1678,12 @@ static int load_ovly(struct nldr_nodeobj
 					status = -EPERM;
--
 	while (len) {
 		page = get_mapping_page(map_obj, pg_i);
 		if (!page) {
@@ -660,6 +665,12 @@ static int build_dma_sg(struct dmm_map_o
 		len -= rest;
 		start += rest;
--
-	while (atomic_read(&net_device->num_outstanding_sends)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&net_device->num_outstanding_sends)) {
 		dev_info(&device->device,
 			"waiting for %d requests to complete...\n",
 			atomic_read(&net_device->num_outstanding_sends));
 		udelay(100);
+		if (_cur < timeout) {
--
 		while (destlen) {
 			src = bounce_addr + bounce_sgl[j].offset;
 			srclen = bounce_sgl[j].length - bounce_sgl[j].offset;
@@ -884,6 +889,12 @@ static unsigned int copy_from_bounce_buf
 				/* unmap the last bounce that is < PAGE_SIZE */
 				kunmap_atomic((void *)bounce_addr, KM_IRQ0);
--
 		while (srclen) {
 			/* assume bounce offset always == 0 */
 			dest = bounce_addr + bounce_sgl[j].length;
@@ -951,6 +967,12 @@ static unsigned int copy_to_bounce_buffe
 				/* unmap the last bounce that is < PAGE_SIZE */
 				kunmap_atomic((void *)bounce_addr, KM_IRQ0);
--
 	while (!list_empty(&nvec->tx_data)) {
 		msg = list_first_entry(&nvec->tx_data, struct nvec_msg, node);
 		spin_unlock_irqrestore(&nvec->tx_lock, flags);
@@ -347,6 +352,12 @@ static void nvec_request_master(struct w
 			list_del_init(&msg->node);
 			nvec_msg_free(nvec, msg);
--
 	while (!list_empty(&nvec->rx_data)) {
 		msg = list_first_entry(&nvec->rx_data, struct nvec_msg, node);
 		list_del_init(&msg->node);
@@ -408,6 +424,12 @@ static void nvec_dispatch(struct work_st
 			nvec_msg_free(nvec, msg);
 		}
--
     while (tempword & FT1000_DB_DPRAM_TX) {
         mdelay(10);
         i++;
@@ -812,7 +817,13 @@ static void ft1000_send_cmd (struct net_
             return;
         }
--
     while (inttype) {
 	if (inttype & ISR_DOORBELL_PEND) {
 		ft1000_parse_dpram_msg(dev);
@@ -2033,7 +2049,13 @@ static irqreturn_t ft1000_interrupt(int
         // Read interrupt type
         inttype = ft1000_read_reg (dev, FT1000_REG_SUP_ISR);
--
 	while (!kthread_should_stop()) {
 		msleep(10);
 		if (!gPollingfailed) {
@@ -50,6 +55,12 @@ int ft1000_poll_thread(void *arg)
 				gPollingfailed = TRUE;
 			}
--
 	while (!pft1000info->CardReady) {
 		if (gPollingfailed) {
 			ret = -EIO;
@@ -190,6 +206,12 @@ static int ft1000_probe(struct usb_inter
 		}
 		msleep(100);
--
 		while (tempword & FT1000_DB_DPRAM_TX) {
 			mdelay(10);
 			i++;
@@ -1397,6 +1402,12 @@ static int ft1000_dsp_prov(void *arg)
 			}
 			ft1000_read_register(dev, &tempword,
--
-	while (retry--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (retry--) {
 		if (inb(iobase + 3) & 0x80)
 			return 0;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (timeout &&
 		       !(inb(dev->iobase + AIO12_8_STATUS) & STATUS_ADC_EOC)) {
 			timeout--;
 			printk(KERN_ERR "timeout %d\n", timeout);
 			udelay(1);
+			if (_cur < timeout) {
--
 		while (timeout--) {
 			if (!(inw(dev->iobase + PCI171x_STATUS) & Status_FE))
 				goto conv_finish;
@@ -375,6 +380,12 @@ static int pci171x_insn_read_ai(struct c
 				DPRINTK("adv_pci1710 D n=%d tm=%d ST=%4x\n", n,
 					timeout,
--
 		while (ni_readl(AIFIFO_Status_6143) & 0x04) {
 			dl = ni_readl(AIFIFO_Data_6143);
 
@@ -1497,6 +1502,12 @@ static void ni_handle_fifo_dregs(struct
 			data[1] = (dl & 0xffff);
 			cfc_write_array_to_buffer(s, data, sizeof(data));
--
 	while ((status1 =
 		devpriv->stc_readw(dev,
 				   Joint_Status_1_Register)) &
@@ -4026,6 +4042,12 @@ static int ni_serial_hw_readwrite8(struc
 			err = -ETIME;
 			goto Error;
--
 		while (devpriv->ndevs-- && devpriv->devs) {
 			struct BondedDevice *bdev;
 
@@ -482,6 +487,12 @@ static void doDevUnconfig(struct comedi_
 				devs_closed |= (0x1 << bdev->minor);
 			}
--
 		while (--i) {
 			hi = inb(dev->iobase + PCL711_AD_HI);
 			if (!(hi & PCL711_DRDY))
 				goto ok;
 			udelay(1);
+			if (_cur < timeout) {
--
 		while (timeout--) {
 			if (inb(dev->iobase + PCL818_STATUS) & 0x10)
 				goto conv_finish;
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (timeout--) {
 		if (inb(dev->iobase + PCL818_STATUS) & 0x10)
 			goto conv_finish;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (timeout--) {
 			if (inl(dev->iobase + PCI9118_ADSTAT) & AdStatus_ADrdy)
 				goto conv_finish;
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (1) {
 		if (!(inb(dev->iobase + 8) & 0x01))
 			return;
 		comedi_buf_put(s->async, inw(dev->iobase));
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((this_usbduxsub->ai_interval) < (cmd->chanlist_len)) {
 			this_usbduxsub->ai_interval =
 			    (this_usbduxsub->ai_interval) * 2;
+			    if (_cur < timeout) {
+			rdstcll(_cur);
+			    }
--
-		while (timeout--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (timeout--) {
 			if (!(readw(devpriv->io_addr +
 				    ICP_MULTI_ADC_CSR) & ADC_BSY))
 				goto conv_finish;
@@ -322,6 +327,12 @@ static int icp_multi_insn_read_ai(struct
 #endif
--
-		while (timeout--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (timeout--) {
 			if (!(readw(devpriv->io_addr +
 				    ICP_MULTI_DAC_CSR) & DAC_BSY))
 				goto dac_ready;
@@ -436,6 +452,12 @@ static int icp_multi_insn_write_ao(struc
 #endif
--
 				while (position < num_samples) {
 					if (dev_private->chunk_counter <
 					    dev_private->chanlist_len) {
@@ -1086,6 +1091,12 @@ static irqreturn_t pci9111_interrupt(int
 					if (dev_private->chunk_counter >=
 					    dev_private->chunk_num_samples)
--
 		while (timeout--) {
 			if (!pci9111_is_fifo_empty())
 				goto conversion_done;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (1) {
 		int data = tty_read(f, timeout);
 
@@ -352,6 +357,12 @@ static struct serial_data serial_read(st
 			result.index = data & 0x1f;
 			break;
--
 		while (1) {
 			struct serial_data data;
 
@@ -562,6 +578,12 @@ static int serial_2002_open(struct comed
 					}
 				}
--
 	while (RtdFifoStatus(dev) & FS_ADC_NOT_EMPTY) {	/* 1 -> not empty */
 		short sample;
 		s16 d = RtdAdcFifoGet(dev);	/* get 2s comp value */
@@ -1416,6 +1421,12 @@ static int ai_read_dregs(struct comedi_d
 
 		if (devpriv->aiCount > 0)	/* < 0, means read forever */
--
 		while (timeout--) {
 			hi = inb(dev->iobase + PCL812_AD_HI);
 			if (!(hi & PCL812_DRDY))
 				goto conv_finish;
 			udelay(1);
+			if (_cur < timeout) {
--
 		while (timeout--) {
 			if (!(inb(dev->iobase + ACL8216_STATUS) & ACL8216_DRDY))
 				goto conv_finish;
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-			while (flags & TransferReady) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (flags & TransferReady) {
 				work++;
 				if (work > 100) {
 					DPRINTK("too much work in interrupt\n");
@@ -579,6 +584,12 @@ static irqreturn_t nidio_interrupt(int i
 				/* DPRINTK("read:%d, %d\n",data1,data2); */
--
 	while (b & 1) {
 		writew(0xff, devpriv->mite->daq_io_addr + Group_1_FIFO);
 		b = readb(devpriv->mite->daq_io_addr + Group_1_Flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (num_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (num_bytes) {
 		unsigned int block_size;
 
 		if (write_ptr + num_bytes > async->prealloc_bufsz)
@@ -722,6 +727,12 @@ void comedi_buf_memcpy_to(struct comedi_
 		num_bytes -= block_size;
--
-	while (nbytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nbytes) {
 		unsigned int block_size;
 
 		src = async->prealloc_buf + read_ptr;
@@ -749,6 +765,12 @@ void comedi_buf_memcpy_from(struct comed
 		nbytes -= block_size;
--
 		while ((skb = skb_dequeue(&hw->authq))) {
 			inf = (hfa384x_InfFrame_t *) skb->data;
 			prism2sta_inf_authreq_defer(wlandev, inf);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (curroff < (HFA384x_PDA_LEN_MAX / 2) &&
 	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
 		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
@@ -623,6 +628,12 @@ int mkpdrlist(struct pda *pda)
 		(pda->nrec)++;
 		curroff += le16_to_cpu(pda16[curroff]) + 1;
--
 	while (record) {
 
 		rcnt++;
@@ -957,6 +973,12 @@ int read_fwfile(const struct ihex_binrec
 			break;
 		}
--
 	while ((skb = skb_dequeue(&wlandev->nsd_rxq))) {
 		if (wlandev->state == WLAN_DEVICE_OPEN) {
 
@@ -323,6 +328,12 @@ static void p80211netdev_rx_bh(unsigned
 			}
 		}
--
 	while (i < num_channels) {
 		if (bytes % channels[i].bytes == 0)
 			channels[i].location = bytes;
@@ -50,6 +55,12 @@ int size_from_channelarray(struct iio_ch
 				+ channels[i].bytes;
 		bytes = channels[i].location + channels[i].bytes;
--
 	while ((initial_read_p != ring->read_p)
 	       || (initial_write_p != ring->write_p)) {
 		initial_read_p = ring->read_p;
 		initial_write_p = ring->write_p;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (*av_masks) {
 		if (bitmap_subset(mask, av_masks, masklength))
 			return av_masks;
 		av_masks += BITS_TO_LONGS(masklength);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len--) {
 		ret = i2c_smbus_write_byte_data(client, reg++, *data++);
 		if (ret < 0) {
 			dev_err(&client->dev, "I2C write error\n");
 			return ret;
 		}
--
 	while (len--) {
 		ret = i2c_smbus_read_byte_data(client, reg++);
 		if (ret < 0) {
@@ -147,6 +163,12 @@ static int ad5933_i2c_read(struct i2c_cl
 			return ret;
 		}
--
 	while (timeout--) {
 		ret =  ad5933_i2c_read(st->client, AD5933_REG_STATUS, 1, &val);
 		if (ret < 0)
@@ -179,6 +206,12 @@ static int ad5933_wait_busy(struct ad593
 			return val;
 		cpu_relax();
--
-	while (retry) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (retry) {
 		ret = i2c_smbus_read_word_data(client,
 				TSL2563_CMD | TSL2563_REG_DATA0LOW);
 		if (ret < 0)
@@ -343,6 +348,12 @@ static int tsl2563_get_adc(struct tsl256
 		adc1 = ret;
--
 	while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
 	       && (pl022->rx < pl022->rx_end)) {
 		switch (pl022->read) {
@@ -690,10 +695,21 @@ static void readwriter(struct pl022 *pl0
 		}
 		pl022->rx += (pl022->cur_chip->n_bytes);
--
 	while ((pl022->exp_fifo_level < pl022->vendor->fifodepth)
 	       && (pl022->tx < pl022->tx_end)) {
 		switch (pl022->write) {
@@ -718,6 +734,11 @@ static void readwriter(struct pl022 *pl0
 		 * clock starts running when you put things into the TX FIFO,
 		 * and then things are continuously clocked into the RX FIFO.
--
 		while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
 		       && (pl022->rx < pl022->rx_end)) {
 			switch (pl022->read) {
@@ -739,6 +760,18 @@ static void readwriter(struct pl022 *pl0
 			}
 			pl022->rx += (pl022->cur_chip->n_bytes);
--
 		while (pl022->tx < pl022->tx_end || pl022->rx < pl022->rx_end) {
 			time = jiffies;
 			readwriter(pl022);
@@ -1469,6 +1507,12 @@ static void do_polling_transfer(struct p
 				goto out;
 			}
--
 	while ((!list_empty(&pl022->queue) || pl022->busy) && limit--) {
 		spin_unlock_irqrestore(&pl022->queue_lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&pl022->queue_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (SPIE_RXCNT(events) < min(4, mspi->len)) {
 			cpu_relax();
 			events = mpc8xxx_spi_read_reg(&reg_base->event);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 			while (tmp--) {
 				rx_data_8 = in_8((u8 *)&reg_base->receive);
 				rx_data |= (rx_data_8 << (tmp * 8));
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-	 while (!list_empty(&hw->msg_queue)) {
+	 unsigned long long delta = (cpu / khz / HZ) * 2;
+	 unsigned long long _start = 0;
+	 unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
+		while (!list_empty(&hw->msg_queue)) {
 		struct spi_message	*m;
 		struct spi_device	*spi;
 		struct spi_transfer	*t = NULL;
@@ -229,6 +234,12 @@ static void ti_ssp_spi_work(struct work_
 		m->complete(m->context);
--
 	while (!list_empty(&hw->msg_queue)) {
 		error = wait_for_completion_interruptible(&hw->complete);
 		if (error < 0) {
 			hw->shutdown = 0;
 			return error;
 		}
--
 	while (spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_RBE) {
 		udelay(10);
 		if (timeout-- < 0)
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!(spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_TBE)) {
 		udelay(10);
 		if (timeout-- < 0)
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!list_empty(&ss->queue)) {
 		mesg = list_entry(ss->queue.next, struct spi_message, queue);
 		list_del_init(&mesg->queue);
@@ -320,6 +347,12 @@ static void spi_sh_work(struct work_stru
 
 		mesg->status = 0;
--
 	 while (!list_empty(&spi100k->msg_queue)) {
 		struct spi_message              *m;
 		struct spi_device               *spi;
@@ -418,6 +423,12 @@ static void omap1_spi100k_work(struct wo
 		m->complete(m->context);
 
--
 	while (!list_empty(&spi100k->msg_queue) && limit--) {
 		spin_unlock_irqrestore(&spi100k->lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&spi100k->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u8 *) (drv_data->tx++)));
 		/* wait until transfer finished.
@@ -236,6 +241,12 @@ static void bfin_spi_u8_writer(struct bf
 			cpu_relax();
 		/* discard RX data and clear RXS */
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, tx_val);
 		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
 			cpu_relax();
 		*(u8 *) (drv_data->rx++) = bfin_read(&drv_data->regs->rdbr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u8 *) (drv_data->tx++)));
 		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
 			cpu_relax();
 		*(u8 *) (drv_data->rx++) = bfin_read(&drv_data->regs->rdbr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u16 *) (drv_data->tx)));
 		drv_data->tx += 2;
@@ -287,6 +325,12 @@ static void bfin_spi_u16_writer(struct b
 			cpu_relax();
 		/* discard RX data and clear RXS */
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, tx_val);
 		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
 			cpu_relax();
 		*(u16 *) (drv_data->rx) = bfin_read(&drv_data->regs->rdbr);
 		drv_data->rx += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u16 *) (drv_data->tx)));
 		drv_data->tx += 2;
@@ -318,6 +378,12 @@ static void bfin_spi_u16_duplex(struct b
 			cpu_relax();
 		*(u16 *) (drv_data->rx) = bfin_read(&drv_data->regs->rdbr);
--
 	while ((!list_empty(&drv_data->queue) || drv_data->busy) && limit--) {
 		spin_unlock_irqrestore(&drv_data->lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&drv_data->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!(__raw_readl(reg) & bit)) {
 		if (time_after(jiffies, timeout))
 			return -1;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&mcspi->msg_queue)) {
 		struct spi_message		*m;
 		struct spi_device		*spi;
@@ -969,6 +985,12 @@ static void omap2_mcspi_work(struct work
 		m->complete(m->context);
 
--
-			while ((TX_FIFO_LVL(status, sci)
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while ((TX_FIFO_LVL(status, sci)
 				|| !S3C64XX_SPI_ST_TX_DONE(status, sci))
 					&& --val) {
 				cpu_relax();
 				status = readl(regs + S3C64XX_SPI_STATUS);
+				if (_cur < timeout) {
--
-	while (!list_empty(&sdd->queue)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&sdd->queue)
 				&& !(sdd->state & SUSPND)) {
 
 		struct spi_message *msg;
@@ -801,6 +817,12 @@ static void s3c64xx_spi_work(struct work
 		spin_lock_irqsave(&sdd->lock, flags);
--
 		while (len) {
 			unsigned int count = SPI_FIFO_SIZE;
 			int i;
@@ -254,6 +259,12 @@ static void txx9spi_work_one(struct txx9
 				}
 			}
--
 	while (!list_empty(&c->queue)) {
 		struct spi_message *m;
 
@@ -300,6 +316,12 @@ static void txx9spi_work(struct work_str
 		txx9spi_work_one(c, m);
 
--
 		while (read_SSSR(reg) & SSSR_RNE) {
 			read_SSDR(reg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	} while ((read_SSSR(reg) & SSSR_BSY) && --limit);
 	write_SSSR_CS(drv_data, SSSR_ROR);
@@ -264,10 +275,21 @@ static int null_reader(struct driver_dat
 	void __iomem *reg = drv_data->ioaddr;
 	u8 n_bytes = drv_data->n_bytes;
 
--
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		read_SSDR(reg);
 		drv_data->rx += n_bytes;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		*(u8 *)(drv_data->rx) = read_SSDR(reg);
 		++drv_data->rx;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		*(u16 *)(drv_data->rx) = read_SSDR(reg);
 		drv_data->rx += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		*(u32 *)(drv_data->rx) = read_SSDR(reg);
 		drv_data->rx += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((!list_empty(&drv_data->queue) || drv_data->busy) && limit--) {
 		spin_unlock_irqrestore(&drv_data->lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&drv_data->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (rb < t->len) {
 		if (t->len - rb > MPC52xx_PSC_BUFSIZE) {
 			rfalarm = MPC52xx_PSC_RFALARM;
@@ -196,6 +201,12 @@ static int mpc52xx_psc_spi_transfer_rxtx
 			for (; recv_at_once; rb++, recv_at_once--)
 				in_8(&psc->mpc52xx_psc_buffer_8);
--
 	while (!list_empty(&mps->queue)) {
 		struct spi_message *m;
 		struct spi_device *spi;
@@ -256,6 +272,12 @@ static void mpc52xx_psc_spi_work(struct
 		mpc52xx_psc_spi_transfer_setup(spi, NULL);
 
--
 	while (id->name[0]) {
 		if (!strcmp(sdev->modalias, id->name))
 			return id;
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&mpc8xxx_spi->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mpc8xxx_spi->queue)) {
 		struct spi_message *m = container_of(mpc8xxx_spi->queue.next,
 						   struct spi_message, queue);
 
@@ -76,6 +81,12 @@ void mpc8xxx_spi_work(struct work_struct
 			mpc8xxx_spi->spi_do_one_msg(m);
--
-	while (!list_empty(&mcfqspi->msgq)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&mcfqspi->msgq)) {
 		struct spi_message *msg;
 		struct spi_device *spi;
 		struct spi_transfer *xfer;
@@ -376,6 +381,12 @@ static void mcfqspi_work(struct work_str
 		msg->complete(msg->context);
--
 	while (!list_empty(&bitbang->queue)) {
 		struct spi_message	*m;
 		struct spi_device	*spi;
@@ -373,6 +378,12 @@ static void bitbang_work(struct work_str
 		}
 
--
 	while (len) {
 		int count;
 		int i;
@@ -201,12 +206,29 @@ static int mpc512x_psc_spi_transfer_rxtx
 			if (rx_buf)
 				*rx_buf++ = data;
--
 		while (in_be32(&fifo->rxcnt)) {
 			in_8(&fifo->rxdata_8);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (!list_empty(&mps->queue)) {
 		struct spi_message *m;
 		struct spi_device *spi;
@@ -268,6 +295,12 @@ static void mpc512x_psc_spi_work(struct
 		mpc512x_psc_spi_transfer_setup(spi, NULL);
 
--
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx8++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		dummy = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, tx_val);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx8++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx8++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx8++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx16++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		dummy = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, tx_val);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx16++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx16++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx16++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&drv_data->queue) && drv_data->busy && limit--) {
 		spin_unlock_irqrestore(&drv_data->lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&drv_data->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (max--) {
 		/* Set the tx word if the transfer's original "tx" is not null */
 		if (dws->tx_end - dws->len) {
@@ -206,6 +211,12 @@ static void dw_writer(struct dw_spi *dws
 		}
 		dw_writew(dws, DW_SPI_DR, txw);
--
 	while (max--) {
 		rxw = dw_readw(dws, DW_SPI_DR);
 		/* Care rx only if the transfer's original "rx" is not null */
@@ -224,6 +240,12 @@ static void dw_reader(struct dw_spi *dws
 				*(u16 *)(dws->rx) = rxw;
 		}
--
 	while ((!list_empty(&dws->queue) || dws->busy) && limit--) {
 		spin_unlock_irqrestore(&dws->lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&dws->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (1) {
 			unsigned int rxd;
 
 			while (!(readl(hw->base + ALTERA_SPI_STATUS) &
@@ -180,6 +185,12 @@ static int altera_spi_txrx(struct spi_de
 				       hw->base + ALTERA_SPI_TXDATA);
 			else
 				break;
+				if (_cur < timeout) {
--
 	while ((ep93xx_spi_read_u8(espi, SSPSR) & SSPSR_RNE)) {
 		ep93xx_do_read(espi, t);
 		espi->fifo_level--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (ep93xx_spi_read_u16(espi, SSPSR) & SSPSR_RNE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ep93xx_spi_read_u16(espi, SSPSR) & SSPSR_RNE) {
 		if (time_after(jiffies, timeout)) {
 			dev_warn(&espi->pdev->dev,
 				 "timeout while flushing RX FIFO\n");
@@ -842,6 +858,12 @@ static void ep93xx_spi_process_message(s
 			return;
 		}
 		ep93xx_spi_read_u16(espi, SSPDR);
+		if (_cur < timeout) {
--
-	while (!list_empty(&espi->msg_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&espi->msg_queue)) {
 		struct spi_message *msg;
 
 		msg = list_first_entry(&espi->msg_queue,
@@ -1177,6 +1204,12 @@ static int __devexit ep93xx_spi_remove(s
 		spin_unlock_irq(&espi->lock);
--
 	while (!list_empty(&ss->queue)) {
 		m = list_entry(ss->queue.next, struct spi_message, queue);
 		list_del_init(&m->queue);
@@ -401,6 +406,12 @@ static void stmp_spi_handle(struct work_
 		m->complete(m->context);
 
--
 	while (!list_empty(&orion_spi->msg_queue)) {
 		struct spi_message *m;
 		struct spi_device *spi;
@@ -340,6 +345,12 @@ msg_done:
 		m->complete(m->context);
 
--
-		while (len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (len) {
 			if (bits > 8) {
 				bytes = 2;
 			} else
@@ -310,6 +315,12 @@ static int uwire_txrx(struct spi_device
 					dev_name(&spi->dev), bits, val);
--
 	while (spi_imx->devtype_data->rx_available(spi_imx)) {
 		spi_imx->rx(spi_imx);
 		spi_imx->txfifo--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (*bytes_copied < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*bytes_copied < count) {
 		const unsigned long request = count - *bytes_copied;
 		u64 tmp;
 
@@ -961,6 +966,12 @@ int ps3_lpm_copy_tb(unsigned long offset
 		buf += tmp;
--
-	while (*bytes_copied < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*bytes_copied < count) {
 		const unsigned long request = count - *bytes_copied;
 		u64 tmp;
 
@@ -1024,6 +1040,12 @@ int ps3_lpm_copy_tb_to_user(unsigned lon
 		buf += tmp;
--
 	while (priv->rx_list.bytes_held < bytes) {
 		u64 tmp;
 
@@ -639,6 +644,12 @@ int ps3_vuart_read(struct ps3_system_bus
 			spin_unlock_irqrestore(&priv->rx_list.lock, flags);
 			return -EAGAIN;
--
-	while (loopcnt++ <= timeout) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (loopcnt++ <= timeout) {
 		error = ps3_vuart_read(dev, buf, size);
 		if (!error)
 			return size;
@@ -212,6 +217,12 @@ static int ps3av_vuart_read(struct ps3_s
 			return error;
--
 	while (ps3_sys_manager_handle_msg(dev)) {
 		/* pause until next DEC interrupt */
 		lv1_pause(0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (1) {
 		/* pause, ignoring DEC interrupt */
 		lv1_pause(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (i < size_bytes) {
 		if (size_bytes - i == 2) {
 			/* Handle 2 bytes in the end */
@@ -468,6 +473,12 @@ static void read_mem32(u32 *buf, const v
 		}
 		buf++;
--
 	while (i < size_bytes) {
 		if (size_bytes - i == 2) {
 			/* 2 bytes */
@@ -518,6 +534,12 @@ static u32 write_mem32(void __iomem *mem
 		}
 		buf++;
--
 	while (again) {
 		spin_lock_irqsave(&hp->lock, flags);
 		again = hvsi_load_chunk(hp, &flip, &hangup, &handshake);
@@ -527,6 +532,12 @@ static irqreturn_t hvsi_interrupt(int ir
 			pr_debug("hvsi%i: attempting re-handshake\n", handshake->index);
 			schedule_work(&handshake->handshaker);
--
 	while (len) {
 		int sent = __write_console(data, len);
 		
@@ -97,6 +102,12 @@ static int domU_write_console(uint32_t v
 
 		if (unlikely(len))
--
-	while (*residual && count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*residual && count) {
 		residual = hvc_iucv_parse_filter(residual,
 						 array + ((size - count) * 8));
 		if (IS_ERR(residual)) {
@@ -1124,6 +1129,12 @@ static int hvc_iucv_setup_filter(const c
 			goto out_err;
--
 	while(temp_open_count) {
 		--temp_open_count;
 		/*
@@ -1309,6 +1314,12 @@ static void hvcs_hangup(struct tty_struc
 		 * final put will never happen.
 		 */
--
 	while(temp_open_count) {
 		--temp_open_count;
 		tty_kref_put(tty);
 		kref_put(&hp->kref, destroy_hvc_struct);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (wlen) {
 			len2 = (wlen > 2048) ? 2048 : wlen;
 			wlen -= len2;
@@ -587,6 +592,12 @@ static int moxa_real_load_code(struct mo
 			}
 			if (readw(baseAddr + key) != keycode)
--
 	while (call < __con_initcall_end) {
 		(*call)();
 		call++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (i--) {
 		int index = cs[i]->index;
 		struct tty_driver *drv = cs[i]->device(cs[i], &index);
@@ -3333,6 +3349,12 @@ static ssize_t show_cons_active(struct d
 					 cs[i]->name, cs[i]->index);
 
--
 	while (hw->rx_ready && !hw->blocking_rx) {
 		received = 1;
 		hw->rx_ready--;
@@ -939,6 +944,12 @@ static int get_packets_from_hw(struct ip
 		do_receive_packet(hw);
 
--
-		while (len--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+while (len--) {
 			data = cyy_readb(info, CyRDSR);
 			tty_insert_flip_char(tty, data, TTY_NORMAL);
 			info->idle_stats.recv_bytes++;
@@ -561,6 +566,12 @@ static void cyy_chip_rx(struct cyclades_
 #ifdef CY_16Y_HACK
--
-			while (len--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (len--) {
 				data = readb(cinfo->base_addr + rx_bufaddr +
 						new_rx_get);
 				new_rx_get = (new_rx_get + 1) &
@@ -992,7 +1008,13 @@ static void cyz_handle_rx(struct cyclade
 				tty_insert_flip_char(tty, data, TTY_NORMAL);
--
-		while (info->xmit_cnt && char_count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+unsigned long long _start = 0;
+unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+			while (info->xmit_cnt && char_count) {
 			data = info->port.xmit_buf[info->xmit_tail];
 			info->xmit_cnt--;
 			info->xmit_tail = (info->xmit_tail + 1) &
@@ -1083,6 +1110,12 @@ static void cyz_handle_tx(struct cyclade
 			tx_put = (tx_put + 1) & (tx_bufsize - 1);
--
 			while (readl(&port->ip_serial_regs->sscr) &
 			       SSCR_RX_DRAIN) {
 				loop_counter++;
 				if (loop_counter > MAXITER)
 					return -1;
+					if (_cur < timeout) {
--
 	while (status & UTSR1_TO_SM(UTSR1_RNE)) {
 		ch = UART_GET_CHAR(sport);
 
@@ -231,6 +236,12 @@ sa1100_rx_chars(struct sa1100_port *spor
 	ignore_char:
 		status = UTSR1_TO_SM(UART_GET_UTSR1(sport)) |
--
 	while (1) {
 		if (in_be16(&bdp->status) & BD_SC_READY)
 			/* This BD is not done, so return "not done" */
@@ -269,6 +274,12 @@ static unsigned int qe_uart_tx_empty(str
 			return 1;
 
--
 	while (!(in_be16(&bdp->status) & BD_SC_READY) &&
 	       (xmit->tail != xmit->head)) {
 		count = 0;
@@ -385,6 +401,12 @@ static int qe_uart_tx_pump(struct uart_q
 			bdp = qe_port->tx_bd_base;
 		else
--
-	while (up) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (up) {
 		struct zilog_channel __iomem *channel
 			= ZILOG_CHANNEL_FROM_PORT(&up->port);
 		struct tty_struct *tty;
@@ -587,6 +592,12 @@ static irqreturn_t sunzilog_interrupt(in
 			tty_flip_buffer_push(tty);
--
 		while (up) {
 			struct zilog_channel __iomem *channel;
 
@@ -1597,6 +1613,12 @@ static int __init sunzilog_init(void)
 			up->curregs[R9] |= MIE;
 			write_zsreg(channel, R9, up->curregs[R9]);
--
 		while (up) {
 			struct zilog_channel __iomem *channel;
 
@@ -1634,6 +1661,12 @@ static void __exit sunzilog_exit(void)
 			up->curregs[R9] &= ~MIE;
 			write_zsreg(channel, R9, up->curregs[R9]);
--
 		while(!cpm_uart_tx_empty(port)) {
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			schedule_timeout(2);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!(in_be16(&bdp->cbd_sc) & BD_SC_READY) &&
 	       xmit->tail != xmit->head) {
 		count = 0;
@@ -719,6 +735,12 @@ static int cpm_uart_tx_pump(struct uart_
 			bdp = pinfo->tx_bd_base;
 		else
--
-	while (fifocnt--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (fifocnt--) {
 		u8 flag = TTY_NORMAL;
 		ch = ltq_r8(port->membase + LTQ_ASC_RBUF);
 		rsr = (ltq_r32(port->membase + LTQ_ASC_STATE)
@@ -211,6 +216,12 @@ lqasc_rx_chars(struct uart_port *port)
 			 * character
--
-	while (!(readl(s->port.membase + AUART_STAT) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(readl(s->port.membase + AUART_STAT) &
 		 AUART_STAT_TXFF)) {
 		if (s->port.x_char) {
 			s->port.icount.tx++;
@@ -149,6 +154,12 @@ static inline void mxs_auart_tx_chars(st
 				uart_write_wakeup(&s->port);
--
 	while ((status = readl(port->membase + ALTERA_JTAGUART_DATA_REG)) &
 	       ALTERA_JTAGUART_DATA_RVALID_MSK) {
 		ch = status & ALTERA_JTAGUART_DATA_DATA_MSK;
@@ -137,6 +142,12 @@ static void altera_jtaguart_rx_chars(str
 		if (uart_handle_sysrq_char(port, ch))
 			continue;
--
-			while (count--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (count--) {
 				writel(xmit->buf[xmit->tail],
 				       port->membase + ALTERA_JTAGUART_DATA_REG);
 				xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 				port->icount.tx++;
+				if (_cur < timeout) {
--
 	while ((status = readb(port->membase + MCFUART_USR)) & MCFUART_USR_RXREADY) {
 		ch = readb(port->membase + MCFUART_URB);
 		flag = TTY_NORMAL;
@@ -308,6 +313,12 @@ static void mcf_rx_chars(struct mcf_uart
 		if (uart_handle_sysrq_char(port, ch))
 			continue;
--
-	while (!((cmdstat = be32_to_cpu(rxre->cmdstat))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!((cmdstat = be32_to_cpu(rxre->cmdstat))
 				& SDMA_DESC_CMDSTAT_O)) {
 		bytes_in = be16_to_cpu(rxre->bytecnt);
 #ifdef CONFIG_CONSOLE_POLL
@@ -1075,6 +1080,12 @@ next_frame:
 					(ulong)rxre + MPSC_RXRE_SIZE);
--
-	while (CIRC_CNT(pi->txr_head, pi->txr_tail, MPSC_TXR_ENTRIES)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (CIRC_CNT(pi->txr_head, pi->txr_tail, MPSC_TXR_ENTRIES)
 			< (MPSC_TXR_ENTRIES - 1)) {
 		if (pi->port.x_char) {
 			/*
@@ -1157,6 +1173,12 @@ static void mpsc_copy_tx_data(struct mps
 
--
 	while (pi->txr_head != pi->txr_tail) {
 		while (mpsc_sdma_tx_active(pi))
 			udelay(100);
 		mpsc_sdma_intr_ack(pi);
 		mpsc_tx_intr(pi);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (mpsc_sdma_tx_active(pi))
diff -u -p a/tty/serial/zs.c b/tty/serial/zs.c
--- a/tty/serial/zs.c
+++ b/tty/serial/zs.c
@@ -242,10 +242,21 @@ static int zs_transmit_drain(struct zs_p
 	struct zs_scc *scc = zport->scc;
--
 	while (!(read_zsreg(zport, R0) & Tx_BUF_EMP) && --loops) {
 		zs_spin_unlock_cond_irq(&scc->zlock, irq);
 		udelay(2);
 		zs_spin_lock_cond_irq(&scc->zlock, irq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!(read_zsreg(zport, R1) & ALL_SNT) && --loops) {
 		zs_spin_unlock_cond_irq(&scc->zlock, irq);
 		udelay(2);
 		zs_spin_lock_cond_irq(&scc->zlock, irq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(UART_GET_FIFO_CNT(&mux_ports[0].port))
 		udelay(1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while(count--) {
 		if(*s == '\n') {
 			UART_PUT_CHAR(&mux_ports[0].port, '\r');
 		}
 		UART_PUT_CHAR(&mux_ports[0].port, *s++);
+		if (_cur < timeout) {
--
 	while ((UART_GET_LSR(uart) & THRE) && xmit->tail != xmit->head) {
 		UART_PUT_CHAR(uart, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		uart->port.icount.tx++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (!(status & SYSFLG_URXFE)) {
 		ch = clps_readl(UARTDR(port));
 
@@ -137,6 +142,12 @@ static irqreturn_t clps711xuart_int_rx(i
 
 	ignore_char:
--
 	while (UART_RX_DATA(status) && (max_chars--)) {
 
 		ch = UART_GET_CHAR(port);
@@ -124,6 +129,12 @@ static void apbuart_rx_chars(struct uart
 
 	      ignore_char:
--
 	while (((status >> 20) & 0x3F) == fifosize) {
 		fifosize++;
 		UART_PUT_CHAR(port, 0);
 		status = UART_GET_STATUS(port);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((status = altera_uart_readl(port, ALTERA_UART_STATUS_REG)) &
 	       ALTERA_UART_STATUS_RRDY_MSK) {
 		ch = altera_uart_readl(port, ALTERA_UART_RXDATA_REG);
@@ -229,6 +234,12 @@ static void altera_uart_rx_chars(struct
 			continue;
 		uart_insert_char(port, status, ALTERA_UART_STATUS_ROE_MSK, ch,
--
-	while (up) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (up) {
 		struct zilog_channel *channel
 			= ZILOG_CHANNEL_FROM_PORT(&up->port);
 		struct tty_struct *tty;
@@ -487,6 +492,12 @@ static irqreturn_t ip22zilog_interrupt(i
 			tty_flip_buffer_push(tty);
--
-			while (readl(&port->ip_serial_regs->sscr) &
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (readl(&port->ip_serial_regs->sscr) &
 						IOC4_SSCR_RX_DRAIN) {
 				loop_counter++;
 				if (loop_counter > MAXITER)
 					return -1;
+					if (_cur < timeout) {
--
 		while (irq_mask1_rd) {
 			/* Disable those we are about to handle */
 			*R_IRQ_MASK1_CLR = irq_mask1_rd;
@@ -2682,6 +2687,12 @@ ser_interrupt(int irq, void *dev_id)
 			local_irq_disable();
 			/* Handle reentered TX interrupt */
--
 	while (!(status & 0x10) && max_count--) {
 		ch = *CSR_UARTDR;
 		flag = TTY_NORMAL;
@@ -113,6 +118,12 @@ static irqreturn_t serial21285_rx_chars(
 		uart_insert_char(port, rxs, RXSTAT_OVERRUN, ch, flag);
 
--
 	while (status & SA_FL_RCV_DONE) {
 		int first = -1;
 
@@ -833,6 +838,12 @@ ignore_char:
 			rcv_buff = 0;
 
--
 	while (!(readl(port->membase + UART_FR) & FR_RXFE)) {
 		rx = readl(port->membase + UART_DR);
 		flg = TTY_NORMAL;
@@ -235,6 +240,12 @@ static void netx_rxint(struct uart_port
 			continue;
 
--
 	while (status) {
 		if (status & IIR_RIS)
 			netx_rxint(port);
@@ -263,6 +279,12 @@ static irqreturn_t netx_int(int irq, voi
 		}
 		writel(0, port->membase + UART_IIR);
--
-	while (psc_ops->raw_rx_rdy(port)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (psc_ops->raw_rx_rdy(port)) {
 		/* Get the char */
 		ch = psc_ops->read_char(port);
 
@@ -991,6 +996,12 @@ mpc52xx_uart_int_rx_chars(struct uart_po
 			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
--
 	while (status & FIFO_TO_SM(PNX8XXX_UART_FIFO_RXFIFO)) {
 		ch = serial_in(sport, PNX8XXX_FIFO) & 0xff;
 
@@ -237,6 +242,12 @@ static void pnx8xxx_rx_chars(struct pnx8
 				PNX8XXX_UART_LCR_RX_NEXT);
 		status = FIFO_TO_SM(serial_in(sport, PNX8XXX_FIFO)) |
--
 	while (rxlvl) {
 		pr_debug("rxlvl %d\n", rxlvl);
 		/* Clear buffer */
@@ -215,6 +220,12 @@ static void max3107_handlerx(struct max3
 		put_data_to_circ_buf(s, valid_str, rxlvl);
 		/* Get new RX level */
--
 	while ((sr = msm_read(port, UART_SR)) & UART_SR_RX_READY) {
 		unsigned int c;
 		char flag = TTY_NORMAL;
@@ -187,6 +192,12 @@ static void handle_rx(struct uart_port *
 
 		if (!uart_handle_sysrq_char(port, c))
--
 	while (SPORT_GET_STAT(up) & RXNE) {
 		ch = rx_one_byte(up);
 		up->port.icount.rx++;
 
 		if (!uart_handle_sysrq_char(&up->port, ch))
 			tty_insert_flip_char(tty, ch, TTY_NORMAL);
--
 	while(!(SPORT_GET_STAT(up) & TXF) && !uart_circ_empty(xmit)) {
 		tx_one_byte(up, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE -1);
 		up->port.icount.tx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!uart_circ_empty(xmit)) {
 		left = uart_circ_chars_pending(xmit);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (left) {
 			len = min(left, WORDS_PER_XFER);
 			blen = len * sizeof(u16);
@@ -299,6 +309,18 @@ static void send_circ_buf(struct uart_ma
 
 			max->port.icount.tx += len;
--
 	while ((status = dz_in(dport, DZ_RBUF)) & DZ_DVAL) {
 		dport = &mux->dport[LINE(status)];
 		uport = &dport->port;
@@ -247,6 +252,12 @@ static inline void dz_receive_chars(stru
 
 		uart_insert_char(uport, status, DZ_OERR, ch, flag);
--
-	while (!uart_circ_empty(xmit) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!uart_circ_empty(xmit) &&
 			!(readl(sport->port.membase + uts_reg(sport))
 				& UTS_TXFULL)) {
 		/* send xmit->buf[xmit->tail]
@@ -393,6 +398,12 @@ static inline void imx_transmit_buffer(s
 		writel(xmit->buf[xmit->tail], sport->port.membase + URTX0);
--
 	while (readl(sport->port.membase + USR2) & USR2_RDR) {
 		flg = TTY_NORMAL;
 		sport->port.icount.rx++;
@@ -542,6 +558,12 @@ static irqreturn_t imx_rxint(int irq, vo
 		}
 
--
 	while (UART_RX_DATA(status) && max_count--) {
 		ch = readb(uap->port.membase + UART01x_DR);
 		flag = TTY_NORMAL;
@@ -163,6 +168,12 @@ static void pl010_rx_chars(struct uart_a
 
 	ignore_char:
--
-		while(info->xmit_cnt) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(info->xmit_cnt) {
 #endif
 
 		uart->ustcnt |= USTCNT_TXEN;
@@ -709,6 +714,12 @@ static int rs_write(struct tty_struct *
 		}
--
     while (count--) {
         if (*str == '\n')
            rs_put_char('\r');
         rs_put_char( *str++ );
+        if (_cur < timeout) {
+           rdstcll(_cur);
--
 	while (!(uart_circ_empty(xmit) || uart_tx_stopped(&up->port))) {
 		nwpserial_putchar(up, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE-1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((status & URLS_URDR) && max_count--) {
 		ch = UART_GET_CHAR(port);
 		flg = TTY_NORMAL;
@@ -199,6 +204,12 @@ static irqreturn_t ks8695uart_rx_chars(i
 
 ignore_char:
--
 	while (status & ATMEL_US_RXRDY) {
 		ch = UART_GET_CHAR(port);
 
@@ -523,6 +528,12 @@ static void atmel_rx_chars(struct uart_p
 
 		atmel_buffer_rx_char(port, status, ch);
--
 	while (ring->head != ring->tail) {
 		struct atmel_uart_char c;
 
@@ -764,6 +780,12 @@ static void atmel_rx_from_ring(struct ua
 			continue;
 
--
 	while (vt8500_read(port, VT8500_URFIDX) & 0x1f00) {
 		unsigned int c;
 		char flag = TTY_NORMAL;
@@ -165,6 +170,12 @@ static void handle_rx(struct uart_port *
 
 		if (!uart_handle_sysrq_char(port, c))
--
 	while (ioread32(port->membase + TIMBUART_ISR) & RXDP) {
 		u8 ch = ioread8(port->membase + TIMBUART_RXFIFO);
 		port->icount.rx++;
 		tty_insert_flip_char(tty, ch, TTY_NORMAL);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!(ioread32(port->membase + TIMBUART_ISR) & TXBF) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(ioread32(port->membase + TIMBUART_ISR) & TXBF) &&
 		!uart_circ_empty(xmit)) {
 		iowrite8(xmit->buf[xmit->tail],
 			port->membase + TIMBUART_TXFIFO);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		port->icount.tx++;
--
-		while (ToRecv) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (ToRecv) {
 			char flag;
 
 			CharNStat = sInW(sGetTxRxDataIO(cp));
@@ -381,6 +386,12 @@ static void rp_do_receive(struct r_port
 				flag = TTY_NORMAL;
--
 	while ((dev = pci_get_device(PCI_VENDOR_ID_RP, PCI_ANY_ID, dev))) {
 		if (register_PCI(count + boards_found, dev))
 			count++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 				while (pClient->msg_count) {
 					pMsg = remove_msg(pInfo, pClient);
 					if (pMsg) {
@@ -770,6 +775,12 @@ static int enable_signals(struct r3964_i
 						TRACE_M("enable_signals - msg "
 							"kfree %p", pMsg);
--
 	while (pClient) {
 		pNext = pClient->next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (pClient->msg_count) {
 			pMsg = remove_msg(pInfo, pClient);
 			if (pMsg) {
 				kfree(pMsg);
 				TRACE_M("r3964_close - msg kfree %p", pMsg);
 			}
--
 	while (pHeader) {
 		pNextHeader = pHeader->next;
 		kfree(pHeader);
 		pHeader = pNextHeader;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!kthread_should_stop()) {
 		/* no one left to give data to, so sleep */
 		if (bfin_jc_tty == NULL && circ_empty(&bfin_jc_write_buf)) {
@@ -140,6 +145,12 @@ bfin_jc_emudat_manager(void *arg)
 				pr_debug("  outgoing data: 0x%08x (pushing %zu)\n", emudat, ate);
 			}
--
 	while (bfin_read_DBGSTAT() & EMUDOF)
 		continue;
 	bfin_write_emudat(count);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (ate < count) {
 		while (bfin_read_DBGSTAT() & EMUDOF)
 			continue;
 		bfin_write_emudat_chars(buf[ate], buf[ate+1], buf[ate+2], buf[ate+3]);
 		ate += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (sel_buffer && sel_buffer_lth > pasted) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (test_bit(TTY_THROTTLED, &tty->flags)) {
@@ -336,6 +341,12 @@ int paste_selection(struct tty_struct *t
 		tty->ldisc->ops->receive_buf(tty, sel_buffer + pasted,
 								NULL, count);
--
 	while (ct--) {
 		unsigned short unicode, fontpos;
 		__get_user(unicode, &list->unicode);
@@ -587,6 +592,12 @@ int con_set_unimap(struct vc_data *vc, u
 		if ((err1 = con_insert_unipair(p, unicode,fontpos)) != 0)
 			err = err1;
--
 	while (*cp) {
 		tty_insert_flip_char(tty, *cp, 0);
 		cp++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while( (Fifocount = (usc_InReg(info,RICR) >> 8)) ) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while( (Fifocount = (usc_InReg(info,RICR) >> 8)) ) {
 		int flag;
 
 		/* read one byte from RxFIFO */
@@ -1517,6 +1522,12 @@ static void mgsl_isr_receive_data( struc
 			 */
--
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while(info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(info) {
 #if SYNCLINK_GENERIC_HDLC
 		hdlcdev_exit(info);
 #endif
@@ -4420,6 +4447,12 @@ static void synclink_cleanup(void)
 		tmp = info;
--
 	while( (Fifocount = usc_InReg(info, TICR) >> 8) && info->xmit_cnt ) {
 		/* there is more space in the transmit FIFO and */
 		/* there is more data in transmit buffer */
@@ -5745,6 +5783,12 @@ static void usc_load_txfifo( struct mgsl
 			}
 			info->icount.tx++;
--
 	while( !Done ) {
 		pBufEntry = &(info->rx_buffer_list[Index]);
 
@@ -6497,6 +6546,12 @@ static void mgsl_free_rx_frame_buffers(
 		Index++;
 		if ( Index == info->rx_buffer_count )
--
 	while( !info->rx_buffer_list[EndIndex].status ) {
 		/*
 		 * If the count field of the buffer entry is non-zero then
@@ -6562,6 +6622,12 @@ static bool mgsl_get_rx_frame(struct mgs
 			}
 			goto Cleanup;
--
-			while(copy_count) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while(copy_count) {
 				int partial_count;
 				if ( copy_count > DMABUFFERSIZE )
 					partial_count = DMABUFFERSIZE;
@@ -6644,6 +6715,12 @@ static bool mgsl_get_rx_frame(struct mgs
 				
--
 	while( BufferSize ){
 		/* Get a pointer to next DMA buffer entry. */
 		pBufEntry = &info->tx_buffer_list[i++];
@@ -6937,6 +7019,12 @@ static void mgsl_load_tx_dma_buffer(stru
 		BufferSize -= Copycount;
 
--
 	while( EndTime-- && !info->irq_occurred ) {
 		msleep_interruptible(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-	while(count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(count) {
 		if (count > 16)
 			linecount = 16;
 		else
@@ -7526,6 +7630,12 @@ static void mgsl_trace_block(struct mgsl
 		
--
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while((status = read_reg(info,CST0)) & BIT0)
 	{
 		int flag = 0;
@@ -2215,6 +2231,12 @@ static void isr_rxrdy(SLMP_INFO * info)
 			if (over)
 				tty_insert_flip_char(tty, 0, TTY_OVERRUN);
--
 	while(info) {
 		reset_port(info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while(info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(info) {
 #if SYNCLINK_GENERIC_HDLC
 		hdlcdev_exit(info);
 #endif
@@ -3945,6 +3983,12 @@ static void synclinkmp_cleanup(void)
 		tmp = info;
--
 	while( info->tx_count && (read_reg(info,SR0) & BIT1) ) {
 
 		/* there is more space in the transmit FIFO and */
@@ -4334,6 +4383,12 @@ static void tx_load_fifo(SLMP_INFO *info
 			}
 			info->icount.tx++;
--
 	while(!done) {
 	        /* reset current buffer for reuse */
 		info->rx_buf_list[first].status = 0xff;
@@ -4822,6 +4882,12 @@ static void rx_free_frame_buffers(SLMP_I
 	        first++;
 		if (first == info->rx_buf_count)
--
-			while(copy_count) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while(copy_count) {
 				int partial_count = min(copy_count,SCABUFSIZE);
 				memcpy( ptmp,
 					info->rx_buf_list_ex[index].virt_addr,
@@ -4974,7 +5045,13 @@ CheckAgain:
 
--
 	while( timeout-- && !info->irq_occurred ) {
 		msleep_interruptible(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-	while(count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(count) {
 		if (count > 16)
 			linecount = 16;
 		else
@@ -5464,6 +5557,12 @@ static void trace_block(SLMP_INFO *info,
 
--
 		while (gdl--) {
 			ch = inb(port->ioaddr + UART_RX);
 			tty_insert_flip_char(tty, ch, 0);
 			cnt++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (test_bit(TTY_LDISC_CHANGING, &tty->flags)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (test_bit(TTY_LDISC_CHANGING, &tty->flags)) {
 		mutex_unlock(&tty->ldisc_mutex);
 		tty_unlock();
 		wait_event(tty_ldisc_wait,
 			test_bit(TTY_LDISC_CHANGING, &tty->flags) == 0);
 		tty_lock();
--
 			while (1) {
 				interruptible_sleep_on(&info->delta_msr_wait);
 				/* see if a signal did it */
@@ -1357,6 +1362,12 @@ static int rs_ioctl(struct tty_struct *t
 					return 0;
 				}
--
 	while (count--) {
 		if (*s == '\n')
 			amiga_serial_putc('\r');
 		amiga_serial_putc(*s++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count) {
 		len = min_t(unsigned int, count, EV_BYTE_CHANNEL_MAX_BYTES);
 		do {
@@ -264,6 +269,12 @@ static int ehv_bc_console_byte_channel_s
 		} while (ret == EV_EAGAIN);
 		count -= len;
 		s += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while(count) {
 		linecount = (count > 16) ? 16 : count;
 		for(i=0; i < linecount; i++)
@@ -571,6 +576,12 @@ static void trace_block(struct slgt_info
 		printk("\n");
 		data  += linecount;
--
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while((action = bh_action(info))) {
 		switch (action) {
 		case BH_RECEIVE:
@@ -2002,6 +2029,12 @@ static void bh_handler(struct work_struc
 			DBGBH(("%s unknown action\n", info->device_name));
 			break;
--
 	while (rd_reg16(info, SSR) & IRQ_RXDATA) {
 		reg = rd_reg16(info, RDR);
 		DBGISR(("isr_rxdata %s RDR=%04X\n", info->device_name, reg));
@@ -2155,6 +2193,12 @@ static void isr_rxdata(struct slgt_info
 				i = 0;
 			info->pending_bh |= BH_RECEIVE;
--
 	while((gsr = rd_reg32(info, GSR) & 0xffffff00)) {
 		DBGISR(("%s gsr=%08x\n", info->device_name, gsr));
 		info->irq_occurred = true;
@@ -2395,6 +2444,12 @@ static irqreturn_t slgt_interrupt(int du
 				isr_tdma(info->port_array[i]);
 			spin_unlock(&info->port_array[i]->lock);
--
 	while(info) {
 		reset_port(info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while(info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(info) {
 #if SYNCLINK_GENERIC_HDLC
 		hdlcdev_exit(info);
 #endif
@@ -3772,6 +3843,12 @@ static void slgt_cleanup(void)
 		tmp = info;
--
 	while(!done) {
 		/* reset current buffer for reuse */
 		info->rbufs[i].status = 0;
@@ -4620,6 +4702,12 @@ static void free_rbufs(struct slgt_info
 			done = 1;
 		if (++i == info->rbuf_count)
--
 			while(copy_count) {
 				int partial_count = min_t(int, copy_count, info->rbuf_fill_level);
 				memcpy(p, info->rbufs[i].buf, partial_count);
@@ -4750,6 +4843,12 @@ check_again:
 				copy_count -= partial_count;
 				if (++i == info->rbuf_count)
--
 	while (size) {
 		d = &info->tbufs[i];
 
@@ -4941,6 +5045,12 @@ static bool tx_load(struct slgt_info *in
 
 		if (++i == info->tbuf_count)
--
 		while (dlen--) {
 			if (ct % 8 == 0) {
 				pr_cont("\n");
@@ -518,6 +523,12 @@ static void gsm_print_packet(const char
 			}
 			pr_cont("%02X ", *data++);
--
 	while (len--) {
 		if (*input == GSM1_SOF || *input == GSM1_ESCAPE
 		    || *input == XON || *input == XOFF) {
@@ -551,6 +567,12 @@ static int gsm_stuff_frame(const u8 *inp
 		} else
 			*output++ = *input++;
--
 	while(1) {
 		len = kfifo_len(dlci->fifo);
 		if (len == 0)
@@ -836,6 +863,12 @@ static int gsm_dlci_data_output(struct g
 		WARN_ON(kfifo_out_locked(dlci->fifo, dp , len, &dlci->lock) != len);
 		__gsm_data_queue(dlci, msg);
--
-	while (sg_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (sg_count) {
 		sg_to_link_tbl_one(link_tbl_ptr, sg_dma_address(sg),
 				   sg_dma_len(sg), offset);
 		link_tbl_ptr++;
 		sg = sg_next(sg);
 		sg_count--;
--
 	while (!(omap_aes_read(dd, offset) & bit)) {
 		if (time_is_before_jiffies(timeout)) {
 			dev_err(dd->dev, "omap-aes timeout\n");
 			return -ETIMEDOUT;
 		}
+		if (_cur < timeout) {
--
 	while (buflen && total) {
 		count = min((*sg)->length - *offset, total);
 		count = min(count, buflen);
@@ -422,6 +438,12 @@ static int sg_copy(struct scatterlist **
 			else
 				total = 0;
--
-	while (!(omap_sham_read(dd, offset) & bit)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (!(omap_sham_read(dd, offset) & bit)) {
 		if (time_is_before_jiffies(timeout))
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-	while (nbytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nbytes) {
 		sg = &dst[i];
 		sg_len = sg->length;
 		addr = dma_map_page(dev->core_dev->device, sg_page(sg),
@@ -583,6 +588,12 @@ static void crypto4xx_copy_pkt_to_dst(st
 			}
--
 		while (nbytes) {
 			sd_idx = get_next_sd(sd_idx);
 			sd = crypto4xx_get_sdp(dev, &sd_dma, sd_idx);
@@ -971,6 +987,12 @@ u32 crypto4xx_build_pd(struct crypto_asy
 				 * which is more than nbytes, so done.
 				 */
--
-	while (core_dev->dev->pdr_head != core_dev->dev->pdr_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (core_dev->dev->pdr_head != core_dev->dev->pdr_tail) {
 		tail = core_dev->dev->pdr_tail;
 		pd_uinfo = core_dev->dev->pdr_uinfo +
 			sizeof(struct pd_uinfo)*tail;
@@ -1100,6 +1127,12 @@ static void crypto4xx_bh_tasklet_cb(unsi
 			/* if tail not done, break */
--
 	while (priv->chan[ch].fifo[tail].desc) {
 		request = &priv->chan[ch].fifo[tail];
 
@@ -389,6 +394,12 @@ static void flush_channel(struct device
 			return;
 		spin_lock_irqsave(&priv->chan[ch].tail_lock, flags);
--
 	while (priv->chan[ch].fifo[tail].dma_desc != cur_desc) {
 		tail = (tail + 1) & (priv->fifo_len - 1);
 		if (tail == priv->chan[ch].tail) {
 			dev_err(dev, "couldn't locate current descriptor\n");
 			return 0;
 		}
--
-		while (sg) {
-			dma_map_sg(dev, sg, 1, dir);
-			sg = scatterwalk_sg_next(sg);
+	if (unlikely(chained)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
--
+			while (sg) {
+				dma_map_sg(dev, sg, 1, dir);
+				sg = scatterwalk_sg_next(sg);
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
--
 	while (sg) {
 		dma_unmap_sg(dev, sg, 1, dir);
 		sg = scatterwalk_sg_next(sg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (n_sg--) {
 		to_talitos_ptr(link_tbl_ptr, sg_dma_address(sg));
 		link_tbl_ptr->len = cpu_to_be16(sg_dma_len(sg));
@@ -981,16 +1031,33 @@ static int sg_to_link_tbl(struct scatter
 		link_tbl_ptr++;
 		cryptlen -= sg_dma_len(sg);
--
 	while (be16_to_cpu(link_tbl_ptr->len) <= (-cryptlen)) {
 		/* Empty this entry, and move to previous one */
 		cryptlen += be16_to_cpu(link_tbl_ptr->len);
 		link_tbl_ptr->len = 0;
 		sg_count--;
 		link_tbl_ptr--;
--
 	while (sg_miter_next(&miter) && offset < total_buffer) {
 		unsigned int len;
 		unsigned int ignore;
@@ -1193,6 +1265,12 @@ static size_t sg_copy_end_to_buffer(stru
 			boffset += len;
 		}
--
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		padlock_xcrypt_ecb(walk.src.virt.addr, walk.dst.virt.addr,
 				   ctx->E, &ctx->cword.encrypt,
 				   nbytes / AES_BLOCK_SIZE);
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
--
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		padlock_xcrypt_ecb(walk.src.virt.addr, walk.dst.virt.addr,
 				   ctx->D, &ctx->cword.decrypt,
 				   nbytes / AES_BLOCK_SIZE);
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
--
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		u8 *iv = padlock_xcrypt_cbc(walk.src.virt.addr,
 					    walk.dst.virt.addr, ctx->E,
 					    walk.iv, &ctx->cword.encrypt,
@@ -442,6 +469,12 @@ static int cbc_aes_encrypt(struct blkcip
 		memcpy(walk.iv, iv, AES_BLOCK_SIZE);
--
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		padlock_xcrypt_cbc(walk.src.virt.addr, walk.dst.virt.addr,
 				   ctx->D, walk.iv, &ctx->cword.decrypt,
 				   nbytes / AES_BLOCK_SIZE);
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
--
 	while (len) {
 		if (!p->sg_src_left) {
 			ret = sg_miter_next(&p->src_sg_it);
@@ -207,6 +212,12 @@ static void copy_src_to_buf(struct req_p
 
 		len -= copy_len;
--
 	while (sl) {
 		cur_len = sl[i].length;
 		++i;
@@ -491,6 +507,12 @@ static int count_sgs(struct scatterlist
 			total_bytes -= cur_len;
 		else
--
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -328,6 +333,12 @@ geode_cbc_decrypt(struct blkcipher_desc
 
 		nbytes -= ret;
--
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -359,6 +375,12 @@ geode_cbc_encrypt(struct blkcipher_desc
 		ret = geode_aes_crypt(op);
 		nbytes -= ret;
--
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -439,6 +466,12 @@ geode_ecb_decrypt(struct blkcipher_desc
 		ret = geode_aes_crypt(op);
 		nbytes -= ret;
--
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -469,6 +507,12 @@ geode_ecb_encrypt(struct blkcipher_desc
 		ret = geode_aes_crypt(op);
 		nbytes -= ret;
--
-	while (!list_empty(&engine->pending) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&engine->pending) &&
 	       engine->in_flight + 1 <= engine->fifo_sz) {
 
 		++engine->in_flight;
@@ -684,6 +689,12 @@ static void spacc_push(struct spacc_engi
 		list_move_tail(&req->list, &engine->in_progress);
--
-	while (!spacc_fifo_stat_empty(engine)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!spacc_fifo_stat_empty(engine)) {
 		req = list_first_entry(&engine->in_progress, struct spacc_req,
 				       list);
 		list_move_tail(&req->list, &engine->completed);
@@ -1190,6 +1206,12 @@ static void spacc_process_done(struct sp
 				break;
--
 	while (n) {
 		spage = sg_page(src);
 		soff = src->offset;
@@ -1387,10 +1392,21 @@ static int hifn_setup_dma(struct hifn_de
 
 		src++;
--
 	while (n) {
 		if (t->length && rctx->walk.flags & ASYNC_FLAGS_MISALIGNED) {
 			BUG_ON(!sg_page(t));
@@ -1410,6 +1426,12 @@ static int hifn_setup_dma(struct hifn_de
 		dst++;
 		t++;
--
-	while (size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size) {
 		copy = min3(drest, size, dst->length);
 
 		size -= copy;
@@ -1478,6 +1505,12 @@ static int ablkcipher_add(unsigned int *
 
--
 	while (nbytes) {
 		if (idx >= w->num && (w->flags & ASYNC_FLAGS_MISALIGNED))
 			return -EINVAL;
@@ -1567,6 +1605,12 @@ static int hifn_cipher_walk(struct ablkc
 		}
 
--
 	while (nbytes) {
 		dst = &req->dst[idx];
 		dlen = min(dst->length, nbytes);
@@ -1597,6 +1646,12 @@ static int hifn_setup_session(struct abl
 
 		nbytes -= dlen;
--
 	while (size) {
 		copy = min3(srest, dst->length, size);
 
@@ -1746,6 +1806,12 @@ static int ablkcipher_get(void *saddr, u
 
 		dst++;
--
 	while ((async_req = crypto_dequeue_request(&dev->queue))) {
 		req = container_of(async_req, struct ablkcipher_request, base);
 		spin_unlock_irqrestore(&dev->lock, flags);
@@ -2040,6 +2111,12 @@ static void hifn_flush(struct hifn_devic
 		hifn_process_ready(req, -ENODEV);
 
--
 	while (buf) {
 		struct buffer_desc *buf1;
 		u32 phys1;
@@ -340,6 +345,12 @@ static void free_buf_chain(struct device
 		dma_pool_free(buffer_pool, buf, phys);
 		buf = buf1;
--
 	while (count--) {
 		unsigned char c = *src++;
 		unsigned char tabentry = bitcounts[c];
@@ -815,6 +820,12 @@ static inline void hdlc_unpack(unsigned
 			}
 		}
--
 	while (numbytes--) {
 		c = *src++;
 		switch (c) {
@@ -929,6 +945,12 @@ static void cmd_loop(unsigned char *src,
 				cs->respdata[cbytes] = c;
 			cbytes++;
--
 	while (head != (tail = inbuf->tail)) {
 		gig_dbg(DEBUG_INTR, "buffer state: %u -> %u", head, tail);
 		if (head > tail)
@@ -966,6 +993,12 @@ void gigaset_isoc_input(struct inbuf_t *
 			head = 0;
 		gig_dbg(DEBUG_INTR, "setting head to %u", head);
--
 	while (cb && !cb->len) {
 		spin_lock_irqsave(&cs->cmdlock, flags);
 		cs->cmdbytes -= cs->curlen;
@@ -148,6 +153,12 @@ static int send_cb(struct cardstate *cs)
 		if (tcb->wake_tasklet)
 			tasklet_schedule(tcb->wake_tasklet);
--
 	while (tail != head) {
 		ev = cs->events + head;
 		kfree(ev->ptr);
 		head = (head + 1) % MAX_EVENTS;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (cb) {
 		tcb = cb;
 		cb = cb->next;
 		kfree(tcb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (*in) {
 		if (!isxdigit(in[0]) || !isxdigit(in[1]) || l >= maxlen)
 			return -1;
 		out[++l] = (hex_to_bin(in[0]) << 4) + hex_to_bin(in[1]);
 		in += 2;
+		if (_cur < timeout) {
--
 	while (count--) {
 		*pout++ = hex_asc_hi(*++ie);
 		*pout++ = hex_asc_lo(*ie);
 		*pout++ = ' ';
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (ap->bcnext) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ap->bcnext) {
 		/* this should never happen */
 		dev_warn(cs->dev, "%s: dropping extra application %u\n",
 			 __func__, ap->bcnext->id);
 		send_disconnect_ind(bcs, ap->bcnext,
 				    CapiCallGivenToOtherApplication);
--
-	while (ap->bcnext) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ap->bcnext) {
 		/* this should never happen */
 		dev_warn(cs->dev, "%s: dropping extra application %u\n",
 			 __func__, ap->bcnext->id);
 		send_disconnect_ind(bcs, ap->bcnext,
 				    CapiCallGivenToOtherApplication);
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -320,6 +325,12 @@ setup_teles3(struct IsdnCard *card)
 			}
 			ipid++;
--
-  while (pc)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
+   while (pc)
    { if ((pc->callref == -1) && (pc->prot.dss1.invoke_id == id))
        return(pc);
      pc = pc->next;
+     if (_cur < timeout) {
+       rdstcll(_cur);
--
 	while ((p - skb->data) < skb->len) {
 		if ((*p & 0xf0) == 0x90) { /* shift codeset */
 			old_codeset = codeset;
@@ -774,6 +790,12 @@ check_infoelements(struct l3_process *pc
 			codeset = old_codeset;
 			codelock = 1;
--
 	while (*sp) {
 		if ('.' == *sp) {
 			sub = sp;
 			*sp = 0;
 		} else
 			sp++;
--
 	while (*sp) {
 		if ('.' == *sp) {
 			sub = sp;
 			*sp = 0;
 		} else
 			sp++;
--
 	while (up) {
 		if ((ri & 7) == 7)
 			up->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);
 		else if (up->para.bchannel == chan)
 			up->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);
 		up = up->next;
--
         /* while free place in tx-fifo available and data in sk-buffer */
         txstat = 0x10;
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
--
         while((txstat & 0x10) && (cs->tx_cnt < len)) {
                 wByteAMD(cs, 0x04, *ptr);
                 ptr++;
                 cs->tx_cnt++;
                 txstat= rByteAMD(cs, 0x07);
+                if (_cur < timeout) {
--
  while (irflags)
  {
 
@@ -550,6 +566,12 @@ void Amd7930_interrupt(struct IsdnCardSt
 
         /* reads Interrupt-Register again. If there is a new interrupt-flag: restart handler */
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len--) {
 		if (b & 0x80)
 			*dp++ = '1';
 		else
 			*dp++ = '0';
 		b = b << 1;
--
 	while (l--) {
 		dp += sprintf(dp, "    octet %d%c ", octet, ch);
 		dp += prbits(dp, *p++, 8, 8);
@@ -737,6 +753,12 @@ general(char *dest, u_char * p)
 			ch = 'a';
 		else
--
 	while (l--) {
 		dp += sprintf(dp, "    octet %d%c ", octet, ch);
 		dp += prbits(dp, *p, 8, 8);
@@ -764,6 +791,12 @@ general_ni1(char *dest, u_char * p)
 			ch = 'a';
 		else
--
 	while (l--) {
 		dp += sprintf(dp, "%c", *p++);
 
@@ -929,6 +967,12 @@ display(char *dest, u_char * p)
 
 		else
--
 		while (l2--) {
 			dp += sprintf(dp, "%2x ", *p++);
 			l--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (buf < bend) {
 			/* Is it a single octet information element? */
 			if (*buf & 0x80) {
@@ -1349,6 +1409,12 @@ dlogframe(struct IsdnCardState *cs, stru
 				cs_fest = 0;
 			}
--
 		while (buf < bend) {
 			/* Is it a single octet information element? */
 			if (*buf & 0x80) {
@@ -1435,6 +1506,12 @@ dlogframe(struct IsdnCardState *cs, stru
 				cs_fest = 0;
 			}
--
 		while (buf < bend) {
 			/* Is it a single octet information element? */
 			if (*buf & 0x80) {
@@ -1504,6 +1586,12 @@ dlogframe(struct IsdnCardState *cs, stru
 
 			/* Skip to next element */
--
 	while (packet_offset < len) {
 		desc = &urb->iso_frame_desc[num_packets];
 		desc->offset = packet_offset;
@@ -347,6 +352,12 @@ static void usb_d_out(struct st5481_adap
 			desc->length = len - packet_offset;
 		num_packets++;
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -962,6 +967,12 @@ setup_elsa_isapnp(struct IsdnCard *card)
 			}
 			ipid++;
--
 	while (!(ReadReg(cs, HFCD_DATA, HFCD_STAT) & HFCD_BUSY) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((ReadReg(cs, HFCD_STATUS, HFCD_STATUS) & HFCD_BUSY) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (idx++ < count) {
 			WaitNoBusy(cs);
 			ReadReg(cs, HFCD_DATA_NODEB, cip);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((f1 != f2) && count--) {
 		z1 = ReadZReg(cs, HFCD_FIFO | HFCD_Z1 | HFCD_REC);
 		z2 = ReadZReg(cs, HFCD_FIFO | HFCD_Z2 | HFCD_REC);
@@ -680,6 +718,12 @@ int receive_dmsg(struct IsdnCardState *c
 		cip = HFCD_FIFO | HFCD_F2 | HFCD_REC;
 		WaitNoBusy(cs);
--
 	while (val) {
 		if (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {
 			cs->hw.hfcD.int_s1 |= val;
@@ -896,6 +945,12 @@ hfc2bds0_interrupt(struct IsdnCardState
 				debugl1(cs, "HFCD irq %x loop %d", val, 15-count);
 		} else
--
 	while(ipid->card_vendor) {
 		if ((pnp_c = pnp_find_card(ipid->card_vendor,
 			ipid->card_device, pnp_c))) {
@@ -584,6 +589,12 @@ setup_sedlbauer_isapnp(struct IsdnCard *
 		}
 		ipid++;
--
-			while (bytecnt) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (bytecnt) {
 				ver = ISARVersion(cs, "Sedlbauer:");
 				if (ver < 0)
 					printk(KERN_WARNING
@@ -843,6 +859,12 @@ ready:
 					break;
--
 	while (st) {
 		FsmDelTimer(&st->ma.t202, 1);
 		st = st->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (len < buf_size) {
 		if ((skb = b_out->tx_skb)) {
 			DBG_SKB(0x100, skb);
@@ -105,6 +110,12 @@ static void usb_b_out(struct st5481_bcs
 						       urb->transfer_buffer+len, buf_size-len);
 			}
--
 	/* while there are bytes left... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p < pend) {
 		if ((*p & 0xf0) == 0x90) {
 			codeset = *p & 0x07;
@@ -118,6 +123,12 @@ findie(u_char * p, int size, u_char ie,
 			p += l;
 			codeset = maincodeset;
--
 	while (np) {
 		if (np == p) {
 			StopAllL3Timer(p);
@@ -307,6 +323,12 @@ release_l3_process(struct l3_process *p)
 		}
 		pp = np;
--
 	while (p) {
 		/* p might be kfreed under us, so we need to save where we want to go on */
 		np = p->next;
 		st->l3.l3ml3(st, pr, p);
 		p = np;
+		if (_cur < timeout) {
--
 	while ((skb = skb_dequeue(&st->l3.squeue))) {
 		st->l3.l3l2(st, DL_DATA | REQUEST, skb);
 		dequeued++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = skb_dequeue(&st->l3.squeue))) {
 		st->l3.l3l2(st, DL_DATA | REQUEST, skb);
 		dequeued++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -209,6 +214,12 @@ setup_hfcs(struct IsdnCard *card)
 			}
 			ipid++;
--
 	    while (count) {
 	      count--; /* empty fifo */
 	      Read_hfc(cs, HFCSX_FIF_DRD);
+	      if (_cur < timeout) {
+		  rdstcll(_cur);
+	      }
--
 	while (1) {
 	  Write_hfc(cs, HFCSX_CIRM, HFCSX_RESET | cs->hw.hfcsx.cirm ); /* Reset */
 	  mdelay(30);
@@ -363,6 +379,12 @@ reset_hfcsx(struct IsdnCardState *cs)
 	  cs->hw.hfcsx.last_fifo = 0xff; /* invalidate */
 	  if (!set_fifo_size(cs)) continue;
--
 	while (val) {
 		if (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {
 			cs->hw.hfcsx.int_s1 |= val;
@@ -851,6 +878,12 @@ hfcsx_interrupt(int intno, void *dev_id)
 				debugl1(cs, "HFC-SX irq %x loop %d", val, 15 - count);
 		} else
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -1435,6 +1473,12 @@ setup_hfcsx(struct IsdnCard *card)
 			}
 			ipid++;
--
 	while (i < ((bch) ? cs->chanlimit : (2 + MAX_WAITING_CALLS))) {
 		if (chanp->fi.state == ST_NULL)
 			return (chanp);
 		chanp++;
 		i++;
+		if (_cur < timeout) {
--
 		while (i < (2 + MAX_WAITING_CALLS)) {
 			if (chanp->fi.state == ST_NULL)
 				return (chanp);
 			chanp++;
 			i++;
+			if (_cur < timeout) {
--
 	while ((READHSCX(cs, hscx, HSCX_STAR) & 0x04) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((request = init_cmd_table[i++])) {
 		value = init_cmd_table[i++];
 		st5481_usb_device_ctrl_msg(adapter, request, value, NULL, NULL);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 			while (len--) {
 				*dst++ = *src++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
-	while (!(cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {
 		val = cs->BC_Read_Reg(cs, HFC_DATA, HFC_CIP | HFC_F2 |
 				      (cs->hw.hfc.cip & 3));
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
--
 	while ((cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((f1 != f2) || (z1 != z2)) && cnt--) {
 		if (cs->debug & L1_DEB_HSCX)
 			debugl1(cs, "hfc clear %d f1(%d) f2(%d)",
@@ -116,9 +143,20 @@ hfc_clear_fifo(struct BCState *bcs)
 				bcs->channel, z1, z2, rcnt);
 		cip = HFC_CIP | HFC_FIFO_OUT | HFC_REC | HFC_CHANNEL(bcs->channel);
--
 		while ((idx < rcnt) && WaitNoBusy(cs)) {
 			cs->BC_Read_Reg(cs, HFC_DATA_NODEB, cip);
 			idx++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while ((idx < count) && WaitNoBusy(cs)) {
 			*ptr++ = cs->BC_Read_Reg(cs, HFC_DATA_NODEB, cip);
 			idx++;
+			if (_cur < timeout) {
+			  rdstcll(_cur);
+			}
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -362,6 +367,12 @@ setup_asuscom(struct IsdnCard *card)
 			}
 			ipid++;
--
-	while (st) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (st) {
 		if (test_and_clear_bit(FLG_L1_ACTIVATING, &st->l1.Flags))
 			st->l1.l1l2(st, PH_ACTIVATE | CONFIRM, NULL);
 		else
 			st->l1.l1l2(st, PH_ACTIVATE | INDICATION, NULL);
 		st = st->next;
--
 	while (st) {
 		if (test_bit(FLG_L1_DBUSY, &cs->HW_Flags))
 			st->l1.l1l2(st, PH_PAUSE | CONFIRM, NULL);
 		st->l1.l1l2(st, PH_DEACTIVATE | INDICATION, NULL);
 		st = st->next;
+		if (_cur < timeout) {
--
-	while ((skb = skb_dequeue(&cs->rq))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((skb = skb_dequeue(&cs->rq))) {
 #ifdef L2FRAME_DEBUG		/* psa */
 		if (cs->debug & L1_DEB_LAPD)
 			Logl2Frame(cs, skb, "PH_DATA", 1);
@@ -264,6 +291,12 @@ DChannel_proc_rcv(struct IsdnCardState *
 				dev_kfree_skb(skb);
--
 	while ((skb = skb_dequeue(&bcs->rqueue))) {
 		bcs->st->l1.l1l2(bcs->st, PH_DATA | INDICATION, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (st) {
 		switch(pr) {
 			case (HW_RESET | INDICATION):
@@ -871,6 +920,12 @@ l1_msg(struct IsdnCardState *cs, int pr,
 				break;
 		}
--
-		while (count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (count) {
 			if (count > HISAX_STATUS_BUFSIZE)
 				cnt = HISAX_STATUS_BUFSIZE;
 			else
@@ -627,6 +632,12 @@ static int HiSax_readstatus(u_char __use
 			p += cnt;
--
-	while (cnt) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt) {
 		cs->cardmsg(cs, CARD_INIT, NULL);
 		/* Timeout 10ms */
 		msleep(10);
@@ -848,6 +864,12 @@ static int init_card(struct IsdnCardStat
 			cs->cardmsg(cs, CARD_TEST, NULL);
--
 	while (i <= last) {
 		cards[i] = cards[i + 1];
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((df->f1 & D_FREG_MASK) != (df->f2 & D_FREG_MASK)) && count--) {
 		zp = &df->za[df->f2 & D_FREG_MASK];
 		rcnt = zp->z1 - zp->z2;
@@ -386,6 +391,12 @@ receive_dmsg(struct IsdnCardState *cs)
 			sched_event_D_pci(cs, D_RCVBUFREADY);
 		} else
--
 		while ((fcnt < 2 * HFCPCI_BTRANS_THRESHOLD) && (bcs->tx_skb)) {
 			if (bcs->tx_skb->len < B_FIFO_SIZE - fcnt) {
 				/* data is suitable for fifo */
@@ -658,6 +674,12 @@ hfcpci_fill_fifo(struct BCState *bcs)
 
 			dev_kfree_skb_any(bcs->tx_skb);
--
 	while (val) {
 		if (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {
 			cs->hw.hfcpci.int_s1 |= val;
@@ -1086,6 +1113,12 @@ hfcpci_interrupt(int intno, void *dev_id
 				debugl1(cs, "HFC-PCI irq %x loop %d", val, 15 - count);
 		} else
--
 	while (((in8 = Read_hfc8(hw, reg)) != ref8)) {
 		ref8 = in8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (((in16 = Read_hfc16(hw, reg)) != ref16)) {
 		ref16 = in16;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (b) {
 		if ((b & hw->mr.r_irq_statech)) {
 			/* reset l1 event */
@@ -1197,12 +1224,23 @@ hfc4s8s_bh(struct work_struct *work)
 		}
 		b <<= 1;
--
 	while (idx < hw->driver_data.max_st_ports) {
 
 		if (hw->mr.timer_irq) {
@@ -1216,6 +1254,11 @@ hfc4s8s_bh(struct work_struct *work)
 		/* ignore fifo 6 (TX E fifo) */
 		*fifo_stat &= 0xff - 0x40;
--
 		while (*fifo_stat) {
 
 			if (!l1p->nt_mode) {
@@ -1255,10 +1298,22 @@ hfc4s8s_bh(struct work_struct *work)
 				*fifo_stat &= ~0x4;
 				tx_b_frame(l1p->b_ch + 1);
--
 		while (ovr) {
 			if ((ovr & 1)) {
 				*ovp |= Read_hfc8(hw, idx);
@@ -1316,6 +1376,12 @@ hfc4s8s_interrupt(int intno, void *dev_i
 			ovp++;
 			idx++;
--
   	while ((READJADE(cs, jade, jade_HDLC_STAR) & mask) && to) {
   		udelay(1);
   		to--;
+  		if (_cur < timeout) {
+  		  	rdstcll(_cur);
+  		}
--
 	while (((sval = bytein(cs->hw.diva.ctrl)) & DIVA_IRQ_REQ) && cnt) {
 		val = readreg(cs->hw.diva.hscx_adr, cs->hw.diva.hscx, HSCX_ISTA + 0x40);
 		if (val)
@@ -303,6 +308,12 @@ diva_interrupt(int intno, void *dev_id)
 		if (val)
 			isac_interrupt(cs, val);
--
 	while ((MemReadHSCX(cs, hscx, HSCX_STAR) & 0x04) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while(ipid->card_vendor) {
 		if ((pnp_c = pnp_find_card(ipid->card_vendor,
 			ipid->card_device, pnp_c))) {
@@ -1134,6 +1161,12 @@ static int __devinit setup_diva_isapnp(s
 		}
 		ipid++;
--
 	while ((sval = (~bytein(cs->hw.avm.cfg_reg+ASL0_OFFSET) & ASL0_R_IRQPENDING))) {
 		if (cs->debug & L1_DEB_INTSTAT)
 			debugl1(cs, "avm IntStatus %x", sval);
@@ -160,6 +165,12 @@ avm_a1p_interrupt(int intno, void *dev_i
 			if (val)
 				isac_interrupt(cs, val);
--
-  while (pc)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
+   while (pc)
    { if ((pc->callref == -1) && (pc->prot.ni1.invoke_id == id))
        return(pc);
      pc = pc->next;
+     if (_cur < timeout) {
+       rdstcll(_cur);
--
 	while ((p - skb->data) < skb->len) {
 		if ((*p & 0xf0) == 0x90) { /* shift codeset */
 			old_codeset = codeset;
@@ -724,6 +740,12 @@ check_infoelements(struct l3_process *pc
 			codeset = old_codeset;
 			codelock = 1;
--
 	while (*sp) {
 		if ('.' == *sp) {
 			sub = sp;
 			*sp = 0;
 		} else
 			sp++;
--
 	while (up) {
 		if ((ri & 7) == 7)
 			up->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);
@@ -2564,6 +2602,12 @@ l3ni1_global_restart(struct l3_process *
 			up->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);
 		
--
 	while (cnt--) {
 		byteout(cs->hw.ix1.cfg_reg + SPECIAL_PORT_OFFSET, 1);
 		HZDELAY(1);	/* wait >=10 ms */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -270,6 +286,12 @@ setup_ix1micro(struct IsdnCard *card)
 			}
 			ipid++;
--
-	while ((ista = cs->readisac(cs, IPACX_ISTA))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while ((ista = cs->readisac(cs, IPACX_ISTA))) {
 //#################################################  
 //		printk(KERN_WARNING "interrupt_ipacx(ista=%02x)\n", ista);
 //#################################################  
@@ -856,6 +861,12 @@ interrupt_ipacx(struct IsdnCardState *cs
     
--
-	while (l2->va != nr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l2->va != nr) {
 		(l2->va)++;
 		if(test_bit(FLG_MOD128, &l2->flag))
 			l2->va %= 128;
@@ -416,6 +421,12 @@ setva(struct PStack *st, unsigned int nr
 		if (test_bit(FLG_LLI_L2WAKEUP, &st->lli.flag) && (len >=0))
--
 	while ((skb = skb_dequeue(&st->l2.ui_queue))) {
 		memcpy(skb_push(skb, i), header, i);
 		enqueue_ui(st, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (l2->vs != nr) {
 			(l2->vs)--;
 			if(test_bit(FLG_MOD128, &l2->flag)) {
@@ -953,6 +980,12 @@ invoke_retransmission(struct PStack *st,
 				st->l1.bcs->tx_cnt += l2->windowar[p1]->len + l2headersize(l2, 0);
 			skb_queue_head(&l2->i_queue, l2->windowar[p1]);
--
-		while (cnt < count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (cnt < count) {
 #ifdef __powerpc__
 			*ptr++ = in_be32((unsigned *)(cs->hw.avm.isac +_IO_BASE));
 #else
 			*ptr++ = inl(cs->hw.avm.isac);
 #endif /* __powerpc__ */
--
 		while (cnt < count) {
 			*p++ = inb(cs->hw.avm.isac);
 			cnt++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-		while (cnt<count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (cnt<count) {
 #ifdef __powerpc__
 			out_be32((unsigned *)(cs->hw.avm.isac +_IO_BASE), *ptr++);
 #else
 			outl(*ptr++, cs->hw.avm.isac);
 #endif /* __powerpc__ */
--
 		while (cnt<count) {
 			outb(*p++, cs->hw.avm.isac);
 			cnt++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-		while (pd->log_head->next) {
-			if ((pd->log_head->usage_cnt <= 0) &&
-			    (pd->log_head->next->usage_cnt <= 0)) {
-				ib = pd->log_head;
-				pd->log_head = pd->log_head->next;
-				kfree(ib);
--
+			while (pd->log_head->next) {
+				if ((pd->log_head->usage_cnt <= 0) &&
+				(pd->log_head->next->usage_cnt <= 0)) {
+					ib = pd->log_head;
+					pd->log_head = pd->log_head->next;
+					kfree(ib);
--
 		while (inf) {
 			inf->usage_cnt--;	/* decrement usage count for buffers */
 			inf = inf->next;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
--
-				while (pd->log_head) {
-					inf = pd->log_head;
-					pd->log_head = pd->log_head->next;
-					kfree(inf);
+			if (pd->if_used <= 0)	/* delete buffers if last file closed */ {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
--
+					while (pd->log_head) {
+						inf = pd->log_head;
+						pd->log_head = pd->log_head->next;
+						kfree(inf);
+						if (_cur < timeout) {
+							rdstcll(_cur);
--
 		while (tmp) {
 			if (tmp->next == card)
 				tmp->next = card->next;
 			card_last = tmp;
 			tmp = tmp->next;
+			if (_cur < timeout) {
--
 	while (cnt--) {
 		*dst++ = *(buf + 1);	/* high byte */
 		*dst++ = *buf;	/* low byte */
 		dst += 2;	/* point to next longword */
 		buf += 2;	/* buffer only filled with words */
+		if (_cur < timeout) {
--
 	while (len) {
 
 		/* first determine the number of bytes that may be buffered */
@@ -302,13 +318,30 @@ ergo_writebootseq(struct HYSDN_CARD *car
 
 		/* now we know how much bytes we may put in the puffer */
--
 		while (nr_write--) {
 			*(dst + wr_mirror) = *buf++;	/* output one byte */
 			if (++wr_mirror >= buflen)
 				wr_mirror = 0;
 			sp->WrPtr = wr_mirror;	/* announce the next byte to E1 */
+			if (_cur < timeout) {
--
 		}		/* while (nr_write) */
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	}			/* while (len) */
 	return (0);
 }				/* ergo_writebootseq */
diff -u -p a/isdn/hysdn/hysdn_boot.c b/isdn/hysdn/hysdn_boot.c
--- a/isdn/hysdn/hysdn_boot.c
+++ b/isdn/hysdn/hysdn_boot.c
--
 	while (cnt--) {
 		boot->Cryptor = (boot->Cryptor >> 1) ^ ((boot->Cryptor & 1U) ? CRYPT_FEEDTERM : 0);
 		*bufp++ ^= (unsigned char)boot->Cryptor;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (card) {
 
 		sprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);
@@ -401,6 +406,12 @@ hysdn_procconf_init(void)
 			hysdn_proclog_init(card);	/* init the log file entry */
 		}
--
 	while (card) {
 
 		sprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);
@@ -427,6 +443,12 @@ hysdn_procconf_release(void)
 		hysdn_proclog_release(card);	/* init the log file entry */
 
--
 	while (card->async_busy) {
 
 		if (card->debug_flags & LOG_SCHED_ASYN)
@@ -163,6 +168,12 @@ hysdn_tx_cfgline(hysdn_card *card, unsig
 		msleep_interruptible(20);		/* Timeout 20ms */
 		if (!--cnt)
--
 	while (card->async_busy) {
 
 		if (card->debug_flags & LOG_SCHED_ASYN)
@@ -188,6 +204,12 @@ hysdn_tx_cfgline(hysdn_card *card, unsig
 		msleep_interruptible(20);		/* Timeout 20ms */
 		if (!--cnt)
--
 	while (nl->sk_count) {
 		dev_kfree_skb(nl->skbs[nl->out_idx++]);		/* free skb */
 		if (nl->out_idx >= MAX_SKB_BUFFERS)
 			nl->out_idx = 0;	/* wrap around */
 		nl->sk_count--;
+		if (_cur < timeout) {
--
-	while ((skb = skb_dequeue(&ap->recv_queue))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&ap->recv_queue))) {
 		if (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_IND)
 			ap->nrecvdatapkt++;
 		else
 			ap->nrecvctlpkt++;
 
--
 	while (divert_info_head->next) {
 		if ((divert_info_head->usage_cnt <= 0) &&
 		    (divert_info_head->next->usage_cnt <= 0)) {
@@ -70,6 +75,12 @@ put_info_buffer(char *cp)
 			kfree(ib);
 		} else
--
 	while (inf) {
 		inf->usage_cnt--;
 		inf = inf->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while (divert_info_head) {
-			inf = divert_info_head;
-			divert_info_head = divert_info_head->next;
-			kfree(inf);
+	if (if_used <= 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
+			while (divert_info_head) {
+				inf = divert_info_head;
+				divert_info_head = divert_info_head->next;
+				kfree(inf);
+					if (_cur < timeout) {
+							rdstcll(_cur);
--
 	while (tries < timeout) {
 		schedule_timeout_interruptible(1);
 		
@@ -222,6 +227,12 @@ int send_and_receive(int card,
 		}
 
--
         while (timeout) {
                 if (inb(ISA_PORT_SOS) & ISA_SOS_READY) {
                         outb(data, ISA_PORT_SDO);
@@ -206,6 +211,12 @@ act2000_isa_writeb(act2000_card * card,
                         timeout--;
                         udelay(10);
--
         while (timeout) {
                 if (inb(ISA_PORT_SIS) & ISA_SIS_READY) {
                         *data = inb(ISA_PORT_SDI);
@@ -223,6 +239,12 @@ act2000_isa_readb(act2000_card * card, u
                         timeout--;
                         udelay(10);
--
 	while (!act2000_isa_readb(card, &c)) {
 		if (card->idat.isa.rcvidx < 8) {
                         card->idat.isa.rcvhdr[card->idat.isa.rcvidx++] = c;
@@ -279,6 +306,12 @@ act2000_isa_receive(act2000_card *card)
 				card->idat.isa.rcvptr = card->idat.isa.rcvhdr;
 			}
--
 	while (1) {
 		spin_lock_irqsave(&card->lock, flags);
 		if (!(card->sbuf)) {
@@ -322,6 +360,11 @@ act2000_isa_send(act2000_card * card)
 		}
 		skb = card->sbuf;
--
 		while (skb->len) {
 			if (act2000_isa_writeb(card, *(skb->data))) {
 				/* Fifo is full, but more data to send */
@@ -332,6 +375,12 @@ act2000_isa_send(act2000_card * card)
 			}
 			skb_pull(skb, 1);
--
         while (length) {
                 l = (length > 1024) ? 1024 : length;
                 c = 0;
@@ -424,7 +484,12 @@ act2000_isa_download(act2000_card * card
                         kfree(buf);
                         return -EFAULT;
--
-                while (c < l) {
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                timeout = rdstcll(start) + delta;
+                        while (c < l) {
                         if (act2000_isa_writeb(card, *b++)) {
                                 printk(KERN_WARNING
                                        "act2000: loader timed out"
@@ -433,9 +498,21 @@ act2000_isa_download(act2000_card * card
                                 return -ETIME;
--
 	while (p) {
 		q  = p->next;
 		kfree(p);
 		p = q;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (p) {
 		if (p->eaz == eaz)
 			return(p->msn);
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (p) {
 			if (p->eaz == eazmsn[0]) {
 				spin_lock_irqsave(&card->lock, flags);
@@ -156,10 +183,21 @@ act2000_set_msn(act2000_card *card, char
 			}
 			q = p;
--
 	while (p) {
 		/* Found in list, replace MSN */
 		if (p->eaz == eazmsn[0]) {
@@ -173,6 +211,12 @@ act2000_set_msn(act2000_card *card, char
 			return 0;
 		}
--
         while (p) {
                 if (p->myid == driverid)
                         return p;
                 p = p->next;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
--
         while (p) {
 		initialized = 0;
 		if (!p->interface.statcallb) {
@@ -774,7 +834,13 @@ act2000_addcard(int bus, int port, int i
                         }
 			failed++;
--
         while (card) {
                 unregister_card(card);
 		del_timer(&card->ptimer);
                 card = card->next;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
--
         while (card) {
                 last = card;
                 card = card->next;
 		act2000_clear_msn(last);
                 kfree(last);
+                if (_cur < timeout) {
--
 	while (p) {
 		int i;
 
@@ -294,7 +299,13 @@ actcapi_manufacturer_req_msn(act2000_car
 			ACTCAPI_QUEUE_TX;
 		}
--
         while (1) {
                 m = (actcapi_msg *)tmp->data;
                 if ((((m->msg.data_b3_req.fakencci >> 8) & 0xff) == chan->ncci) &&
@@ -622,6 +638,12 @@ handle_ack(act2000_card *card, act2000_c
 			printk(KERN_WARNING "act2000: handle_ack nothing found!\n");
                         return 0;
--
 	while ((skb = skb_dequeue(&card->rcvq))) {
 		actcapi_debug_msg(skb, 0);
 		msg = (actcapi_msg *)skb->data;
@@ -934,6 +961,12 @@ actcapi_dispatch(struct work_struct *wor
 				break;
 		}
--
 	while (card->sndcount[ch]) {
 		if ((skb = skb_dequeue(&card->bqueue[ch]))) {
 			len = skb->len;
@@ -77,6 +82,12 @@ isdnloop_bchan_send(isdnloop_card * card
 			card->interface.statcallb(&cmd);
 		} else
--
 	while (cc) {
 		for (ch = 0; ch < 2; ch++) {
 			/* Exclude ourself */
@@ -692,12 +708,23 @@ isdnloop_try_call(isdnloop_card * card,
 					break;
 				case ISDN_PTYPE_1TR6:
--
 					while (*e) {
 						sprintf(nbuf, "%s%c", cc->s0num[0], *e);
 						if (!(strcmp(nbuf, cmd->parm.setup.phone)))
 							num_match = 1;
 						e++;
-					}
--
 			while (strchr("0157", *p)) {
 				if (i)
 					card->sil[ch - 1] |= si2bit[*p - '0'];
 				i = (*p++ == '0');
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (len) {
 		int count = len;
 		u_char *p;
@@ -1005,6 +1054,12 @@ isdnloop_writecmd(const u_char * buf, in
 			}
 			ocount++;
--
 	while (p) {
 		isdnloop_stopcard(p);
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (p) {
 		if (p->myid == driverid)
 			return p;
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (card) {
 		cmd.command = ISDN_STAT_UNLOAD;
 		cmd.driver = card->myid;
@@ -1524,13 +1606,30 @@ isdnloop_exit(void)
 		for (i = 0; i < ISDNLOOP_BCH; i++)
 			isdnloop_free_queue(card, i);
--
 	while (card) {
 		last = card;
 		skb_queue_purge(&card->dqueue);
 		card = card->next;
 		kfree(last);
+		if (_cur < timeout) {
--
-	while (line < len) {    /* Are we done with all lines of the matrix? */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (line < len) {    /* Are we done with all lines of the matrix? */
 		if ((line % 10) == 0) {	/* the 0. line of the matrix is always 0 ! */
 			if (m[line] != 0x00) {	/* not 0 ? -> error! */
 #ifdef ISDN_V110_DEBUG
@@ -239,6 +244,12 @@ DecodeMatrix(isdn_v110_stream * v, unsig
 			}
--
 	while ((i < len) && (line < mlen)) {	/* while we still have input data */
 		switch (line % 10) {	/* in which line of the matrix are we? */
 			case 0:
@@ -380,6 +396,12 @@ EncodeMatrix(unsigned char *buf, int len
 		mbit >>= 1;     /* go to next bit of matrix */
 		goto next_bit;
--
 	while (s->nleft < s->nbits) {
 		int d = *((*in)++);
 		(*len)--;
 		s->word = (s->word << 8) | d;
 		s->nleft += 8;
+		if (_cur < timeout) {
--
 	while (len) {
 		int e = isdn_audio_get_bits(s, &in, &len);
 		int sign;
@@ -386,6 +402,12 @@ isdn_audio_adpcm2xlaw(adpcm_state * s, i
 		d = (d * Mx[nbits - 2][e] + 0x2000) >> 14;
 		if (d < 5)
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len--) {
 		int e = 0,
 		 nmax = 1 << (nbits - 1);
 		int sign,
@@ -415,9 +442,20 @@ isdn_audio_xlaw2adpcm(adpcm_state * s, i
 			e = nmax;
--
 		while (--nmax && delta > d) {
 			delta -= d;
 			e++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while ((skb = skb_dequeue(&info->dtmf_queue))) {
 		result = (int *) skb->data;
 		s = info->dtmf_state;
@@ -577,6 +626,12 @@ isdn_audio_eval_dtmf(modem_info * info)
 		} else
 			kfree_skb(skb);
--
-	while (isdn_wildmat(s, p)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (isdn_wildmat(s, p)) {
 		if (*++s == '\0')
 			return (2);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (p) {
 		*(p->private) = 1;
 		p = (infostruct *) p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (p) {
 			if (p->private == (char *) &(filep->private_data)) {
 				if (q)
@@ -1815,6 +1842,12 @@ isdn_close(struct inode *ino, struct fil
 			}
 			q = p;
--
 		printk(KERN_WARNING "isdn: No private data while closing isdnctrl\n");
 		goto out;
diff -u -p a/isdn/i4l/isdn_ppp.c b/isdn/i4l/isdn_ppp.c
--- a/isdn/i4l/isdn_ppp.c
+++ b/isdn/i4l/isdn_ppp.c
@@ -164,11 +164,22 @@ isdn_ppp_bind(isdn_net_local * lp)
--
 		while (net_dev) {	/* step through net devices to find exclusive minors */
 			isdn_net_local *lp = net_dev->local;
 			if (lp->pppbind >= 0)
 				exclusive[lp->pppbind] = 1;
 			net_dev = net_dev->next;
+			if (_cur < timeout) {
--
 				while(ipc) {
 					j = ipc->num / (sizeof(long)*8);
 					i = ipc->num % (sizeof(long)*8);
 					if(j < 8)
 						protos[j] |= (0x1<<i);
 					ipc = ipc->next;
--
-    	while( frag ) {
+    	unsigned long long delta = (cpu / khz / HZ) * 2;
+    	unsigned long long _start = 0;
+    	unsigned long long _cur = 0;
+    	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while( frag ) {
 		nextfrag = frag->next;
 		isdn_ppp_mp_free_skb(lp->netdev->pb, frag);
 		frag = nextfrag;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while (from != to) {
-	  		struct sk_buff * next = from->next;
-			isdn_ppp_mp_free_skb(mp, from);
+	if( from ) {
+	  		unsigned long long delta = (cpu / khz / HZ) * 2;
+	  		unsigned long long _start = 0;
--
+	  		while (from != to) {
+	  			struct sk_buff * next = from->next;
+	  		isdn_ppp_mp_free_skb(mp, from);
 	  		from = next;
+	  		if (_cur < timeout) {
+	  			  		rdstcll(_cur);
--
-		while( from != to ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while( from != to ) {
 			unsigned int len = from->len - MP_HEADER_LEN;
 
 			skb_copy_from_linear_data_offset(from, MP_HEADER_LEN,
@@ -1908,6 +1958,12 @@ void isdn_ppp_mp_reassembly( isdn_net_de
 			frag = from->next;
--
 						while (--l) {
 							if (*dp == DLE)
 								tty_insert_flip_char(tty, DLE, 0);
 							tty_insert_flip_char(tty, *dp++, 0);
+							if (_cur < timeout) {
+								rdstcll(_cur);
--
 	while (c--) {
 		ch = *buf;
 		if ((ch != 0x11) && (ch != 0x13))
 			return 1;
 		buf++;
+		if (_cur < timeout) {
--
 	while ((frame = dev->read_queue)) {
 		dev->read_queue = frame->next;
 		spin_unlock_irqrestore(&dev->lock, flags);
@@ -312,6 +317,12 @@ pcbit_deliver(struct work_struct *work)
 		kfree(frame);
 
--
 		while (read_seq != dev->rcv_seq) {
 			pcbit_receive(dev);
 			dev->rcv_seq = (dev->rcv_seq + 1) % 8;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 						while (*p) {
 							if (*p >= '0' && *p <= '9')
 								*q++ = *p;
 							p++;
+							if (_cur < timeout) {
+								rdstcll(_cur);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (1) {
 #ifdef BOOT_DEBUG
 		printk(KERN_DEBUG "Loader %d ?\n", cardnumber);
 #endif
@@ -772,6 +788,12 @@ icn_check_loader(int cardnumber)
 			icn_release_channel();
--
-  while (slsec) { \
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (slsec) { \
     msleep_interruptible(1000); \
     slsec--; \
-  } \
+  if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (left) {
 		if (sbfree) {   /* If there is a free buffer...  */
 			cnt = left;
@@ -951,10 +989,21 @@ icn_loadproto(u_char __user * buffer, ic
 			}
 			schedule_timeout_interruptible(10);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (1) {
 		if (readb(&cmd_o) || readb(&cmd_i)) {
 #ifdef BOOT_DEBUG
 			printk(KERN_DEBUG "Proto?\n");
@@ -999,6 +1048,12 @@ icn_loadproto(u_char __user * buffer, ic
 			icn_maprelease_channel(card, 0);
--
 	while (p) {
 		icn_stopcard(p);
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (card) {
 		if (!request_region(card->port, ICN_PORTLEN, "icn-isdn")) {
 			printk(KERN_WARNING
@@ -1146,6 +1217,12 @@ icn_disable_cards(void)
 			release_region(card->port, ICN_PORTLEN);
 		}
--
 	while (p) {
 		if (p->myid == driverid)
 			return p;
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (card) {
 		cmd.command = ISDN_STAT_UNLOAD;
 		cmd.driver = card->myid;
@@ -1676,13 +1769,30 @@ static void __exit icn_exit(void)
 		tmpcard = card->next;
 		spin_unlock_irqrestore(&card->lock, flags);
--
 	while (card) {
 		last = card;
 		card = card->next;
 		kfree(last);
+		if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while ((skb = skb_dequeue(&dch->rqueue))) {
 			if (likely(dch->dev.D.peer)) {
 				err = dch->dev.D.recv(dch->dev.D.peer, skb);
@@ -34,6 +39,12 @@ dchannel_bh(struct work_struct *ws)
 					dev_kfree_skb(skb);
 			} else
--
 		while ((skb = skb_dequeue(&bch->rqueue))) {
 			bch->rcount--;
 			if (likely(bch->ch.peer)) {
@@ -58,6 +74,12 @@ bchannel_bh(struct work_struct *ws)
 					dev_kfree_skb(skb);
 			} else
--
-	while (l2->va != nr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l2->va != nr) {
 		l2->va++;
 		if (test_bit(FLG_MOD128, &l2->flag))
 			l2->va %= 128;
@@ -582,11 +587,28 @@ setva(struct layer2 *l2, unsigned int nr
 			l2->windowar[l2->sow] = NULL;
--
 	while (skb) {
 		dev_kfree_skb(skb);
 		skb = skb_dequeue(&l2->tmp_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = skb_dequeue(&l2->ui_queue))) {
 		memcpy(skb_push(skb, i), header, i);
 		enqueue_ui(l2, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (l2->vs != nr) {
 			(l2->vs)--;
 			if (test_bit(FLG_MOD128, &l2->flag)) {
@@ -1152,6 +1190,12 @@ invoke_retransmission(struct layer2 *l2,
 				    "%s: windowar[%d] is NULL\n",
 				    __func__, p1);
--
 	while (i < ii) {
 		*p = volume_change[*p];
 		p++;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((tok = strsep(&dup, "|"))) {
 		if (!strlen(tok))
 			continue;
@@ -320,7 +325,13 @@ int dsp_pipeline_build(struct dsp_pipeli
 				"%s\n", __func__, name);
 			incomplete = 1;
--
 			while (*digits) {
 				int k;
 				struct sk_buff *nskb;
@@ -755,6 +760,12 @@ dsp_function(struct mISDNchannel *ch,  s
 						dev_kfree_skb(nskb);
 				}
--
 			while (*digits) {
 				int k;
 				struct sk_buff *nskb;
@@ -801,6 +817,12 @@ dsp_function(struct mISDNchannel *ch,  s
 						dev_kfree_skb(nskb);
 				}
--
 	while ((skb = skb_dequeue(&dsp->sendq))) {
 		/* in locked date, we must have still data in queue */
 		if (dsp->data_pending) {
@@ -1040,6 +1067,12 @@ dsp_send_bh(struct work_struct *work)
 			} else
 				dev_kfree_skb(skb);
--
 		while ((tok = strsep(&dup, ","))) {
 			if (!strlen(tok))
 				continue;
@@ -88,6 +93,12 @@ void dsp_hwec_enable(struct dsp *dsp, co
 				if (sscanf(val, "%d", &tmp) == 1)
 					deftaps = tmp;
--
 	while (samples[i].len) {
 		j = 0;
-		while (j < (*samples[i].len)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (j < (*samples[i].len)) {
 			samples[i].data[j] =
 				dsp_audio_alaw_to_ulaw[samples[i].data[j]];
 			j++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (len) {
 		/* find sample to start with */
 		while (42) {
@@ -421,6 +448,12 @@ void dsp_tone_copy(struct dsp *dsp, u8 *
 		data += num;
 		count += num;
 		len -= num;
+		if (_cur < timeout) {
--
 	while (i < ii) {
 		d[w++ & CMX_BUFF_MASK] = *p++;
 		i++;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 				while (r != rr) {
 					*c++ += dsp_audio_law_to_s32[q[r]];
 					r = (r+1) & CMX_BUFF_MASK;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 			while (r != rr) {
 				p[r] = dsp_silence;
 				r = (r+1) & CMX_BUFF_MASK;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 				while (r != rr) {
 					p[r] = dsp_silence;
 					r = (r+1) & CMX_BUFF_MASK;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 				while (r != rr) {
 					q[r] = dsp_silence;
 					r = (r+1) & CMX_BUFF_MASK;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 			while (i) {
 				dsp->rx_delay[i] = dsp->rx_delay[i-1];
 				dsp->tx_delay[i] = dsp->tx_delay[i-1];
 				i--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
-	while (w != ww) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (w != ww) {
 #ifdef CMX_TX_DEBUG
 		if (strlen(debugbuf) < 48)
 			sprintf(debugbuf+strlen(debugbuf), " %02x", *d);
 #endif
 		p[w] = *d++;
--
-	while (!signal_pending(current)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!signal_pending(current)) {
 		struct kvec iov = {
 			.iov_base = recvbuf,
 			.iov_len = recvbuf_size,
@@ -743,15 +748,32 @@ l1oip_socket_thread(void *data)
 				printk(KERN_WARNING
--
 	while (!hc->socket) {
 		spin_unlock(&hc->socket_lock);
 		schedule_timeout(HZ/10);
 		spin_lock(&hc->socket_lock);
+		if (_cur < timeout) {
+				rdstcll(_cur);
--
-		while (l) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (l) {
 			ll = (l < L1OIP_MAX_PERFRAME) ? l : L1OIP_MAX_PERFRAME;
 			l1oip_socket_send(hc, 0, dch->slot, 0,
 				hc->chan[dch->slot].tx_counter++, p, ll);
 			p += ll;
 			l -= ll;
--
-		while (l) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (l) {
 			ll = (l < L1OIP_MAX_PERFRAME) ? l : L1OIP_MAX_PERFRAME;
 			l1oip_socket_send(hc, hc->codec, bch->slot, 0,
 				hc->chan[bch->slot].tx_counter, p, ll);
 			hc->chan[bch->slot].tx_counter += ll;
 			p += ll;
--
 	while (i < ii) {
 		*result++ = table_com[(data[0]<<8) | (data[1])];
 		data += 2;
 		i++;
 		o++;
+		if (_cur < timeout) {
--
 	while (i < len) {
 		r = table_dec[*data++];
 		*result++ = r>>8;
 		*result++ = r;
 		i++;
+		if (_cur < timeout) {
--
 	while (i < len) {
 		*result++ = alaw_to_ulaw[*data++];
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (i < len) {
 		*result++ = ulaw_to_alaw[*data++];
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (i < len) {
 		/* collect a block of 9 samples */
 		if (j < 9) {
@@ -442,6 +447,12 @@ dsp_bf_encrypt(struct dsp *dsp, u8 *data
 		bf_crypt_out[6] = ((yr>>15) & 0x7f) | ((cs<<6) & 0x80);
 		bf_crypt_out[7] = ((yr>>8) & 0x7f) | (cs<<7);
--
 	while (i < len) {
 		/*
 		 * shift upper bit and rotate data to buffer ring
@@ -549,6 +565,12 @@ dsp_bf_decrypt(struct dsp *dsp, u8 *data
 		bf_data_out[7] = dsp_audio_seven2law[(yr>>8) & 0x7f];
 		bf_data_out[8] = dsp_audio_seven2law[(yr>>1) & 0x7f];
--
-    while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                         (word)(len+1+sizeof(*pmsg))))) {
       if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
         queueFreeMsg (dbg_queue);
       } else {
         break;
--
-      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                         (word)(len+1+sizeof(*pmsg))))) {
         if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
           queueFreeMsg (dbg_queue);
         } else {
           break;
--
-    while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                 (word)length+sizeof(*pmsg)))) {
       if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
         queueFreeMsg (dbg_queue);
       } else {
         break;
--
-    while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                   (word)length+sizeof(*pmsg)+2))) {
       if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
         queueFreeMsg (dbg_queue);
       } else {
         break;
--
-      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                                           (word)length))) {
         if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
           queueFreeMsg (dbg_queue);
         } else {
           break;
--
-  while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                       (word)(len+1+sizeof(*pmsg))))) {
     if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
       queueFreeMsg (dbg_queue);
     } else {
       break;
--
-      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                         (word)(len+1+sizeof(*pmsg))))) {
         if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
           queueFreeMsg (dbg_queue);
         } else {
           break;
--
-  while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                               (word)length+sizeof(*pmsg)))) {
     if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
       queueFreeMsg (dbg_queue);
     } else {
       break;
--
   while (ref_len--) {
     if (*nmbr-- != *ref--) {
       return (-1);
     }
+    if (_cur < timeout) {
+      rdstcll(_cur);
--
  while (dwords--) {
   *data++ = READ_DWORD((Base + (unsigned long)addr));
   addr+=4;
+  if (_cur < timeout) {
+   rdstcll(_cur);
+  }
--
- while (dwords--) {
+ unsigned long long delta = (cpu / khz / HZ) * 2;
+ unsigned long long _start = 0;
+ unsigned long long _cur = 0;
+ unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (dwords--) {
 	WRITE_DWORD((Base + (unsigned long)addr), *data);
   	addr+=4;
 	data++;
+	if (_cur < timeout) {
+  	rdstcll(_cur);
--
 	while ( code < FileLength )
 	{
 		val = ((word)File[code++]) << 3 ;
@@ -343,6 +348,12 @@ int qBri_FPGA_download (PISDN_ADAPTER Io
 			WRITE_WORD(addr, baseval | FPGA_CCLK) ;     /* set CCLK hi */
 			WRITE_WORD(addr, baseval) ;                 /* set CCLK lo */
--
 	while (length--) {
 		outpp(addrHi, (word) (address >> 16));
 		outppw(addrLo, (word) (address & 0x0000ffff));
 		outpp(ioaddr, *data++);
 		address++;
+		if (_cur < timeout) {
--
 	while (length--) {
 		WRITE_BYTE(mem++, *data++);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
 						while (len--) {
 							*dst++ = READ_BYTE(src++);
+							if (_cur < timeout) {
+		rdstcll(_cur);
+							}
+							else {
--
 						while (len--) {
 							*dst++ = READ_BYTE(src++);
+							if (_cur < timeout) {
+			rdstcll(_cur);
+							}
+							else {
--
 	while (length--) {
 		WRITE_BYTE(mem++, *data++);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
 		while ((*buffer_length >= (64 * 1024))
 		       &&
 		       (!(*buffer = diva_os_malloc (0, *buffer_length)))) {
 			*buffer_length -= 1024;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (diva_mnt_shutdown_xdi_adapters() && i--) {
 		diva_os_sleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 			while (length--) {
 				pci_write_config_dword(dev, offset,
 						       *(unsigned int *)
 						       p++);
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 			while (length--) {
 				pci_write_config_byte(dev, offset,
 						      *(unsigned char *)
 						      p++);
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 			while (length--) {
 				pci_read_config_dword(dev, offset,
 						      (unsigned int *)
 						      p++);
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 			while (length--) {
 				pci_read_config_byte(dev, offset,
 						     (unsigned char *)
 						     p++);
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while ((a = get_and_remove_from_queue())) {
 		if (a->interface.cleanup_adapter_proc) {
 			(*(a->interface.cleanup_adapter_proc)) (a);
@@ -379,6 +384,12 @@ void divasa_xdi_driver_unload(void)
 			remove_adapter_proc(a);
 		}
--
-  while(e_no && ReadyCount) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(e_no && ReadyCount) {
     next_req(a);
     this = entity_ptr(a, e_no);
 #ifdef USE_EXTENDED_DEBUGS
@@ -149,7 +154,12 @@ void pr_out(ADAPTER * a)
    } else { /* Use CMA extension in order to transfer data to the card */
--
-      while (i < this->XNum) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+        while (i < this->XNum) {
         diva_istream_write (a,
                             this->Id,
                             PTR_P(a,this,&X[i].P[0]),
@@ -157,6 +167,12 @@ void pr_out(ADAPTER * a)
                             ((i+1) == this->XNum),
--
     while(Count--) {
       if((Rc=a->ram_in(a, &RcIn->Rc)) != 0) {
         dword tmp[2];
@@ -291,6 +318,12 @@ byte pr_dpc(ADAPTER * a)
       }
         /* get buffer address of next return code                   */
--
     while(Count--) {
         /* if the application marks an indication as RNR, all       */
         /* indications from the same Id delivered in this interrupt */
@@ -337,6 +375,12 @@ byte pr_dpc(ADAPTER * a)
       }
         /* get buffer address of next indication                    */
--
     while (sample_number < length)
     {
       if (cycle_counter < CAPIDTMF_RECV_ACCUMULATE_CYCLES)
@@ -669,6 +674,12 @@ void capidtmf_recv_block (t_capidtmf_sta
         cycle_counter = 0;
         sample_number++;
--
         while (k != plci->msg_in_write_pos)
         {
           if (k == plci->msg_in_wrap_pos)
@@ -488,6 +493,12 @@ word api_put(APPL   * appl, CAPI_MSG   *
           k += (((CAPI_MSG   *)(&((byte   *)(plci->msg_in_queue))[k]))->header.length +
             MSG_IN_OVERHEAD + 3) & 0xfffc;
--
     while (i != plci->msg_in_write_pos)
     {
       if (i == plci->msg_in_wrap_pos)
@@ -1036,6 +1052,12 @@ static void plci_free_msg_in_queue (PLCI
       i += (((CAPI_MSG   *)(&((byte   *)(plci->msg_in_queue))[i]))->header.length +
         MSG_IN_OVERHEAD + 3) & 0xfffc;
--
   while(ploc<plci->Sig.RBuffer->length-1) {
 
         /* read information element id and length                   */
@@ -9003,6 +9030,12 @@ static void IndParse(PLCI *plci, word *p
     }
 
--
   while (i + sizeof(word) <= a->adv_voice_coef_length)
   {
     PUT_WORD (p, GET_WORD (a->adv_voice_coef_buffer + i));
     p += 2;
     i += 2;
+    if (_cur < timeout) {
--
   while (i < ADV_VOICE_OLD_COEF_COUNT * sizeof(word))
   {
     PUT_WORD (p, 0x8000);
     p += 2;
     i += 2;
+    if (_cur < timeout) {
--
         while (ncci_ptr->data_pending)
         {
           plci->data_sent_ptr = ncci_ptr->DBuffer[ncci_ptr->data_out].P;
           data_rc (plci, plci->adapter->ncci_ch[plci->adjust_b_ncci]);
+          if (_cur < timeout) {
+        rdstcll(_cur);
--
         while (ncci_ptr->data_ack_pending)
           data_ack (plci, plci->adapter->ncci_ch[plci->adjust_b_ncci]);
diff -u -p a/isdn/hardware/avm/b1dma.c b/isdn/hardware/avm/b1dma.c
--- a/isdn/hardware/avm/b1dma.c
+++ b/isdn/hardware/avm/b1dma.c
@@ -109,12 +109,23 @@ static int b1dma_tolink(avmcard *card, v
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len--) {
 		while (   !b1dma_tx_empty(card->port)
 		       && time_before(jiffies, stop));
 		if (!b1dma_tx_empty(card->port)) 
 			return -1;
 	        t1outp(card->port, 0x01, *s++);
+	        if (_cur < timeout) {
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len--) {
 		while (   !b1dma_rx_full(card->port)
 		       && time_before(jiffies, stop));
 		if (!b1dma_rx_full(card->port)) 
 			return -1;
 	        *s++ = t1inp(card->port, 0x00);
+	        if (_cur < timeout) {
--
 	while (b1_rx_full(card->port)) {
 
 		b1cmd = b1_get_byte(card->port);
@@ -276,6 +281,12 @@ static irqreturn_t t1isa_interrupt(int i
 					card->name, b1cmd);
 			return IRQ_NONE;
--
 	while (cnt < count) {
 		val = le32_to_cpu(inl(addr));
 		put_unaligned(val, ptr);
 		ptr++;
 		cnt += 4;
+		if (_cur < timeout) {
--
 	while (cnt < count) {
 		val = get_unaligned(ptr);
 		outl(cpu_to_le32(val), addr);
 		ptr++;
 		cnt += 4;
+		if (_cur < timeout) {
--
 	while (cnt--) {
 		spin_lock_irqsave(&card->lock, flags);
 		initW6692(card);
@@ -931,6 +936,12 @@ init_card(struct w6692_hw *card)
 			reset_w6692(card);
 		} else
--
 	while (alt_idx < intf->num_altsetting) {
 		iface = intf->altsetting + alt_idx;
 		probe_alt_setting = iface->desc.bAlternateSetting;
 		cfg_used = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (validconf[cfg_used][0]) {
 			cfg_found = 1;
 			vcf = validconf[cfg_used];
@@ -2026,8 +2036,20 @@ hfcsusb_probe(struct usb_interface *intf
 				}
 			}
--
 	while (cnt--) {
 		val = card->send.start[idx];
 		val &= mask;
@@ -204,6 +209,12 @@ fill_mem(struct tiger_ch *bc, u32 idx, u
 		card->send.start[idx++] = val;
 		if (idx >= card->send.size)
--
 	while (hfc_register_names[++i].name) {
 		if (hfc_register_names[i].reg == reg)
 			strcat(regname, hfc_register_names[i].name);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (hfc_register_names[i++].name)
 		;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while (hfc_register_names[++i].name) {
 		if (hfc_register_names[i].reg == reg)
 			strcat(regname, hfc_register_names[i].name);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (hfc_register_names[i++].name)
 		;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while (hfc_register_names[++i].name) {
 		if (hfc_register_names[i].reg == reg)
 			strcat(regname, hfc_register_names[i].name);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (len>>2) {
 		outl(cpu_to_le32(*(u32 *)data), hc->pci_iobase);
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len>>1) {
 		outw(cpu_to_le16(*(u16 *)data), hc->pci_iobase);
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len) {
 		outb(*data, hc->pci_iobase);
 		data++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (len>>2) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>2) {
 		writel(cpu_to_le32(*(u32 *)data),
 			hc->pci_membase + A_FIFO_DATA0);
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
--
-	while (len>>1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>1) {
 		writew(cpu_to_le16(*(u16 *)data),
 			hc->pci_membase + A_FIFO_DATA0);
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
--
 	while (len) {
 		writeb(*data, hc->pci_membase + A_FIFO_DATA0);
 		data++;
 		len--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (len>>2) {
 		*(u32 *)data = le32_to_cpu(inl(hc->pci_iobase));
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len>>1) {
 		*(u16 *)data = le16_to_cpu(inw(hc->pci_iobase));
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len) {
 		*data = inb(hc->pci_iobase);
 		data++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (len>>2) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>2) {
 		*(u32 *)data =
 			le32_to_cpu(readl(hc->pci_membase + A_FIFO_DATA0));
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
--
-	while (len>>1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>1) {
 		*(u16 *)data =
 			le16_to_cpu(readw(hc->pci_membase + A_FIFO_DATA0));
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
--
 	while (len) {
 		*data = readb(hc->pci_membase + A_FIFO_DATA0);
 		data++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (f2 != (temp = HFC_inb_nodebug(hc, A_F2))) {
 			if (debug & DEBUG_HFCMULTI_FIFO)
 				printk(KERN_DEBUG
 				    "%s(card %d): reread f2 because %d!=%d\n",
 				    __func__, hc->id + 1, temp, f2);
 			f2 = temp; /* repeat until F2 is equal */
--
 	while (z2 != (temp = (HFC_inw_nodebug(hc, A_Z2) - hc->Zmin))) {
 		if (debug & DEBUG_HFCMULTI_FIFO)
 			printk(KERN_DEBUG "%s(card %d): reread z2 because "
 				"%d!=%d\n", __func__, hc->id + 1, temp, z2);
 		z2 = temp; /* repeat unti Z2 is equal */
+		if (_cur < timeout) {
--
 		while (f1 != (temp = HFC_inb_nodebug(hc, A_F1))) {
 			if (debug & DEBUG_HFCMULTI_FIFO)
 				printk(KERN_DEBUG
 				    "%s(card %d): reread f1 because %d!=%d\n",
 				    __func__, hc->id + 1, temp, f1);
 			f1 = temp; /* repeat until F1 is equal */
--
 	while (z1 != (temp = (HFC_inw_nodebug(hc, A_Z1) - hc->Zmin))) {
 		if (debug & DEBUG_HFCMULTI_FIFO)
 			printk(KERN_DEBUG "%s(card %d): reread z2 because "
 				"%d!=%d\n", __func__, hc->id + 1, temp, z2);
 		z1 = temp; /* repeat until Z1 is equal */
+		if (_cur < timeout) {
--
 				while (st_status != (temp =
 					HFC_inb_nodebug(hc, A_ST_RD_STATE))) {
 					if (debug & DEBUG_HFCMULTI_STATE)
@@ -2572,6 +2786,12 @@ ph_state_irq(struct hfc_multi *hc, u_cha
 						    __func__, temp,
 						    st_status);
--
 				while (dch->state != (temp =
 					HFC_inb_nodebug(hc, R_E1_RD_STA))) {
 					if (debug & DEBUG_HFCMULTI_STATE)
@@ -2767,6 +2992,12 @@ hfcmulti_interrupt(int intno, void *dev_
 						    __func__, temp,
 						    dch->state);
--
 			while (pt) { /* release already registered ports */
 				pt--;
 				release_port(hc, hc->chan[(pt << 2) + 2].dch);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
 	while ((val & 1) && t) {
 		udelay(1);
 		t--;
 		val = isar->read_reg(isar->hw, ISAR_HIA);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-			while (l < (int)len) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (l < (int)len) {
 				hex_dump_to_buffer(msg + l, len - l, 32, 1,
 					isar->log, 256, 1);
 				pr_debug("%s: %s %02x: %s\n", isar->name,
 					__func__, l, isar->log);
 				l += 32;
--
-			while (l < (int)isar->clsb) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (l < (int)isar->clsb) {
 				hex_dump_to_buffer(msg + l, isar->clsb - l, 32,
 					1, isar->log, 256, 1);
 				pr_debug("%s: %s %02x: %s\n", isar->name,
 					__func__, l, isar->log);
 				l += 32;
--
 	while (t && !(irq & ISAR_IRQSTA)) {
 		udelay(1);
 		t--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cnt < size) {
 		blk_head.sadr = le16_to_cpu(*sp++);
 		blk_head.len = le16_to_cpu(*sp++);
@@ -262,11 +311,22 @@ load_firmware(struct isar_hw *isar, cons
 			pr_debug("%s: load %3d words at %04x\n", isar->name,
 				noc, blk_head.sadr);
--
 			while (noc) {
 				val = le16_to_cpu(*sp++);
 				*mp++ = val >> 8;
 				*mp++ = val & 0xFF;
 				noc--;
+				if (_cur < timeout) {
--
 	while ((!isar->bstat) && cnt) {
 		mdelay(1);
 		cnt--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 		while (ista && cnt--) {
 			pr_debug("%s: ISTA %02x\n", ipac->name, ista);
 			if (ista & IPACX__ICA)
@@ -1165,9 +1170,20 @@ mISDNipac_irq(struct ipac_hw *ipac, int
 			if (ista & (ISACX__ICD | ISACX__CIC))
 				mISDNisac_irq(&ipac->isac, ista);
--
 		while (ista && cnt--) {
 			pr_debug("%s: ISTA %02x\n", ipac->name, ista);
 			if (ista & (IPAC__ICD | IPAC__EXD)) {
@@ -1184,6 +1200,12 @@ mISDNipac_irq(struct ipac_hw *ipac, int
 			if (ista & (IPAC__ICB | IPAC__EXB))
 				ipac_irq(&ipac->hscx[1], ista);
--
 		while (cnt) {
diff -u -p a/isdn/hardware/mISDN/hfcpci.c b/isdn/hardware/mISDN/hfcpci.c
--- a/isdn/hardware/mISDN/hfcpci.c
+++ b/isdn/hardware/mISDN/hfcpci.c
@@ -1768,7 +1768,12 @@ init_card(struct hfc_pci *hc)
 	}
--
-	while (cnt) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt) {
 		inithfcpci(hc);
 		/*
 		 * Finally enable IRQ output
@@ -1803,6 +1808,12 @@ init_card(struct hfc_pci *hc)
 			hc->initdone = 1;
--
 		while (fs->state != available) {
 			spin_unlock_irqrestore(&swim3_lock, flags);
 			if (interruptible && signal_pending(current)) {
@@ -848,6 +853,12 @@ static int grab_drive(struct floppy_stat
 			}
 			interruptible_sleep_on(&fs->wait);
--
 	while (time_before(jiffies, expire)) {
 		if (gpio_get_value(rstout) == 1)
 			return MG_ERR_NONE;
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&sc->luns)) {
 		p = sc->luns.next;
 		lun = list_entry(p, struct ub_lun, link);
@@ -532,6 +537,12 @@ static void ub_cleanup(struct ub_dev *sc
 
 		ub_id_put(lun->id);
--
 	while (req) {
 		unsigned block = blk_rq_pos(req);
 		unsigned count = blk_rq_cur_sectors(req);
@@ -335,6 +340,12 @@ static void do_xd_request (struct reques
 		/* wrap up, 0 = success, -errno = fail */
 		if (!__blk_end_request_cur(req, res))
--
 	while (count) {
 		temp = count < xd_maxsectors ? count : xd_maxsectors;
 
@@ -464,6 +480,12 @@ static int xd_readwrite (u_char operatio
 				buffer[i] = xd_dma_buffer[i];
 
--
 	while (!complete) {
 		if (xd_waitport(XD_STATUS,STAT_READY,STAT_READY,timeout))
 			return (1);
@@ -623,6 +650,12 @@ static u_int xd_command (u_char *command
 				complete = 1;
 				break;
--
 			while (min[i] != max[i] - 1) {
 				test[i] = (min[i] + max[i]) / 2;
 				xd_build(cmdblk,CMD_SEEK,drive,(u_char) test[0],(u_short) test[1],(u_char) test[2],0,0);
@@ -1011,6 +1049,12 @@ static void __init xd_override_init_driv
 					min[i] = test[i];
 				else
--
 	while (chain) {
 		tmp = chain;
 		chain = chain->bi_next;
 
 		bio_put(tmp);
+		if (_cur < timeout) {
--
 	while (old_chain) {
 		tmp = bio_kmalloc(gfpmask, old_chain->bi_max_vecs);
 		if (!tmp)
@@ -283,6 +299,12 @@ static struct bio *bio_chain_clone(struc
 		}
 
--
 	while (i < ccissscsi[h->ctlr].ndevices) {
 		csd = &ccissscsi[h->ctlr].dev[i];
 		found=0;
@@ -598,6 +603,12 @@ adjust_cciss_scsi_table(ctlr_info_t *h,
 				sizeof(csd->revision));
 		} else 		/* device is same as it ever was, */
--
 	while (1) {
 		enum action res;
 		unsigned long saved_flags;
@@ -429,6 +434,12 @@ static void run_fsm(void)
 				pi_disconnect(pi_current);
 				pd_claimed = 0;
--
 			while(count)
 			{
 				u8 d;
@@ -407,6 +412,12 @@ static void ppc6_rd_data_blk(Interface *
 
 				*data++ = d;
--
 			while(count)
 			{
 				ppc->cur_ctrl ^= data_stb;
@@ -429,6 +445,12 @@ static void ppc6_rd_data_blk(Interface *
 
 				*data++ = inb(ppc->lpt_addr);
--
 			while(count)
 			{
 				*data++ = inb(ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(count)
 			{
 				*data++ = inb(ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(count)
 			{
 				*data++ = inb(ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(count--)
 			{
 				outb(*data++, ppc->lpt_addr);
@@ -539,6 +599,12 @@ static void ppc6_wr_data_blk(Interface *
 				ppc->cur_ctrl ^= data_stb;
 
--
 			while(count)
 			{
 				this = *data++;
@@ -576,6 +647,12 @@ static void ppc6_wr_data_blk(Interface *
 
 					last = this;
--
 			while(count)
 			{
 				outb(*data++,ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(count)
 			{
 				outb(*data++,ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(count)
 			{
 				outb(*data++,ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while ((((r = status_reg(dev)) & go) || (stop && (!(r & stop))))
 	       && time_before(jiffies, tmo)) {
 		if (j++ < PG_SPIN)
 			udelay(PG_SPIN_DEL);
 		else
 			pg_sleep(1);
--
 	while (read_reg(dev, 7) & STAT_DRQ) {
 		d = (read_reg(dev, 4) + 256 * read_reg(dev, 5));
 		n = ((d + 3) & 0xfffc);
@@ -376,6 +392,12 @@ static int pg_completion(struct pg *dev,
 		buf += d;
 		r = pg_wait(dev, STAT_BUSY, STAT_DRQ | STAT_READY | STAT_ERR,
--
 	while (k < tmo) {
 		cd->last_sense = 0;
 		pcd_atapi(cd, tr_cmd, 0, NULL, DBMSG("test unit ready"));
@@ -589,6 +594,12 @@ static int pcd_ready_wait(struct pcd_uni
 			return p;
 		k++;
--
 	while (1) {
 		if (!pcd_req) {
 			pcd_req = blk_fetch_request(q);
@@ -756,6 +772,12 @@ static void do_pcd_request(struct reques
 			__blk_end_request_all(pcd_req, -EIO);
 			pcd_req = NULL;
--
 	while (pcd_count && (pcd_sector / 4 == pcd_bufblk)) {
 		int o = (pcd_sector % 4) * 512;
 		memcpy(pcd_buf, pcd_buffer + o, 512);
 		pcd_count--;
 		pcd_buf += 512;
 		pcd_sector++;
--
-	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
 
 		wait_event_interruptible(lo->lo_event,
 				!bio_list_empty(&lo->lo_bio_list) ||
@@ -549,6 +554,12 @@ static int loop_thread(void *data)
 
--
 	while (is_loop_device(f)) {
 		struct loop_device *l;
 
@@ -840,6 +856,12 @@ static int loop_set_fd(struct loop_devic
 			goto out_putf;
 		}
--
 	while (left) {
 		sz = (left > ioc->malloc_size) ? ioc->malloc_size : left;
 		buff_size[sg_used] = sz;
@@ -1631,6 +1636,12 @@ static int cciss_bigpassthru(ctlr_info_t
 		left -= sz;
 		data_ptr += sz;
--
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
 		while (raw_tag != FIFO_EMPTY)
 			raw_tag = next_command(h);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
 		while (raw_tag != FIFO_EMPTY) {
@@ -3610,6 +3637,12 @@ static irqreturn_t do_cciss_intx(int irq
 			else
 				raw_tag = process_nonindexed_cmd(h, raw_tag);
 		}
+		if (_cur < timeout) {
--
 	while (req) {
 		int err = -EIO;
 
@@ -556,6 +561,12 @@ static void redo_fd_request(struct reque
 	done:
 		if (!__blk_end_request_cur(req, err))
--
 	while (*p) {
 		parent = *p;
 		tmp = rb_entry(parent, struct pkt_rb_node, rb_node);
@@ -724,6 +729,12 @@ static void pkt_rbtree_insert(struct pkt
 			p = &(*p)->rb_left;
 		else
--
 	while (node) {
 		bio = node->bio;
 		zone = ZONE(bio->bi_sector, pd);
@@ -1301,6 +1317,12 @@ try_next_bio:
 		}
 		if (node == first_node)
--
 			while (src_offs >= src_bvl->bv_len) {
 				src_offs -= src_bvl->bv_len;
 				segment++;
 				BUG_ON(segment >= bio->bi_vcnt);
 				src_bvl = bio_iovec_idx(bio, segment);
+				if (_cur < timeout) {
--
 	while (!list_empty(head)) {
 		prepare_to_wait(&mdev->ee_wait, &wait, TASK_UNINTERRUPTIBLE);
 		spin_unlock_irq(&mdev->req_lock);
 		io_schedule();
 		finish_wait(&mdev->ee_wait, &wait);
 		spin_lock_irq(&mdev->req_lock);
--
 	while (bios) {
 		bio = bios;
 		bios = bios->bi_next;
 		bio_put(bio);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (get_t_state(&mdev->receiver) == Running) {
 		drbd_thread_current_set_cpu(mdev);
 		if (!drbd_recv_header(mdev, &cmd, &packet_size))
@@ -3714,6 +3741,12 @@ static void drbdd(struct drbd_conf *mdev
 			    cmdname(cmd), packet_size);
 			goto err_out;
--
 	while (drbd_pp_pool) {
 		page = drbd_pp_pool;
 		drbd_pp_pool = (struct page *)page_private(page);
 		__free_page(page);
 		drbd_pp_vacant--;
+		if (_cur < timeout) {
--
 	while (try++ < max_tries) {
 		rv = _drbd_request_state(mdev, mask, val, CS_WAIT_COMPLETE);
 
@@ -391,6 +396,12 @@ drbd_set_role(struct drbd_conf *mdev, en
 				goto fail;
 		}
--
 	while (offset < end) {
 		do_now = min_t(size_t, ALIGN(offset + 1, LWPP), end) - offset;
 		idx = bm_word_to_page_idx(b, offset);
@@ -590,6 +595,12 @@ static void bm_memset(struct drbd_bitmap
 		bm_unmap(p_addr);
 		bm_set_page_need_writeout(b->bm_pages[idx]);
--
 	while ((tmp = page_chain_next(page))) {
 		/* all but the last page will be fully used */
 		sg_set_page(&sg, page, PAGE_SIZE, 0);
 		crypto_hash_update(&desc, &sg, sg.length);
 		page = tmp;
+		if (_cur < timeout) {
--
 	while (1) {
 		if (odev == mdev)
 			return ERR_SYNC_AFTER_CYCLE;
@@ -1432,6 +1448,12 @@ static int sync_after_error(struct drbd_
 
 		/* follow the dependency chain */
--
 	while (req) {
 		unsigned long start = blk_rq_pos(req) << 9;
 		unsigned long len  = blk_rq_cur_bytes(req);
@@ -87,6 +92,11 @@ static void do_z2_request(struct request
 			err = -EIO;
 			goto done;
--
 		while (len) {
 			unsigned long addr = start & Z2RAM_CHUNKMASK;
 			unsigned long size = Z2RAM_CHUNKSIZE - addr;
@@ -99,10 +109,22 @@ static void do_z2_request(struct request
 				memcpy((char *)addr, req->buffer, size);
 			start += size;
--
 		while (size) {
 			z2ram_map[ z2ram_size++ ] = vaddr;
 			size -= Z2RAM_CHUNKSIZE;
 			vaddr += Z2RAM_CHUNKSIZE;
 			list_count++;
+			if (_cur < timeout) {
--
-	  while (DAC960_GEM_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_GEM_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_GEM_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2808,7 +2813,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_BA_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_BA_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_BA_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2838,7 +2854,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_LP_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_LP_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_LP_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2868,7 +2895,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_LA_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_LA_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_LA_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2898,7 +2936,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_PG_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_PG_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_PG_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2930,7 +2979,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_PD_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_PD_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_PD_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2968,7 +3028,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_PD_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_PD_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_PD_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -3004,7 +3075,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
    while(1) {
 	Request = blk_peek_request(req_q);
 	if (!Request)
@@ -3357,6 +3439,12 @@ static int DAC960_process_queue(DAC960_C
 		 Command->SegmentCount, Command->DmaDirection);
 
--
-  while (NextStatusMailbox->Fields.Valid)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (NextStatusMailbox->Fields.Valid)
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	NextStatusMailbox->Fields.CommandIdentifier;
@@ -5404,6 +5497,12 @@ static irqreturn_t DAC960_LA_InterruptHa
       if (++NextStatusMailbox > Controller->V1.LastStatusMailbox)
--
-  while (NextStatusMailbox->Fields.Valid)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (NextStatusMailbox->Fields.Valid)
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	NextStatusMailbox->Fields.CommandIdentifier;
@@ -5442,6 +5546,12 @@ static irqreturn_t DAC960_PG_InterruptHa
       if (++NextStatusMailbox > Controller->V1.LastStatusMailbox)
--
-  while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	DAC960_PD_ReadStatusCommandIdentifier(ControllerBaseAddress);
@@ -5477,6 +5592,12 @@ static irqreturn_t DAC960_PD_InterruptHa
       DAC960_PD_AcknowledgeInterrupt(ControllerBaseAddress);
--
-  while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	DAC960_PD_ReadStatusCommandIdentifier(ControllerBaseAddress);
@@ -5550,6 +5676,12 @@ static irqreturn_t DAC960_P_InterruptHan
 	  break;
--
-	  while (Controller->V2.NewControllerInformation->PhysicalScanActive)
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (Controller->V2.NewControllerInformation->PhysicalScanActive)
 	    {
 	      DAC960_ExecuteCommand(Command);
 	      sleep_on_timeout(&Controller->CommandWaitQueue, HZ);
+	      if (_cur < timeout) {
+					rdstcll(_cur);
--
 	    while ((Command = DAC960_AllocateCommand(Controller)) == NULL)
 	      DAC960_WaitForCommand(Controller);
-	    while (Controller->V1.DirectCommandActive[DCDB.Channel]
+	    unsigned long long delta = (cpu / khz / HZ) * 2;
+	    unsigned long long _start = 0;
+	    unsigned long long _cur = 0;
+	      unsigned long long timeout;
+	      timeout = rdstcll(start) + delta;
+	      while (Controller->V1.DirectCommandActive[DCDB.Channel]
 						     [DCDB.TargetID])
 	      {
 		spin_unlock_irq(&Controller->queue_lock);
@@ -6774,6 +6922,12 @@ static long DAC960_gam_ioctl(struct file
 			     !Controller->V1.DirectCommandActive
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		if (try_to_freeze())
 			continue;
 		if (unlikely(vbd->size != vbd_sz(vbd)))
@@ -307,6 +312,12 @@ int xen_blkif_schedule(void *arg)
 
--
 	while (1) {
 		u32 status = le32_to_cpu(resp[idx].status);
 
@@ -1191,6 +1196,12 @@ static inline void carm_handle_responses
 
 		idx = NEXT_RESP(idx);
--
 	while (!list_empty(&d->bufq)) {
 		buf = container_of(d->bufq.next, struct buf, bufs);
 		list_del(d->bufq.next);
 		bio = buf->bio;
 		mempool_free(buf, d->bufpool);
 		bio_endio(bio, -EIO);
--
 	while ((d = *dd)) {
 		spin_lock(&d->lock);
 		if ((!all && (d->flags & DEVFL_UP))
@@ -153,12 +169,29 @@ aoedev_flush(const char __user *str, siz
 		spin_unlock(&d->lock);
 		d->next = rmd;
--
 	while ((d = rmd)) {
 		rmd = d->next;
 		del_timer_sync(&d->timer);
 		aoedev_freedev(d);	/* must be able to sleep */
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((d = devlist)) {
 		devlist = d->next;
 
@@ -267,6 +305,12 @@ aoedev_exit(void)
 
 		del_timer_sync(&d->timer);
--
 	while (i--) {
 		struct request_queue *q = unit[i].disk->queue;
 
 		put_disk(unit[i].disk);
 		if (q)
 			blk_cleanup_queue(q);
--
 	while (chain) {
 		tmp = chain;
 		chain = chain->bi_next;
 		bio_put(tmp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (chain) {
 		bio_for_each_segment(bv, chain, i) {
 			if (pos + bv->bv_len > start_ofs) {
@@ -676,6 +692,12 @@ static void zero_bio_chain(struct bio *c
 		}
 
--
 	while (old_chain && (total < len)) {
 		tmp = bio_kmalloc(gfpmask, old_chain->bi_max_vecs);
 		if (!tmp)
@@ -739,6 +766,12 @@ static struct bio *bio_chain_clone(struc
 		old_chain = old_chain->bi_next;
 
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		int len = sizeof(*dh) +
 			  snap_count * sizeof(struct rbd_image_snap_ondisk) +
 			  snap_names_len;
@@ -1600,6 +1638,12 @@ static int rbd_read_header(struct rbd_de
 			continue;
--
 	while (!list_empty(&rbd_dev->snaps)) {
 		snap = list_first_entry(&rbd_dev->snaps, struct rbd_snap, node);
 		__rbd_remove_snap_dev(rbd_dev, snap);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (*name) {
 		if (name == start)
 			return start;
 		name--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (ace->id_req_count) {
 			complete(&ace->id_completion);
 			ace->id_req_count--;
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (ace->id_req_count) {
 			complete(&ace->id_completion);
 			ace->id_req_count--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (1) {
 		if (probed_format >= 8 || !DP->autodetect[probed_format]) {
 			DRS->probed_format = 0;
@@ -2026,6 +2031,12 @@ static int next_valid_format(void)
 			return 0;
 		}
--
 		while (tracksize <= fsector_t % _floppy->sect) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (tracksize + ssize > _floppy->sect) {
 				SIZECODE--;
 				ssize >>= 1;
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
--
 	while (ptr) {
 		struct floppy_raw_cmd cmd = *ptr;
 		cmd.next = NULL;
@@ -3078,6 +3116,12 @@ static int raw_cmd_copyout(int cmd, void
 			}
 		}
--
-	while (this) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (this) {
 		if (this->buffer_length) {
 			fd_dma_mem_free((unsigned long)this->kernel_data,
 					this->buffer_length);
@@ -3099,6 +3148,12 @@ static void raw_cmd_free(struct floppy_r
 		next = this->next;
--
 	while (drive--) {
 		if ((allowed_drive_mask & (1 << drive)) &&
 		    fdc_state[FDC(drive)].version != FDC_NONE) {
@@ -4334,7 +4394,13 @@ out_remove_drives:
 			device_remove_file(&floppy_device[drive].dev, &dev_attr_cmos);
 			platform_device_unregister(&floppy_device[drive]);
--
 	while (dr--) {
 		del_timer_sync(&motor_off_timer[dr]);
 		if (disks[dr]->queue) {
@@ -4356,6 +4427,12 @@ out_put_disk:
 			disks[dr]->queue = NULL;
 		}
--
 	while (p != io_regions) {
 		p--;
 		release_region(FDCS->address + p->offset, p->size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (*cfg) {
 		ptr = cfg;
 		while (*cfg && *cfg != ' ' && *cfg != '\t')
@@ -4534,6 +4627,12 @@ static void __init parse_floppy_cfg_stri
 		}
 		if (*ptr)
 			floppy_setup(ptr);
+			if (_cur < timeout) {
--
 	while (count) {
 		unsigned int offset, avail;
 		unsigned int entry;
@@ -466,6 +471,12 @@ static int ps3vram_read(struct ps3_syste
 		buf += avail;
 		count -= avail;
--
 	while (count) {
 		unsigned int offset, avail;
 		unsigned int entry;
@@ -509,6 +525,12 @@ static int ps3vram_write(struct ps3_syst
 		buf += avail;
 		count -= avail;
--
 	while(c && c != h->reqQ) {
 		seq_printf(m, "->%p", c);
 		c=c->next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while(c && c != h->cmpQ) {
 		seq_printf(m, "->%p", c);
 		c=c->next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (j--) {
 		put_disk(ida_gendisk[i][j]);
 		ida_gendisk[i][j] = NULL;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 		while((a = h->access.command_completed(h))) {
 			a1 = a; a &= ~3;
 			if ((c = h->cmpQ) == NULL)
@@ -1096,6 +1134,12 @@ static irqreturn_t do_ida_intr(int irq,
 				}
 				continue;
--
 	while (return_bio) {
 		struct bio *bio = return_bio;
 
 		return_bio = bio->bi_next;
 		bio->bi_next = NULL;
 		bio_endio(bio, 0);
--
-	while (!list_empty(&lo->queue_head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&lo->queue_head)) {
 		req = list_entry(lo->queue_head.next, struct request,
 				 queuelist);
 		list_del_init(&req->queuelist);
 		req->errors++;
 		nbd_end_request(req);
--
-	while (!list_empty(&lo->waiting_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&lo->waiting_queue)) {
 		req = list_entry(lo->waiting_queue.next, struct request,
 				 queuelist);
 		list_del_init(&req->queuelist);
 		req->errors++;
 		nbd_end_request(req);
--
-	while (!kthread_should_stop() || !list_empty(&lo->waiting_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop() || !list_empty(&lo->waiting_queue)) {
 		/* wait for something to do */
 		wait_event_interruptible(lo->waiting_wq,
 					 kthread_should_stop() ||
@@ -528,6 +555,12 @@ static int nbd_thread(void *data)
 
--
 	while (i--) {
 		blk_cleanup_queue(nbd_dev[i].disk->queue);
 		put_disk(nbd_dev[i].disk);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (pulses--) {
 		gpio_set_value_cansleep(led_dat->gpio, 0);
 		udelay(1);
 		gpio_set_value_cansleep(led_dat->gpio, 1);
 		udelay(1);
+		if (_cur < timeout) {
--
 	while (i--) {
 		led_classdev_unregister(&pca955x[i].led_cdev);
 		cancel_work_sync(&pca955x[i].work);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 		while (1) {
 			buf = skip_spaces(buf);
 			if (!strnicmp(buf, "io", 2)) {
@@ -393,6 +398,12 @@ static ssize_t pnp_set_current_resources
 				continue;
 			}
--
 	while (pos) {
 		str += sprintf(str, "%s\n", pos->id);
 		pos = pos->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (pos) {
 		if (memcmp(pos->id, id, 3) == 0)
 			if (compare_func(pos->id, id) == 1)
 				return 1;
 		pos = pos->next;
+		if (_cur < timeout) {
--
 	while (*drv_id->id) {
 		if (compare_pnp_id(dev->id, drv_id->id))
 			return drv_id;
 		drv_id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (new_option && pnp_option_set(new_option) == set) {
 			if (new_option->type == IORESOURCE_IRQ) {
 				irq = &new_option->u.irq;
@@ -197,6 +202,12 @@ static void quirk_add_irq_optional_depen
 			dbg_pnp_show_option(dev, new_option);
 			new_option = list_entry(new_option->list.next,
--
 	while (!pnp_check_port(dev, res)) {
 		res->start += rule->align;
 		res->end = res->start + rule->size - 1;
@@ -54,6 +59,12 @@ static int pnp_assign_port(struct pnp_de
 				(unsigned long long) rule->max);
 			return -EBUSY;
--
 	while (!pnp_check_mem(dev, res)) {
 		res->start += rule->align;
 		res->end = res->start + rule->size - 1;
@@ -106,6 +122,12 @@ static int pnp_assign_mem(struct pnp_dev
 				(unsigned long long) rule->max);
 			return -EBUSY;
--
 	while (1) {
 		int status;
 
@@ -196,6 +201,12 @@ static int pnp_dock_thread(void *unused)
 #endif
 			}
--
 	while ((char *)p < (char *)end) {
 		if (p[0] & 0x80) {	/* large tag */
 			len = (p[2] << 8) | p[1];
@@ -272,6 +288,12 @@ static void pnpbios_zero_data_stream(str
 		for (i = 0; i < len; i++)
 			p[i] = 0;
--
 	while (*drv_id->id) {
 		if (compare_pnp_id(card->id, drv_id->id)) {
 			int i = 0;
@@ -44,6 +49,12 @@ static const struct pnp_card_device_id *
 			}
 		}
--
 	while (id) {
 		next = id->next;
 		kfree(id);
 		id = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (pos) {
 		str += sprintf(str, "%s\n", pos->id);
 		pos = pos->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (pos != &card->devices) {
 		dev = card_to_pnp_dev(pos);
 		if ((!dev->card_link) && compare_pnp_id(dev->id, id))
 			goto found;
 		pos = pos->next;
+		if (_cur < timeout) {
--
-	while (i < res_cnt) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < res_cnt) {
 		switch (resource->type) {
 		case ACPI_RESOURCE_TYPE_IRQ:
 			pnpacpi_encode_irq(dev, resource,
@@ -1156,6 +1161,12 @@ int pnpacpi_encode_resources(struct pnp_
 		}
--
 	while (id) {
 		next = id->next;
 		kfree(id);
 		id = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (list != &pnp_cards) {
 		struct pnp_card *card = global_to_pnp_card(list);
 
 		if (compare_pnp_id(card->id, id) || (memcmp(id, any, 7) == 0))
 			return card;
 		list = list->next;
--
 		while (list != &pnp_global) {
 			struct pnp_dev *dev = global_to_pnp_dev(list);
 
@@ -64,6 +80,12 @@ struct pnp_dev *pnp_find_dev(struct pnp_
 			    (memcmp(id, any, 7) == 0))
 				return dev;
--
 		while (list != &card->devices) {
 			struct pnp_dev *dev = card_to_pnp_dev(list);
 
 			if (compare_pnp_id(dev->id, id))
 				return dev;
 			list = list->next;
--
 		while (len) {
 			sys = set_cis_map(s, card_offset, flags);
 			if (!sys) {
@@ -196,6 +201,12 @@ int pcmcia_read_cis_mem(struct pcmcia_so
 			}
 			card_offset += s->map_size;
--
 		while (len) {
 			sys = set_cis_map(s, card_offset, flags);
 			if (!sys) {
@@ -270,6 +286,12 @@ int pcmcia_write_cis_mem(struct pcmcia_s
 			}
 			card_offset += s->map_size;
--
 			while (*p & 0x80) {
 				if (++p == q)
 					return NULL;
@@ -933,6 +960,12 @@ static u_char *parse_power(u_char *p, u_
 					pwr->flags |= CISTPL_POWER_HIGHZ_REQ;
 				else
--
 		while (e->regbit) {
 			if (pscr & e->regbit)
 				events |= e->eventbit;
 
 			e++;
+			if (_cur < timeout) {
--
 			while (nmemb--) {
 				writeb(*bp++, addr);
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
--
 			while (nmemb--) {
 	    		*bp++ = readb(addr);
+	    		if (_cur < timeout) {
+		rdstcll(_cur);
+	    		}
+	    		else {
--
-			while (nmemb--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (nmemb--) {
 #ifdef PCC_DEBUG_DBEX
 				if (_dbex) {
 					unsigned char *cp = (unsigned char *)bp;
@@ -191,10 +218,21 @@ void pcc_iorw(int sock, unsigned long po
 				} else
--
-	    	while (nmemb--) {
+	    	unsigned long long delta = (cpu / khz / HZ) * 2;
+	    	unsigned long long _start = 0;
+	    	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (nmemb--) {
 #ifdef  PCC_DEBUG_DBEX
 				if (_dbex) {
 					unsigned char *cp = (unsigned char *)bp;
@@ -206,6 +244,12 @@ void pcc_iorw(int sock, unsigned long po
 				} else
--
 	while (did && did->match_flags) {
 		for (i = 0; i < 4; i++) {
 			if (!did->prod_id[i])
@@ -71,6 +76,12 @@ static void pcmcia_check_driver(struct p
 				"details\n");
 		}
--
 	while (did && did->match_flags) {
 		dev_dbg(dev, "trying to match to %s\n", drv->name);
 		if (pcmcia_devmatch(p_dev, did)) {
@@ -912,6 +928,12 @@ static int pcmcia_bus_match(struct devic
 			return 1;
 		}
--
 	while (!gpio_get_value(GPIO_NR_PALMTC_PCMCIA_PWRREADY) &&
 		timeout) {
 		mdelay(1);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (__raw_readl(&rtcreg->ctl) & TX4939_RTCCTL_BUSY) {
 		/* timeout on approx. 100us (@ GBUS200MHz) */
 		if (i++ > 200 * 100)
 			return -EBUSY;
 		cpu_relax();
+		if (_cur < timeout) {
--
 	while (secs != secs2 && --timeout) {
 		secs = secs2;
 		secs2 = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
@@ -89,10 +89,21 @@ static int tegra_rtc_wait_while_busy(str
 
 	/* first wait for the RTC to become busy. this is when it
 	 * posts its updated seconds+msec registers to AHB side. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
--
 	while (tegra_rtc_check_busy(info)) {
 		if (!retries--)
 			goto retry_failed;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((msm6242_read(priv, MSM6242_CD) & MSM6242_CD_BUSY) && cnt) {
 		msm6242_clear(priv, MSM6242_CD_HOLD, MSM6242_CD);
 		udelay(70);
 		msm6242_set(priv, MSM6242_CD_HOLD, MSM6242_CD);
 		cnt--;
+		if (_cur < timeout) {
--
 	while (*p) {
 		struct daisydev *dev = *p;
 		if (dev->port != port) {
@@ -186,6 +191,12 @@ void parport_daisy_fini(struct parport *
 		}
 		*p = dev->next;
--
 	while (p) {
 		char *sep;
 		q = strchr(p, ';');
@@ -74,9 +79,20 @@ static void parse_data(struct parport *p
 			while (u >= p && *u == ' ')
 				*u-- = '\0';
 			u = p;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
--
 			while (*u) {
 				*u = toupper(*u);
 				u++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (time_before (jiffies, deadline)) {
 		if (signal_pending (current))
 			return -EINTR;
@@ -217,6 +222,12 @@ int parport_wait_peripheral(struct parpo
 			 * Wait for another 10ms. */
 			schedule_timeout_interruptible(msecs_to_jiffies(10));
--
 	while (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {
 		uiomem->size = 0;
 		++uiomem;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {
 		uiomem->size = 0;
 		++uiomem;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (atomic_read(&dev->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&dev->refcnt)) {
 		printk(KERN_INFO "Waiting for %s to become free: refcnt=%d.\n",
 		       dev->name, atomic_read(&dev->refcnt));
 		msleep(1000);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (head != tail) {
 		iommu_print_event(iommu, iommu->evt_buf + head);
 		head = (head + EVENT_ENTRY_SIZE) % iommu->evt_buf_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (level > end_lvl) {
 		if (!IOMMU_PTE_PRESENT(*pte)) {
 			page = (u64 *)get_zeroed_page(gfp);
@@ -944,6 +960,12 @@ static u64 *alloc_pte(struct protection_
 			*pte_page = pte;
 
--
-		while (*entry) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (*entry) {
 			struct iova *this = container_of(*entry,
 							struct iova, node);
 			parent = *entry;
@@ -161,6 +166,12 @@ move_left:
 				entry = &((*entry)->rb_right);
--
 	while (*new) {
 		struct iova *this = container_of(*new, struct iova, node);
 		parent = *new;
@@ -190,6 +206,12 @@ iova_insert_rbtree(struct rb_root *root,
 			new = &((*new)->rb_right);
 		else
--
 	while (node) {
 		struct iova *iova = container_of(node, struct iova, node);
 
@@ -270,6 +297,12 @@ struct iova *find_iova(struct iova_domai
 			node = node->rb_left;
 		else if (pfn > iova->pfn_lo)
--
 	while (node) {
 		struct iova *iova = container_of(node, struct iova, node);
 		rb_erase(node, &iovad->rbroot);
 		free_iova_mem(iova);
 		node = rb_first(&iovad->rbroot);
+		if (_cur < timeout) {
--
 	while (*str) {
 		if (!strncmp(str, "on", 2)) {
 			dmar_disabled = 0;
@@ -454,6 +459,12 @@ static int __init intel_iommu_setup(char
 		str += strcspn(str, ",");
 		while (*str == ',')
 			str++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
--
-	while (parent != tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (parent != tmp) {
 		ret = domain_context_mapping_one(domain,
 						 pci_domain_nr(parent->bus),
 						 parent->bus->number,
@@ -1671,6 +1687,12 @@ domain_context_mapping(struct dmar_domai
 		if (ret)
--
-	while (parent != tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (parent != tmp) {
 		ret = device_context_mapped(iommu, parent->bus->number,
 					    parent->devfn);
 		if (!ret)
 			return ret;
 		parent = parent->bus->self;
--
-	while (!list_empty(&domain->devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&domain->devices)) {
 		info = list_entry(domain->devices.next,
 			struct device_domain_info, link);
 		list_del(&info->link);
@@ -1910,6 +1948,12 @@ static void domain_remove_dev_info(struc
 		free_devinfo_mem(info);
--
-		while (parent != tmp) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (parent != tmp) {
 			iommu_detach_dev(iommu, parent->bus->number,
 					 parent->devfn);
 			parent = parent->bus->self;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&domain->devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&domain->devices)) {
 		info = list_entry(domain->devices.next,
 			struct device_domain_info, link);
 		list_del(&info->link);
@@ -3828,6 +3888,12 @@ static void vm_domain_remove_all_dev_inf
 
--
 	while (iommu->agaw < dmar_domain->agaw) {
 		struct dma_pte *pte;
 
@@ -4011,6 +4082,12 @@ static int intel_iommu_attach_device(str
 			free_pgtable_page(pte);
 		}
--
 	while (start < end) {
 		scope = start;
 		if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_ENDPOINT ||
@@ -137,6 +142,12 @@ int __init dmar_parse_dev_scope(void *st
 			       "Unsupported device scope\n");
 		}
--
 	while (start < end) {
 		scope = start;
 		if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_ENDPOINT ||
@@ -160,6 +176,12 @@ int __init dmar_parse_dev_scope(void *st
 			index ++;
 		}
--
 	while (dev) {
 		for (index = 0; index < cnt; index++)
 			if (dev == devices[index])
@@ -394,6 +421,12 @@ static int dmar_pci_device_match(struct
 
 		/* Check our parent */
--
-	while (((unsigned long)entry_header) <
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (((unsigned long)entry_header) <
 			(((unsigned long)dmar) + dmar_tbl->length)) {
 		/* Avoid looping forever on bad ACPI tables */
 		if (entry_header->length == 0) {
@@ -536,6 +574,12 @@ int __init check_zero_address(void)
 		}
--
-	while (p < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (p < end) {
 		dev = (struct ivhd_entry *)p;
 		switch (dev->type) {
 		case IVHD_DEV_SELECT:
@@ -428,6 +433,12 @@ static int __init find_last_devid_from_i
 			break;
--
-	while (p < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (p < end) {
 		h = (struct ivhd_header *)p;
 		switch (h->type) {
 		case ACPI_IVHD_TYPE:
@@ -471,6 +487,12 @@ static int __init find_last_devid_acpi(s
 			break;
--
 	while (p < end) {
 		e = (struct ivhd_entry *)p;
 		switch (e->type) {
@@ -883,6 +910,12 @@ static void __init init_iommu_from_acpi(
 		}
 
--
 	while (p < end) {
 		h = (struct ivhd_header *)p;
 		switch (*p) {
@@ -1051,6 +1089,12 @@ static int __init init_iommu_all(struct
 		}
 		p += h->length;
--
 	while (p < end) {
 		m = (struct ivmd_header *)p;
 		if (m->flags & IVMD_FLAG_EXCL_RANGE)
@@ -1215,6 +1264,12 @@ static int __init init_memory_definition
 			init_unity_map_range(m);
 
--
 	while (bytes) {
 		ent_sz = max_alignment(da | pa);
 		ent_sz = min_t(unsigned, ent_sz, iopgsz_max(bytes));
@@ -99,6 +104,12 @@ static unsigned sgtable_nents(size_t byt
 		da += ent_sz;
 		pa += ent_sz;
--
 	while (*str) {
 		if (!strncmp(str, "on", 2))
 			disable_intremap = 0;
@@ -48,6 +53,12 @@ static __init int setup_intremap(char *s
 		str += strcspn(str, ",");
 		while (*str == ',')
 			str++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (start < end) {
 		scope = start;
 		if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_IOAPIC) {
@@ -739,6 +755,12 @@ static int ir_parse_ioapic_hpet_scope(st
 			ir_parse_one_hpet_scope(scope, iommu);
 		}
--
 	while (!IsStatusReady(j)) {
 		ixj_perfmon(j->statuswait);
 		if (time_after(jiffies, jif)) {
 			ixj_perfmon(j->statuswaitfail);
 			return -1;
 		}
--
 	while (!IsPCControlReady(j)) {
 		ixj_perfmon(j->pcontrolwait);
 		if (time_after(jiffies, jif)) {
 			ixj_perfmon(j->pcontrolwaitfail);
 			return -1;
 		}
--
 	while (!IsControlReady(j)) {
 		ixj_perfmon(j->iscontrolready);
 		if (time_after(jiffies, jif)) {
@@ -1464,6 +1491,12 @@ static int ixj_WriteDSPCommand(unsigned
 			}
 			return -1;
--
 	while (len--)
 	{
 		*buff = table_ulaw2alaw[*(unsigned char *)buff];
 		buff++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
         while (len--)
         {
                 *buff = table_alaw2ulaw[*(unsigned char *)buff];
                 buff++;
+                if (_cur < timeout) {
+                	rdstcll(_cur);
--
 	while (!j->read_buffer_ready || (j->dtmf_state && j->flags.dtmf_oob)) {
 		++j->read_wait;
 		if (file_p->f_flags & O_NONBLOCK) {
@@ -2779,6 +2839,12 @@ static ssize_t ixj_read(struct file * fi
 			j->flags.inread = 0;
 			return -EINTR;
--
 	while (!j->write_buffers_empty) {
 		++j->write_wait;
 		if (file_p->f_flags & O_NONBLOCK) {
@@ -2860,6 +2931,12 @@ static ssize_t ixj_write(struct file *fi
 			j->flags.inwrite = 0;
 			return -EINTR;
--
 	while (mContinue) {
 		if ((pIn[1] & 0x03) == 0x01) {
 			pOut[0] = pIn[0];
@@ -5034,6 +5116,12 @@ static int ixj_daa_cid_read(IXJ *j)
 			mContinue = false;
 		}
--
 	while (ids->id) {
 		if (ids->id == dev->id.id)
 			return ids;
 
 		ids++;
+		if (_cur < timeout) {
--
 	while (mr && enum_id && *reg_idx < desc->hw.nr_mask_regs) {
 		mr = desc->hw.mask_regs + *reg_idx;
 
@@ -80,6 +85,12 @@ static unsigned int __init _intc_mask_da
 
 		*fld_idx = 0;
--
 	while (pr && enum_id && *reg_idx < desc->hw.nr_prio_regs) {
 		pr = desc->hw.prio_regs + *reg_idx;
 
@@ -149,6 +165,12 @@ static unsigned int __init _intc_prio_da
 
 		*fld_idx = 0;
--
 	while (!found) {
 		found = 1;
 
@@ -103,6 +108,12 @@ nv04_calc_arb(struct nv_fifo_info *fifo,
 
 		fifo->lwm = clwm;
--
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -1071,6 +1076,12 @@ nv04_graph_isr(struct drm_device *dev)
 				     "mthd 0x%04x data 0x%08x\n",
 				chid, subc, class, mthd, data);
--
 	while (!list_empty(&mem->regions)) {
 		this = list_first_entry(&mem->regions, struct nouveau_mm_node, rl_entry);
 
 		list_del(&this->rl_entry);
 		nouveau_mm_put(mm, this);
+		if (_cur < timeout) {
--
 		while (num) {
 			struct nouveau_gpuobj *pgt = vm->pgt[pde].obj[big];
 
@@ -64,6 +69,12 @@ nouveau_vm_map_at(struct nouveau_vma *vm
 			}
 
--
 	while (num) {
 		struct nouveau_gpuobj *pgt = vm->pgt[pde].obj[big];
 
@@ -107,6 +123,12 @@ nouveau_vm_map_sg(struct nouveau_vma *vm
 			pde++;
 			pte = 0;
--
 	while (num) {
 		struct nouveau_gpuobj *pgt = vm->pgt[pde].obj[big];
 
@@ -141,6 +168,12 @@ nouveau_vm_unmap_at(struct nouveau_vma *
 			pde++;
 			pte = 0;
--
 	while (chan->dma.ib_free < count) {
 		uint32_t get = nvchan_rd32(chan, 0x88);
 		if (get != prev_get) {
@@ -210,6 +215,12 @@ nv50_dma_push_wait(struct nouveau_channe
 		chan->dma.ib_free = get - chan->dma.ib_put;
 		if (chan->dma.ib_free <= 0)
--
 	while (parts) {
 		u32 psize = nv_rd32(dev, 0x11020c + (part++ * 0x1000));
 		if (psize == 0)
@@ -131,6 +136,12 @@ nvc0_vram_init(struct drm_device *dev)
 
 		NV_DEBUG(dev, "%d: mem_amount 0x%08x\n", part, psize);
--
 	while (mode->hdisplay) {
 		if (mode->hdisplay <= native->hdisplay &&
 		    mode->vdisplay <= native->vdisplay) {
@@ -597,6 +602,12 @@ nouveau_connector_scaler_modes_add(struc
 		}
 
--
 	while (dwords) {
 		int push = dwords > 2047 ? 2047 : dwords;
 
@@ -146,6 +151,12 @@ nvc0_fbcon_imageblit(struct fb_info *inf
 		BEGIN_NVC0(chan, 6, NvSub2D, 0x0860, push);
 		OUT_RINGp(chan, data, push);
--
 			while (lvsw != conf[0] || lpre != conf[1]) {
 				conf += dp->table[5];
 				if (conf >= last)
 					return -EINVAL;
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (mcnt--) {
 		u8 remaining = msg->len;
 		u8 *ptr = msg->buf;
 
-		while (remaining) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (remaining) {
 			u8 cnt = (remaining > 16) ? 16 : remaining;
 			u8 cmd;
 
@@ -716,9 +737,21 @@ nouveau_dp_i2c_xfer(struct i2c_adapter *
 
--
 	while (dwords) {
 		int push = dwords > 2047 ? 2047 : dwords;
 
@@ -146,6 +151,12 @@ nv50_fbcon_imageblit(struct fb_info *inf
 		BEGIN_RING(chan, NvSub2D, 0x40000860, push);
 		OUT_RINGp(chan, data, push);
--
-	while (nv_rd32(dev, 0x400700) & 2) {}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (nv_rd32(dev, 0x400700) & 2) {if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
--
 		while (!(ntpcv & (1 << 4))) {
 			ntpcv <<= 1;
 			shift++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((stat = nv_rd32(dev, 0x400100))) {
 		u64 inst = (u64)(nv_rd32(dev, 0x40032c) & 0x0fffffff) << 12;
 		u32 chid = nv50_graph_isr_chid(dev, inst);
@@ -974,6 +979,12 @@ nv50_graph_isr(struct drm_device *dev)
 				chid, inst, subc, class, mthd, data);
 			nv50_fb_vm_trap(dev, 1);
--
-	while (put != get) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (put != get) {
 		nv_wo32(cache, ptr + 0,
 			nv_rd32(dev, NV40_PFIFO_CACHE1_METHOD(get)));
 		nv_wo32(cache, ptr + 4,
 			nv_rd32(dev, NV40_PFIFO_CACHE1_DATA(get)));
 		get = (get + 1) & 0x1ff;
--
 	while (dsize) {
 		int iter_len = dsize > 128 ? 128 : dsize;
 
@@ -131,6 +136,12 @@ nv04_fbcon_imageblit(struct fb_info *inf
 		OUT_RINGp(chan, data, iter_len);
 		data += iter_len;
--
-	while ((table = ROM16(bios->data[bios->init_script_tbls_ptr + i]))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((table = ROM16(bios->data[bios->init_script_tbls_ptr + i]))) {
 		NV_INFO(bios->dev,
 			"Parsing VBIOS init table %d at offset 0x%04X\n",
 			i / 2, table);
@@ -3855,6 +3860,12 @@ parse_init_tables(struct nvbios *bios)
 
--
 	while (map->reg) {
 		if (map->type == type)
 			return map->reg;
 		map++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (entries--) {
 		if (entry[0] == id) {
 			bit->id = entry[0];
@@ -5498,6 +5525,12 @@ bit_table(struct drm_device *dev, u8 id,
 		}
 
--
 	while (page_count) {
 		int line_count = (page_count > 2047) ? 2047 : page_count;
 
@@ -508,6 +513,12 @@ nvc0_bo_move_m2mf(struct nouveau_channel
 		page_count -= line_count;
 		src_offset += (PAGE_SIZE * line_count);
--
 	while (length) {
 		u32 amount, stride, height;
 
@@ -598,6 +614,12 @@ nv50_bo_move_m2mf(struct nouveau_channel
 		length -= amount;
 		src_offset += amount;
--
-	while (page_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (page_count) {
 		int line_count = (page_count > 2047) ? 2047 : page_count;
 
 		ret = RING_SPACE(chan, 11);
@@ -653,6 +680,12 @@ nv04_bo_move_m2mf(struct nouveau_channel
 		page_count -= line_count;
--
 		while ((entry = nouveau_ramht_remove_entry(chan, 0))) {
 			nouveau_ramht_remove_hash(chan, entry->handle);
 			nouveau_gpuobj_ref(NULL, &entry->gpuobj);
 			kfree(entry);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -426,6 +431,12 @@ nv40_graph_isr(struct drm_device *dev)
 				     "class 0x%04x mthd 0x%04x data 0x%08x\n",
 				chid, inst, subc, class, mthd, data);
--
 	while (bf->name) {
 		if (value & bf->mask) {
 			printk(" %s", bf->name);
@@ -41,6 +46,12 @@ nouveau_bitfield_print(const struct nouv
 		}
 
--
 	while (en->name) {
 		if (en->value == value)
 			return en;
 		en++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (n < (d * 2)) {
 			n += (n / m);
 			m++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (cnt--) {
 		nv_wo32(pgt, pte + 0, lower_32_bits(phys));
 		nv_wo32(pgt, pte + 4, upper_32_bits(phys));
 		phys += next;
 		pte  += 8;
+		if (_cur < timeout) {
--
 	while (cnt--) {
 		u64 phys = nvc0_vm_addr(vma, *list++, mem->memtype, 5);
 		nv_wo32(pgt, pte + 0, lower_32_bits(phys));
 		nv_wo32(pgt, pte + 4, upper_32_bits(phys));
 		pte += 8;
+		if (_cur < timeout) {
--
 	while (cnt--) {
 		nv_wo32(pgt, pte + 0, 0x00000000);
 		nv_wo32(pgt, pte + 4, 0x00000000);
 		pte += 8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (vidmask) {
 		if (i > nr_vidtag) {
 			NV_DEBUG(dev, "vid bit %d unknown\n", i);
@@ -201,6 +206,12 @@ nouveau_volt_init(struct drm_device *dev
 
 		vidmask >>= 1;
--
 	while (units) {
 		u32 subp, unit = ffs(units) - 1;
 		for (subp = 0; subp < 2; subp++)
 			nvc0_mfb_subp_isr(dev, unit, subp);
 		units &= ~(1 << unit);
+		if (_cur < timeout) {
--
 	while (cnt) {
 		u32 offset_h = upper_32_bits(phys);
 		u32 offset_l = lower_32_bits(phys);
@@ -112,11 +117,28 @@ nv50_vm_map(struct nouveau_vma *vma, str
 			delta    += block << (vma->node->type - 3);
 		}
--
 		while (block) {
 			nv_wo32(pgt, pte + 0, offset_l);
 			nv_wo32(pgt, pte + 4, offset_h);
 			pte += 8;
 			block -= 8;
+			if (_cur < timeout) {
--
 	while (cnt--) {
 		u64 phys = nv50_vm_addr(vma, (u64)*list++, mem->memtype, 2);
 		nv_wo32(pgt, pte + 0, lower_32_bits(phys));
 		nv_wo32(pgt, pte + 4, upper_32_bits(phys));
 		pte += 8;
+		if (_cur < timeout) {
--
 	while (cnt--) {
 		nv_wo32(pgt, pte + 0, 0x00000000);
 		nv_wo32(pgt, pte + 4, 0x00000000);
 		pte += 8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -704,6 +709,12 @@ nv20_graph_isr(struct drm_device *dev)
 				     "mthd 0x%04x data 0x%08x\n",
 				chid, subc, class, mthd, data);
--
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -1120,6 +1125,12 @@ nv10_graph_isr(struct drm_device *dev)
 				     "mthd 0x%04x data 0x%08x\n",
 				chid, subc, class, mthd, data);
--
 		while (u) {
 			int i = ffs(u) - 1;
 			nvc0_fifo_isr_vm_fault(dev, i);
 			u &= ~(1 << i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (u) {
 			int i = ffs(u) - 1;
 			nvc0_fifo_isr_subfifo_intr(dev, i);
 			u &= ~(1 << i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (nvbe->nr_pages--) {
 			pci_unmap_page(dev->pdev, nvbe->pages[nvbe->nr_pages],
 				       PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (cnt--) {
 		nv_wo32(pgt, pte, (*list++ >> 7) | 1);
 		pte += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cnt--) {
 		nv_wo32(pgt, pte, 0x00000000);
 		pte += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cnt--) {
 		u32 addr = list ? (*list++ >> 12) : (dummy >> 12);
 		switch (pte++ & 0x3) {
@@ -262,6 +300,12 @@ nv44_sgdma_fill(struct nouveau_gpuobj *p
 			tmp[3] |= addr >> 15;
 			break;
--
 	while (entry->buf_count < count) {
 		buf = &entry->buflist[entry->buf_count];
 		buf->idx = dma->buf_count + entry->buf_count;
@@ -723,6 +728,12 @@ int drm_addbufs_agp(struct drm_device *
 		offset += alignment;
 		entry->buf_count++;
--
 	while (entry->buf_count < count) {
 
 		dmah = drm_pci_alloc(dev, PAGE_SIZE << page_order, 0x1000);
@@ -925,6 +941,12 @@ int drm_addbufs_pci(struct drm_device *
 				  entry->buf_count, buf->address);
 		}
--
 	while (entry->buf_count < count) {
 		buf = &entry->buflist[entry->buf_count];
 		buf->idx = dma->buf_count + entry->buf_count;
@@ -1090,6 +1117,12 @@ static int drm_addbufs_sg(struct drm_dev
 		offset += alignment;
 		entry->buf_count++;
--
 	while (entry->buf_count < count) {
 		buf = &entry->buflist[entry->buf_count];
 		buf->idx = dma->buf_count + entry->buf_count;
@@ -1247,6 +1285,12 @@ static int drm_addbufs_fb(struct drm_dev
 		offset += alignment;
 		entry->buf_count++;
--
 	while (num_desc--) {
 		if (descriptor_this_page-- == 0) {
 			cur_descriptor_page--;
@@ -81,6 +86,12 @@ via_unmap_blit_from_device(struct pci_de
 		dma_unmap_page(&pdev->dev, desc_ptr->mem_addr, desc_ptr->size, vsg->direction);
 		next = (dma_addr_t) desc_ptr->next;
--
 	while (blitq->serviced != blitq->cur) {
 
 		cur_released = blitq->serviced++;
@@ -527,6 +543,12 @@ via_dmablit_workqueue(struct work_struct
 		kfree(cur_sg);
 
--
 	while (rptr != wptr) {
 		/* wptr/rptr are in bytes! */
 		ring_index = rptr / 4;
@@ -3033,6 +3038,12 @@ restart_ih:
 		/* wptr/rptr are in bytes! */
 		rptr += 16;
--
 	/* make sure wptr hasn't changed while processing */
 	wptr = evergreen_get_ih_wptr(rdev);
diff -u -p a/gpu/drm/radeon/rs600.c b/gpu/drm/radeon/rs600.c
--- a/gpu/drm/radeon/rs600.c
+++ b/gpu/drm/radeon/rs600.c
@@ -639,6 +639,11 @@ int rs600_irq_process(struct radeon_devi
--
 	while (status || rdev->irq.stat_regs.r500.disp_int) {
 		/* SW interrupt */
 		if (G_000044_SW_INT(status)) {
@@ -678,6 +683,12 @@ int rs600_irq_process(struct radeon_devi
 			DRM_DEBUG("HPD2\n");
 		}
--
 	while (status) {
 		/* SW interrupt */
 		if (status & RADEON_SW_INT_TEST) {
@@ -775,6 +780,12 @@ int r100_irq_process(struct radeon_devic
 			DRM_DEBUG("HPD2\n");
 		}
--
 		while (RBIOS16(offset)) {
 			uint16_t cmd = ((RBIOS16(offset) & 0xe000) >> 13);
 			uint32_t addr = (RBIOS16(offset) & 0x1fff);
@@ -3078,6 +3083,12 @@ static void combios_parse_mmio_table(str
 			default:
 				break;
--
 		while (RBIOS8(offset)) {
 			uint8_t cmd = ((RBIOS8(offset) & 0xc0) >> 6);
 			uint8_t addr = (RBIOS8(offset) & 0x3f);
@@ -3168,6 +3184,12 @@ static void combios_parse_pll_table(stru
 			default:
 				break;
--
 	while (ram--) {
 		addr = ram * 1024 * 1024;
 		/* write to each page */
@@ -3248,6 +3275,12 @@ static uint32_t combios_detect_ram(struc
 		WREG32(RADEON_MM_INDEX, (addr) | RADEON_MM_APER);
 		if (RREG32(RADEON_MM_DATA) != 0xdeadbeef)
--
 		while (dwords & 0xf) {
 			u32 *data = (u32 *)
 			    ((char *)dev->agp_buffer_map->handle
 			     + buf->offset + start);
 			data[dwords++] = RADEON_CP_PACKET2;
+			if (_cur < timeout) {
--
 	while (dwords & 0xf) {
 		packet2s[num_packet2s++] = cpu_to_le32(PACKET2(0));
 		dwords++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-			while (remaining) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (remaining) {
 				if (remaining > 15)
 					current_count = 15;
 				else
@@ -735,9 +740,20 @@ static int r500_hw_i2c_xfer(struct i2c_a
 					p->buf[buffer_offset + j] = RREG32(AVIVO_DC_I2C_DATA) & 0xff;
--
-			while (remaining) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (remaining) {
 				if (remaining > 15)
 					current_count = 15;
 				else
@@ -776,6 +792,12 @@ static int r500_hw_i2c_xfer(struct i2c_a
 				}
--
-		while (ref_div <= pll->max_ref_div) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (ref_div <= pll->max_ref_div) {
 			avivo_get_fb_div(pll, target_clock, post_div, ref_div,
 					 &fb_div, &frac_fb_div);
 			if (frac_fb_div >= (pll->reference_freq / 2))
@@ -850,6 +855,12 @@ void radeon_compute_pll_avivo(struct rad
 				break;
--
 		while (min_ref_div < max_ref_div-1) {
 			uint32_t mid = (min_ref_div + max_ref_div) / 2;
 			uint32_t pll_in = pll->reference_freq / mid;
@@ -925,6 +941,12 @@ void radeon_compute_pll_legacy(struct ra
 				min_ref_div = mid;
 			else
--
 			while (min_feed_div < max_feed_div) {
 				uint32_t vco;
 				uint32_t min_frac_feed_div = min_fractional_feed_div;
@@ -984,6 +1011,11 @@ void radeon_compute_pll_legacy(struct ra
 					continue;
 				}
--
 				while (min_frac_feed_div < max_frac_feed_div) {
 					frac_feedback_div = (min_frac_feed_div + max_frac_feed_div) / 2;
 					tmp = (uint64_t)pll->reference_freq * 10000 * feedback_div;
@@ -1038,11 +1070,23 @@ void radeon_compute_pll_legacy(struct ra
 						min_frac_feed_div = frac_feedback_div + 1;
 					else
--
 	while (rptr != wptr) {
 		/* wptr/rptr are in bytes! */
 		ring_index = rptr / 4;
@@ -3484,6 +3489,12 @@ restart_ih:
 		/* wptr/rptr are in bytes! */
 		rptr += 16;
--
 	/* make sure wptr hasn't changed while processing */
 	wptr = r600_get_ih_wptr(rdev);
diff -u -p a/gpu/drm/radeon/r600_blit_kms.c b/gpu/drm/radeon/r600_blit_kms.c
--- a/gpu/drm/radeon/r600_blit_kms.c
+++ b/gpu/drm/radeon/r600_blit_kms.c
@@ -527,9 +527,20 @@ int r600_blit_init(struct radeon_device
--
 	while (dwords & 0xf) {
 		packet2s[num_packet2s++] = cpu_to_le32(PACKET2(0));
 		dwords++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (num_gpu_pages) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_gpu_pages) {
 		num_gpu_pages -=
 			r600_blit_create_rect(num_gpu_pages, NULL, NULL,
 					      rdev->r600_blit.max_dim);
 		num_loops++;
+		if (_cur < timeout) {
--
-	while (num_gpu_pages) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (num_gpu_pages) {
 		int w, h;
 		unsigned size_in_bytes;
 		unsigned pages_per_loop =
@@ -779,5 +806,11 @@ void r600_kms_blit_copy(struct radeon_de
 		src_gpu_addr += size_in_bytes;
--
 		while (size_bytes) {
 			int cur_size = size_bytes;
 			int src_x = src_gpu_addr & 255;
@@ -682,10 +687,21 @@ r600_blit_copy(struct drm_device *dev,
 			src_gpu_addr += cur_size * h;
 			dst_gpu_addr += cur_size * h;
--
 		while (size_bytes) {
 			int cur_size = size_bytes;
 			int src_x = (src_gpu_addr & 255);
@@ -772,6 +788,12 @@ r600_blit_copy(struct drm_device *dev,
 			src_gpu_addr += cur_size * h;
 			dst_gpu_addr += cur_size * h;
--
 	while (ring->space < n) {
 		ring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
 		ring->space = ring->head - (ring->tail + 8);
@@ -266,6 +271,12 @@ static int i810_wait_ring(struct drm_dev
 			goto out_wait_ring;
 		}
--
-	while (!list_empty(&ring->request_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ring->request_list)) {
 		struct drm_i915_gem_request *request;
 
 		request = list_first_entry(&ring->request_list,
@@ -1759,9 +1764,20 @@ static void i915_gem_reset_ring_lists(st
 		list_del(&request->list);
--
-	while (!list_empty(&ring->active_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ring->active_list)) {
 		struct drm_i915_gem_object *obj;
 
 		obj = list_first_entry(&ring->active_list,
@@ -1771,6 +1787,12 @@ static void i915_gem_reset_ring_lists(st
 		obj->base.write_domain = 0;
--
-	while (!list_empty(&dev_priv->mm.flushing_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev_priv->mm.flushing_list)) {
 		obj = list_first_entry(&dev_priv->mm.flushing_list,
 				      struct drm_i915_gem_object,
 				      mm_list);
@@ -1818,6 +1845,12 @@ void i915_gem_reset(struct drm_device *d
 		obj->base.write_domain = 0;
--
-	while (!list_empty(&file_priv->mm.request_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&file_priv->mm.request_list)) {
 		struct drm_i915_gem_request *request;
 
 		request = list_first_entry(&file_priv->mm.request_list,
@@ -4181,6 +4219,12 @@ void i915_gem_release(struct drm_device
 					   client_list);
--
 	while (count--) {
 		seq_printf(m, "  %08x %8u %04x %04x %08x%s%s%s%s%s%s",
 			   err->gtt_offset,
@@ -734,6 +739,12 @@ static void print_error_buffers(struct s
 
 		seq_printf(m, "\n");
--
 	while (index < total) {
 		current_id = *(base + index);
 		index++;
@@ -58,6 +63,12 @@ find_section(struct bdb_header *bdb, int
 		if (current_id == section_id)
 			return base + index;
--
 			while (len) {
 				if (wait_for(I915_READ(GMBUS2 + reg_offset) & (GMBUS_SATOER | GMBUS_HW_RDY), 50))
 					goto timeout;
@@ -297,6 +302,12 @@ gmbus_xfer(struct i2c_adapter *adapter,
 
 				I915_WRITE(GMBUS3 + reg_offset, val);
--
 	while (--i) {
 		struct intel_gmbus *bus = &dev_priv->gmbus[i];
 		i2c_del_adapter(&bus->adapter);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (!list_empty(&unwind_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&unwind_list)) {
 		obj = list_first_entry(&unwind_list,
 				       struct drm_i915_gem_object,
 				       exec_list);
@@ -140,6 +145,12 @@ i915_gem_evict_something(struct drm_devi
 
--
-	while (!list_empty(&unwind_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&unwind_list)) {
 		obj = list_first_entry(&unwind_list,
 				       struct drm_i915_gem_object,
 				       exec_list);
@@ -162,10 +178,21 @@ found:
 		}
--
-	while (!list_empty(&eviction_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&eviction_list)) {
 		obj = list_first_entry(&eviction_list,
 				       struct drm_i915_gem_object,
 				       exec_list);
@@ -174,6 +201,12 @@ found:
 
--
 	while (rem--) {
 		*virt++ = MI_NOOP;
 		*virt++ = MI_NOOP;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(objects)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(objects)) {
 		struct drm_i915_gem_exec_object2 *entry;
 		bool need_fence, need_mappable;
 
@@ -495,6 +500,12 @@ i915_gem_execbuffer_reserve(struct intel
 
--
 	while (objects != &obj->exec_list) {
 		if (obj->gtt_space)
 			i915_gem_object_unpin(obj);
@@ -611,6 +627,12 @@ err:
 		obj = list_entry(obj->exec_list.prev,
 				 struct drm_i915_gem_object,
--
-	while (!list_empty(objects)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(objects)) {
 		obj = list_first_entry(objects,
 				       struct drm_i915_gem_object,
 				       exec_list);
 		list_del_init(&obj->exec_list);
 		drm_gem_object_unreference(&obj->base);
--
-	while (!list_empty(&objects)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&objects)) {
 		struct drm_i915_gem_object *obj;
 
 		obj = list_first_entry(&objects,
@@ -1251,6 +1289,12 @@ err:
 				       exec_list);
--
 	while (ttm_zones_above_swap_target(glob, from_wq, extra)) {
 		shrink = glob->shrink;
 		spin_unlock(&glob->lock);
@@ -226,6 +231,12 @@ static void ttm_shrink(struct ttm_mem_gl
 		spin_lock(&glob->lock);
 		if (unlikely(ret != 0))
--
 	while (!list_empty(&tfile->ref_list)) {
 		list = tfile->ref_list.next;
 		ref = list_entry(list, struct ttm_ref_object, head);
 		ttm_ref_object_release(&ref->kref);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&man->lru)) {
 		spin_unlock(&glob->lru_lock);
 		ret = ttm_mem_evict_first(bdev, mem_type, false, false, false);
@@ -1333,6 +1338,12 @@ static int ttm_bo_force_list_clean(struc
 			}
 		}
--
 	while (i--) {
 		man = &bdev->man[i];
 		if (man->has_type) {
@@ -1515,6 +1531,12 @@ int ttm_bo_device_release(struct ttm_bo_
 			}
 			man->has_type = false;
--
 	while (*cur) {
 		parent = *cur;
 		cur_bo = rb_entry(parent, struct ttm_buffer_object, vm_rb);
@@ -1654,6 +1681,12 @@ static void ttm_bo_vm_insert_rb(struct t
 			cur = &parent->rb_right;
 		else
--
 	while (bo->sync_obj) {
 
 		if (driver->sync_obj_signaled(bo->sync_obj, bo->sync_obj_arg)) {
@@ -1761,6 +1799,12 @@ int ttm_bo_wait(struct ttm_buffer_object
 			driver->sync_obj_unref(&sync_obj);
 			spin_lock(&bdev->fence_lock);
--
 	while (entry) {
 		next = entry->next;
 		kfree(entry);
 		entry = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!vmw_lag_lt(queue, us)) {
 		spin_lock(&queue->lock);
 		if (list_empty(&queue->head))
@@ -166,6 +171,12 @@ int vmw_wait_lag(struct vmw_private *dev
 			return ret;
 
--
 	while (sw_context->cmd_bounce_size < size) {
 		sw_context->cmd_bounce_size =
 			PAGE_ALIGN(sw_context->cmd_bounce_size +
 				   (sw_context->cmd_bounce_size >> 1));
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&fman->fence_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&fman->fence_list)) {
 		struct vmw_fence_obj *fence =
 			list_entry(fman->fence_list.prev, struct vmw_fence_obj,
 				   head);
@@ -664,6 +669,12 @@ void vmw_fence_fifo_down(struct vmw_fenc
 
--
 	while (num_pages--) {
 		pfn = page_to_pfn(*pages++);
 		if (prev_pfn + 1 != pfn)
 			++descriptors;
 		prev_pfn = pfn;
+		if (_cur < timeout) {
--
 	while (1) {
 		uint32_t stop = ioread32(fifo_mem + SVGA_FIFO_STOP);
 		bool need_bounce = false;
@@ -370,6 +375,12 @@ void *vmw_fifo_reserve(struct vmw_privat
 				return fifo_state->dynamic_buffer;
 			}
--
 	while (new_bus) {
 		new_bridge = new_bus->self;
 
@@ -481,6 +486,11 @@ static void vga_arbiter_check_bridge_sha
 			/* now iterate the previous devices bridge hierarchy */
 			/* if the new devices parent bridge is in the other devices
--
 			while (bus) {
 				bridge = bus->self;
 				if (bridge) {
@@ -488,9 +498,21 @@ static void vga_arbiter_check_bridge_sha
 						vgadev->bridge_has_one_vga = false;
 				}
--
 	while (ids->id) {
 		if (ids->id == DIO_WILDCARD)
 			return ids;
@@ -40,6 +45,12 @@ dio_match_device(const struct dio_device
 				return ids;
 		}
--
 	while (dev->interrupt_out_busy) {
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EAGAIN;
@@ -717,6 +722,12 @@ static ssize_t tower_write (struct file
 		if (retval) {
 			goto unlock_exit;
--
-	while (rec) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rec) {
 		err = emi26_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
 					ANCHOR_LOAD_INTERNAL);
@@ -131,6 +136,12 @@ static int emi26_load_firmware (struct u
 			goto wraperr;
--
-	while (bytes_to_read) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bytes_to_read) {
 		int data_in_secondary = dev->secondary_tail - dev->secondary_head;
 		dbg(2," %s : while, data_in_secondary=%d, status=%d",
 		    __func__, data_in_secondary,
@@ -524,6 +529,12 @@ static ssize_t adu_read(struct file *fil
 				}
 			}
 		}
--
 	while (ptr+4 <= firmware->data+firmware->size) {
 		memcpy(data, ptr, 4);
 		len = (data[0] << 8 | data[1]);
@@ -99,6 +104,12 @@ static int isight_firmware_load(struct u
 			}
 
--
-	while (rec) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rec) {
 		err = emi62_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
 					ANCHOR_LOAD_INTERNAL);
@@ -138,6 +143,12 @@ static int emi62_load_firmware (struct u
 			goto wraperr;
--
-		while (!completion_done(&completion)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!completion_done(&completion)) {
 			retval = usb_unlink_urb(urb);
 
 			switch (retval) {
@@ -1174,6 +1179,12 @@ static int unlink1(struct usbtest_dev *d
 			}
--
-		while (retries) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (retries) {
 			result = usb_control_msg(rio->rio_dev,
 						 usb_rcvctrlpipe(rio-> rio_dev, 0),
 						 rio_cmd.request,
@@ -192,6 +197,12 @@ static long ioctl_rio(struct file *file,
 			   will be little_endian and will potentially need to
--
-		while (retries) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (retries) {
 			result = usb_control_msg(rio->rio_dev,
 						 usb_sndctrlpipe(rio-> rio_dev, 0),
 						 rio_cmd.request,
@@ -246,6 +262,12 @@ static long ioctl_rio(struct file *file,
 
--
 		while (thistime) {
 			if (!rio->rio_dev) {
 				errn = -ENODEV;
@@ -330,6 +357,12 @@ write_rio(struct file *file, const char
 				thistime -= partial;
 			} else
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		u16 a = sisusbcon_readw(p);
 
 		a = ((a) & 0x88ff)        |
@@ -349,6 +354,12 @@ sisusbcon_invert_region(struct vc_data *
 		    (((a) & 0x0700) << 4);
--
 	while (timeout--) {
 		if (base == (mask & usbhs_read(priv, fifo->sel))) {
 			usbhs_pipe_select_fifo(pipe, fifo);
 			return 0;
 		}
 		udelay(10);
--
 	while (fst->Status & FCM_STATUS_BUSY) {
 		US_DEBUGP("20 second USB/ATAPI bridge TIMEOUT occurred!\n");
 		US_DEBUGP("fst->Status is %x\n", fst->Status);
@@ -306,6 +311,12 @@ static int freecom_transport(struct scsi
 			return USB_STOR_TRANSPORT_ERROR;
 
--
-	while (cnt < buflen && sg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt < buflen && sg) {
 		struct page *page = sg_page(sg) +
 				((sg->offset + *offset) >> PAGE_SHIFT);
 		unsigned int poff = (sg->offset + *offset) & (PAGE_SIZE-1);
@@ -194,6 +199,12 @@ unsigned int usb_stor_access_xfer_buf(un
 			cnt += plen;
--
 	while (c67x00_ep_data_free(ep)) {
 		/* Drop the lock so we can sleep waiting for the hardware */
 		spin_unlock_irqrestore(&c67x00->lock, flags);
@@ -349,6 +354,12 @@ void c67x00_endpoint_disable(struct usb_
 		wait_for_completion_timeout(&c67x00->endpoint_disable, 1 * HZ);
 
--
 	while (td->td_list.next != &c67x00->td_list) {
 		td = list_entry(td->td_list.next, struct c67x00_td, td_list);
 		if (td->pipe == last_td->pipe) {
@@ -921,6 +937,12 @@ static inline void c67x00_clear_pipe(str
 			td = tmp;
 		}
--
 		while (*prev && (temp = *prev) != ed) {
 			prev_p = &temp->hwNextED;
 			prev = &temp->ed_next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (td) {
 		struct td	*td_next = td->next_dl_td;
 		struct ed	*ed = td->ed;
@@ -1151,5 +1167,11 @@ dl_done_list (struct ohci_hcd *ohci)
 
 		takeback_td(ohci, td);
--
-		while (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {
 			msleep (10);
 			if (--temp == 0) {
 				ohci_err (ohci, "USB HC takeover failed!"
 					"  (BIOS/SMM bug)\n");
 				return -EBUSY;
--
 	while (!(readl(usb_phy_reg_base + USB_PHY_PLL_REG) & PLL_READY)) {
 		if (!(pll_retry_cont--)) {
 			dev_dbg(&pdev->dev, "USB PHY PLL not ready\n");
 			err = -EIO;
 			goto err2;
 		}
--
 	while (!(readl(usb_phy_reg_base + USB_PHY_PLL_REG) & PLL_READY)) {
 		if (!(pll_retry_cont--)) {
 			dev_dbg(&pdev->dev, "USB PHY PLL not ready\n");
 			err = -EIO;
 			goto err2;
 		}
--
 	while (ep_queue) {
 		list_for_each_entry_safe(qh, qh_next, ep_queue, qh_list) {
 			ep = list_entry(qh->qtd_list.next, struct isp1760_qtd,
@@ -966,6 +971,12 @@ void schedule_ptds(struct usb_hcd *hcd)
 			ep_queue = &priv->bulkqhs;
 		else
--
 	while (ep_queue) {
 		list_for_each_entry_safe(qh, qh_next, ep_queue, qh_list)
 			enqueue_qtds(hcd, qh);
@@ -1009,6 +1025,12 @@ void schedule_ptds(struct usb_hcd *hcd)
 			ep_queue = &priv->bulkqhs;
 		else
--
 	while (priv->int_done_map || priv->atl_done_map) {
 		if (priv->int_done_map) {
 			/* INT ptd */
@@ -1237,6 +1264,12 @@ static void handle_done_ptds(struct usb_
 			start_bus_transfer(hcd, ptd_offset, slot, slots, qtd,
 				qh, &ptd);
--
 	while (last_trb(xhci, ring, enq_seg, enq)) {
 		enq_seg = enq_seg->next;
 		enq = enq_seg->trbs;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (last_trb(xhci, ring, enq_seg, enq)) {
 			enq_seg = enq_seg->next;
 			enq = enq_seg->trbs;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-	while (cur_seg->trbs > trb ||
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cur_seg->trbs > trb ||
 			&cur_seg->trbs[TRBS_PER_SEGMENT - 1] < trb) {
 		generic_trb = &cur_seg->trbs[TRBS_PER_SEGMENT - 1].generic;
 		if (generic_trb->field[3] & cpu_to_le32(LINK_TOGGLE))
@@ -498,6 +525,12 @@ static struct xhci_segment *find_trb_seg
 		if (cur_seg == start_seg)
--
-	while (xhci_trb_virt_to_dma(state->new_deq_seg, state->new_deq_ptr)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (xhci_trb_virt_to_dma(state->new_deq_seg, state->new_deq_ptr)
 			!= (dma_addr_t)(hw_dequeue & ~0xf)) {
 		next_trb(xhci, ep_ring, &state->new_deq_seg,
 					&state->new_deq_ptr);
@@ -609,6 +647,12 @@ void xhci_find_new_dequeue_state(struct
 			WARN_ON(1);
--
-			while (!list_empty(&ring->td_list)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&ring->td_list)) {
 				cur_td = list_first_entry(&ring->td_list,
 						struct xhci_td,
 						td_list);
@@ -1017,8 +1066,19 @@ void xhci_stop_endpoint_command_watchdog
 					list_del_init(&cur_td->cancelled_td_list);
--
-			while (!list_empty(&temp_ep->cancelled_td_list)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&temp_ep->cancelled_td_list)) {
 				cur_td = list_first_entry(
 						&temp_ep->cancelled_td_list,
 						struct xhci_td,
@@ -1026,6 +1086,12 @@ void xhci_stop_endpoint_command_watchdog
 				list_del_init(&cur_td->cancelled_td_list);
--
-		while (last_trb(xhci, ring, ring->enq_seg, next)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while (last_trb(xhci, ring, ring->enq_seg, next)) {
 			/* If we're not dealing with 0.95 hardware or isoc rings
 			 * on AMD 0.96 host, clear the chain bit.
 			 */
@@ -2828,6 +2899,12 @@ static int prepare_ring(struct xhci_hcd
 			ring->enq_seg = ring->enq_seg->next;
--
 		while (running_total < sg_dma_len(sg) && running_total < temp) {
 			num_trbs++;
 			running_total += TRB_MAX_BUFF_SIZE;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
--
 	while (running_total < urb->transfer_buffer_length) {
 		num_trbs++;
 		running_total += TRB_MAX_BUFF_SIZE;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 		while (offset && count--) {
 			pci_read_config_dword (pdev, offset, &cap);
 			switch (cap & 0xff) {
@@ -786,6 +791,12 @@ static ssize_t fill_registers_buffer(str
 				break;
 			}
--
-	while (here.ptr && here.ptr != ptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (here.ptr && here.ptr != ptr) {
 		prev_p = periodic_next_shadow(ehci, prev_p,
 				Q_NEXT_TYPE(ehci, *hw_p));
 		hw_p = shadow_next_periodic(ehci, &here,
 				Q_NEXT_TYPE(ehci, *hw_p));
 		here = *prev_p;
--
 	while (q->ptr) {
 		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
 		case Q_TYPE_QH:
@@ -191,7 +207,13 @@ periodic_usecs (struct ehci_hcd *ehci, u
 			q = &q->sitd->sitd_next;
 			break;
--
 	while (q->ptr) {
 		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
 		case Q_TYPE_ITD:
@@ -303,6 +330,12 @@ periodic_tt_usecs (
 			hw_p = &q->fstn->hw_next;
 			q = &q->fstn->fstn_next;
--
 		while (here.ptr) {
 			switch (hc32_to_cpu(ehci, type)) {
 			case Q_TYPE_ITD:
@@ -468,6 +506,12 @@ static int tt_no_collision (
 
 			/* collision or error */
--
 		while (!list_empty (&stream->free_list)) {
 			struct list_head	*entry;
 
@@ -1093,6 +1142,12 @@ iso_stream_put(struct ehci_hcd *ehci, st
 				dma_pool_free (ehci->sitd_pool, sitd,
 						sitd->sitd_dma);
--
-	while (offset && --count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset && --count) {
 		pci_read_config_dword(pdev, offset, &cap);
 
 		switch (cap & 0xff) {
@@ -663,6 +668,12 @@ static void __devinit quirk_usb_disable_
 				 "%02x\n", cap & 0xff);
--
-	while (ehci->qh_scan_next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+ timeout = rdstcll(start) + delta;
+ while (ehci->qh_scan_next) {
 		qh = ehci->qh_scan_next;
 		ehci->qh_scan_next = qh->qh_next.qh;
  rescan:
@@ -1303,6 +1308,12 @@ static void scan_async (struct ehci_hcd
 			else
--
 	while (ed) {
 		u32		info = hc32_to_cpu (ohci, ed->hwINFO);
 		u32		headp = hc32_to_cpu (ohci, ed->hwHeadP);
@@ -502,6 +507,12 @@ show_list (struct ohci_hcd *ohci, char *
 		buf += temp;
 
--
 	while (port--) {
 		if (test_bit(port, &ehci->owned_ports)) {
 			reg = &ehci->regs->port_status[port];
@@ -75,6 +80,12 @@ static void ehci_handover_companion_port
 						USB_PORT_FEAT_RESET, port + 1,
 						NULL, 0);
--
 	while (port--) {
 		if (test_bit(port, &ehci->owned_ports)) {
 			ehci_hub_control(hcd, GetPortStatus,
@@ -102,6 +118,12 @@ static void ehci_handover_companion_port
 				ehci_writel(ehci, status & ~PORT_PE, reg);
 			}
--
-		while (port--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (port--) {
 			u32 __iomem	*hostpc_reg;
 
 			hostpc_reg = (u32 __iomem *)((u8 *) ehci->regs
 					+ HOSTPC0 + 4 * port);
 			temp = ehci_readl(ehci, hostpc_reg);
--
 	while (port--) {
 		u32 __iomem	*reg = &ehci->regs->port_status[port];
 		u32		t1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;
@@ -179,18 +217,35 @@ static __maybe_unused void ehci_adjust_p
 		ehci_vdbg(ehci, "port %d, %08x -> %08x\n",
 				port + 1, t1, t2);
--
-		while (port--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (port--) {
 			u32 __iomem	*hostpc_reg;
 
 			hostpc_reg = (u32 __iomem *)((u8 *) ehci->regs
 					+ HOSTPC0 + 4 * port);
 			temp = ehci_readl(ehci, hostpc_reg);
--
-		while (port--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (port--) {
 			if (ehci->reset_done[port] != 0) {
 				spin_unlock_irq(&ehci->lock);
 				ehci_dbg(ehci, "suspend failed because "
@@ -233,6 +293,12 @@ static int ehci_bus_suspend (struct usb_
 						port + 1);
--
 	while (port--) {
 		u32 __iomem	*reg = &ehci->regs->port_status [port];
 		u32		t1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;
@@ -294,6 +365,12 @@ static int ehci_bus_suspend (struct usb_
 			ehci_writel(ehci, t2, reg);
 			changed = 1;
--
-		while (port--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (port--) {
 			u32 __iomem	*hostpc_reg;
 			u32		t3;
 
@@ -322,6 +404,12 @@ static int ehci_bus_suspend (struct usb_
 			ehci_dbg(ehci, "Port %d phy low-power mode %s\n",
--
 		while (i--) {
 			if (test_bit(i, &ehci->bus_suspended)) {
 				u32 __iomem	*hostpc_reg;
@@ -421,6 +514,12 @@ static int ehci_bus_resume (struct usb_h
 				ehci_writel(ehci, temp & ~HOSTPC_PHCD,
 						hostpc_reg);
--
 	while (i--) {
 		temp = ehci_readl(ehci, &ehci->regs->port_status [i]);
 		temp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
@@ -438,6 +542,12 @@ static int ehci_bus_resume (struct usb_h
 			set_bit(i, &resume_needed);
 		}
--
 	while (i--) {
 		temp = ehci_readl(ehci, &ehci->regs->port_status [i]);
 		if (test_bit(i, &resume_needed)) {
@@ -455,6 +570,12 @@ static int ehci_bus_resume (struct usb_h
 			ehci_writel(ehci, temp, &ehci->regs->port_status [i]);
 			ehci_vdbg (ehci, "resumed port %d\n", i + 1);
--
-			while (ports--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (ports--) {
 				u32 __iomem *sreg =
 						&ehci->regs->port_status[ports];
 
@@ -1073,6 +1199,12 @@ static int ehci_hub_control (
 				if (temp & PORT_PE)
--
 	while (remaining) {
 		size_t len;
 
@@ -287,6 +292,12 @@ static void qset_copy_bounce_to_sg(struc
 			sg = sg_next(sg);
 			offset = 0;
--
 		while (dma_remaining) {
 			size_t dma_len;
 
@@ -521,6 +537,12 @@ static int qset_add_urb_sg(struct whc *w
 			prev_end = dma_addr = ep;
 			dma_remaining -= dma_len;
--
 		while (sg_remaining) {
 			if (!std || std->len == max_std_len) {
 				std = qset_new_std(whc, qset, urb, mem_flags);
@@ -599,6 +626,12 @@ static int qset_add_urb_sg_linearize(str
 			orig += len;
 			sg_remaining -= len;
--
 	while (ntds_remaining) {
 		struct whc_std *std;
 		size_t std_len;
@@ -683,6 +721,12 @@ int qset_add_urb(struct whc *whc, struct
 		ntds_remaining--;
 		remaining -= std_len;
--
-		while (i--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i--) {
 			int pstatus;
 
 			/* leverage per-port change bits feature */
@@ -915,6 +920,12 @@ static irqreturn_t ehci_irq (struct usb_
 			ehci->reset_done[i] = jiffies + msecs_to_jiffies(25);
--
 	while (tmp != &urbp->td_list) {
 		td = list_entry(tmp, struct uhci_td, list);
 		tmp = tmp->prev;
 
 		uhci_remove_td_from_urbp(td);
 		uhci_free_td(uhci, td);
--
-		while ((qh = uhci->next_qh) != uhci->skelqh[i]) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((qh = uhci->next_qh) != uhci->skelqh[i]) {
 			uhci->next_qh = list_entry(qh->node.next,
 					struct uhci_qh, node);
 
@@ -1770,6 +1786,12 @@ rescan:
 	list_entry(qh->queue.next, struct urb_priv, node));
--
 	while (here.ptr && here.ptr != ptr) {
 		prev_p = periodic_next_shadow(prev_p, Q_NEXT_TYPE(*hw_p));
 		hw_p = here.hw_next;
 		here = *prev_p;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (q->ptr) {
 		switch (Q_NEXT_TYPE(*hw_p)) {
 		case Q_TYPE_QH:
@@ -1864,7 +1880,13 @@ static unsigned short periodic_usecs(str
 			q = &q->qh->qh_next;
 			break;
--
-		while (i--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while (i--) {
 			int pstatus = readl(&oxu->regs->port_status[i]);
 
 			if (pstatus & PORT_OWNER)
@@ -2505,6 +2532,12 @@ static irqreturn_t oxu210_hcd_irq(struct
 			oxu->reset_done[i] = jiffies + msecs_to_jiffies(20);
--
 	while (port--) {
 		u32 __iomem *reg = &oxu->regs->port_status[port];
 		u32 t1 = readl(reg) & ~PORT_RWC_BITS;
@@ -3499,6 +3537,12 @@ static int oxu_bus_suspend(struct usb_hc
 				port + 1, t1, t2);
 			writel(t2, reg);
--
-	while (i--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i--) {
 		temp = readl(&oxu->regs->port_status[i]);
 		temp &= ~(PORT_RWC_BITS
 			| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);
@@ -3566,9 +3615,20 @@ static int oxu_bus_resume(struct usb_hcd
 			temp |= PORT_RESUME;
--
 	while (i--) {
 		temp = readl(&oxu->regs->port_status[i]);
 		if (test_bit(i, &oxu->bus_suspended) && (temp & PORT_SUSPEND)) {
@@ -3576,6 +3636,12 @@ static int oxu_bus_resume(struct usb_hcd
 			writel(temp, &oxu->regs->port_status[i]);
 			oxu_vdbg(oxu, "resumed port %d\n", i + 1);
--
 		while (seg != first_seg) {
 			struct xhci_segment *next = seg->next;
 			xhci_segment_free(xhci, seg);
 			seg = next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 			while (prev) {
 				next = prev->next;
 				xhci_segment_free(xhci, prev);
 				prev = next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
-		while (port_index--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (port_index--) {
 			if (bus_state->resume_done[port_index] != 0) {
 				spin_unlock_irqrestore(&xhci->lock, flags);
 				xhci_dbg(xhci, "suspend failed because "
@@ -967,11 +972,22 @@ int xhci_bus_suspend(struct usb_hcd *hcd
 						port_index + 1);
--
 	while (port_index--) {
 		/* suspend the port if the port is not suspended */
 		u32 t1, t2;
@@ -1007,6 +1023,12 @@ int xhci_bus_suspend(struct usb_hcd *hcd
 		t1 = xhci_port_state_to_neutral(t1);
 		if (t1 != t2)
--
 	while (port_index--) {
 		/* Check whether need resume ports. If needed
 		   resume port and disable remote wakeup */
@@ -1085,6 +1112,12 @@ int xhci_bus_resume(struct usb_hcd *hcd)
 				xhci_ring_device(xhci, slot_id);
 		} else
--
 	while (port--) {
 		u32 stat = isp1362_read_reg32(isp1362_hcd, HCRHPORT1 + port);
 
@@ -1885,6 +1890,12 @@ static int isp1362_bus_resume(struct usb
 		}
 		DBG(0, "%s: Resuming RH port %d\n", __func__, port);
--
 	while (!clkrdy && time_before_eq(jiffies, t)) {
 		spin_lock_irqsave(&isp1362_hcd->lock, flags);
 		clkrdy = isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_CLKRDY;
 		spin_unlock_irqrestore(&isp1362_hcd->lock, flags);
 		if (!clkrdy)
 			msleep(4);
--
 	while (buf) {
 		p = strchr(buf, '\n');
 		if (p)
@@ -34,6 +39,12 @@ static void lprintk(char *buf)
 		buf = p;
 		if (buf)
--
 		while (tmp != head) {
 			qh = list_entry(tmp, struct uhci_qh, node);
 			tmp = tmp->next;
@@ -465,6 +481,12 @@ check_link:
 						len - (out - buf), 4);
 			if (!fsbr_link && qh->skel >= SKEL_FSBR)
--
-	while (val--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (val--) {
 		u32 stat =
 		    isp116x_read_reg32(isp116x, val ? HCRHPORT2 : HCRHPORT1);
 		/* force global, not selective, resume */
@@ -1485,6 +1490,12 @@ static int isp116x_bus_resume(struct usb
 		DBG("%s: Resuming port %d\n", __func__, val);
--
 		while (queue) {
 			struct cppi_descriptor	*tmp = queue->next;
 
 			cppi_bd_free(cppi_ch, queue);
 			queue = tmp;
+			if (_cur < timeout) {
--
 	while (!list_empty(&ep->req_list)) {
 		req = list_first_entry(&ep->req_list, struct musb_request, list);
 		musb_g_giveback(ep, &req->request, status);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (csr & MUSB_TXCSR_FIFONOTEMPTY) {
 		if (csr != lastcsr)
 			dev_dbg(musb->controller, "Host TX FIFONOTEMPTY csr: %02x\n", csr);
@@ -125,6 +130,12 @@ static void musb_h_tx_flush_fifo(struct
 				ep->epnum, csr))
 			return;
--
 		while (!list_empty(&hep->urb_list)) {
 			urb = next_urb(qh);
 			urb->status = -ESHUTDOWN;
 			musb_advance_schedule(musb, urb, qh->hw_ep, is_in);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
 				& MUSB_ULPI_REG_CMPLT)) {
 		i++;
 		if (i == 10000)
 			return -ETIMEDOUT;
 
--
-	while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
 				& MUSB_ULPI_REG_CMPLT)) {
 		i++;
 		if (i == 10000)
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
--
 	while (reg) {
 		if (reg & 1) {
 			/* musb_ep_select(musb->mregs, ep_num); */
@@ -1560,11 +1587,22 @@ irqreturn_t musb_interrupt(struct musb *
 
 		reg >>= 1;
--
 	while (reg) {
 		if (reg & 1) {
 			/* musb_ep_select(musb->mregs, ep_num); */
@@ -1580,6 +1618,12 @@ irqreturn_t musb_interrupt(struct musb *
 		}
 		reg >>= 1;
--
-	while (ms--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (ms--) {
 		for (i = 0; i < 1000; i++)
 			outb(0x1, 0x80);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (readl(&ehci_debug->control) & DBGP_ENABLED) {
 		kgdbdbgp_loop_cnt = 1;
 		ret = kgdbdbgp_read_char();
@@ -1074,6 +1090,12 @@ static int kgdbdbgp_reader_thread(void *
 			continue;
 		}
--
 		while (1) {
 			if (signal_pending(current))
 				return -ERESTARTSYS;
@@ -2055,6 +2060,12 @@ static int mos7720_ioctl(struct tty_stru
 				return 0;
 			}
--
 	while (!list_empty(&garmin_data_p->pktlist)) {
 		result = (struct garmin_packet *)garmin_data_p->pktlist.next;
 		list_del(&result->list);
 		kfree(result);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (n < size) {
 		cksum += *recpkt++;
 		n++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (offs < count) {
 
 		data = *(buf+offs);
@@ -573,6 +600,12 @@ static int gsp_receive(struct garmin_dat
 			size = GSP_INITIAL_OFFSET;
 			dleSeen = 0;
--
-	while (offs < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offs < count) {
 		/* if buffer contains header, copy rest of data */
 		if (garmin_data_p->insize >= GARMIN_PKTHDR_LENGTH)
 			len = GARMIN_PKTHDR_LENGTH
@@ -818,6 +856,12 @@ static int nat_receive(struct garmin_dat
 				}
--
 	while (count) {
 		unsigned int i;
 		unsigned int lf;
@@ -250,6 +255,12 @@ static void usb_console_write(struct con
 		}
 		buf += i;
--
-		while (i < urb->actual_length) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i < urb->actual_length) {
 
 			/* Check port number from message*/
 			if (data[i] >= serial->num_ports) {
@@ -915,6 +920,12 @@ static void usa49wg_indat_callback(struc
 			}
--
 	while (1) {
 		/* wake up in bulk read */
 		interruptible_sleep_on(&port->delta_msr_wait);
@@ -568,6 +573,12 @@ static int spcp8x5_wait_modem_info(struc
 			return 0;
 
--
 		while (1) {
 			interruptible_sleep_on(&port->delta_msr_wait);
 			if (signal_pending(current))
@@ -864,6 +869,12 @@ static int ti_ioctl(struct tty_struct *t
 			    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)))
 				return 0;
--
 	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
 		err = usb_submit_urb(urb, GFP_ATOMIC);
 		if (!err) {
@@ -700,6 +705,12 @@ static void play_delayed(struct usb_seri
 			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!multi_change) {
 		interruptible_sleep_on(&port->delta_msr_wait);
 		/* see if a signal did it */
@@ -549,6 +554,12 @@ static int wait_modem_info(struct usb_se
 			return 0;
 		}
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		count = mos7840_chars_in_buffer(tty);
 
 		/* Check for Buffer status */
@@ -1335,6 +1340,12 @@ static void mos7840_block_until_chase_re
 			/* Reset timeout value back to seconds */
--
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (1) {
 			/* interruptible_sleep_on(&mos7840_port->delta_msr_wait); */
 			mos7840_port->delta_msr_cond = 0;
 			wait_event_interruptible(port->delta_msr_wait,
@@ -2333,6 +2349,12 @@ static int mos7840_ioctl(struct tty_stru
 				return 0;
--
-		while ((position < length) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((position < length) &&
 				(portNumber < edge_serial->serial->num_ports)) {
 			txCredits = data[position] | (data[position+1] << 8);
 			if (txCredits) {
@@ -652,6 +657,12 @@ static void edge_interrupt_callback(stru
 			}
--
 	while (1) {
 		/* Save Last credits */
 		lastCredits = edge_port->txCredits;
@@ -1002,6 +1018,12 @@ static void block_until_chase_response(s
 					lastCredits, edge_port->txCredits);
 			loop = 10;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		/* Save Last count */
 		lastCount = fifo->count;
 
@@ -1053,6 +1080,12 @@ static void block_until_tx_empty(struct
 			/* Reset timeout value back to seconds */
--
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (1) {
 			prepare_to_wait(&port->delta_msr_wait,
 						&wait, TASK_INTERRUPTIBLE);
 			schedule();
@@ -1723,6 +1761,12 @@ static int edge_ioctl(struct tty_struct
 				return 0;
--
 	while (1) {
 		interruptible_sleep_on(&port->delta_msr_wait);
 		/* see if a signal did it */
@@ -635,6 +640,12 @@ static int wait_modem_info(struct usb_se
 			return 0;
 		}
--
 	while (1) {
 		wait_event_interruptible(port->delta_msr_wait,
 					 (port->serial->disconnected ||
@@ -414,6 +419,12 @@ static int wait_modem_info(struct usb_se
 		    (arg & TIOCM_CD  && (prev.dcd != cur.dcd)) ||
 		    (arg & TIOCM_CTS && (prev.cts != cur.cts)))
--
 	while (count > 0) {
-		while (oob_priv->dp_write_urb_in_use) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (oob_priv->dp_write_urb_in_use) {
 			cond_wait_interruptible_timeout_irqrestore(
 				&oob_port->write_wait, DIGI_RETRY_TIMEOUT,
 				&oob_priv->dp_port_lock, flags);
 			if (interruptible && signal_pending(current))
 				return -EINTR;
--
 	while (count > 0 && ret == 0) {
-		while (priv->dp_write_urb_in_use &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (priv->dp_write_urb_in_use &&
 		       time_before(jiffies, timeout)) {
 			cond_wait_interruptible_timeout_irqrestore(
 				&port->write_wait, DIGI_RETRY_TIMEOUT,
@@ -710,6 +726,12 @@ static int digi_write_inb_command(struct
 			if (signal_pending(current))
--
-	while (oob_priv->dp_write_urb_in_use) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (oob_priv->dp_write_urb_in_use) {
 		spin_unlock(&port_priv->dp_port_lock);
 		cond_wait_interruptible_timeout_irqrestore(
 			&oob_port->write_wait, DIGI_RETRY_TIMEOUT,
@@ -790,6 +817,12 @@ static int digi_set_modem_signals(struct
 			return -EINTR;
--
-	while (time_before(jiffies, timeout) && !priv->dp_transmit_idle) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, timeout) && !priv->dp_transmit_idle) {
 		cond_wait_interruptible_timeout_irqrestore(
 			&priv->dp_transmit_idle_wait, DIGI_RETRY_TIMEOUT,
 			&priv->dp_port_lock, flags);
 		if (signal_pending(current))
 			return -EINTR;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		wait_event_interruptible(port->delta_msr_wait,
 					port->serial->disconnected ||
 					priv->status.pin_state != prev);
@@ -724,6 +729,12 @@ static int wait_modem_info(struct usb_se
 		    ((arg & TIOCM_CTS) && (changed & PIN_CTS)))
--
-	while (length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (length) {
 		if (length > 64)
 			read_length = 64;
 		else
@@ -347,6 +352,12 @@ static int read_download_mem(struct usb_
 		start_address += read_length;
--
-	while (length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (length) {
 		if (length > EPROM_PAGE_SIZE)
 			write_length = EPROM_PAGE_SIZE;
 		else
@@ -500,6 +516,12 @@ static int write_i2c_mem(struct edgeport
 		length		-= write_length;
--
 		while (1) {
 			interruptible_sleep_on(&port->delta_msr_wait);
 			/* see if a signal did it */
@@ -2605,6 +2632,12 @@ static int edge_ioctl(struct tty_struct
 				return 0;
 			}
--
 	while (usec--) {
 		if (!(readl(view) & mask))
 			return 0;
 
 		udelay(1);
+		if (_cur < timeout) {
--
 	while (length) {
 		/*
 		 * Determine step_len.
@@ -247,6 +252,12 @@ static unsigned int mon_copy_to_buff(con
 		if ((off += step_len) >= this->b_size) off = 0;
 		from += step_len;
--
 	while (length) {
 		/*
 		 * Determine step_len.
@@ -280,6 +296,12 @@ static int copy_from_buf(const struct mo
 		if ((off += step_len) >= this->b_size) off = 0;
 		to += step_len;
--
 	while (bytes < avail) {
 		ep = MON_OFF2HDR(rp, cur_out);
 
@@ -969,6 +996,12 @@ static int mon_bin_queued(struct mon_rea
 		if ((cur_out += size) >= rp->b_size)
 			cur_out -= rp->b_size;
--
 	while (MON_RING_EMPTY(rp)) {
 		spin_unlock_irqrestore(&rp->b_lock, flags);
 
@@ -1293,6 +1331,12 @@ static int mon_bin_wait_event(struct fil
 		set_current_state(TASK_INTERRUPTIBLE);
 
--
 	while (!list_empty(&rp->e_list)) {
 		p = rp->e_list.next;
 		ep = list_entry(p, struct mon_event_text, e_link);
 		list_del(p);
 		--rp->nevents;
 		kmem_cache_free(rp->e_slab, ep);
--
 	while (!list_empty(&mon_buses)) {
 		p = mon_buses.next;
 		mbus = list_entry(p, struct mon_bus, bus_link);
@@ -411,6 +416,12 @@ static void __exit mon_exit(void)
 
 		mon_dissolve(mbus, mbus->u_bus);
--
 	while (writecount < count) {
 		/*
 		 * Step 1: Submit next block.
@@ -777,6 +782,12 @@ static ssize_t usblp_write(struct file *
 		 * The wmut exists mainly to cover us here.
 		 */
--
 		while (skb2) {
 			if (status < 0
 					|| ETH_HLEN > skb2->len
@@ -318,6 +323,12 @@ static void rx_complete(struct usb_ep *e
 			status = netif_rx(skb2);
 next_frame:
--
 	while (i--) {
 		req = usb_ep_alloc_request(ep, GFP_ATOMIC);
 		if (!req)
 			return list_empty(list) ? -ENOMEM : 0;
 		list_add(&req->list, list);
+		if (_cur < timeout) {
--
-	while (!list_empty(&dev->rx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_reqs)) {
 		req = container_of(dev->rx_reqs.next,
 				struct usb_request, list);
 		list_del_init(&req->list);
@@ -436,6 +463,12 @@ static void rx_fill(struct eth_dev *dev,
 		}
--
-	while (!list_empty(&dev->tx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->tx_reqs)) {
 		req = container_of(dev->tx_reqs.next,
 					struct usb_request, list);
 		list_del(&req->list);
@@ -965,6 +1003,12 @@ void gether_disconnect(struct gether *li
 		spin_unlock(&dev->req_lock);
--
-	while (!list_empty(&dev->rx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_reqs)) {
 		req = container_of(dev->rx_reqs.next,
 					struct usb_request, list);
 		list_del(&req->list);
@@ -980,6 +1029,12 @@ void gether_disconnect(struct gether *li
 		spin_unlock(&dev->req_lock);
--
 			while (i) {
 				sprintf(name, NAME_TEMPLATE, --i);
 				remove_proc_entry(name, NULL);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-	while (!list_empty (&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty (&ep->queue)) {
 		struct s3c2410_request *req;
 		req = list_entry (ep->queue.next, struct s3c2410_request,
 				queue);
 		s3c2410_udc_done(ep, req, status);
+		if (_cur < timeout) {
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct pxa27x_request, queue);
 		req_done(ep, req, status, &flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!ep_is_empty(ep)) {
 		i = udc_ep_readl(ep, UDCDR);
 		ep_err(ep, "wrong to have extra bytes for setup : 0x%08x\n", i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!(net2272_ep_read(ep, EP_STAT0) & (1 << BUFFER_FULL))) {
 		buf = req->req.buf + req->req.actual;
 		prefetch(buf);
@@ -499,6 +504,12 @@ net2272_write_fifo(struct net2272_ep *ep
 			return 1;
 		}
--
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next,
 				struct net2272_request,
 				queue);
 		net2272_done(ep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
--
-		while (!list_empty(&ep->queue)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&ep->queue)) {
 			req = list_entry(ep->queue.next,
 				struct net2272_request, queue);
 			net2272_done(ep, req,
 				(req->req.actual == req->req.length) ? 0 : -EPROTO);
+			if (_cur < timeout) {
--
 	while ((pch_udc_read_ep_control(ep) & UDC_EPCTL_NAK) && --loopcnt) {
 		pch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_CNAK);
 		udelay(5);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct pch_udc_request, queue);
 		complete_req(ep, req, -ESHUTDOWN);	/* Remove from list */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&ep->queue)) {
 		struct fsl_req *req = NULL;
 
 		req = list_entry(ep->queue.next, struct fsl_req, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
--
 	while (fsl_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {
 		if (time_after(jiffies, timeout)) {
 			ERR("udc reset timeout!\n");
 			return -ETIMEDOUT;
 		}
 		cpu_relax();
--
 		while (fsl_readl(&dr_regs->endptflush)) {
 			if (time_after(jiffies, timeout)) {
 				ERR("ep flush timeout\n");
 				return;
 			}
 			cpu_relax();
--
 	} while (fsl_readl(&dr_regs->endptstatus) & bits);
diff -u -p a/usb/gadget/langwell_udc.c b/usb/gadget/langwell_udc.c
--- a/usb/gadget/langwell_udc.c
+++ b/usb/gadget/langwell_udc.c
@@ -450,11 +450,22 @@ static void nuke(struct langwell_ep *ep,
 	if (&ep->ep && ep->desc)
--
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		struct langwell_request	*req = NULL;
 		req = list_entry(ep->queue.next, struct langwell_request,
 				queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
--
 		while (readl(&dev->op_regs->endptflush)) {
 			if (time_after(jiffies, timeout)) {
 				dev_err(&dev->pdev->dev, "ep flush timeout\n");
 				goto done;
 			}
 			cpu_relax();
--
 	} while (readl(&dev->op_regs->endptstat) & flush_bit);
 done:
@@ -1368,12 +1390,23 @@ static int langwell_udc_reset(struct lan
 
 	/* wait for reset to complete */
 	timeout = jiffies + RESET_TIMEOUT;
--
 	while (readl(&dev->op_regs->usbcmd) & CMD_RST) {
 		if (time_after(jiffies, timeout)) {
 			dev_err(&dev->pdev->dev, "device reset timeout\n");
 			return -ETIMEDOUT;
 		}
 		cpu_relax();
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct m66592_request, queue);
 		spin_lock_irqsave(&ep->m66592->lock, flags);
 		transfer_complete(ep, req, -ECONNRESET);
 		spin_unlock_irqrestore(&ep->m66592->lock, flags);
+		if (_cur < timeout) {
--
 	while (!list_empty(&imx_ep->queue)) {
 		req = list_entry(imx_ep->queue.next, struct imx_request, queue);
 		done(imx_ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		if (count == 0) {	/* last byte */
 			temp = __raw_readl(imx_ep->imx_usb->base
 				+ USB_EP_FCTRL(EP_NO(imx_ep)));
@@ -456,6 +472,12 @@ static int write_packet(struct imx_ep_st
 		}
--
 	while (!imx_ep_empty(imx_ep)) {
 		i = __raw_readl(imx_usb->base +	USB_EP_FDAT(EP_NO(imx_ep)));
 		D_ERR(imx_usb->dev,
 			"<%s> wrong to have extra bytes for setup : 0x%08x\n",
 			__func__, i);
+		if (_cur < timeout) {
--
-	while (!(r8a66597_read(r8a66597, ep->fifoctr) & FRDY)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(r8a66597_read(r8a66597, ep->fifoctr) & FRDY)) {
 		udelay(1);
 		if (unlikely(i++ >= 10000)) {	/* timeout = 10 msec */
 			dev_err(r8a66597_to_dev(r8a66597),
@@ -1424,6 +1429,12 @@ static void sudmac_finish(struct r8a6659
 				__func__, pipenum);
--
 	while (!list_empty(&ep->queue)) {
 		req = get_request_from_ep(ep);
 		spin_lock_irqsave(&ep->r8a66597->lock, flags);
 		transfer_complete(ep, req, -ECONNRESET);
 		spin_unlock_irqrestore(&ep->r8a66597->lock, flags);
+		if (_cur < timeout) {
--
-	while (!list_empty(&hsep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&hsep->queue)) {
 		hsreq = list_entry(hsep->queue.next,
 				struct s3c_hsudc_req, queue);
 		s3c_hsudc_complete_request(hsep, hsreq, status);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (ep_intr) {
 		if (ep_intr & 1)  {
 			hsep = &hsudc->ep[ep_idx];
@@ -1129,6 +1145,12 @@ static irqreturn_t s3c_hsudc_irq(int irq
 		}
 		ep_intr >>= 1;
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct goku_request, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct at91_request, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&mEp->qh.queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mEp->qh.queue)) {
 
 		/* pop oldest request */
 		struct ci13xxx_req *mReq = \
@@ -1604,6 +1609,12 @@ __acquires(mEp->lock)
 			mReq->req.complete(&mEp->ep, &mReq->req);
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct omap_req, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (UDCCS0 & UDCCS0_RNE) {
 		byte = (u8) UDDR0;
 
@@ -614,6 +619,12 @@ read_ep0_fifo (struct pxa25x_ep *ep, str
 			req->req.actual++;
 			bufferspace--;
--
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next,
 				struct pxa25x_request,
 				queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
--
 	while (*src) {
 		memcpy(mem, *src, (*src)->bLength);
 		*tmp = mem;
 		tmp++;
 		mem += (*src)->bLength;
 		src++;
--
 	while (!READ_COND) {
 		spin_unlock_irqrestore(&hidg->spinlock, flags);
 		if (file->f_flags & O_NONBLOCK)
@@ -153,6 +158,12 @@ static ssize_t f_hidg_read(struct file *
 			return -ERESTARTSYS;
 
--
-	while (!WRITE_COND) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (!WRITE_COND) {
 		mutex_unlock(&hidg->lock);
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
@@ -209,6 +225,12 @@ static ssize_t f_hidg_write(struct file
 			return -ERESTARTSYS;
--
-	while (!list_empty(&queue->irqqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&queue->irqqueue)) {
 		buf = list_first_entry(&queue->irqqueue, struct uvc_buffer,
 				       queue);
 		list_del(&buf->queue);
 		buf->state = UVC_BUF_STATE_ERROR;
 		wake_up(&buf->wait);
--
 	while (!list_empty(head)) {
 		req = list_entry(head->next, struct usb_request, list);
 		list_del(&req->list);
 		gs_free_req(ep, req);
 		if (allocated)
 			(*allocated)--;
--
-	while (likely(!list_empty(&dev->rx_reqs))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!list_empty(&dev->rx_reqs))) {
 		int error;
 
 		req = container_of(dev->rx_reqs.next,
@@ -535,6 +540,12 @@ setup_rx_reqs(struct printer_dev *dev)
 		} else {
--
-	while ((current_rx_bytes || likely(!list_empty(&dev->rx_buffers)))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((current_rx_bytes || likely(!list_empty(&dev->rx_buffers)))
 			&& len) {
 		if (current_rx_bytes == 0) {
 			req = container_of(dev->rx_buffers.next,
@@ -657,6 +673,12 @@ printer_read(struct file *fd, char __use
 			current_rx_buf = NULL;
--
-	while (likely(!list_empty(&dev->tx_reqs)) && len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (likely(!list_empty(&dev->tx_reqs)) && len) {
 
 		if (len > USB_BUFSIZE)
 			size = USB_BUFSIZE;
@@ -770,6 +797,12 @@ printer_write(struct file *fd, const cha
 
--
-	while (likely(!(list_empty(&dev->rx_buffers)))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!(list_empty(&dev->rx_buffers)))) {
 		req = container_of(dev->rx_buffers.next, struct usb_request,
 				list);
 		list_del_init(&req->list);
 		list_add(&req->list, &dev->rx_reqs);
+		if (_cur < timeout) {
--
-	while (likely(!(list_empty(&dev->rx_reqs_active)))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!(list_empty(&dev->rx_reqs_active)))) {
 		req = container_of(dev->rx_buffers.next, struct usb_request,
 				list);
 		list_del_init(&req->list);
 		list_add(&req->list, &dev->rx_reqs);
+		if (_cur < timeout) {
--
-	while (likely(!(list_empty(&dev->tx_reqs_active)))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!(list_empty(&dev->tx_reqs_active)))) {
 		req = container_of(dev->tx_reqs_active.next,
 				struct usb_request, list);
 		list_del_init(&req->list);
 		list_add(&req->list, &dev->tx_reqs);
+		if (_cur < timeout) {
--
-	while (!list_empty(&dev->tx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->tx_reqs)) {
 		req = container_of(dev->tx_reqs.next, struct usb_request,
 				list);
 		list_del(&req->list);
 		printer_req_free(dev->in_ep, req);
+		if (_cur < timeout) {
--
-	while (!list_empty(&dev->rx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_reqs)) {
 		req = container_of(dev->rx_reqs.next,
 				struct usb_request, list);
 		list_del(&req->list);
 		printer_req_free(dev->out_ep, req);
+		if (_cur < timeout) {
--
-	while (!list_empty(&dev->rx_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_buffers)) {
 		req = container_of(dev->rx_buffers.next,
 				struct usb_request, list);
 		list_del(&req->list);
 		printer_req_free(dev->out_ep, req);
+		if (_cur < timeout) {
--
-			while (!list_empty(&dev->tx_reqs)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&dev->tx_reqs)) {
 				req = container_of(dev->tx_reqs.next,
 						struct usb_request, list);
 				list_del(&req->list);
 				printer_req_free(dev->in_ep, req);
+				if (_cur < timeout) {
--
-			while (!list_empty(&dev->rx_reqs)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&dev->rx_reqs)) {
 				req = container_of(dev->rx_reqs.next,
 						struct usb_request, list);
 				list_del(&req->list);
 				printer_req_free(dev->out_ep, req);
+				if (_cur < timeout) {
--
-	while (!list_empty (&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty (&ep->queue)) {
 		req = list_entry (ep->queue.next,
 				struct net2280_request,
 				queue);
 		done (ep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
--
-		while (!list_empty (&ep->queue)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty (&ep->queue)) {
 			req = list_entry (ep->queue.next,
 					struct net2280_request, queue);
 			done (ep, req, (req->req.actual == req->req.length)
 						? 0 : -EPROTO);
+			if (_cur < timeout) {
--
 			while (readl(&udc->op_regs->epprime) & bit_pos) {
 				if (loops == 0) {
 					retval = -ETIME;
@@ -302,6 +307,12 @@ static int queue_dtd(struct mv_ep *ep, s
 				}
 				udelay(LOOPS_USEC);
--
 				while (curr_dtd->size_ioc_sts
 					& DTD_STATUS_ACTIVE) {
 					if (loops == 0) {
@@ -356,6 +372,12 @@ static int queue_dtd(struct mv_ep *ep, s
 					}
 					loops--;
--
-			while ((curr_dtd_ptr != req->head->td_dma)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((curr_dtd_ptr != req->head->td_dma)) {
 				curr_dtd_ptr = dqh->curr_dtd_ptr;
 				if (loops == 0) {
 					dev_err(&udc->dev->dev,
@@ -414,6 +441,12 @@ static int queue_dtd(struct mv_ep *ep, s
 						&udc->op_regs->epprime);
--
-		while (readl(&udc->op_regs->epflush)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (readl(&udc->op_regs->epflush)) {
 			/*
 			 * ENDPTFLUSH bit should be cleared to indicate this
 			 * operation is complete
@@ -758,6 +796,12 @@ static void mv_ep_fifo_flush(struct usb_
 			}
--
 	} while (readl(&udc->op_regs->epstatus) & bit_pos);
@@ -1091,7 +1135,12 @@ static int udc_reset(struct mv_udc *udc)
 
 	/* wait for reset to complete */
 	loops = LOOPS(RESET_TIMEOUT);
-	while (readl(&udc->op_regs->usbcmd) & USBCMD_CTRL_RESET) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (readl(&udc->op_regs->usbcmd) & USBCMD_CTRL_RESET) {
 		if (loops == 0) {
 			dev_err(&udc->dev->dev,
 				"Wait for RESET completed TIMEOUT\n");
@@ -1099,6 +1148,12 @@ static int udc_reset(struct mv_udc *udc)
 		}
--
 	while (!list_empty(&ep->queue)) {
 		struct mv_req *req = NULL;
 		req = list_entry(ep->queue.next, struct mv_req, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (*sp) {
 		s = *sp;
 		language = cpu_to_le16(s->language);
@@ -800,6 +805,12 @@ static void collect_langs(struct usb_gad
 		*tmp++ = language;
 repeat:
--
 	while (*sp) {
 		s = *sp++;
 		if (s->language != language)
@@ -820,6 +836,12 @@ static int lookup_string(
 		value = usb_gadget_get_string(s, id, buf);
 		if (value > 0)
--
-	while (!list_empty(&cdev->configs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cdev->configs)) {
 		struct usb_configuration	*c;
 
 		c = list_first_entry(&cdev->configs,
 				struct usb_configuration, list);
-		while (!list_empty(&c->functions)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&c->functions)) {
 			struct usb_function		*f;
 
 			f = list_first_entry(&c->functions,
@@ -1345,6 +1377,12 @@ composite_unbind(struct usb_gadget *gadg
 				f->unbind(c, f);
--
 	while (td && !(td->status & AMD_BIT(UDC_DMA_IN_STS_L))) {
 		td = phys_to_virt(td->next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (td && !(td->status & AMD_BIT(UDC_DMA_IN_STS_L))) {
 		td = phys_to_virt(td->next);
 		/* received number bytes */
@@ -922,6 +938,12 @@ static u32 udc_get_ppbdu_rxbytes(struct
 			count += AMD_GETBITS(td->status,
 				UDC_DMA_OUT_STS_RXBYTES);
--
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next,
 			struct udc_request,
 			queue);
 		complete_req(ep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
--
 	while (!list_empty(&ep->queue)) {
 		struct qe_req *req = NULL;
 		req = list_entry(ep->queue.next, struct qe_req, queue);
 
 		done(ep, req, status);
+		if (_cur < timeout) {
--
 	while (!(bdstatus & R_E) && !(bdstatus & BD_LENGTH_MASK) && !stop) {
 		bdstatus = R_E | R_I | (bdstatus & R_W);
 		out_be32((u32 __iomem *)bd, bdstatus);
@@ -752,6 +768,12 @@ static void recycle_rxbds(struct qe_ep *
 		bdstatus = in_be32((u32 __iomem *)bd);
 		if (stopatnext && (bd == nextbd))
--
 	while (!(bdstatus & R_E) && length) {
 		if ((bdstatus & R_F) && (bdstatus & R_L)
 			&& !(bdstatus & R_ERROR)) {
@@ -887,6 +914,12 @@ static int qe_ep0_rx(struct qe_udc *udc)
 		bdstatus = in_be32((u32 __iomem *)bd);
 		length = bdstatus & BD_LENGTH_MASK;
--
 	while (!(bdstatus & T_R) && (bdstatus & ~T_W)) {
 		pframe = ep->txframe;
 
@@ -1399,6 +1437,12 @@ static int qe_ep0_txconf(struct qe_ep *e
 
 		bd = ep->c_txbd;
--
 	while (!(bdstatus & T_R) && (bdstatus & ~T_W)) {
 		pframe = ep->txframe;
 		if (bdstatus & DEVICE_T_ERROR) {
@@ -1454,6 +1503,12 @@ static int qe_ep_txconf(struct qe_ep *ep
 		ep_txframe_handle(ep);
 		bd = ep->c_txbd;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		u32 grstctl = readl(hsotg->regs + S3C_GRSTCTL);
 
 		if (timeout-- < 0) {
@@ -2564,6 +2569,12 @@ static int s3c_hsotg_corereset(struct s3
 			continue;
--
 	while ((epctrl & USBA_TX_PK_RDY) && !(epstatus & USBA_TX_PK_RDY)) {
 		DBG(DBG_BUS, "%s: TX PK ready\n", ep->ep.name);
 
@@ -1593,6 +1598,12 @@ static void usba_ep_irq(struct usba_udc
 
 		epstatus = usba_ep_readl(ep, STA);
--
 	while (!list_empty (&ep->queue)) {
 		struct dummy_request	*req;
 
@@ -254,6 +259,12 @@ static void nuke (struct dummy *dum, str
 		spin_unlock (&dum->lock);
 		req->req.complete (&ep->ep, &req->req);
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct fusb300_request, queue);
 		spin_lock_irqsave(&ep->fusb300->lock, flags);
 		done(ep, req, -ECONNRESET);
 		spin_unlock_irqrestore(&ep->fusb300->lock, flags);
+		if (_cur < timeout) {
--
 	while (!usb_trylock_device(udev)) {
 
 		/* If we can't acquire the lock after waiting one second,
@@ -593,6 +598,12 @@ int usb_lock_device_for_reset(struct usb
 		if (iface && (iface->condition == USB_INTERFACE_UNBINDING ||
 				iface->condition == USB_INTERFACE_UNBOUND))
--
 		while (++i < n) {
 			intf = udev->actconfig->interface[i];
 			usb_resume_interface(udev, intf, msg, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (leng && start <= end) {
 		start += sprintf(start, " %02x", *ptr);
 		ptr++; leng--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&anchor->urb_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
 		/* we must make sure the URB isn't freed before we kill it*/
@@ -695,6 +700,12 @@ void usb_kill_anchored_urbs(struct usb_a
 		usb_kill_urb(victim);
--
-	while (!list_empty(&anchor->urb_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
 		/* we must make sure the URB isn't freed before we kill it*/
@@ -728,6 +744,12 @@ void usb_poison_anchored_urbs(struct usb
 		usb_poison_urb(victim);
--
-	while (!list_empty(&anchor->urb_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
 		__usb_unanchor_urb(victim, anchor);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (!list_empty (&ep->urb_list)) {
 		spin_lock_irq(&hcd_urb_list_lock);
 
@@ -1687,6 +1692,12 @@ rescan:
 			usb_kill_urb (urb);
 			usb_put_urb (urb);
--
 	while (i < entries && !io->status) {
 		int retval;
 
@@ -549,6 +554,12 @@ void usb_sg_wait(struct usb_sg_request *
 		spin_lock_irq(&io->lock);
 		if (retval && (io->status == 0 || io->status == -ECONNRESET))
--
 	while (!list_empty(list)) {
 		as = list_entry(list->next, struct async, asynclist);
 		list_del_init(&as->asynclist);
@@ -451,6 +456,12 @@ static void destroy_async(struct dev_sta
 		usb_kill_urb(urb);
 		usb_put_urb(urb);
--
 	while (as) {
 		free_async(as);
 		as = async_getcompleted(ps);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&udev->filelist)) {
 		ps = list_entry(udev->filelist.next, struct dev_state, list);
 		destroy_all_async(ps);
@@ -2038,6 +2065,12 @@ static void usbdev_remove(struct usb_dev
 			kill_pid_info_as_cred(ps->discsignr, &sinfo,
 					ps->disc_pid, ps->cred, ps->secid);
--
 	while (pos < len) {
 		int tmp;
 		u32 index;
@@ -507,6 +512,12 @@ static ssize_t cxacru_sysfs_store_adsl_c
 			atm_info(instance->usbatm, "config%s\n", log);
 			num = 0;
--
 		while (l--) {
 			offd = le32_to_cpu(buf[offb++]);
 			if (offd >= size) {
@@ -720,6 +736,12 @@ static int cxacru_cm_get_array(struct cx
 				goto cleanup;
 			}
--
 	while ((urb = usbatm_pop_urb(&instance->rx_channel))) {
 		vdbg("%s: processing urb 0x%p", __func__, urb);
 
@@ -574,6 +579,12 @@ static void usbatm_rx_process(unsigned l
 
 		if (usbatm_submit_urb(urb))
--
 	while (!kthread_should_stop()) {
 		if (ret < 0 || sc->reset)
 			ret = uea_start_reset(sc);
@@ -1917,6 +1922,12 @@ static int uea_kthread(void *data)
 		if (ret != -EAGAIN)
 			uea_wait(sc, 0, msecs_to_jiffies(1000));
--
 	while (size) {
 		if (size < sizeof(*notif_hdr)) {
 			missing = sizeof(*notif_hdr) - size;
@@ -146,6 +151,12 @@ static void wa_notif_dispatch(struct wor
 				(size_t)notif_hdr->bLength);
 			break;
--
 	while (!list_empty(&dep->request_list)) {
 		req = next_request(&dep->request_list);
 
 		dwc3_gadget_giveback(dep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (buffer_icap_busy(base_address)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (buffer_icap_busy(base_address)) {
 		retries++;
 		if (retries > XHI_MAX_RETRIES)
 			return -EBUSY;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (buffer_icap_busy(base_address)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (buffer_icap_busy(base_address)) {
 		retries++;
 		if (retries > XHI_MAX_RETRIES)
 			return -EBUSY;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!(c1 & 0x80) && time_before(jiffies, timeout)) {
 		msleep(10);
 		/*
@@ -393,6 +398,12 @@ static int erase_block(int nBlock)
 		 */
 		c1 = *(volatile unsigned char *) (pWritePtr);
--
-	while (check_ioport && check->port1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (check_ioport && check->port1) {
 		if (!request_region(check->port1,
 				   sonypi_device.region_size,
 				   "Sony Programmable I/O Device Check")) {
@@ -1249,9 +1254,20 @@ static int __devinit sonypi_setup_ioport
 		}
--
-	while (ioport_list->port1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioport_list->port1) {
 
 		if (request_region(ioport_list->port1,
 				   sonypi_device.region_size,
@@ -1261,6 +1277,12 @@ static int __devinit sonypi_setup_ioport
 			return 0;
--
-	while (irq_list->irq) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (irq_list->irq) {
 
 		if (!request_irq(irq_list->irq, sonypi_irq,
 				 IRQF_SHARED, "sonypi", sonypi_irq)) {
@@ -1278,6 +1305,12 @@ static int __devinit sonypi_setup_irq(st
 			return 0;
--
 	while ( (dev = pci_get_class(PCI_CLASS_OTHERS << 16, dev))) {
 
 		if (!pci_match_id(applicom_pci_tbl, dev))
@@ -239,6 +244,12 @@ static int __init applicom_init(void)
 		writeb(0x40, apbs[boardno - 1].RamIO + RAM_IT_FROM_PC);
 
--
 	while(1) {
 		/* Stick ourself on the wait queue */
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -612,6 +628,12 @@ static ssize_t ac_read (struct file *fil
 			printk(KERN_DEBUG "Looping in ac_read. loopcount %d\n", loopcount);
 		}
--
 		while (i < count && dtlk_readable()) {
 			ch = dtlk_read_lpc();
 			/*        printk("dtlk_read() reads 0x%02x\n", ch); */
 			if (put_user(ch, buf++))
 				return -EFAULT;
 			i++;
--
 	while (1) {
 		hv_err = sun4v_rng_data_read(data_ra, &ticks);
 		if (hv_err == HV_EOK)
@@ -195,6 +200,12 @@ static int n2rng_generic_read_data(unsig
 			udelay(10000);
 		} else
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		hv_err = n2rng_read_diag_data_one(np, unit,
 						  data_ra, data_len,
 						  &ticks);
@@ -242,6 +258,12 @@ static int n2rng_generic_read_diag_data(
 			return -EIO;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		hv_err = n2rng_write_ctl_one(np, unit, state, control_ra,
 					     np->wd_timeo, &ticks);
 		if (hv_err == HV_EOK)
@@ -270,6 +297,12 @@ static int n2rng_generic_write_control(s
 			udelay(1);
--
 	while (size) {
 		if (mutex_lock_interruptible(&rng_mutex)) {
 			err = -ERESTARTSYS;
@@ -161,6 +166,12 @@ static ssize_t rng_dev_read(struct file
 			err = -ERESTARTSYS;
 			goto out;
--
 	while (*link) {
 		parent = *link;
 		x = rb_entry(parent, struct mmtimer, list);
@@ -276,6 +281,12 @@ static void mmtimer_add_list(struct mmti
 			link = &(*link)->rb_left;
 		else
--
-	while (!mmtimer_setup(x->cpu, COMPARATOR, expires,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!mmtimer_setup(x->cpu, COMPARATOR, expires,
 				&set_completion_time)) {
 		int to;
 
@@ -344,6 +360,12 @@ restart:
 			kfree(x);
--
 	while (nbytes--) {
 		w = rol32(*bytes++, input_rotate & 31);
 		i = (i - 1) & wordmask;
@@ -522,6 +527,12 @@ static void __mix_pool_bytes(struct entr
 		 * input bits across the pool evenly.
 		 */
--
-	while (nbytes--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nbytes--) {
 		w = rol32(*bytes++, input_rotate & 31) ^ f->pool[i & 3] ^
 			f->pool[(i + 1) & 3];
 		f->pool[i & 3] = (w >> 3) ^ twist_table[w & 7];
 		input_rotate += (i++ & 3) ? 7 : 14;
+		if (_cur < timeout) {
--
 	while (nbytes) {
 		extract_buf(r, tmp);
 
@@ -1007,6 +1034,12 @@ static ssize_t extract_entropy(struct en
 		nbytes -= i;
 		buf += i;
--
 	while (op_struct_list) {
 		struct op_struct *toFree = op_struct_list;
 		op_struct_list = op_struct_list->next;
 		kfree(toFree);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (link->open) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+ 		unsigned long long timeout;
+ 		timeout = rdstcll(start) + delta;
+ 		while (link->open) {
 		DEBUGP(3, dev, KERN_INFO MODULE_NAME ": delaying release "
 		       "until process has terminated\n");
  		wait_event(dev->devq, (link->open == 0));
+ 		if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while (link->open) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (link->open) {
 		printk(KERN_INFO MODULE_NAME ": delaying release until "
 		       "process has terminated\n");
 		/* note: don't interrupt us:
@@ -1733,6 +1738,12 @@ static void cmm_cm4000_release(struct pc
 		 * the devices _first_ !
--
 	while (read_reg(info, (unsigned char)(channel+STAR)) & BIT2) {
 		udelay(1);
 		if (i++ == 1000)
 			return false;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (fifo_count) {
 		data   = read_reg(info, CHA + RXFIFO);
 		status = read_reg(info, CHA + RXFIFO);
@@ -936,6 +952,12 @@ static void rx_ready_async(MGSLPC_INFO *
 				flag = TTY_FRAME;
 		}
--
 	while (info->tx_count && fifo_count) {
 		c = min(2, min_t(int, fifo_count, min(info->tx_count, TXBUFSIZE - info->tx_get)));
 
@@ -1024,6 +1051,12 @@ static void tx_ready(MGSLPC_INFO *info,
 		info->tx_count -= c;
 		info->tx_get = (info->tx_get + c) & (TXBUFSIZE - 1);
--
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while(info) {
 		if (info == remove_info) {
 			if (last)
@@ -2755,6 +2804,12 @@ static void mgslpc_remove_device(MGSLPC_
 		}
 		last = info;
--
 	while(end_time-- && !info->irq_occurred) {
 		msleep_interruptible(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-	while(count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(count) {
 		if (count > 16)
 			linecount = 16;
 		else
@@ -3836,6 +3907,12 @@ static void trace_block(MGSLPC_INFO *inf
 
--
 		while (!data_to_read) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			spin_unlock(&ipmi_read_lock);
 			schedule();
 			spin_lock(&ipmi_read_lock);
+			if (_cur < timeout) {
--
 	while (rcvrs) {
 		rcvr = rcvrs;
 		rcvrs = rcvr->next;
 		kfree(rcvr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (user->gets_events && !list_empty(&intf->waiting_events)) {
 		list_for_each_entry_safe(msg, msg2, &intf->waiting_events, link)
 			list_move_tail(&msg->link, &msgs);
@@ -1218,6 +1234,12 @@ int ipmi_set_gets_events(ipmi_user_t use
 
 		spin_lock_irqsave(&intf->events_lock, flags);
--
 	while (rcvrs) {
 		rcvr = rcvrs;
 		rcvrs = rcvr->next;
 		kfree(rcvr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (smi->proc_entries) {
 		entry = smi->proc_entries;
 		smi->proc_entries = entry->next;
@@ -2097,6 +2135,12 @@ static void remove_proc_entries(ipmi_smi
 		remove_proc_entry(entry->name, smi->proc_dir);
 		kfree(entry->name);
--
 		while (*p) {
 			int size = strlen(p);
 
@@ -4417,6 +4466,12 @@ static void send_panic_events(char *str)
 				       intf->channels[0].address,
 				       intf->channels[0].lun,
--
 	while (bn) {
 		ret = bsr_add_node(bn);
 		if (ret) {
@@ -288,6 +293,12 @@ static int bsr_create_devs(struct device
 			return ret;
 		}
--
 	while (count < len - 1) {
 		burstcnt = get_burstcount(chip);
 		for (; burstcnt > 0 && count < len - 1; burstcnt--) {
@@ -340,6 +345,12 @@ static int tpm_tis_send_data(struct tpm_
 			rc = -EIO;
 			goto out_err;
--
-	while (cursor < to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cursor < to) {
 		if (!devmem_is_allowed(pfn)) {
 			printk(KERN_INFO
 		"Program %s tried to access /dev/mem between %Lx->%Lx.\n",
@@ -73,6 +78,12 @@ static inline int range_is_allowed(unsig
 		}
--
 	while (count) {
 		pfn = *ppos / PAGE_SIZE;
 		if (pfn > saved_max_pfn)
@@ -383,6 +399,12 @@ static ssize_t read_oldmem(struct file *
 		*ppos += csize;
 		read += csize;
--
 	while (j < (pg_start + mem->page_count)) {
 		if (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (j < (io_pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (j < (io_pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count)) {
 		if (!PGE_EMPTY(agp_bridge, RD_GATT(j))) {
 			pr_debug("i460_insert_memory_small_io_page: GATT[%d]=0x%x is busy\n",
 				 j, RD_GATT(j));
 			return -EBUSY;
 		}
--
 	while (j < (pg_start + mem->page_count)) {
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = SVRWRKS_GET_GATT(addr);
 		if (!PGE_EMPTY(agp_bridge, readl(cur_gatt+GET_GATT_OFF(addr))))
 			return -EBUSY;
 		j++;
--
 	while (j < (io_pg_start + io_pg_count)) {
 		if (hp->gatt[j]) {
 			return -EBUSY;
 		}
 		j++;
+		if (_cur < timeout) {
--
 	while (j < (pg_start + mem->page_count)) {
 		if (!PGE_EMPTY(agp_bridge, readl(agp_bridge->gatt_table+j)))
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (j < (pg_start + mem->page_count)) {
 		if (table[j])
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (j < (io_pg_start + io_pg_count)) {
 		if (info->gatt[j])
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (j < (pg_start + mem->page_count)) {
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
 		if (!PGE_EMPTY(agp_bridge, readl(cur_gatt+GET_GATT_OFF(addr))))
 			return -EBUSY;
 		j++;
--
 		while (!cap_ptr) {
 			gfxcard = pci_get_class(PCI_CLASS_DISPLAY_VGA<<8, gfxcard);
 			if (!gfxcard) {
@@ -444,6 +460,12 @@ static int __devinit agp_amdk7_probe(str
 				return -ENODEV;
 			}
--
 	while (j < (pg_start + mem->page_count)) {
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
 		if (!PGE_EMPTY(agp_bridge,readl(cur_gatt+GET_GATT_OFF(addr))))
 			return -EBUSY;
 		j++;
--
 	while (client) {
 		struct agp_file_private *priv;
 
@@ -353,6 +358,12 @@ static void agp_remove_all_clients(struc
 		}
 		client = client->next;
--
 	while (memory) {
 		temp = memory;
 		memory = memory->next;
 		agp_free_memory_wrap(temp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (buf) {
 		port->stats.bytes_discarded += buf->len - buf->offset;
 		if (add_inbuf(port->in_vq, buf) < 0) {
@@ -422,6 +427,12 @@ static void discard_port_data(struct por
 		}
 		port->inbuf = NULL;
--
 	while ((buf = virtqueue_get_buf(port->out_vq, &len))) {
 		kfree(buf);
 		port->outvq_full = false;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((buf = virtqueue_get_buf(vq, &len))) {
 		spin_unlock(&portdev->c_ivq_lock);
 
@@ -1494,6 +1521,12 @@ static void control_work_handler(struct
 				 "Error adding buffer to queue\n");
 			free_buf(buf);
--
 		while (msg->len && len) {
 			*data++ = IN32(id, I2CRXTX);
 			msg->len--;
 			len--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (davinci_i2c_read_reg(dev, DAVINCI_I2C_STR_REG)
 	       & DAVINCI_I2C_STR_BB) {
 		if (to_cnt <= DAVINCI_I2C_MAX_TRIES) {
@@ -295,6 +300,12 @@ static int i2c_davinci_wait_bus_not_busy
 		}
 		if (allow_sleep)
--
 	while (!(status & SMSTA_XEN) && timeout--) {
 		msleep(1);
 		status = reg_read(smbus, REG_SMSTA);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (num--) {
 		const char *str = val & bits->mask ? bits->set : bits->unset;
 		if (str)
 			printk("%s ", str);
 		bits++;
+		if (_cur < timeout) {
--
 	while (timeout-- && readl(_ISR(i2c)) & (ISR_IBB | ISR_UB)) {
 		if ((readl(_ISR(i2c)) & ISR_SAD) != 0)
 			timeout += 4;
 
 		msleep(2);
 		show_state(i2c);
--
 	while (time_before(jiffies, timeout)) {
 		if (i2c_debug > 1)
 			dev_dbg(&i2c->adap.dev, "%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\n",
@@ -354,6 +381,12 @@ static int i2c_pxa_wait_master(struct px
 		}
 
--
 	while (time_before(jiffies, timeout)) {
 		if (i2c_debug > 1)
 			dev_dbg(&i2c->adap.dev, "%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\n",
@@ -402,6 +440,12 @@ static int i2c_pxa_wait_slave(struct pxa
 		}
 
--
 	while (timeout-- && readl(_ISR(i2c)) & (ISR_IBB | ISR_UB)) {
 		udelay(1000);
 		show_state(i2c);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (readl(i2c->regs + MXS_I2C_QUEUESTAT)
 			& MXS_I2C_QUEUESTAT_RD_QUEUE_EMPTY) {
 			if (time_after(jiffies, timeout))
 				return -ETIMEDOUT;
 			cond_resched();
+			if (_cur < timeout) {
--
 	while (!iface->result) {
 		if (!wait_for_completion_timeout(&iface->complete,
 			adap->timeout)) {
 			iface->result = -1;
 			dev_err(&adap->dev, "master transfer timeout\n");
 		}
--
 	while (!iface->result) {
 		if (!wait_for_completion_timeout(&iface->complete,
 			adap->timeout)) {
 			iface->result = -1;
 			dev_err(&adap->dev, "smbus transfer timeout\n");
 		}
--
-	while (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &
 						MV64XXX_I2C_REG_CONTROL_IFLG) {
 		status = readl(drv_data->reg_base + MV64XXX_I2C_REG_STATUS);
 		mv64xxx_i2c_fsm(drv_data, status);
 		mv64xxx_i2c_do_action(drv_data);
 		rc = IRQ_HANDLED;
--
 	while (i < (len - 1)) {
 		WR(adap, PSC_SMBTXRX, 0);
 		if (wait_for_rx_byte(adap, &buf[i]))
 			return -EIO;
 
 		i++;
--
 	while (i < (len-1)) {
 		data = buf[i];
 		WR(adap, PSC_SMBTXRX, data);
 		if (wait_ack(adap))
 			return -EIO;
 		i++;
--
 	while (length--) {
 		if (!length)	/* need to send Stop before reading last byte */
 			at91_twi_write(AT91_TWI_CR, AT91_TWI_STOP);
@@ -98,6 +103,12 @@ static int xfer_read(struct i2c_adapter
 			return -ETIMEDOUT;
 		}
--
@@ -448,12 +448,23 @@ static int stu300_wait_while_busy(struct
 	for (i = 0; i < BUSY_RELEASE_ATTEMPTS; i++) {
 		timeout = jiffies + STU300_TIMEOUT;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
--
 		while (!time_after(jiffies, timeout)) {
 			/* Is not busy? */
 			if ((stu300_r8(dev->virtbase + I2C_SR1) &
 			     I2C_SR1_BUSY_IND) == 0)
 				return 0;
 			msleep(1);
--
 	while ((iface->msgs_push < iface->msgs_num)
 	    && (i2c_rd16(iface, S6_I2C_STATUS) & (1 << S6_I2C_STATUS_TFNF))) {
 		struct i2c_msg *m = &iface->msgs[iface->msgs_push];
@@ -110,6 +115,12 @@ static void s6i2c_handle_interrupt(struc
 			iface->push = 0;
 			iface->msgs_push += 1;
--
 	while ((res = platform_get_resource(dev, IORESOURCE_IRQ, k))) {
 		for (n = res->start; hook && n <= res->end; n++) {
 			if (request_irq(n, sh_mobile_i2c_isr, 0,
@@ -552,6 +557,12 @@ static int sh_mobile_i2c_hook_irqs(struc
 			}
 		}
--
 	while ((in_8(&iic->directcntl) & mask) != mask){
 		if (unlikely(time_after(jiffies, x)))
 			return -1;
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (readb(i2c->base + MPC_I2C_SR) & CSR_MBB) {
 		if (signal_pending(current)) {
 			dev_dbg(i2c->dev, "Interrupted\n");
@@ -524,6 +529,12 @@ static int mpc_xfer(struct i2c_adapter *
 			return -EIO;
 		}
--
 		while ((adap_info->pch_data[i].pch_i2c_xfer_in_progress)) {
 			/* Wait until all channel transfers are completed */
 			msleep(20);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (!time_after(jiffies, timeout)) {
 			if ((readl(dev->virtbase + I2C_CR) &
 				(I2C_CR_FTX | I2C_CR_FRX)) == 0)
 					return 0;
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (len--) {
 		u16 data = i2c->tx_msg->buf[i2c->tx_pos++];
 		if ((xiic_tx_space(i2c) == 0) && (i2c->nmsgs == 1)) {
@@ -313,6 +318,12 @@ static void xiic_fill_tx_fifo(struct xii
 			dev_dbg(i2c->adap.dev.parent, "%s TX STOP\n", __func__);
 		}
--
 	while (err && tries--) {
 		mdelay(1);
 		err = xiic_bus_busy(i2c);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (tptr < num) {
 		pmsg = &msgs[tptr];
 		dev_dbg(&adap->dev, "R: %d T: %d\n", rptr, tptr);
@@ -346,6 +351,12 @@ static int cpm_i2c_xfer(struct i2c_adapt
 		if (pmsg->flags & I2C_M_RD)
 			rptr++;
--
 	while (tptr < num) {
 		/* Check for outstanding messages */
 		dev_dbg(&adap->dev, "test ready.\n");
@@ -386,6 +402,12 @@ static int cpm_i2c_xfer(struct i2c_adapt
 			if (ret)
 				goto out_err;
--
 	while (ioread16(dev->base + SMCR) & SMCR_BBSY) {
 		if (time_after(jiffies, timeout)) {
 			dev_warn(dev->dev, "timeout waiting for bus ready\n");
@@ -138,6 +143,12 @@ static int highlander_i2c_wait_for_bbsy(
 		}
 
--
-		while (!(omap_i2c_read_reg(dev, OMAP_I2C_SYSS_REG) &
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!(omap_i2c_read_reg(dev, OMAP_I2C_SYSS_REG) &
 			 SYSS_RESETDONE_MASK)) {
 			if (time_after(jiffies, timeout)) {
 				dev_warn(dev->dev, "timeout waiting "
@@ -343,6 +348,12 @@ static int omap_i2c_init(struct omap_i2c
 				return -ETIMEDOUT;
--
 	while (omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG) & OMAP_I2C_STAT_BB) {
 		if (time_after(jiffies, timeout)) {
 			dev_warn(dev->dev, "timeout waiting for bus ready\n");
 			return -ETIMEDOUT;
 		}
 		msleep(1);
--
 		while (con & OMAP_I2C_CON_STT) {
 			con = omap_i2c_read_reg(dev, OMAP_I2C_CON_REG);
 
@@ -576,6 +603,12 @@ static int omap_i2c_xfer_msg(struct i2c_
 				return -ETIMEDOUT;
 			}
--
-	while (--timeout && !(*stat & OMAP_I2C_STAT_XUDF)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (--timeout && !(*stat & OMAP_I2C_STAT_XUDF)) {
 		if (*stat & (OMAP_I2C_STAT_NACK | OMAP_I2C_STAT_AL)) {
 			omap_i2c_ack_stat(dev, *stat & (OMAP_I2C_STAT_XRDY |
 							OMAP_I2C_STAT_XDR));
@@ -787,6 +825,12 @@ static int errata_omap3_1p153(struct oma
 
--
 			while (num_bytes) {
 				num_bytes--;
 				w = omap_i2c_read_reg(dev, OMAP_I2C_DATA_REG);
@@ -893,6 +942,12 @@ complete:
 								" requested\n");
 					break;
--
 			while (num_bytes) {
 				num_bytes--;
 				w = 0;
@@ -942,6 +1002,12 @@ complete:
 					goto complete;
 
--
 	while (i2c_readl(i2c_dev, I2C_FIFO_CONTROL) &
 		(I2C_FIFO_CONTROL_TX_FLUSH | I2C_FIFO_CONTROL_RX_FLUSH)) {
 		if (time_after(jiffies, timeout)) {
@@ -212,6 +217,12 @@ static int tegra_i2c_flush_fifos(struct
 			return -ETIMEDOUT;
 		}
--
 	while (length--) {
 		if (!poll_status(I2C_STATUS_TFNF)) {
 			dev_dbg(&adap->dev, "Tx FIFO Not Full timeout\n");
@@ -77,6 +82,12 @@ static int xfer_read(struct i2c_adapter
 		/* read the data to buf */
 		*buf = (readl(I2C_DATACMD) & I2C_DATACMD_DAT_MASK);
--
 	while (length--) {
 		/* send addr */
 		writel(i2c_reg | I2C_DATACMD_WRITE, I2C_DATACMD);
@@ -110,6 +126,12 @@ static int xfer_write(struct i2c_adapter
 		/* read the data to buf */
 		i2c_reg++;
--
 	while (dw_readl(dev, DW_IC_STATUS) & DW_IC_STATUS_ACTIVITY) {
 		if (timeout <= 0) {
 			dev_warn(dev->dev, "timeout waiting for bus ready\n");
@@ -322,6 +327,12 @@ static int i2c_dw_wait_bus_not_busy(stru
 		}
 		timeout--;
--
 	while (!(status & I2C_PCF_BB) && --timeout) {
 		udelay(100); /* wait for 100 us */
 		status = get_pcf(adap, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((*status & I2C_PCF_PIN) && --timeout) {
 		adap->waitforpin(adap->data);
 		*status = get_pcf(adap, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (curmsg < num) {
 		state = pca_status(adap);
 
@@ -341,6 +346,12 @@ static int pca_xfer(struct i2c_adapter *
 
 		if (!completed)
--
 	while (id->name[0]) {
 		if (strcmp(client->name, id->name) == 0)
 			return id;
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (strlen(eids->sig)) {
 		if (!strcmp(eids->sig, edev->id.sig) &&
 		    edev->state & EISA_CONFIG_ENABLED) {
@@ -123,6 +128,12 @@ static int eisa_bus_match(struct device
 		}
 
--
 	while ((z = zorro_find_device(ZORRO_WILDCARD, z))) {
 		unsigned long board;
 		struct ide_hw hw[MAX_NUM_HWIFS], *hws[MAX_NUM_HWIFS];
@@ -228,6 +233,12 @@ fail_base2:
 		}
 
--
 	while (cle->id_model) {
 		if (strcmp(cle->id_model, (char *)&id[ATA_ID_PROD]) == 0 &&
 		    (cle->id_firmware == NULL ||
 		     strstr((char *)&id[ATA_ID_FW_REV], cle->id_firmware)))
 			return cle->cd_flags;
 		cle++;
--
 	while (len) {
 		unsigned nr_bytes = min(len, cursg->length - cmd->cursg_ofs);
 		int page_is_high;
@@ -275,6 +280,12 @@ void ide_pio_bytes(ide_drive_t *drive, s
 			local_irq_restore(flags);
 
--
 	while (time_before(jiffies, timeout)) {
 		if (ide_do_test_unit_ready(drive, disk) == 0)
 			return 0;
@@ -702,6 +707,12 @@ static int idetape_wait_ready(ide_drive_
 			     (tape->ascq == 1 || tape->ascq == 8)))
 			return -EIO;
--
 	while (bcount) {
 		unsigned int count = min(tape->buffer_size, bcount);
 
 		idetape_queue_rw_tail(drive, REQ_IDETAPE_WRITE, count);
 		bcount -= count;
+		if (_cur < timeout) {
--
-	while (done < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (done < count) {
 		size_t todo;
 
 		/* flush if staging buffer is full */
@@ -1217,6 +1244,12 @@ static ssize_t idetape_chrdev_write(stru
 		tape->cur += todo;
--
 	while (count--) {
 		__raw_writew(le16_to_cpu(*ptr), (void __iomem *)port);
 		ptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (lap->device) {
 		if (lap->device == pdev->device &&
 		    lap->subvendor == pdev->subsystem_vendor &&
@@ -282,6 +287,12 @@ static u8 piix_cable_detect(ide_hwif_t *
 			return ATA_CBL_PATA40_SHORT;
 		}
--
 	while (i && sg_dma_len(sg)) {
 		dma_addr_t cur_addr;
 		int cur_len;
 		cur_addr = sg_dma_address(sg);
 		cur_len = sg_dma_len(sg);
 
-		while (cur_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (cur_len) {
 			if (count++ >= IOC4_PRD_ENTRIES) {
 				printk(KERN_WARNING
 				       "%s: DMA table too small\n",
@@ -455,10 +465,22 @@ static int sgiioc4_build_dmatable(ide_dr
 				cur_addr += bcount;
--
 		while (hi > lo) {
 			mid = (lo + hi) / 2;
 			if (sense_data_texts[mid].asc_ascq == key ||
@@ -293,6 +298,12 @@ void ide_cd_log_error(const char *name,
 				hi = mid;
 			else
--
 		while (stat & 0x03) {
 			udelay(1);
 			(void) pci_read_config_byte(dev, 0x43, &stat);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (cur_len) {
 			if (count++ >= PRD_ENTRIES)
 				goto use_pio_instead;
@@ -267,6 +272,12 @@ static int tx4939ide_build_dmatable(ide_
 			*table++ = cur_addr;
 			cur_addr += bcount;
--
 	while (count--) {
 		__raw_writew(le16_to_cpu(*ptr), (void __iomem *)port);
 		ptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (g->name || (d && d->name)) {
 		/* read settings in the alphabetical order */
 		if (g->name && d && d->name) {
@@ -318,6 +323,12 @@ static int ide_settings_proc_show(struct
 		if (ds->set)
 			seq_printf(m, "w");
--
 	while (count && isspace(*s)) {
 		--count;
 		++s;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (s != end && *s == ' ')
 		++s;
 	/* compress internal blanks and strip trailing blanks */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (s != end && *s) {
 		if (*s++ != ' ' || (s != end && *s && *s != ' '))
 			*p++ = *(s-1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (p != end)
@@ -508,6 +519,11 @@ int ide_wait_not_busy(ide_hwif_t *hwif,
 {
 	u8 stat = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
--
 	while (timeout--) {
 		/*
 		 * Turn this into a schedule() sleep once I'm sure
@@ -526,6 +542,12 @@ int ide_wait_not_busy(ide_hwif_t *hwif,
 			return -ENODEV;
 		touch_softlockup_watchdog();
--
 	while (lap->device) {
 		if (lap->device == pdev->device &&
 		    lap->subvendor == pdev->subsystem_vendor &&
 		    lap->subdevice == pdev->subsystem_device)
 			return ATA_CBL_PATA40_SHORT;
 		lap++;
--
 	while (i && sg_dma_len(sg)) {
 		u32 cur_addr;
 		u32 cur_len;
@@ -232,7 +237,12 @@ static int auide_build_dmatable(ide_driv
 		cur_addr = sg_dma_address(sg);
 		cur_len = sg_dma_len(sg);
--
-		while (cur_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (cur_len) {
 			u32 flags = DDMA_FLAGS_NOIE;
 			unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
 
@@ -264,9 +274,21 @@ static int auide_build_dmatable(ide_driv
 
--
 	while (i && sg_dma_len(sg)) {
 		u32 cur_addr;
 		u32 cur_len;
@@ -1502,7 +1507,12 @@ static int pmac_ide_build_dmatable(ide_d
 			}
 			return 0;
--
-		while (cur_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (cur_len) {
 			unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
 
 			if (count++ >= MAX_DCMDS) {
@@ -1519,9 +1529,21 @@ static int pmac_ide_build_dmatable(ide_d
 			cur_addr += tc;
--
 		while (cur_len) {
 			if (count++ >= PRD_ENTRIES)
 				goto use_pio_instead;
@@ -153,6 +158,12 @@ int ide_build_dmatable(ide_drive_t *driv
 			*table++ = cpu_to_le32(xcount);
 			cur_addr += bcount;
--
 	while (port->rport_task) {
 		if (port->rport_task == RPORT_ADD) {
 			port->rport_task = RPORT_NONE;
@@ -648,6 +653,12 @@ void zfcp_scsi_rport_work(struct work_st
 			port->rport_task = RPORT_NONE;
 			zfcp_scsi_rport_block(port);
--
-	while (offset < length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < length) {
 		rec_length = min((u16) ZFCP_DBF_PAY_MAX_REC,
 				 (u16) (length - offset));
 		memcpy(pl->data, data + offset, rec_length);
@@ -48,6 +53,12 @@ void zfcp_dbf_pl_write(struct zfcp_dbf *
 
--
 	while (payload->counter < scount && (char *)pl[payload->counter]) {
 		memcpy(payload->data, (char *)pl[payload->counter], length);
 		debug_event(dbf->pay, 1, payload, zfcp_dbf_plen(length));
 		payload->counter++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (size) {
 		length = min((unsigned int)size, sg->length);
 		if (copy_from_user(sg_virt(sg++), user_buffer, length))
 			return -EFAULT;
 		user_buffer += length;
 		size -= length;
--
 	while (size) {
 		length = min((unsigned int) size, sg->length);
 		if (copy_to_user(user_buffer, sg_virt(sg++), length))
 			return -EFAULT;
 		user_buffer += length;
 		size -= length;
--
 	while ((dev = bus_find_device(&ap_bus_type, NULL, NULL,
 		    __ap_match_all)))
 	{
 		device_unregister(dev);
 		put_device(dev);
+		if (_cur < timeout) {
--
 	while (erp_done != erp) {
 
 		if (erp_done == NULL)	/* end of chain reached */
@@ -2639,6 +2644,12 @@ dasd_3990_erp_handle_match_erp(struct da
 		/* free the finished erp request */
 		dasd_free_erp_request(erp_free, erp_free->memdev);
--
 	}			/* end while */
 
 	if (erp->retries > 0) {
diff -u -p a/s390/block/dasd_alias.c b/s390/block/dasd_alias.c
--- a/s390/block/dasd_alias.c
+++ b/s390/block/dasd_alias.c
--
-	while (!list_empty(&active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&active)) {
 		device = list_first_entry(&active, struct dasd_device,
 					  alias_list);
 		spin_unlock_irqrestore(&lcu->lock, flags);
@@ -852,6 +857,12 @@ static void flush_all_alias_devices_on_l
 		if (device == list_first_entry(&active,
--
 		while (seg_len) {
 			if (new_track) {
 				trkid = recid;
@@ -2452,6 +2457,12 @@ static struct dasd_ccw_req *dasd_eckd_bu
 				idaw_len = 0;
 				end_idaw = 0;
--
 			while (seg_len) {
 				if (new_track) {
 					trkid = recid;
@@ -2727,6 +2743,12 @@ static struct dasd_ccw_req *dasd_eckd_bu
 				if (IS_ERR(last_tidaw))
 					return ERR_PTR(-EINVAL);
--
-	while (from <= to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (from <= to) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       from, ((int *) from)[0], ((int *) from)[1]);
@@ -3618,6 +3645,12 @@ dasd_eckd_dump_ccw_range(struct ccw1 *fr
 		}
--
 	while (dasd_eer_get_free_bytes(eerb) < count + sizeof(count)) {
 		if (eerb->residual > 0) {
 			eerb->tail += eerb->residual;
@@ -202,6 +207,12 @@ static int dasd_eer_start_record(struct
 		eerb->tail += tailcount;
 		if (eerb->tail >= eerb->buffersize)
--
-		while (!tc) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!tc) {
 			tc = dasd_eer_read_buffer(eerb, (char *) &tailcount,
 						  sizeof(tailcount));
 			if (!tc) {
@@ -627,6 +643,12 @@ static ssize_t dasd_eer_read(struct file
 					return -ERESTARTSYS;
--
 	while (fdata->start_unit <= fdata->stop_unit) {
 		cqr = base->discipline->format_device(base, fdata);
 		if (IS_ERR(cqr))
@@ -192,6 +197,12 @@ static int dasd_format(struct dasd_block
 			return rc;
 		}
--
-	while (act <= end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (act <= end) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       act, ((int *) act)[0], ((int *) act)[1]);
@@ -526,6 +531,12 @@ dasd_fba_dump_sense(struct dasd_device *
 				       [(count>>2)]);
--
-	while (act <= end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (act <= end) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       act, ((int *) act)[0], ((int *) act)[1]);
@@ -548,6 +564,12 @@ dasd_fba_dump_sense(struct dasd_device *
 				       [(count>>2)]);
--
-	while (act <= last) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (act <= last) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       act, ((int *) act)[0], ((int *) act)[1]);
@@ -566,6 +593,12 @@ dasd_fba_dump_sense(struct dasd_device *
 				       [(count>>2)]);
--
 	while (i--) {
 		blk_cleanup_queue(xpram_queues[i]);
 		put_disk(xpram_disks[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (from <= to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (from <= to) {
 		sprintf(bus_id, "%01x.%01x.%04x",
 			from_id0, from_id1, from++);
 		devmap = dasd_add_busid(bus_id, features);
 		if (IS_ERR(devmap))
 			return (char *)devmap;
--
 	while (priv->buffer_free) {
 		rc = vmlogrdr_receive_data(priv);
 		if (rc) {
@@ -490,6 +495,12 @@ static ssize_t vmlogrdr_read(struct file
 			if (rc)
 				return rc;
--
 	while (sclp_con_queue_running) {
 		spin_unlock_irqrestore(&sclp_con_lock, flags);
 		sclp_sync_wait();
 		spin_lock_irqsave(&sclp_con_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (list_empty(&sclp_con_pages)) {
 				if (sclp_con_suspended)
 					goto out;
 				spin_unlock_irqrestore(&sclp_con_lock, flags);
 				sclp_sync_wait();
 				spin_lock_irqsave(&sclp_con_lock, flags);
--
-			while (list_empty(&sclp_tty_pages)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (list_empty(&sclp_tty_pages)) {
 				spin_unlock_irqrestore(&sclp_tty_lock, flags);
 				if (may_fail)
 					goto out;
 				else
 					sclp_sync_wait();
--
 	while (!cp->write) {
 		raw3270_wait_cons_dev(cp->view.dev);
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-			while (!raw3270_request_final(rq)) {
-				wait_cons_dev();
-				barrier();
+		if (rc == 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
--
+				while (!raw3270_request_final(rq)) {
+					wait_cons_dev();
+					barrier();
+						if (_cur < timeout) {
+								rdstcll(_cur);
+						}
--
 	while (!list_empty(&rp->view_list)) {
 		v = list_entry(rp->view_list.next, struct raw3270_view, list);
 		if (v->fn->release)
@@ -1285,6 +1302,12 @@ raw3270_remove (struct ccw_device *cdev)
 		spin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);
 		raw3270_del_view(v);
--
-			while (list_empty(&sclp_vt220_empty)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (list_empty(&sclp_vt220_empty)) {
 				spin_unlock_irqrestore(&sclp_vt220_lock, flags);
 				if (may_fail || sclp_vt220_suspended)
 					goto out;
 				else
 					sclp_sync_wait();
--
 	while (sclp_vt220_queue_running) {
 		spin_unlock_irqrestore(&sclp_vt220_lock, flags);
 		sclp_sync_wait();
 		spin_lock_irqsave(&sclp_vt220_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (sclp_running_state != sclp_running_state_idle) {
 		/* Check for expired request timer */
 		if (timer_pending(&sclp_request_timer) &&
@@ -476,6 +481,12 @@ sclp_sync_wait(void)
 		    del_timer(&sclp_request_timer))
 			sclp_request_timer.function(sclp_request_timer.data);
--
 	while (ptr->cda) {
 		kfree((void *)(addr_t) ptr->cda);
 		ptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (urd->open_flag) {
 		spin_unlock(&urd->open_lock);
 		if (file->f_flags & O_NONBLOCK) {
@@ -723,6 +739,12 @@ static int ur_open(struct inode *inode,
 			goto fail_put;
 		}
--
 	while (zfcpdump_save_areas[i]) {
 		unsigned long cp_start, cp_end; /* copy range */
 		unsigned long sa_start, sa_end; /* save area range */
@@ -274,6 +279,12 @@ static int zcore_add_lc(char __user *buf
 			return -EFAULT;
 next:
--
 		while (line->len < tp->cx) {
 			cell = line->cells + line->len;
 			cell->character = tp->view.ascebc[' '];
 			cell->highlight = tp->highlight;
 			cell->f_color = tp->f_color;
 			line->len++;
--
 	while (line->len < tp->cx) {
 		line->cells[line->len].character = tp->view.ascebc[' '];
 		line->cells[line->len].highlight = TAX_RESET;
 		line->cells[line->len].f_color = TAC_RESET;
 		line->len++;
+		if (_cur < timeout) {
--
 		while (c) {
 			if (forced_cleanup ||
 			    atomic_read(&c->state) ==
@@ -388,6 +393,12 @@ static inline void qeth_cleanup_handled_
 				c = c->next_pending;
 			}
--
 	while (skb) {
 		QETH_CARD_TEXT_(q->card, 5, "skbn%d", notification);
 		QETH_CARD_TEXT_(q->card, 5, "%lx", (long) skb);
@@ -1105,6 +1121,12 @@ static void qeth_notify_skbs(struct qeth
 			skb = NULL;
 		else
--
 	while (skb) {
 		QETH_CARD_TEXT(buf->q->card, 5, "skbr");
 		QETH_CARD_TEXT_(buf->q->card, 5, "%lx", (long) skb);
 		atomic_dec(&skb->users);
 		dev_kfree_skb_any(skb);
 		skb = skb_dequeue(&buf->skb_list);
--
 	while (known_devices[i][QETH_DEV_MODEL_IND]) {
 		if ((CARD_RDEV(card)->id.dev_type ==
 				known_devices[i][QETH_DEV_TYPE_IND]) &&
@@ -1447,6 +1485,12 @@ static int qeth_determine_card_type(stru
 			return 0;
 		}
--
 		while (!atomic_read(&reply->received)) {
 			if (time_after(jiffies, timeout))
 				goto time_err;
 			cpu_relax();
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (buffer->element[e].addr) {
 			unsigned long phys_aob_addr;
 
@@ -3443,6 +3503,12 @@ static void qeth_qdio_cq_handler(struct
 			buffer->element[e].length = 0;
 
--
 	while (atomic_dec_return(&queue->state)) {
 		flush_count = 0;
 		start_index = queue->next_buf_to_fill;
@@ -3877,6 +3948,12 @@ int qeth_do_send_packet(struct qeth_card
 			flush_count += qeth_flush_buffers_on_no_pci(queue);
 		if (flush_count)
--
 	while (skb_len) {
 		data_len = min(skb_len, (int)(element->length - offset));
 		if (data_len) {
@@ -4839,6 +4921,12 @@ struct sk_buff *qeth_core_get_next_skb(s
 		} else {
 			offset += data_len;
--
-	while ((skb = skb_dequeue(&conn->collect_queue))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&conn->collect_queue))) {
 		header.next = conn->tx_buff->len + skb->len + NETIUCV_HDRLEN;
 		memcpy(skb_put(conn->tx_buff, NETIUCV_HDRLEN), &header,
 		       NETIUCV_HDRLEN);
@@ -764,6 +769,12 @@ static void conn_action_txdone(fsm_insta
 		stat_maxcq++;
--
 	while ((skb = skb_dequeue(q))) {
 		atomic_dec(&skb->users);
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&iucv_connection_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&iucv_connection_list)) {
 		cp = list_entry(iucv_connection_list.next,
 				struct iucv_connection, list);
 		ndev = cp->netdev;
@@ -2184,6 +2211,12 @@ static void __exit netiucv_exit(void)
 
--
 	while ((skb = skb_dequeue(q))) {
 		atomic_dec(&skb->users);
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = skb_dequeue(&ch->io_queue))) {
 		priv->stats.tx_packets++;
 		priv->stats.tx_bytes += skb->len - LL_HEADER_LENGTH;
@@ -277,6 +293,12 @@ static void chx_txdone(fsm_instance *fi,
 		}
 		atomic_dec(&skb->users);
--
-		while ((skb = skb_dequeue(&ch->collect_queue))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((skb = skb_dequeue(&ch->collect_queue))) {
 			skb_copy_from_linear_data(skb,
 				skb_put(ch->trans_skb, skb->len), skb->len);
 			priv->stats.tx_packets++;
@@ -304,6 +331,12 @@ static void chx_txdone(fsm_instance *fi,
 			atomic_dec(&skb->users);
--
 	while ((skb = skb_dequeue(&ch->io_queue))) {
 		priv->stats.tx_packets++;
 		priv->stats.tx_bytes += skb->len - TH_HEADER_LENGTH;
@@ -1256,6 +1294,12 @@ static void ctcmpc_chx_txdone(fsm_instan
 		}
 		atomic_dec(&skb->users);
--
 		while (card->rx.b_count) {
 			buffer = &card->qdio.in_q->bufs[card->rx.b_index];
 			if (!(card->rx.qdio_err &&
@@ -512,6 +517,12 @@ static int qeth_l2_poll(struct napi_stru
 				goto out;
 			else
--
-	while (!list_empty(&card->ipm_list)){
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&card->ipm_list)){
 		ipm = list_entry(card->ipm_list.next,
 				 struct lcs_ipm_list, list);
 		list_del(&ipm->list);
@@ -468,6 +473,12 @@ lcs_clear_multicast_list(struct lcs_card
 			spin_lock_irqsave(&card->ipm_lock, flags);
--
-		while (channel->io_idx != index) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (channel->io_idx != index) {
 			__lcs_processed_buffer(channel,
 					       channel->iob + channel->io_idx);
 			channel->io_idx =
 				(channel->io_idx + 1) & (LCS_NUM_BUFFS - 1);
+				if (_cur < timeout) {
--
-	while (*buf) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (*buf) {
 		if (!isxdigit(*buf++))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!list_empty(tbd_list)) {
 		todo = list_entry(tbd_list->next, struct qeth_ipaddr, entry);
 		list_del(&todo->entry);
@@ -481,6 +497,12 @@ void qeth_l3_set_ip_addr_list(struct qet
 				list_add_tail(&addr->entry, &card->ip_list);
 			kfree(todo);
--
-	while (!list_empty(&card->ip_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&card->ip_list)) {
 		addr = list_entry(card->ip_list.next,
 				  struct qeth_ipaddr, entry);
 		list_del_init(&addr->entry);
@@ -510,6 +537,12 @@ static void qeth_l3_clear_ip_list(struct
 			continue;
--
 		while (card->rx.b_count) {
 			buffer = &card->qdio.in_q->bufs[card->rx.b_index];
 			if (!(card->rx.qdio_err &&
@@ -2112,6 +2150,12 @@ static int qeth_l3_poll(struct napi_stru
 				goto out;
 			else
--
-	while ((dev = driver_find_device(&cdriver->driver, NULL, NULL,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((dev = driver_find_device(&cdriver->driver, NULL, NULL,
 					 __ccwgroup_match_all))) {
 		struct ccwgroup_device *gdev = to_ccwgroupdev(dev);
 
@@ -591,6 +596,12 @@ void ccwgroup_driver_unregister(struct c
 		__ccwgroup_remove_cdev_refs(gdev);
--
 		while (word) {
 			if (word & INDICATOR_MASK) {
 				airq = airqs[isc][i];
@@ -146,6 +151,12 @@ void do_adapter_IO(u8 isc)
 			}
 			word <<= 8;
--
-	while ((from_ssid < to_ssid) || ((from_ssid == to_ssid) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((from_ssid < to_ssid) || ((from_ssid == to_ssid) &&
 	       (from <= to))) {
 		if (action == add)
 			set_bit(from, bl_dev[from_ssid]);
@@ -70,6 +75,12 @@ static int blacklist_range(range_action
 			from_ssid++;
--
 	while ((parm = strsep(&str, ","))) {
 		rc = 0;
 		ra = action;
@@ -196,6 +212,12 @@ static int blacklist_parse_parameters(ch
 				totalrc = -EINVAL;
 		} else
--
 	while (table->twd) {
 		if (value <= table->twd) {
 			if (nodelay && table->tdelay == 0)
@@ -112,6 +117,12 @@ max63xx_select_timeout(struct max63xx_ti
 		}
 
--
 			while(!ready){
 				udelay(20);
 				if ((readl(&regs->WinData) & 0xff000000) ==
@@ -502,6 +507,12 @@ static unsigned int write_eeprom(struct
 					ready = 1;
 					error = 1;
--
 	while (prodidx != eidx){
 		switch (rrpriv->evt_ring[eidx].code){
 		case E_NIC_UP:
@@ -930,6 +946,12 @@ static u32 rr_handle_event(struct net_de
 			       dev->name, rrpriv->evt_ring[eidx].code);
 		}
--
 		while ((target_config = strsep(&input, ";"))) {
 			nt = alloc_param_target(target_config);
 			if (IS_ERR(nt)) {
@@ -744,6 +749,12 @@ static int __init init_netconsole(void)
 			spin_lock_irqsave(&target_list_lock, flags);
 			list_add(&nt->list, &target_list);
--
 	while (ret) {
 		if (cmp_addr(&ret->pppoe_pa, sid, addr) &&
 		    ret->pppoe_ifindex == ifindex)
 			return ret;
 
 		ret = ret->next;
--
 	while (ret) {
 		if (cmp_2_addr(&ret->pppoe_pa, &po->pppoe_pa) &&
 		    ret->pppoe_ifindex == po->pppoe_ifindex)
 			return -EALREADY;
 
 		ret = ret->next;
--
 		while (po) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (po && po->pppoe_dev != dev) {
 				po = po->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 		while (po) {
 			if (!pos--)
 				goto out;
 			po = po->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (state->ccount != ccount) {
 			mppe_rekey(state, 0);
 			state->ccount = (state->ccount + 1) % MPPE_CCOUNT_SPACE;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 				while ((ccount & ~0xff) !=
 				       (state->ccount & ~0xff)) {
 					mppe_rekey(state, 0);
 					state->ccount =
 					    (state->ccount +
 					     256) % MPPE_CCOUNT_SPACE;
--
 	while (i < count && buf < buflim) {
 		c = data[i++];
 		if (i == 1 && c == 0 && (ap->flags & SC_COMP_PROT))
 			continue;	/* compress protocol field */
 		fcs = PPP_FCS(fcs, c);
 		PUT_BYTE(ap, buf, c, islcp);
--
 	while (skb_peek(&cfspi->chead)) {
 		skb = skb_dequeue_tail(&cfspi->chead);
 		skb_queue_head(&cfspi->qhead, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (nfrms < cfhsi->rx_state.nfrms) {
 		pfrm += *plen;
 		rx_sz += *plen;
 		plen++;
 		nfrms++;
+		if (_cur < timeout) {
--
-	while (!(list_empty(&pshm_drv->tx_pend_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->tx_pend_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_pend_list.next,
 					struct buf_list, list);
 
 		list_del(&pbuf->list);
--
-	while (!(list_empty(&pshm_drv->tx_full_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->tx_full_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_full_list.next,
 					struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
--
-	while (!(list_empty(&pshm_drv->tx_empty_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->tx_empty_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_empty_list.next,
 					struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
--
-	while (!(list_empty(&pshm_drv->rx_full_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->rx_full_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_full_list.next,
 				struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
--
-	while (!(list_empty(&pshm_drv->rx_pend_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->rx_pend_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_pend_list.next,
 				struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
--
-	while (!(list_empty(&pshm_drv->rx_empty_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->rx_empty_list))) {
 		pbuf =
 			list_entry(pshm_drv->rx_empty_list.next,
 				struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
--
 	while (len > PAGE_SIZE - offset) {
 		tx->size = PAGE_SIZE - offset;
 		tx->flags |= XEN_NETTXF_more_data;
@@ -446,6 +451,12 @@ static void xennet_make_frags(struct sk_
 		tx->offset = offset;
 		tx->size = len;
--
-	while ((nskb = __skb_dequeue(list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((nskb = __skb_dequeue(list))) {
 		struct xen_netif_rx_response *rx =
 			RING_GET_RESPONSE(&np->rx, ++cons);
 		skb_frag_t *nfrag = &skb_shinfo(nskb)->frags[0];
@@ -789,6 +805,12 @@ static RING_IDX xennet_fill_frags(struct
 		kfree_skb(nskb);
--
 	while ((i != rp) && (work_done < budget)) {
 		memcpy(rx, RING_GET_RESPONSE(&np->rx, i), sizeof(*rx));
 		memset(extras, 0, sizeof(rinfo.extras));
@@ -1019,6 +1046,12 @@ err:
 
 		np->rx.rsp_cons = ++i;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		spin_lock_irqsave(&i2400m->rx_lock, flags);
 		list_splice_init(&i2400m->rx_reports, &list);
 		spin_unlock_irqrestore(&i2400m->rx_lock, flags);
@@ -203,6 +208,12 @@ void i2400m_report_hook_work(struct work
 			list_del(&args->list_node);
--
-	while (offset < ack_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < ack_size) {
 		init_completion(&notif_completion);
 		result = i2400mu_notif_submit(i2400mu, &notif_urb,
 					      &notif_completion);
@@ -344,6 +349,12 @@ ssize_t i2400mu_bus_bm_wait_for_ack(stru
 		len = min(ack_size - offset, (size_t) notif_urb.actual_length);
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (count--) {
 		if (fp && *fp++) {
 			if (!test_and_set_bit(SLF_ERROR, &sl->flags))
 				sl->dev->stats.rx_errors++;
@@ -690,6 +695,12 @@ static void slip_receive_buf(struct tty_
 		else
--
 	while (!(elp_reg & ELPCTRL_WLAN_READY)) {
 		if (time_after(jiffies, timeout)) {
 			wl1251_error("elp wakeup timeout");
@@ -94,6 +99,12 @@ int wl1251_ps_elp_wakeup(struct wl1251 *
 		}
 		msleep(1);
--
-	while (chunk_num < fw_data_len / CHUNK_SIZE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (chunk_num < fw_data_len / CHUNK_SIZE) {
 		/* 10.2 update partition, if needed */
 		addr = WL1251_PART_DOWN_MEM_START +
 			(chunk_num + 2) * CHUNK_SIZE;
@@ -379,6 +384,12 @@ static int wl1251_boot_upload_firmware(s
 		wl1251_mem_write(wl, addr, buf, len);
--
 	while (nvs_ptr[0]) {
 		burst_len = nvs_ptr[0];
 		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));
@@ -442,6 +458,12 @@ static int wl1251_boot_upload_nvs(struct
 			nvs_ptr += 4;
 			dest_addr += 4;
--
-	while (nvs_bytes_written < nvs_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nvs_bytes_written < nvs_len) {
 		val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
 		       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));
 
@@ -474,6 +501,12 @@ static int wl1251_boot_upload_nvs(struct
 		nvs_ptr += 4;
--
 	while (!(intr & WL1251_ACX_INTR_CMD_COMPLETE)) {
 		if (time_after(jiffies, timeout)) {
 			wl1251_error("command complete timeout");
@@ -48,6 +53,12 @@ int wl1251_cmd_send(struct wl1251 *wl, u
 		msleep(1);
 
--
 	while ((skb = skb_dequeue(&wl->tx_queue))) {
 		if (!woken_up) {
 			ret = wl1251_ps_elp_wakeup(wl);
@@ -340,7 +345,13 @@ void wl1251_tx_work(struct work_struct *
 			dev_kfree_skb(skb);
 			goto out;
--
 	while ((skb = skb_dequeue(&wl->tx_queue))) {
 		info = IEEE80211_SKB_CB(skb);
 
@@ -544,6 +560,12 @@ void wl1251_tx_flush(struct wl1251 *wl)
 				continue;
 
--
 		while (bufsize--) {
 			pci_read_config_byte(dev, cap_data, buf);
 			cap_data++;
 			buf++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (i < pcie_serdes_spinwait) {
 		if (R_REG(&pcieregs->mdiocontrol) & MDIOCTL_ACCESS_DONE) {
 			if (!write) {
@@ -450,6 +466,12 @@ pcie_mdioop(struct pcicore_info *pi, uin
 		}
 		udelay(1000);
--
-	while ((p = dma_getnexttxp(pub, range))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while ((p = dma_getnexttxp(pub, range))) {
 		/* For unframed data, we don't have any packets to free */
 		if (!(di->dma.dmactrlflags & DMA_CTRL_UNFRAMED))
 			brcmu_pkt_buf_free_skb(p);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (i != end) {
 		skb = (struct sk_buff *)di->txp[i];
 		if (skb != NULL) {
@@ -1422,5 +1438,11 @@ void dma_walk_packets(struct dma_pub *dm
 			(callback_fnc)(tx_info, arg_a);
 		}
--
-	while (tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (tmp) {
 		if (tmp->next == t) {
 			tmp->next = t->next;
 #ifdef BCMDBG
@@ -1542,6 +1547,12 @@ void brcms_free_timer(struct brcms_timer
 			return;
--
 	while (precision--) {
 		quotient <<= 1;
 		if (remainder >= roundup) {
@@ -1031,6 +1036,12 @@ wlc_lcnphy_qdiv_roundup(u32 dividend, u3
 		} else {
 			remainder <<= 1;
--
 	while (read_phy_reg(pi, 0x481) & (0x1 << 9)) {
 
 		if (wait_count > (10 * 500)) {
@@ -1222,6 +1238,12 @@ wlc_lcnphy_rx_iq_est(struct brcms_phy *p
 		}
 		udelay(100);
--
 	while (div_frac >= fref3) {
 		div_int++;
 		div_frac -= fref3;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 		while ((op >> 31) == (op >> 30)) {
 			u16extraSignBits++;
 			op = op << 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (srv->flags & SRFL_MORE) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				    while (srv->flags & SRFL_MORE) {
 				srv++;
 				if (srv->off == 0)
 					continue;
@@ -986,6 +991,12 @@ _initvars_srom_pci(u8 sromrev, u16 *srom
 								   mask)) <<
--
-	while (skb) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (skb) {
 		nskb = skb->next;
 		skb->next = NULL;
 
@@ -61,6 +66,12 @@ void brcmu_pkt_buf_free_skb(struct sk_bu
 
--
 	while (p) {
 		if (fn == NULL || (*fn) (p, arg)) {
 			bool head = (p == q->head);
@@ -243,6 +259,12 @@ brcmu_pktq_pflush(struct pktq *pq, int p
 			prev = p;
 			p = p->prev;
--
 	while (ntimes && pend) {
 		if (pend) {
 			set_current_state(TASK_INTERRUPTIBLE);
@@ -1315,6 +1320,12 @@ int brcmf_netdev_wait_pend8021x(struct n
 			ntimes--;
 		}
--
-	while (!list_empty(&cfg_priv->evt_q_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cfg_priv->evt_q_list)) {
 		e = list_first_entry(&cfg_priv->evt_q_list,
 				     struct brcmf_cfg80211_event_q, evt_q_list);
 		list_del(&e->evt_q_list);
 		kfree(e);
+		if (_cur < timeout) {
--
-		while (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
 			clkctl = brcmf_sdcard_cfg_read(bus->sdiodev,
 						       SDIO_FUNC_1,
 						       SBSDIO_FUNC1_CHIPCLKCSR,
@@ -880,6 +885,12 @@ static int brcmf_sdbrcm_htclk(struct brc
 				break;
--
 	while (c->last != idx) {
 		for (n = 0; n < CONSOLE_LINE_MAX - 2; n++) {
 			if (c->last == idx) {
@@ -2888,6 +2904,12 @@ static int brcmf_sdbrcm_readconsole(stru
 			line[n] = 0;
 			printk(KERN_DEBUG "CONSOLE: %s\n", line);
--
 	while ((len =
 		brcmf_sdbrcm_get_image((char *)memptr, MEMBLOCK, bus))) {
 		ret = brcmf_sdbrcm_membytes(bus, true, offset, memptr, len);
@@ -3439,6 +3466,12 @@ static int brcmf_sdbrcm_download_code_fi
 		}
 
--
-	while (enable != ready) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (enable != ready) {
 		ready = brcmf_sdcard_cfg_read(bus->sdiodev, SDIO_FUNC_0,
 					      SDIO_CCCR_IORx, NULL);
 		if (time_after(jiffies, timeout))
@@ -3741,6 +3779,12 @@ int brcmf_sdbrcm_bus_init(struct brcmf_p
 		else if (time_after(jiffies, timeout - BRCMF_WAIT_F2RDY + 50))
--
-	while (i < octets - 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i < octets - 1) {
 		data = tx_get_next_word(txhdr, packet,
 					sizeof(struct b43legacy_txhdr_fw3), &i);
 		b43legacy_pio_write(queue, B43legacy_PIO_TXDATA, data);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-		while (j <= t->range) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (j <= t->range) {
 			int r = islpci_mgt_transaction(priv->ndev, PIMFOR_OP_SET,
 						      oid, data, t->size,
 						      &response);
@@ -617,6 +622,12 @@ mgt_commit_list(islpci_private *priv, en
 			j++;
--
-	while (priv->free_data_tx !=
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (priv->free_data_tx !=
 	       le32_to_cpu(control_block->
 			   device_curr_frag[ISL38XX_CB_TX_DATA_LQ])) {
 		/* read the index of the first fragment to be freed */
@@ -70,6 +75,12 @@ islpci_eth_cleanup_transmit(islpci_priva
 		}
--
 	while ((void *) h < data + len) {
 		if (h->flags & PIMFOR_FLAG_LITTLE_ENDIAN) {
 			le32_to_cpus(&h->oid);
@@ -98,6 +103,12 @@ pimfor_decode_header(void *data, int len
 		if (h->oid != OID_INL_TUNNEL)
 			return h;
--
-	while (pos < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (pos < end) {
 		if (pos + 2 + pos[1] > end) {
 			printk(KERN_DEBUG "Parsing Beacon/ProbeResp failed "
 			       "for %pM\n", addr);
@@ -2236,6 +2241,12 @@ prism54_process_bss_data(islpci_private
 			return;
--
-	while (full_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (full_len) {
 		if (full_len < 254)
 			full_len = 0;
 		else
@@ -319,6 +324,12 @@ static u16 wl3501_get_tx_buffer(struct w
 			ret = 0;
--
 	while (ptr) {
 		u16 next;
 
@@ -343,6 +359,12 @@ static void wl3501_free_tx_buffer(struct
 		wl3501_get_from_wla(this, ptr, &next, sizeof(next));
 		this->tx_buffer_tail = ptr;
--
 	while ((next - this->tx_buffer_head) < this->tx_buffer_size) {
 		this->tx_buffer_cnt++;
 		wl3501_set_to_wla(this, ptr, &next, sizeof(next));
 		ptr = next;
 		next = ptr + WL3501_BLKSZ;
+		if (_cur < timeout) {
--
 		while (*ptr) {
 			if ((*ptr & 0x7f) == priv->data_rate) {
 				ret = 0;
 				goto done;
 			}
 			ptr++;
--
 	while (((wrptr & MWIFIEX_RXBD_MASK) !=
 		(card->rxbd_rdptr & MWIFIEX_RXBD_MASK)) ||
 	       ((wrptr & MWIFIEX_BD_FLAG_ROLLOVER_IND) ==
@@ -903,7 +908,13 @@ static int mwifiex_pcie_process_recv_dat
 		dev_dbg(adapter->dev, "info: RECV DATA: Received packet from "
 				      "firmware successfully\n");
--
 	while (adapter->int_status & HOST_INTR_MASK) {
 		if (adapter->int_status & HOST_INTR_DNLD_DONE) {
 			adapter->int_status &= ~HOST_INTR_DNLD_DONE;
@@ -1650,6 +1666,12 @@ static int mwifiex_process_int_status(st
 			}
 
--
 	while (count) {
 		if (!memcmp(iebody->ptk_body, oui, sizeof(iebody->ptk_body)))
 			return MWIFIEX_OUI_PRESENT;
@@ -101,6 +106,12 @@ mwifiex_search_oui_in_ie(struct ie_body
 		if (count)
 			iebody = (struct ie_body *) ((u8 *) iebody +
--
 		while (tlv_idx < max_chan_per_scan
 		       && tmp_chan_list->chan_number && !done_early) {
 
@@ -674,6 +690,12 @@ mwifiex_scan_channel_list(struct mwifiex
 				|| tmp_chan_list->chan_number == 6
 				|| tmp_chan_list->chan_number == 11))
--
 		while (length) {
 			pg++;
 			if (max_power < pg->power_max)
@@ -387,6 +392,12 @@ static int mwifiex_get_power_level(struc
 				min_power = pg->power_min;
 
--
 		while (!skb_queue_empty(&list)) {
 			rx_skb = __skb_dequeue(&list);
 			ret = mwifiex_recv_packet(adapter, rx_skb);
 			if (ret == -1)
 				dev_err(adapter->dev, "Rx of A-MSDU failed");
+				if (_cur < timeout) {
--
 	while (1) {
 		spin_lock_irqsave(&rxq->lock, flags);
 		if (list_empty(&rxq->rx_used)) {
@@ -352,6 +357,12 @@ static void iwl4965_rx_allocate(struct i
 		priv->alloc_rxb_page++;
 
--
 	while (!list_empty(&priv->free_frames)) {
 		element = priv->free_frames.next;
 		list_del(element);
 		kfree(list_entry(element, struct iwl3945_frame, list));
 		priv->frames_count--;
+		if (_cur < timeout) {
--
 	while (i != r) {
 		int len;
 
@@ -1317,6 +1333,12 @@ static void iwl3945_rx_handle(struct iwl
 				count = 0;
 			}
--
-	while (size && (PAGE_SIZE - len)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size && (PAGE_SIZE - len)) {
 		hex_dump_to_buffer(data + ofs, size, 16, 1, buf + len,
 				   PAGE_SIZE - len, 1);
 		len = strlen(buf);
@@ -3305,6 +3332,12 @@ static ssize_t iwl3945_show_measurement(
 
--
-	while (sent_bitmap) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sent_bitmap) {
 		ack = sent_bitmap & 1ULL;
 		successes += ack;
 		IWL_DEBUG_TX_REPLY(priv, "%s ON i=%d idx=%d raw=%d\n",
@@ -1207,6 +1212,12 @@ static int iwl4965_tx_status_reply_compr
 			agg->start_idx + i);
--
 	while (tl->queue_count &&
 	       (tl->time_stamp < oldest_time)) {
 		tl->total -= tl->packet_count[tl->head];
@@ -260,6 +265,12 @@ iwl4965_rs_tl_rm_old_stats(struct iwl_tr
 		tl->head++;
 		if (tl->head >= TID_QUEUE_MAX_SIZE)
--
 	while (q->write_ptr != q->read_ptr) {
 		priv->cfg->ops->lib->txq_free_tfd(priv, txq);
 		q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (q->read_ptr != q->write_ptr) {
 		i = iwl_legacy_get_cmd_index(q, q->read_ptr, 0);
 
@@ -164,6 +180,12 @@ void iwl_legacy_cmd_queue_unmap(struct i
 		}
 
--
 	while (!list_empty(&priv->free_frames)) {
 		element = priv->free_frames.next;
 		list_del(element);
 		kfree(list_entry(element, struct iwl_frame, list));
 		priv->frames_count--;
+		if (_cur < timeout) {
--
 	while (i != r) {
 		int len;
 
@@ -755,6 +771,12 @@ void iwl4965_rx_handle(struct iwl_priv *
 				count = 0;
 			}
--
 	while (pos < size) {
 		tlv_h = (struct mrvl_ie_header *) tlv;
 		if (!tlv_h->len)
@@ -222,6 +227,12 @@ static void *lbs_tlv_find(uint16_t tlv_t
 		length = le16_to_cpu(tlv_h->len) + sizeof(*tlv_h);
 		pos += length;
--
 	while (size) {
 		ret = if_sdio_wait_status(card, FW_DL_READY_STATUS);
 		if (ret)
@@ -518,6 +523,12 @@ static int if_sdio_prog_helper(struct if
 
 		firmware += chunk_size;
--
 	while (size) {
 		ret = if_sdio_wait_status(card, FW_DL_READY_STATUS);
 		if (ret)
@@ -623,7 +639,12 @@ static int if_sdio_prog_real(struct if_s
 		if (req_size > size)
 			req_size = size;
--
-		while (req_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (req_size) {
 			chunk_size = min(req_size, (size_t)512);
 
 			memcpy(chunk_buffer, firmware, chunk_size);
@@ -639,6 +660,18 @@ static int if_sdio_prog_real(struct if_s
 			firmware += chunk_size;
--
 	while (card->packets) {
 		packet = card->packets;
 		card->packets = card->packets->next;
 		kfree(packet);
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (card->packets) {
 		packet = card->packets;
 		card->packets = card->packets->next;
 		kfree(packet);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (1) {
 		u16 val;
 		err = spu_read_u16(card, reg, &val);
@@ -313,6 +318,12 @@ static int spu_wait_for_u16(struct if_sp
 			       __func__, val, target_mask, target);
 			return -ETIMEDOUT;
--
-	while (priv->scan_channel < last_channel) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (priv->scan_channel < last_channel) {
 		struct chanscanparamset *param = (void *) tlv;
 
 		param->radiotype = CMD_SCAN_RADIO_TYPE_BG;
@@ -229,6 +234,12 @@ static int lbs_add_channel_list_tlv(stru
 		}
--
 	while (list_len) {
 		if (!memcmp(list, mac, ETH_ALEN))
 			return 1;
 		list += ETH_ALEN;
 		list_len--;
+		if (_cur < timeout) {
--
 	while (iter && iter->helper) {
 		if (iter->model != card_model)
 			goto next;
@@ -1265,7 +1281,13 @@ int lbs_get_firmware(struct device *dev,
 
   next:
--
 	while (!skb_queue_empty(&rx_queue)) {
 		_skb = skb_dequeue(&rx_queue);
 		_rtl_usb_rx_process_agg(hw, _skb);
 		ieee80211_rx_irqsafe(hw, _skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((_skb = skb_dequeue(&rtlusb->tx_skb_queue[i]))) {
 			rtlusb->usb_tx_cleanup(hw, _skb);
 			txinfo = IEEE80211_SKB_CB(_skb);
 			ieee80211_tx_info_clear_status(txinfo);
 			txinfo->flags |= IEEE80211_TX_STAT_ACK;
 			ieee80211_tx_status_irqsafe(hw, _skb);
--
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -1252,6 +1257,12 @@ u8 *rtl_find_ie(u8 *data, unsigned int l
 			return pos;
 
--
 	while (pos < end) {
 		if (pos[0] == 221) {
 			vendor_ie.length = pos[1];
@@ -1404,6 +1420,12 @@ static bool rtl_find_221_ie(struct ieee8
 			return false;
 
--
 	while (true) {
 		spin_lock_irqsave(&rtlpriv->locks.h2c_lock, flag);
 		if (rtlhal->h2c_setinprogress) {
@@ -301,7 +306,12 @@ static void _rtl92c_fill_h2c_command(str
 				 ("H2C set in progress! Wait to set.."
 				  "element_id(%d).\n", element_id));
--
-			while (rtlhal->h2c_setinprogress) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (rtlhal->h2c_setinprogress) {
 				spin_unlock_irqrestore(&rtlpriv->locks.h2c_lock,
 						       flag);
 				h2c_waitcounter++;
@@ -314,6 +324,12 @@ static void _rtl92c_fill_h2c_command(str
 					return;
--
 	while (!bwrite_sucess) {
diff -u -p a/net/wireless/rtlwifi/rtl8192de/phy.c b/net/wireless/rtlwifi/rtl8192de/phy.c
--- a/net/wireless/rtlwifi/rtl8192de/phy.c
+++ b/net/wireless/rtlwifi/rtl8192de/phy.c
@@ -2829,11 +2829,22 @@ static void _rtl92d_phy_lc_calibrate_sw(
 		}
--
 		while ((!(u4tmp & BIT(11))) && timecount <= timeout) {
 			mdelay(50);
 			timecount += 50;
 			u4tmp = rtl_get_rfreg(hw, (enum radio_path)index,
 					      RF_SYN_G6, BRFREGOFFSETMASK);
+			if (_cur < timeout) {
--
 	while (rtlpriv->mac80211.act_scanning && timecount < timeout) {
 		udelay(50);
 		timecount += 50;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (rtlphy->lck_inprogress && timecount < timeout) {
 		mdelay(50);
 		timecount += 50;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (true) {
 		spin_lock_irqsave(&rtlpriv->locks.h2c_lock, flag);
 		if (rtlhal->h2c_setinprogress) {
@@ -392,7 +397,12 @@ static void _rtl92d_fill_h2c_command(str
 				 ("H2C set in progress! Wait to set.."
 				 "element_id(%d).\n", element_id));
--
-			while (rtlhal->h2c_setinprogress) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (rtlhal->h2c_setinprogress) {
 				spin_unlock_irqrestore(&rtlpriv->locks.h2c_lock,
 						       flag);
 				h2c_waitcounter++;
@@ -406,6 +416,12 @@ static void _rtl92d_fill_h2c_command(str
 
--
 	while (!bwrite_sucess) {
 		wait_writeh2c_limmit--;
diff -u -p a/net/wireless/rtlwifi/efuse.c b/net/wireless/rtlwifi/efuse.c
--- a/net/wireless/rtlwifi/efuse.c
+++ b/net/wireless/rtlwifi/efuse.c
@@ -950,6 +950,11 @@ static int efuse_pg_packet_write(struct
--
 	while (continual && (efuse_addr <
 	       (EFUSE_MAX_SIZE - EFUSE_OOB_PROTECT_BYTES))) {
 
@@ -1002,6 +1007,12 @@ static int efuse_pg_packet_write(struct
 					("efuse PG_STATE_HEADER-3\n"));
 			}
--
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb;
@@ -605,6 +610,12 @@ static void _rtl_pci_tx_isr(struct ieee8
 		}
 tx_status_ok:
--
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb = __skb_dequeue(&ring->queue);
@@ -1160,6 +1176,12 @@ static void _rtl_pci_free_tx_ring(struct
 				 skb->len, PCI_DMA_TODEVICE);
 		kfree_skb(skb);
--
-			while (skb_queue_len(&ring->queue)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (skb_queue_len(&ring->queue)) {
 				struct rtl_tx_desc *entry =
 				    &ring->desc[ring->idx];
 				struct sk_buff *skb =
@@ -1300,6 +1327,12 @@ int rtl_pci_reset_trx_ring(struct ieee80
 						 skb->len, PCI_DMA_TODEVICE);
--
 	while (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {
 		mdelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {
 		mdelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {
 		mdelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((reg & HERMES_CMD_BUSY) && k) {
 		k--;
 		udelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((!(reg & HERMES_EV_CMD)) && k) {
 		k--;
 		udelay(10);
 		reg = hermes_read_regn(hw, EVSTAT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (k && (reg & HERMES_CMD_BUSY)) {
 		if (reg == 0xffff) /* Special case - the card has probably been
 				      removed, so don't wait for the timeout */
@@ -223,6 +250,12 @@ static int hermes_init(struct hermes *hw
 		k--;
 		udelay(1);
--
 	while ((!(reg & HERMES_EV_CMD)) && k) {
 		k--;
 		udelay(10);
 		reg = hermes_read_regn(hw, EVSTAT);
+		if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((!(reg & HERMES_EV_ALLOC)) && k) {
 		k--;
 		udelay(10);
 		reg = hermes_read_regn(hw, EVSTAT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((reg & HERMES_OFFSET_BUSY) && k) {
 		k--;
 		udelay(1);
 		reg = hermes_read_reg(hw, oreg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((reg & (HERMES_OFFSET_BUSY | HERMES_OFFSET_ERR)) && k) {
 		k--;
 		udelay(1);
 		reg = hermes_read_reg(hw, oreg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len--) {
 		obuf = hex_byte_pack(obuf, *ibuf++);
 		*obuf++ = '-';
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (time_before_eq(jiffies, timeout)) {
 		if (!test_bit(STATUS_SCAN_HW, &priv->shrd->status))
 			goto finished;
 		msleep(20);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		spin_lock_irqsave(&rxq->lock, flags);
 		if (list_empty(&rxq->rx_used)) {
@@ -330,6 +335,12 @@ static void iwlagn_rx_allocate(struct iw
 		rxq->free_count++;
 
--
 	while (i != r) {
 		int len, err;
 		u16 sequence;
@@ -526,6 +542,12 @@ static void iwl_rx_handle(struct iwl_tra
 				count = 0;
 			}
--
-	while (trans_pcie->ict_tbl[trans_pcie->ict_index]) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (trans_pcie->ict_tbl[trans_pcie->ict_index]) {
 
 		val |= le32_to_cpu(trans_pcie->ict_tbl[trans_pcie->ict_index]);
 		IWL_DEBUG_ISR(trans, "ICT index %d value 0x%08X\n",
@@ -1400,6 +1427,12 @@ irqreturn_t iwl_isr_ict(int irq, void *d
 		trans_pcie->ict_index =
--
 	while (tl->queue_count &&
 	       (tl->time_stamp < oldest_time)) {
 		tl->total -= tl->packet_count[tl->head];
@@ -276,6 +281,12 @@ static void rs_tl_rm_old_stats(struct iw
 		tl->head++;
 		if (tl->head >= TID_QUEUE_MAX_SIZE)
--
 		while (!skb_queue_empty(&skbs)) {
 			skb = __skb_dequeue(&skbs);
 			hdr = (struct ieee80211_hdr *)skb->data;
@@ -830,6 +835,12 @@ int iwlagn_rx_reply_tx(struct iwl_priv *
 			ieee80211_tx_status_irqsafe(priv->hw, skb);
 
--
 	while (!skb_queue_empty(&reclaimed_skbs)) {
 		struct ieee80211_hdr *hdr;
 		struct ieee80211_tx_info *info;
@@ -973,6 +989,12 @@ int iwlagn_rx_reply_compressed_ba(struct
 		}
 
--
-	while (q->write_ptr != q->read_ptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (q->write_ptr != q->read_ptr) {
 		/* The read_ptr needs to bound by q->n_window */
 		iwlagn_txq_free_tfd(trans, txq, get_cmd_index(q, q->read_ptr),
 				    dma_dir);
 		q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd);
+		if (_cur < timeout) {
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		snprint_line(line, sizeof(line), &data[ofs],
 			     min(len, 16U), ofs);
 		printk(KERN_DEBUG "%s\n", line);
 		ofs += 16;
 		len -= min(len, 16U);
--
-	while (size && len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size && len) {
 		out = snprint_line(output, size, &data[ofs],
 				   min_t(size_t, len, 16U), ofs);
 
@@ -289,6 +305,12 @@ static int snprintk_buf(u8 * output, siz
 		size -= out;
--
 	while (current_index < priv->sram_desc.last_cb_index) {
 		udelay(50);
 		previous_index = current_index;
@@ -2974,6 +3001,12 @@ static int ipw_fw_dma_wait(struct ipw_pr
 			ipw_fw_dma_abort(priv);
 			return -1;
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		printk(KERN_DEBUG "%s\n",
 		       snprint_line(line, sizeof(line), &data[ofs],
 				    min(len, 16U), ofs));
 		ofs += 16;
 		len -= min(len, 16U);
--
-	while (i != r) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i != r) {
 		/* IPW_DEBUG_RX("r = %d : w = %d : processing = %d\n",
 		   r, rxq->next, i); */
 
@@ -2793,6 +2809,12 @@ static void __ipw2100_rx_process(struct
 		rxq->drv[i].status.info.field = 0;
--
-	while (len < PAGE_SIZE - 128 && loop < ARRAY_SIZE(ord_data)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (len < PAGE_SIZE - 128 && loop < ARRAY_SIZE(ord_data)) {
 		val_len = sizeof(u32);
 
 		if (ipw2100_get_ordinal(priv, ord_data[loop].index, &val,
@@ -4013,6 +4040,12 @@ static ssize_t show_ordinals(struct devi
 				       ord_data[loop].index, val,
--
 	while (!list_empty(&priv->tx_pend_list)) {
 		element = priv->tx_pend_list.next;
 		packet = list_entry(element, struct ipw2100_tx_packet, list);
@@ -5898,6 +5936,12 @@ static int ipw2100_close(struct net_devi
 
 		list_add_tail(element, &priv->tx_free_list);
--
 	while (skb) {
 		rt2x00mac_tx(rt2x00dev->hw, skb);
 		skb = ieee80211_get_buffered_bc(rt2x00dev->hw, vif);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -464,6 +480,12 @@ static u8 *rt2x00lib_find_ie(u8 *data, u
 			return pos;
 
--
-	while (kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
 
 		/* TX_STA_FIFO_PID_QUEUE is a 2-bit field, thus
 		 * qid is guaranteed to be one of the TX QIDs
@@ -544,6 +549,12 @@ static void rt2800usb_txdone(struct rt2x
 		if (entry)
--
-		while (entry != entry_done) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (entry != entry_done) {
 			/* Catch up.
 			 * Just report any entries we missed as failed.
 			 */
@@ -2212,6 +2217,12 @@ static void rt61pci_txdone(struct rt2x00
 
--
-	while (len && !status) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (len && !status) {
 		bsize = min_t(u16, CSR_CACHE_SIZE, len);
 		status = rt2x00usb_vendor_req_buff_lock(rt2x00dev, request,
 							requesttype, off, tb,
@@ -132,6 +137,12 @@ int rt2x00usb_vendor_request_buff(struct
 		tb  += bsize;
--
 	while (offset < len) {
 		if (!rt2800_check_firmware_crc(data + offset, fw_len))
 			return FW_BAD_CRC;
 
 		offset += fw_len;
+		if (_cur < timeout) {
--
 		while ((skb = ieee80211_get_buffered_bc(priv->hw, priv->vif))) {
 			skb_queue_tail(&priv->bc_ps_buf, skb);
 			tx_buff_bc = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-	while (!list_empty(&priv->tx_pending)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&priv->tx_pending)) {
 		entry = list_entry(priv->tx_pending.next,
 				   struct p54s_tx_info, tx_list);
 
@@ -467,6 +472,12 @@ static int p54spi_wq_tx(struct p54s_priv
 		}
--
 	while (remains) {
 		u32 i = 0;
 		left = min((u32)0x1000, remains);
@@ -100,13 +105,30 @@ static int p54p_upload_firmware(struct i
 		P54P_READ(int_enable);
 
--
 		while (i < left) {
 			P54P_WRITE(direct_mem_win[i], *data++);
 			i += sizeof(u32);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (i != idx) {
 		u16 len;
 		struct sk_buff *skb;
@@ -237,6 +264,12 @@ static void p54p_check_rx_ring(struct ie
 
 		i++;
--
-	while (i != idx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i != idx) {
 		desc = &ring[i];
 
 		skb = tx_buf[i];
@@ -275,6 +313,12 @@ static void p54p_check_tx_ring(struct ie
 
--
 	while (length--) {
 		chk ^= le32_to_cpu(*data++);
 		chk = (chk >> 5) ^ (chk << 3);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (remains) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (left--) {
 			if (carry) {
 				*tmp++ = carry;
@@ -540,6 +561,12 @@ static int p54u_upload_firmware_3887(str
 				break;
 			}
--
 	while (remains) {
 		unsigned int block_len = min(remains, (unsigned int)512);
 		memcpy(buf, data, block_len);
@@ -781,6 +819,12 @@ static int p54u_upload_firmware_net2280(
 		remains -= block_len;
 		data += block_len;
--
 	while (i--) {
 		switch (intf->altsetting->endpoint[i].desc.bEndpointAddress) {
 		case P54U_PIPE_DATA:
@@ -952,6 +1001,12 @@ static int __devinit p54u_probe(struct u
 		case P54U_PIPE_INT | USB_DIR_IN:
 			recognized_pipes++;
--
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -93,6 +98,12 @@ u8 *p54_find_ie(struct sk_buff *skb, u8
 			return pos;
 
--
 	while ((total = p54_flush_count(priv) && i--)) {
 		/* waste time */
 		msleep(20);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (bootrec->data <= end_data && (bootrec->data +
 	       (len = le32_to_cpu(bootrec->len))) <= end_data) {
 		u32 code = le32_to_cpu(bootrec->code);
@@ -122,6 +127,12 @@ int p54_parse_firmware(struct ieee80211_
 			break;
 		}
--
 			while ((u8 *)tmp < entry->data + data_len) {
 				struct exp_if *exp_if = tmp;
 				if (exp_if->if_id == cpu_to_le16(IF_ID_ISL39000))
 					synth = le16_to_cpu(exp_if->variant);
 				tmp += sizeof(*exp_if);
+				if (_cur < timeout) {
--
-	while (eeprom_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (eeprom_size) {
 		blocksize = min(eeprom_size, maxblocksize);
 		ret = p54_download_eeprom(priv, (void *) (eeprom + offset),
 					  offset, blocksize);
@@ -912,6 +928,12 @@ int p54_read_eeprom(struct ieee80211_hw
 
--
 	while (i--) {
 		u8 octet = atmel_read8(priv->dev, DR);
 		crc = crc32_le(crc, &octet, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (1) {
 		if (!atmel_lock_mac(priv)) {
 			/* failed to contact card */
@@ -1260,6 +1276,12 @@ static irqreturn_t service_interrupt(int
 			printk(KERN_INFO "%s: Generic_irq received.\n", dev->name);
 			break;
--
 	while (time_diff--) {
 		priv->last_qual += HZ;
 		priv->wstats.qual.qual = priv->wstats.qual.qual / 2;
 		priv->wstats.qual.qual +=
 			priv->beacons_this_sec * priv->beacon_period * (priv->wstats.qual.level + 100) / 4000;
 		priv->beacons_this_sec = 0;
--
 	while (i--) {
 		rtl818x_iowrite32(priv, (__le32 __iomem *)&priv->map->PHY[0], buf);
 		if (rtl818x_ioread8(priv, &priv->map->PHY[2]) == (data & 0xFF))
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (count--) {
 		struct rtl8180_rx_desc *entry = &priv->rx_ring[priv->rx_idx];
 		struct sk_buff *skb = priv->rx_buf[priv->rx_idx];
@@ -169,6 +185,12 @@ static void rtl8180_handle_rx(struct iee
 		if (priv->rx_idx == 31)
 			entry->flags |= cpu_to_le32(RTL818X_RX_DESC_FLAG_EOR);
--
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl8180_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb;
@@ -204,6 +231,12 @@ static void rtl8180_handle_tx(struct iee
 		ieee80211_tx_status_irqsafe(dev, skb);
 		if (ring->entries - skb_queue_len(&ring->queue) == 2)
--
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl8180_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb = __skb_dequeue(&ring->queue);
@@ -534,6 +572,12 @@ static void rtl8180_free_tx_ring(struct
 				 skb->len, PCI_DMA_TODEVICE);
 		kfree_skb(skb);
--
 	while (check_bssid_list_item(bssid, bssid_len, buf, len)) {
 		if (rndis_bss_info_update(usbdev, bssid) && match_bssid &&
 		    matched) {
@@ -2107,6 +2112,12 @@ resize_buf:
 
 		real_count++;
--
 	while (tmp2 >= freqref) {
 		tmp1++;
 		tmp2 -= freqref;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 	while (tuple) {
 		switch (tuple->code) {
 		case 0x80:
@@ -123,6 +128,12 @@ static int __devinit b43_sdio_probe(stru
 			break;
 		}
--
-	while (skb_queue_len(&wl->tx_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (skb_queue_len(&wl->tx_queue)) {
 		skb = skb_dequeue(&wl->tx_queue);
 
 		if (b43_using_pio_transfers(dev))
@@ -3389,6 +3394,12 @@ static void b43_tx_work(struct work_stru
 			err = b43_dma_tx(dev, skb);
--
 	while (tmp & 0x2) {
 		r = zd_ioread32_locked(&mac->chip, &tmp, CR_BCN_FIFO_SEMAPHORE);
 		if (r < 0)
@@ -760,6 +765,12 @@ static int zd_mac_config_beacon(struct i
 			}
 		}
--
-	while((!rc) && (bss.index != cpu_to_le16(0xffff))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while((!rc) && (bss.index != cpu_to_le16(0xffff))) {
 		/* Grab a network off the free list */
 		if (!list_empty(&ai->network_free_list)) {
 			tmp_net = list_entry(ai->network_free_list.next,
@@ -3036,6 +3041,12 @@ static void airo_process_scan_results (s
 		/* Read next entry */
--
 	while (1) {
 		int status = IN4500(ai, OFFSET0+whichbap);
 		if (status & BAP_BUSY) {
@@ -4011,6 +4027,12 @@ static int bap_setup(struct airo_info *a
 		OUT4500(ai, SELECT0+whichbap, rid);
 		OUT4500(ai, OFFSET0+whichbap, offset);
--
 	while( line[0] ) {
 /*** Mode processing */
 		if ( !strncmp( line, "Mode: ", 6 ) ) {
@@ -5003,6 +5030,12 @@ static void proc_config_on_close(struct
 		}
 		while( line[0] && line[0] != '\n' ) line++;
 		if ( line[0] ) line++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while(!list_empty(&airo_devices)) {
 		ai = list_entry(airo_devices.next, struct airo_info, dev_list);
 		airo_print_info(ai->dev->name, "Unregistering...");
 		stop_airo_card(ai->dev, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((skb = skb_dequeue(&wl->links[hlid].tx_queue[i]))) {
 			filtered[i]++;
 
@@ -212,6 +217,12 @@ static void wl1271_ps_filter_frames(stru
 			info->flags |= IEEE80211_TX_STAT_TX_FILTERED;
 			info->status.rates[0].idx = -1;
--
-		while (pkt_offset < buf_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (pkt_offset < buf_size) {
 			pkt_length = wl12xx_rx_get_buf_size(status,
 					drv_rx_counter);
 
@@ -260,6 +265,12 @@ void wl12xx_rx(struct wl1271 *wl, struct
 			drv_rx_counter++;
--
 	while (num_busy_bytes) {
 		num_busy_bytes--;
 		spi_message_init(&m);
@@ -198,6 +203,12 @@ static int wl1271_spi_read_busy(struct w
 
 		if (*busy_buf & 0x1)
--
 	while (chunk_num < fw_data_len / CHUNK_SIZE) {
 		/* 10.2 update partition, if needed */
 		addr = dest + (chunk_num + 2) * CHUNK_SIZE;
@@ -208,6 +213,12 @@ static int wl1271_boot_upload_firmware_c
 		wl1271_write(wl, addr, chunk, CHUNK_SIZE, false);
 
--
 	while (nvs_ptr[0]) {
 		burst_len = nvs_ptr[0];
 		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));
@@ -364,6 +380,12 @@ static int wl1271_boot_upload_nvs(struct
 
 		if (nvs_ptr >= (u8 *) wl->nvs + nvs_len)
--
 	while (!(intr & WL1271_ACX_INTR_CMD_COMPLETE)) {
 		if (time_after(jiffies, timeout)) {
 			wl1271_error("command complete timeout");
@@ -85,6 +90,12 @@ int wl1271_cmd_send(struct wl1271 *wl, u
 			msleep(1);
 
--
 	while (!kthread_should_stop()) {
 		if (rx && !rx_started) {
 			dev_info(pdev, "starting rx test\n");
@@ -393,6 +398,12 @@ static int tester(void *data)
 
 		if (!rx_started && !tx_started)
--
 	while (!done && loopcount--) {
 		/*
 		 * In order to avoid a race with the hardirq, clear the flag
@@ -1037,6 +1042,12 @@ irqreturn_t wl1271_irq(int irq, void *co
 
 		if (intr & WL1271_ACX_INTR_HW_AVAILABLE)
--
 	while (retries) {
 		retries--;
 		ret = wl1271_chip_wakeup(wl);
@@ -1431,6 +1447,12 @@ irq_disable:
 		mutex_lock(&wl->mutex);
 power_off:
--
 	while (retries) {
 		retries--;
 		ret = wl1271_chip_wakeup(wl);
@@ -1956,6 +1983,12 @@ irq_disable:
 		mutex_lock(&wl->mutex);
 power_off:
--
 	while ((skb = wl1271_skb_dequeue(wl))) {
 		if (wl1271_tx_is_data_present(skb))
 			had_data = true;
@@ -682,7 +687,13 @@ void wl1271_tx_work_locked(struct wl1271
 		}
 		buf_offset += ret;
--
 		while ((skb = skb_dequeue(&wl->links[hlid].tx_queue[i]))) {
 			wl1271_debug(DEBUG_TX, "link freeing skb 0x%p", skb);
 
@@ -874,6 +890,12 @@ void wl1271_tx_reset_link_queues(struct
 			}
 
--
-			while ((skb = skb_dequeue(&wl->tx_queue[i]))) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while ((skb = skb_dequeue(&wl->tx_queue[i]))) {
 				wl1271_debug(DEBUG_TX, "freeing skb 0x%p",
 					     skb);
 
@@ -914,6 +941,12 @@ void wl1271_tx_reset(struct wl1271 *wl,
 					info->status.rates[0].count = 0;
--
-	while (!time_after(jiffies, timeout)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!time_after(jiffies, timeout)) {
 		mutex_lock(&wl->mutex);
 		wl1271_debug(DEBUG_TX, "flushing tx buffer: %d %d",
 			     wl->tx_frames_cnt,
@@ -985,6 +1023,12 @@ void wl1271_tx_flush(struct wl1271 *wl)
 		}
--
-	while (iwm->calib_done_map != expected_bitmap) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (iwm->calib_done_map != expected_bitmap) {
 		if (iwm_notif_handle(iwm, CALIBRATION_RES_NOTIFICATION,
 				     IWM_SRC_LMAC, WAIT_NOTIF_TIMEOUT)) {
 			IWM_DBG_FW(iwm, DBG, "Initial calibration timeout\n");
@@ -290,6 +295,12 @@ static int iwm_init_calib(struct iwm_pri
 		IWM_DBG_FW(iwm, DBG, "Got calibration result. calib_done_map: "
--
 	while ((frame = __skb_dequeue(&list))) {
 		ndev->stats.rx_packets++;
 		ndev->stats.rx_bytes += frame->len;
@@ -1591,6 +1596,12 @@ static void iwm_rx_process_amsdu(struct
 			IWM_ERR(iwm, "Packet dropped\n");
 			ndev->stats.rx_dropped++;
--
 	while (!skb_queue_empty(&iwm->rx_list)) {
 		skb = skb_dequeue(&iwm->rx_list);
 		rx_info = skb_to_rx_info(skb);
@@ -99,6 +104,12 @@ static void iwm_sdio_isr_worker(struct w
 			IWM_WARN(iwm, "RX error\n");
 
--
-		while ((pdadc_0 < (s16) pdadc_n) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((pdadc_0 < (s16) pdadc_n) &&
 		(pdadc_i < AR5K_EEPROM_POWER_TABLE_SIZE * 2)) {
 			s16 tmp = pdadc_tmp[table_size - 1] +
 					(pdadc_0 - max_idx) * pwr_step;
 			pdadc_out[pdadc_i++] = (tmp > 127) ? 127 : (u8) tmp;
 			pdadc_0++;
--
 	while (pdadc_i < AR5K_EEPROM_POWER_TABLE_SIZE * 2) {
 		pdadc_out[pdadc_i] = pdadc_out[pdadc_i - 1];
 		pdadc_i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(rx_pktq)) {
 		fetched_pkts = 0;
 
@@ -1736,6 +1741,12 @@ static int ath6kl_htc_rx_fetch(struct ht
 
 			list_add_tail(&packet->list, comp_pktq);
--
-	while (len < buf_len && !ath6kl_debug_fwlog_empty(ar)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len < buf_len && !ath6kl_debug_fwlog_empty(ar)) {
 		ccnt = CIRC_CNT_TO_END(fwlog->head, fwlog->tail,
 				       ATH6KL_FWLOG_SIZE);
 
@@ -332,6 +337,12 @@ static ssize_t ath6kl_fwlog_read(struct
 
--
-	while (!list_empty(packet_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(packet_queue)) {
 
 		packet = list_first_entry(packet_queue, struct htc_packet,
 					  list);
@@ -599,6 +604,12 @@ void ath6kl_tx_complete(void *context, s
 
--
 	while (num) {
 		skb = ath6kl_buf_alloc(ATH6KL_BUFFER_SIZE);
 		if (!skb) {
@@ -663,6 +679,12 @@ static void ath6kl_alloc_netbufs(struct
 		}
 		skb_queue_tail(q, skb);
--
 	while (count) {
 		skb = ath6kl_buf_alloc(ATH6KL_AMSDU_BUFFER_SIZE);
 		if (!skb)
@@ -735,6 +762,12 @@ void ath6kl_refill_amsdu_rxbufs(struct a
 		list_add_tail(&packet->list, &ar->amsdu_rx_buffer_queue);
 		spin_unlock_bh(&ar->lock);
--
-	while (time_before(jiffies, timeout) && !ar->bmi.cmd_credits) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, timeout) && !ar->bmi.cmd_credits) {
 
 		/*
 		 * Hit the credit counter with a 4-byte access, the first byte
@@ -52,6 +57,12 @@ static int ath6kl_get_bmi_cmd_credits(st
 		 * Ignore anything in the upper 3 bytes
--
-	while (time_before(jiffies, timeout) && !rx_word) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, timeout) && !rx_word) {
 		ret = hif_read_write_sync(ar, RX_LOOKAHEAD_VALID_ADDRESS,
 					  (u8 *)&rx_word, sizeof(rx_word),
 					  HIF_RD_SYNC_BYTE_INC);
@@ -80,6 +96,12 @@ static int ath6kl_bmi_get_rx_lkahd(struc
 
--
-	while (len_remain) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len_remain) {
 		rx_len = (len_remain < BMI_DATASZ_MAX) ?
 					len_remain : BMI_DATASZ_MAX;
 		offset = 0;
@@ -316,6 +343,12 @@ int ath6kl_bmi_read(struct ath6kl *ar, u
 		}
--
 	while (len_remain) {
 		src = &buf[len - len_remain];
 
@@ -380,6 +418,12 @@ int ath6kl_bmi_write(struct ath6kl *ar,
 			return ret;
 		}
--
-	while (len_remain) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len_remain) {
 		tx_len = (len_remain < (BMI_DATASZ_MAX - header)) ?
 			  len_remain : (BMI_DATASZ_MAX - header);
 
@@ -597,6 +646,12 @@ int ath6kl_bmi_lz_data(struct ath6kl *ar
 		}
--
 	while (atomic_read(&ar_sdio->irq_handling)) {
 		sdio_release_host(ar_sdio->func);
 		schedule_timeout(HZ / 10);
 		sdio_claim_host(ar_sdio->func);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(skb) {
 		hdr = (struct ieee80211_hdr *) skb->data;
 
@@ -342,6 +347,12 @@ static void ath9k_htc_send_buffered(stru
 		}
 	next:
--
 	while (skb) {
 		ath_tx_cabq(hw, skb);
 		skb = ieee80211_get_buffered_bc(hw, vif);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = __skb_dequeue(&tid->buf_q))) {
 		fi = get_frame_info(skb);
 		bf = fi->bf;
@@ -178,6 +183,12 @@ static void ath_tx_flush_tid(struct ath_
 			ath_tx_send_normal(sc, txq, NULL, skb);
 		}
--
 	while (tid->baw_head != tid->baw_tail && !test_bit(tid->baw_head, tid->tx_buf)) {
 		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
 		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = __skb_dequeue(&tid->buf_q))) {
 		fi = get_frame_info(skb);
 		bf = fi->bf;
@@ -253,6 +280,12 @@ static void ath_tid_drain(struct ath_sof
 		spin_unlock(&txq->axq_lock);
 		ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0, 0);
--
 	while (bf) {
 		fi = get_frame_info(bf->bf_mpdu);
 		ba_index = ATH_BA_INDEX(seq_st, bf->bf_state.seqno);
@@ -349,6 +387,12 @@ static void ath_tx_count_frames(struct a
 			(*nbad)++;
 
--
-		while (bf) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bf) {
 			bf_next = bf->bf_next;
 
 			if (!bf->bf_stale || bf_next != NULL)
@@ -401,6 +450,12 @@ static void ath_tx_complete_aggr(struct
 				0, 0);
--
 	while (bf) {
 		struct sk_buff *skb = bf->bf_mpdu;
 		struct ath_frame_info *fi = get_frame_info(skb);
@@ -1058,6 +1118,12 @@ static void ath_tx_fill_desc(struct ath_
 
 		ath9k_hw_set_txdesc(ah, bf->bf_desc, &info);
--
 	while (!list_empty(list)) {
 		bf = list_first_entry(list, struct ath_buf, list);
 
@@ -1440,6 +1511,12 @@ static void ath_drain_txq_list(struct at
 		else
 			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0, 0);
--
-		while (!list_empty(&txq->txq_fifo[idx])) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&txq->txq_fifo[idx])) {
 			ath_drain_txq_list(sc, txq, &txq->txq_fifo[idx],
 					   retry_tx);
 
 			INCR(idx, ATH_TXFIFO_DEPTH);
+			if (_cur < timeout) {
--
 		while (ndesc_skipped) {
 			dma_len = ndesc_skipped * desc_len;
 			dd->dd_desc_len += dma_len;
 
 			ndesc_skipped = ATH_DESC_4KB_BOUND_NUM_SKIPPED(dma_len);
+			if (_cur < timeout) {
--
-			while (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {
 				BUG_ON((caddr_t) bf->bf_desc >=
 				       ((caddr_t) dd->dd_desc +
 					dd->dd_desc_len));
@@ -396,6 +412,12 @@ int ath_descdma_setup(struct ath_softc *
 				ds += (desc_len * ndesc);
--
 	while (pmu_set != REG_READ(ah, pmu_reg)) {
 		if (timeout-- == 0)
 			return false;
 		REG_WRITE(ah, pmu_reg, pmu_set);
 		udelay(10);
+		if (_cur < timeout) {
--
 	while (tx_chainmask || rx_chainmask) {
 		if (tx_chainmask & BIT(0))
 			pCap->max_txchains++;
@@ -2345,6 +2350,12 @@ int ath9k_hw_fill_cap_info(struct ath_hw
 
 		tx_chainmask >>= 1;
--
-	while (thresh_mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (thresh_mask) {
 		index = rightmost_index(timer_table, &thresh_mask);
 		timer = timer_table->timers[index];
 		BUG_ON(!timer);
 		ath_dbg(common, ATH_DBG_HWTIMER,
 			"TSF overflow for Gen timer %d\n", index);
--
-	while (trigger_mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (trigger_mask) {
 		index = rightmost_index(timer_table, &trigger_mask);
 		timer = timer_table->timers[index];
 		BUG_ON(!timer);
 		ath_dbg(common, ATH_DBG_HWTIMER,
 			"Gen timer[%d] trigger\n", index);
--
 	while (i < ARRAY_SIZE(mcs_rix_off) && rate->idx > mcs_rix_off[i]) {
 		rix++; i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 		while ((ss < maxIndex) && (k < (AR5416_NUM_PDADC_VALUES - 1))) {
 			pPDADCValues[k++] = vpdTableI[i][ss++];
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
--
-			while ((ss <= tgtIndex) &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((ss <= tgtIndex) &&
 			       (k < (AR5416_NUM_PDADC_VALUES - 1))) {
 				tmpVal = (int16_t)((vpdTableI[i][sizeCurrVpdTable - 1] +
 						    (ss - maxIndex + 1) * vpdStep));
 				pPDADCValues[k++] = (u8)((tmpVal > 255) ?
 							 255 : tmpVal);
--
 	while (index < len) {
 		u16 pkt_len;
 		u16 pkt_tag;
@@ -613,7 +618,13 @@ static void ath9k_hif_usb_rx_stream(stru
 			skb_put(nskb, pkt_len);
 			skb_pool[pool_index++] = nskb;
--
 	while (len) {
 		transfer = min_t(int, len, 4096);
 		memcpy(buf, data, transfer);
@@ -997,6 +1013,12 @@ static int ath9k_hif_usb_download_fw(str
 		len -= transfer;
 		data += transfer;
--
 	while ((urb = usb_get_from_anchor(&ar->tx_err))) {
 		struct sk_buff *skb = (void *)urb->context;
 
 		carl9170_tx_drop(ar, skb);
 		carl9170_tx_callback(ar, skb);
 		usb_free_urb(urb);
--
 	while ((urb = usb_get_from_anchor(&ar->tx_wait))) {
 		struct sk_buff *skb = (void *)urb->context;
 		carl9170_tx_drop(ar, skb);
 		carl9170_tx_callback(ar, skb);
 		usb_free_urb(urb);
+		if (_cur < timeout) {
--
 	while (len) {
 		transfer = min_t(unsigned int, len, 4096u);
 		memcpy(buf, data, transfer);
@@ -822,6 +849,12 @@ static int carl9170_usb_load_firmware(st
 		len -= transfer;
 		data += transfer;
--
 	while (pos_addr < end_addr) {
 		if (pos_addr + sizeof(*head) > end_addr)
 			return -E2BIG;
@@ -93,6 +98,12 @@ static int carl9170_fw_verify_descs(stru
 		pos_addr += pos_length;
 		pos = (void *)pos_addr;
--
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -505,6 +510,12 @@ static u8 *carl9170_find_ie(u8 *data, un
 			return pos;
 
--
-	while (!list_empty(&tid_gc)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&tid_gc)) {
 		struct sk_buff *skb;
 		tid_info = list_first_entry(&tid_gc, struct carl9170_sta_tid,
 					    tmp_list);
@@ -214,6 +219,12 @@ static void carl9170_ampdu_gc(struct ar9
 
--
 			while ((skb = skb_dequeue(&ar->tx_pending[i]))) {
 				struct ieee80211_tx_info *info;
 
@@ -238,6 +254,12 @@ static void carl9170_flush(struct ar9170
 					atomic_dec(&ar->tx_ampdu_upload);
 
--
 		while (!skb_queue_empty(&ar->tx_status[i])) {
 			struct sk_buff *skb;
 
@@ -295,6 +322,12 @@ static void carl9170_zap_queues(struct a
 			carl9170_tx_drop(ar, skb);
 			spin_lock_bh(&ar->tx_status[i].lock);
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		err = carl9170_exec_cmd(ar, CARL9170_CMD_RREG,
 					RB, (u8 *) rng_load,
 					RB, (u8 *) buf);
@@ -1506,6 +1544,12 @@ static int carl9170_rng_get(struct ar917
 
--
 	while (pos + 1 < PRISM2_PDA_SIZE / 2) {
 		len = le16_to_cpu(pda[pos]);
 		pdr = le16_to_cpu(pda[pos + 1]);
@@ -168,6 +173,12 @@ static int prism2_pda_ok(u8 *buf)
 		}
 
--
 	while (entry) {
 		spin_lock_bh(&ap->sta_table_lock);
 		sta = ap_get_sta(ap, entry->addr);
@@ -1086,6 +1091,12 @@ static void handle_add_proc_queue(struct
 		prev = entry;
 		entry = entry->next;
--
-	while (entry) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (entry) {
 		PDEBUG(DEBUG_AP, "%s: %s automatic WDS connection "
 		       "to AP %pM\n",
 		       local->dev->name,
@@ -1973,6 +1989,12 @@ static void handle_wds_oper_queue(struct
 		prev = entry;
--
 	while (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE &&
 	       work_done < quota) {
 		work_done += flexcan_read_frame(dev);
 		reg_iflag1 = flexcan_read(&regs->iflag1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count--) {
 		if (fp && *fp++) {
 			if (!test_and_set_bit(SLF_ERROR, &sl->flags))
@@ -420,6 +425,12 @@ static void slcan_receive_buf(struct tty
 			continue;
 		}
--
 			while (status & SR_RBS) {
 				sja1000_rx(dev);
 				status = priv->read_reg(priv, SJA1000_REG_SR);
 				/* check for absent controller */
 				if (status == 0xFF && sja1000_is_absent(priv))
 					goto out;
--
-	while (count && priv->read_reg(priv,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count && priv->read_reg(priv,
 				&priv->regs->ifregs[iface].com_req) &
 				IF_COMR_BUSY) {
 		count--;
 		udelay(1);
+		if (_cur < timeout) {
--
-	while (!(bfin_read(&reg->control) & CCA)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(bfin_read(&reg->control) & CCA)) {
 		udelay(10);
 		if (--timeout == 0) {
 			dev_err(dev->dev.parent,
 					"fail to enter configuration mode\n");
 			BUG();
--
-	while (bfin_read(&reg->status) & CCA) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (bfin_read(&reg->status) & CCA) {
 		udelay(10);
 		if (--timeout == 0) {
 			dev_err(dev->dev.parent,
 					"fail to leave configuration mode\n");
 			BUG();
--
-		while (!(bfin_read(&reg->intr) & SMACK)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!(bfin_read(&reg->intr) & SMACK)) {
 			udelay(10);
 			if (--timeout == 0) {
 				dev_err(dev->dev.parent,
 						"fail to enter sleep mode\n");
 				BUG();
--
-		while (mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK) {
 			schedule();
 			if (time_after(jiffies, timeout)) {
 				dev_err(&spi->dev, "MCP251x didn't"
 					" enter in normal mode\n");
 				return -EBUSY;
--
 	while (mem < end) {
 		ret = fw_parse(&mem, &type, &addr, &len, &dat);
 		if (ret < 0)
@@ -213,6 +218,12 @@ int softing_load_fw(const char *file, st
 			ret = -EIO;
 			goto failed;
--
 	while (mem < end) {
 		ret = fw_parse(&mem, &type, &addr, &len, &dat);
 		if (ret)
@@ -307,6 +323,12 @@ int softing_load_app_fw(const char *file
 			ret = -EIO;
 			goto failed;
--
 	while (unlikely(ktime_to_ns(tmp) > ktime_to_ns(now))) {
 		card->ts_ref = ktime_add(card->ts_ref, card->ts_overflow);
 		target = tmp;
 		tmp = ktime_add(target, card->ts_overflow);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count && (offset >= from->iov_len)) {
 		offset -= from->iov_len;
 		++from;
 		--count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count--) {
 		struct page *page[MAX_SKB_FRAGS];
 		int num_pages;
@@ -543,6 +559,11 @@ static int zerocopy_sg_from_iovec(struct
 		skb->len += len;
 		skb->truesize += truesize;
--
 		while (len) {
 			int off = base & ~PAGE_MASK;
 			int size = min_t(int, len, PAGE_SIZE - off);
@@ -552,9 +573,21 @@ static int zerocopy_sg_from_iovec(struct
 			base += size;
 			len -= size;
--
 	while (nr_segs && (offset >= iv->iov_len)) {
 		offset -= iv->iov_len;
 		++iv;
 		--nr_segs;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len) {
 		set_skb_frag(skb, page, offset, &len);
 		page = (struct page *)page->private;
 		offset = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--num_buf) {
 		i = skb_shinfo(skb)->nr_frags;
 		if (i >= MAX_SKB_FRAGS) {
@@ -246,6 +262,12 @@ static int receive_mergeable(struct virt
 		set_skb_frag(skb, page, 0, &len);
 
--
-	while (a & 0x80 || a & 0x40) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (a & 0x80 || a & 0x40) {
 		/* a little sleep */
 		yield();
 
@@ -276,6 +281,12 @@ card_wait_for_busy_clear(const int ioadd
 				name);
--
-	while (a & 0x80 || !(a & 0x40)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (a & 0x80 || !(a & 0x40)) {
 		/* a little sleep */
 		yield();
 
@@ -300,6 +316,12 @@ card_wait_for_ready(const int ioaddr[],
 				name);
--
-	while (inb(ioaddr[1] + 6) & 0x80) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb(ioaddr[1] + 6) & 0x80) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready timeout\n",
 				name);
 			return -ETIME;
 		}
--
-	while (!(inb(ioaddr[1] + 6) & 0x40)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(inb(ioaddr[1] + 6) & 0x40)) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready timeout\n",
 				name);
 			return -ETIME;
 		}
--
-	while (inb(ioaddr[1] + 6) & 0x80) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb(ioaddr[1] + 6) & 0x80) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready_clear timeout\n",
 				name);
 			return -ETIME;
 		}
--
-	while (inb(ioaddr[1] + 6) & 0x40) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb(ioaddr[1] + 6) & 0x40) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready_clear timeout\n",
 				name);
 			return -ETIME;
 		}
--
-	while (bp->rcv_xmt_reg.index.rcv_comp != p_type_2_cons->index.rcv_cons)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bp->rcv_xmt_reg.index.rcv_comp != p_type_2_cons->index.rcv_cons)
 		{
 		/* Process any errors */
 
@@ -3120,6 +3125,12 @@ static void dfx_rcv_queue_process(
 
--
-	while (bp->rcv_xmt_reg.index.xmt_comp != p_type_2_cons->index.xmt_cons)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bp->rcv_xmt_reg.index.xmt_comp != p_type_2_cons->index.xmt_cons)
 		{
 		/* Get pointer to the transmit driver descriptor block information */
 
@@ -3417,6 +3433,12 @@ static int dfx_xmt_done(DFX_board_t *bp)
 
--
-	while (bp->rcv_xmt_reg.index.xmt_comp != bp->rcv_xmt_reg.index.xmt_prod)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bp->rcv_xmt_reg.index.xmt_comp != bp->rcv_xmt_reg.index.xmt_prod)
 		{
 		/* Get pointer to the transmit driver descriptor block information */
 
@@ -3544,6 +3571,12 @@ static void dfx_xmt_flush( DFX_board_t *
 		 */
--
-	while (smc->e.trace_prop) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (smc->e.trace_prop) {
 		DB_ECM("ECM : prop_actions - trace_prop %d\n",
 			smc->e.trace_prop,0) ;
 
@@ -511,6 +516,12 @@ static void prop_actions(struct s_smc *s
 			DB_ECM("ECM : propagate TRACE on PHY %d\n",upstream,0) ;
--
 	while (oem_ids[i].oi_status) {
 		switch (oem_ids[i].oi_status) {
 		case OI_STAT_ACTIVE:
@@ -524,6 +529,12 @@ int set_oi_id_def(struct s_smc *smc)
 		default:
 			return 1;		/* invalid oi_status */
--
 	while (*p) {
 		if (!sm_to_para(smc,sm,(int) *p)) {
 			DB_SMT("SMT: smt_check_para - missing para %x\n",*p,0);
 			return -1;
 		}
 		p++ ;
--
 	while (tm && !done) {
 		if (delta >= tm->tm_delta) {
 			tm->tm_active = FALSE ;
@@ -140,6 +145,12 @@ static void timer_done(struct s_smc *smc
 			delta = 0 ;
 			done = 1 ;
--
 	while (tx_used) {
 		DRV_BUF_FLUSH(t,DDI_DMA_SYNC_FORCPU) ;
 		tbctrl = le32_to_cpu(t->txd_tbctrl) ;
@@ -620,6 +625,12 @@ static u_long repair_txd_ring(struct s_s
 		DRV_BUF_FLUSH(t,DDI_DMA_SYNC_FORDEV) ;
 		t = t->txd_next ;
--
 	while (rx_used) {
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
 		rbctrl = le32_to_cpu(r->rxd_rbctrl) ;
@@ -672,6 +688,12 @@ static u_long repair_rxd_ring(struct s_s
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORDEV) ;
 		r = r->rxd_next ;
--
 		while ((mb = get_llc_rx(smc))) {
 			smt_to_llc(smc,mb) ;
-		}
+			if (_cur < timeout) {
+rdstcll(_cur);
+			}
--
 		while (!offDepth && (mb = get_llc_rx(smc))) {
 			smt_to_llc(smc,mb) ;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
--
 		while (rx_used && !(r->rxd_rbctrl & cpu_to_le32(BMU_ST_BUF))) {
 			DB_RX("Check STF bit in %x",(void *)r,0,5) ;
 			r = r->rxd_next ;
 			DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
 			frag_count++ ;
 			rx_used-- ;
--
 	while (queue->rx_used) {
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
 		DB_RX("switch OWN bit of RxD 0x%x ",r,0,5) ;
@@ -1489,6 +1549,11 @@ void mac_drv_clear_rx_queue(struct s_smc
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORDEV) ;
 		r = r->rxd_next ;
--
 		while (r != queue->rx_curr_put &&
 			!(r->rxd_rbctrl & cpu_to_le32(BMU_ST_BUF))) {
 			DB_RX("Check STF bit in %x",(void *)r,0,5) ;
@@ -1497,6 +1562,12 @@ void mac_drv_clear_rx_queue(struct s_smc
 			r = r->rxd_next ;
 			DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
--
 	while (len) {
 		n = SMT_PAGESIZE - ((long)data & (SMT_PAGESIZE-1)) ;
 		if (n >= len) {
@@ -1844,6 +1926,12 @@ void smt_send_mbuf(struct s_smc *smc, SM
 		frag_count++ ;
 		len -= n ;
--
 		while (tx_used) {
 			DRV_BUF_FLUSH(t,DDI_DMA_SYNC_FORCPU) ;
 			DB_TX("switch OWN bit of TxD 0x%x ",t,0,5) ;
@@ -2057,6 +2150,12 @@ void mac_drv_clear_tx_queue(struct s_smc
 			DRV_BUF_FLUSH(t,DDI_DMA_SYNC_FORDEV) ;
 			t = t->txd_next ;
--
 	while (swap && (c = *swap++)) {
 		switch(c) {
 		case 'b' :
@@ -1292,6 +1297,12 @@ static int smt_set_para(struct s_smc *sm
 			SMT_PANIC(smc,SMT_E0120, SMT_E0120_MSG) ;
 			return SMT_RDF_ILLEGAL;
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (len--) {
 		n++ ;
 #ifdef UNIX
 		printf("%x%s",*p++ & 0xff,len ? ( (n & 7) ? " " : "-") : "") ;
 #else
 		printf("%02x%s",*p++ & 0xff,len ? ( (n & 7) ? " " : "-") : "") ;
--
 	while (proto) {
 		if ((result = proto->ioctl(dev, ifr)) != -EINVAL)
 			return result;
 		proto = proto->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (*p != proto) {
 		BUG_ON(!*p);
 		p = &((*p)->next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (1) {
                 desc_t *desc = &get_status(port)->tx_descs[port->tx_in];
 		struct sk_buff *skb = port->tx_skbs[port->tx_in];
@@ -187,6 +192,12 @@ static inline void wanxl_tx_intr(port_t
 				 PCI_DMA_TODEVICE);
 		dev_kfree_skb_irq(skb);
--
 	while(len)
 	{	
 		offset = addr & SDLA_ADDR_MASK;
@@ -99,6 +104,12 @@ static void __sdla_read(struct net_devic
 		addr += bytes;
 		temp += bytes;
--
 	while(len)
 	{
 		offset = addr & SDLA_ADDR_MASK;
@@ -130,6 +146,12 @@ static void __sdla_write(struct net_devi
 		addr += bytes;
 		temp += bytes;
--
 	while(len)
 	{
 		SDLA_WINDOW(dev, addr);
@@ -163,6 +190,12 @@ static void sdla_clear(struct net_device
 
 		addr += bytes;
--
 	while (time_before(jiffies, done) && (resp != resp1) && (!resp2 || (resp != resp2)))
 	{
 		if (jiffies != now)
@@ -268,6 +306,12 @@ static int sdla_z80_poll(struct net_devi
 			now = jiffies;
 			resp = *temp;
--
 	while (waiting && time_before_eq(jiffies, jiffs))
 	{
 		if (waiting++ % 3) 
@@ -470,6 +519,12 @@ static int sdla_cmd(struct net_device *d
 			waiting = ((volatile int)(cmd_buf->opp_flag));
 			spin_unlock_irqrestore(&sdla_lock, pflags);
--
 	while ((status = cpc_readb(&ptdescr->status)) & DST_OSB) {
 		rcvd += cpc_readw(&ptdescr->len);
 		first_bd = (first_bd + 1) & (N_DMA_RX_BUF - 1);
@@ -456,6 +461,12 @@ static int dma_get_rx_frame_size(pc300_t
 			return rcvd;
 		}
--
 	while (1) {
 		if ((rxb = dma_get_rx_frame_size(card, ch)) == -1)
 			return;
@@ -1954,6 +1970,12 @@ static void cpc_net_rx(struct net_device
 		dev->stats.rx_packets++;
 		skb->protocol = hdlc_type_trans(skb, dev);
--
 	while ((cpc_readl(card->hw.scabase + DTX_REG(CDAL,ch)) !=
 		TX_BD_ADDR(ch,chan->tx_first_bd)) &&
 	       (cpc_readb(&ptdescr->status) & DST_OSB)) {
@@ -1980,7 +2007,13 @@ static void sca_tx_intr(pc300dev_t *dev)
 		chan->nfree_tx_bd++;
 		chan->tx_first_bd = (chan->tx_first_bd + 1) & (N_DMA_TX_BUF - 1);
--
 	while (card) {
 		card_t *ptr = card;
 		card = card->next_card;
 		unregister_hdlc_device(port_to_dev(ptr));
 		c101_destroy_card(ptr);
+		if (_cur < timeout) {
--
 	while (!chan->rx_status) {
 		current->state = TASK_INTERRUPTIBLE;
 		spin_unlock_irqrestore(&cosa->lock, flags);
@@ -818,6 +823,12 @@ static ssize_t cosa_read(struct file *fi
 			mutex_unlock(&chan->rlock);
 			return -ERESTARTSYS;
--
 	while (!chan->tx_status) {
 		current->state = TASK_INTERRUPTIBLE;
 		spin_unlock_irqrestore(&cosa->lock, flags);
@@ -904,6 +920,12 @@ static ssize_t cosa_write(struct file *f
 			up(&chan->wsem);
 			return -ERESTARTSYS;
--
-	while (length--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (length--) {
 		char c;
 #ifndef SRP_DOWNLOAD_AT_BOOT
 		if (get_user(c, microcode))
@@ -1423,6 +1450,12 @@ static int download(struct cosa_data *co
 		if (put_wait_data(cosa, c) == -1)
--
-	while (length--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (length--) {
 		char c;
 		int i;
 		if ((i=get_wait_data(cosa)) == -1) {
@@ -1499,6 +1537,12 @@ static int readmem(struct cosa_data *cos
 		*microcode = c;
--
-	while (--retries) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (--retries) {
 		/* read data and return them */
 		if (cosa_getstatus(cosa) & SR_RX_RDY) {
 			short r;
@@ -1578,6 +1627,12 @@ static int get_wait_data(struct cosa_dat
 		}
--
-	while (--retries) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (--retries) {
 		/* read data and return them */
 		if (cosa_getstatus(cosa) & SR_TX_RDY) {
 			cosa_putdata8(cosa, data);
@@ -1605,6 +1665,12 @@ static int put_wait_data(struct cosa_dat
 		/* sleep if not ready to read */
--
 			while (cpc_tty_area[port].buf_rx.first) {
 				aux = (unsigned char *)cpc_tty_area[port].buf_rx.first;
 				cpc_tty_area[port].buf_rx.first = cpc_tty_area[port].buf_rx.first->next;
 				kfree(aux);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 		while (cpc_tty->buf_rx.first) {
 			aux = (unsigned char *)cpc_tty->buf_rx.first;
 			cpc_tty->buf_rx.first = cpc_tty->buf_rx.first->next;
 			kfree(aux);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (1) { 
 		rx_len = 0;
 		ptdescr = (pcsca_bd_t  __iomem *)(card->hw.rambase + RX_BD_ADDR(ch, first_bd));
@@ -878,6 +905,12 @@ void cpc_tty_receive(pc300dev_t *pc300de
 			schedule_work(&(cpc_tty->tty_rx_work));
 			stats->rx_packets++;
--
 	while(c->txcount) {
 		/* FIFO full ? */
 		if(!(read_zsreg(c, R0)&4))
@@ -424,6 +429,12 @@ static void z8530_tx(struct z8530_channe
 			write_zsctrl(c, RES_EOM_L);
 			write_zsreg(c, R10, c->regs[10]&~ABUNDER);
--
 			while(c->txcount && (read_zsreg(c,R0)&Tx_BUF_EMP))
 			{		
 				write_zsreg(c, R8, *c->tx_ptr++);
 				c->txcount--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 		while (!(FST_RDB(card, txDescrRing[pi][port->txpos].bits) &
 			 DMA_OWN) &&
 		       !(card->dmatx_in_progress)) {
@@ -1431,6 +1436,12 @@ do_bottom_half_tx(struct fst_card_info *
 				 */
 				break;
--
 	while (rdidx != wridx) {
 		event = FST_RDB(card, interruptEvent.evntbuff[rdidx]);
 		port = &card->ports[event & 0x03];
@@ -1622,6 +1638,12 @@ fst_intr(int dummy, void *dev_id)
 		/* Bump and wrap the index */
 		if (++rdidx >= MAX_CIRBUFF)
--
 	while (*s) {
 		d[i] = (*s - '0') << 4;
 		if (*(s + 1))
@@ -1151,6 +1156,12 @@ static int byte_to_nibble(u8 *s, u8 *d,
 		}
 		++i;
--
 	while (len) {
 		*d++ = '0' + (*s >> 4);
 
@@ -1172,6 +1188,12 @@ static void nibble_to_byte(u8 *s, u8 *d,
 		} else break;
 
--
-	while(dev) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while(dev) {
 		struct cycx_x25_channel *chan = netdev_priv(dev);
 
 		pr_info("%-5.5s %-15.15s   %d     ETH_P_%s\n",
 			chan->name, chan->addr, netif_queue_stopped(dev),
 			chan->protocol == ETH_P_IP ? "IP" : "X25");
--
-		while(1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while(1) {
 			if (*hw == '0' && !valid[0])
 				valid[0] = 1; /* Port 0 enabled */
 			else if (*hw == '1' && !valid[1])
@@ -529,6 +534,12 @@ static int __init n2_init(void)
 			else
--
 	while (card) {
 		card_t *ptr = card;
 		card = card->next_card;
 		n2_destroy_card(ptr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (0xffffffc0 & divider) {
 				m++;
 				divider >>= 1;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
--
 			//while (dpriv->rx_needs_refill) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (!(rx_fd->state1 & Hold)) {
 					rx_fd++;
 					cur++;
 					if (!(cur = cur%RX_RING_SIZE))
 						rx_fd = dpriv->rx_fd;
+						if (_cur < timeout) {
--
 	while (pvc) {
 		if (pvc->dlci == dlci)
 			return pvc;
 		if (pvc->dlci > dlci)
 			return NULL; /* the list is sorted */
 		pvc = pvc->next;
--
-	while (*pvc_p) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (*pvc_p) {
 		if (!pvc_is_used(*pvc_p)) {
 			pvc_device *pvc = *pvc_p;
 #ifdef DEBUG_PVC
@@ -259,6 +275,12 @@ static inline void delete_unused_pvcs(hd
 			continue;
--
-		while (pvc) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (pvc) {
 			data[i++] = lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :
 				LMI_ANSI_CISCO_PVCSTAT;
 			data[i++] = stat_len;
@@ -550,6 +577,12 @@ static void fr_lmi_send(struct net_devic
 
--
 			while (pvc) {	/* Activate all PVCs */
 				pvc_carrier(1, pvc);
 				pvc->state.exist = pvc->state.active = 1;
 				pvc->state.new = 0;
 				pvc = pvc->next;
+				if (_cur < timeout) {
--
 		while (pvc) {		/* Deactivate all PVCs */
 			pvc_carrier(0, pvc);
 			pvc->state.exist = pvc->state.active = 0;
@@ -591,6 +640,12 @@ static void fr_set_link_state(int reliab
 			if (!state(hdlc)->settings.dce)
 				pvc->state.bandwidth = 0;
--
 			while (pvc) {
 				if (pvc->state.new) {
 					pvc->state.new = 0;
@@ -756,6 +816,12 @@ static int fr_lmi_recv(struct net_device
 					state(hdlc)->dce_changed = 1;
 				}
--
 	while (pvc) {
 		pvc->state.deleted = 1;
 		pvc = pvc->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (skb->len >= i + 2 + stat_len) {
 		u16 dlci;
 		u32 bw;
@@ -843,10 +925,21 @@ static int fr_lmi_recv(struct net_device
 		}
 
--
 	while (pvc) {
 		if (pvc->state.deleted && pvc->state.exist) {
 			pvc_carrier(0, pvc);
@@ -856,6 +949,12 @@ static int fr_lmi_recv(struct net_device
 			fr_log_dlci_active(pvc);
 		}
--
 	while (pvc) {		/* Shutdown all PVCs for this FRAD */
 		if (pvc->main)
 			dev_close(pvc->main);
 		if (pvc->ether)
 			dev_close(pvc->ether);
 		pvc = pvc->next;
--
 	while (pvc) {
 		pvc_device *next = pvc->next;
 		/* destructors will free_netdev() main and ether */
@@ -1160,6 +1275,12 @@ static void fr_destroy(struct net_device
 
 		kfree(pvc);
--
-	while (received < budget) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (received < budget) {
 		struct sk_buff *skb;
 		struct desc *desc;
 		int n;
@@ -779,6 +784,12 @@ static int hss_hdlc_poll(struct napi_str
 		desc->pkt_len = 0;
--
-	while (readw(addr)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (readw(addr)) {
 		udelay(1000);
 
 		if (++i > 50)
 			return -1;
+			if (_cur < timeout) {
--
 	while (count--) {
 		if (fp && *fp++) {
 			if (!test_and_set_bit(SLF_ERROR, &sl->flags))
@@ -534,6 +539,12 @@ static void x25_asy_receive_buf(struct t
 			continue;
 		}
--
-	while (!(rd->rdma.cntinfo & HPCDMA_OWN)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(rd->rdma.cntinfo & HPCDMA_OWN)) {
 		len = PKT_BUF_SZ - (rd->rdma.cntinfo & HPCDMA_BCNT) - 3;
 		dma_unmap_single(dev->dev.parent, rd->rdma.pbuf,
 				 PKT_BUF_SZ, DMA_FROM_DEVICE);
@@ -404,6 +409,12 @@ memory_squeeze:
 		dma_sync_desc_dev(dev, rd);
--
 	while ((td->tdma.cntinfo & (HPCDMA_XIU | HPCDMA_ETXD)) ==
 	      (HPCDMA_XIU | HPCDMA_ETXD)) {
 		i = NEXT_TX(i);
 		td = &sp->tx_desc[i];
 		dma_sync_desc_cpu(dev, td);
+		if (_cur < timeout) {
--
 	while (i < (nbufs - 1)) {
 		buf[i].tdma.pnext = VIRT_TO_DMA(sp, buf + i + 1);
 		buf[i].tdma.pbuf = 0;
 		dma_sync_desc_dev(dev, &buf[i]);
 		i++;
+		if (_cur < timeout) {
--
 	while (i < (nbufs - 1)) {
 		buf[i].rdma.pnext = VIRT_TO_DMA(sp, buf + i + 1);
 		buf[i].rdma.pbuf = 0;
 		dma_sync_desc_dev(dev, &buf[i]);
 		i++;
+		if (_cur < timeout) {
--
 			while (mii_phy) {
 				struct mii_phy *phy;
 				phy = mii_phy;
 				mii_phy = mii_phy->next;
 				kfree(phy);
+				if (_cur < timeout) {
--
-		while (poll_bit) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (poll_bit) {
 			yield();
 
 			poll_bit ^= (mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS) & poll_bit);
@@ -689,6 +705,12 @@ static int __devinit sis900_mii_probe(st
 				       dev_name);
--
 	while (sis_priv->first_mii) {
 		phy = sis_priv->first_mii;
 		sis_priv->first_mii = phy->next;
 		kfree(phy);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while(!(inb(dev->base_addr+2)&(1<<5)))
 		{
 			n++;
@@ -497,6 +502,12 @@ static int __init mc32_probe1(struct net
 				err = -ENODEV;
 				goto err_exit_irq;
--
-		while ((dev->base_addr = addr_list[idx++])) {
-			if (elp_sense(dev) == 0)
-				return dev->base_addr;
+	} else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
--
+			while ((dev->base_addr = addr_list[idx++])) {
+				if (elp_sense(dev) == 0)
+					return dev->base_addr;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
--
 	while (((status = inb(ioaddr + STATUS_REG)) & (RX_INT|TX_INT)) && (boguscount--))
 	{
 		handled = 1;
@@ -1231,6 +1236,12 @@ eepro_interrupt(int irq, void *dev_id)
 
 			eepro_en_int(ioaddr);
--
 	while ((rfd->stat) & STAT_C) {	/* Loop while complete frames */
 		if (rfd->rbd == I596_NULL)
 			rbd = I596_NULL;
@@ -894,6 +899,12 @@ memory_squeeze:
 		lp->scb.rfd = rfd->b_next;
 		lp->rfd_head = rfd->v_next;
--
 	while (--delcnt && dma->iscp.stat) {
 		udelay(10);
 		DMA_INV(dev, &(dma->iscp), sizeof(struct i596_iscp));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (--delcnt && dma->scb.command) {
 		udelay(10);
 		DMA_INV(dev, &(dma->scb), sizeof(struct i596_scb));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (rfd->stat & SWAP16(STAT_C)) {	/* Loop while complete frames */
 		if (rfd->rbd == I596_NULL)
 			rbd = NULL;
@@ -789,6 +816,12 @@ memory_squeeze:
 		DMA_WBACK_INV(dev, rfd->v_prev, sizeof(struct i596_rfd));
 		rfd = lp->rfd_head;
--
 				while (!SCB_complete(rsst=scb_status(dev)))
 				{
 					if (!--boguscount)
@@ -566,6 +571,12 @@ static void unstick_cu(struct net_device
 						scb_command(dev, SCB_CUstart);
 						outb(0,ioaddr+SIGNAL_CA);
--
 		while (!scb_status(dev))
 		{
 			if (!--boguscount)
@@ -1336,6 +1352,12 @@ static void eexp_hw_txrestart(struct net
 					return;
 				}
--
 		while (inw(ioaddr+0x4000))
 		{
 			if (!--rboguscount)
@@ -1532,6 +1559,12 @@ static void eexp_hw_init586(struct net_d
 					return;
 				}
--
 		while (!scb_status(dev))
 		{
 			if (!--iboguscount)
@@ -1560,6 +1598,12 @@ static void eexp_hw_init586(struct net_d
 					return;
 				}
--
-	while (lp->scb.command) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (lp->scb.command) {
 		if (--boguscnt == 0) {
 			printk("%s: %s timed out - stat %4.4x, cmd %4.4x\n",
 			       dev->name, msg,
@@ -400,6 +405,12 @@ i596_timeout(struct net_device *dev, cha
 		}
--
-	while (lp->iscp.busy) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (lp->iscp.busy) {
 		if (--boguscnt == 0) {
 			/* No i82596 present? */
 			printk("%s: i82596 initialization timed out\n",
@@ -609,6 +625,12 @@ i596_scp_setup(struct net_device *dev) {
 		}
--
 	while (lp->cmd_head) {
 		cmd = (struct i596_cmd *)lp->cmd_head;
 
@@ -773,6 +800,12 @@ i596_cleanup_cmd(struct net_device *dev)
 			}
 		}
--
-	while (lp->cmd_head && (lp->cmd_head->status & CMD_STAT_C)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (lp->cmd_head && (lp->cmd_head->status & CMD_STAT_C)) {
 		cmd = lp->cmd_head;
 
 		lp->cmd_head = pa_to_va(lp->cmd_head->pa_next);
@@ -1132,13 +1170,30 @@ i596_handle_CU_completion(struct net_dev
 
--
 	while (cmd && (cmd != lp->cmd_tail)) {
 		cmd->command &= 0x1fff;
 		cmd = pa_to_va(cmd->pa_next);
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (work--) {
 		if (!(cpr8(Cmd) & CmdReset))
 			return;
 
 		schedule_timeout_uninterruptible(10);
+		if (_cur < timeout) {
--
 	while (i < len - 1) {
 		val = read_eeprom(cp->regs, offset, addr_len);
 		data[i++] = (u8)val;
 		data[i++] = (u8)(val >> 8);
 		offset++;
+		if (_cur < timeout) {
--
 	while (i < len - 1) {
 		val = (u16)data[i++];
 		val |= (u16)data[i++] << 8;
 		write_eeprom(cp->regs, offset, val, addr_len);
 		offset++;
+		if (_cur < timeout) {
--
 	while (root_atp_dev) {
 		struct net_local *atp_local = netdev_priv(root_atp_dev);
 		next_dev = atp_local->next_module;
@@ -933,6 +938,12 @@ static void __exit atp_cleanup_module(vo
 		/* No need to release_region(), since we never snarf it. */
 		free_netdev(root_atp_dev);
--
-	while (evtcsm != evtprd) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (evtcsm != evtprd) {
 		switch (ap->evt_ring[evtcsm].evt) {
 		case E_FW_RUNNING:
 			printk(KERN_INFO "%s: Firmware up and running\n",
@@ -1927,6 +1932,12 @@ static u32 ace_handle_event(struct net_d
 			       ap->name, ap->evt_ring[evtcsm].evt);
--
 	while (idx != rxretprd) {
 		struct ring_info *rip;
 		struct sk_buff *skb;
@@ -2030,6 +2046,12 @@ static void ace_rx_int(struct net_device
 		dev->stats.rx_bytes += retdesc->size;
 
--
 	while ((nolock_regb_read(priv, reg) & mask) != val) {
 		if (time_after(jiffies, timeout)) {
 			if (netif_msg_drv(priv))
@@ -430,6 +435,12 @@ static int poll_ready(struct enc28j60_ne
 			return -ETIMEDOUT;
 		}
--
 	while (next_to_clean != hw_next_to_clean) {
 		buffer_info = &tpd_ring->buffer_info[next_to_clean];
 		atl1c_clean_buffer(pdev, buffer_info, 1);
 		if (++next_to_clean == tpd_ring->count)
 			next_to_clean = 0;
 		atomic_set(&tpd_ring->next_to_clean, next_to_clean);
--
 		while (1) {
 			if (atl1_read_eeprom(hw, i + 0x100, &control)) {
 				if (key_valid) {
@@ -468,6 +473,12 @@ static int atl1_get_permanent_address(st
 				/* read error */
 				break;
--
 	while (1) {
 		if (atl1_spi_read(hw, i + 0x1f000, &control)) {
 			if (key_valid) {
@@ -501,6 +517,12 @@ static int atl1_get_permanent_address(st
 			/* read error */
 			break;
--
 	while (rfd_ring->next_to_clean != (rrd->buf_indx + offset)) {
 		rfd_ring->buffer_info[rfd_ring->next_to_clean].alloced = 0;
 		if (++rfd_ring->next_to_clean == rfd_ring->count) {
 			rfd_ring->next_to_clean = 0;
 		}
+		if (_cur < timeout) {
--
 	while (1) {
 		rrd = ATL1_RRD_DESC(rrd_ring, rrd_next_to_clean);
 		i = 1;
@@ -2035,6 +2073,12 @@ rrd_ok:
 		buffer_info->skb = NULL;
 		buffer_info->alloced = 0;
--
-	while (cmb_tpd_next_to_clean != sw_tpd_next_to_clean) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cmb_tpd_next_to_clean != sw_tpd_next_to_clean) {
 		buffer_info = &tpd_ring->buffer_info[sw_tpd_next_to_clean];
 		if (buffer_info->dma) {
 			pci_unmap_page(adapter->pdev, buffer_info->dma,
@@ -2089,6 +2138,12 @@ static void atl1_intr_tx(struct atl1_ada
 
--
 		while (1) {
 			if (atl2_read_eeprom(hw, i + 0x100, &Control)) {
 				if (KeyValid) {
@@ -2288,6 +2293,12 @@ static int get_permanent_address(struct
 				break; /* read error */
 			}
--
 	while (1) {
 		if (atl2_spi_read(hw, i + 0x1f000, &Control)) {
 			if (KeyValid) {
@@ -2324,6 +2340,12 @@ static int get_permanent_address(struct
 			break; /* read error */
 		}
--
 	while (next_to_clean != hw_next_to_clean) {
 		tx_buffer = &tx_ring->tx_buffer[next_to_clean];
 		if (tx_buffer->dma) {
@@ -1246,6 +1251,12 @@ static bool atl1e_clean_tx_irq(struct at
 
 		if (++next_to_clean == tx_ring->count)
--
 	while (mapped_len < buf_len) {
 		/* mapped_len == 0, means we should use the first tpd,
 		   which is given by caller  */
@@ -1745,11 +1761,22 @@ static int atl1e_tx_map(struct atl1e_ada
 			/* We need to unwind the mappings we've done */
 			ring_end = adapter->tx_ring.next_to_use;
--
 			while (adapter->tx_ring.next_to_use != ring_end) {
 				tpd = atl1e_get_tpd(adapter);
 				tx_buffer = atl1e_get_tx_buffer(adapter, tpd);
 				pci_unmap_single(adapter->pdev, tx_buffer->dma,
 						 tx_buffer->length, PCI_DMA_TODEVICE);
+				if (_cur < timeout) {
--
 				while (adapter->tx_ring.next_to_use != ring_end) {
 					tpd = atl1e_get_tpd(adapter);
 					tx_buffer = atl1e_get_tx_buffer(adapter, tpd);
 					dma_unmap_page(&adapter->pdev->dev, tx_buffer->dma,
 						       tx_buffer->length, DMA_TO_DEVICE);
+					if (_cur < timeout) {
--
 	while (rx->fill_cnt != (rx->cnt + rx->mask + 1)) {
 		idx = rx->fill_cnt & rx->mask;
 		if (rx->page_offset + bytes <= MYRI10GE_ALLOC_SIZE) {
@@ -1294,6 +1299,12 @@ myri10ge_alloc_rx_pages(struct myri10ge_
 			myri10ge_submit_8rx(&rx->lanai[idx - 7],
 					    &rx->shadow[idx - 7]);
--
 	while (tx->pkt_done != mcp_index) {
 		idx = tx->done & tx->mask;
 		skb = tx->info[idx].skb;
@@ -1440,6 +1456,12 @@ myri10ge_tx_done(struct myri10ge_slice_s
 							      bus), len,
 					       PCI_DMA_TODEVICE);
--
 	while (tx->done != tx->req) {
 		idx = tx->done & tx->mask;
 		skb = tx->info[idx].skb;
@@ -2176,6 +2203,12 @@ static void myri10ge_free_rings(struct m
 							      bus), len,
 					       PCI_DMA_TODEVICE);
--
 	while (slice) {
 		slice--;
 		napi_disable(&mgp->ss[slice].napi);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-		while (len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (len) {
 			u8 flags_next;
 			int cum_len_next;
 
@@ -2919,6 +2968,12 @@ again:
 				else
--
 	while (segs) {
 		curr = segs;
 		segs = segs->next;
@@ -3030,6 +3090,12 @@ static netdev_tx_t myri10ge_sw_tso(struc
 			}
 			goto drop;
--
 	while (comp_head != comp_busy && n < comps_size) {
 		comps[n++] = eq->comps[comp_head];
 		LEPP_QINC(comp_head);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (qup->__packet_receive_read !=
 	       qsp->__packet_receive_queue.__packet_write) {
 		int index = qup->__packet_receive_read;
 		tile_net_discard_aux(info, index);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (countdown && mbx->ops.check_for_msg(hw)) {
 		countdown--;
 		udelay(mbx->udelay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (countdown && mbx->ops.check_for_ack(hw)) {
 		countdown--;
 		udelay(mbx->udelay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	/* we cannot reset while the RSTI / RSTD bits are asserted */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!mbx->ops.check_for_rst(hw) && timeout) {
 		timeout--;
 		udelay(5);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 			while (i) {
 				i--;
 				ixgbevf_free_tx_resources(adapter,
 							  &tx_ring[i]);
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 			while (i) {
 				i--;
 				ixgbevf_free_rx_resources(adapter,
 							  &rx_ring[i]);
-			}
+				if (_cur < timeout) {
--
 	while (test->reg) {
 		for (i = 0; i < test->array_len; i++) {
 			switch (test->test_type) {
@@ -605,6 +632,12 @@ static int ixgbevf_reg_test(struct ixgbe
 			}
 		}
--
 	while ((eop_desc->wb.status & cpu_to_le32(IXGBE_TXD_STAT_DD)) &&
 	       (count < tx_ring->work_limit)) {
 		bool cleaned = false;
@@ -238,6 +243,12 @@ static bool ixgbevf_clean_tx_irq(struct
 cont_loop:
 		eop = tx_ring->tx_buffer_info[i].next_to_watch;
--
 	while (cleaned_count--) {
 		rx_desc = IXGBE_RX_DESC_ADV(*rx_ring, i);
 
@@ -417,7 +433,13 @@ static void ixgbevf_alloc_rx_buffers(str
 		if (i == rx_ring->count)
 			i = 0;
--
 	 * set them up later while requesting irq's.
 	 */
-	while (vectors >= vector_threshold) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (vectors >= vector_threshold) {
 		err = pci_enable_msix(adapter->pdev, adapter->msix_entries,
 				      vectors);
 		if (!err) /* Success in acquiring all requested vectors. */
@@ -1903,6 +1930,12 @@ static void ixgbevf_acquire_msix_vectors
 			vectors = 0; /* Nasty failure, quit now */
--
 	while (q_idx) {
 		q_idx--;
 		q_vector = adapter->q_vector[q_idx];
 		netif_napi_del(&q_vector->napi);
 		kfree(q_vector);
 		adapter->q_vector[q_idx] = NULL;
--
 	while (len) {
 		tx_buffer_info = &tx_ring->tx_buffer_info[i];
 		size = min(len, (unsigned int)IXGBE_MAX_DATA_PER_TXD);
@@ -2909,6 +2958,12 @@ static int ixgbevf_tx_map(struct ixgbevf
 		i++;
 		if (i == tx_ring->count)
--
 		while (len) {
 			tx_buffer_info = &tx_ring->tx_buffer_info[i];
 			size = min(len, (unsigned int)IXGBE_MAX_DATA_PER_TXD);
@@ -2939,6 +2999,12 @@ static int ixgbevf_tx_map(struct ixgbevf
 			i++;
 			if (i == tx_ring->count)
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		tx_buffer_info = &tx_ring->tx_buffer_info[i];
 		tx_desc = IXGBE_TX_DESC_ADV(*tx_ring, i);
 		tx_desc->read.buffer_addr = cpu_to_le64(tx_buffer_info->dma);
@@ -3022,6 +3093,12 @@ static void ixgbevf_tx_queue(struct ixgb
 		i++;
--
-	while (mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (mask) {
 		/* A "1" is shifted out to the PHY by setting the MDIO bit to "1" and
 		 * then raising and lowering the Management Data Clock. A "0" is
 		 * shifted out to the PHY by setting the MDIO bit to "0" and then
@@ -2764,6 +2769,12 @@ static void e1000_shift_out_mdi_bits(str
 		e1000_lower_mdi_clk(hw, &ctrl);
--
-	while (widx < words) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (widx < words) {
 		u8 write_opcode = EEPROM_WRITE_OPCODE_SPI;
 
 		if (e1000_spi_eeprom_ready(hw))
@@ -4189,6 +4205,12 @@ static s32 e1000_write_eeprom_spi(struct
 				break;
--
-	while (words_written < words) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (words_written < words) {
 		/* Send the Write command (3-bit opcode + addr) */
 		e1000_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE_MICROWIRE,
 					eeprom->opcode_bits);
@@ -4260,6 +4287,12 @@ static s32 e1000_write_eeprom_microwire(
 		e1000_standby_eeprom(hw);
--
 	while (pvfdev) {
 		if (pvfdev->devfn == vf_devfn &&
 		    (pvfdev->bus->number >= pdev->bus->number))
@@ -73,6 +78,12 @@ static int ixgbe_find_enabled_vfs(struct
 		vf_devfn += 2;
 		pvfdev = pci_get_device(IXGBE_INTEL_VENDOR_ID,
--
 				while (i) {
 					i--;
 					ixgbe_free_tx_resources(&temp_tx_ring[i]);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
--
 				while (i) {
 					i--;
 					ixgbe_free_rx_resources(&temp_rx_ring[i]);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
--
 	while (test->reg) {
 		for (i = 0; i < test->array_len; i++) {
 			switch (test->test_type) {
@@ -1391,6 +1418,12 @@ static int ixgbe_reg_test(struct ixgbe_a
 			}
 		}
--
-	while (staterr & IXGBE_RXD_STAT_DD) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (staterr & IXGBE_RXD_STAT_DD) {
 		/* check Rx buffer */
 		rx_buffer_info = &rx_ring->rx_buffer_info[rx_ntc];
 
@@ -1762,6 +1800,12 @@ static u16 ixgbe_clean_test_rings(struct
 		/* fetch next descriptor */
--
-	while (!end_data) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!end_data) {
 		/*
 		 * Read control word from PHY init contents offset
 		 */
@@ -820,6 +825,12 @@ s32 ixgbe_reset_phy_nl(struct ixgbe_hw *
 			ret_val = IXGBE_ERR_PHY;
--
 		while (len) {
 			/* max number of buffers allowed in one DDP context */
 			if (j >= IXGBE_BUFFCNT_MAX) {
@@ -230,6 +235,12 @@ static int ixgbe_fcoe_ddp_setup(struct n
 			len -= thislen;
 			addr += thislen;
--
 	while (len) {
 		buffer_info = &tx_ring->buffer_info[i];
 		size = min(len, IXGB_MAX_DATA_PER_TXD);
@@ -1380,6 +1385,12 @@ ixgb_tx_map(struct ixgb_adapter *adapter
 			if (i == tx_ring->count)
 				i = 0;
--
 		while (len) {
 			i++;
 			if (i == tx_ring->count)
@@ -1416,6 +1432,12 @@ ixgb_tx_map(struct ixgb_adapter *adapter
 			len -= size;
 			offset += size;
--
 	while (count--) {
 		if (i==0)
 			i += tx_ring->count;
 		i--;
 		buffer_info = &tx_ring->buffer_info[i];
 		ixgb_unmap_and_free_tx_resource(adapter, buffer_info);
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		buffer_info = &tx_ring->buffer_info[i];
 		tx_desc = IXGB_TX_DESC(*tx_ring, i);
 		tx_desc->buff_addr = cpu_to_le64(buffer_info->dma);
@@ -1475,6 +1513,12 @@ ixgb_tx_queue(struct ixgb_adapter *adapt
 		tx_desc->vlan = cpu_to_le16(vlan_id);
--
 	while (eop_desc->status & IXGB_TX_DESC_STATUS_DD) {
 
 		rmb(); /* read buffer_info after eop_desc */
@@ -1893,6 +1942,12 @@ ixgb_clean_tx_irq(struct ixgb_adapter *a
 
 		eop = tx_ring->buffer_info[i].next_to_watch;
--
 				while (i) {
 					i--;
 					igb_free_tx_resources(&temp_ring[i]);
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
--
 				while (i) {
 					i--;
 					igb_free_rx_resources(&temp_ring[i]);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
--
 	while (test->reg) {
 		for (i = 0; i < test->array_len; i++) {
 			switch (test->test_type) {
@@ -1146,6 +1173,12 @@ static int igb_reg_test(struct igb_adapt
 			}
 		}
--
-	while (igb_test_staterr(rx_desc, E1000_RXD_STAT_DD)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (igb_test_staterr(rx_desc, E1000_RXD_STAT_DD)) {
 		/* check rx buffer */
 		rx_buffer_info = &rx_ring->rx_buffer_info[rx_ntc];
 
@@ -1613,6 +1651,12 @@ static int igb_clean_test_rings(struct i
 
--
 	while (pvfdev) {
 		if (pvfdev->devfn == vf_devfn &&
 		    (pvfdev->bus->number >= pdev->bus->number))
@@ -4983,6 +4988,12 @@ static int igb_find_enabled_vfs(struct i
 		vf_devfn += vf_stride;
 		pvfdev = pci_get_device(hw->vendor_id,
--
 		while (tx_desc != eop_desc) {
 			tx_buffer->dma = 0;
 
@@ -5777,6 +5793,12 @@ static bool igb_clean_tx_irq(struct igb_
 					       tx_buffer->length,
 					       DMA_TO_DEVICE);
--
-	while (widx < words) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (widx < words) {
 		u8 write_opcode = NVM_WRITE_OPCODE_SPI;
 
 		ret_val = igb_ready_nvm_eeprom(hw);
@@ -497,6 +502,12 @@ s32 igb_write_nvm_spi(struct e1000_hw *h
 				break;
--
 	while (nic->cb_to_send != nic->cb_to_use) {
 		if (unlikely(e100_exec_cmd(nic, nic->cuc_cmd,
 			nic->cb_to_send->dma_addr))) {
@@ -910,6 +915,12 @@ static int e100_exec_cb(struct nic *nic,
 			nic->cuc_cmd = cuc_resume;
 			nic->cb_to_send = nic->cb_to_send->next;
--
 		while (nic->cbs_avail != nic->params.cbs.count) {
 			struct cb *cb = nic->cb_to_clean;
 			if (cb->skb) {
@@ -1826,6 +1842,12 @@ static void e100_clean_cbs(struct nic *n
 			}
 			nic->cb_to_clean = nic->cb_to_clean->next;
--
 	while (len) {
 		buffer_info = &tx_ring->buffer_info[i];
 		size = min(len, max_per_txd);
@@ -4692,6 +4697,12 @@ static int e1000_tx_map(struct e1000_ada
 			if (i == tx_ring->count)
 				i = 0;
--
 		while (len) {
 			i++;
 			if (i == tx_ring->count)
@@ -4721,6 +4737,12 @@ static int e1000_tx_map(struct e1000_ada
 			len -= size;
 			offset += size;
--
 	while (count--) {
 		if (i == 0)
 			i += tx_ring->count;
 		i--;
 		buffer_info = &tx_ring->buffer_info[i];
 		e1000_put_txbuf(adapter, buffer_info);
--
 	while (widx < words) {
 		u8 write_opcode = NVM_WRITE_OPCODE_SPI;
 
@@ -2130,6 +2135,12 @@ s32 e1000e_write_nvm_spi(struct e1000_hw
 				break;
 			}
--
 	while (cleaned_count--) {
 		rx_desc = IGBVF_RX_DESC_ADV(*rx_ring, i);
 
@@ -207,7 +212,13 @@ static void igbvf_alloc_rx_buffers(struc
 		if (i == rx_ring->count)
 			i = 0;
--
 	while ((eop_desc->wb.status & cpu_to_le32(E1000_TXD_STAT_DD)) &&
 	       (count < tx_ring->count)) {
 		rmb();	/* read buffer_info after eop_desc status */
@@ -785,6 +801,12 @@ static bool igbvf_clean_tx_irq(struct ig
 		}
 		eop = tx_ring->buffer_info[i].next_to_watch;
--
 	while (count--) {
 		if (i==0)
 			i += tx_ring->count;
 		i--;
 		buffer_info = &tx_ring->buffer_info[i];
 		igbvf_put_txbuf(adapter, buffer_info);
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		buffer_info = &tx_ring->buffer_info[i];
 		tx_desc = IGBVF_TX_DESC_ADV(*tx_ring, i);
 		tx_desc->read.buffer_addr = cpu_to_le64(buffer_info->dma);
@@ -2139,6 +2177,12 @@ static inline void igbvf_tx_queue_adv(st
 		i++;
--
 	while (countdown && mbx->ops.check_for_msg(hw)) {
 		countdown--;
 		udelay(mbx->usec_delay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (countdown && mbx->ops.check_for_ack(hw)) {
 		countdown--;
 		udelay(mbx->usec_delay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	/* we cannot initialize while the RSTI / RSTD bits are asserted */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!mbx->ops.check_for_rst(hw) && timeout) {
 		timeout--;
 		udelay(5);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (--tries) {
 		u32 tmp = sbus_readl(gregs + GLOB_CTRL);
 		if (tmp & GLOB_CTRL_RESET) {
@@ -72,6 +77,12 @@ static inline int qec_global_reset(void
 			continue;
 		}
--
 	while (--tries) {
 		u8 tmp = sbus_readb(mregs + MREGS_BCONFIG);
 		if (tmp & MREGS_BCONFIG_RESET) {
@@ -98,6 +114,12 @@ static inline int qe_stop(struct sunqe *
 			continue;
 		}
--
 	while (--tries) {
 		u32 tmp = sbus_readl(cregs + CREG_CTRL);
 		if (tmp & CREG_CTRL_RESET) {
@@ -113,6 +140,12 @@ static inline int qe_stop(struct sunqe *
 			continue;
 		}
--
-	while (!((flags = this->rx_flags) & RXD_OWN)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!((flags = this->rx_flags) & RXD_OWN)) {
 		struct sk_buff *skb;
 		unsigned char *this_qbuf =
 			&qbufs->rx_buf[elem & (RX_RING_SIZE - 1)][0];
@@ -455,6 +493,12 @@ static void qe_rx(struct sunqe *qep)
 
--
 	while (root_qec_dev) {
 		struct sunqec *next = root_qec_dev->next_module;
 		struct platform_device *op = root_qec_dev->op;
@@ -1000,6 +1049,12 @@ static void __exit qec_exit(void)
 		kfree(root_qec_dev);
 
--
 	while (!((flags = hme_read_desc32(hp, &this->rx_flags)) & RXFLAG_OWN)) {
 		struct sk_buff *skb;
 		int len = flags >> 16;
@@ -2076,6 +2081,12 @@ static void happy_meal_rx(struct happy_m
 	next:
 		elem = NEXT_RX(elem);
--
 	while (tmp != &pdev->bus->devices) {
 		struct pci_dev *this_pdev = pci_dev_b(tmp);
 
@@ -2867,6 +2883,12 @@ static int is_quattro_p(struct pci_dev *
 			n_hmes++;
 
--
 	while (qfe_pci_list) {
 		struct quattro *qfe = qfe_pci_list;
 		struct quattro *next = qfe->next;
@@ -3219,6 +3246,12 @@ static void happy_meal_pci_exit(void)
 		kfree(qfe);
 
--
 	while (qfe_sbus_list) {
 		struct quattro *qfe = qfe_sbus_list;
 		struct quattro *next = qfe->next;
@@ -3320,6 +3358,12 @@ static void happy_meal_sbus_exit(void)
 		kfree(qfe);
 
--
 	while (--tries) {
 		if (sbus_readl(gregs + GLOB_CTRL) & GLOB_CTRL_RESET) {
 			udelay(20);
 			continue;
 		}
 		break;
--
 	while (i--) {
 		sbus_writel(MGMT_CLKOFF, tregs + TCVR_MPAL);
 		sbus_readl(tregs + TCVR_MPAL);
 		sbus_writel(MGMT_CLKON, tregs + TCVR_MPAL);
 		sbus_readl(tregs + TCVR_MPAL);
+		if (_cur < timeout) {
--
 	while (!((flags = this->rx_flags) & RXD_OWN)) {
 		struct sk_buff *skb;
 		int len = (flags & RXD_LENGTH); /* FCS not included */
@@ -884,6 +911,12 @@ static void bigmac_rx(struct bigmac *bp)
 	next:
 		elem = NEXT_RX(elem);
--
 	while (curr != limit) {
 		curr = NEXT_RX(curr);
 		if (++count == 4) {
@@ -736,6 +741,12 @@ static __inline__ void gem_post_rxds(str
 			kick = curr;
 			count = 0;
--
 	while (work_done < budget && mix_ircnt.s.ircnt) {
 
 		rc = octeon_mgmt_receive_one(p);
@@ -401,6 +406,12 @@ static int octeon_mgmt_receive_packets(s
 
 		/* Check for more packets. */
--
 	while (mmio_verify_registers[i]) {
 		int reg = mmio_verify_registers[i++];
 		unsigned char a = inb(pioaddr+reg);
@@ -826,6 +831,12 @@ static int __devinit rhine_init_one(stru
 				reg, a, b);
 			goto err_out_unmap;
--
 	while ((status = readword(dev->base_addr, ISQ_PORT))) {
 		if (net_debug > 4)printk("%s: event=%04x\n", dev->name, status);
 		handled = 1;
@@ -1559,6 +1564,11 @@ static irqreturn_t net_interrupt(int irq
 #if ALLOW_DMA
 			if (lp->use_dma && (status & RX_DMA)) {
--
 				while(count) {
 					if (net_debug > 5)
 						printk("%s: receiving %d DMA frames\n", dev->name, count);
@@ -1569,6 +1579,12 @@ static irqreturn_t net_interrupt(int irq
 						count = readreg(dev, PP_DmaFrameCnt);
 					if (net_debug > 2 && count > 0)
--
 	while ((status = swab16(nubus_readw(dev->base_addr + ISQ_PORT)))) {
 		if (net_debug > 4)printk("%s: event=%04x\n", dev->name, status);
 		switch(status & ISQ_EVENT_MASK) {
@@ -479,6 +484,12 @@ static irqreturn_t net_interrupt(int irq
 			dev->stats.collisions += (status >> 6);
 			break;
--
-	while (GRETH_REGLOAD(greth->regs->mdio) & GRETH_MII_BUSY) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (GRETH_REGLOAD(greth->regs->mdio) & GRETH_MII_BUSY) {
 		if (time_after(jiffies, timeout))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (!phy_aneg_done(greth->phy) && time_before(jiffies, timeout)) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
--
 	while (GRETH_REGLOAD(regs->control) & GRETH_RESET) {
 		if (time_after(jiffies, timeout)) {
 			err = -EIO;
@@ -1436,6 +1463,12 @@ static int __devinit greth_of_probe(stru
 				dev_err(greth->dev, "timeout when waiting for reset.\n");
 			goto error2;
--
 	while (chan->head) {
 		struct cpdma_desc __iomem *desc = chan->head;
 		dma_addr_t next_dma;
@@ -858,6 +863,12 @@ int cpdma_chan_stop(struct cpdma_chan *c
 		spin_unlock_irqrestore(&chan->lock, flags);
 		__cpdma_chan_free(chan, desc, 0, -ENOSYS);
--
 	while (tlan_have_eisa) {
 		dev = tlan_eisa_devices;
 		priv = netdev_priv(dev);
@@ -640,6 +645,12 @@ static void tlan_eisa_cleanup(void)
 		tlan_eisa_devices = priv->next_device;
 		free_netdev(dev);
--
 	while (time_after(timeout, jiffies)) {
 		reg = __raw_readl(&regs->user[0].access);
 		if ((reg & USERACCESS_GO) == 0)
@@ -180,6 +185,12 @@ static inline int wait_for_user_access(s
 		dev_warn(data->dev, "resetting idled controller\n");
 		__davinci_mdio_reset(data);
--
 	while (time_after(timeout, jiffies)) {
 		if (__raw_readl(&regs->control) & CONTROL_IDLE)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, k))) {
 		for (i = res->start; i <= res->end; i++) {
 			if (request_irq(i, emac_irq, IRQF_DISABLED,
@@ -1559,6 +1564,12 @@ static int emac_dev_open(struct net_devi
 				goto rollback;
 		}
--
 	while ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, i))) {
 		for (irq_num = res->start; irq_num <= res->end; irq_num++)
 			free_irq(irq_num, priv->ndev);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((idx = sky2_read16(hw, STAT_PUT_IDX)) != hw->st_idx) {
 		work_done += sky2_status_intr(hw, work_limit - work_done, idx);
 
 		if (work_done >= work_limit)
 			goto done;
+			if (_cur < timeout) {
--
 	while ( (sky2_pci_read16(hw, cap + PCI_VPD_ADDR) & PCI_VPD_ADDR_F) == busy) {
 		/* Can take up to 10.6 ms for write */
 		if (time_after(jiffies, start + HZ/4)) {
@@ -4253,6 +4269,12 @@ static int sky2_vpd_wait(const struct sk
 			return -ETIMEDOUT;
 		}
--
 	while (refilled < budget && rxq->rx_desc_count < rxq->rx_ring_size) {
 		struct sk_buff *skb;
 		int rx;
@@ -697,6 +702,12 @@ static int rxq_refill(struct rx_queue *r
 		 * IP header ends up 16-byte aligned.
 		 */
--
 	while (num_queues && left_over_budget) {
 
 		budget_per_queue = left_over_budget/num_queues;
@@ -2865,6 +2870,12 @@ static int gfar_poll(struct napi_struct
 				num_queues--;
 			}
--
 	while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) {
 
 		/* Since we have allocated space to hold a complete frame,
@@ -738,6 +743,12 @@ rx_processing_done:
 		 * able to keep up at the expense of system resources.
 		 */
--
-	while (!bcom_queue_empty(s)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!bcom_queue_empty(s)) {
 		struct bcom_fec_bd *bd;
 		struct sk_buff *skb;
 
@@ -139,6 +144,12 @@ static void mpc52xx_fec_free_rx_buffers(
 		dma_unmap_single(dev->dev.parent, bd->skb_pa, skb->len,
--
 	while (!bcom_queue_full(rxtsk)) {
 		skb = dev_alloc_skb(FEC_RX_BUFFER_SIZE);
 		if (!skb)
@@ -167,6 +183,12 @@ static int mpc52xx_fec_alloc_rx_buffers(
 		/* zero out the initial receive buffers to aid debugging */
 		memset(skb->data, 0, FEC_RX_BUFFER_SIZE);
--
-	while (bcom_buffer_done(priv->tx_dmatsk)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (bcom_buffer_done(priv->tx_dmatsk)) {
 		struct sk_buff *skb;
 		struct bcom_fec_bd *bd;
 		skb = bcom_retrieve_buffer(priv->tx_dmatsk, NULL,
@@ -380,6 +407,12 @@ static irqreturn_t mpc52xx_fec_tx_interr
 				 DMA_TO_DEVICE);
--
-	while (bcom_buffer_done(priv->rx_dmatsk)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bcom_buffer_done(priv->rx_dmatsk)) {
 
 		rskb = bcom_retrieve_buffer(priv->rx_dmatsk, &status,
 					    (struct bcom_bd **)&bd);
@@ -441,6 +479,12 @@ static irqreturn_t mpc52xx_fec_rx_interr
 			netif_rx(rskb);
--
 	while ((compl = be_mcc_compl_get(adapter))) {
 		if (compl->flags & CQE_FLAGS_ASYNC_MASK) {
 			/* Interpret flags as an async trailer */
@@ -253,6 +258,12 @@ int be_process_mcc(struct be_adapter *ad
 		}
 		be_mcc_compl_use(compl);
--
 	while (total_size) {
 		buf_size = min(total_size, (u32)60*1024);
 		total_size -= buf_size;
@@ -1395,6 +1411,12 @@ void be_cmd_get_regs(struct be_adapter *
 		}
 		offset += buf_size;
--
 	while (copied) {
 		wrb = queue_head_node(txq);
 		unmap_tx_frag(dev, wrb, map_single);
 		map_single = false;
 		copied -= wrb->frag_len;
 		queue_head_inc(txq);
--
-		while ((txcp = be_tx_compl_get(tx_cq))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((txcp = be_tx_compl_get(tx_cq))) {
 			end_idx = AMAP_GET_BITS(struct amap_eth_tx_compl,
 					wrb_index, txcp);
 			num_wrbs += be_tx_compl_process(adapter, txo, end_idx);
 			cmpl++;
+			if (_cur < timeout) {
--
-	while (atomic_read(&txq->used)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (atomic_read(&txq->used)) {
 		sent_skb = sent_skbs[txq->tail];
 		end_idx = txq->tail;
 		index_adv(&end_idx,
@@ -1563,6 +1590,12 @@ static void be_tx_compl_clean(struct be_
 			txq->len);
--
-		while ((txcp = be_tx_compl_get(&txo->cq))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((txcp = be_tx_compl_get(&txo->cq))) {
 			num_wrbs += be_tx_compl_process(adapter, txo,
 				AMAP_GET_BITS(struct amap_eth_tx_compl,
 					wrb_index, txcp));
 			tx_compl++;
+			if (_cur < timeout) {
--
-		while ((idev = pnp_find_dev(NULL,
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((idev = pnp_find_dev(NULL,
 					    isapnp_clone_list[i].vendor,
 					    isapnp_clone_list[i].function,
 					    idev))) {
@@ -275,6 +280,12 @@ static int __init ne_probe_isapnp(struct
 			}
--
 	while ((pdev_ne[this_dev] && platform_get_drvdata(pdev_ne[this_dev])) ||
 		io[this_dev]) {
 		if (++this_dev == MAX_NE_CARDS)
 			return ERR_PTR(-ENOMEM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-                while ((idev = pnp_find_dev(NULL,
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                        timeout = rdstcll(start) + delta;
+                        while ((idev = pnp_find_dev(NULL,
                                             ultra_device_ids[i].vendor,
                                             ultra_device_ids[i].function,
                                             idev))) {
@@ -367,6 +372,12 @@ static int __init ultra_probe_isapnp(str
                         }
--
 	while(offset_len--) {
 		offset = (offset << 8) | tuple[4+offset_len];
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
--
-	while (i < network->rate_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < network->rate_len) {
 		if (j < network->rate_ext_len &&
 		    ((scan->ext_rate[j] & 0x7f) < (scan->rate[i] & 0x7f)))
 		    rate = scan->ext_rate[j++] & 0x7f;
@@ -624,11 +629,28 @@ static char *gelic_wl_translate_scan(str
 		iwe.u.bitrate.value = rate * 500000; /* 500kbps unit */
--
 	while (j < network->rate_ext_len) {
 		iwe.u.bitrate.value = (scan->ext_rate[j++] & 0x7f) * 500000;
 		tmp = iwe_stream_add_value(info, ev, tmp, stop, &iwe,
 					   IW_EV_PARAM_LEN);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		status = lv1_net_control(bus_id(port->card), dev_id(port->card),
 					 GELIC_LV1_GET_WLAN_EVENT, 0, 0, 0,
 					 &event, &tmp);
@@ -2179,6 +2206,12 @@ static void gelic_wl_event_worker(struct
 		default:
--
 	} /* while */
 }
 /*
diff -u -p a/net/ethernet/toshiba/spider_net.c b/net/ethernet/toshiba/spider_net.c
--- a/net/ethernet/toshiba/spider_net.c
+++ b/net/ethernet/toshiba/spider_net.c
--
 	while (1) {
 		spin_lock_irqsave(&chain->lock, flags);
 		if (chain->tail == chain->head) {
@@ -861,6 +866,12 @@ spider_net_release_tx_chain(struct spide
 					PCI_DMA_TODEVICE);
 			dev_kfree_skb(skb);
--
 	while (regs[i][0]) {
 		spider_net_write_reg(card, regs[i][0], regs[i][1]);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (tc_readl(&tr->MD_CA) & MD_CA_Busy) {
 		if (time_after(jiffies, timeout))
 			return -EIO;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (tc_readl(&tr->MD_CA) & MD_CA_Busy) {
 		if (time_after(jiffies, timeout))
 			return -EIO;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (rx_queue->notified_count != rx_queue->added_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rx_queue->notified_count != rx_queue->added_count) {
 		efx_build_rx_desc(
 			rx_queue,
 			rx_queue->notified_count & rx_queue->ptr_mask);
 		++rx_queue->notified_count;
+		if (_cur < timeout) {
--
 	while (part != &efx_mtd->part[0]) {
 		--part;
 		efx_mtd_remove_partition(part);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (offset < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset < end) {
 		chunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);
 		rc = efx_mcdi_nvram_read(efx, part->mcdi.nvram_type, offset,
 					 buffer, chunk);
@@ -476,6 +492,12 @@ static int siena_mtd_read(struct mtd_inf
 			goto out;
--
-	while (offset < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < end) {
 		rc = efx_mcdi_nvram_erase(efx, part->mcdi.nvram_type, offset,
 					  chunk);
 		if (rc)
 			goto out;
 		offset += chunk;
--
-	while (offset < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset < end) {
 		chunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);
 		rc = efx_mcdi_nvram_write(efx, part->mcdi.nvram_type, offset,
 					  buffer, chunk);
@@ -539,6 +577,12 @@ static int siena_mtd_write(struct mtd_in
 			goto out;
--
 		while (mask) {
 			if (mask & 1) {
 				stat = efx_mdio_read(efx, mmd, MDIO_CTRL1);
@@ -98,6 +103,12 @@ int efx_mdio_wait_reset_mmds(struct efx_
 			}
 			mask = mask >> 1;
--
 	while (mmd_mask) {
 		if ((mmd_mask & 1) && efx_mdio_check_mmd(efx, mmd))
 			return -EIO;
 		mmd_mask = mmd_mask >> 1;
 		mmd++;
+		if (_cur < timeout) {
--
 	while (mmd_mask) {
 		if (mmd_mask & 1)
 			efx_mdio_set_mmd_lpower(efx, low_power, mmd);
 		mmd_mask = (mmd_mask >> 1);
 		mmd++;
+		if (_cur < timeout) {
--
 	while (*reg_values) {
 		u8 reg = *reg_values++;
 		u8 value = *reg_values++;
 		int rc = i2c_smbus_write_byte_data(client, reg, value);
 		if (rc)
 			return rc;
--
 	while (!mac_up && tries) {
 		netif_dbg(efx, hw, efx->net_dev, "bashing xaui\n");
 		falcon_reset_xaui(efx);
@@ -263,6 +268,12 @@ static bool falcon_xmac_link_ok_retry(st
 
 		mac_up = falcon_xmac_link_ok(efx);
--
 	while (tx_queue->insert_count != tx_queue->write_count) {
 		--tx_queue->insert_count;
 		insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
 		buffer = &tx_queue->buffer[insert_ptr];
 		efx_dequeue_buffer(tx_queue, buffer);
 		buffer->len = 0;
--
 	while (read_ptr != stop_index) {
 		struct efx_tx_buffer *buffer = &tx_queue->buffer[read_ptr];
 		if (unlikely(buffer->len == 0)) {
@@ -336,6 +352,12 @@ static void efx_dequeue_buffers(struct e
 
 		++tx_queue->read_count;
--
 	while (tx_queue->read_count != tx_queue->write_count) {
 		buffer = &tx_queue->buffer[tx_queue->read_count & tx_queue->ptr_mask];
 		efx_dequeue_buffer(tx_queue, buffer);
@@ -540,6 +567,12 @@ void efx_release_tx_buffers(struct efx_t
 		buffer->len = 0;
 
--
-	while (tx_queue->insert_count != tx_queue->write_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tx_queue->insert_count != tx_queue->write_count) {
 		--tx_queue->insert_count;
 		buffer = &tx_queue->buffer[tx_queue->insert_count &
 					   tx_queue->ptr_mask];
@@ -911,6 +949,12 @@ static void efx_enqueue_unwind(struct ef
 		}
--
 	while (index != stop) {
 		if (test_bit(index, table->used_bitmap) &&
 		    table->spec[index].priority == EFX_FILTER_PRI_HINT &&
@@ -714,6 +719,12 @@ bool __efx_filter_rfs_expire(struct efx_
 			efx_filter_table_clear_entry(efx, table, index);
 		}
--
-				while (j < max_entries) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (j < max_entries) {
 					if (mtable[itable[j]] != i) {
 						j++;
 						continue;
@@ -3889,9 +3894,20 @@ enum vxge_hw_status vxge_hw_vpath_rts_rt
 						&data0, &data1, 1, itable);
--
-				while (j < max_entries) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (j < max_entries) {
 					if (mtable[itable[j]] != i) {
 						j++;
 						continue;
@@ -3900,9 +3916,20 @@ enum vxge_hw_status vxge_hw_vpath_rts_rt
 						&data0, &data1, 2, itable);
--
-				while (j < max_entries) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (j < max_entries) {
 					if (mtable[itable[j]] != i) {
 						j++;
 						continue;
@@ -3911,9 +3938,20 @@ enum vxge_hw_status vxge_hw_vpath_rts_rt
 						&data0, &data1, 3, itable);
--
-				while (j < max_entries) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (j < max_entries) {
 					if (mtable[itable[j]] != i) {
 						j++;
 						continue;
@@ -3922,6 +3960,12 @@ enum vxge_hw_status vxge_hw_vpath_rts_rt
 						&data0, &data1, 4, itable);
--
 	while (processed < budget) {
 		struct ixpdev_rx_desc *desc;
 		struct sk_buff *skb;
@@ -121,6 +126,12 @@ static int ixpdev_rx(struct net_device *
 err:
 		ixp2000_reg_write(RING_RX_PENDING, _desc);
--
-	while (received < budget) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (received < budget) {
 		struct sk_buff *skb;
 		struct desc *desc;
 		int n;
@@ -764,6 +769,12 @@ static int eth_poll(struct napi_struct *
 		desc->pkt_len = 0;
--
 	while (npackets < budget) {
 		/*
 		 * break out of while loop if there are no more
@@ -438,6 +443,12 @@ static int dnet_poll(struct napi_struct
 			printk(KERN_NOTICE
 			       "%s: No memory to allocate a sk_buff of "
 			       "size %u.\n", dev->name, pkt_len);
+			if (_cur < timeout) {
--
   while (mace_read(lp, ioaddr, MACE_BIUCC) & 0x01) {
     /* Wait for reset bit to be cleared automatically after <= 200ns */;
     if(++ct > 500)
@@ -552,6 +557,12 @@ static int mace_init(mace_private *lp, u
     	return -1;
     }
--
   while (mace_read(lp, ioaddr, MACE_IAC) & MACE_IAC_ADDRCHG)
   {
   	if(++ ct > 500)
@@ -598,6 +614,12 @@ static int mace_init(mace_private *lp, u
 		pr_err("ADDRCHG timeout, card removed?\n");
   		return -1;
--
 	while (readl(mii_control_reg) & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			netdev_err(dev, "read_MII busy timeout!!\n");
 			return -1;
 		}
--
 	while (readl(mii_control_reg) & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			netdev_err(dev, "mdio_read busy timeout!!\n");
 			return -1;
 		}
--
 	while (readl(mii_control_reg) & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			netdev_err(dev, "mdio_write busy timeout!!\n");
 			return;
 		}
--
 	while (buff_stat & RX_T_DONE)  {
 		status = prxd->status;
 		pDB = aup->rx_db_inuse[aup->rx_head];
@@ -768,6 +806,12 @@ static int au1000_rx(struct net_device *
 		/* next descriptor */
 		prxd = aup->rx_dma_ring[aup->rx_head];
--
 	while (ptxd->buff_stat & TX_T_DONE) {
 		au1000_update_tx_stats(dev, ptxd->status);
 		ptxd->buff_stat &= ~TX_T_DONE;
@@ -820,6 +869,12 @@ static void au1000_tx_ack(struct net_dev
 			aup->tx_full = 0;
 			netif_wake_queue(dev);
--
 	while(!( (rmdstat = rmdp->u.s.status) & RCV_OWN))
 	{
 		cnt++;
@@ -1133,6 +1138,12 @@ static void ni65_recv_intr(struct net_de
 		rmdp->u.s.status = RCV_OWN; /* change owner */
 		p->rmdnum = (p->rmdnum + 1) & (RMDNUM-1);
--
-	while (--new >= lp->rx_ring_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (--new >= lp->rx_ring_size) {
 		if (new_skb_list[new]) {
 			pci_unmap_single(lp->pci_dev, new_dma_addr_list[new],
 					 PKT_BUF_SIZE, PCI_DMA_FROMDEVICE);
 			dev_kfree_skb(new_skb_list[new]);
 		}
--
 	while (x < numbuffs && !rc) {
 		skb = lp->rx_skbuff[x];
 		packet = lp->tx_skbuff[x]->data;
@@ -998,6 +1014,12 @@ static int pcnet32_loopback_test(struct
 			}
 		}
--
-	while (!(a->read_csr(ioaddr, CSR5) & CSR5_SUSPEND)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(a->read_csr(ioaddr, CSR5) & CSR5_SUSPEND)) {
 		spin_unlock_irqrestore(&lp->lock, *flags);
 		if (can_sleep)
 			msleep(1);
@@ -1094,6 +1121,12 @@ static int pcnet32_suspend(struct net_de
 				     "Error getting into suspend!\n");
--
 	while (pcnet32_dev) {
 		struct pcnet32_private *lp = netdev_priv(pcnet32_dev);
 		next_dev = lp->next;
@@ -2920,6 +2958,12 @@ static void __exit pcnet32_cleanup_modul
 				    lp->init_block, lp->init_dma_addr);
 		free_netdev(pcnet32_dev);
--
 	while( len-- ) {
 		*cto++ = *cfrom++;
 		MFPDELAY();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (clen--) {
 			*tp++ = *fp++;
 			tp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (clen--) {
 			*rtp++ = *rfp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (clen--) {
 			*tp++ = *fp++;
 			*tp++ = *fp++;
@@ -367,6 +394,12 @@ static void cp_to_buf(const int type, vo
 			*tp++ = *fp++;
 			*tp++ = *fp++;
--
 		while (clen--) {
 			*rtp++ = *rfp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (clen--) {
 			*tp++ = *fp++;
 			fp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (clen--) {
 			*rtp++ = *rfp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (clen--) {
 			*tp++ = *fp++;
 			*tp++ = *fp++;
@@ -428,6 +499,12 @@ static void cp_from_buf(const int type,
 			*tp++ = *fp++;
 			*tp++ = *fp++;
--
 		while (clen--) {
 			*rtp++ = *rfp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (dev) {
 			i++;
 			lp = netdev_priv(dev);
 			dev = lp->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (root_lance_dev) {
 		struct net_device *dev = root_lance_dev;
 		struct lance_private *lp = netdev_priv(dev);
@@ -1321,6 +1425,12 @@ static void __exit dec_lance_platform_re
 		unregister_netdev(dev);
 		root_lance_dev = lp->next;
--
 	while (!ftmac100_rxdes_owned_by_dma(rxdes)) {
 		if (ftmac100_rxdes_first_segment(rxdes))
 			return rxdes;
@@ -322,6 +327,12 @@ ftmac100_rx_locate_first_segment(struct
 		ftmac100_rxdes_set_dma_own(rxdes);
 		ftmac100_rx_pointer_advance(priv);
--
 	while (ftgmac100_rxdes_packet_ready(rxdes)) {
 		if (ftgmac100_rxdes_first_segment(rxdes))
 			return rxdes;
@@ -341,6 +346,12 @@ ftgmac100_rx_locate_first_segment(struct
 		ftgmac100_rxdes_set_dma_own(rxdes);
 		ftgmac100_rx_pointer_advance(priv);
--
-	while ((___rval = mace->eth.phy_data) & MDIO_BUSY) {	\
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+unsigned long long _start = 0;
+unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((___rval = mace->eth.phy_data) & MDIO_BUSY) {	\
 		udelay(25);					\
+	if (_cur < timeout) {
+		rdstcll(_cur);
 	}
+	else {
--
-	while (priv->rx_write != fifo_rptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (priv->rx_write != fifo_rptr) {
 		dma_unmap_single(NULL, priv->rx_ring_dmas[priv->rx_write],
 				 METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);
 		status = priv->rx_ring[priv->rx_write]->status.raw;
@@ -448,6 +464,12 @@ static void meth_rx(struct net_device* d
 				       METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);
--
-	while (priv->tx_read != rptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (priv->tx_read != rptr) {
 		skb = priv->tx_skbs[priv->tx_read];
 		status = priv->tx_ring[priv->tx_read].header.raw;
 #if MFE_DEBUG>=1
@@ -516,6 +543,12 @@ static void meth_tx_cleanup(struct net_d
 		priv->tx_ring[priv->tx_read].header.raw = 0;
--
 	while (1) {
 		u64 reg;
 		reg = nic_find(ioc3, &save);
@@ -385,6 +390,12 @@ static int nic_init(struct ioc3 *ioc3)
 		}
 		crc = reg & 0xff;
--
 	while (w0 & ERXBUF_V) {
 		err = be32_to_cpu(rxb->err);		/* It's valid ...  */
 		if (err & ERXBUF_GOODPKT) {
@@ -644,6 +660,12 @@ next:
 		skb = ip->rx_skbs[rx_entry];
 		rxb = (struct ioc3_erxbuf *) (skb->data - RX_OFFSET);
--
 	while (o_entry != tx_entry) {
 		packets++;
 		skb = ip->tx_skbs[o_entry];
@@ -678,6 +705,12 @@ static inline void ioc3_tx(struct net_de
 
 		etcir = ioc3_r_etcir();			/* More pkts sent?  */
--
 		while (n_entry != rx_entry) {
 			skb = ip->rx_skbs[n_entry];
 			if (skb)
 				dev_kfree_skb_any(skb);
 
 			n_entry = (n_entry + 1) & 511;
--
 	while (miicontrol & BMCR_RESET) {
 		usleep_range(10000, 20000);
 		miicontrol = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);
 		/* FIXME: 100 tries seem excessive */
 		if (tries++ > 100)
 			return -1;
--
 	while (np->put_rx.orig != less_rx) {
 		struct sk_buff *skb = dev_alloc_skb(np->rx_buf_sz + NV_RX_ALLOC_PAD);
 		if (skb) {
@@ -1761,6 +1777,12 @@ static int nv_alloc_rx(struct net_device
 				np->put_rx_ctx = np->first_rx_ctx;
 		} else
--
 	while (np->put_rx.ex != less_rx) {
 		struct sk_buff *skb = dev_alloc_skb(np->rx_buf_sz + NV_RX_ALLOC_PAD);
 		if (skb) {
@@ -1793,6 +1820,12 @@ static int nv_alloc_rx_optimized(struct
 				np->put_rx_ctx = np->first_rx_ctx;
 		} else
--
 	while ((np->get_tx.orig != np->put_tx.orig) &&
 	       !((flags = le32_to_cpu(np->get_tx.orig->flaglen)) & NV_TX_VALID) &&
 	       (tx_work < limit)) {
@@ -2413,6 +2451,12 @@ static int nv_tx_done(struct net_device
 			np->get_tx.orig = np->first_tx.orig;
 		if (unlikely(np->get_tx_ctx++ == np->last_tx_ctx))
--
 	while ((np->get_tx.ex != np->put_tx.ex) &&
 	       !((flags = le32_to_cpu(np->get_tx.ex->flaglen)) & NV_TX2_VALID) &&
 	       (tx_work < limit)) {
@@ -2458,6 +2507,12 @@ static int nv_tx_done_optimized(struct n
 			np->get_tx.ex = np->first_tx.ex;
 		if (unlikely(np->get_tx_ctx++ == np->last_tx_ctx))
--
 	while ((np->get_rx.orig != np->put_rx.orig) &&
 	      !((flags = le32_to_cpu(np->get_rx.orig->flaglen)) & NV_RX_AVAIL) &&
 		(rx_work < limit)) {
@@ -2702,6 +2762,12 @@ next_pkt:
 			np->get_rx_ctx = np->first_rx_ctx;
 
--
 	while ((np->get_rx.ex != np->put_rx.ex) &&
 	      !((flags = le32_to_cpu(np->get_rx.ex->flaglen)) & NV_RX2_AVAIL) &&
 	      (rx_work < limit)) {
@@ -2789,6 +2860,12 @@ next_pkt:
 			np->get_rx_ctx = np->first_rx_ctx;
 
--
 			while (!(phylink & PHY_LINK_SPEEDDPU_RESOLVED) &&
 				--cnt) {
 
@@ -464,6 +469,12 @@ jme_check_link(struct net_device *netdev
 					phylink = jme_linkstat_from_phy(jme);
 				else
--
 	while (!atomic_dec_and_test(&jme->link_changing)) {
 		atomic_inc(&jme->link_changing);
 		netif_info(jme, intr, jme->dev, "Get link change lock failed\n");
 		while (atomic_read(&jme->link_changing) != 1)
 			netif_info(jme, intr, jme->dev, "Waiting link change lock\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
--
 	while ((val & SMBCSR_BUSY) && --to) {
 		msleep(1);
 		val = jread32(jme, JME_SMBCSR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((val & SMBINTF_HWCMD) && --to) {
 		msleep(1);
 		val = jread32(jme, JME_SMBINTF);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((val & SMBCSR_BUSY) && --to) {
 		msleep(1);
 		val = jread32(jme, JME_SMBCSR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((val & SMBINTF_HWCMD) && --to) {
 		msleep(1);
 		val = jread32(jme, JME_SMBINTF);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (len > dmae_wr_max) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len > dmae_wr_max) {
 		bnx2x_write_dmae(bp, phys_addr + offset,
 				 addr + offset, dmae_wr_max);
 		offset += dmae_wr_max * 4;
 		len -= dmae_wr_max;
+		if (_cur < timeout) {
--
 	while ((crd != init_crd) && ((u32)SUB_S32(crd_freed, crd_freed_start) <
 	       (init_crd - crd_start))) {
 		if (cur_cnt--) {
@@ -1053,6 +1069,12 @@ static void bnx2x_pbf_pN_buf_flushed(str
 			   regs->pN, crd_freed);
 			break;
--
 	while (occup && ((u32)SUB_S32(freed, freed_start) < to_free)) {
 		if (cur_cnt--) {
 			udelay(FLR_WAIT_INTERAVAL);
@@ -1085,6 +1112,12 @@ static void bnx2x_pbf_pN_cmd_flushed(str
 			   regs->pN, freed);
 			break;
--
 	while (1) {
 		switch (bp->recovery_state) {
 		case BNX2X_RECOVERY_INIT:
@@ -8467,6 +8505,12 @@ static void bnx2x_parity_recover(struct
 		default:
 			return;
--
 			while (tout && REG_RD(bp, IGU_REG_RESET_MEMORIES)) {
 				tout--;
 				usleep_range(1000, 1000);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while ((init_crd != crd) && count) {
 		msleep(5);
 
 		crd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);
 		count--;
+		if (_cur < timeout) {
--
-	while (!list_empty(&o->pending_comp)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&o->pending_comp)) {
 		elem = list_first_entry(&o->pending_comp,
 					struct bnx2x_exeq_elem, link);
 
 		list_del(&elem->link);
 		bnx2x_exe_queue_free_elem(bp, elem);
--
-	while (!list_empty(&o->exe_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&o->exe_queue)) {
 		elem = list_first_entry(&o->exe_queue, struct bnx2x_exeq_elem,
 					link);
 		WARN_ON(!elem->cmd_len);
@@ -231,6 +247,12 @@ static inline int bnx2x_exe_queue_step(s
 			list_del(&spacer.link);
--
-	while (cnt--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (cnt--) {
 		if (!test_bit(state, pstate)) {
 #ifdef BNX2X_STOP_ON_ERROR
 			DP(BNX2X_MSG_SP, "exit  (cnt %d)\n", 5000 - cnt);
@@ -327,6 +354,12 @@ static inline int bnx2x_state_wait(struc
 
--
 	while (cnt--) {
 		/* Wait for the current command to complete */
 		rc = raw->wait_comp(bp, raw);
@@ -1333,6 +1371,12 @@ static int bnx2x_wait_vlan_mac(struct bn
 			usleep_range(1000, 1000);
 		else
--
-		while (!bnx2x_exe_queue_empty(&o->exe_queue) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!bnx2x_exe_queue_empty(&o->exe_queue) &&
 		       max_iterations--) {
 
 			/* Wait for the current command to complete */
@@ -1729,6 +1778,12 @@ int bnx2x_config_vlan_mac(
 						  ramrod_flags);
--
-	while (required_num_of_pg < pg_help_data->num_of_pg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (required_num_of_pg < pg_help_data->num_of_pg) {
 		entry_joined = pg_help_data->num_of_pg - 2;
 		entry_removed = entry_joined + 1;
 		/* protect index */
@@ -1459,6 +1464,12 @@ static int bnx2x_dcbx_join_pgs(
 		}
--
 	while (num_cqes) {
 		struct cnic_ulp_ops *ulp_ops;
 		int ulp_type;
@@ -2705,6 +2710,12 @@ end:
 		num_cqes -= j;
 		i += j;
--
 	while (sw_cons != hw_cons) {
 		u8 cqe_fp_flags;
 
@@ -2767,6 +2783,12 @@ static int cnic_l2_completion(struct cni
 				comp++;
 		}
--
 	while ((kcqe_cnt = cnic_get_kcqes(dev, &cp->kcq1))) {
 
 		service_kcqes(dev, kcqe_cnt);
@@ -2815,6 +2842,12 @@ static u32 cnic_service_bnx2_queues(stru
 		/* status block index must be read first */
 		rmb();
--
 	while ((kcqe_cnt = cnic_get_kcqes(dev, info))) {
 
 		service_kcqes(dev, kcqe_cnt);
@@ -2942,6 +2980,12 @@ static u32 cnic_service_bnx2x_kcq(struct
 		last_status = *info->status_idx_ptr;
 		/* status block index must be read before reading the KCQ */
--
 	while (!list_empty(&cnic_dev_list)) {
 		dev = list_entry(cnic_dev_list.next, struct cnic_dev, list);
 		if (test_bit(CNIC_F_CNIC_UP, &dev->flags)) {
@@ -5451,11 +5500,28 @@ static void cnic_release(void)
 		cnic_unregister_netdev(dev);
 		list_del_init(&dev->list);
--
-	while (!list_empty(&cnic_udev_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cnic_udev_list)) {
 		udev = list_entry(cnic_udev_list.next, struct cnic_uio_dev,
 				  list);
 		cnic_free_uio(udev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while (frag_len_left) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (frag_len_left) {
 		len = min(frag_len_left, (unsigned int)WQ_ENET_MAX_DESC_LEN);
 		dma_addr = pci_map_single(enic->pdev, skb->data + offset,
 				len, PCI_DMA_TODEVICE);
@@ -708,6 +713,12 @@ static inline void enic_queue_wq_skb_tso
 			eop && (len == frag_len_left), loopback);
--
-		while (frag_len_left) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (frag_len_left) {
 			len = min(frag_len_left,
 				(unsigned int)WQ_ENET_MAX_DESC_LEN);
 			dma_addr = skb_frag_dma_map(&enic->pdev->dev, frag,
@@ -735,6 +751,12 @@ static inline void enic_queue_wq_skb_tso
 				loopback);
--
 	while(i--) {
 		if(!(TSI_READ(TSI108_MAC_MII_IND) & TSI108_MAC_MII_IND_BUSY))
 			return;
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(i--){
 		if(!(TSI_READ(TSI108_EC_RXSTAT) & TSI108_EC_RXSTAT_ACTIVE))
 			return;
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!data->txfree || data->txhead != data->txtail) {
 		int tx = data->txtail;
 		struct sk_buff *skb;
@@ -1424,12 +1451,23 @@ static int tsi108_close(struct net_devic
 		data->txtail = (data->txtail + 1) % TSI108_TXRING_LEN;
 		data->txfree++;
--
 	while (data->rxfree) {
 		int rx = data->rxtail;
 		struct sk_buff *skb;
@@ -1438,6 +1476,12 @@ static int tsi108_close(struct net_devic
 		data->rxtail = (data->rxtail + 1) % TSI108_RXRING_LEN;
 		data->rxfree--;
--
 	while ((smsc911x_reg_read(pdata, E2P_CMD) & E2P_CMD_EPC_BUSY_) &&
 	       --timeout) {
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (resets--) {
 		SMC_SET_HW_CFG(lp, HW_CFG_SRST_);
 		timeout=10;
@@ -211,6 +216,12 @@ static void smc911x_reset(struct net_dev
 				break;
 			}
 		} while (--timeout && (reg & HW_CFG_SRST_));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while ((lp->rxrcommit > hp100_inb(RX_PDL))) {
 		/*
 		 * The packet was received into the pdl pointed to by lp->rxrhead (
@@ -1972,6 +1977,12 @@ static void hp100_rx_bm(struct net_devic
 			lp->rxrtail = lp->rxrtail->next;
 		}
--
 	while (wis) {
 		skb = unmap_array[unmap_cons].skb;
 
@@ -207,6 +212,12 @@ bnad_free_txbufs(struct bnad *bnad,
 				skb_shinfo(skb)->nr_frags);
 
--
-	while (to_alloc--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (to_alloc--) {
 		if (!wi_range)
 			BNA_RXQ_QPGE_PTR_GET(unmap_prod, rcb->sw_qpt, rxent,
 					     wi_range);
@@ -390,7 +406,13 @@ bnad_alloc_n_post_rxbufs(struct bnad *bn
 		rxent++;
--
-	while (cmpl->valid && packets < budget) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cmpl->valid && packets < budget) {
 		packets++;
 		BNA_UPDATE_PKT_CNT(pkt_rt, ntohs(cmpl->length));
 
@@ -516,6 +543,12 @@ bnad_poll_cq(struct bnad *bnad, struct b
 next:
--
 	while (!list_empty(&rxf->mcast_pending_del_q)) {
 		bfa_q_deq(&rxf->mcast_pending_del_q, &qe);
 		bfa_q_qe_init(qe);
@@ -542,6 +547,12 @@ bna_rxf_mcast_cfg_apply(struct bna_rxf *
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
 		if (ret)
--
 		while (!(vlan_pending_bitmask & 0x1)) {
 			block_idx++;
 			vlan_pending_bitmask >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!list_empty(&rxf->mcast_pending_del_q)) {
 		bfa_q_deq(&rxf->mcast_pending_del_q, &qe);
 		bfa_q_qe_init(qe);
@@ -593,9 +620,20 @@ bna_rxf_mcast_cfg_reset(struct bna_rxf *
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
 		if (ret)
--
 	while (!list_empty(&rxf->mcast_active_q)) {
 		bfa_q_deq(&rxf->mcast_active_q, &qe);
 		bfa_q_qe_init(qe);
@@ -603,6 +641,12 @@ bna_rxf_mcast_cfg_reset(struct bna_rxf *
 		mac = (struct bna_mac *)qe;
 		if (bna_rxf_mcast_del(rxf, mac, cleanup))
--
 	while (!list_empty(&rxf->ucast_pending_add_q)) {
 		bfa_q_deq(&rxf->ucast_pending_add_q, &mac);
 		bfa_q_qe_init(&mac->qe);
 		bna_ucam_mod_mac_put(&rxf->rx->bna->ucam_mod, mac);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&rxf->mcast_pending_add_q)) {
 		bfa_q_deq(&rxf->mcast_pending_add_q, &mac);
 		bfa_q_qe_init(&mac->qe);
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (!list_empty(&rxf->mcast_pending_add_q)) {
 		bfa_q_deq(&rxf->mcast_pending_add_q, &qe);
 		bfa_q_qe_init(qe);
 		mac = (struct bna_mac *)qe;
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
+		if (_cur < timeout) {
--
 	while (!list_empty(&rxf->mcast_active_q)) {
 		bfa_q_deq(&rxf->mcast_active_q, &qe);
 		mac = (struct bna_mac *)qe;
 		bfa_q_qe_init(&mac->qe);
 		list_add_tail(&mac->qe, &rxf->mcast_pending_del_q);
+		if (_cur < timeout) {
--
 	while (!list_empty(&list_head)) {
 		bfa_q_deq(&list_head, &qe);
 		mac = (struct bna_mac *)qe;
 		bfa_q_qe_init(&mac->qe);
 		list_add_tail(&mac->qe, &rxf->mcast_pending_add_q);
+		if (_cur < timeout) {
--
 	while (!list_empty(&list_head)) {
 		bfa_q_deq(&list_head, &qe);
 		mac = (struct bna_mac *)qe;
 		bfa_q_qe_init(&mac->qe);
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
+		if (_cur < timeout) {
--
 	while (!list_empty(&rxf->ucast_pending_del_q)) {
 		bfa_q_deq(&rxf->ucast_pending_del_q, &qe);
 		bfa_q_qe_init(qe);
@@ -1058,9 +1173,20 @@ bna_rxf_ucast_cfg_reset(struct bna_rxf *
 			bna_ucam_mod_mac_put(&rxf->rx->bna->ucam_mod, mac);
 			return 1;
--
 	while (!list_empty(&rxf->ucast_active_q)) {
 		bfa_q_deq(&rxf->ucast_active_q, &qe);
 		bfa_q_qe_init(qe);
@@ -1071,6 +1197,12 @@ bna_rxf_ucast_cfg_reset(struct bna_rxf *
 				BFI_ENET_H2I_MAC_UCAST_DEL_REQ);
 			return 1;
--
 	while (!list_empty(&rx->rxp_q)) {
 		bfa_q_deq(&rx->rxp_q, &rxp);
 		GET_RXQS(rxp, q0, q1);
@@ -2573,6 +2710,12 @@ bna_rx_destroy(struct bna_rx *rx)
 		rxp->cq.ccb = NULL;
 		rxp->rx = NULL;
--
 	while (!list_empty(&tx->txq_q)) {
 		bfa_q_deq(&tx->txq_q, &txq);
 		bfa_q_qe_init(&txq->qe);
 		txq->tcb = NULL;
 		txq->tx = NULL;
 		list_add_tail(&txq->qe, &tx_mod->txq_free_q);
--
 	while (!list_empty(&cmdq->pending_q)) {
 		bfa_q_deq(&cmdq->pending_q, &cmdq_ent);
 		bfa_q_qe_init(&cmdq_ent->qe);
 		call_cmdq_ent_cbfn(cmdq_ent, BFA_STATUS_FAILED);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		to_copy = (len < BFI_MSGQ_CMD_ENTRY_SIZE) ?
 				len : BFI_MSGQ_CMD_ENTRY_SIZE;
 		memcpy(dst, src, to_copy);
@@ -228,6 +244,12 @@ __cmd_copy(struct bfa_msgq_cmdq *cmdq, s
 		dst = (u8 *)cmdq->addr.kva;
--
 	while (!list_empty(&cmdq->pending_q)) {
 		cmd =
 		(struct bfa_msgq_cmd_entry *)bfa_q_first(&cmdq->pending_q);
@@ -254,6 +281,12 @@ bfa_msgq_cmdq_ci_update(struct bfa_msgq_
 		} else {
 			break;
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		to_copy = (len < BFI_MSGQ_RSP_ENTRY_SIZE) ?
 				len : BFI_MSGQ_RSP_ENTRY_SIZE;
 		memcpy(dst, src, to_copy);
@@ -665,5 +703,11 @@ bfa_msgq_rsp_copy(struct bfa_msgq *msgq,
 		BFA_MSGQ_INDX_ADD(ci, 1, rspq->depth);
--
 	while (n--) {
 		if (d->skb) {	/* an SGL is present */
 			if (need_unmap)
@@ -307,6 +312,12 @@ static void free_tx_desc(struct adapter
 			cidx = 0;
 			d = q->sdesc;
--
 	while (q->credits--) {
 		struct rx_sw_desc *d = &q->sdesc[cidx];
 
@@ -388,6 +404,12 @@ static void free_rx_bufs(struct pci_dev
 		clear_rx_desc(pdev, q, d);
 		if (++cidx == q->size)
--
 	while (work_done < budget) {
 		struct sk_buff *skb, *tmp, *skbs[RX_BUNDLE_SIZE];
 		struct sk_buff_head queue;
@@ -1872,6 +1899,12 @@ static int ofld_poll(struct napi_struct
 			spin_unlock_irq(&q->lock);
 		}
--
 	while (adap->sge.qs[0].rspq.offload_pkts < init_cnt + n) {
 		if (!--attempts)
 			return -ETIMEDOUT;
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while (t.len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (t.len) {
 			unsigned int chunk =
 				min_t(unsigned int, t.len, sizeof(buf));
 
@@ -2418,6 +2434,12 @@ static int cxgb_extension_ioctl(struct n
 			useraddr += chunk;
--
 		while (v) {
 			qs->fl[i].empty += (v & 1);
 			if (i)
 				qs++;
 			i ^= 1;
 			v >>= 1;
--
-	while (n--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (n--) {
 		struct sk_buff *skb = *skbs++;
 		unsigned int opcode = get_opcode(skb);
 		int ret = cpl_handlers[opcode] (dev, skb);
@@ -1033,6 +1038,12 @@ static int process_rx(struct t3cdev *dev
 #endif
--
 	while (1) {
 		u32 val = t3_read_reg(adapter, reg);
 
@@ -67,6 +72,12 @@ int t3_wait_op_done_val(struct adapter *
 			return -EAGAIN;
 		if (delay)
--
 	while (n--) {
 		t3_write_reg(adapter, p->reg_addr + offset, p->val);
 		p++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (nregs--) {
 		t3_write_reg(adap, addr_reg, start_idx);
 		*vals++ = t3_read_reg(adap, data_reg);
 		start_idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (n--) {
 		int i;
 		u64 val64 = 0;
@@ -186,6 +224,12 @@ int t3_mc7_bd_read(struct mc7 *mc7, unsi
 			start += 8;
 		}
--
 	while (1) {
 		if ((ret = sf1_write(adapter, 1, 1, SF_RD_STATUS)) != 0 ||
 		    (ret = sf1_read(adapter, 1, 0, &status)) != 0)
@@ -826,6 +875,12 @@ static int flash_wait_op(struct adapter
 			return -EAGAIN;
 		if (delay)
--
 	while (start <= end) {
 		int ret;
 
@@ -1072,6 +1132,12 @@ static int t3_flash_erase_sectors(struct
 		    (ret = flash_wait_op(adapter, 5, 500)) != 0)
 			return ret;
--
 	while (n--) {
 		if (d->skb) {                       /* an SGL is present */
 			if (unmap)
@@ -350,6 +355,12 @@ static void free_tx_desc(struct adapter
 			cidx = 0;
 			d = q->sdesc;
--
 	while (n--) {
 		struct rx_sw_desc *d = &q->sdesc[q->cidx];
 
@@ -424,6 +440,12 @@ static void free_rx_bufs(struct adapter
 		if (++q->cidx == q->size)
 			q->cidx = 0;
--
-	while (frags--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (frags--) {
 		if (q->cidx == 0)
 			q->cidx = q->size - 1;
 		else
@@ -1639,6 +1666,12 @@ static void restore_rx_bufs(const struct
 		d->page = si->frags[frags].page;
--
 	while (count) {
 		size_t len;
 		int ret, ofst;
@@ -2040,6 +2045,12 @@ static ssize_t mem_read(struct file *fil
 		buf += len;
 		pos += len;
--
 	while (adap->tid_release_head) {
 		void **p = adap->tid_release_head;
 		unsigned int chan = (uintptr_t)p & 3;
@@ -2233,6 +2249,12 @@ static void process_tid_release_list(str
 		mk_tid_release(skb, chan, p - adap->tids.tid_tab);
 		t4_ofld_send(adap, skb);
--
 	while (1) {
 		u32 val = t4_read_reg(adapter, reg);
 
@@ -68,6 +73,12 @@ static int t4_wait_op_done_val(struct ad
 			return -EAGAIN;
 		if (delay)
--
 	while (nregs--) {
 		t4_write_reg(adap, addr_reg, start_idx);
 		*vals++ = t4_read_reg(adap, data_reg);
 		start_idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		if ((ret = sf1_write(adapter, 1, 1, 1, SF_RD_STATUS)) != 0 ||
 		    (ret = sf1_read(adapter, 1, 0, 1, &status)) != 0)
@@ -517,6 +544,12 @@ static int flash_wait_op(struct adapter
 			return -EAGAIN;
 		if (delay)
--
 	while (nparams--) {
 		*p++ = htonl(*params++);
 		*p++ = htonl(*val++);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (e->arpq_head) {
 		struct sk_buff *skb = e->arpq_head;
 
 		e->arpq_head = skb->next;
 		skb->next = NULL;
 		t4_ofld_send(adap, skb);
--
 		while (e->arpq_head) {
 			struct sk_buff *skb = e->arpq_head;
 
 			e->arpq_head = skb->next;
 			kfree_skb(skb);
+			if (_cur < timeout) {
--
 	while (arpq) {
 		struct sk_buff *skb = arpq;
 		const struct l2t_skb_cb *cb = L2T_SKB_CB(skb);
@@ -428,6 +455,12 @@ static void handle_failed_resolution(str
 			cb->arp_err_handler(cb->handle, skb);
 		else
--
 	while (n--) {
 		/*
 		 * If we kept a reference to the original TX skb, we need to
@@ -410,6 +415,12 @@ static void free_tx_desc(struct adapter
 			cidx = 0;
 			sdesc = tq->sdesc;
--
 	while (n--) {
 		struct rx_sw_desc *sdesc = &fl->sdesc[fl->cidx];
 
@@ -489,6 +505,12 @@ static void free_rx_bufs(struct adapter
 		if (++fl->cidx == fl->size)
 			fl->cidx = 0;
--
-	while (frags--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (frags--) {
 		if (fl->cidx == 0)
 			fl->cidx = fl->size - 1;
 		else
@@ -1603,6 +1630,12 @@ static void restore_rx_bufs(const struct
 		sdesc->page = gl->frags[frags].page;
--
 			while (nqbuf) {
 				nqbuf--;
 				*qbp++ = *rsp++;
 				if (rsp >= rsp_end)
 					rsp = rspq;
+					if (_cur < timeout) {
--
 	while (rem) {
 		unsigned int ix = VI_VF_NUM_STATS - rem;
 		unsigned int nstats = min(6U, rem);
@@ -1223,6 +1239,12 @@ int t4vf_get_port_stats(struct adapter *
 
 		rem -= nstats;
--
-	while (q->credits--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (q->credits--) {
 		struct freelQ_ce *ce = &q->centries[cidx];
 
 		pci_unmap_single(pdev, dma_unmap_addr(ce, dma_addr),
@@ -530,6 +535,12 @@ static void free_freelQ_buffers(struct p
 		ce->skb = NULL;
--
 	while (n--) {
 		if (likely(dma_unmap_len(ce, dma_len))) {
 			pci_unmap_single(pdev, dma_unmap_addr(ce, dma_addr),
@@ -654,6 +670,12 @@ static void free_cmdQ_buffers(struct sge
 			cidx = 0;
 			ce = q->centries;
--
 	while (done < budget && e->GenerationBit == q->genbit) {
 		flags |= e->Qsleeping;
 
@@ -1544,6 +1571,12 @@ static int process_responses(struct adap
 			writel(q->credits, adapter->regs + A_SG_RSPQUEUECREDIT);
 			q->credits = 0;
--
 	while (1) {
 		u32 val = readl(adapter->regs + reg) & mask;
 
@@ -71,6 +76,12 @@ static int t1_wait_op_done(adapter_t *ad
 			return 1;
 		if (delay)
--
 	while (dlist->descriptors[lp->rxBuffIndex].addr & EMAC_DESC_DONE) {
 		p_recv = dlist->recv_buf[lp->rxBuffIndex];
 		pktlen = dlist->descriptors[lp->rxBuffIndex].size & 0x7ff;	/* Length of frame including FCS */
@@ -907,6 +912,12 @@ static void at91ether_rx(struct net_devi
 			lp->rxBuffIndex = 0;
 		else
--
 	while ((rx < budget) && !complete) {
 		struct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];
 
@@ -170,6 +175,12 @@ ltq_etop_poll_rx(struct napi_struct *nap
 		} else {
 			complete = 1;
--
 	while (tx_index--) {
 		mlx4_en_deactivate_tx_ring(priv, &priv->tx_ring[tx_index]);
 		mlx4_en_deactivate_cq(priv, &priv->tx_cq[tx_index]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (i > start) {
 		i -= inc;
 		mlx4_table_put(dev, table, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cmd_pending(dev)) {
 		if (time_after_eq(jiffies, end))
 			goto out;
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (ring->cons != ring->prod) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ring->cons != ring->prod) {
 		ring->last_nr_txbb = mlx4_en_free_tx_desc(priv, ring,
 						ring->cons & ring->size_mask,
 						!!(ring->cons & ring->size));
 		ring->cons += ring->last_nr_txbb;
 		cnt++;
--
 		while (t & ((1 << buf->page_shift) - 1)) {
 			--buf->page_shift;
 			buf->npages *= 2;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
--
 	while ((eqe = next_eqe_sw(eq))) {
 		/*
 		 * Make sure we read EQ entry contents after we've
@@ -257,6 +262,12 @@ static int mlx4_eq_int(struct mlx4_dev *
 			eq_set_ci(eq, 0);
 			set_ci = 0;
--
 	while (i--) {
 		page_alloc = &ring->page_alloc[i];
 		put_page(page_alloc->page);
 		page_alloc->page = NULL;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while (ring->actual_size > new_size) {
 			ring->actual_size--;
 			ring->prod--;
 			mlx4_en_free_rx_desc(priv, ring, ring->actual_size);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (ring->cons != ring->prod) {
 		index = ring->cons & ring->size_mask;
 		en_dbg(DRV, priv, "Processing descriptor:%d\n", index);
 		mlx4_en_free_rx_desc(priv, ring, index);
 		++ring->cons;
+		if (_cur < timeout) {
--
-	while (XNOR(cqe->owner_sr_opcode & MLX4_CQE_OWNER_MASK,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (XNOR(cqe->owner_sr_opcode & MLX4_CQE_OWNER_MASK,
 		    cq->mcq.cons_index & cq->size)) {
 
 		skb_frags = ring->rx_info + (index << priv->log_rx_info);
@@ -673,6 +711,12 @@ next:
 			 * flush only pending LRO sessions */
--
-	while (buf_size < eff_mtu) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (buf_size < eff_mtu) {
 		priv->frag_info[i].frag_size =
 			(eff_mtu > buf_size + frag_sizes[i]) ?
 				frag_sizes[i] : eff_mtu - buf_size;
@@ -765,6 +814,12 @@ void mlx4_en_calc_rx_buf(struct net_devi
 						priv->frag_info[i].frag_align);
--
 	while (o > order) {
 		--o;
 		seg <<= 1;
 		set_bit(seg ^ 1, buddy->bits[o]);
 		++buddy->num_free[o];
+		if (_cur < timeout) {
--
 	while (test_bit(seg ^ 1, buddy->bits[order])) {
 		clear_bit(seg ^ 1, buddy->bits[order]);
 		--buddy->num_free[order];
 		seg >>= 1;
 		++order;
+		if (_cur < timeout) {
--
-	while (((u8)(pd->rx_skb_i - pd->rx_skb_o)) >
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (((u8)(pd->rx_skb_i - pd->rx_skb_o)) >
 			s6dmac_pending_count(pd->rx_dma, pd->rx_chan)) {
 		skb = pd->rx_skb[(pd->rx_skb_o++) % S6_NUM_RX_SKB];
 		pfx = readl(pd->reg + S6_GMAC_BURST_POSTRD);
@@ -400,15 +405,32 @@ static void s6gmac_rx_interrupt(struct n
 			skb->ip_summed = CHECKSUM_UNNECESSARY;
--
-	while (((u8)(pd->tx_skb_i - pd->tx_skb_o)) >
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (((u8)(pd->tx_skb_i - pd->tx_skb_o)) >
 			s6dmac_pending_count(pd->tx_dma, pd->tx_chan)) {
 		dev_kfree_skb_irq(pd->tx_skb[(pd->tx_skb_o++) % S6_NUM_TX_SKB]);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (mask) {
 		b = fls(mask) - 1;
 		mask &= ~(1 << b);
 		pd->carry[inf[b].net_index] += (1 << inf[b].reg_size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (readl(pd->reg + S6_GMAC_MACMIIINDI)) {
 		if (--tmo == 0)
 			return -ETIME;
 		udelay(64);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (i < nr_of_pages) {
 		u8 *kpage = (u8 *)get_zeroed_page(GFP_KERNEL);
 		if (!kpage)
@@ -87,6 +92,12 @@ static int hw_queue_ctor(struct hw_queue
 			kpage += pagesize;
 			i++;
--
 	while (pfn < end_pfn) {
 		if (ehea_is_hugepage(pfn)) {
 			/* Add mem found in front of the hugepage */
@@ -740,6 +756,12 @@ static int ehea_create_busmap_callback(u
 			start_pfn = pfn;
 		} else
--
 	while (rx != budget) {
 		napi_complete(napi);
 		ehea_reset_cq_ep(pr->recv_cq);
@@ -905,6 +910,12 @@ static int ehea_poll(struct napi_struct
 
 		cqe_skb = ehea_proc_cqes(pr, EHEA_POLL_MAX_CQES);
--
-	while (eqe) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (eqe) {
 		qp_token = EHEA_BMASK_GET(EHEA_EQE_QP_TOKEN, eqe->entry);
 		pr_err("QP aff_err: entry=0x%llx, token=0x%x\n",
 		       eqe->entry, qp_token);
@@ -959,6 +975,12 @@ static irqreturn_t ehea_qp_aff_irq_handl
 			reset_port = 1;   /* Reset in case of CQ or EQ error */
--
 	while (eqe) {
 		pr_debug("*eqe=%lx\n", (unsigned long) eqe->entry);
 		ehea_parse_eqe(adapter, eqe->entry);
 		eqe = ehea_poll_eq(adapter->neq);
 		pr_debug("next eqe=%p\n", eqe);
+		if (_cur < timeout) {
--
-	while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
 
 		dn_log_port_id = of_get_property(eth_dn, "ibm,hea-port-no",
 						 NULL);
@@ -3110,6 +3148,12 @@ static int ehea_setup_ports(struct ehea_
 			ehea_remove_adapter_mr(adapter);
--
-	while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
 
 		dn_log_port_id = of_get_property(eth_dn, "ibm,hea-port-no",
 						 NULL);
 		if (dn_log_port_id)
 			if (*dn_log_port_id == logical_port_id)
--
 		while (!(in_be32(&p->mr0) & EMAC_MR0_TXI) && n) {
 			udelay(1);
 			--n;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 			while (!(r = in_be32(&p->mr0) & EMAC_MR0_RXI) && n) {
 				udelay(1);
 				--n;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 		while (!(in_be32(&p->mr0) & EMAC_MR0_RXI) && n) {
 			udelay(1);
 			--n;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!emac_phy_done(dev, in_be32(&p->stacr))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait idle\n");
 			goto bail;
 		}
--
 	while (!emac_phy_done(dev, (r = in_be32(&p->stacr)))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait complete\n");
 			goto bail;
 		}
--
 	while (!emac_phy_done(dev, in_be32(&p->stacr))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait idle\n");
 			goto bail;
 		}
--
 	while (!emac_phy_done(dev, in_be32(&p->stacr))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait complete\n");
 			goto bail;
 		}
--
 	while (slot != dev->tx_slot) {
 		dev->tx_desc[slot].ctrl = 0;
 		--dev->tx_cnt;
 		if (--slot < 0)
 			slot = NUM_TX_BUFF - 1;
+			if (_cur < timeout) {
--
 	while (1) {
 		u16 ctrl = dev->rx_desc[slot].ctrl;
 		if (ctrl & MAL_RX_CTRL_EMPTY)
@@ -1805,6 +1898,12 @@ static int emac_peek_rx_sg(void *param)
 		/* I'm just being paranoid here :) */
 		if (unlikely(slot == dev->rx_slot))
--
 	while (done < length) {
 		list[i].addr = iseries_hv_addr(p + done);
 		list[i].size = min(length-done, PAGE_SIZE);
 		done += list[i].size;
 		i++;
+		if (_cur < timeout) {
--
 	while (IS_DMA_FINISHED(td->control)) {
 		if (lp->tx_full == 1) {
 			netif_wake_queue(dev);
@@ -592,6 +597,12 @@ static void korina_tx(struct net_device
 		lp->tx_next_done = (lp->tx_next_done + 1) & KORINA_TDS_MASK;
 		td = &lp->td_ring[lp->tx_next_done];
--
 	while (count) {
 		temp = ql_read_other_func_reg(qdev, reg);
 
@@ -55,6 +60,12 @@ static int ql_wait_other_func_reg_rdy(st
 			return 0;
 		mdelay(10);
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count) {
 		temp = ql_read32(qdev, reg);
 
 		/* check for errors */
@@ -181,6 +186,12 @@ int ql_wait_reg_rdy(struct ql_adapter *q
 			return 0;
--
 	while (count) {
 		temp = ql_read32(qdev, CFG);
 		if (temp & CFG_LE)
@@ -203,6 +219,12 @@ static int ql_wait_cfg(struct ql_adapter
 			return 0;
 		udelay(UDELAY_DELAY);
--
-	while (prod != rx_ring->cnsmr_idx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (prod != rx_ring->cnsmr_idx) {
 
 		netif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,
 			     "cq_id = %d, prod = %d, cnsmr = %d.\n.",
@@ -2199,6 +2226,12 @@ static int ql_clean_outbound_rx_ring(str
 		count++;
--
 	while (curr_idx != clean_idx) {
 		lbq_desc = &rx_ring->lbq[curr_idx];
 
@@ -2768,6 +2806,12 @@ static void ql_free_lbq_buffers(struct q
 		if (++curr_idx == rx_ring->lbq_len)
 			curr_idx = 0;
--
-		while (i-- && !test_bit(QL_ADAPTER_UP, &qdev->flags)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (i-- && !test_bit(QL_ADAPTER_UP, &qdev->flags)) {
 			netif_err(qdev, ifup, qdev->ndev,
 				  "Waiting for adapter UP...\n");
 			ssleep(1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count) {
 		temp = ql_read_page0_reg(qdev, &port_regs->macMIIStatusReg);
 		if (!(temp & MAC_MII_STATUS_BSY))
 			return 0;
 		udelay(10);
 		count--;
--
 	while ((le32_to_cpu(*(qdev->prsp_producer_index)) !=
 		qdev->rsp_consumer_index) && (work_done < work_to_do)) {
 
@@ -2178,6 +2194,12 @@ static int ql_tx_rx_clean(struct ql3_ada
 		}
 
--
-		while (copied < hdr_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (copied < hdr_len) {
 
 			copy_len = min((int)sizeof(struct cmd_desc_type0) -
 				offset, (hdr_len - copied));
@@ -2079,6 +2084,12 @@ set_flags:
 			offset = 0;
--
-	while (!list_empty(head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(head)) {
 		cur = list_entry(head->next, struct qlcnic_mac_list_s, list);
 		qlcnic_sre_macaddr_change(adapter,
 				cur->mac_addr, 0, QLCNIC_MAC_DEL);
 		list_del(&cur->list);
 		kfree(cur);
--
 		while (cnt) {
 			QLCNIC_RD_DUMP_REG(addr, base, &data);
 			*buffer++ = cpu_to_le32(data);
 			addr += l1->read_addr_stride;
 			cnt--;
+			if (_cur < timeout) {
--
 		while (cnt) {
 			QLCNIC_RD_DUMP_REG(addr, base, &data);
 			*buffer++ = cpu_to_le32(data);
 			addr += l2->read_addr_stride;
 			cnt--;
+			if (_cur < timeout) {
--
-	while (copied < hdr_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (copied < hdr_len) {
 
 		copy_len = min((int)sizeof(struct cmd_desc_type0) - offset,
 				(hdr_len - copied));
@@ -1879,6 +1884,12 @@ netxen_tso_check(struct net_device *netd
 		offset = 0;
--
 	while (!list_empty(head)) {
 		cur = list_entry(head->next, struct nx_vlan_ip_list, list);
 		netxen_config_ipaddr(adapter, cur->ip_addr, NX_IP_DOWN);
 		list_del(&cur->list);
 		kfree(cur);
+		if (_cur < timeout) {
--
-	while (!list_empty(head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(head)) {
 		cur = list_entry(head->next, nx_mac_list_t, list);
 
 		nx_p3_sre_macaddr_change(adapter,
 				cur->mac_addr, NETXEN_MAC_DEL);
 		list_del(&cur->list);
--
-	while (!list_empty(head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(head)) {
 		cur = list_entry(head->next, nx_mac_list_t, list);
 		nx_p3_sre_macaddr_change(adapter,
 				cur->mac_addr, NETXEN_MAC_DEL);
 		list_del(&cur->list);
 		kfree(cur);
--
 	while (f->m.wptr != f->m.rptr) {
 		f->m.rptr += BDX_TXF_DESC_SZ;
 		f->m.rptr &= f->m.size_mask;
@@ -1731,6 +1736,12 @@ static void bdx_tx_cleanup(struct bdx_pr
 		/* now should come skb pointer - free it */
 		dev_kfree_skb_irq(db->rptr->addr.skb);
--
-	while (db->rptr != db->wptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (db->rptr != db->wptr) {
 		if (likely(db->rptr->len))
 			pci_unmap_page(priv->pdev, db->rptr->addr.dma,
 				       db->rptr->len, PCI_DMA_TODEVICE);
 		else
 			dev_kfree_skb(db->rptr->addr.skb);
--
 	while (1) {
 		/* read descriptor that was next to be filled by SONIC */
 
@@ -641,6 +646,12 @@ static void irqrx_handler(struct net_dev
 		priv->lastrxdescr = priv->nextrxdescr;
 		if ((++priv->nextrxdescr) >= priv->rxbufcnt)
--
 	while (1) {
 		ival = inw(dev->base_addr + SONIC_ISREG);
 
@@ -733,6 +749,12 @@ static irqreturn_t irq_handler(int dummy
 			outw(ISREG_TXER, dev->base_addr + SONIC_ISREG);
 		}
--
 		while (destoffs < tmplen) {
 			memcpy_toio(priv->base + baddr + destoffs, fill, l);
 			destoffs += l;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((tx_done_idx != dev->tx_free_idx) &&
 	       !(CMDSTS_OWN & (cmdsts = le32_to_cpu(desc[DESC_CMDSTS]))) ) {
 		struct sk_buff *skb;
@@ -1018,6 +1023,12 @@ static void do_tx_done(struct net_device
 		desc[DESC_CMDSTS] = cpu_to_le32(0);
 		mb();
--
 	while (IPG_AC_RESET_BUSY & ipg_r32(ASIC_CTRL)) {
 		mdelay(IPG_AC_RESETWAIT);
 		if (++timeout_count > IPG_AC_RESET_TIMEOUT)
 			return -ETIME;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while ((le64_to_cpu(rxfd->rfs) & IPG_RFS_RFDDONE) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((le64_to_cpu(rxfd->rfs) & IPG_RFS_RFDDONE) &&
 	       !((le64_to_cpu(rxfd->rfs) & IPG_RFS_FRAMESTART) &&
 		 (le64_to_cpu(rxfd->rfs) & IPG_RFS_FRAMEEND))) {
 		unsigned int entry = curr++ % IPG_RFDLIST_LENGTH;
@@ -1533,6 +1549,12 @@ static int ipg_nic_rx(struct net_device
 
--
 	while (!(alloc & 1)) {
 		shift++;
 		alloc >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (alloc) {
 			shift++;
 			alloc >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (hw->tx_int_mask) {
 		hw->tx_int_cnt++;
 		hw->tx_int_mask >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (info->avail < info->alloc) {
 		/* Get next descriptor which is not hardware owned. */
 		desc = &info->ring[last];
@@ -4799,6 +4837,12 @@ static void transmit_cleanup(struct dev_
 		last++;
 		last &= info->mask;
--
 	while (range->end > range->start) {
 		regs_len += (range->end - range->start + 3) / 4 * 4;
 		range++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (range->end > range->start) {
 		for (len = range->start; len < range->end; len += 4) {
 			*buf = readl(hw->io + len);
 			buf++;
 		}
 		range++;
--
-	while (received < budget
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (received < budget
 			&& ksp->rx_buffers[buff_n].skb
 			&& (!(ksp->rx_ring[buff_n].status &
 					cpu_to_le32(RDES_OWN)))) {
@@ -536,6 +541,12 @@ rx_failure:
 rx_finished:
--
 	while (!last) {
 		txb = skb_dequeue(&ks->txq);
 		last = skb_queue_empty(&ks->txq);
@@ -733,6 +738,12 @@ static void ks8851_tx_work(struct work_s
 
 			ks8851_done_tx(ks, txb);
--
-	while (!skb_queue_empty(&ks->txq)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!skb_queue_empty(&ks->txq)) {
 		struct sk_buff *txb = skb_dequeue(&ks->txq);
 
 		netif_dbg(ks, ifdown, ks->netdev,
 			  "%s: freeing txb %p\n", __func__, txb);
 
--
 	while (ks->frame_cnt--) {
 		skb = dev_alloc_skb(frame_hdr->len + 16);
 		if (likely(skb && (frame_hdr->sts & RXFSHR_RXFV) &&
@@ -812,6 +817,12 @@ static void ks_rcv(struct ks_net *ks, st
 				dev_kfree_skb_irq(skb);
 		}
--
 	while (rx_data) {
 		ks8842_rx_frame(netdev, adapter);
 		rx_data = ks8842_read16(adapter, 16, REG_RXMIR) & 0x1fff;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((bfin_read_EMAC_STAADD()) & STABUSY) {
 		udelay(1);
 		if (timeout_cnt-- < 0) {
 			pr_err("wait MDC/MDIO transaction to complete timeout\n");
 			return -ETIMEDOUT;
 		}
--
 	while (tx_list_head != current_tx_ptr) {
 		tx_list_head->desc_a.config &= ~DMAEN;
 		tx_list_head->status.status_word = 0;
@@ -1277,6 +1293,12 @@ static void bfin_mac_timeout(struct net_
 			tx_list_head->skb = NULL;
 		}
--
 	while (!skb_queue_empty(&lp->cache.queue) && !netif_queue_stopped(dev) && lp->tx_enable) {
 	    de4x5_queue_pkt(de4x5_get_cache(dev), dev);
+	    if (_cur < timeout) {
+	    rdstcll(_cur);
+	    }
+	    else {
--
-    while (count--) {
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+	while (count--) {
 	gep_wr(((lp->chipset==DC21140) && (lp->ibn!=5) ?
 		                                   *p++ : get_unaligned_le16(w++)), dev);
 	mdelay(2);                          /* 2ms per action */
+	if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (db->rx_avail_cnt) {
 		dev_kfree_skb(db->rx_ready_ptr->rx_skb_ptr);
 		db->rx_ready_ptr = db->rx_ready_ptr->next_rx_desc;
 		db->rx_avail_cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--i) {
 		if (!de_is_running(de))
 			return;
 		udelay(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (db->rx_avail_cnt) {
 		dev_kfree_skb(db->rx_ready_ptr->rx_skb_ptr);
 		db->rx_ready_ptr = db->rx_ready_ptr->next_rx_desc;
 		db->rx_avail_cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (inb(EWRK3_RQC) && !status) {	/* Whilst there's incoming data */
 		if ((page = inb(EWRK3_RQ)) < lp->mPage) {	/* Get next entry's buffer page */
 			/*
@@ -1048,6 +1053,12 @@ static int ewrk3_rx(struct net_device *d
 			printk("ewrk3_rx(): Illegal page number, page %d\n", page);
 			printk("ewrk3_rx(): CSR: %02x ICR: %02x FMQC: %02x\n", inb(EWRK3_CSR), inb(EWRK3_ICR), inb(EWRK3_FMQC));
--
     while (eth_status & FullPktRcvd) {
 	rsr = GetByte(XIRCREG0_RSR);
 	if (bytes_rcvd > maxrx_bytes && (rsr & PktRxOk)) {
@@ -1124,6 +1129,12 @@ xirc2ps_interrupt(int irq, void *dev_id)
 
 	/* get the new ethernet status */
--
     while (--i) {
 	out_8(&mb->biucc, SWRST);
 	if (in_8(&mb->biucc) & SWRST) {
@@ -332,6 +337,12 @@ static void mace_reset(struct net_device
 	    continue;
 	}
--
     while (in_8(&mb->pr) & XMTSV) {
 	del_timer(&mp->tx_timeout);
 	mp->timeout_active = 0;
@@ -778,6 +794,12 @@ static irqreturn_t mace_interrupt(int ir
 	mace_last_fs = fs;
 	mace_last_xcount = xcount;
--
 	while (--i) {
 		mb->biucc = SWRST;
 		if (mb->biucc & SWRST) {
@@ -277,6 +282,12 @@ static void mace_reset(struct net_device
 			continue;
 		}
--
-		while (mp->rx_tail < head) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (mp->rx_tail < head) {
 			mace_dma_rx_frame(dev, (struct mace_frame*) (mp->rx_ring
 				+ (mp->rx_tail * MACE_BUFF_SIZE)));
 			mp->rx_tail++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (in_be32(lp->base_addr + XEL_MDIOCTRL_OFFSET) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (in_be32(lp->base_addr + XEL_MDIOCTRL_OFFSET) &
 			XEL_MDIOCTRL_MDIOSTS_MASK) {
 		if (end - jiffies <= 0) {
 			WARN_ON(1);
 			return -ETIMEDOUT;
 		}
--
 	while (!(temac_ior(lp, XTE_RDY0_OFFSET) & XTE_RDY0_HARD_ACS_RDY_MASK)) {
 		if (end - jiffies <= 0) {
 			WARN_ON(1);
 			return -ETIMEDOUT;
 		}
 		msleep(1);
--
 	while (tp->opt) {
 		reg = temac_indirect_in32(lp, tp->reg) & ~tp->m_or;
 		if (options & tp->opt)
 			reg |= tp->m_or;
 		temac_indirect_out32(lp, tp->reg, reg);
 		tp++;
--
-	while (stat & STS_CTRL_APP0_CMPLT) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (stat & STS_CTRL_APP0_CMPLT) {
 		dma_unmap_single(ndev->dev.parent, cur_p->phys, cur_p->len,
 				 DMA_TO_DEVICE);
 		if (cur_p->app4)
@@ -652,6 +679,12 @@ static void temac_start_xmit_done(struct
 
--
-	while ((bdstat & STS_CTRL_APP0_CMPLT)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((bdstat & STS_CTRL_APP0_CMPLT)) {
 
 		skb = lp->rx_skb[lp->rx_bd_ci];
 		length = cur_p->app4 & 0x3FFF;
@@ -813,6 +851,12 @@ static void ll_temac_recv(struct net_dev
 
--
-		while((idev = pnp_find_dev(NULL,
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while((idev = pnp_find_dev(NULL,
 					   corkscrew_isapnp_adapters[i].vendor,
 					   corkscrew_isapnp_adapters[i].function,
 					   idev))) {
@@ -541,6 +546,12 @@ static struct net_device *corkscrew_scan
 			if (!err)
--
 	while ((rx_status = vp->rx_ring[entry].status) & RxDComplete) {
 		if (rx_status & RxDError) {	/* Error, update stats. */
 			unsigned char rx_error = rx_status >> 16;
@@ -1397,6 +1413,12 @@ static int boomerang_rx(struct net_devic
 			dev->stats.rx_packets++;
 		}
--
-	while (!list_empty(&root_corkscrew_dev)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&root_corkscrew_dev)) {
 		struct net_device *dev;
 		struct corkscrew_private *vp;
 
@@ -1579,6 +1606,12 @@ void cleanup_module(void)
 		unregister_netdev(dev);
--
 	while(cleared != ready) {
 		resp = (struct resp_desc *)(base + cleared);
 		count = resp->numDesc + 1;
@@ -530,6 +535,12 @@ typhoon_process_response(struct typhoon
 
 cleanup:
--
 	while (numSections--) {
 		if (remaining < sizeof(struct typhoon_section_header))
 			goto invalid_fw;
@@ -1321,6 +1337,12 @@ typhoon_request_firmware(struct typhoon
 
 		image_data += section_len;
--
 		while(section_len) {
 			len = min_t(u32, section_len, PAGE_SIZE);
 
@@ -1443,6 +1470,12 @@ typhoon_download_firmware(struct typhoon
 			image_data += len;
 			load_addr += len;
--
 	while(lastRead != le32_to_cpu(*index)) {
 		tx = (struct tx_desc *) (txRing->ringBase + lastRead);
 		type = tx->flags & TYPHOON_TYPE_MASK;
@@ -1540,6 +1578,12 @@ typhoon_clean_tx(struct typhoon *tp, str
 
 		tx->flags = 0;
--
 	while (mask) {
 		/* low MDC, prepare MDO */
 		miir &= ~(MASK_MIIR_MII_MDC + MASK_MIIR_MII_MDO);
@@ -752,6 +757,12 @@ static ulong m80x_send_cmd_to_phy(void _
 		mask >>= 1;
 		if (mask == 0x2 && opcode == OP_READ)
--
 	while (mask) {
 		/* low MDC */
 		miir &= ~MASK_MIIR_MII_MDC;
@@ -786,6 +802,12 @@ static int mdio_read(struct net_device *
 
 		/* next */
--
 	while (mask) {
 		/* low MDC, prepare MDO */
 		miir &= ~(MASK_MIIR_MII_MDC + MASK_MIIR_MII_MDO);
@@ -820,6 +847,12 @@ static void mdio_write(struct net_device
 
 		/* next */
--
 	while (--delay) {
 		ioread32(ioaddr + BCR);
 		rmb();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (status) {
 		int fill_level;
 		writel(status, NETX_PFIFO_XPEC_ISR(priv->id));
@@ -202,6 +207,12 @@ netx_eth_interrupt(int irq, void *dev_id
 			mii_check_media(&priv->mii, netif_msg_link(priv), 1);
 
--
 	while (count < limit && !(descptr->status & DSC_OWNER_MAC)) {
 		/* Read the descriptor status */
 		err = descptr->status;
@@ -586,6 +591,12 @@ next_descr:
 		descptr->status = DSC_OWNER_MAC;
 		descptr = descptr->vndescp;
--
 	while (entry != cur_entry) {
 		txbd = &ether->tdesc->desclist[ether->finish_tx];
 
@@ -692,6 +697,12 @@ static irqreturn_t w90p910_tx_interrupt(
 
 		entry = ether->tdesc_phys +
--
 	while (!skb_queue_empty(q)) {
 		struct skb_data		*entry;
 		struct urb		*urb;
@@ -626,6 +631,12 @@ found:
 			count++;
 		usb_put_urb(urb);
--
 	while (!skb_queue_empty(&dev->rxq)
 		&& !skb_queue_empty(&dev->txq)
 		&& !skb_queue_empty(&dev->done)) {
@@ -667,6 +683,12 @@ static void usbnet_terminate_urbs(struct
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			netif_dbg(dev, ifdown, dev->net,
--
 	while ((skb = skb_dequeue (&dev->done))) {
 		entry = (struct skb_data *) skb->cb;
 		switch (entry->state) {
@@ -1220,6 +1247,12 @@ static void usbnet_bh (unsigned long par
 		default:
 			netdev_dbg(dev->net, "bogus skb state %d\n", entry->state);
--
 		while ((res = usb_get_from_anchor(&dev->deferred))) {
 
 			skb = (struct sk_buff *)res->context;
@@ -1557,6 +1595,12 @@ int usbnet_resume (struct usb_interface
 				dev->net->trans_start = jiffies;
 				__skb_queue_tail(&dev->txq, skb);
--
 	while (likely(skb->len)) {
 		err = parse_hip(skb->data, skb->len, &hh);
 		if (err) {
@@ -887,6 +892,12 @@ static int sierra_net_rx_fixup(struct us
 		if (new_skb)
 			usbnet_skb_return(dev, new_skb);
--
 	} /* while */
 
 	return 0;
diff -u -p a/net/usb/asix.c b/net/usb/asix.c
--- a/net/usb/asix.c
+++ b/net/usb/asix.c
--
 	while (offset + sizeof(u16) <= skb->len) {
 		u16 remaining = 0;
 		unsigned char *data;
@@ -379,6 +384,12 @@ static int asix_rx_fixup_internal(struct
 
 		offset += (rx->size + 1) & 0xfffe;
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (count) {
 		switch (odev->rx_parse_state) {
 		case WAIT_IP:
 			/* waiting for IP header. */
@@ -985,6 +990,12 @@ static void packetizeRx(struct hso_net *
 			count--;
--
 	while (serial->rx_urb_filled[serial->curr_rx_urb_idx]) {
 		curr_urb = serial->rx_urb[serial->curr_rx_urb_idx];
 		count = put_rxbuf_data(curr_urb, serial);
@@ -1181,6 +1197,12 @@ static void put_rxbuf_data_and_resubmit_
 				serial->curr_rx_urb_idx = 0;
 			hso_resubmit_rx_bulk_urb(serial, curr_urb);
--
-		while (write_length_remaining) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (write_length_remaining) {
 			if (test_bit(TTY_THROTTLED, &tty->flags)) {
 				tty_kref_put(tty);
 				return -1;
@@ -2073,6 +2100,12 @@ static int put_rxbuf_data(struct urb *ur
 			serial->curr_rx_urb_offset += curr_write_len;
--
 	while (count--) {
 		if (buf->len < sizeof(*packet)) {
 			netif_err(dev, ifup, dev->net, "Packet too short\n");
@@ -235,7 +240,13 @@ static int vl600_rx_fixup(struct usbnet
 
 			return 1;
--
 		while (count--) {
 			/* rx not enabled: save the raw bytes and never
 			 * trigger any netif_rx. The received bytes are flushed
@@ -573,6 +578,12 @@ int sirdev_receive(struct sir_dev *dev,
 			/* What should we do when the buffer is full? */
 			if (unlikely(dev->rx_buff.len == dev->rx_buff.truesize))
--
 	while ((status = inb(iobase+FS_FO)) & FS_FO_FSFDR) {
 		st_fifo->entries[st_fifo->tail].status = status;
 		
@@ -812,8 +817,19 @@ static int w83977af_dma_receive_complete
 		
 		st_fifo->tail++;
--
 	while (st_fifo->len) {
 		/* Get first entry */
 		status = st_fifo->entries[st_fifo->head].status;
@@ -890,6 +906,12 @@ static int w83977af_dma_receive_complete
 			skb->protocol = htons(ETH_P_IRDA);
 			netif_rx(skb);
--
 		while (lsr & LSR_FIFOE) {
 			data = STRBR;
 			if (lsr & (LSR_OE | LSR_PE | LSR_FE | LSR_BI)) {
@@ -288,6 +293,12 @@ static irqreturn_t pxa_irda_sir_irq(int
 						  &si->rx_buff, data);
 			}
--
-	    	while ((si->tx_buff.len) && (STLSR & LSR_TDRQ)) {
+	    	unsigned long long delta = (cpu / khz / HZ) * 2;
+	    	unsigned long long _start = 0;
+	    	unsigned long long _cur = 0;
+	    	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((si->tx_buff.len) && (STLSR & LSR_TDRQ)) {
 	    		STTHR = *si->tx_buff.data++;
 			si->tx_buff.len -= 1;
-	    	}
+			if (_cur < timeout) {
+	    		rdstcll(_cur);
--
 	while (!(UART_GET_LSR(port) & THRE)) {
 		cpu_relax();
 		continue;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (address->cfg_base) {
 		cfg_base = address->cfg_base;
 
@@ -2176,6 +2181,12 @@ static int __init smsc_ircc_look_for_chi
 					found++;
 		}
--
 	while (chip->devid != devid) {
 
 		chip++;
 
 		if (chip->name == NULL)
 			return NULL;
--
-	while (!(ptxd->flags & AU_OWN) && (aup->tx_tail != aup->tx_head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(ptxd->flags & AU_OWN) && (aup->tx_tail != aup->tx_head)) {
 		update_tx_stats(dev, ptxd->flags, 
 				ptxd->count_1<<8 | ptxd->count_0);
 		ptxd->count_0 = 0;
@@ -451,6 +456,12 @@ static void au1k_tx_ack(struct net_devic
 			aup->tx_full = 0;
--
 	while (!(flags & AU_OWN))  {
 		pDB = aup->rx_db_inuse[aup->rx_head];
 		count = prxd->count_1<<8 | prxd->count_0;
@@ -618,6 +634,12 @@ static int au1k_irda_rx(struct net_devic
 		prxd = aup->rx_ring[aup->rx_head];
 		flags = prxd->flags;
--
 	while ((status = inb(iobase+FRM_ST)) & FRM_ST_VLD) {
 		/* We must empty the status FIFO no matter what */
 		len = inb(iobase+RFLFL) | ((inb(iobase+RFLFH) & 0x1f) << 8);
@@ -1793,6 +1798,12 @@ static int nsc_ircc_dma_receive_complete
 		st_fifo->pending_bytes += len;
 		st_fifo->tail++;
--
 	while (st_fifo->len > 0) {
diff -u -p a/net/irda/donauboe.c b/net/irda/donauboe.c
--- a/net/irda/donauboe.c
+++ b/net/irda/donauboe.c
@@ -893,21 +893,43 @@ toshoboe_probe (struct toshoboe_cb *self
 
--
-      while (toshoboe_numvalidrcvs (self) != n)
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (toshoboe_numvalidrcvs (self) != n)
         {
           if (i > 4800)
               return toshoboe_probefail (self, "filter test");
           udelay ((9600*(TT_LEN+16))/self->speed);
           i++;
--
-      while ((toshoboe_numrcvs(self) != self->int_rx) || (self->int_tx != n))
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while ((toshoboe_numrcvs(self) != self->int_rx) || (self->int_tx != n))
         {
           if (i > 4800)
               return toshoboe_probefail (self, "interrupt test");
           udelay ((9600*(TT_LEN+16))/self->speed);
           i++;
--
-          while (self->ring->tx[txpc].control & OBOE_CTL_TX_HW_OWNS)
+          unsigned long long delta = (cpu / khz / HZ) * 2;
+          unsigned long long _start = 0;
+          unsigned long long _cur = 0;
+            unsigned long long timeout;
+            timeout = rdstcll(start) + delta;
+            while (self->ring->tx[txpc].control & OBOE_CTL_TX_HW_OWNS)
             {
               txp = txpc;
               txpc++;
@@ -1196,6 +1223,12 @@ toshoboe_interrupt (int irq, void *dev_i
               self->netdev->stats.tx_packets++;
--
-      while (!(self->ring->rx[self->rxs].control & OBOE_CTL_RX_HW_OWNS))
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (!(self->ring->rx[self->rxs].control & OBOE_CTL_RX_HW_OWNS))
         {
           int len = self->ring->rx[self->rxs].len;
           skb = NULL;
@@ -1313,6 +1351,12 @@ dumpbufs(self->rx_bufs[self->rxs],len,'<
           if (skb)
--
 	while (status & UTSR0_EIF) {
 		int stat, data;
 
@@ -386,6 +391,12 @@ static void sa1100_irda_hpsir_irq(struct
 			async_unwrap_char(dev, &dev->stats, &si->rx_buff, data);
 
--
         while (ipddp_route_list) {
                 p = ipddp_route_list->next;
                 kfree(ipddp_route_list);
                 ipddp_route_list = p;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
--
         while(length--)
         {
                 outb(ltf->data[i], ioaddr);
                 i++;
-        }
+                if (_cur < timeout) {
--
                 while(inb(ioaddr+TANG_CARD_STATUS)&TANG_RX_READY)
                 {
 			outb(0, ioaddr+COPS_CLEAR_INT);	/* Clear interrupt. */
                 	cops_rx(dev);          	/* Kick out packets waiting. */
 			schedule();
+			if (_cur < timeout) {
--
-	while (tq->tx_ring.next2comp != eop_idx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tq->tx_ring.next2comp != eop_idx) {
 		vmxnet3_unmap_tx_buf(tq->buf_info + tq->tx_ring.next2comp,
 				     pdev);
 
@@ -360,6 +365,12 @@ vmxnet3_unmap_pkt(u32 eop_idx, struct vm
 		 */
--
-	while (VMXNET3_TCD_GET_GEN(&gdesc->tcd) == tq->comp_ring.gen) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (VMXNET3_TCD_GET_GEN(&gdesc->tcd) == tq->comp_ring.gen) {
 		completed += vmxnet3_unmap_pkt(VMXNET3_TCD_GET_TXIDX(
 					       &gdesc->tcd), tq, adapter->pdev,
 					       adapter);
 
 		vmxnet3_comp_ring_adv_next2proc(&tq->comp_ring);
--
 	while (tq->tx_ring.next2comp != tq->tx_ring.next2fill) {
 		struct vmxnet3_tx_buf_info *tbi;
 
@@ -415,6 +442,12 @@ vmxnet3_tq_cleanup(struct vmxnet3_tx_que
 			tbi->skb = NULL;
 		}
--
 	while (len) {
 		u32 buf_size;
 
@@ -743,6 +781,12 @@ vmxnet3_map_pkt(struct sk_buff *skb, str
 
 		len -= buf_size;
--
-		while (num_to_alloc) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (num_to_alloc) {
 			vmxnet3_getRxDesc(rxd, &ring->base[ring->next2fill].rxd,
 					  &rxCmdDesc);
 			BUG_ON(!rxd->addr);
@@ -1304,6 +1353,12 @@ rcd_done:
 			rxd->gen = ring->gen;
--
-	while (vectors >= vector_threshold) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (vectors >= vector_threshold) {
 		err = pci_enable_msix(adapter->pdev, adapter->intr.msix_entries,
 				      vectors);
 		if (!err) {
@@ -2722,6 +2782,12 @@ vmxnet3_acquire_msix_vectors(struct vmxn
 			       " %d instead\n", vectors, adapter->netdev->name,
--
 	while (myFirstTxDesc != myNextTxDesc) {
 		dev_kfree_skb(myFirstTxDesc->skb);
 		myFirstTxDesc->skb = 0;
 		myFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((*R_DMA_CH1_FIRST != virt_to_phys(myNextRxDesc)) &&
 		       (myNextRxDesc != myLastRxDesc)) {
 			/* Take out the buffer and give it to the OS, then
@@ -1166,10 +1182,21 @@ e100rxtx_interrupt(int irq, void *dev_id
 
 			/* now, we might have gotten another packet
--
 	while (virt_to_phys(myFirstTxDesc) != *R_DMA_CH0_FIRST &&
 	       (netif_queue_stopped(dev) || myFirstTxDesc != myNextTxDesc)) {
 		dev->stats.tx_bytes += myFirstTxDesc->skb->len;
@@ -1182,6 +1209,12 @@ e100rxtx_interrupt(int irq, void *dev_id
 		myFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);
                 /* Wake up queue. */
--
 	while (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) { 
 		schedule();		
 		if (time_after(jiffies, t + 40 * HZ)) {
 			printk(KERN_ERR "%s: 3COM 3C359 Velocity XL  card not responding to global reset.\n", dev->name);
 			return -ENODEV;
 		}
--
 	while ( !(readw(xl_mmio + MMIO_INTSTATUS_AUTO) & INTSTAT_SRB) ) { 
 		schedule();		
 		if (time_after(jiffies, t + 15 * HZ)) {
 			printk(KERN_ERR "3COM 3C359 Velocity XL  card not responding.\n");
 			return -ENODEV; 
 		}
--
 	while (xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].framestatus & (RXUPDCOMPLETE | RXUPDFULL) ) { /* Descriptor to process */
 
 		if (xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].framestatus & RXUPDFULL ) { /* UpdFull, Multiple Descriptors used for the frame */
@@ -942,9 +969,20 @@ static void xl_rx(struct net_device *dev
 
 			temp_ring_loc = xl_priv->rx_ring_tail ; 
--
 			while (xl_priv->xl_rx_ring[temp_ring_loc].framestatus & RXUPDFULL ) {
 				temp_ring_loc++ ; 
 				temp_ring_loc &= (XL_RX_RING_SIZE-1) ; 
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while (xl_priv->rx_ring_tail != temp_ring_loc) { 
 				copy_len = le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfraglen) & 0x7FFF;
 				frame_length -= copy_len ;  
@@ -972,6 +1015,12 @@ static void xl_rx(struct net_device *dev
 							  copy_len);
 				pci_dma_sync_single_for_device(xl_priv->pdev,le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfragaddr),xl_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE);
--
 	} /* while packet to do */
 
 	/* Clear the updComplete interrupt */
@@ -1123,10 +1178,21 @@ static irqreturn_t xl_interrupt(int irq,
 
 			if (intstatus & TXUNDERRUN) { /* Issue DnReset command */
--
 				while (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) { /* Wait for command to run */
 					/* !!! FIX-ME !!!! 
 					Must put a timeout check here ! */
 					/* Empty Loop */
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (xl_priv->xl_tx_ring[xl_priv->tx_ring_tail].framestartheader & TXDNCOMPLETE ) { 
 		txd = &(xl_priv->xl_tx_ring[xl_priv->tx_ring_tail]) ;
 		pci_unmap_single(xl_priv->pdev, le32_to_cpu(txd->buffer), xl_priv->tx_ring_skb[xl_priv->tx_ring_tail]->len, PCI_DMA_TODEVICE);
@@ -1277,6 +1348,12 @@ static void xl_dn_comp(struct net_device
 		xl_priv->tx_ring_tail++ ; 
 		xl_priv->tx_ring_tail &= (XL_TX_RING_SIZE - 1) ; 
--
 	while (!((readw(streamer_mmio + SISR)) & SISR_SRB_REPLY)) {
 		msleep_interruptible(100);
 		if (time_after(jiffies, t + 40 * HZ)) {
@@ -520,6 +525,12 @@ static int streamer_reset(struct net_dev
 				dev_kfree_skb(skb);
 			return -1;
--
 	while (rx_desc->status & 0x01000000) {	/* While processed descriptors are available */
 		if (rx_ring_last_received != streamer_priv->rx_ring_last_received) 
 		{
@@ -1016,6 +1032,12 @@ static void streamer_rx(struct net_devic
 
 		/* try the next one */
--
 				while(streamer_priv->streamer_tx_ring[(streamer_priv->tx_ring_last_status + 1) & (STREAMER_TX_RING_SIZE - 1)].status) {
 				streamer_priv->tx_ring_last_status = (streamer_priv->tx_ring_last_status + 1) & (STREAMER_TX_RING_SIZE - 1);
 				streamer_priv->free_tx_ring_entries++;
@@ -1063,6 +1090,12 @@ static irqreturn_t streamer_interrupt(in
 				streamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].rsvd1 = 0;
 				streamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].rsvd2 = 0;
--
 			while (i < buffer_len) {
 				rx_word=ntohs(readw(streamer_mmio+LAPDINC));
 				frame_data[i]=rx_word >> 8;
 				frame_data[i+1]=rx_word & 0xff;
 				i += 2;
+				if (_cur < timeout) {
--
         while(weight)
         {
                 branch = ROOT;
@@ -798,6 +803,12 @@ static int smctr_decode_firmware(struct
                         buff    = 0;
                         shift   = 12;
--
 	while((readl(olympic_mmio+BCTL)) & BCTL_SOFTRESET) {
 		schedule();		
 		if(time_after(jiffies, t + 40*HZ)) {
 			printk(KERN_ERR "IBM PCI tokenring card not responding.\n");
 			return -ENODEV;
 		}
--
 		while (!(readl(olympic_mmio+CLKCTL) & CLKCTL_PAUSE)) {
 			schedule() ; 
 			if(time_after(jiffies, t + 2*HZ)) {
 				printk(KERN_ERR "IBM Cardbus tokenring adapter not responsing.\n") ; 
 				return -ENODEV;
 			}
--
 	while(!((readl(olympic_mmio+SISR_RR)) & SISR_SRB_REPLY)) {
 		schedule();		
 		if(time_after(jiffies, t + 15*HZ)) {
 			printk(KERN_ERR "IBM PCI tokenring card not responding.\n");
 			return -ENODEV;
 		}
--
-	while (rx_status->status_buffercnt) { 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (rx_status->status_buffercnt) { 
                 u32 l_status_buffercnt;
 
 		olympic_priv->rx_status_last_received++ ;
@@ -879,6 +917,12 @@ static void olympic_rx(struct net_device
 		rx_status = &(olympic_priv->olympic_rx_status_ring[(olympic_priv->rx_status_last_received+1) & (OLYMPIC_RX_RING_SIZE -1) ]);
--
 	} /* while */
 
 }
@@ -969,6 +1013,11 @@ static irqreturn_t olympic_interrupt(int
 		/* We shouldn't ever miss the Tx interrupt, but the you never know, hence the loop to ensure
 		   we get all tx completions. */
--
 			while(olympic_priv->olympic_tx_status_ring[(olympic_priv->tx_ring_last_status + 1) & (OLYMPIC_TX_RING_SIZE-1)].status) { 
 				olympic_priv->tx_ring_last_status++;
 				olympic_priv->tx_ring_last_status &= (OLYMPIC_TX_RING_SIZE-1);
@@ -981,6 +1030,12 @@ static irqreturn_t olympic_interrupt(int
 				dev_kfree_skb_irq(olympic_priv->tx_ring_skb[olympic_priv->tx_ring_last_status]);
 				olympic_priv->olympic_tx_ring[olympic_priv->tx_ring_last_status].buffer=cpu_to_le32(0xdeadbeef);
--
 		while (!readb(ti->mmio + ACA_OFFSET + ACA_RW + RRR_EVEN)){
 			if (!time_after(jiffies, timeout)) continue;
 			DPRINTK( "Hardware timeout during initialization.\n");
 			iounmap(t_mmio);
 			return -ENODEV;
+			if (_cur < timeout) {
--
 	while(1) {
 		if (ti->page_mask) {
 			dhb_page=(dhb >> 8) & ti->page_mask;
@@ -1655,6 +1671,12 @@ static void tr_tx(struct net_device *dev
 		}
 		memcpy_toio(dhbuf, &ti->current_skb->data[src_offset], src_len);
--
 	while (rnet->tx_cnt && (rnet->ack_slot != slot)) {
 		/* dma unmap single */
 		dev_kfree_skb_irq(rnet->tx_skb[rnet->ack_slot]);
@@ -283,6 +288,12 @@ static void rionet_outb_msg_event(struct
 		++rnet->ack_slot;
 		rnet->ack_slot &= (RIONET_TX_RING_SIZE - 1);
--
 	while (timediff >= 500000)
 		timediff -= 1000000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while (timediff >= bdus2) {
 		timediff -= bc->baud_us;
 		bc->modem.ser12.pll_time += bc->baud_us;
@@ -249,6 +254,12 @@ static __inline__ void ser12_rx(struct n
 		}
 		/* add a one bit */
--
 	while (count) {
 		count--;
 		if (fp && *fp++) {
@@ -482,6 +487,12 @@ static void sixpack_receive_buf(struct t
 				sp->dev->stats.rx_errors++;
 			continue;
--
 	while (first) {
 		info = first;
 
@@ -302,6 +307,12 @@ static void __exit dmascc_exit(void)
 		/* Free memory */
 		first = info->next;
--
 	while ((is = read_scc(&info->priv[0], R3)) && i--) {
 		if (is & CHARxIP) {
 			rx_isr(&info->priv[0]);
@@ -1113,6 +1129,12 @@ static inline void z8530_isr(struct scc_
 		}
 		write_scc(&info->priv[0], R0, RES_H_IUS);
--
 		while ((is = ~inb(card_base + TWIN_INT_REG)) &
 		       TWIN_INT_MSK) {
 			if (is & TWIN_SCC_MSK) {
@@ -1153,6 +1180,12 @@ static irqreturn_t scc_isr(int irq, void
 				inb(card_base + TWIN_CLR_TMR2);
 				tm_isr(&info->priv[1]);
--
-		while (read_scc(priv, R0) & Rx_CH_AV) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (read_scc(priv, R0) & Rx_CH_AV) {
 			rc = read_scc(priv, R1);
 			if (priv->rx_ptr < BUF_SIZE)
 				priv->rx_buf[priv->rx_head][priv->
@@ -1182,6 +1220,12 @@ static void rx_isr(struct scc_priv *priv
 				read_scc_data(priv);
--
 	while (priv->rx_count) {
 		spin_unlock_irqrestore(&priv->ring_lock, flags);
 		cb = priv->rx_len[i];
@@ -1285,6 +1334,12 @@ static void rx_bh(struct work_struct *ug
 		/* Move tail */
 		priv->rx_tail = i = (i + 1) % NUM_RX_BUF;
--
 	while ((read_scc(priv, R0) & Tx_BUF_EMP) && p < priv->tx_len[i]) {
 		write_scc_data(priv, priv->tx_buf[i][p++], 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (!list_empty(&bpq_devices)) {
 		bpq = list_entry(bpq_devices.next, struct bpqdev, bpq_list);
 		bpq_free_device(bpq->axdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!hdlcdrv_hbuf_empty(&s->hdlcrx.hbuf)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (!hdlcdrv_hbuf_empty(&s->hdlcrx.hbuf)) {
 		word = hdlcdrv_hbuf_get(&s->hdlcrx.hbuf);	
 
 #ifdef HDLCDRV_DEBUG
@@ -215,6 +220,12 @@ void hdlcdrv_receiver(struct net_device
 		}
--
 	while (p) {
 		if (p->bitrate == bitrate) {
 			memcpy(p->bits, bits, YAM_FPGA_SIZE);
 			goto out;
 		}
 		p = p->next;
--
 	while (p) {
 		if (p->bitrate == bitrate)
 			return p->bits;
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (yam_data) {
 		p = yam_data;
 		yam_data = yam_data->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count--) {
 		if (fp != NULL && *fp++) {
 			if (!test_and_set_bit(AXF_ERROR, &ax->flags))
@@ -948,6 +953,12 @@ static void mkiss_receive_buf(struct tty
 		}
 
--
 	while (time_before(jiffies, tstart + HZ/3)) {
 		if (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)
 			goto epptimeout;
@@ -891,6 +896,12 @@ static int epp_open(struct net_device *d
 		if (pp->ops->epp_read_data(pp, tmp, 128, 0) != 128)
 			goto epptimeout;
--
-		while (sendcount) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (sendcount) {
 			rio_write_config_32(rdev,
 					  TSI578_SP_CS_TX(portnum), 0x40fc8000);
 			checkcount = 3;
-			while (checkcount--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (checkcount--) {
 				udelay(50);
 				rio_read_config_32(rdev,
 					rdev->phys_efptr +
@@ -263,9 +273,21 @@ tsi57x_em_handler(struct rio_dev *rdev,
 					&regval);
--
-	while (result != port->host_deviceid) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (result != port->host_deviceid) {
 		if (wait_ms != 0 && tcnt == wait_ms) {
 			pr_debug("RIO: timeout when locking device %x:%x\n",
 				destid, hopcount);
@@ -605,6 +610,12 @@ rio_lock_device(struct rio_mport *port,
 		rio_mport_read_config_32(port, destid,
--
 	while ((tmp = rio_get_host_deviceid_lock(port, hopcount))
 	       < port->host_deviceid) {
 		/* Delay a bit */
@@ -797,6 +813,12 @@ static int __devinit rio_enum_peer(struc
 					  hopcount,
 					  RIO_HOST_DID_LOCK_CSR,
--
 		while (!rio_enum_complete(mport)) {
 			mdelay(1);
 			if (enum_timeout_flag) {
 				del_timer_sync(&rio_enum_timer);
 				goto timeout;
 			}
--
 	while (id->vid || id->asm_vid) {
 		if (((id->vid == RIO_ANY_ID) || (id->vid == rdev->vid)) &&
 		    ((id->did == RIO_ANY_ID) || (id->did == rdev->did)) &&
@@ -39,6 +44,12 @@ static const struct rio_device_id *rio_m
 			|| (id->asm_did == rdev->asm_did)))
 			return id;
--
-	while (ext_ftr_ptr)  {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ext_ftr_ptr)  {
 		if (local)
 			rio_local_read_config_32(port, ext_ftr_ptr,
 						 &ftr_header);
@@ -441,6 +446,12 @@ rio_mport_get_physefb(struct rio_mport *
 
--
 	while (n && (n != &rio_devices)) {
 		rdev = rio_dev_g(n);
 		if (rdev->comp_tag == comp_tag)
 			goto exit;
 		n = n->next;
+		if (_cur < timeout) {
--
-	while (rio_mport_read_config_32(mport, destid, hopcount,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rio_mport_read_config_32(mport, destid, hopcount,
 					RIO_DEV_ID_CAR, &tmp)) {
 		i++;
 		if (i == RIO_MAX_CHK_RETRY)
 			return -EIO;
 		mdelay(1);
--
-	while (checkcount--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (checkcount--) {
 		udelay(50);
 		rio_read_config_32(rdev,
 			rdev->phys_efptr + RIO_PORT_N_MNT_RSP_CSR(pnum),
@@ -618,6 +656,12 @@ rio_get_input_status(struct rio_dev *rde
 			*lnkresp = regval;
--
 	while (n && (n != &rio_devices)) {
 		rdev = rio_dev_g(n);
 		if ((vid == RIO_ANY_ID || rdev->vid == vid) &&
@@ -989,6 +1038,12 @@ struct rio_dev *rio_get_asm(u16 vid, u16
 		    (asm_did == RIO_ANY_ID || rdev->asm_did == asm_did))
 			goto exit;
--
 	while ((ch_stat = ioread32(priv->regs +
 		TSI721_DMAC_STS(TSI721_DMACH_MAINT))) & TSI721_DMAC_STS_RUN) {
 		udelay(1);
@@ -152,6 +157,12 @@ static int tsi721_maint_dma(struct tsi72
 			err = -EIO;
 			goto err_out;
--
-	while (kfifo_out_spinlocked(&priv->pw_fifo, (unsigned char *)msg_buffer,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (kfifo_out_spinlocked(&priv->pw_fifo, (unsigned char *)msg_buffer,
 			 TSI721_RIO_PW_MSG_SIZE, &priv->pw_fifo_lock)) {
 		/* Process one message */
 #ifdef DEBUG_PW
@@ -311,6 +327,12 @@ static void tsi721_pw_dpc(struct work_st
 #endif
--
-	while (wr_ptr != rd_ptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (wr_ptr != rd_ptr) {
 		idb_entry = (u64 *)(priv->idb_base +
 					(TSI721_IDB_ENTRY_SIZE * rd_ptr));
 		rd_ptr++;
@@ -442,6 +469,12 @@ static void tsi721_db_dpc(struct work_st
 
--
 		while (sts_ptr[j]) {
 			for (i = 0; i < 8 && sts_ptr[j]; i++, j++) {
 				prev_ptr = last_ptr;
@@ -1268,6 +1306,12 @@ static void tsi721_omsg_handler(struct t
 			++srd_ptr;
 			srd_ptr %= priv->omsg_ring[ch].sts_size;
--
 	while (maxspin) {
 		if ((msmsdcc_readl(host, MMCISTATUS) & mask))
 			return 0;
 		udelay(1);
 		--maxspin;
+		if (_cur < timeout) {
--
 		while (!(at91_mci_read(host, AT91_MCI_SR) & AT91_MCI_CMDRDY)) {
 			/* spin */
 			pr_debug("Clearing: SR = %08X\n", at91_mci_read(host, AT91_MCI_SR));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((fifo = fifo_count(host))) {
 		if (!host->pio_bytes) {
 			res = get_data_buffer(host, &host->pio_bytes,
@@ -416,11 +421,28 @@ static void do_pio_read(struct s3cmci_ho
 			u32 data = readl(from_ptr);
 			u8 *p = (u8 *)host->pio_ptr;
--
 			while (n--) {
 				*p++ = data;
 				data >>= 8;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
-	while (readl(host->base + S3C2410_SDIDSTA) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (readl(host->base + S3C2410_SDIDSTA) &
 	       (S3C2410_SDIDSTA_TXDATAON | S3C2410_SDIDSTA_RXDATAON)) {
 
 		dbg(host, dbg_err,
@@ -1001,6 +1028,12 @@ static int s3cmci_setup_data(struct s3cm
 			dbg_dumpregs(host, "DRF");
--
 	while (restarts < maxloops) {
 		OMAP_MMC_WRITE(host, STAT, 0xFFFF);
 		OMAP_MMC_WRITE(host, CMD, (3 << 12) | (1 << 7));
 
 		passes = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (passes < timeout) {
 			stat = OMAP_MMC_READ(host, STAT);
 			if (stat & OMAP_MMC_STAT_END_OF_CMD)
 				goto out;
 			udelay(1);
 			passes++;
--
 		while (len) {
 			data = sdricoh_readl(host, R230_DATA);
 			size = min(len, 4);
 			len -= size;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
--
 			while (size) {
 				*buf = data & 0xFF;
 				buf++;
 				data >>= 8;
 				size--;
+				if (_cur < timeout) {
--
 		while (len) {
 			size = min(len, 4);
 			len -= size;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
--
 			while (size) {
 				data >>= 8;
 				data |= (u32)*buf << 24;
 				buf++;
 				size--;
+				if (_cur < timeout) {
--
-	while ((pci_dev =
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((pci_dev =
 		pci_get_device(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C476,
 			       pci_dev))) {
 		/* try to init the device */
@@ -490,6 +539,12 @@ static int sdricoh_pcmcia_probe(struct p
 			return 0;
--
 	while (i--) {
 		irq = platform_get_irq(pdev, i);
 		free_irq(irq, host);
-	}
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 		while (register_count--) {
 			add_offloaded_reg(vub300, &vub300->resp.irq.reg[ri]);
 			ri += 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (register_count--) {
 			add_offloaded_reg(vub300, &vub300->resp.irq.reg[ri]);
 			ri += 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (I--) {
 			unsigned int func_num = 0;
 			vub300->sdio_register[i].func_num = *data++;
@@ -1341,6 +1368,12 @@ static void __download_offload_pseudocod
 			vub300->sdio_register[i].activate = 1;
 			vub300->sdio_register[i].prepared = 0;
--
 		while (register_count--) {
 			add_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);
 			ri += 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (register_count--) {
 			add_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);
 			ri += 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (register_count--) {
 			add_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);
 			ri += 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (rotator & 0x8000) {
 			bitshift++;
 			rotator <<= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (status & 0x80) {
 		status <<= 1;
 		bitshift--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (time_before(jiffies, timeout)) {
 		cmd_status = mci_readl(host, CMD);
 		if (!(cmd_status & SDMMC_CMD_START))
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-		while (present != slot->last_detect_state) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (present != slot->last_detect_state) {
 			dev_dbg(&slot->mmc->class_dev, "card %s\n",
 				present ? "inserted" : "removed");
 
@@ -1645,6 +1661,12 @@ static void dw_mci_work_routine_card(str
 				host->pdata->setpower(slot->id, 0);
--
 	while (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_EMPTY)) {
 		/*
 		 * The size field in the FSR is broken so we have to
@@ -465,6 +470,12 @@ static void wbsd_empty_fifo(struct wbsd_
 				buffer = wbsd_sg_to_buffer(host);
 			}
--
 	while (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_FULL)) {
 		/*
 		 * The size field in the FSR is broken so we have to
@@ -528,6 +544,12 @@ static void wbsd_fill_fifo(struct wbsd_h
 				buffer = wbsd_sg_to_buffer(host);
 			}
--
 	while (host->max_clk / div > clock) {
 		/*
 		 * On CNS3xxx divider grows linearly up to 4, and then
@@ -50,6 +55,12 @@ static void sdhci_cns3xxx_set_clock(stru
 			div *= 2;
 		else
--
-	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
 		if (timeout == 0) {
 			pr_err("%s: Reset 0x%x never completed.\n",
 				mmc_hostname(host->mmc), (int)mask);
@@ -207,6 +212,12 @@ static void sdhci_reset(struct sdhci_hos
 		}
--
 	while (blksize) {
 		if (!sg_miter_next(&host->sg_miter))
 			BUG();
@@ -314,6 +330,11 @@ static void sdhci_read_block_pio(struct
 
 		buf = host->sg_miter.addr;
--
 		while (len) {
 			if (chunk == 0) {
 				scratch = sdhci_readl(host, SDHCI_BUFFER);
@@ -326,6 +347,18 @@ static void sdhci_read_block_pio(struct
 			scratch >>= 8;
 			chunk--;
--
 	while (blksize) {
 		if (!sg_miter_next(&host->sg_miter))
 			BUG();
@@ -360,6 +398,11 @@ static void sdhci_write_block_pio(struct
 
 		buf = host->sg_miter.addr;
--
 		while (len) {
 			scratch |= (u32)*buf << (chunk * 8);
 
@@ -372,6 +415,18 @@ static void sdhci_write_block_pio(struct
 				chunk = 0;
 				scratch = 0;
--
-	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
 		if (timeout == 0) {
 			pr_err("%s: Controller never released "
 				"inhibit bit(s).\n", mmc_hostname(host->mmc));
@@ -981,6 +1041,12 @@ static void sdhci_send_command(struct sd
 		}
--
-	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
 		& SDHCI_CLOCK_INT_STABLE)) {
 		if (timeout == 0) {
 			pr_err("%s: Internal clock never "
@@ -1151,6 +1222,12 @@ static void sdhci_set_clock(struct sdhci
 		}
--
 	while (t_size) {
 		cnt = sg[host->sg_pos].length - host->block_pos;
 		if (!cnt) {
@@ -205,6 +210,12 @@ static void tifm_sd_transfer_data(struct
 
 		t_size -= p_cnt;
--
 	while (t_size) {
 		cnt = sg[host->sg_pos].length - host->block_pos;
 		if (!cnt) {
@@ -257,6 +273,12 @@ static void tifm_sd_bounce_block(struct
 
 		t_size -= p_cnt;
--
 		while (delay--) {
 			reg = readw(host->base + MMC_REG_STATUS);
 			if (reg & STATUS_CARD_BUS_CLK_RUN) {
@@ -157,6 +162,12 @@ static int imxmci_start_clock(struct imx
 
 			if (test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events))
--
-	while (!(*pstat & stat_mask)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(*pstat & stat_mask)) {
 		loops += 2;
 		if (loops >= timeout) {
 			dev_dbg(mmc_dev(host->mmc), "busy wait timeout in %s, STATUS = 0x%x (0x%x)\n",
@@ -211,6 +227,12 @@ static int imxmci_busy_wait_for_status(s
 		}
--
 		while ((stat & STATUS_APPL_BUFF_FE) &&
 		       (host->data_cnt < host->dma_size)) {
 			if (burst_len >= host->dma_size - host->data_cnt) {
@@ -619,6 +646,12 @@ static int imxmci_cpu_driven_data(struct
 
 			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data write burst %d STATUS = 0x%x\n",
--
 	while (sg_miter_next(miter)) {
 		buf = miter->addr;
 		i = miter->length / 4;
 		j = i / 8;
 		i = i & 0x7;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (j) {
 			timeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_TXFIFO_WR_REQ);
 			if (unlikely(timeout))
@@ -263,19 +273,42 @@ static bool jz4740_mmc_write_data(struct
 			writel(buf[7], fifo_addr);
 			buf += 8;
--
 			while (i) {
 				writel(*buf, fifo_addr);
 				++buf;
 				--i;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (sg_miter_next(miter)) {
 		buf = miter->addr;
 		i = miter->length;
 		j = i / 32;
 		i = i & 0x1f;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (j) {
 			timeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_RXFIFO_RD_REQ);
 			if (unlikely(timeout))
@@ -321,6 +364,12 @@ static bool jz4740_mmc_read_data(struct
 
 			buf += 8;
--
 	while (!(status & JZ_MMC_STATUS_DATA_FIFO_EMPTY) && --timeout) {
 		d = readl(fifo_addr);
 		status = readl(host->base + JZ_REG_MMC_STATUS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (remainder > func->cur_blksize) {
 			unsigned blocks;
 
@@ -332,6 +337,12 @@ static int sdio_io_rw_ext_helper(struct
 			buf += size;
 			if (incr_addr)
--
 	while (tuple) {
 		victim = tuple;
 		tuple = tuple->next;
 		kfree(victim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (tuple && tuple != func->card->tuples) {
 		victim = tuple;
 		tuple = tuple->next;
 		kfree(victim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (ids->class || ids->vendor || ids->device) {
 			if (sdio_match_one(func, ids))
 				return ids;
 			ids++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (sz) {
 		base = page_address(mem->arr[--i].page);
 		cnt = 1 << mem->arr[i].order;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (sz && cnt) {
 			addr = base + PAGE_SIZE * --cnt;
 			if (last_addr && last_addr + PAGE_SIZE == addr)
@@ -477,9 +487,21 @@ static int mmc_test_map_sg_max_scatter(s
 			sg_set_page(sg, virt_to_page(addr), len, 0);
 			sz -= len;
--
     while (part->FreeTotal < nblocks) {
 	ret = reclaim_block(part);
 	if (ret)
 	    return ret;
+	    if (_cur < timeout) {
+	    rdstcll(_cur);
--
 	while (nr_sects) {
 		uint32_t old_addr = part->VirtualBlockMap[sector];
 		if (old_addr != 0xffffffff) {
@@ -1024,6 +1040,12 @@ static int ftl_discardsect(struct mtd_bl
 		}
 		nr_sects--;
--
 	while (!kthread_should_stop()) {
 		int res;
 
@@ -179,6 +184,12 @@ static int mtd_blktrans_thread(void *arg
 			req = NULL;
 
--
 	while (*size > min_alloc) {
 		kbuf = kmalloc(*size, flags);
 		if (kbuf)
@@ -750,6 +755,12 @@ void *mtd_kmalloc_up_to(const struct mtd
 
 		*size >>= 1;
--
 	while (thisEUN <= nftl->lastEUN ) {
 		unsigned int status, foldmark;
 
@@ -340,6 +345,12 @@ static u16 NFTL_foldchain (struct NFTLre
 		}
 
--
 	while (thisEUN <= nftl->lastEUN && thisEUN != targetEUN) {
 		unsigned int EUNtmp;
 
@@ -473,6 +489,12 @@ static u16 NFTL_foldchain (struct NFTLre
 			nftl->numfreeEUNs++;
 		}
--
 		while (writeEUN <= nftl->lastEUN) {
 			struct nftl_bci bci;
 			size_t retlen;
@@ -593,6 +620,12 @@ static inline u16 NFTL_findwriteunit(str
 
 			/* Skip to next block in chain */
--
-		while (thisEUN < nftl->nb_blocks) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while (thisEUN < nftl->nb_blocks) {
 			if (nftl_read_oob(mtd, (thisEUN * nftl->EraseSize) +
 					  blockofs, 8, &retlen,
 					  (char *)&bci) < 0)
@@ -761,6 +799,12 @@ static int nftl_readblock(struct mtd_blk
 				return 1;
--
 	while (count) {
 		len = min_t(size_t, count, size);
 
@@ -261,6 +266,12 @@ static ssize_t mtd_read(struct file *fil
 			return ret;
 		}
--
 	while (count) {
 		len = min_t(size_t, count, size);
 
@@ -341,6 +357,12 @@ static ssize_t mtd_write(struct file *fi
 			kfree(kbuf);
 			return ret;
--
 		while (header.length) {
 			offset += sizeof(header) + header.length;
 			master->read(master, offset, sizeof(header),
 				     &len, (uint8_t *)&header);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (header.length) {
 			offset += sizeof(header) + header.length;
 			master->read(master, offset, sizeof(header),
 				     &len, (uint8_t *)&header);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (thisEUN < inftl->nb_blocks) {
 		for (block = 0; block < inftl->EraseSize/SECTORSIZE; block ++) {
 			if ((BlockMap[block] != BLOCK_NIL) ||
@@ -314,6 +319,12 @@ static u16 INFTL_foldchain(struct INFTLr
 		}
 
--
 	while (thisEUN < inftl->nb_blocks) {
 		for (block = 0; block < inftl->EraseSize/SECTORSIZE; block++) {
 			if (BlockUsed[block] || BlockDeleted[block])
@@ -696,6 +712,12 @@ static void INFTL_trydeletechain(struct
 		}
 
--
-	while (thisEUN < inftl->nb_blocks) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (thisEUN < inftl->nb_blocks) {
 		if (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +
 				   blockofs, 8, &retlen, (char *)&bci) < 0)
 			status = SECTOR_IGNORE;
@@ -795,7 +822,13 @@ static int INFTL_deleteblock(struct INFT
 			return 1;
--
-	while (thisEUN < inftl->nb_blocks) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (thisEUN < inftl->nb_blocks) {
 		if (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +
 				  blockofs, 8, &retlen, (char *)&bci) < 0)
 			status = SECTOR_IGNORE;
@@ -905,7 +943,13 @@ static int inftl_readblock(struct mtd_bl
 		}
--
 		while ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&
 			(data_setup_in_cycles < nfc->max_data_setup_cycles)) {
 
@@ -450,6 +455,12 @@ static int gpmi_nfc_compute_hardware_tim
 			if (ideal_sample_delay_in_ns < 0)
 				ideal_sample_delay_in_ns = 0;
--
-	while ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&
 			(data_setup_in_cycles < nfc->max_data_setup_cycles)) {
 
 		/* Give a cycle to data setup. */
@@ -602,6 +618,12 @@ static int gpmi_nfc_compute_hardware_tim
 		/* Jam a negative ideal sample delay to zero. */
--
-	while (SAMPLE_IS_NOT_WITHIN_THE_EYE &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (SAMPLE_IS_NOT_WITHIN_THE_EYE &&
 			(data_setup_in_cycles < nfc->max_data_setup_cycles)) {
 		/*
 		 * If control arrives here, the quantized sample delay falls
@@ -696,6 +723,12 @@ static int gpmi_nfc_compute_hardware_tim
 
--
 	while (len) {
 		reg = buf[0] | buf[1] << 8 | buf[2] << 16 | buf[3] << 24;
 		r852_write_reg_dword(dev, R852_DATALINE, reg);
 		buf += 4;
 		len -= 4;
 
--
 	while (len) {
 		u8 oob[16];
 		size_t byte = from & al->bytemask;
@@ -411,6 +416,12 @@ static int alauda_bounce_read(struct mtd
 		buf += cplen;
 		from += cplen;
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		u8 oob[16];
 
 		err = alauda_read_page(mtd, from, buf, oob,
@@ -443,6 +459,12 @@ static int alauda_read(struct mtd_info *
 		buf += mtd->writesize;
--
 	while (len) {
 		u32 page = (to >> al->card->pageshift) & al->pagemask;
 		u8 oob[16] = {	'h', 'e', 'l', 'l', 'o', 0xff, 0xff, 0xff,
@@ -484,6 +511,12 @@ static int alauda_write(struct mtd_info
 		buf += mtd->writesize;
 		to += mtd->writesize;
--
 	while (len) {
 		/* don't erase bad blocks */
 		err = alauda_isbad(mtd, ofs);
@@ -512,6 +550,12 @@ static int __alauda_erase(struct mtd_inf
 
 		ofs += mtd->erasesize;
--
 	while (len && (unsigned long)buf & 7) {
 		*buf++ = readb(io_base);
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (i < len/8) {
 		/*
 		 * Since GCC has no proper constraint (PR 43518)
@@ -65,6 +81,12 @@ static void orion_nand_read_buf(struct m
 
 		asm volatile ("ldrd\t%0, [%1]" : "=&r" (x) : "r" (io_base));
--
 	while (i < len)
diff -u -p a/mtd/nand/nand_base.c b/mtd/nand/nand_base.c
--- a/mtd/nand/nand_base.c
+++ b/mtd/nand/nand_base.c
@@ -2587,7 +2587,12 @@ int nand_erase_nand(struct mtd_info *mtd
 
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (len) {
 		/* Heck if we have a bad block, we do not erase bad blocks! */
 		if (nand_block_checkbad(mtd, ((loff_t) page) <<
 					chip->page_shift, 0, allowbbt)) {
@@ -2655,6 +2660,12 @@ int nand_erase_nand(struct mtd_info *mtd
 				bbt_masked_page = chip->bbt_td->pages[chipnr] &
--
 	while (len--) {
 		crc ^= *p++ << 8;
 		for (i = 0; i < 8; i++)
 			crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {
 			if (time_after(jiffies, timeo)) {
 				printk("_DoC_WaitReady timed out.\n");
@@ -265,6 +270,12 @@ static int _DoC_WaitReady(struct doc_pri
 			}
 			udelay(1);
--
 		while (blocks > maxblocks) {
 			blocks >>= 1;
 			maxblocks = min(32768U, (maxblocks << 1) + psize);
 			mh->UnitSizeFactor--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (totlen) {
 		len = min(totlen, (size_t)(1 << this->bbt_erase_shift));
 		if (marker_len) {
@@ -247,6 +252,12 @@ static int read_bbt(struct mtd_info *mtd
 		}
 		totlen -= len;
--
 		while (flips--) {
 			int pos = random32() % (num * 8);
 			ns->buf.byte[pos / 8] ^= (1 << (pos % 8));
@@ -1425,6 +1430,12 @@ void do_bit_flips(struct nandsim *ns, in
 				"reading from %d ecc: corrected=%u failed=%u\n",
 				pos, ns->regs.row, ns->regs.column + ns->regs.off,
--
 	while (timeout--) {
 		if (readb(FLTRCR(flctl)) & TREND) {
 			writeb(0x0, FLTRCR(flctl));
 			return;
 		}
 		udelay(1);
--
 	while (timeout--) {
 		uint32_t val;
 		/* check FIFO */
@@ -139,6 +155,12 @@ static void wait_rfifo_ready(struct sh_f
 		if (val & 0xFF)
 			return;
--
 	while (timeout--) {
 		/* check FIFO */
 		len = (readl(FLDTCNTR(flctl)) >> 16) & 0xFF;
 		if (len >= 4)
 			return;
 		udelay(1);
--
 	while (timeout--) {
 		size = readl(FLDTCNTR(flctl)) >> 24;
 		if (size & 0xFF)
@@ -204,6 +242,12 @@ static int wait_recfifo_ready(struct sh_
 		}
 
--
 	while (timeout--) {
 		/* check FLECFIFO */
 		len = (readl(FLDTCNTR(flctl)) >> 24) & 0xFF;
 		if (len >= 4)
 			return;
 		udelay(1);
--
 	while (size) {
 		/* Calculate spare buffer number */
 		s = offset / sbsize;
@@ -450,6 +455,12 @@ static void mpc5121_nfc_copy_spare(struc
 		buffer += blksize;
 		offset += blksize;
--
 	while (len) {
 		bsize = min(len, 256);
 		mpc5121_nfc_read_buf(mtd, tmp, bsize);
@@ -522,6 +538,12 @@ static int mpc5121_nfc_verify_buf(struct
 
 		buf += bsize;
--
 	while (nfc_read(mtd, NFC_CONFIG1) & NFC_RESET) {
 		if (resettime++ >= NFC_RESET_TIMEOUT) {
 			dev_err(dev, "Timeout while resetting NFC!\n");
@@ -772,6 +799,12 @@ static int __devinit mpc5121_nfc_probe(s
 		}
 
 		udelay(1);
+		if (_cur < timeout) {
--
 	while (i && readb(this->IO_ADDR_R + MM_NAND_STS) & CS_NAND_CTLR_BUSY) {
 		udelay(1);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (num_err--) {
 		change_bit(0, (unsigned long *)&err_idx[i]);
 		change_bit(1, (unsigned long *)&err_idx[i]);
@@ -517,6 +522,12 @@ static int fsmc_correct_data(struct mtd_
 			change_bit(err_idx[i], (unsigned long *)dat);
 			i++;
--
 	while (len--) {
 		iowrite8(*p++, info->nand.IO_ADDR_W);
 		/* wait until buffer is available for write */
 		do {
 			status = gpmc_read_status(GPMC_STATUS_BUFFER);
 		} while (!status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (len--) {
 		iowrite16(*p++, info->nand.IO_ADDR_W);
 		/* wait until buffer is available for write */
 		do {
 			status = gpmc_read_status(GPMC_STATUS_BUFFER);
 		} while (!status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 		while (len) {
 			w_count = gpmc_read_status(GPMC_PREFETCH_FIFO_CNT);
 			w_count = w_count >> 1;
 			for (i = 0; (i < w_count) && len; i++, len -= 2)
 				iowrite16(*p++, info->nand.IO_ADDR_W);
+				if (_cur < timeout) {
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (len--) {
 		if (*p++ != cpu_to_le16(readw(info->nand.IO_ADDR_R)))
 			return -EFAULT;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
@@ -75,6 +80,12 @@ static void vmax301_copy_from(struct map
 		to += thislen;
 		from += thislen;
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
@@ -100,6 +116,12 @@ static void vmax301_copy_to(struct map_i
 		to += thislen;
 		from += thislen;
--
 	while(len--) {
 		unsigned long tmp = address_fix8_write(map->map_priv_1 + to++);
 		*(__u8 *)(tmp) = *(__u8 *)(from++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (start < end) {
 		/* invalidate D cache line */
 		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (start));
 		start += CACHELINESIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
@@ -135,6 +140,12 @@ static void sbc_gxx_copy_from(struct map
 		to += thislen;
 		from += thislen;
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
@@ -160,6 +176,12 @@ static void sbc_gxx_copy_to(struct map_i
 		to += thislen;
 		from += thislen;
--
 	while(*sor)
 	{
 		if(*sor==',')
@@ -91,6 +96,12 @@ static char * __init get_string_option(c
 				return sor;
 			}
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
@@ -84,6 +89,12 @@ static void oct5066_copy_from(struct map
 		to += thislen;
 		from += thislen;
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
@@ -109,6 +125,12 @@ static void oct5066_copy_to(struct map_i
 		to += thislen;
 		from += thislen;
--
 	while(len) {
 		int toread = win_size - (from & (win_size-1));
 		caddr_t addr;
@@ -158,6 +163,12 @@ static void pcmcia_copy_from_remap(struc
 		len -= toread;
 		to += toread;
--
 	while(len) {
 		int towrite = win_size - (to & (win_size-1));
 		caddr_t addr;
@@ -207,6 +223,12 @@ static void pcmcia_copy_to_remap(struct
 		len -= towrite;
 		to += towrite;
--
 	while (i--) {
 		mtd_device_unregister(msp_flash[i]);
 		map_destroy(msp_flash[i]);
 		kfree(msp_maps[i].name);
 		iounmap(msp_maps[i].virt);
 		kfree(msp_parts[i]);
--
   while (++r <= NN-KK) {	/* r is the step number */
     /* Compute discrepancy at the r-th step in poly-form */
     discr_r = 0;
@@ -324,6 +329,12 @@ eras_dec_rs(dtype Alpha_to[NN + 1], dtyp
       }
       COPY(lambda,t,NN-KK+1);
--
 		while (len) {
 			if (erase_sector(flash, addr)) {
 				instr->state = MTD_ERASE_FAILED;
@@ -324,6 +329,12 @@ static int m25p80_erase(struct mtd_info
 
 			addr += mtd->erasesize;
--
-		while (soff_hi != eoff_hi) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (soff_hi != eoff_hi) {
 #ifdef CONFIG_MTD_PMC551_DEBUG
 			printk(KERN_DEBUG "pmc551_erase() soff_hi: %ld, "
 				"eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);
@@ -154,6 +159,12 @@ static int pmc551_erase(struct mtd_info
 			pmc551_point(mtd, (priv->base_map0 | soff_hi),
--
-		while (soff_hi != eoff_hi) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (soff_hi != eoff_hi) {
 #ifdef CONFIG_MTD_PMC551_DEBUG
 			printk(KERN_DEBUG "pmc551_read() soff_hi: %ld, "
 				"eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);
@@ -267,6 +283,12 @@ static int pmc551_read(struct mtd_info *
 			soff_hi += priv->asize;
--
-		while (soff_hi != eoff_hi) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (soff_hi != eoff_hi) {
 #ifdef CONFIG_MTD_PMC551_DEBUG
 			printk(KERN_DEBUG "pmc551_write() soff_hi: %ld, "
 				"eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);
@@ -334,6 +361,12 @@ static int pmc551_write(struct mtd_info
 			soff_hi += priv->asize;
--
 	while ((mtd = pmc551list)) {
 		priv = mtd->priv;
 		pmc551list = priv->nextpmc551;
@@ -859,6 +897,12 @@ static void __exit cleanup_pmc551(void)
 		mtd_device_unregister(mtd);
 		kfree(mtd);
--
-   while (len)
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
+	 while (len)
 	 {
 		if (!erase_block (addr))
 		  {
@@ -426,6 +431,12 @@ static int flash_erase (struct mtd_info
 		len -= mtd->eraseregions[i].erasesize;
--
 	while (addr < end) {
 		err = sst25l_erase_sector(flash, addr);
 		if (err) {
@@ -205,6 +210,12 @@ static int sst25l_erase(struct mtd_info
 		}
 
--
-	while (old) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (old) {
 		if (DoCMil_is_alias(this, old)) {
 			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium at "
 			       "0x%lX - already configured\n", this->physadr);
@@ -335,6 +340,12 @@ void DoCMil_init(struct mtd_info *mtd)
 			old = old->nextdoc->priv;
--
 	while ((mtd=docmillist)) {
 		this = mtd->priv;
 		docmillist = this->nextdoc;
@@ -830,6 +846,12 @@ static void __exit cleanup_doc2001(void)
 		iounmap(this->virtadr);
 		kfree(this->chips);
--
 	while (*curmtd) {
 		curmtd = &(*curmtd)->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (slram_mtdlist) {
 		nextitem = slram_mtdlist->next;
 		mtd_device_unregister(slram_mtdlist->mtdinfo);
@@ -237,6 +253,12 @@ static void unregister_devices(void)
 		kfree(slram_mtdlist->mtdinfo);
 		kfree(slram_mtdlist);
--
 	while (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {
 		/* issue 2 read from NOP register after reading from CDSNControl register
 	   	see Software Requirement 11.4 item 2. */
@@ -96,6 +101,12 @@ static int _DoC_WaitReady(struct DiskOnC
 		}
 		udelay(1);
--
-	while (old) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (old) {
 		if (DoC2k_is_alias(old, this)) {
 			printk(KERN_NOTICE
 			       "Ignoring DiskOnChip 2000 at 0x%lX - already configured\n",
@@ -529,6 +545,12 @@ void DoC2k_init(struct mtd_info *mtd)
 			old = old->nextdoc->priv;
--
 	while (left) {
 		len = left;
 
@@ -737,6 +764,12 @@ static int doc_read(struct mtd_info *mtd
 		from += len;
 		left -= len;
--
 	while (left) {
 		len = left;
 
@@ -912,6 +950,12 @@ static int doc_write(struct mtd_info *mt
 		to += len;
 		left -= len;
--
 	while(len) {
 		mychip = &this->chips[ofs >> this->chipshift];
 
@@ -1156,6 +1205,12 @@ static int doc_erase(struct mtd_info *mt
 		}
 		ofs += mtd->erasesize;
--
 	while ((mtd = doc2klist)) {
 		this = mtd->priv;
 		doc2klist = this->nextdoc;
@@ -1187,6 +1247,12 @@ static void __exit cleanup_doc2000(void)
 		iounmap(this->virtadr);
 		kfree(this->chips);
--
 	while (pages) {
 		page = page_read(mapping, index);
 		if (!page)
@@ -71,6 +76,12 @@ static int _block2mtd_erase(struct block
 		page_cache_release(page);
 		pages--;
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		if ((offset + len) > PAGE_SIZE)
 			cpylen = PAGE_SIZE - offset;	// multiple pages
 		else
@@ -134,6 +150,12 @@ static int block2mtd_read(struct mtd_inf
 		buf += cpylen;
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		if ((offset+len) > PAGE_SIZE)
 			cpylen = PAGE_SIZE - offset;	// multiple pages
 		else
@@ -178,6 +205,12 @@ static int _block2mtd_write(struct block
 		buf += cpylen;
--
-	while (old) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (old) {
 		if (DoCMilPlus_is_alias(this, old)) {
 			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium "
 				"Plus at 0x%lX - already configured\n",
@@ -459,6 +464,12 @@ void DoCMilPlus_init(struct mtd_info *mt
 			old = old->nextdoc->priv;
--
 	while ((mtd=docmilpluslist)) {
 		this = mtd->priv;
 		docmilpluslist = this->nextdoc;
@@ -1095,6 +1111,12 @@ static void __exit cleanup_doc2001plus(v
 		iounmap(this->virtadr);
 		kfree(this->chips);
--
-                while (temp_len) {
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (temp_len) {
 			printk("before unlock %x: block status register is %x\n",temp_adr,cfi_read_query(map, temp_adr+(2*ofs_factor)));
 			temp_adr += mtd->erasesize;
 			temp_len -= mtd->erasesize;
+			if (_cur < timeout) {
+	rdstcll(_cur);
--
 			while (chip->state != newstate) {
 				DECLARE_WAITQUEUE(wait, current);
 				set_current_state(TASK_UNINTERRUPTIBLE);
@@ -1159,6 +1164,12 @@ static int __xipram xip_wait_for_operati
 				schedule();
 				remove_wait_queue(&chip->wq, &wait);
--
-	while(len >= map_bankwidth(map)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while(len >= map_bankwidth(map)) {
 		map_word datum = map_word_load(map, buf);
 
 		ret = do_write_oneword(map, &cfi->chips[chipnum],
@@ -1620,6 +1636,12 @@ static int cfi_intelext_write_words (str
 			if (chipnum == cfi->numchips)
--
 	while (size) {
 		unsigned long bus_ofs = offset & ~(map_bankwidth(map)-1);
 		int gap = offset - bus_ofs;
@@ -2205,6 +2232,12 @@ do_otp_write(struct map_info *map, struc
 		offset += n;
 		buf += n;
--
-	while(len >= map_bankwidth(map)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while(len >= map_bankwidth(map)) {
 		map_word datum;
 
 		datum = map_word_load(map, buf);
@@ -1331,6 +1336,12 @@ static int cfi_amdstd_write_words(struct
 				return 0;
--
 	while(z < words * map_bankwidth(map)) {
 		datum = map_word_load(map, buf);
 		map_write(map, datum, adr + z);
 
 		z += map_bankwidth(map);
 		buf += map_bankwidth(map);
--
 	while (len >= map_bankwidth(map) * 2) {
 		/* We must not cross write block boundaries */
 		int size = wbufsize - (ofs & (wbufsize-1));
@@ -1547,6 +1574,12 @@ static int cfi_amdstd_write_buffers(stru
 			if (chipnum == cfi->numchips)
 				return 0;
--
 	while (*p) {
 		parent = *p;
 		cur = rb_entry(parent, struct swap_eb, rb);
@@ -228,6 +233,12 @@ static void __mtdswap_rb_add(struct rb_r
 			p = &(*p)->rb_right;
 		else
--
 	while (i < idx && p) {
 		p = rb_next(p);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (1) {
 		ret = mtdswap_gc(d, 1);
 		if (ret || mtd_blktrans_cease_background(dev))
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((pp = of_get_next_child(node, pp))) {
 		const __be32 *reg;
 		int len;
@@ -74,6 +79,12 @@ static int parse_ofpart_partitions(struc
 			(*pparts)[i].mask_flags = MTD_WRITEABLE;
 
--
-		while (offs < slave->mtd.size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (offs < slave->mtd.size) {
 			if (master->block_isbad(master,
 						offs + slave->offset))
 				slave->mtd.ecc_stats.badblocks++;
 			offs += slave->mtd.erasesize;
+			if (_cur < timeout) {
--
 	while (*p) {
 		parent = *p;
 		sv = rb_entry(parent, struct ubi_scan_volume, rb);
@@ -269,6 +274,12 @@ static struct ubi_scan_volume *add_volum
 			p = &(*p)->rb_left;
 		else
--
 	while (*p) {
 		int cmp_res;
 
@@ -556,6 +572,12 @@ int ubi_scan_add_used(struct ubi_device
 			return add_to_list(si, pnum, ec, cmp_res & 4,
 					   &si->erase);
--
 	while (p) {
 		sv = rb_entry(p, struct ubi_scan_volume, rb);
 
@@ -613,6 +640,12 @@ struct ubi_scan_volume *ubi_scan_find_sv
 			p = p->rb_left;
 		else
--
 	while (p) {
 		seb = rb_entry(p, struct ubi_scan_leb, u.rb);
 
@@ -642,6 +680,12 @@ struct ubi_scan_leb *ubi_scan_find_seb(c
 			p = p->rb_left;
 		else
--
 	while ((rb = rb_first(&sv->root))) {
 		seb = rb_entry(rb, struct ubi_scan_leb, u.rb);
 		rb_erase(&seb->u.rb, &sv->root);
 		list_add_tail(&seb->u.list, &si->erase);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (this) {
 		if (this->rb_left)
 			this = this->rb_left;
@@ -1270,6 +1330,12 @@ static void destroy_sv(struct ubi_scan_i
 
 			kmem_cache_free(si->scan_leb_slab, seb);
--
 	while (rb) {
 		if (rb->rb_left)
 			rb = rb->rb_left;
@@ -1321,6 +1392,12 @@ void ubi_scan_destroy_si(struct ubi_scan
 
 			destroy_sv(si, sv);
--
 	while (*p) {
 		struct ubi_wl_entry *e1;
 
@@ -205,6 +210,12 @@ static void wl_tree_add(struct ubi_wl_en
 			else
 				p = &(*p)->rb_right;
--
 	while (!ubi->free.rb_node) {
 		spin_unlock(&ubi->wl_lock);
 
@@ -281,6 +297,12 @@ static int produce_free_peb(struct ubi_d
 			return err;
 
--
 	while (p) {
 		struct ubi_wl_entry *e1;
 
@@ -321,6 +348,12 @@ static int in_wl_tree(struct ubi_wl_entr
 			else
 				p = p->rb_right;
--
 	while (p) {
 		struct ubi_wl_entry *e1;
 
@@ -374,6 +412,12 @@ static struct ubi_wl_entry *find_wl_entr
 			p = p->rb_right;
 			e = e1;
--
 	while (ubi->works_count) {
 		err = do_work(ubi);
 		if (err)
 			return err;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (ubi->works_count) {
 		dbg_wl("flush more (%d pending works)", ubi->works_count);
 		err = do_work(ubi);
 		if (err)
 			return err;
+			if (_cur < timeout) {
--
 	while (rb) {
 		if (rb->rb_left)
 			rb = rb->rb_left;
@@ -1342,6 +1413,12 @@ static void tree_destroy(struct rb_root
 
 			kmem_cache_free(ubi_wl_entry_slab, e);
--
 	while (!list_empty(&ubi->works)) {
 		struct ubi_work *wrk;
 
@@ -1416,6 +1498,12 @@ static void cancel_pending(struct ubi_de
 		wrk->func(ubi, wrk, 1);
 		ubi->works_count -= 1;
--
 	while (p) {
 		struct ubi_ltree_entry *le;
 
@@ -116,6 +121,12 @@ static struct ubi_ltree_entry *ltree_loo
 			else
 				return le;
--
 		while (*p) {
 			parent = *p;
 			le1 = rb_entry(parent, struct ubi_ltree_entry, rb);
@@ -181,6 +197,12 @@ static struct ubi_ltree_entry *ltree_add
 				else
 					p = &(*p)->rb_right;
--
 	while (i < len) {
 		printk("0x%08x: ", start + i);
 		diff = "   ";
@@ -497,6 +502,12 @@ static void print_bufs(unsigned char *re
 			printk(" %02x", written[start + i + j2]);
 		printk("\n");
--
 	while (i < offset + len) {
 		if (buf[i] != check_buf[i]) {
 			(*bytesp)++;
@@ -528,6 +544,12 @@ static int countdiffs(unsigned char *buf
 			}
 		}
--
 	while (offs > mtd->erasesize) {
 		offsets[eb++] = mtd->erasesize;
 		offs -= mtd->erasesize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (chip->state != chip_state) {
 			/* Someone's suspended the operation: sleep */
 			DECLARE_WAITQUEUE(wait, current);
@@ -170,6 +175,12 @@ static int wait_for_ready(struct map_inf
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
--
 			/* Suspend has occurred while sleep: reset timeout */
diff -u -p a/mtd/sm_ftl.c b/mtd/sm_ftl.c
--- a/mtd/sm_ftl.c
+++ b/mtd/sm_ftl.c
@@ -869,11 +869,22 @@ static int sm_init_zone(struct sm_ftl *f
 	get_random_bytes(&i, 2);
--
-	while (i--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i--) {
 		len = kfifo_out(&zone->free_sectors,
 					(unsigned char *)&block, 2);
 		WARN_ON(len != 2);
 		kfifo_in(&zone->free_sectors, (const unsigned char *)&block, 2);
+		if (_cur < timeout) {
--
 	while (!req.complete) {
 		adb_iop_poll();
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (state == state_attached) {
 		unsigned long elapsed, start;
 
@@ -1871,6 +1876,12 @@ static int main_control_loop(void *x)
 		elapsed = jiffies - start;
 		if (elapsed < HZ)
--
 	while (count--) {
 		result = ams_i2c_read(AMS_COMMAND);
 		if (result == 0 || result & 0x80)
 			return 0;
 
 		schedule_timeout_uninterruptible(HZ / 20);
--
-	while(!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(!kthread_should_stop()) {
 		try_to_freeze();
 		msleep_interruptible(2000);
 
@@ -364,6 +369,12 @@ static int monitor_task(void *arg)
 		display_stats(th);
--
 	while (!list_empty(&smu_fans)) {
 		fct = list_entry(smu_fans.next, struct smu_fan_control, link);
 		list_del(&fct->link);
 		wf_unregister_control(&fct->ctrl);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while(adb_handler[index].busy) {
 			write_unlock_irq(&adb_handler_lock);
 			yield();
 			write_lock_irq(&adb_handler_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!list_empty(&smu_ads)) {
 		ads = list_entry(smu_ads.next, struct smu_ad_sensor, link);
 		list_del(&ads->link);
 		wf_unregister_sensor(&ads->sens);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (cur) {
 		if (cur == req) {
 			local_irq_restore(flags);
 			return 1;
 		}
 		cur = cur->next;
--
 		while (!req->complete) {
 			macii_poll();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (!kthread_should_stop()) {
 		try_to_freeze();
 
@@ -119,6 +124,12 @@ static int wf_thread_func(void *data)
 		delay = next - jiffies;
 		if (delay <= HZ)
--
 	while (len) {
 		unsigned int clen = min(len, chunk);
 
@@ -946,6 +951,12 @@ static int smu_read_datablock(u8 *dest,
 		len -= clen;
 		addr += clen;
--
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_init: no response from PMU\n");
@@ -204,11 +209,22 @@ pmu_init(void)
 		}
 		udelay(10);
--
 	while (interrupt_data[0] || pmu_state != idle) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_init: timed out acking intrs\n");
@@ -220,11 +236,22 @@ pmu_init(void)
 		}
 		pmu_poll();
--
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_init: no response from PMU\n");
@@ -232,6 +259,12 @@ pmu_init(void)
 		}
 		udelay(10);
--
 	while (!req.complete)
 		pmu_poll();
 	timeout = 100000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_adb_reset_bus (reset): no response from PMU\n");
@@ -435,6 +473,12 @@ pmu_reset_bus(void)
 		}
 		udelay(10);
--
 		while (!(via2[B] & TACK)) {
 			if (--timeout < 0) {
 				printk(KERN_ERR "PMU not responding (!ack)\n");
 				goto finish;
 			}
 			udelay(10);
--
 	while (!kthread_should_stop()) {
 		for (i = 0; i < media_bay_count; ++i) {
 			mutex_lock(&media_bays[i].lock);
@@ -552,6 +557,12 @@ static int media_bay_task(void *x)
 		}
 
--
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "init_pmu: no response from PMU\n");
@@ -538,11 +543,22 @@ init_pmu(void)
 		}
 		udelay(10);
--
 	while (interrupt_data[0][0] || pmu_state != idle) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "init_pmu: timed out acking intrs\n");
@@ -552,6 +568,12 @@ init_pmu(void)
 			adb_int_pending = 1;
 		via_pmu_interrupt(0, NULL);
--
 	while (asleep) {
 		mb();
 		mtmsr(msr);
 		isync();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 				while (i--) {
 					u16 new_idx = (ioat->tail+i) & (new_size-1);
 
 					ioat2_free_ring_ent(ring[new_idx], c);
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while ((d40d = d40_first_active_get(d40c))) {
 		d40_desc_remove(d40d);
 		d40_desc_free(d40c, d40d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((d40d = d40_first_queued(d40c))) {
 		d40_desc_remove(d40d);
 		d40_desc_free(d40c, d40d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((d40d = d40_first_pending(d40c))) {
 		d40_desc_remove(d40d);
 		d40_desc_free(d40c, d40d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (l->link_addr) {
 		next = l->virt_link_addr;
 		dma_pool_free(pool->dmapool, l, l->phy_this);
 		DEBUGFS_POOL_COUNTER_ADD(pool, -1);
 		l = next;
+		if (_cur < timeout) {
--
 	while (lli->link_addr) {
 		lli->control = ctrl_chained | MAX_DMA_PACKET_SIZE;
 		lli->src_addr = src;
@@ -163,6 +179,12 @@ coh901318_lli_fill_memcpy(struct coh9013
 
 		src += MAX_DMA_PACKET_SIZE;
--
 	while (lli->link_addr) {
 		size_t block_size = MAX_DMA_PACKET_SIZE;
 		lli->control = ctrl_chained | MAX_DMA_PACKET_SIZE;
@@ -219,6 +246,12 @@ coh901318_lli_fill_single(struct coh9013
 			src += block_size;
 		else if (dir == DMA_FROM_DEVICE)
--
 		while (bytes_to_transfer) {
 			u32 val;
 
@@ -302,6 +340,12 @@ coh901318_lli_fill_sg(struct coh901318_p
 
 			bytes_to_transfer -= elem_size;
--
-		while ((rv = ioread32(&dma_reg->csfpl))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((rv = ioread32(&dma_reg->csfpl))) {
 			i = rv & DMA_CDB_ADDR_MSK;
 			cdb = (struct dma_cdb *)&p[i -
 			    (u32)chan->device->dma_desc_pool];
@@ -1217,6 +1222,12 @@ static void ppc440spe_adma_device_clear_
 						BUG();
--
 	while (stride--) {
 		slot->slots_per_op = 0;
 		slot = list_entry(slot->slot_node.next,
 				struct ppc440spe_adma_desc_slot,
 				slot_node);
+		if (_cur < timeout) {
--
-		while (dst_cnt--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (dst_cnt--) {
 			addr = ppc440spe_desc_get_dest_addr(
 				desc, chan, dst_cnt);
 			dma_unmap_page(chan->device->dev,
 					addr, desc->unmap_len,
 					DMA_FROM_DEVICE);
--
-		while (src_cnt--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (src_cnt--) {
 			addr = ppc440spe_desc_get_src_addr(
 				desc, chan, src_cnt);
 			dma_unmap_page(chan->device->dev,
 					addr, desc->unmap_len,
 					DMA_TO_DEVICE);
--
 			while (num_slots) {
 				int i;
 				/* pre-ack all but the last descriptor */
@@ -2053,6 +2102,12 @@ retry:
 						slot_node);
 				}
--
-		while (src_cnt--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (src_cnt--) {
 			ppc440spe_adma_pq_set_src(sw_desc, src[src_cnt],
 						  src_cnt);
 
@@ -2768,6 +2828,12 @@ static struct ppc440spe_adma_desc_slot *
 				mult = scf[src_cnt];
--
-		while (src_cnt--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (src_cnt--) {
 			/* handle descriptors (if dst_cnt == 2) inside
 			 * the ppc440spe_adma_pq_set_srcxxx() functions
 			 */
@@ -2863,6 +2934,12 @@ static struct ppc440spe_adma_desc_slot *
 				mult = scf[src_cnt];
--
-	while (op <= index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (op <= index) {
 		lop = op;
 		if (k == XOR_MAX_OPS) {
 			k = 0;
@@ -3746,6 +3828,12 @@ static void ppc440spe_adma_dma2rxor_set_
 			op += 2;
--
-	while (op <= index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (op <= index) {
 		lop = op;
 		if (k == XOR_MAX_OPS) {
 			k = 0;
@@ -3788,6 +3881,12 @@ static void ppc440spe_adma_dma2rxor_set_
 			op += 2;
--
 	while (iovec_idx < pinned_list->nr_iovecs) {
 		struct dma_page_list *page_list;
 
@@ -175,6 +180,11 @@ dma_cookie_t dma_memcpy_to_iovec(struct
 			 - ((unsigned long)page_list->base_address & PAGE_MASK)) >> PAGE_SHIFT;
 
--
 		while (iov[iovec_idx].iov_len) {
 			copy = min_t(int, PAGE_SIZE - iov_byte_offset, len);
 			copy = min_t(int, copy, iov[iovec_idx].iov_len);
@@ -200,8 +210,20 @@ dma_cookie_t dma_memcpy_to_iovec(struct
 			kdata += copy;
 			iov_byte_offset = 0;
--
 	while (iovec_idx < pinned_list->nr_iovecs) {
 		struct dma_page_list *page_list;
 
@@ -244,6 +271,11 @@ dma_cookie_t dma_memcpy_pg_to_iovec(stru
 			 - ((unsigned long)page_list->base_address & PAGE_MASK)) >> PAGE_SHIFT;
 
--
 		while (iov[iovec_idx].iov_len) {
 			copy = min_t(int, PAGE_SIZE - iov_byte_offset, len);
 			copy = min_t(int, copy, iov[iovec_idx].iov_len);
@@ -270,8 +302,20 @@ dma_cookie_t dma_memcpy_pg_to_iovec(stru
 			offset += copy;
 			iov_byte_offset = 0;
--
 			while (bd.remainder > (mbus->buswidth - 1)) {
 				size_t lli_len, tsize, width;
 
@@ -741,6 +746,12 @@ static int pl08x_fill_llis_for_desc(stru
 				pl08x_fill_lli_for_desc(&bd, num_llis++,
 						lli_len, cctl);
--
-	while (!list_empty(&desc->tx_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&desc->tx_list)) {
 		struct ep93xx_dma_desc *d = list_first_entry(&desc->tx_list,
 			struct ep93xx_dma_desc, node);
 
@@ -239,6 +244,12 @@ static void ep93xx_dma_set_active(struct
 		d->txd.callback_param = desc->txd.callback_param;
--
-	while (l) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l) {
 		dev_vdbg(COHC_2_DEV(cohc), "i %d, lli %p, ctrl 0x%x, src 0x%x"
 			 ", dst 0x%x, link 0x%x virt_link_addr 0x%p\n",
 			 i, l, l->control, l->src_addr, l->dst_addr,
 			 l->link_addr, l->virt_link_addr);
 		i++;
--
 	while (lli) {
 		bytes += lli->control & COH901318_CX_CTRL_TC_VALUE_MASK;
 		lli = lli->virt_link_addr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (status1) {
 		/* Find first bit set, return as a number. */
 		i = ffs(status1) - 1;
@@ -863,9 +890,20 @@ static irqreturn_t dma_irq_handler(int i
 			}
 		}
--
 	while (status2) {
 		/* Find first bit set, return as a number. */
 		i = ffs(status2) - 1;
@@ -908,6 +946,12 @@ static irqreturn_t dma_irq_handler(int i
 			}
 		}
--
 	while ((cohd = coh901318_first_active_get(cohc))) {
 		/* release the lli allocation*/
 		coh901318_lli_free(&cohc->base->pool, &cohd->lli);
@@ -1396,8 +1445,19 @@ coh901318_control(struct dma_chan *chan,
 		/* return desc to free-list */
 		coh901318_desc_remove(cohd);
--
 	while ((cohd = coh901318_first_queued(cohc))) {
 		/* release the lli allocation*/
 		coh901318_lli_free(&cohc->base->pool, &cohd->lli);
@@ -1405,6 +1465,12 @@ coh901318_control(struct dma_chan *chan,
 		/* return desc to free-list */
 		coh901318_desc_remove(cohd);
--
 	while (n--) {
 		struct dma_async_tx_descriptor *txd = &desc->txd;
 
@@ -964,6 +969,12 @@ static int idmac_desc_alloc(struct idmac
 		list_add(&desc->list, &ichan->free_list);
 
--
 		while ((line = ffs(status))) {
 			struct ipu_irq_map *map;
 
@@ -303,6 +308,12 @@ static void ipu_irq_err(unsigned int irq
 				continue;
 			}
--
 		while ((line = ffs(status))) {
 			struct ipu_irq_map *map;
 
@@ -340,6 +356,12 @@ static void ipu_irq_fn(unsigned int irq,
 				continue;
 			}
--
 	while (!list_empty(&last->node)) {
 		desc = list_entry(last->node.next, struct dma_pl330_desc, node);
 
@@ -410,6 +415,12 @@ static dma_cookie_t pl330_tx_submit(stru
 		desc->txd.cookie = cookie;
 
--
-			while (!list_empty(&first->node)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&first->node)) {
 				desc = list_entry(first->node.next,
 						struct dma_pl330_desc, node);
 				list_move_tail(&desc->node, &pdmac->desc_pool);
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (status) {
 		/*txn interrupt*/
 		i = get_ch_index(&status, mid->chan_base);
@@ -977,10 +982,21 @@ static void dma_tasklet(unsigned long da
 				mid->dma_base + MASK_BLOCK);
 		}
--
 	while (status) {
 		/*err interrupt*/
 		i = get_ch_index(&status, mid->chan_base);
@@ -1002,6 +1018,12 @@ static void dma_tasklet(unsigned long da
 		iowrite32(UNMASK_INTR_REG(midc->ch_id),
 				mid->dma_base + MASK_ERR);
--
-				while (src_cnt--) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (src_cnt--) {
 					addr = mv_desc_get_src_addr(unmap,
 								    src_cnt);
 					if (addr == dest)
 						continue;
 					dma_unmap_page(dev, addr, len,
--
 			while (num_slots) {
 				int i;
 
@@ -515,6 +531,12 @@ retry:
 						slot_node);
 				}
--
 	while (stat) {
 		int channel = fls(stat) - 1;
 		struct sdma_channel *sdmac = &sdma->channel[channel];
@@ -553,6 +558,12 @@ static irqreturn_t sdma_int_handler(int
 		mxc_sdma_handle_channel(sdmac);
 
--
 	while (buf < buf_len) {
 		struct sdma_buffer_descriptor *bd = &sdmac->bd[i];
 		int param;
@@ -1071,6 +1087,12 @@ static struct dma_async_tx_descriptor *s
 		buf += period_len;
 
--
 	while (stride--) {
 		slot->slots_per_op = 0;
 		slot = list_entry(slot->slot_node.next,
 				struct iop_adma_desc_slot,
 				slot_node);
+		if (_cur < timeout) {
--
 		while (src_cnt--) {
 			addr = iop_desc_get_src_addr(unmap, iop_chan, src_cnt);
 			if (addr == dest)
 				continue;
 			dma_unmap_page(dev, addr, len, DMA_TO_DEVICE);
+			if (_cur < timeout) {
--
-			while (num_slots) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (num_slots) {
 				int i;
 				dev_dbg(iop_chan->device->common.dev,
 					"allocated slot: %d "
@@ -419,6 +446,12 @@ retry:
 						slot_node);
--
-	while (stat1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (stat1) {
 		int channel = fls(stat1) - 1;
 		struct mxs_dma_chan *mxs_chan =
 			&mxs_dma->mxs_chans[channel % MXS_DMA_CHANNELS];
@@ -301,6 +306,12 @@ static irqreturn_t mxs_dma_int_handler(i
 
--
 	while (buf < buf_len) {
 		struct mxs_dma_ccw *ccw = &mxs_chan->ccw[i];
 
@@ -522,6 +538,12 @@ static struct dma_async_tx_descriptor *m
 		buf += period_len;
 
--
 	while (chan->client_count < dmaengine_ref_count) {
 		__module_get(owner);
 		chan->client_count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&priv->list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&priv->list)) {
 		gref = list_entry(priv->list.next,
 			struct gntalloc_gref, next_file);
 		list_del(&gref->next_file);
 		gref->users--;
 		if (gref->users == 0)
--
 	while (pages && !err) {
 		while (pages && map->unmap_ops[offset].handle == -1) {
 			offset++;
@@ -354,6 +359,12 @@ static int unmap_grant_pages(struct gran
 		err = __unmap_grant_pages(map, offset, range);
 		offset += range;
 		pages -= range;
--
 	while (!list_empty(&priv->maps)) {
 		map = list_entry(priv->maps.next, struct grant_map, next);
 		list_del(&map->next);
 		gntdev_put_map(map);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (pgno < nr_pages) {
 		page = balloon_retrieve(highmem);
 		if (page && (highmem || !PageHighMem(page))) {
@@ -522,6 +527,12 @@ int alloc_xenballooned_pages(int nr_page
 			if (st != BP_DONE)
 				goto out_undo;
--
-	while (!list_empty(&seized_devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&seized_devices)) {
 		psdev = container_of(seized_devices.next,
 				     struct pcistub_device, dev_list);
 		list_del(&psdev->dev_list);
@@ -377,6 +382,12 @@ static int __init pcistub_init_devices_l
 
--
 	while ((recorded < bytes) && (i < desc->nr_addrs)) {
 		unsigned long vaddr = (unsigned long)buffer + recorded;
 		unsigned long paddr;
@@ -49,6 +54,12 @@ static int xencomm_init(struct xencomm_d
 
 		desc->address[i++] = paddr;
--
-	while (list_empty(&xs_state.reply_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (list_empty(&xs_state.reply_list)) {
 		spin_unlock(&xs_state.reply_lock);
 		/* XXX FIXME: Avoid synchronous wait for response here. */
 		wait_event(xs_state.reply_waitq,
 			   !list_empty(&xs_state.reply_list));
 		spin_lock(&xs_state.reply_lock);
--
 	while (!((flags = shared[ref].flags) & GTF_transfer_committed)) {
 		if (sync_cmpxchg(&shared[ref].flags, flags, 0) == flags)
 			return 0;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!(flags & GTF_transfer_completed)) {
 		flags = shared[ref].flags;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cb) {
 		if (cb == callback)
 			goto out;
 		cb = cb->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (list_empty(&u->read_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (list_empty(&u->read_buffers)) {
 		mutex_unlock(&u->reply_mutex);
 		if (filp->f_flags & O_NONBLOCK)
 			return -EAGAIN;
@@ -133,6 +138,12 @@ again:
 		if (ret)
--
 	while (!list_empty(list)) {
 		rb = list_entry(list->next, struct read_buffer, list);
 		list_del(list->next);
 		kfree(rb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (nelem--) {
 		if (pageidx > PAGE_SIZE-size) {
 			struct page *page = alloc_page(GFP_KERNEL);
@@ -101,6 +106,12 @@ static int gather_array(struct list_head
 
 		data += size;
--
 	while (fm_stat.sig_lock_busy && count-- && !ret) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
 
 		ret = send_get_req(p, TUNER_STATUS, TLG_MODE_FM_RADIO,
 				  &fm_stat, &status, sizeof(fm_stat));
--
 	 } while (0)
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while (count && count >= video->lines_size) {
 		if (video->prev_left) {
 			copy_data(video->prev_left);
@@ -251,6 +256,12 @@ static void copy_video_data(struct video
 			continue;
 		}
--
 	while (atv_stat.sig_lock_busy && count-- && !ret) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
 
 		ret = send_get_req(pd, TUNER_STATUS, TLG_MODE_ANALOG_TV,
 				&atv_stat, &cmd_status, sizeof(atv_stat));
--
-	while (!s->data_available_for_read) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!s->data_available_for_read) {
 		int ret = wait_event_interruptible(s->read_queue,
 					     s->data_available_for_read);
 		if (ret == -ERESTARTSYS) {
 			a->result = -EINTR;
 			return;
--
 	while (i--) {
 		int err;
 		if (stype == fsize->type) {
@@ -482,6 +487,12 @@ static int __find_resolution(struct v4l2
 			}
 		}
--
-	while (!list_empty(&queue->irqqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&queue->irqqueue)) {
 		buf = list_first_entry(&queue->irqqueue, struct uvc_buffer,
 				       queue);
 		list_del(&buf->queue);
 		buf->state = UVC_BUF_STATE_ERROR;
 		wake_up(&buf->wait);
--
 	while (numerator > ((uint32_t)-1)/multiplier) {
 		multiplier /= 2;
 		denominator /= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-   while (pdec->nbits_in_reservoir<(nbits_wanted)) \
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (pdec->nbits_in_reservoir<(nbits_wanted)) \
     { \
       pdec->reservoir |= (*(pdec->stream)++) << (pdec->nbits_in_reservoir); \
       pdec->nbits_in_reservoir += 8; \
-    } \
+    if (_cur < timeout) {
--
 }  while(0);
 
 #define skip_nbits(pdec, nbits_to_skip) do { \
@@ -747,11 +758,22 @@ static void DecompressBand23(struct pwc_
 	ptable8004 = pdec->table_8004_pass1[compression_index];
 
--
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_Y(pdec->temp_colors, planar_y, real_image_width, pdec->scalebits);
 		planar_y += 4;
 		nblocks--;
+		if (_cur < timeout) {
--
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_CrCb(pdec->temp_colors, planar_u, real_image_width/2, pdec->scalebits);
@@ -771,6 +798,12 @@ static void DecompressBand23(struct pwc_
 		planar_v += 8;
 		planar_u += 8;
--
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_RedBlue(pdec->temp_colors, rgbbayer, real_image_width, pdec->scalebits);
 		dest += 8;
 		nblocks--;
+		if (_cur < timeout) {
--
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_Green(pdec->temp_colors, rgbbayer+1, real_image_width, pdec->scalebits);
@@ -835,6 +884,12 @@ static void DecompressBandBayer(struct p
 
 		rgbbayer += 16;
--
-		while (bandlines_left--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (bandlines_left--) {
 
 			DecompressBandBayer(pwc->decompress_data,
 					    src,
@@ -881,6 +941,12 @@ void pwc_dec23_decompress(const struct p
 			src += pwc->vbandlength;
--
-		while (bandlines_left--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (bandlines_left--) {
 
 			DecompressBand23(pwc->decompress_data,
 					 src,
@@ -915,6 +986,12 @@ void pwc_dec23_decompress(const struct p
 			pout_planar_u += pwc->view.x;
--
-	while (!list_empty(&pdev->queued_bufs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&pdev->queued_bufs)) {
 		struct pwc_frame_buf *buf;
 
 		buf = list_entry(pdev->queued_bufs.next, struct pwc_frame_buf,
 				 list);
 		list_del(&buf->list);
--
 		while (!((status = read_lpstatus(q)) & 8)) {
 			/* 1000 is enough spins on the I/O for all normal
 			   cases, at that point we start to poll slowly
@@ -188,8 +193,19 @@ static int qc_waithand(struct qcam *q, i
 				msleep_interruptible(5);
 			if (runs > (maxpoll + 1000)) /* 5 seconds */
--
 		while (((status = read_lpstatus(q)) & 8)) {
 			/* 1000 is enough spins on the I/O for all normal
 			   cases, at that point we start to poll slowly
@@ -202,6 +218,12 @@ static int qc_waithand(struct qcam *q, i
 				msleep_interruptible(5);
 			if (runs++ > (maxpoll + 1000)) /* 5 seconds */
--
 	while (!list_empty(&vidq->active)) {
 		buf = list_entry(vidq->active.next, struct viu_buf, vb.queue);
 		list_del(&buf->vb.queue);
 		buf->vb.state = VIDEOBUF_ERROR;
 		wake_up(&buf->vb.done);
 		dprintk(1, "viu/0: [%p/%d] timeout\n", buf, buf->vb.i);
--
 	while (!list_empty(&dma_q->active)) {
 		struct vivi_buffer *buf;
 		buf = list_entry(dma_q->active.next, struct vivi_buffer, list);
 		list_del(&buf->list);
 		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
 		dprintk(dev, 2, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);
--
-	while (!list_empty(&vivi_devlist)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&vivi_devlist)) {
 		list = vivi_devlist.next;
 		list_del(list);
 		dev = list_entry(list, struct vivi_dev, vivi_devlist);
@@ -1244,6 +1260,12 @@ static int vivi_release(void)
 		v4l2_device_unregister(&dev->v4l2_dev);
--
-		while (prog_cnt != dev->_last_index_irq) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (prog_cnt != dev->_last_index_irq) {
 			/* Update _last_index_irq */
 			if (dev->_last_index_irq < (NUMBER_OF_PROGRAMS - 1))
 				dev->_last_index_irq++;
@@ -526,6 +531,12 @@ int cx25821_audio_upstream_irq(struct cx
 
--
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++) =
 				    cpu_to_le32(RISC_WRITE | sg_dma_len(sg));
 				*(rp++) = cpu_to_le32(sg_dma_address(sg));
 				*(rp++) = cpu_to_le32(0);	/* bits 63-32 */
 				todo -= sg_dma_len(sg);
--
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++) = cpu_to_le32(RISC_WRITE |
 						      sg_dma_len(sg));
 				*(rp++) = cpu_to_le32(sg_dma_address(sg));
 				*(rp++) = cpu_to_le32(0);	/* bits 63-32 */
 				todo -= sg_dma_len(sg);
--
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf =
 		    list_entry(q->active.next, struct cx25821_buffer, vb.queue);
 		list_del(&buf->vb.queue);
 
 		buf->vb.state = VIDEOBUF_ERROR;
--
 	while (line) {
 		*line = 0;
 		svar = strpbrk(sp, tdelim);
@@ -173,6 +178,12 @@ static ssize_t zoran_write(struct file *
 		}
 		sp = line + 1;
--
 	while (i < len) {
 		zr36050_write(ptr, startreg++, data[i++]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 //      while (((por = btread(ZR36057_POR)) & (ZR36057_POR_POPen | ZR36057_POR_POTime)) == ZR36057_POR_POPen) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((por = btread(ZR36057_POR)) & ZR36057_POR_POPen) {
 		/* wait for something to happen */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (zr->jpg_dma_tail < zr->jpg_dma_head) {
 		if (zr->jpg_settings.TmpDcm == 1)
 			i = (zr->jpg_dma_tail -
@@ -1190,6 +1206,12 @@ zoran_reap_stat_com (struct zoran *zr)
 		buffer->state = BUZ_STATE_DONE;
 
--
-		while ((stat = count_reset_interrupt(zr))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((stat = count_reset_interrupt(zr))) {
 			if (count++ > 100) {
 				btand(~ZR36057_ICR_IntPinEn, ZR36057_ICR);
 				dprintk(1,
@@ -1364,6 +1391,12 @@ zoran_irq (int             irq,
 					ZR_DEVNAME(zr), stat);
--
 	while (h) {
 		// attach only if the slave has at least the flags
 		// expected by the master
@@ -153,6 +158,12 @@ videocodec_attach (struct videocodec_mas
 			}
 		}
--
 	while (h) {
 		a = h->list;
 		prev = NULL;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (a) {
 			if (codec == a->codec) {
 				res = a->codec->unset(a->codec);
@@ -222,8 +243,20 @@ videocodec_detach (struct videocodec *co
 			}
 			prev = a;
--
-	while (h) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (h) {
 		if (codec == h->codec) {
 			if (h->attached) {
 				dprintk(1,
@@ -311,6 +349,12 @@ videocodec_unregister (const struct vide
 		}
--
-	while (h) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (h) {
 		seq_printf(m, "S %32s %04x %08lx %08lx (TEMPLATE)\n",
 			      h->codec->name, h->codec->type,
 			      h->codec->flags, h->codec->magic);
 		a = h->list;
-		while (a) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (a) {
 			seq_printf(m, "M %32s %04x %08lx %08lx (%s)\n",
 				      a->codec->master_data->name,
 				      a->codec->master_data->type,
@@ -342,8 +396,20 @@ static int proc_videocodecs_show(struct
 				      a->codec->master_data->magic,
--
 	while (i < len) {
 		zr36060_write(ptr, startreg++, data[i++]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (num) {
 		num >>= 1;
 		result <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-			while (!test_bit(IVTV_F_I_EOS, &itv->i_flags) &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!test_bit(IVTV_F_I_EOS, &itv->i_flags) &&
 				time_before(jiffies,
 					    then + msecs_to_jiffies(2000))) {
 				schedule_timeout(msecs_to_jiffies(10));
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while (!(oi->video_buffer_size & (1 << size_shift))) {
 			size_shift--;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
--
 		while (1) {
 			if (test_and_clear_bit(IVTV_F_I_EV_DEC_STOPPED, &itv->i_flags))
 				ev->type = VIDEO_EVENT_DECODER_STOPPED;
@@ -1752,6 +1757,12 @@ static int ivtv_decoder_ioctls(struct fi
 				IVTV_DEBUG_INFO("User stopped wait for event\n");
 				return -EINTR;
--
-		while (vi->cc_payload_idx) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (vi->cc_payload_idx) {
 			cc = vi->cc_payload[0];
 
 			memcpy(vi->cc_payload, vi->cc_payload + 1,
@@ -540,6 +545,12 @@ void ivtv_vbi_work_handler(struct ivtv *
 
--
 	while (bytes_available < needed_bytes) {
 		struct ivtv_buffer *buf = list_entry(steal->list.prev, struct ivtv_buffer, list);
 		u16 dma_xfer_cnt = buf->dma_xfer_cnt;
@@ -163,19 +168,47 @@ int ivtv_queue_move(struct ivtv_stream *
 				break;
 			buf = list_entry(steal->list.prev, struct ivtv_buffer, list);
--
 		while (to->length - old_length < needed_bytes) {
 			ivtv_queue_move_buf(s, from, to, 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (to->bytesused - old_bytesused < needed_bytes) {
 			ivtv_queue_move_buf(s, from, to, to_free);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while ((buf = ivtv_dequeue(s, &s->q_free))) {
 		if (ivtv_might_use_dma(s))
 			pci_unmap_single(s->itv->pdev, buf->dma_handle,
 				s->buf_size + 256, s->dma);
 		kfree(buf->buf);
 		kfree(buf);
--
 	while (!(readl(&mbox->flags) & IVTV_MBOX_FIRMWARE_DONE)) {
 		if (time_after(jiffies, then + api_timeout)) {
 			IVTV_DEBUG_WARN("Could not get result (%s)\n", api_info[cmd].name);
@@ -313,6 +318,12 @@ static int ivtv_api_call(struct ivtv *it
 			mdelay(1);
 		else
--
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx23885_buffer,
 			vb.queue);
 		list_del(&buf->vb.queue);
@@ -174,6 +179,12 @@ void cx23885_vbi_timeout(unsigned long d
 		wake_up(&buf->vb.done);
--
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next,
 			struct cx23885_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -1523,6 +1528,12 @@ static void cx23885_vid_timeout(unsigned
 		printk(KERN_ERR "%s: [%p/%d] timeout - dma=0x%08lx\n",
--
 	while (params.shutdown == false) {
 		params.enable = false;
 		params.interrupt_enable = false;
 		params.shutdown = true;
 		v4l2_subdev_call(dev->sd_ir, ir, rx_s_parameters, &params);
 		v4l2_subdev_call(dev->sd_ir, ir, rx_g_parameters, &params);
--
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++) = cpu_to_le32(RISC_WRITE|
 						    sg_dma_len(sg));
 				*(rp++) = cpu_to_le32(sg_dma_address(sg));
 				*(rp++) = cpu_to_le32(0); /* bits 63-32 */
 				todo -= sg_dma_len(sg);
--
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx23885_buffer,
 				 vb.queue);
 		list_del(&buf->vb.queue);
@@ -1635,6 +1662,12 @@ static void do_cancel_buffers(struct cx2
 		wake_up(&buf->vb.done);
--
 	while (1) {
 		if (frame->status == FRAME_READY)
 			return 0;
@@ -386,6 +391,12 @@ static int sync(struct camera_data *cam,
 			return -ERESTARTSYS;
 		if(!cam->present)
--
 	while (!suspend && !list_empty(&cap->pending_buf_q)) {
 		buf = fimc_pending_queue_pop(cap);
 		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&cap->active_buf_q)) {
 		buf = fimc_active_queue_pop(cap);
 		if (suspend)
 			fimc_pending_queue_add(cap, buf);
 		else
 			vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
--
 	while (sh--) {
 		u32 tmp = 1 << sh;
 		if (src >= tar * tmp) {
 			*shift = sh, *ratio = tmp;
 			return 0;
 		}
--
 	while ((me = media_entity_graph_walk_next(&graph))) {
 		if (media_entity_type(me) != MEDIA_ENT_T_V4L2_SUBDEV)
 			continue;
@@ -54,6 +59,12 @@ void fimc_pipeline_prepare(struct fimc_d
 			fimc->pipeline.sensor = sd;
 		else if (sd->grp_id == CSIS_GROUP_ID)
--
 	while (!kthread_should_stop()) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&ctx->ref_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ctx->ref_queue)) {
 		mb_entry = list_entry((&ctx->ref_queue)->next,
 						struct s5p_mfc_buf, list);
 		mb_y_addr = vb2_dma_contig_plane_dma_addr(mb_entry->b, 0);
@@ -605,6 +610,12 @@ static void cleanup_ref_queue(struct s5p
 		ctx->ref_queue_cnt--;
--
 	while (!test_bit(new_ctx, &dev->ctx_work_bits)) {
 		new_ctx = (new_ctx + 1) % MFC_NUM_CONTEXTS;
 		if (++cnt > MFC_NUM_CONTEXTS) {
@@ -1102,6 +1107,12 @@ static int s5p_mfc_get_new_ctx(struct s5
 			spin_unlock_irqrestore(&dev->condlock, flags);
 			return -EAGAIN;
--
 	while (!list_empty(lh)) {
 		b = list_entry(lh->next, struct s5p_mfc_buf, list);
 		for (i = 0; i < b->b->num_planes; i++)
 			vb2_set_plane_payload(b->b, i, 0);
 		vb2_buffer_done(b->b, VB2_BUF_STATE_ERROR);
 		list_del(&b->list);
--
-	while (!list_empty(&ctx->dst_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ctx->dst_queue)) {
 		dst_buf = list_entry(ctx->dst_queue.next,
 				     struct s5p_mfc_buf, list);
 		mfc_debug(2, "Cleaning up buffer: %d\n",
@@ -188,6 +193,12 @@ static void s5p_mfc_handle_frame_all_ext
 
--
 	while (dev->ctx[ctx->num]) {
 		ctx->num++;
 		if (ctx->num >= MFC_NUM_CONTEXTS) {
@@ -671,6 +687,12 @@ static int s5p_mfc_open(struct file *fil
 			ret = -EBUSY;
 			goto err_no_ctx;
--
 	while (!list_empty(&btv->capture)) {
 		item = list_entry(btv->capture.next, struct bttv_buffer, vb.queue);
 		list_del(&item->vb.queue);
 		item->vb.state = VIDEOBUF_ERROR;
 		wake_up(&item->vb.done);
+		if (_cur < timeout) {
--
 	while (!list_empty(&btv->vcapture)) {
 		item = list_entry(btv->vcapture.next, struct bttv_buffer, vb.queue);
 		list_del(&item->vb.queue);
 		item->vb.state = VIDEOBUF_ERROR;
 		wake_up(&item->vb.done);
+		if (_cur < timeout) {
--
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++)=cpu_to_le32(BT848_RISC_WRITE|
 						    sg_dma_len(sg));
 				*(rp++)=cpu_to_le32(sg_dma_address(sg));
 				todo -= sg_dma_len(sg);
 				sg++;
--
 			while (yoffset && yoffset >= sg_dma_len(ysg)) {
 				yoffset -= sg_dma_len(ysg);
 				ysg++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
--
 			while (uoffset && uoffset >= sg_dma_len(usg)) {
 				uoffset -= sg_dma_len(usg);
 				usg++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while (voffset && voffset >= sg_dma_len(vsg)) {
 				voffset -= sg_dma_len(vsg);
 				vsg++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-	while ((dev = pci_get_device(PCI_VENDOR_ID_INTEL,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((dev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_82441, dev))) {
 		unsigned char b;
 		pci_read_config_byte(dev, 0x53, &b);
 		if (bttv_debug)
 			pr_info("Host bridge: 82441FX Natoma, bufcon=0x%02x\n",
--
 	while ((intr = vino->intr_status)) {
 		fc_a = vino->a.field_counter >> 1;
 		fc_b = vino->b.field_counter >> 1;
@@ -2506,6 +2511,12 @@ static irqreturn_t vino_interrupt(int ir
 		loop++;
 #endif
--
 	while (first <= last) {
 		const struct v4l2_int_ioctl_desc *mid;
 
@@ -130,6 +135,12 @@ static v4l2_int_ioctl_func *find_ioctl(s
 			last = mid - 1;
 		else
--
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -133,6 +138,12 @@ void cx8800_vbi_timeout(unsigned long da
 		wake_up(&buf->vb.done);
 		printk("%s/0: [%p/%d] timeout - dma=0x%08lx\n", dev->core->name,
--
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -335,6 +340,12 @@ static void do_cancel_buffers(struct cx8
 		wake_up(&buf->vb.done);
 		dprintk(1,"[%p/%d] %s - dma=0x%08lx\n",
--
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++)=cpu_to_le32(RISC_WRITE|
 						    sg_dma_len(sg));
 				*(rp++)=cpu_to_le32(sg_dma_address(sg));
 				todo -= sg_dma_len(sg);
 				sg++;
--
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -1633,6 +1638,12 @@ static void cx8800_vid_timeout(unsigned
 		wake_up(&buf->vb.done);
 		printk("%s/0: [%p/%d] timeout - dma=0x%08lx\n", core->name,
--
 		while (bytes < nbytes) {
 			unsigned int lo1, hi1, lo2, hi2;
 			unsigned char r, g, b;
@@ -333,12 +338,23 @@ static unsigned int qcam_read_bytes(stru
 				buf[bytes++] = g;
 				buf[bytes++] = r;
--
 		while (bytes < nbytes) {
 			unsigned int hi, lo;
 
@@ -364,6 +380,12 @@ get_fragment:
 					buf[n++] = rgb[0];
 				}
--
 	while (!ret && (is_smaller(cam_rect, rect) ||
 			is_inside(cam_rect, rect)) &&
 	       (cap.bounds.width > width || cap.bounds.height > height)) {
@@ -1355,6 +1360,12 @@ static int client_s_crop(struct soc_came
 		dev_geo(dev, "Camera S_CROP %d for %dx%d@%d:%d\n", ret,
 			cam_rect->width, cam_rect->height,
--
 	while ((width > tmp_w || height > tmp_h) &&
 	       tmp_w < max_width && tmp_h < max_height) {
 		tmp_w = min(2 * tmp_w, max_width);
@@ -1440,6 +1456,12 @@ static int client_s_fmt(struct soc_camer
 			dev_err(dev, "Client failed to set format: %d\n", ret);
 			return ret;
--
 	while (bytes_to_write >= free_write_space) {
 
 		if (timeout-- == 0) {
@@ -214,6 +219,12 @@ int saa7164_bus_set(struct saa7164_dev *
 			free_write_space = (curr_srp + bus->m_dwSizeSetRing) -
 				curr_swp;
--
 	while (i--) {
 		int err = abs(fsize->width - mf->width)
 				+ abs(fsize->height - mf->height);
@@ -489,6 +494,12 @@ static int sr030pc30_try_frame_size(stru
 			match = fsize;
 		}
--
 	while ((entity = media_entity_graph_walk_next(&graph))) {
 		if (media_entity_type(entity) == MEDIA_ENT_T_DEVNODE)
 			use += entity->use_count;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-	while (!time_after(jiffies, timeout)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (!time_after(jiffies, timeout)) {
 		if (!busy(isp))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (omap3isp_stat_busy(&isp->isp_af)
 	    || omap3isp_stat_busy(&isp->isp_aewb)
 	    || omap3isp_stat_busy(&isp->isp_hist)
@@ -1029,6 +1056,12 @@ static int isp_suspend_modules(struct is
 			return 1;
 		}
--
-	while (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN,
 			       ISP_SYSSTATUS) & 0x1)) {
 		if (timeout++ > 10000) {
 			dev_alert(isp->dev, "cannot reset ISP\n");
 			return -ETIMEDOUT;
 		}
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		buf = isp_stat_buf_find_oldest(stat);
 		if (!buf) {
 			spin_unlock_irqrestore(&stat->isp->stat_lock, flags);
@@ -321,6 +326,12 @@ static struct ispstat_buffer *isp_stat_b
 			/* Buffer isn't corrupted. */
--
-		while (bytes_parsed < buffer_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bytes_parsed < buffer_size) {
 			u32 bytes_used = 0;
 
 			sav_eav = cx231xx_find_next_SAV_EAV(
@@ -416,6 +421,12 @@ static inline int cx231xx_isoc_copy(stru
 					p_buffer + bytes_parsed,/* p_buffer */
--
-		while (bytes_parsed < buffer_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bytes_parsed < buffer_size) {
 			u32 bytes_used = 0;
 
 			sav_eav = cx231xx_find_next_SAV_EAV(
@@ -502,6 +518,12 @@ static inline int cx231xx_bulk_copy(stru
 					p_buffer + bytes_parsed,/* p_buffer */
--
-		while (bytes_parsed < buffer_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bytes_parsed < buffer_size) {
 			u32 bytes_used = 0;
 
 			sav_eav = cx231xx_find_next_SAV_EAV(
@@ -154,6 +159,12 @@ static inline int cx231xx_isoc_vbi_copy(
 					p_buffer+bytes_parsed, /* p_buffer */
--
 	while (!(gpio&0x020000)) {
 		msleep(10);
 
@@ -336,6 +341,12 @@ static int waitForMciComplete(struct cx2
 			dprintk(3, "ERROR: Timeout - gpio=%x\n", gpio);
 			return -1;
--
 	while (init != (u8)(end + 1)) {
 		if ((i % max_line) == 0) {
 			if (i > 0)
@@ -95,6 +100,12 @@ static void dump_reg_range(struct v4l2_s
 
 		init++;
--
 	while (data[0] || data[1]) {
 		saa717x_write(sd, data[0], data[1]);
 		data += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (state->watch_stereo) {
 			if (msp_sleep(state, count ? 1000 : 5000))
 				goto restart;
 			if (count)
 				count--;
 			watch_stereo(client);
--
 		while (state->watch_stereo) {
 			if (msp_sleep(state, count ? 1000 : 5000))
 				goto restart;
 			if (count)
 				count--;
 			watch_stereo(client);
--
-		while (state->watch_stereo) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while (state->watch_stereo) {
 			watch_stereo(client);
 			if (msp_sleep(state, 5000))
 				goto restart;
+				if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, k))) {
 		for (i = res->start; i <= res->end; i++) {
 			if (request_irq(i, vpif_channel_isr, IRQF_DISABLED,
@@ -1716,6 +1721,12 @@ static __init int vpif_probe(struct plat
 			}
 		}
--
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i))) {
 		for (irq_num = res->start; irq_num <= res->end; irq_num++)
 			free_irq(irq_num,
 				 (void *)(&vpif_obj.dev[i]->channel_id));
 		i++;
+		if (_cur < timeout) {
--
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, k))) {
 		for (i = res->start; i <= res->end; i++) {
 			if (request_irq(i, vpif_channel_isr, IRQF_DISABLED,
@@ -2189,6 +2194,12 @@ static __init int vpif_probe(struct plat
 			}
 		}
--
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i))) {
 		for (irq_num = res->start; irq_num <= res->end; irq_num++)
 			free_irq(irq_num,
 				 (void *)(&vpif_obj.dev[i]->channel_id));
 		i++;
+		if (_cur < timeout) {
--
 	while (i) {
 		i--;
 		alloc_size = sg_dma_len(&dma->sglist[i]);
@@ -247,6 +252,12 @@ static void omap24xxcam_vbq_free_mmap_bu
 		} while (alloc_size -= PAGE_SIZE);
 		__free_pages(sg_page(&dma->sglist[i]),
 			     get_order(sg_dma_len(&dma->sglist[i])));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (size) {
 		order = get_order(size);
 		/*
@@ -335,6 +351,12 @@ static int omap24xxcam_vbq_alloc_mmap_bu
 		do {
 			SetPageReserved(page++);
 		} while (alloc_size -= PAGE_SIZE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (i) {
 		i--;
 		omap24xxcam_vbq_free_mmap_buffer(vbq->bufs[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (!(omap24xxcam_reg_in(cam->mmio_base, CAM_SYSSTATUS)
 		 & CAM_SYSSTATUS_RESETDONE)
 	       && --max_loop) {
 		ndelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!(omap24xxcam_reg_in(base, CAMDMA_CCR(ch))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(omap24xxcam_reg_in(base, CAMDMA_CCR(ch))
 		 & CAMDMA_CCR_ENABLE)) {
 		if (ch == dmach) {
 			/* The previous transfer has ended and this one
@@ -151,6 +156,12 @@ static void omap24xxcam_dmahw_transfer_c
 			break;
--
 	while (queued_sgdma > 0) {
 		sg_state = sgdma->sg_state + sgslot;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while ((sg_state->next_sglist < sg_state->sglen) &&
 		       !(sg_state->csr & csr_error)) {
 			const struct scatterlist *sglist;
@@ -486,6 +502,12 @@ void omap24xxcam_sgdma_process(struct om
 				expires = jiffies + HZ;
 				mod_timer(&sgdma->reset_timer, expires);
--
 	while (i--) {
 		int err = abs(fsize->width - mf->width)
 				+ abs(fsize->height - mf->height);
@@ -377,6 +382,12 @@ static int noon010_try_frame_size(struct
 			match = fsize;
 		}
--
 	while (gspca_dev->present && gspca_dev->streaming) {
 		/* request some data and then read it until we have
 		 * a complete frame. */
@@ -282,7 +287,13 @@ static void sq905_dostream(struct work_s
 			if (ret < 0)
 				goto quit_stream;
--
 	while (cx11646_fw1[i][1]) {
 		reg_w(gspca_dev, 0x006b, cx11646_fw1[i], 3);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cx_sensor_init[i][0]) {
 		reg_w_val(gspca_dev, 0x00e5, cx_sensor_init[i][0]);
 		reg_r(gspca_dev, 0x00e8, 1);		/* -> 0x00 */
@@ -809,6 +825,12 @@ static void cx11646_init1(struct gspca_d
 			reg_r(gspca_dev, 0x00ed, 1);	/* -> 0x01 */
 		}
--
 	while (retry--) {
 		msleep(10);
 		reg_r(gspca_dev, 0x08);
@@ -596,6 +601,12 @@ static int i2c_w(struct gspca_dev *gspca
 				return -1;
 			return 0;
--
 	while (retry--) {
 		reg_r(gspca_dev, ET_ClCK, 1);
 		if (gspca_dev->usb_buf[0] != 0)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (action->req) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (action->req) {
 		switch (action->req) {
 		case 0xa0:	/* write register */
 			reg_w(gspca_dev, action->val, action->idx);
@@ -5786,6 +5791,12 @@ static void usb_exchange(struct gspca_de
 		}
--
 	while ((*sensormap)[0]) {
 		gspca_dev->usb_buf[0] = (*sensormap)[1];
 		gspca_dev->usb_buf[1] = (*sensormap)[1] >> 8;
 		reg_w_buf(gspca_dev, (*sensormap)[0], 2);
 		sensormap++;
+		if (_cur < timeout) {
--
 	while ((*sensor)[0]) {
 		i2c_write(gspca_dev, (*sensor)[1], (*sensor)[0]);
 		sensor++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (++n < len) {
 		if (tbl[n].idx != 0xffff)
 			ctrl_out(gspca_dev, 0x40, 1, tbl[n].val, tbl[n].idx,
@@ -612,6 +617,12 @@ int keep_on_fetching_validx(struct gspca
 			break;
 		else
--
-	while (gspca_dev->present && gspca_dev->streaming) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (gspca_dev->present && gspca_dev->streaming) {
 		/* Request the header, which tells the size to download */
 		ret = usb_bulk_msg(gspca_dev->dev,
 				usb_rcvbulkpipe(gspca_dev->dev, 0x81),
@@ -189,7 +194,13 @@ static void sq905c_dostream(struct work_
 			gspca_frame_add(gspca_dev, packet_type,
--
 	while (len) {
 		int id, chunk_len;
 
@@ -478,6 +483,12 @@ frame_data:
 		}
 		data    += chunk_len;
--
-		while (!w9966_i2c_getscl(cam)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while (!w9966_i2c_getscl(cam)) {
 			if (time_after(jiffies, timeout))
 				return -1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (!list_empty(&q_src->list)) {
 		mdl = list_first_entry(&q_src->list, struct cx18_mdl, list);
 		list_move_tail(&mdl->list, &q_dst->list);
@@ -227,6 +232,12 @@ static void cx18_queue_flush(struct cx18
 		mdl->skipped = 0;
 		mdl->curr_buf = NULL;
--
-		while (!list_empty(&mdl->buf_list)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&mdl->buf_list)) {
 			buf = list_first_entry(&mdl->buf_list,
 					       struct cx18_buffer, list);
 			list_move_tail(&buf->list, &s->buf_pool);
 			buf->bytesused = 0;
 			buf->readpos = 0;
--
-	while (!list_empty(&s->buf_pool)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&s->buf_pool)) {
 		buf = list_first_entry(&s->buf_pool, struct cx18_buffer, list);
 		list_del_init(&buf->list);
 
@@ -439,5 +466,11 @@ void cx18_stream_free(struct cx18_stream
 				s->buf_size, s->dma);
--
 	while (dlen) {
 		chunkCnt = 8;
 		if (chunkCnt > dlen) chunkCnt = dlen;
@@ -77,6 +82,12 @@ static int pvr2_encoder_write_words(stru
 		data += chunkCnt;
 		dlen -= chunkCnt;
--
 	while (dlen) {
 		chunkCnt = 16;
 		if (chunkCnt > dlen) chunkCnt = dlen;
@@ -127,6 +143,12 @@ static int pvr2_encoder_read_words(struc
 		data += chunkCnt;
 		dlen -= chunkCnt;
--
 	while (src[cnt] && (cnt + 1) < dst_max) {
 		dst[cnt] = src[cnt];
 		cnt++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (hdw->ctl_write_pend_flag || hdw->ctl_read_pend_flag) {
 		wait_for_completion(&hdw->ctl_done);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (ucnt < ccnt) {
 		lcnt = 0;
 		while ((lcnt + ucnt < ccnt) && (buf[lcnt + ucnt] != '\n')) {
@@ -5040,6 +5067,12 @@ static void pvr2_hdw_state_log_state(str
 		}
 		printk(KERN_INFO "%s %.*s\n", hdw->name, lcnt, buf + ucnt);
 		ucnt += lcnt + 1;
+		if (_cur < timeout) {
--
 		while (sp->buffer_total_count < cnt) {
 			struct pvr2_buffer *bp;
 			bp = kmalloc(sizeof(*bp),GFP_KERNEL);
@@ -340,8 +345,19 @@ static int pvr2_stream_buffer_count(stru
 			sp->buffers[sp->buffer_total_count] = bp;
 			(sp->buffer_total_count)++;
--
 		while (sp->buffer_total_count > cnt) {
 			struct pvr2_buffer *bp;
 			bp = sp->buffers[sp->buffer_total_count - 1];
@@ -350,6 +366,12 @@ static int pvr2_stream_buffer_count(stru
 			(sp->buffer_total_count)--;
 			pvr2_buffer_done(bp);
--
 	while ((lp = sp->queued_list.next) != &sp->queued_list) {
 		bp1 = list_entry(lp,struct pvr2_buffer,list_overhead);
 		pvr2_buffer_wipe(bp1);
@@ -409,6 +436,12 @@ static void pvr2_stream_internal_flush(s
 		   here first. */
 		if (bp1->state != pvr2_buffer_state_queued) continue;
--
 			while (tcnt) {
 				bcnt = tcnt;
 				if (bcnt > sizeof(hdw->cmd_buffer)-1) {
@@ -430,6 +435,12 @@ static int pvr2_i2c_xfer(struct i2c_adap
 				}
 				offs += bcnt;
--
 			while (tcnt || wcnt) {
 				bcnt = tcnt;
 				if (bcnt > sizeof(hdw->cmd_buffer)-1) {
@@ -473,6 +489,12 @@ static int pvr2_i2c_xfer(struct i2c_adap
 				offs += bcnt;
 				tcnt -= bcnt;
--
 	while (!kthread_should_stop()) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (bufSize) {
 		if (!mMode) {
 			cnt = 0;
@@ -176,6 +181,12 @@ int pvr2_std_str_to_id(v4l2_std_id *idPt
 		if (cnt < bufSize) cnt++;
 		bufPtr += cnt;
--
 	while (count--) {
 		int val = hex_to_bin(*buf++);
 		if (val < 0 || val >= radix)
 			return -EINVAL;
 		result *= radix;
 		result += val;
--
 	while (count) {
 		for (bcnt = 0; bcnt < count; bcnt++) {
 			if (buf[bcnt] == '\n') break;
@@ -318,6 +334,12 @@ int pvr2_debugifc_docmd(struct pvr2_hdw
 		if (bcnt < count) bcnt++;
 		buf += bcnt;
--
 	while ((map[i].rfmax * 1000) < *freq) {
 		if (tda18271_debug & DBG_ADV)
 			tda_map("(%d) rfmax = %d < freq = %d, "
@@ -1037,6 +1042,12 @@ int tda18271_lookup_rf_band(struct dvb_f
 		if (map[i].rfmax == 0)
 			return -EINVAL;
--
 	while (reg_pair[i].reg || reg_pair[i].val) {
 		if (reg_pair[i].reg == reg) {
 			reg_pair[i].val &= ~mask;
@@ -184,6 +189,12 @@ static void set_reg_bits(struct reg_pair
 		}
 		i++;
--
 	while (reg_pair1[i].reg || reg_pair1[i].val) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (reg_pair2[j].reg || reg_pair2[j].val) {
 			if (reg_pair1[i].reg != reg_pair2[j].reg) {
 				j++;
@@ -203,8 +224,20 @@ static void copy_reg_bits(struct reg_pai
 			}
 			reg_pair2[j].val = reg_pair1[i].val;
--
-			while (pos < len) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (pos < len) {
 				if ((len - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)
 					nbytes_to_send =
 						XC_MAX_I2C_WRITE_LENGTH;
@@ -366,6 +371,12 @@ static int xc_load_i2c_sequence(struct d
 					return result;
--
-			while (pos < len) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (pos < len) {
 				if ((len - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)
 					nbytes_to_send =
 						XC_MAX_I2C_WRITE_LENGTH;
@@ -355,6 +360,12 @@ static int xc_load_i2c_sequence(struct d
 					return result;
--
-	while (p < endp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (p < endp) {
 		__u32 type, size;
 		v4l2_std_id id;
 		__u16 int_freq = 0;
@@ -827,6 +843,12 @@ static int xc4000_fwupload(struct dvb_fr
 		priv->firm[n].int_freq = int_freq;
--
 	while (!kthread_should_stop()) {
 
 		spin_lock_irq(&raw->lock);
@@ -69,6 +74,12 @@ static int ir_raw_event_thread(void *dat
 			handler->decode(raw->dev, ev);
 		raw->prev_ev = ev;
--
 	while (next_one < size) {
 		next_zero = find_next_zero_bit_le(ldata, size, next_one + 1);
 		ev.pulse = false;
@@ -215,6 +220,12 @@ static void ite_decode_bytes(struct ite_
 			    (dev->rdev, &ev);
 		} else
--
 	while (start <= end) {
 		mid = (start + end) / 2;
 		if (rc_map->scan[mid].scancode < scancode)
@@ -422,6 +427,12 @@ static unsigned int ir_lookup_by_scancod
 			end = mid - 1;
 		else
--
 	while (inb(data->sbase + WBCIR_REG_SP3_LSR) & WBCIR_RX_AVAIL) {
 		irdata = inb(data->sbase + WBCIR_REG_SP3_RXDATA);
 		if (data->rxstate == WBCIR_RXSTATE_ERROR)
@@ -360,6 +365,12 @@ wbcir_irq_rx(struct wbcir_data *data, st
 		rawir.pulse = irdata & 0x80 ? false : true;
 		rawir.duration = US_TO_NS((irdata & 0x7F) * 10);
--
 		while (nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY_IDX)) {
 			val = nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY);
 			nvt_dbg("setting wake up key: 0x%x", val);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!list_empty(&coredev->clients)) {
 		client = (struct smscore_client_t *) coredev->clients.next;
 		client->onremove_handler(client->context);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!list_empty(&coredev->buffers)) {
 			cb = (struct smscore_buffer_t *) coredev->buffers.next;
 			list_del(&cb->entry);
 			kfree(cb);
 			num_buffers++;
+			if (_cur < timeout) {
--
-	while (!list_empty(&client->idlist)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&client->idlist)) {
 		struct smscore_idlist_t *identry =
 			(struct smscore_idlist_t *) client->idlist.next;
 		list_del(&identry->entry);
 		kfree(identry);
+		if (_cur < timeout) {
--
 	while (!list_empty(&g_smscore_notifyees)) {
 		struct smscore_device_notifyee_t *notifyee =
 			(struct smscore_device_notifyee_t *)
@@ -1619,10 +1657,21 @@ static void __exit smscore_module_exit(v
 
 		list_del(&notifyee->entry);
--
 	while (!list_empty(&g_smscore_registry)) {
 		struct smscore_registry_entry_t *entry =
 			(struct smscore_registry_entry_t *)
@@ -1630,6 +1679,12 @@ static void __exit smscore_module_exit(v
 
 		list_del(&entry->entry);
--
-	while (size >= smsdev->func->cur_blksize) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size >= smsdev->func->cur_blksize) {
 		ret = sdio_memcpy_toio(smsdev->func, SMSSDIO_DATA,
 					buffer, smsdev->func->cur_blksize);
 		if (ret)
@@ -95,6 +100,12 @@ static int smssdio_sendrequest(void *con
 
--
-			while (size) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (size) {
 				ret = sdio_memcpy_fromio(smsdev->func,
 						  buffer, SMSSDIO_DATA,
 						  smsdev->func->cur_blksize);
@@ -214,6 +230,12 @@ static void smssdio_interrupt(struct sdi
 					size -= smsdev->func->cur_blksize;
--
-	while (mantis->last_block != mantis->busy_block) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (mantis->last_block != mantis->busy_block) {
 		dprintk(MANTIS_DEBUG, 1, "last block=[%d] finished block=[%d]",
 			mantis->last_block, mantis->busy_block);
 
 		(config->ts_size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)
 		(&mantis->demux, &mantis->buf_cpu[mantis->last_block * MANTIS_BLOCK_BYTES], MANTIS_BLOCK_BYTES);
--
 	while (i < num) {
 		/* Byte MODE */
 		if ((config->i2c_mode & MANTIS_BYTE_MODE) &&
@@ -196,6 +201,12 @@ static int mantis_i2c_xfer(struct i2c_ad
 				goto bail_out;
 		}
--
-	while (dev->EventQueueReadIndex != dev->EventQueueWriteIndex) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (dev->EventQueueReadIndex != dev->EventQueueWriteIndex) {
 		struct EVENT_BUFFER Event =
 			dev->EventQueue[dev->EventQueueReadIndex];
 		dev->EventQueueReadIndex =
@@ -86,6 +91,12 @@ static void event_tasklet(unsigned long
 		if ((Event.UARTStatus & 0x02) && (dev->RxEventNotify))
--
-	while (left) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (left) {
 		if (wait_event_interruptible(
 			    dev->tsin_rbuf.queue,
 			    dvb_ringbuffer_avail(&dev->tsin_rbuf) > 0) < 0)
@@ -84,6 +89,12 @@ static ssize_t ts_read(struct file *file
 		dvb_ringbuffer_read_user(&dev->tsin_rbuf, buf, avail);
--
 	while (len) {
 		*p = swab32(*p);
 		p++;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (card->bt->last_block != card->bt->finished_block) {
 		(card->bt->TS_Size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)
 			(&card->demux,
@@ -63,6 +68,12 @@ static void dvb_bt8xx_task(unsigned long
 			 card->bt->block_bytes);
 		card->bt->last_block = (card->bt->last_block + 1) %
--
 			while (p-- != tab) {
 				vfree(p[0]->data);
 				p[0]->data = NULL;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while (c < count && p->found < p->plength + 6) {
 				l = count - c;
 				if (l + p->found > p->plength + 6)
@@ -377,6 +382,12 @@ int av7110_ipack_instant_repack (const u
 				write_ipack(p, buf + c, l);
 				p->found += l;
--
 	while (c < length - 3 && !found) {
 		if (buf[c] == 0x00 && buf[c + 1] == 0x00 &&
 		    buf[c + 2] == 0x01) {
@@ -626,6 +631,12 @@ static int find_pes_header(u8 const *buf
 			}
 		} else
--
 	while (c < length) {
 		c2 = find_pes_header(buf + c + add, length - c - add, &p->frags);
 		if (c2 >= 0) {
@@ -734,6 +750,12 @@ void av7110_p2t_write(u8 const *buf, lon
 			p->pos = rest;
 			c = length;
--
 	while (c < length) {
 		memset(obuf, 0, TS_SIZE);
 		if (length - c >= (TS_SIZE - 4)){
@@ -817,6 +844,12 @@ static void p_to_t(u8 const *buf, long i
 		}
 		feed->cb.ts(obuf, 188, NULL, 0, &feed->feed.ts, DMX_OK);
--
 	while (!kthread_should_stop()) {
 		try_to_freeze();
 
@@ -328,6 +333,12 @@ static int pt1_thread(void *data)
 			if (++table_index >= pt1_nr_tables)
 				table_index = 0;
--
 	while (i < pt1_nr_tables) {
 		ret = pt1_init_table(pt1, &tables[i], &pfn);
 		if (ret)
 			goto err;
 		tables[i - 1].page->next_pfn = cpu_to_le32(pfn);
 		i++;
--
 			while (len--) {
 				next_msg->buf[len] = word;
 				word >>= 8;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
--
 		while (stream->buf_num) {
 			stream->buf_num--;
 			deb_mem("freeing buffer %d\n",stream->buf_num);
 			usb_free_coherent(stream->udev, stream->buf_size,
 					  stream->buf_list[stream->buf_num],
 					  stream->dma_addr[stream->buf_num]);
--
 	while (i < num) {
 		if (msg[i].addr == af9015_af9013_config[0].demod_address ||
 		    msg[i].addr == af9015_af9013_config[1].demod_address) {
@@ -342,6 +347,12 @@ Due to that the only way to select corre
 		if (ret)
 			goto error;
--
 	while (i < num) {
 		if (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {
 			if (msg[i].addr == ec168_ec100_config.demod_address) {
@@ -173,6 +178,12 @@ static int ec168_i2c_xfer(struct i2c_ada
 		if (ret)
 			goto error;
--
-		while (rc_seq->address) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (rc_seq->address) {
 			if ((ret = m920x_write(d->udev, M9206_CORE,
 					       rc_seq->data,
 					       rc_seq->address)) != 0) {
@@ -80,6 +85,12 @@ static int m920x_init(struct dvb_usb_dev
 			}
--
 	while (left) {
 		if (input->cbuf == idx)
 			return count - left;
@@ -534,6 +539,12 @@ static ssize_t ddb_input_read(struct ddb
 		left -= free;
 		ddbwritel((input->cbuf << 11) | (input->coff >> 7),
--
-		while (input->cbuf != ((input->stat >> 11) & 0x1f)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (input->cbuf != ((input->stat >> 11) & 0x1f)
 		       || (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))) {
 			dvb_dmx_swfilter_packets(&input->demux,
 						 input->vbuf[input->cbuf],
@@ -1016,7 +1032,13 @@ static void input_tasklet(unsigned long
 			ddbwritel((input->cbuf << 11),
--
 	while (wlen) {
 		data <<= 8;
 		data |= *wbuf;
 		wlen--;
 		wbuf++;
+		if (_cur < timeout) {
--
 	while (count--) {
 		if (buf[0] == 0x47)
 			dvb_dmx_swfilter_packet(demux, buf);
 		buf += 188;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!kthread_should_stop()) {
 		/* sleep for a bit */
 		if (!ca->wakeup) {
@@ -999,6 +1004,11 @@ static int dvb_ca_en50221_thread(void *d
 			mutex_lock(&ca->slot_info[slot].slot_lock);
 
--
 			while (dvb_ca_en50221_check_camstatus(ca, slot)) {
 				/* clear down an old CI slot if necessary */
 				if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE)
@@ -1012,6 +1022,12 @@ static int dvb_ca_en50221_thread(void *d
 				/* we've handled one CAMCHANGE */
 				dvb_ca_en50221_thread_update_delay(ca);
--
 	while (fragpos < count) {
 		fraglen = ca->slot_info[slot].link_buf_size - 2;
 		if ((count - fragpos) < fraglen)
@@ -1344,6 +1371,12 @@ static ssize_t dvb_ca_en50221_io_write(s
 		}
 
--
 	while ((slot_count < ca->slot_count) && (!found)) {
 		if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
 			goto nextslot;
@@ -1392,6 +1430,12 @@ static int dvb_ca_en50221_io_read_condit
 nextslot:
 		slot = (slot + 1) % ca->slot_count;
--
 	while ( !found  && c < count){
 		u8 *b = mbuf+c;
 
@@ -358,6 +363,12 @@ int dvb_filter_get_ac3info(u8 *mbuf, int
 		else {
 			c++;
--
 	while(!ready) {
 		/* calculate the lnb_drift */
 		fepriv->lnb_drift = fepriv->auto_step * fepriv->step_size;
@@ -333,6 +338,12 @@ static int dvb_frontend_swzigzag_autotun
 		}
 
--
 	while (len--) {
 		crc ^= *buf++;
 		crc ^= (u8)crc >> 4;
 		tmp = (u8)crc;
 		crc ^= (tmp ^ (tmp << 1)) << 4;
+		if (_cur < timeout) {
--
-	while (length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (length) {
 		switch (dec->packet_state) {
 
 		case 0:
@@ -729,6 +745,12 @@ static void ttusb_dec_process_urb_frame(
 			       __func__);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		spin_lock_irqsave(&dec->urb_frame_list_lock, flags);
 		if ((item = dec->urb_frame_list.next) != &dec->urb_frame_list) {
 			frame = list_entry(item, struct urb_frame,
@@ -754,6 +781,12 @@ static void ttusb_dec_process_urb_frame_
 
--
 				while (i) {
 					usb_kill_urb(dec->iso_urb[i - 1]);
 					i--;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
--
 	while ((item = dec->urb_frame_list.next) != &dec->urb_frame_list) {
 		frame = list_entry(item, struct urb_frame, urb_frame_list);
 		list_del(&frame->urb_frame_list);
 		kfree(frame);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((item = dec->filter_info_list.next) != &dec->filter_info_list) {
 		finfo = list_entry(item, struct filter_info, filter_info_list);
 		list_del(&finfo->filter_info_list);
 		kfree(finfo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (read_pos < length) {
 		c->operand[write_pos++] = msg[read_pos++];
 		c->operand[write_pos++] = msg[read_pos++];
@@ -1185,6 +1190,12 @@ int avc_ca_pmt(struct firedtv *fdtv, cha
 			read_pos += es_info_length;
 			write_pos += es_info_length;
--
 	while (i < NbData) {
 		while (stv0900_get_bits(intp, FIFO_FULL))
 			;/* checkpatch complains */
 		stv0900_write_reg(intp, DISTXDATA, data[i]);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (l) {
 		r = *n++;
 
@@ -150,6 +155,12 @@ static void dib7000p_write_tab(struct di
 			r++;
 		} while (--l);
 		l = *n++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-		while (pos < fw->size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (pos < fw->size) {
 
 			if ((fw->size - pos) > wlen)
 				cnt = wlen;
@@ -556,6 +561,12 @@ static int tda10048_firmware_upload(stru
 				&fw->data[pos], cnt);
--
 	while (1) {
 		r=*tab++;
 		m=*tab++;
@@ -124,6 +129,12 @@ static void tda10023_writetab(struct tda
 		}
 		else
--
 	while (jiffies - start < timeout &&
 	       !(tda8083_readreg(state, 0x02) & 0x80))
 	{
 		msleep(50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (l) {
 			r = *n++;
 			do {
@@ -847,6 +852,12 @@ static int dib8000_reset(struct dvb_fron
 				r++;
 			} while (--l);
 			l = *n++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
-	while (cx24116_readreg(state, CX24116_REG_EXECUTE)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cx24116_readreg(state, CX24116_REG_EXECUTE)) {
 		msleep(10);
 		if (i++ > 64) {
 			/* Avoid looping forever if the firmware does
@@ -557,6 +562,12 @@ static int cx24116_cmd_execute(struct dv
 				__func__);
--
 	while (l) {
 		r = *n++;
 
@@ -141,6 +146,12 @@ static void dib7000m_write_tab(struct di
 			r++;
 		} while (--l);
 		l = *n++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (time_before(jiffies, t)) {
 		deb_info("waiting for HAB to complete\n");
 		msleep(10);
@@ -193,6 +198,12 @@ static int bcm3510_hab_send_request(stru
 
 		if (!v.HABSTAT_a8.HABR)
--
 	while (time_before(jiffies, t)) {
 		msleep(10);
 		if ((ret = bcm3510_readB(st,0xa2,&v)) < 0)
@@ -677,6 +693,12 @@ static int bcm3510_reset(struct bcm3510_
 
 		if (v.APSTAT1_a2.RESET)
--
 	while (time_before(jiffies, t)) {
 		msleep(10);
 		if ((ret = bcm3510_readB(st,0xa2,&v)) < 0)
@@ -701,6 +728,12 @@ static int bcm3510_clear_reset(struct bc
 		/* verify that reset is cleared */
 		if (!v.APSTAT1_a2.RESET)
--
 	while (l) {
 		r = pgm_read_word(n++);
 		do {
@@ -683,6 +688,12 @@ static int dib0070_reset(struct dvb_fron
 			r++;
 		} while (--l);
 		l = pgm_read_word(n++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (pos != len) {
 		// work out how much to send this time
 		tx_size = len - pos;
@@ -346,6 +351,12 @@ static int tda1004x_do_upload(struct tda
 		pos += tx_size;
 
--
 	while (!STB0899_GETFIELD(RXEND, reg)) {
 		reg = stb0899_read_reg(state, STB0899_DISRX_ST0);
 		if (jiffies - start > timeout) {
@@ -730,6 +735,12 @@ static int stb0899_wait_diseqc_rxidle(st
 			return -ETIMEDOUT;
 		}
--
 	while (!STB0899_GETFIELD(TXIDLE, reg)) {
 		reg = stb0899_read_reg(state, STB0899_DISSTATUS);
 		if (jiffies - start > timeout) {
@@ -779,6 +795,12 @@ static int stb0899_wait_diseqc_txidle(st
 			return -ETIMEDOUT;
 		}
--
 	while (fw_pos < SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET){
 		tx_len = (fw_pos <= SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - 252) ? 252 : SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - fw_pos;
 		// write register 0xCF0A
@@ -136,6 +141,12 @@ static int sp8870_firmware_upload (struc
 			return err;
 		}
--
 	while (txlen) {
 		dibx000_read_word(mst, mst->base_reg + 2);
 
@@ -124,6 +129,12 @@ static int dibx000_master_i2c_write(stru
 		if (dibx000_is_i2c_done(mst) != 0)
 			return -EREMOTEIO;
--
 	while (rxlen) {
 		len = rxlen > 8 ? 8 : rxlen;
 		da = (((u8) (msg->addr)) << 9) |
@@ -158,6 +174,11 @@ static int dibx000_master_i2c_read(struc
 
 		rxlen -= len;
--
 		while (len) {
 			da = dibx000_read_word(mst, mst->base_reg);
 			*b++ = (da >> 8) & 0xff;
@@ -166,6 +187,18 @@ static int dibx000_master_i2c_read(struc
 				*b++ =  da   & 0xff;
 				len--;
--
 	while ((cx24123_readreg(state, 0x20) & 0x80)) {
 		if (time_after(jiffies, timeout)) {
 			err("%s:  demodulator is not responding," \
@@ -650,6 +655,12 @@ static int cx24123_pll_writereg(struct d
 			return -EREMOTEIO;
 		}
--
 	while ((!lock) && (time < timeout)) {
 		reg = stb0899_read_reg(state, STB0899_CFGPDELSTATUS1);
 		dprintk(state->verbose, FE_DEBUG, 1, "---------> CFGPDELSTATUS=[0x%02x]", reg);
 		lock = STB0899_GETFIELD(CFGPDELSTATUS_LOCK, reg);
 		time++;
+		if (_cur < timeout) {
--
 	while (stv0299_readreg(state, 0x0a) & 1) {
 		if (jiffies - start > timeout) {
 			dprintk ("%s: timeout!!\n", __func__);
 			return -ETIMEDOUT;
 		}
 		msleep(10);
--
 	while (l) {
 		r = pgm_read_word(n++);
 		do {
@@ -1420,6 +1425,12 @@ static void dib0090_set_default_config(s
 			r++;
 		} while (--l);
 		l = pgm_read_word(n++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (link_top(graph) < stack_top(graph)->num_links) {
 		struct media_entity *entity = stack_top(graph);
 		struct media_link *link = &entity->links[link_top(graph)];
@@ -190,6 +195,12 @@ media_entity_graph_walk_next(struct medi
 		/* Push the new entity to stack and start over. */
 		link_top(graph)++;
--
 	while ((entity = media_entity_graph_walk_next(&graph))) {
 		entity->stream_count++;
 		WARN_ON(entity->pipe && entity->pipe != pipe);
 		entity->pipe = pipe;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((entity = media_entity_graph_walk_next(&graph))) {
 		entity->stream_count--;
 		if (entity->stream_count == 0)
 			entity->pipe = NULL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while ((skb = skb_dequeue(&fmdev->rx_q))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&fmdev->rx_q))) {
 		if (skb->len < sizeof(struct fm_event_msg_hdr)) {
 			fmerr("skb(%p) has only %d bytes, "
 				"at least need %zu bytes to decode\n", skb,
@@ -337,6 +342,12 @@ static void recv_tasklet(unsigned long a
 		if (num_fm_hci_cmds && atomic_read(&fmdev->tx_cnt))
--
 	while (i--) {
 		if ((bitmask & 0x8000000000000000ull) != 0) {
 			outb(0x80, zol->io);
@@ -154,6 +159,12 @@ static int zol_setfreq(struct zoltrix *z
 			udelay(50);
 		}
--
 	while (radio->wr_index == radio->rd_index) {
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EWOULDBLOCK;
@@ -478,6 +483,12 @@ static ssize_t si470x_fops_read(struct f
 			retval = -EINTR;
 			goto done;
--
 	while (bits--) {
 		if (data & 1) {
 			outb(5, io);
@@ -78,6 +83,12 @@ static void outbits(int bits, unsigned i
 			udelay(6);
 		}
--
 	while (radio->wr_index == radio->rd_index) {
 		if (file->f_flags & O_NONBLOCK) {
 			r = -EWOULDBLOCK;
@@ -1222,6 +1227,12 @@ static ssize_t wl1273_fm_fops_read(struc
 			r = -EINTR;
 			goto out;
--
 	while (remaining) {
 		if (!mem_len) {
 			sg = sg_next(sg);
@@ -183,6 +188,12 @@ int ft_queue_data_in(struct se_cmd *se_c
 						__func__, fp, ep->xid,
 						remaining, lport->lso_max);
--
 	while (frame_len) {
 		if (!mem_len) {
 			sg = sg_next(sg);
@@ -310,7 +326,13 @@ void ft_recv_write_data(struct ft_cmd *c
 		mem_off += tlen;
 		mem_len -= tlen;
--
 	while (!list_empty(&drain_task_list)) {
 		task = list_entry(drain_task_list.next, struct se_task, t_state_list);
 		list_del(&task->t_state_list);
@@ -293,6 +298,12 @@ static void core_tmr_drain_task_list(
 		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 
--
 	while (!list_empty(&drain_cmd_list)) {
 		cmd = list_entry(drain_cmd_list.next, struct se_cmd, se_queue_node);
 		list_del_init(&cmd->se_queue_node);
@@ -348,6 +364,12 @@ static void core_tmr_drain_cmd_list(
 
 		core_tmr_handle_tas_abort(tmr_nacl, cmd, tas,
--
 	while (len < cmd->data_length) {
 		alua_access_state = (ptr[0] & 0x0f);
 		/*
@@ -348,7 +353,13 @@ int target_emulate_set_target_port_group
 
 		ptr += 4;
--
-		while (bio_add_page(bio, sg_page(sg), sg->length, sg->offset)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (bio_add_page(bio, sg_page(sg), sg->length, sg->offset)
 				!= sg->length) {
 			bio = iblock_get_bio(task, block_lba, sg_num);
 			if (!bio)
 				goto fail;
 			bio_list_add(&list, bio);
--
-		while (i < (4 + page_83[3])) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i < (4 + page_83[3])) {
 			vpd->device_identifier[j++] =
 				hex_str[(page_83[i] & 0xf0) >> 4];
 			vpd->device_identifier[j++] =
 				hex_str[page_83[i] & 0x0f];
 			i++;
--
 	while (!list_empty(&dispose_list)) {
 		task = list_first_entry(&dispose_list, struct se_task, t_list);
 
@@ -3320,6 +3336,12 @@ static void transport_free_dev_tasks(str
 		list_del(&task->t_list);
 
--
 	while (length) {
 		u32 page_len = min_t(u32, length, PAGE_SIZE);
 		page = alloc_page(GFP_KERNEL | __GFP_ZERO);
@@ -3511,6 +3538,12 @@ transport_generic_get_mem(struct se_cmd
 		sg_set_page(&cmd->t_data_sg[i], page, page_len, 0);
 		length -= page_len;
--
-	while (!list_empty(&lun->lun_cmd_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&lun->lun_cmd_list)) {
 		cmd = list_first_entry(&lun->lun_cmd_list,
 		       struct se_cmd, se_lun_node);
 		list_del(&cmd->se_lun_node);
@@ -4212,6 +4250,12 @@ check_cond:
 
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		ret = wait_event_interruptible(dev->dev_queue_obj.thread_wq,
 				atomic_read(&dev->dev_queue_obj.queue_cnt) ||
 				kthread_should_stop());
@@ -4724,6 +4773,12 @@ get_cmd:
 		}
--
-	while (total_sg_needed) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
 			max_sg_per_table : total_sg_needed;
 
@@ -191,6 +196,12 @@ static int rd_build_device_space(struct
 
--
 	while (req->rd_size) {
 		u32 len;
 		void *rd_addr;
@@ -409,6 +425,12 @@ static int rd_MEMCPY(struct rd_request *
 
 		/* since we increment, the first sg entry is correct */
--
 	while (*hbio) {
 		bio = *hbio;
 		*hbio = (*hbio)->bi_next;
 		bio->bi_next = NULL;
 		bio_endio(bio, 0);	/* XXX: should be error */
+		if (_cur < timeout) {
--
 	while (hbio) {
 		struct bio *bio = hbio;
 		hbio = hbio->bi_next;
 		bio->bi_next = NULL;
 		bio_endio(bio, 0);	/* XXX: should be error */
+		if (_cur < timeout) {
--
 	while (start < end) {
 		char *key, *value;
 		struct iscsi_param *param;
@@ -1607,6 +1612,12 @@ int iscsi_decode_text_input(
 			}
 			SET_PSTATE_ACCEPTOR(param);
--
 	while ((ts = iscsi_get_ts_from_inactive_list())) {
 
 		spin_lock_bh(&ts->ts_state_lock);
@@ -169,6 +174,12 @@ extern void iscsi_deallocate_thread_sets
 
 		released_count++;
--
-	while (exp_data_sn > data_sn) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (exp_data_sn > data_sn) {
 		if ((cmd->next_burst_len +
 		     conn->conn_ops->MaxRecvDataSegmentLength) <
 		     conn->sess->sess_ops->MaxBurstLength) {
@@ -59,6 +64,12 @@ void iscsit_create_conn_recovery_datain_
 			cmd->next_burst_len = 0;
--
 	while (cmd->write_data_done > write_data_done) {
 		if ((write_data_done + conn->sess->sess_ops->MaxBurstLength) <=
 		     cmd->write_data_done)
 			write_data_done += conn->sess->sess_ops->MaxBurstLength;
 		else
 			break;
--
-	while (data_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (data_len) {
 		u32 space = (sg->length - offset);
 		u32 sub_len = min_t(u32, data_len, space);
 send_pg:
@@ -1360,7 +1365,13 @@ send_pg:
 		data_len -= sub_len;
--
-	while (total_rx < data) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (total_rx < data) {
 		rx_loop = kernel_recvmsg(conn->sock, &msg, iov_p, iov_len,
 					(data - total_rx), MSG_WAITALL);
 		if (rx_loop <= 0) {
@@ -1474,6 +1490,12 @@ static int iscsit_do_rx_data(
 		total_rx += rx_loop;
--
-	while (total_tx < data) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (total_tx < data) {
 		tx_loop = kernel_sendmsg(conn->sock, &msg, iov_p, iov_len,
 					(data - total_tx));
 		if (tx_loop <= 0) {
@@ -1511,6 +1538,12 @@ static int iscsit_do_tx_data(
 		total_tx += tx_loop;
--
-	while (offset < buf_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < buf_len) {
 		size = ((offset + length) > buf_len) ?
 			(buf_len - offset) : length;
 
@@ -77,6 +82,12 @@ int iscsit_dump_data_payload(
 		}
--
 	while (begrun < last_r2tsn) {
 		r2t = iscsit_get_holder_for_r2tsn(cmd, begrun);
 		if (!r2t)
@@ -184,6 +200,12 @@ static int iscsit_handle_r2t_snack(
 			return -1;
 
--
-	while (begrun > data_sn++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (begrun > data_sn++) {
 		data_sn_count++;
 		if ((dr->next_burst_len +
 		     conn->conn_ops->MaxRecvDataSegmentLength) <
@@ -224,6 +251,12 @@ int iscsit_create_recovery_datain_values
 			data_sn_count = 0;
--
-				while (data_sn < begrun) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (data_sn < begrun) {
 					seq->pdu_send_order++;
 					read_data_done +=
 						conn->conn_ops->MaxRecvDataSegmentLength;
 					seq->next_burst_len +=
 						conn->conn_ops->MaxRecvDataSegmentLength;
--
 				while (data_sn < begrun) {
 					seq->pdu_send_order++;
 
@@ -358,6 +407,12 @@ int iscsit_create_recovery_datain_values
 						}
 					}
--
 	while (begrun < last_statsn) {
 		found_cmd = 0;
 
@@ -558,6 +618,12 @@ int iscsit_handle_status_snack(
 		cmd->i_state = ISTATE_SEND_STATUS_RECOVERY;
 		iscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		if (++pdu_count > MAX_LOGIN_PDUS) {
 			pr_err("MAX_LOGIN_PDUS count reached.\n");
 			iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
@@ -726,6 +731,12 @@ static int iscsi_target_do_login(struct
 			login_rsp->flags &= ~ISCSI_FLAG_LOGIN_TRANSIT;
--
 	while (start < end) {
 		if (iscsi_extract_key_value(start, &key, &value) < 0) {
 			ret = -1;
@@ -812,6 +828,12 @@ static int iscsi_target_locate_portal(
 			t_buf = value;
 
--
 		while (stat) {
 			int bit = __ffs(stat);
 			int line = bank * 8 + bit;
 
 			handle_nested_irq(stmpe_gpio->irq_base + line);
 			stat &= ~(1 << bit);
--
 		while (status) {
 			res = ffs(status);
 			n += res;
 			generic_handle_irq(n - 1);
 			status >>= res;
+			if (_cur < timeout) {
--
 	while (status) {
 		int bit = __ffs(status);
 
 		generic_handle_irq(first_irq + bit);
 		status &= ~BIT(bit);
+		if (_cur < timeout) {
--
 	while (new_irqs) {
 		level = __ffs(new_irqs);
 		pca953x_gpio_direction_input(&chip->gpio_chip, level);
 		new_irqs &= ~(1 << level);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (n--) {
 		int ret = mcp23008_read(mcp, reg++);
 		if (ret < 0)
 			return ret;
 		*vals++ = ret;
+		if (_cur < timeout) {
--
 	while (n--) {
 		int ret = mcp23017_read(mcp, reg++);
 		if (ret < 0)
 			return ret;
 		*vals++ = ret;
+		if (_cur < timeout) {
--
 		while (pending) {
 			gpio = __ffs(pending);
 			mask = BIT(gpio);
@@ -257,6 +262,12 @@ static void lnw_irq_handler(unsigned irq
 			/* Clear before handling so we can't lose an edge */
 			writel(mask, gedr);
--
-			while (pending) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (pending) {
 				if (pending & (1 << bit)) {
 					handle_nested_irq(dev->irq_base +
 							  (bank << 3) + bit);
@@ -264,6 +269,12 @@ static irqreturn_t adp5588_irq_handler(i
 
--
 		while (val) {
 			mask = val & -val;
 			j = fls(mask) - 1;
@@ -578,6 +583,12 @@ static void msm_gpio_irq_handler(unsigne
 			val &= ~mask;
 			generic_handle_irq(FIRST_GPIO_IRQ +
--
 		while (stat) {
 			int bit = __ffs(stat);
 			int line = i * 8 + bit;
 
 			handle_nested_irq(tc3589x_gpio->irq_base + line);
 			stat &= ~(1 << bit);
--
 	while (fw_csr_iterator_next(&ci, &key, &value)) {
 		if (last_key == search_key &&
 		    key == (CSR_DESCRIPTOR | CSR_LEAF))
 			return ci.p - 1 + value;
 
 		last_key = key;
--
 	while (fw_csr_iterator_next(&ci, &key, &value)) {
 		switch (key) {
 		case CSR_VENDOR:	id[0] = value; break;
@@ -140,6 +156,12 @@ static void get_ids(const u32 *directory
 		case CSR_SPECIFIER_ID:	id[2] = value; break;
 		case CSR_VERSION:	id[3] = value; break;
--
-	while (fw_csr_iterator_next(&ci, &key, &value)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (fw_csr_iterator_next(&ci, &key, &value)) {
 		switch (key) {
 		case CSR_SPECIFIER_ID:
 			specifier_id = value;
@@ -416,6 +443,12 @@ static int units_sprintf(char *buf, cons
 			version = value;
--
 	while (fw_csr_iterator_next(&ci, &key, &value)) {
 		if (key != (CSR_UNIT | CSR_DIRECTORY))
 			continue;
@@ -696,6 +734,12 @@ static void create_units(struct fw_devic
 
 	skip_unit:
--
-	while (i != end_buffer_index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i != end_buffer_index) {
 		dma_sync_single_for_cpu(ctx->ohci->card.device,
 					ar_buffer_bus(ctx, i),
 					PAGE_SIZE, DMA_FROM_DEVICE);
 		i = ar_next_buffer_index(i);
+		if (_cur < timeout) {
--
 	while (p < end) {
 		next = handle_ar_packet(ctx, p);
 		if (!next)
 			return p;
 		p = next;
+		if (_cur < timeout) {
--
-	while (i != end_buffer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i != end_buffer) {
 		dma_sync_single_for_device(ctx->ohci->card.device,
 					   ar_buffer_bus(ctx, i),
 					   PAGE_SIZE, DMA_FROM_DEVICE);
 		ar_context_link_page(ctx, i);
 		i = ar_next_buffer_index(i);
--
-		while (iso_event) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (iso_event) {
 			i = ffs(iso_event) - 1;
 			tasklet_schedule(
 				&ohci->ir_context_list[i].context.tasklet);
 			iso_event &= ~(1 << i);
+			if (_cur < timeout) {
--
-		while (iso_event) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (iso_event) {
 			i = ffs(iso_event) - 1;
 			tasklet_schedule(
 				&ohci->it_context_list[i].context.tasklet);
 			iso_event &= ~(1 << i);
+			if (_cur < timeout) {
--
 	while (!(d->control & cpu_to_le16(DESCRIPTOR_BRANCH_ALWAYS))) {
 		d++;
 		buffer_dma = le32_to_cpu(d->data_address);
@@ -2722,6 +2782,12 @@ static int handle_ir_packet_per_buffer(s
 					      buffer_dma & ~PAGE_MASK,
 					      le16_to_cpu(d->req_count),
--
-	while (fw_csr_iterator_next(&ci, &key, &value)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (fw_csr_iterator_next(&ci, &key, &value)) {
 		switch (key) {
 
 		case CSR_DEPENDENT_INFO | CSR_OFFSET:
@@ -1054,6 +1059,12 @@ static int sbp2_scan_unit_dir(struct sbp
 				return -ENOMEM;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		port_type = (q >> shift) & 0x03;
 		switch (port_type) {
 		case SELFID_PORT_CHILD:
@@ -97,6 +102,12 @@ static u32 *count_ports(u32 *sid, int *t
 
--
 	while (sid < end) {
 		next_sid = count_ports(sid, &port_count, &child_port_count);
 
@@ -309,6 +325,12 @@ static struct fw_node *build_tree(struct
 
 		sid = next_sid;
--
 	while (&node0->link != &list0) {
 		WARN_ON(node0->port_count != node1->port_count);
 
@@ -498,6 +525,12 @@ static void update_tree(struct fw_card *
 		next1 = fw_node(node1->link.next);
 		fw_node_put(node1);
--
 	while (card->tlabel_mask & (1ULL << tlabel)) {
 		tlabel = (tlabel + 1) & 0x3f;
 		if (tlabel == card->current_tlabel)
 			return -EBUSY;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (handler->offset + handler->length <= region->end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (handler->offset + handler->length <= region->end) {
 		if (is_in_fcp_region(handler->offset, handler->length))
 			other = NULL;
 		else
@@ -592,6 +608,12 @@ int fw_core_add_address_handler(struct f
 			ret = 0;
--
-		while (pfnleft) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (pfnleft) {
 			if (pfnleft > pfncount)
 				pfncurr = pfncount;
 			else
@@ -348,6 +353,12 @@ static int create_gpadl_header(void *kbu
 				      &msgheader->submsglist);
--
 	while (1) {
 		if (msg->header.message_type == HVMSG_NONE) {
 			/* no msg */
@@ -476,6 +481,12 @@ static void vmbus_on_msg_dpc(unsigned lo
 			 */
 			wrmsrl(HV_X64_MSR_EOM, 0);
--
 	while (remain) {
 		if (sscanf(buffer, " lcd_out : %i", &value) == 1)
 			lcd_out = value & 1;
@@ -623,6 +628,12 @@ static ssize_t video_proc_write(struct f
 			--remain;
 		}
 		while (remain && *(buffer - 1) != ';');
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (status & 1) {
 		udelay(1); /* scu processing time is in few u secods */
 		status = ipc_read_status();
@@ -149,6 +154,12 @@ static inline int busy_loop(void) /* Wai
 			dev_err(&ipcdev.pdev->dev, "IPC timed out");
 			return -ETIMEDOUT;
--
 	while (qlist_size) {
 		if ((qlist->vendor == thinkpad_id.vendor ||
 				qlist->vendor == TPACPI_MATCH_ANY) &&
@@ -491,6 +496,12 @@ static unsigned long __init tpacpi_check
 
 		qlist_size--;
--
 	while (*fmt) {
 		char c = *(fmt++);
 		switch (c) {
@@ -589,6 +605,12 @@ static int acpi_evalf(acpi_handle handle
 			va_end(ap);
 			return 0;
--
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "enable") == 0)
 			status = TPACPI_RFK_RADIO_ON;
@@ -1404,6 +1431,12 @@ static int tpacpi_rfk_procfs_write(const
 			status = TPACPI_RFK_RADIO_OFF;
 		else
--
 	while (!res && i < ARRAY_SIZE(tpacpi_driver_attributes)) {
 		res = driver_create_file(drv, tpacpi_driver_attributes[i]);
 		i++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		if (!acpi_evalf(hkey_handle, &hkey, "MHKP", "d")) {
 			pr_err("failed to retrieve HKEY event\n");
@@ -3758,6 +3807,12 @@ static void hotkey_notify(struct ibm_str
 					dev_name(&ibm->acpi->device->dev),
 					event, hkey);
--
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "enable") == 0) {
 			hotkey_enabledisable_warn(1);
@@ -3859,6 +3919,12 @@ static int hotkey_write(char *buf)
 			res = -EINVAL;
 			goto errexit;
--
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "lcd_enable") == 0) {
 			enable |= TP_ACPI_VIDEO_S_LCD;
@@ -4737,6 +4808,12 @@ static int video_write(char *buf)
 				return res;
 		} else
--
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "on") == 0) {
 			newstatus = 1;
@@ -4918,6 +5000,12 @@ static int light_write(char *buf)
 			newstatus = 0;
 		} else
--
-	while ((cmd = next_cmd(&buf))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((cmd = next_cmd(&buf))) {
 		if (sscanf(cmd, "%u", &cmos_cmd) == 1 &&
 		    cmos_cmd >= 0 && cmos_cmd <= 21) {
 			/* cmos_cmd set */
@@ -5007,6 +5100,12 @@ static int cmos_write(char *buf)
 		res = issue_thinkpad_cmos_command(cmos_cmd);
--
 	while ((cmd = next_cmd(&buf))) {
 		if (sscanf(cmd, "%d", &led) != 1 || led < 0 || led > 15)
 			return -EINVAL;
@@ -5424,6 +5528,12 @@ static int led_write(char *buf)
 		rc = led_set_status(led, s);
 		if (rc < 0)
--
-	while ((cmd = next_cmd(&buf))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((cmd = next_cmd(&buf))) {
 		if (sscanf(cmd, "%u", &beep_cmd) == 1 &&
 		    beep_cmd >= 0 && beep_cmd <= 17) {
 			/* beep_cmd set */
@@ -5503,6 +5618,12 @@ static int beep_write(char *buf)
 					beep_cmd))
--
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "up") == 0) {
 			if (level < bright_maxlvl)
@@ -6392,6 +6518,12 @@ static int brightness_write(char *buf)
 			/* new level set */
 		} else
--
 	while ((cmd = next_cmd(&buf))) {
 		if (!tp_features.mixer_no_level_control) {
 			if (strlencmp(cmd, "up") == 0) {
@@ -7067,6 +7204,12 @@ static int volume_write(char *buf)
 			new_mute = 0;
 		else
--
 	while (!rc && (cmd = next_cmd(&buf))) {
 		if (!((fan_control_commands & TPACPI_FAN_CMD_LEVEL) &&
 		      fan_write_cmd_level(cmd, &rc)) &&
@@ -8370,6 +8518,12 @@ static int fan_write(char *buf)
 			rc = -EINVAL;
 		else if (!rc)
--
 			while (ret & 1 << (i - WM831X_IRQ_GPIO_1)) {
 				handle_nested_irq(wm831x->irq_base + i);
 				ret = wm831x_reg_read(wm831x,
 						      WM831X_GPIO_LEVEL);
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (isr) {
 			int irq = fls(isr) - 1;
 			isr &= ~(1 << irq);
@@ -824,6 +829,12 @@ static void menelaus_work(struct work_st
 				handler(menelaus);
 			menelaus_enable_irq(irq);
--
 	while (acks) {
 		int i = __ffs(acks);
 
@@ -387,6 +392,12 @@ static irqreturn_t tps6586x_irq(int irq,
 			handle_nested_irq(tps6586x->irq_base + i);
 
--
 	while (pins) {
 		int pin = __ffs(pins);
 		int regoffset = numregs - (pin / afperreg) - 1;
@@ -272,6 +277,12 @@ int stmpe_set_altfunc(struct stmpe *stmp
 		regs[regoffset] |= af << pos;
 
--
 		while (status) {
 			int bit = __ffs(status);
 			int line = bank * 8 + bit;
 
 			handle_nested_irq(stmpe->irq_base + line);
 			status &= ~(1 << bit);
--
 	while (curr_voltage < tps_comp.uV_max) {
 		curr_voltage = tps_comp.vsel_table[index];
 		if (curr_voltage >= voltage)
 			break;
 		else if (curr_voltage < voltage)
 			index ++;
--
-	while (timeout) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (timeout) {
 		msleep(1);
 
 		ret = wm831x_reg_read(wm831x,
@@ -211,6 +216,12 @@ static int wm831x_auxadc_read_polled(str
 			ret = -EBUSY;
--
-	while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
 			& OMAP_USBTLL_SYSSTATUS_RESETDONE)) {
 		cpu_relax();
 
@@ -751,6 +756,12 @@ static int usbhs_enable(struct device *d
 			ret = -EINVAL;
--
-	while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
 				& (1 << 0))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
--
-	while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
 				& (1 << 1))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
--
-	while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
 				& (1 << 2))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
--
-	while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
 				& (1 << 0))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
--
 	while (!kthread_should_stop()) {
 		unsigned int x, y, p;
 		signed long timeout;
@@ -270,6 +275,12 @@ static int ucb1x00_thread(void *_ts)
 		try_to_freeze();
 
--
 	while (status) {
 		int bit = __ffs(status);
 
 		handle_nested_irq(tc3589x->irq_base + bit);
 		status &= ~(1 << bit);
+		if (_cur < timeout) {
--
 		while (edge_change) {
 			int		i = fls(edge_change) - 1;
 			struct irq_data	*idata;
@@ -545,6 +550,12 @@ static void twl4030_sih_bus_sync_unlock(
 				bytes[byte] |= BIT(off + 0);
 
--
 	while (isr) {
 		irq = fls(isr);
 		irq--;
@@ -616,6 +632,12 @@ static irqreturn_t handle_twl4030_sih(in
 		else
 			pr_err("twl4030: %s SIH, invalid ISR bit %d\n",
--
-	while (numregs) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (numregs) {
 		/* The hardware limit for get page is 4 */
 		u8 curnum = min_t(u8, numregs, 4u);
 
@@ -1039,6 +1044,12 @@ static int get_register_page_interruptib
 		numregs -= curnum;
--
 	while (stat & ~mask) {
 		int irq = __ffs(stat & ~mask);
 
@@ -443,6 +448,12 @@ static int mc13xxx_irq_handle(struct mc1
 
 			ret = mc13xxx_reg_write(mc13xxx, offmask, mask);
--
 		while (resconfig->resource) {
 			err = twl4030_configure_resource(resconfig);
 			if (err)
 				goto resource;
 			resconfig++;
 
--
-  while (pio_instead) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (pio_instead) {
 #endif
     // bytes waiting for RX transfer
     rx_bytes = dev->rx_bytes;
@@ -1071,6 +1076,12 @@ static void rx_schedule (hrz_dev * dev,
 #else
--
-  while (pio_instead) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (pio_instead) {
 #endif
     // bytes in current region waiting for TX transfer
     tx_bytes = dev->tx_bytes;
@@ -1227,6 +1243,12 @@ static void tx_schedule (hrz_dev * const
 #else
--
-  while ((int_source = rd_regl (dev, INT_SOURCE_REG_OFF)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
+    while ((int_source = rd_regl (dev, INT_SOURCE_REG_OFF)
 	  & INTERESTING_INTERRUPTS)) {
     // In the interests of fairness, the handlers below are
     // called in sequence and without immediate return to the head of
@@ -1427,6 +1454,12 @@ static irqreturn_t interrupt_handler(int
       PRINTD (DBG_IRQ|DBG_RX, "rx_data_av asserted");
--
   while (!(idle_channels = rd_regw (dev, TX_STATUS_OFF) & IDLE_CHANNELS_MASK)) {
     PRINTD (DBG_TX|DBG_WARN, "waiting for idle TX channel");
     // delay a bit here
@@ -1476,6 +1514,12 @@ static short setup_idle_tx_channel (hrz_
       PRINTD (DBG_TX|DBG_ERR, "spun out waiting for idle TX channel");
       return -EBUSY;
--
     while (keep_going) {
       if (idle_channels & (1<<chan)) {
 	tx_channel = chan;
@@ -1492,6 +1541,12 @@ static short setup_idle_tx_channel (hrz_
       ++chan;
       if (chan == TX_CHANS)
--
-  while ((free_buffers = rd_regw (dev, TX_FREE_BUFFER_COUNT_OFF)) < buffers_required) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while ((free_buffers = rd_regw (dev, TX_FREE_BUFFER_COUNT_OFF)) < buffers_required) {
     PRINTD (DBG_TX, "waiting for free TX buffers, got %d of %d",
 	    free_buffers, buffers_required);
     // what is the appropriate delay? implement a timeout? (depending on line speed?)
@@ -1682,6 +1742,12 @@ static int hrz_send (struct atm_vcc * at
       hrz_kfree_skb (skb);
--
 	while (x = zin(MWA(mbx)), (pos & 0xffff) != x) {
 		u32 *here;
 		struct sk_buff *skb;
@@ -471,6 +476,12 @@ printk("dummy: 0x%08lx, 0x%08lx\n",dummy
 		ATM_SKB(skb)->vcc = vcc;
 		vcc->push(vcc,skb);
--
-	while (x = zin(MWA(mbx)), (pos & 0xffff) != x) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (x = zin(MWA(mbx)), (pos & 0xffff) != x) {
 		int chan;
 
 #if 1
@@ -775,6 +791,12 @@ NO !
 		}
--
 	while ((reason = zin(GSR))) {
 		handled = 1;
 		EVENT("reason 0x%x\n",reason,0);
@@ -1087,6 +1114,12 @@ static irqreturn_t zatm_int(int irq,void
 			if (reason & 8) poll_tx(dev,3);
 		}
--
 	while (he_dev->rbrq_head != rbrq_tail) {
 		++updated;
 
@@ -1803,6 +1808,12 @@ next_rbrq_entry:
 				((unsigned long) he_dev->rbrq_base |
 					RBRQ_MASK(he_dev->rbrq_head + 1));
--
-	while (he_dev->tbrq_head != tbrq_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (he_dev->tbrq_head != tbrq_tail) {
 		++updated;
 
 		HPRINTK("tbrq%d 0x%x%s%s\n",
@@ -1885,6 +1901,12 @@ next_tbrq_entry:
 		he_dev->tbrq_head = (struct he_tbrq *)
--
 	while (he_dev->irq_head != he_dev->irq_tail) {
 		++updated;
 
@@ -2015,6 +2042,12 @@ he_tasklet(unsigned long data)
 		he_dev->irq_head->isw = ITYPE_INVALID;
 
--
 		while (he_readl(he_dev, RCC_STAT) & RCC_BUSY) {
 			HPRINTK("close cid 0x%x RCC_BUSY\n", cid);
 			udelay(250);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (!((tsr4 = he_readl_tsr4(he_dev, cid)) & TSR4_SESSION_ENDED)) {
 			HPRINTK("close tx cid 0x%x !TSR4_SESSION_ENDED (tsr4 = 0x%x)\n", cid, tsr4);
 			udelay(250);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (TSR0_CONN_STATE(tsr0 = he_readl_tsr0(he_dev, cid)) != 0) {
diff -u -p a/atm/eni.c b/atm/eni.c
--- a/atm/eni.c
+++ b/atm/eni.c
@@ -623,7 +623,12 @@ static inline int rx_vcc(struct atm_vcc
 	eni_vcc = ENI_VCC(vcc);
--
-	while (eni_vcc->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR) >>
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (eni_vcc->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR) >>
 	    MID_VCI_DESCR_SHIFT)) {
 		EVENT("rx_vcc(2: host dsc=0x%lx, nic dsc=0x%lx)\n",
 		    eni_vcc->descr,tmp);
@@ -631,6 +636,12 @@ static inline int rx_vcc(struct atm_vcc
 		    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>
--
-	while (ENI_VCC(vcc)->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ENI_VCC(vcc)->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR)
 	    >> MID_VCI_DESCR_SHIFT)) {
 		EVENT("rx_vcc(4: host dsc=0x%lx, nic dsc=0x%lx)\n",
 		    eni_vcc->descr,tmp);
@@ -648,6 +664,12 @@ static inline int rx_vcc(struct atm_vcc
 		    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>
--
 	while ((curr = eni_dev->fast)) {
 		EVENT("poll_rx.fast\n",0,0);
 		if (rx_vcc(curr)) return;
@@ -666,7 +693,18 @@ static void poll_rx(struct atm_dev *dev)
 		ENI_VCC(curr)->next = ENI_VCC_NOS;
 		barrier();
--
 	while ((curr = eni_dev->slow)) {
 		EVENT("poll_rx.slow\n",0,0);
 		if (rx_vcc(curr)) return;
@@ -674,6 +712,12 @@ static void poll_rx(struct atm_dev *dev)
 		ENI_VCC(curr)->next = ENI_VCC_NOS;
 		barrier();
--
 	while (eni_in(MID_SERV_WRITE) != eni_dev->serv_read) {
 		vci = readl(eni_dev->service+eni_dev->serv_read*4);
 		eni_dev->serv_read = (eni_dev->serv_read+1) & (NR_SERVICE-1);
@@ -718,6 +767,12 @@ static void get_service(struct atm_dev *
 		}
 putting++;
--
-			while ((skb = skb_dequeue(&tx->backlog))) {
-				res = do_tx(skb);
-				if (res == enq_ok) continue;
-				DPRINTK("re-queuing TX PDU\n");
-				skb_queue_head(&tx->backlog,skb);
-requeued++;
--
+				while ((skb = skb_dequeue(&tx->backlog))) {
+					res = do_tx(skb);
+					if (res == enq_ok) continue;
+					DPRINTK("re-queuing TX PDU\n");
+					skb_queue_head(&tx->backlog,skb);
+				requeued++;
--
-	while (lanai->service.ptr != end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (lanai->service.ptr != end) {
 		ntx += handle_service(lanai,
 		    le32_to_cpup(lanai->service.ptr++));
 		if (lanai->service.ptr >= lanai->service.end)
 			lanai->service.ptr = lanai->service.start;
+			if (_cur < timeout) {
--
 	while (pool->skb[index]) {
 		index = (index + 1) & FBQ_MASK;
 		if (index == pool->index)
 			return -ENOBUFS;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while ((skb = skb_dequeue(&scq->transmit))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&scq->transmit))) {
 		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
 				 skb->len, PCI_DMA_TODEVICE);
 
@@ -683,9 +699,20 @@ free_scq(struct idt77252_dev *card, stru
 			vcc->pop(vcc, skb);
--
-	while ((skb = skb_dequeue(&scq->pending))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&scq->pending))) {
 		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
 				 skb->len, PCI_DMA_TODEVICE);
 
@@ -694,6 +721,12 @@ free_scq(struct idt77252_dev *card, stru
 			vcc->pop(vcc, skb);
--
 	while (head != tail) {
 		unsigned int vpi, vci;
 		u32 header;
@@ -1363,6 +1401,12 @@ drop:
 				break;
 			}
--
 	while (count--) {
 		skb = dev_alloc_skb(size);
 		if (!skb)
@@ -1873,6 +1922,12 @@ add_rx_skb(struct idt77252_dev *card, in
 			printk("%s: FB QUEUE full\n", __func__);
 			goto outunmap;
--
 	while (idt77252_chain) {
 		card = idt77252_chain;
 		dev = card->atmdev;
@@ -3783,6 +3843,12 @@ static void __exit idt77252_exit(void)
 		deinit_card(card);
 		pci_disable_device(card->pcidev);
--
 		while (!(man & (1<<31))) {
 			exp = exp - 1;
 			man = man<<1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-	while ((wp = read_fs (dev, Q_WP (q->offset))) & Q_FULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((wp = read_fs (dev, Q_WP (q->offset))) & Q_FULL) {
 		fs_dprintk (FS_DEBUG_TXQ, "Found queue at %x full. Waiting.\n", 
 			    q->offset);
 		schedule ();
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {
 		fs_dprintk (FS_DEBUG_QUEUE, "reaping return queue entry at %lx\n", rq); 
 		qe = bus_to_virt (rq);
@@ -697,6 +724,12 @@ static void process_return_queue (struct
 		}
     
--
 	while (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {
 		fs_dprintk (FS_DEBUG_QUEUE, "reaping txdone entry at %lx\n", rq); 
 		qe = bus_to_virt (rq);
@@ -767,6 +805,12 @@ static void process_txdone_queue (struct
 		}
     
--
 	while (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {
 		fs_dprintk (FS_DEBUG_QUEUE, "reaping incoming queue entry at %lx\n", rq); 
 		qe = bus_to_virt (rq);
@@ -850,6 +899,12 @@ static void process_incoming (struct fs_
 				STATUS_CODE(qe), res_strings[STATUS_CODE (qe)]);
 		}
--
     while (buffer) {
 
 	if (buffer->supplied) {
@@ -979,6 +984,12 @@ int bsq_audit(int where, struct host_bsq
 
 	count++;
--
     while (time_before(jiffies, timeout)) {
 
 	c = (int) fore200e->bus->read(&monitor->soft_uart.recv);
@@ -2471,6 +2487,12 @@ fore200e_monitor_getc(struct fore200e* f
 #endif
 	    return c & 0xFF;
--
     while (*str) {
 
 	/* the i960 monitor doesn't accept any new character if it has something to say */
 	while (fore200e_monitor_getc(fore200e) >= 0);
 	
 	fore200e_monitor_putc(fore200e, *str++);
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
--
     while (fore200e_monitor_getc(fore200e) >= 0);
diff -u -p a/atm/ambassador.c b/atm/ambassador.c
--- a/atm/ambassador.c
+++ b/atm/ambassador.c
@@ -591,17 +591,39 @@ static int command_do (amb_dev * dev, co
     msleep(cq->pending);
--
     while (ptrs->out != my_slot) {
       PRINTD (DBG_CMD, "wait: command slot (now at %p)", ptrs->out);
       set_current_state(TASK_UNINTERRUPTIBLE);
       schedule();
+      if (_cur < timeout) {
+        rdstcll(_cur);
--
     while (ptrs->out->request != cpu_to_be32 (SRB_COMPLETE)) {
       PRINTD (DBG_CMD, "wait: command slot completion");
       set_current_state(TASK_UNINTERRUPTIBLE);
       schedule();
+      if (_cur < timeout) {
+        rdstcll(_cur);
--
   while (rxq->pending < rxq->maximum && rxq->pending < rxq->buffers_wanted) {
     
     struct sk_buff * skb = alloc_skb (rxq->buffer_size, priority);
@@ -808,6 +835,12 @@ static void fill_rx_pool (amb_dev * dev,
     if (rx_give (dev, &rx, pool))
       dev_kfree_skb_any (skb);
--
     while (!(man & (1<<31))) {
       exp = exp - 1;
       man = man<<1;
+      if (_cur < timeout) {
+	rdstcll(_cur);
+      }
--
   while (command_do (dev, &cmd)) {
     set_current_state(TASK_UNINTERRUPTIBLE);
     schedule();
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
--
   while (command_do (dev, &cmd)) {
     set_current_state(TASK_UNINTERRUPTIBLE);
     schedule();
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
--
 	while ((reason = GET(PICR))) {
 		if (reason & uPD98402_INT_LOS)
 			printk(KERN_NOTICE "%s(itf %d): signal lost\n",
@@ -203,6 +208,12 @@ static void uPD98402_int(struct atm_dev
 			    "FIFO overflow\n",dev->type,dev->number);
 			silence = (jiffies+HZ/2)|1;
--
   while (dev->host_tcq_wr != tcq_wr) {
      desc1 = *(u_short *)(dev->seg_ram + dev->host_tcq_wr);
      if (!desc1) ;
@@ -171,6 +176,12 @@ static void ia_hack_tcq(IADEV *dev) {
      dev->host_tcq_wr += 2;
      if (dev->host_tcq_wr > dev->ffL.tcq_ed) 
--
      while (i < dev->num_tx_desc) {
         if (!dev->desc_tbl[i].timestamp) {
            i++;
@@ -210,6 +226,12 @@ static u16 get_desc (IADEV *dev, struct
            dev->desc_tbl[i].txskb = NULL;
         }
--
      } /* while */
   }
   if (dev->ffL.tcq_rd == dev->host_tcq_wr) 
@@ -218,6 +240,11 @@ static u16 get_desc (IADEV *dev, struct
   /* Get the next available descriptor number from TCQ */
   desc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);
--
   while (!desc_num || (dev->desc_tbl[desc_num -1]).timestamp) {
      dev->ffL.tcq_rd += 2;
      if (dev->ffL.tcq_rd > dev->ffL.tcq_ed) 
@@ -225,6 +252,12 @@ static u16 get_desc (IADEV *dev, struct
      if (dev->ffL.tcq_rd == dev->host_tcq_wr) 
         return 0xFFFF; 
--
    while (toBeAssigned)
    {
       // If this is the first time, start the table loading for this connection
@@ -562,6 +600,12 @@ static int ia_cbr_setup (IADEV *dev, str
        memcpy((caddr_t)TstSchedTbl, (caddr_t)&vcIndex, sizeof(*TstSchedTbl));
        dev->CbrRemEntries--;
--
    } /* while */ 
 
    /* IaFFrednCbrEnable */
@@ -663,6 +707,11 @@ static void ia_tx_poll (IADEV *iadev) {
        }
 
--
        while (skb1 && (skb1 != skb)) {
           if (!(IA_SKB_STATE(skb1) & IA_TX_DONE)) {
              printk("IA_tx_intr: Vci %d lost pkt!!!\n", vcc->vci);
@@ -677,6 +726,12 @@ static void ia_tx_poll (IADEV *iadev) {
           else 
              dev_kfree_skb_any(skb1);
--
 	while (len--) {
 		ia_phy_write32(iadev, regs->reg, regs->val);
 		regs++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
     while(count < length){
         pBuf += sprintf( pBuf, "%s", prefix );
         for(col = 0;count + col < length && col < 16; col++){
@@ -1003,6 +1074,12 @@ static void xdump( u_char*  cp, int  len
         printk("%s\n", prntBuf);
         count += col;
--
   while (tcq_st_ptr != tcq_ed_ptr) {
       tmp = iadev->seg_ram+tcq_st_ptr;
       printk("TCQ slot %d desc = %d  Addr = %p\n", i++, readw(tmp), tmp);
       tcq_st_ptr += 2;
+      if (_cur < timeout) {
+  rdstcll(_cur);
--
 	while(!(state & PCQ_EMPTY))  
 	{  
              rx_pkt(dev);  
 	     state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  
-	}  
+	     if (_cur < timeout) {
--
   while(dle != cur_dle)  
   {  
       /* free the DMAed skb */  
@@ -1353,6 +1457,12 @@ static void rx_dle_intr(struct atm_dev *
 INCR_DLE:
       if (++dle == iadev->rx_dle_q.end)  
--
        while (i != iadev->num_vc) {
           i /= 2;
           vcsize_sel++;
+          if (_cur < timeout) {
+       	rdstcll(_cur);
+          }
--
         while (i != iadev->num_vc) {
           i /= 2;
           vcsize_sel++;
+          if (_cur < timeout) {
+        rdstcll(_cur);
+          }
--
    while( (status = readl(iadev->reg+IPHASE5575_BUS_STATUS_REG) & 0x7f))  
    { 
 	handled = 1;
@@ -2252,6 +2389,12 @@ static irqreturn_t ia_int(int irq, void
            if (status & STAT_FEINT) 
                ia_frontend_intr(iadev);
--
            while((skb = skb_dequeue(&iadev->tx_backlog))) {
               if (ATM_SKB(skb)->vcc == vcc){ 
                  if (vcc->pop) vcc->pop(vcc, skb);
@@ -2627,6 +2775,12 @@ static void ia_close(struct atm_vcc *vcc
               }
               else 
--
            while((skb = skb_dequeue(&tmp_tx_backlog))) 
              skb_queue_tail(&iadev->tx_backlog, skb);
diff -u -p a/atm/nicstar.c b/atm/nicstar.c
--- a/atm/nicstar.c
+++ b/atm/nicstar.c
@@ -1164,6 +1164,11 @@ static irqreturn_t ns_irq_handler(int ir
--
 		while (readl(card->membase + RAWCT) != card->rawch) {
 
 			if (ns_rcqe_islast(card->rawcell)) {
@@ -1180,6 +1185,12 @@ static irqreturn_t ns_irq_handler(int ir
 				card->rawch += NS_RCQE_SIZE;
 				card->rawcell++;
--
 	while (scq->tail == scq->next) {
 		if (in_interrupt()) {
 			spin_unlock_irqrestore(&scq->lock, flags);
@@ -1764,6 +1780,12 @@ static int push_scqe(ns_dev * card, vc_m
 			       card->index);
 			return 1;
--
 	while (!ns_tsi_isempty(card->tsq.next) || !ns_tsi_isempty(one_ahead) ||
 	       !ns_tsi_isempty(two_ahead))
 		/* At most two empty, as stated in the 77201 errata */
@@ -1872,11 +1899,22 @@ static void process_tsq(ns_dev * card)
 		serviced_entries = 1;
 
--
 		while (ns_tsi_isempty(card->tsq.next)) {
 			if (card->tsq.next == card->tsq.last)
 				card->tsq.next = card->tsq.base;
 			else
 				card->tsq.next++;
+				if (_cur < timeout) {
--
-	while (i != pos) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i != pos) {
 		skb = scq->skb[i];
 		XPRINTK("nicstar%d: freeing skb at 0x%p (index %d).\n",
 			card->index, skb, i);
@@ -1958,6 +2007,12 @@ static void drain_scq(ns_dev * card, scq
 		}
--
 			while (card->sbfqc < card->sbnr.init) {
 				struct sk_buff *sb;
 
@@ -2681,10 +2741,21 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->sbpool.queue, sb);
 				skb_reserve(sb, NS_AAL0_HEADER);
--
 			while (card->lbfqc < card->lbnr.init) {
 				struct sk_buff *lb;
 
@@ -2695,10 +2766,21 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->lbpool.queue, lb);
 				skb_reserve(lb, NS_SMBUFSIZE);
--
 			while (card->hbpool.count > card->hbnr.init) {
 				struct sk_buff *hb;
 
@@ -2713,7 +2795,18 @@ static int ns_ioctl(struct atm_dev *dev,
 				else
 					dev_kfree_skb_any(hb);
--
 			while (card->hbpool.count < card->hbnr.init) {
 				struct sk_buff *hb;
 
@@ -2725,10 +2818,21 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->hbpool.queue, hb);
 				card->hbpool.count++;
--
 			while (card->iovpool.count > card->iovnr.init) {
 				struct sk_buff *iovb;
 
@@ -2743,7 +2847,18 @@ static int ns_ioctl(struct atm_dev *dev,
 				else
 					dev_kfree_skb_any(iovb);
--
 			while (card->iovpool.count < card->iovnr.init) {
 				struct sk_buff *iovb;
 
@@ -2755,6 +2870,12 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->iovpool.queue, iovb);
 				card->iovpool.count++;
--
 	while (1) {
 		if (dm_bufio_cache_size_latch != 1) {
 			b = alloc_buffer(c, GFP_NOIO | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);
@@ -765,6 +770,12 @@ static struct dm_buffer *__alloc_buffer_
 			return b;
 
--
 	while (c->n_buffers[LIST_CLEAN] + c->n_buffers[LIST_DIRTY] >
 	       limit_buffers) {
 
@@ -862,6 +878,12 @@ static void __check_watermark(struct dm_
 
 		__free_buffer_wake(b);
--
 	while (c->need_reserved_buffers) {
 		struct dm_buffer *b = alloc_buffer(c, GFP_KERNEL);
 
@@ -1480,6 +1507,12 @@ struct dm_bufio_client *dm_bufio_client_
 			goto bad_buffer;
 		}
--
-	while (!list_empty(&c->reserved_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&c->reserved_buffers)) {
 		struct dm_buffer *b = list_entry(c->reserved_buffers.next,
 						 struct dm_buffer, lru_list);
 		list_del(&b->lru_list);
 		free_buffer(b);
+		if (_cur < timeout) {
--
-	while (!list_empty(&c->reserved_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&c->reserved_buffers)) {
 		struct dm_buffer *b = list_entry(c->reserved_buffers.next,
 						 struct dm_buffer, lru_list);
 		list_del(&b->lru_list);
 		free_buffer(b);
+		if (_cur < timeout) {
--
 	while(j--) {
 		bio = r1_bio->bios[j];
 		for (i = 0; i < RESYNC_PAGES; i++) {
@@ -116,6 +121,12 @@ static void * r1buf_pool_alloc(gfp_t gfp
 			bio->bi_io_vec[i].bv_page = page;
 			bio->bi_vcnt = i+1;
--
 		while (bio) { /* submit pending writes */
 			struct bio *next = bio->bi_next;
 			bio->bi_next = NULL;
 			generic_make_request(bio);
 			bio = next;
+			if (_cur < timeout) {
--
 	while(sectors) {
 		int s = sectors;
 		int d = r1_bio->read_disk;
@@ -1566,6 +1593,11 @@ static int fix_sync_read_error(struct r1
 
 		start = d;
--
 		while (d != r1_bio->read_disk) {
 			if (d == 0)
 				d = conf->raid_disks;
@@ -1579,8 +1611,19 @@ static int fix_sync_read_error(struct r1
 				r1_bio->bios[d]->bi_end_io = NULL;
 				rdev_dec_pending(rdev, mddev);
--
 		while (d != r1_bio->read_disk) {
 			if (d == 0)
 				d = conf->raid_disks;
@@ -1592,10 +1635,22 @@ static int fix_sync_read_error(struct r1
 					    bio->bi_io_vec[idx].bv_page,
 					    READ) != 0)
--
 		while (d != read_disk) {
 			if (d==0)
 				d = conf->raid_disks;
@@ -1798,8 +1858,19 @@ static void fix_read_error(struct r1conf
 			    test_bit(In_sync, &rdev->flags))
 				r1_sync_page_io(rdev, sect, s,
--
 		while (d != read_disk) {
 			char b[BDEVNAME_SIZE];
 			if (d==0)
@@ -1820,6 +1891,12 @@ static void fix_read_error(struct r1conf
 					       bdevname(rdev->bdev, b));
 				}
--
 	while (sect_to_write) {
 		struct bio *wbio;
 		if (sectors > sect_to_write)
@@ -1917,6 +1999,12 @@ static int narrow_write_error(struct r1b
 		sect_to_write -= sectors;
 		sector += sectors;
--
 	while ((ds->sweeper != ds->current_entry) &&
 	       !ds->entries[ds->sweeper].count) {
 		list_splice_init(&ds->entries[ds->sweeper].work_items, head);
 		ds->sweeper = ds_next(ds->sweeper);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((bio = bio_list_pop(&bios))) {
 		if (dm_get_mapinfo(bio)->ptr == tc)
 			bio_endio(bio, DM_ENDIO_REQUEUE);
 		else
 			bio_list_add(master, bio);
+			if (_cur < timeout) {
--
 	while (argc && !r) {
 		arg_name = dm_shift_arg(as);
 		argc--;
@@ -1691,6 +1718,12 @@ static int parse_pool_features(struct dm
 
 		ti->error = "Unrecognised pool feature requested";
--
 	while (begin < end) {
 		if (!(begin & (ENTRIES_PER_WORD - 1)) &&
 		    bitmap_word_used(addr, begin)) {
@@ -181,6 +186,12 @@ static int sm_find_free(void *addr, unsi
 		}
 
--
 	while (unprocessed_frames(s)) {
 		uint32_t flags;
 		struct frame *f;
@@ -285,6 +290,12 @@ int dm_btree_del(struct dm_btree_info *i
 			}
 			f->current_child = f->nr_children;
--
 	while (bio->bi_idx < bio->bi_vcnt &&
 	       bio->bi_io_vec[bio->bi_idx].bv_len <= offset) {
 		/* remove this whole bio_vec */
 		offset -= bio->bi_io_vec[bio->bi_idx].bv_len;
 		bio->bi_idx++;
+		if (_cur < timeout) {
--
 		while (!is_free) {
 			dev = MKDEV(MD_MAJOR, next_minor);
 			next_minor++;
@@ -667,6 +683,12 @@ static struct mddev * mddev_find(dev_t u
 					is_free = 0;
 					break;
--
 	while (*cmd && *str && *cmd == *str) {
 		cmd++;
 		str++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (decimals < scale) {
 		result *= 10;
 		decimals ++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 
 		/* We need to wait INTERRUPTIBLE so that
 		 * we don't add to the load-average.
@@ -6436,6 +6485,12 @@ static int md_thread(void * arg)
 		clear_bit(THREAD_WAKEUP, &thread->flags);
--
 		while (j >= mddev->resync_max && !kthread_should_stop()) {
 			/* As this condition is controlled by user-space,
 			 * we can block indefinitely, so use '_interruptible'
@@ -7209,6 +7269,12 @@ void md_do_sync(struct mddev *mddev)
 			wait_event_interruptible(mddev->recovery_wait,
 						 mddev->resync_max > j
--
 	while (sectors) {
 		/* didn't merge (it all).
 		 * Need to add a range just before 'hi' */
@@ -7861,6 +7932,12 @@ static int md_set_badblocks(struct badbl
 			sectors -= this_sectors;
 			s += this_sectors;
--
 	while (bi) {
 
 		return_bi = bi->bi_next;
@@ -178,6 +183,12 @@ static void return_io(struct bio *return
 		bi->bi_size = 0;
 		bio_endio(bi, 0);
--
 			while (rbi && rbi->bi_sector <
 				dev->sector + STRIPE_SECTORS) {
 				rbi2 = r5_next_bio(rbi, dev->sector);
@@ -682,6 +698,12 @@ static void ops_complete_biofill(void *s
 					return_bi = rbi;
 				}
--
-			while (rbi && rbi->bi_sector <
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (rbi && rbi->bi_sector <
 				dev->sector + STRIPE_SECTORS) {
 				tx = async_copy_data(0, rbi, dev->page,
 					dev->sector, tx);
 				rbi = r5_next_bio(rbi, dev->sector);
+				if (_cur < timeout) {
--
-			while (wbi && wbi->bi_sector <
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (wbi && wbi->bi_sector <
 				dev->sector + STRIPE_SECTORS) {
 				if (wbi->bi_rw & REQ_FUA)
 					set_bit(R5_WantFUA, &dev->flags);
 				tx = async_copy_data(1, wbi, dev->page,
 					dev->sector, tx);
--
 		while (!list_empty(&newstripes)) {
 			nsh = list_entry(newstripes.next, struct stripe_head, lru);
 			list_del(&nsh->lru);
 			kmem_cache_free(sc, nsh);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while(!list_empty(&newstripes)) {
 		nsh = list_entry(newstripes.next, struct stripe_head, lru);
 		list_del_init(&nsh->lru);
@@ -1549,6 +1609,12 @@ static int resize_stripes(struct r5conf
 					err = -ENOMEM;
 			}
--
 	while (*bip && (*bip)->bi_sector < bi->bi_sector) {
 		if ((*bip)->bi_sector + ((*bip)->bi_size >> 9) > bi->bi_sector)
 			goto overlap;
 		bip = & (*bip)->bi_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (bi && bi->bi_sector <
 			sh->dev[i].sector + STRIPE_SECTORS) {
 			struct bio *nextbi = r5_next_bio(bi, sh->dev[i].sector);
@@ -2306,11 +2388,22 @@ handle_failed_stripe(struct r5conf *conf
 				*return_bi = bi;
 			}
--
 		while (bi && bi->bi_sector <
 		       sh->dev[i].sector + STRIPE_SECTORS) {
 			struct bio *bi2 = r5_next_bio(bi, sh->dev[i].sector);
@@ -2321,6 +2414,12 @@ handle_failed_stripe(struct r5conf *conf
 				*return_bi = bi;
 			}
--
-			while (bi && bi->bi_sector <
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (bi && bi->bi_sector <
 			       sh->dev[i].sector + STRIPE_SECTORS) {
 				struct bio *nextbi =
 					r5_next_bio(bi, sh->dev[i].sector);
@@ -2344,6 +2448,12 @@ handle_failed_stripe(struct r5conf *conf
 					*return_bi = bi;
--
 				while (wbi && wbi->bi_sector <
 					dev->sector + STRIPE_SECTORS) {
 					wbi2 = r5_next_bio(wbi, dev->sector);
@@ -2538,6 +2653,12 @@ static void handle_stripe_clean_event(st
 						*return_bi = wbi;
 					}
--
 		while (!list_empty(&conf->delayed_list)) {
 			struct list_head *l = conf->delayed_list.next;
 			struct stripe_head *sh;
@@ -3407,6 +3533,12 @@ static void raid5_activate_delayed(struc
 			if (!test_and_set_bit(STRIPE_PREREAD_ACTIVE, &sh->state))
 				atomic_inc(&conf->preread_active_stripes);
--
 	while (!list_empty(&head)) {
 		struct stripe_head *sh = list_entry(head.next, struct stripe_head, lru);
 		list_del_init(&sh->lru);
 		atomic_inc(&sh->count);
 		__release_stripe(conf, sh);
+		if (_cur < timeout) {
--
 	while (first_sector <= last_sector) {
 		sh = get_active_stripe(conf, first_sector, 1, 0, 1);
 		set_bit(STRIPE_EXPAND_SOURCE, &sh->state);
 		set_bit(STRIPE_HANDLE, &sh->state);
 		release_stripe(sh);
 		first_sector += STRIPE_SECTORS;
--
 	while (!list_empty(&stripes)) {
 		sh = list_entry(stripes.next, struct stripe_head, lru);
 		list_del_init(&sh->lru);
 		release_stripe(sh);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (size < conf->max_nr_stripes) {
 		if (drop_one_stripe(conf))
 			conf->max_nr_stripes--;
 		else
 			break;
+			if (_cur < timeout) {
--
 	while (size > conf->max_nr_stripes) {
 		if (grow_one_stripe(conf))
 			conf->max_nr_stripes++;
 		else break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (pl) {
 		next = pl->next;
 		free_pl(pl);
 		pl = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (origin_write_extent(s, dest.sector, io_size)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (origin_write_extent(s, dest.sector, io_size)) {
 		wait_event(_pending_exceptions_done,
 			   (read_pending_exceptions_done_count() !=
 			    previous_count));
 		/* Retry after the wait, until all exceptions are done. */
 		previous_count = read_pending_exceptions_done_count();
--
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
 		generic_make_request(bio);
 		bio = n;
+		if (_cur < timeout) {
--
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
@@ -1357,6 +1384,12 @@ static void retry_origin_bios(struct dm_
 		if (r == DM_MAPIO_REMAPPED)
 			generic_make_request(bio);
--
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
 		bio_io_error(bio);
 		bio = n;
+		if (_cur < timeout) {
--
 	while(ctx->idx_in < ctx->bio_in->bi_vcnt &&
 	      ctx->idx_out < ctx->bio_out->bi_vcnt) {
 
@@ -803,6 +808,12 @@ static int crypt_convert(struct crypt_co
 			atomic_dec(&ctx->pending);
 			return r;
--
 	while (as.argc) {
 		struct priority_group *pg;
 
@@ -845,6 +850,12 @@ static int multipath_ctr(struct dm_targe
 		pg->pg_num = pg_count;
 		if (!--next_pg_num)
--
 	while (!blk_queue_stopped(q)) {
 		rq = blk_peek_request(q);
 		if (!rq)
@@ -1678,6 +1683,12 @@ static void dm_request_fn(struct request
 
 		BUG_ON(!irqs_disabled());
--
 	while (i < dm_table_get_num_targets(table)) {
 		ti = dm_table_get_target(table, i++);
 
 		if (ti->type->iterate_devices &&
 		    ti->type->iterate_devices(ti, dm_device_merge_is_compulsory, NULL))
 			return 0;
--
 		while (bh && bh->b_blocknr) {
 			atomic_inc(&bitmap->pending_writes);
 			set_buffer_locked(bh);
 			set_buffer_mapped(bh);
 			submit_bh(WRITE | REQ_SYNC, bh);
 			bh = bh->b_this_page;
--
 	while (bh) {
 		struct buffer_head *next = bh->b_this_page;
 		free_buffer_head(bh);
 		bh = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (bh) {
 		if (count == 0)
 			bh->b_blocknr = 0;
@@ -419,6 +446,12 @@ static struct page *read_page(struct fil
 		}
 		block++;
--
 	while (sectors) {
 		sector_t blocks;
 		bitmap_counter_t *bmc;
@@ -1376,6 +1414,12 @@ int bitmap_startwrite(struct bitmap *bit
 			sectors -= blocks;
 		else
--
 	while (sectors) {
 		sector_t blocks;
 		unsigned long flags;
@@ -1434,6 +1483,12 @@ void bitmap_endwrite(struct bitmap *bitm
 			sectors -= blocks;
 		else
--
-	while (*blocks < (PAGE_SIZE>>9)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*blocks < (PAGE_SIZE>>9)) {
 		rv |= __bitmap_start_sync(bitmap, offset,
 					  &blocks1, degraded);
 		offset += blocks1;
 		*blocks += blocks1;
+		if (_cur < timeout) {
--
 	while (sector < bitmap->mddev->resync_max_sectors) {
 		bitmap_end_sync(bitmap, sector, &blocks, 0);
 		sector += blocks;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (s < sector && s < bitmap->mddev->resync_max_sectors) {
 		bitmap_end_sync(bitmap, s, &blocks, 0);
 		s += blocks;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (sector < mddev->resync_max_sectors) {
 		sector_t blocks;
 		bitmap_start_sync(bitmap, sector, &blocks, 0);
 		sector += blocks;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
 		generic_make_request(bio);
 		bio = n;
+		if (_cur < timeout) {
--
 	while (hi > lo) {
 
 		mid = (hi + lo) / 2;
@@ -47,6 +52,12 @@ static inline struct dev_info *which_dev
 			hi = mid;
 		else
--
 		while (sector >= conf->stride) {
 			sector -= conf->stride;
 			if (dev < conf->near_copies)
 				dev += conf->raid_disks - conf->near_copies;
 			else
 				dev -= conf->near_copies;
--
 		while (bio) { /* submit pending writes */
 			struct bio *next = bio->bi_next;
 			bio->bi_next = NULL;
 			generic_make_request(bio);
 			bio = next;
+			if (_cur < timeout) {
--
 		while (n--) {
 			if (conf->mirrors[this].rdev &&
 			    this != ignore)
 				cnt++;
 			this = (this+1) % conf->raid_disks;
+			if (_cur < timeout) {
--
 	while (atomic_dec_and_test(&r10_bio->remaining)) {
 		if (r10_bio->master_bio == NULL) {
 			/* the primary of several recovery bios */
@@ -1505,6 +1543,12 @@ static void end_sync_request(struct r10b
 				put_buf(r10_bio);
 			r10_bio = r10_bio2;
--
 		while (sl != r10_bio->read_slot) {
 			char b[BDEVNAME_SIZE];
 
@@ -1949,8 +1998,19 @@ static void fix_read_error(struct r10con
 			}
 			rdev_dec_pending(rdev, mddev);
--
 		while (sl != r10_bio->read_slot) {
 			char b[BDEVNAME_SIZE];
 
@@ -1998,6 +2058,12 @@ static void fix_read_error(struct r10con
 
 			rdev_dec_pending(rdev, mddev);
--
 	while (sect_to_write) {
 		struct bio *wbio;
 		if (sectors > sect_to_write)
@@ -2078,6 +2149,12 @@ static int narrow_write_error(struct r10
 		sect_to_write -= sectors;
 		sector += sectors;
--
 			while (r10_bio) {
 				struct r10bio *rb2 = r10_bio;
 				r10_bio = (struct r10bio*) rb2->master_bio;
 				rb2->master_bio = NULL;
 				put_buf(rb2);
+				if (_cur < timeout) {
--
 	while (biolist) {
 		bio = biolist;
 		biolist = biolist->bi_next;
@@ -2738,6 +2831,12 @@ static sector_t sync_request(struct mdde
 			md_sync_acct(bio->bi_bdev, nr_sectors);
 			generic_make_request(bio);
--
-	while (i < dm_table_get_num_targets(table)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < dm_table_get_num_targets(table)) {
 		blk_set_default_limits(&ti_limits);
 
 		ti = dm_table_get_target(table, i++);
@@ -1280,6 +1285,12 @@ combine_limits:
 			       dm_device_name(table->md),
--
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
@@ -1340,6 +1356,12 @@ static bool dm_table_supports_flush(stru
 		if (ti->type->iterate_devices &&
 		    ti->type->iterate_devices(ti, device_flush_capable, &flush))
--
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
 		if (ti->discard_zeroes_data_unsupported)
 			return 0;
+			if (_cur < timeout) {
--
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
 		if (!ti->type->iterate_devices ||
 		    !ti->type->iterate_devices(ti, func, NULL))
 			return 0;
--
 	while (i--) {
 		if (postsuspend) {
 			if (ti->type->postsuspend)
@@ -1479,6 +1528,12 @@ static void suspend_targets(struct dm_ta
 			ti->type->presuspend(ti);
 
--
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
@@ -1607,6 +1667,12 @@ bool dm_table_supports_discards(struct d
 		if (ti->type->iterate_devices &&
 		    ti->type->iterate_devices(ti, device_discard_capable, NULL))
--
 	while (argc) {
 		arg_name = dm_shift_arg(as);
 		argc--;
@@ -126,6 +131,12 @@ static int parse_features(struct dm_arg_
 
 		ti->error = "Unrecognised flakey feature requested";
--
 	while ((reg = dm_rh_recovery_start(ms->rh))) {
 		r = recover(ms, reg);
 		if (r)
 			dm_rh_recovery_end(reg, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((bio = bio_list_pop(reads))) {
 		region = dm_rh_bio_to_region(ms->rh, bio);
 		m = get_default_mirror(ms);
@@ -566,6 +582,12 @@ static void do_reads(struct mirror_set *
 			read_async_bio(m, bio);
 		else
--
 	while ((bio = bio_list_pop(writes))) {
 		if ((bio->bi_rw & REQ_FLUSH) ||
 		    (bio->bi_rw & REQ_DISCARD)) {
@@ -705,6 +732,12 @@ static void do_writes(struct mirror_set
 		}
 
--
 	while ((bio = bio_list_pop(&recover)))
 		dm_rh_delay(ms->rh, bio);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while ((bio = bio_list_pop(&nosync))) {
 		if (unlikely(ms->leg_failure) && errors_handled(ms)) {
 			spin_lock_irq(&ms->lock);
@@ -758,6 +796,12 @@ static void do_writes(struct mirror_set
 			map_bio(get_default_mirror(ms), bio);
 			generic_make_request(bio);
--
 	while ((bio = bio_list_pop(failures))) {
 		if (!ms->log_failure) {
 			ms->in_sync = 0;
@@ -805,6 +854,12 @@ static void do_failures(struct mirror_se
 			hold_bio(ms, bio);
 		else
--
-	while (IS_ERR(msg = i2o_msg_get(c))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (IS_ERR(msg = i2o_msg_get(c))) {
 		if (time_after(jiffies, timeout)) {
 			osm_debug("%s: Timeout waiting for message frame.\n",
 				  c->name);
 			return ERR_PTR(-ETIMEDOUT);
 		}
--
 		while (IS_ERR(msg = i2o_msg_get_wait(c, I2O_TIMEOUT_RESET))) {
 			if (time_after(jiffies, timeout)) {
 				osm_err("%s: IOP reset timeout.\n", c->name);
@@ -553,6 +569,12 @@ static int i2o_iop_reset(struct i2o_cont
 				goto exit;
 			}
--
-	while (i2o_pe->name) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i2o_pe->name) {
 		tmp = proc_create_data(i2o_pe->name, i2o_pe->mode, dir,
 				       i2o_pe->fops, data);
 		if (!tmp)
 			return -1;
 
--
 	while (pe) {
 		tmp = pe->next;
 		i2o_proc_subdir_remove(pe);
 		remove_proc_entry(pe->name, dir);
 		pe = tmp;
+		if (_cur < timeout) {
--
 	while (pe) {
 		tmp = pe->next;
 		if (pe->data == c) {
@@ -2015,6 +2042,12 @@ static void i2o_proc_iop_remove(struct p
 		}
 		osm_debug("removing IOP /proc/i2o/%s\n", c->name);
--
 		while (!mptsas_sas_expander_pg0(ioc, &buffer,
 		    (MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<
 		     MPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle) &&
@@ -3889,6 +3894,12 @@ retry_page:
 				found_expander = 1;
 			}
--
-	while (!mptsas_sas_expander_pg0(ioc, &buffer,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!mptsas_sas_expander_pg0(ioc, &buffer,
 	    (MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<
 	     MPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle)) {
 
@@ -3950,6 +3966,12 @@ mptsas_probe_expanders(MPT_ADAPTER *ioc)
 		    "sas_addr (0x%llx)\n", ioc->name, port_info->num_phys,
--
 	while (!(mptsas_sas_device_pg0(ioc, &sas_device,
 	    MPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE, handle))) {
 
@@ -3987,6 +4014,12 @@ mptsas_probe_devices(MPT_ADAPTER *ioc)
 			continue;
 
--
 	while (! (nib & 0x4)) { /* eob */
 		/* skip ignore/chain. */
 		if (nib == 0 || nib == 3) {
@@ -1208,6 +1213,12 @@ kfree_sgl(MptSge_t *sgl, dma_addr_t sgl_
 		sg++;
 		bl++;
--
-	while (buckets) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (buckets) {
 		mf = mpt_get_msg_frame(LanCtx, mpt_dev);
 		if (mf == NULL) {
 			printk (KERN_ERR "%s: Unable to alloc request frame\n",
@@ -1282,6 +1287,12 @@ mpt_lan_post_receive_buckets(struct mpt_
 		priv->total_posted += i;
--
 		while ( sz )
 		{
 			shiftFactor++;
 			sz = sz >> 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (fwSize--) {
 		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
--
 	while (nextImage) {
 		pExtImage = (MpiExtImageHeader_t *) ((char *)pFwHeader + nextImage);
 
@@ -3763,10 +3790,27 @@ mpt_downloadboot(MPT_ADAPTER *ioc, MpiFw
 						ioc->name, fwSize*4, fwSize*4, ptrFw, load_addr));
 		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, load_addr);
--
 		while (fwSize--) {
 			CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
--
 	while (size) {
 		err = ec_read(*off, &data[*off - init_off]);
 		if (err)
 			return err;
 		*off += 1;
 		size--;
--
 	while (size) {
 		u8 byte_write = data[*off - init_off];
 		err = ec_write(*off, byte_write);
@@ -89,6 +105,12 @@ static ssize_t acpi_ec_write_io(struct f
 
 		*off += 1;
--
 	while (us) {
 		u32 delay = 1000;
 
@@ -603,6 +608,12 @@ void acpi_os_stall(u32 us)
 		udelay(delay);
 		touch_nmi_watchdog();
--
 	while (i < count) {
 
 		/* Print current offset */
@@ -616,6 +621,12 @@ void acpi_ut_dump_buffer2(u8 * buffer, u
 
 		acpi_os_printf("\n");
--
 			while (info->parameters[info->param_count]) {
 				if (info->param_count > ACPI_METHOD_MAX_ARG) {
 					return_ACPI_STATUS(AE_LIMIT);
 				}
 				info->param_count++;
+				if (_cur < timeout) {
--
 	while (next) {
 		prev = next;
 		next = next->method.mutex;
@@ -335,6 +351,12 @@ void acpi_ns_exec_module_code_list(void)
 		/* Delete the (temporary) method object */
 
--
 		while (last_obj_desc->common.next_object) {
 			last_obj_desc = last_obj_desc->common.next_object;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
--
 	while (obj_desc) {
 		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
 		    (obj_desc->data.handler == handler)) {
@@ -345,6 +361,12 @@ acpi_ns_attach_data(struct acpi_namespac
 
 		prev_obj_desc = obj_desc;
--
 	while (obj_desc) {
 		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
 		    (obj_desc->data.handler == handler)) {
@@ -407,6 +434,12 @@ acpi_ns_detach_data(struct acpi_namespac
 
 		prev_obj_desc = obj_desc;
--
 	while (obj_desc) {
 		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
 		    (obj_desc->data.handler == handler)) {
@@ -442,6 +480,12 @@ acpi_ns_get_attached_data(struct acpi_na
 		}
 
--
 	while (next_interface) {
 		acpi_gbl_supported_interfaces = next_interface->next;
 
@@ -156,6 +161,12 @@ void acpi_ut_interface_terminate(void)
 		}
 
--
 	while (next_interface) {
 		if (!ACPI_STRCMP(interface_name, next_interface->name)) {
 
@@ -258,6 +274,12 @@ acpi_status acpi_ut_remove_interface(acp
 
 		previous_interface = next_interface;
--
 	while (next_interface) {
 		if (!ACPI_STRCMP(interface_name, next_interface->name)) {
 			return (next_interface);
 		}
 
 		next_interface = next_interface->next;
--
-	while (next_node && (next_node != acpi_gbl_root_node)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (next_node && (next_node != acpi_gbl_root_node)) {
 		if (ACPI_GET_DESCRIPTOR_TYPE(next_node) != ACPI_DESC_TYPE_NAMED) {
 			ACPI_ERROR((AE_INFO,
 				    "Invalid Namespace Node (%p) while traversing namespace",
@@ -199,6 +204,12 @@ acpi_size acpi_ns_get_pathname_length(st
 		}
 		size += ACPI_PATH_SEGMENT_LENGTH;
 		next_node = next_node->parent;
+		if (_cur < timeout) {
--
 	while (byte_count) {
 		/*
 		 * Final bit positions for the package length bytes:
@@ -103,6 +108,12 @@ acpi_ps_get_next_package_length(struct a
 
 		byte_zero_mask = 0x0F;	/* Use bits [0:3] of byte 0 */
--
 	while (acpi_ps_is_prefix_char(*end)) {
 		end++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+	}
+	else {
--
 		while (aml[length]) {
 			length++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
--
 			while (parser_state->aml < parser_state->pkg_end) {
 				field = acpi_ps_get_next_field(parser_state);
 				if (!field) {
@@ -642,6 +680,12 @@ acpi_ps_get_next_arg(struct acpi_walk_st
 					arg = field;
 				}
--
 		while (next_gpe_block->next) {
 			next_gpe_block = next_gpe_block->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (gpe_xrupt_info) {
 		gpe_block = gpe_xrupt_info->gpe_block_list_head;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (gpe_block) {
 			next_gpe_block = gpe_block->next;
 			ACPI_FREE(gpe_block->event_info);
@@ -86,10 +96,22 @@ static void acpi_ut_terminate(void)
 			ACPI_FREE(gpe_block);
 
--
 	while (gpe_xrupt_info) {
 
 		/* Walk all Gpe Blocks attached to this interrupt level */
 
 		gpe_block = gpe_xrupt_info->gpe_block_list_head;
-		while (gpe_block) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (gpe_block) {
 			walk_info.gpe_block = gpe_block;
 			walk_info.gpe_device = gpe_block->node;
 
@@ -279,9 +289,21 @@ void acpi_ev_update_gpes(acpi_owner_id t
 			}
--
-			while (prev) {
+		else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
--
+				while (prev) {
 
 				/* Traverse all siblings in the parent's argument list */
 
-				next = prev->common.next;
-				if (next == op) {
--
-	while (walk_state) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (walk_state) {
 		if (ACPI_SUCCESS(status)) {
 			/*
 			 * The parse_loop executes AML until the method terminates
@@ -676,6 +693,12 @@ acpi_status acpi_ps_parse_aml(struct acp
 		}
--
 		while ((length < original_object->buffer.length) &&
 		       (original_object->buffer.pointer[length])) {
 			length++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-		while (length--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (length--) {
 			*elements =
 			    acpi_ut_create_integer_object((u64) *buffer);
 			if (!*elements) {
@@ -499,6 +515,12 @@ acpi_ns_convert_to_package(union acpi_op
 			}
--
 	while (state) {
 
 		/* Get one element of the package */
@@ -973,6 +978,11 @@ acpi_ut_walk_package_tree(union acpi_ope
 			}
 
--
 			while (state->pkg.index >=
 			       state->pkg.source_object->package.count) {
 				/*
@@ -1001,6 +1011,12 @@ acpi_ut_walk_package_tree(union acpi_ope
 				 * completed package object.
 				 */
--
-				while (state_list) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (state_list) {
 					state =
 					    acpi_ut_pop_generic_state
 					    (&state_list);
 					acpi_ut_delete_generic_state(state);
+					if (_cur < timeout) {
--
 		while (handler_obj) {
 			if (handler_obj->address_space.space_id == space_id) {
 				if (handler_obj->address_space.handler_flags &
@@ -184,6 +189,12 @@ acpi_ev_has_default_handler(struct acpi_
 			}
 
--
 	while (obj_desc) {
 
 		/* Is this the correct Region? */
@@ -626,6 +642,12 @@ acpi_ev_detach_region(union acpi_operand
 
 		last_obj_ptr = &obj_desc->region.next;
--
-		while (next_handler_obj) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (next_handler_obj) {
 
 			/* Found a handler, is it for the same address space? */
 
@@ -782,6 +809,12 @@ acpi_ev_install_handler(acpi_handle obj_
 			/* Walk the linked list of handlers attached to this device */
--
 		while (handler_obj) {
 
 			/* Same space_id indicates a handler already installed */
@@ -938,6 +976,12 @@ acpi_ev_install_space_handler(struct acp
 			/* Walk the linked list of handlers */
 
--
 	while (next_node) {
 		if ((next_node->type == ACPI_TYPE_REGION) &&
 		    (next_node->object) &&
@@ -1221,6 +1270,12 @@ static void acpi_ev_orphan_ec_reg_method
 			goto exit;	/* Do not execute _REG */
 		}
--
 	while (arg) {
 		/*
 		 * Three types of field elements are handled:
@@ -329,6 +334,12 @@ acpi_ds_get_field_names(struct acpi_crea
 		}
 
--
 	while (arg) {
 		/*
 		 * Ignore OFFSET and ACCESSAS terms here; we are only interested in the
@@ -500,6 +516,12 @@ acpi_ds_init_field_objects(union acpi_pa
 		/* Get the next field element in the list */
 
--
 	while (1) {
 		status = acpi_get_parent(current_device, &parent_device);
 		if (ACPI_FAILURE(status)) {
@@ -209,6 +214,12 @@ acpi_hw_build_pci_list(acpi_handle root_
 		list_head = list_element;
 
--
-	while (info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (info) {
 		status = acpi_hw_get_pci_device_info(pci_id, info->device,
 						     &bus_number, &is_bridge);
 		if (ACPI_FAILURE(status)) {
@@ -263,6 +279,12 @@ acpi_hw_process_pci_list(struct acpi_pci
 		}
--
 	while (next) {
 		previous = next;
 		next = previous->next;
 		ACPI_FREE(previous);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (acpi_ns_valid_root_prefix(*next_external_char)) {
 			next_external_char++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (next) {
 		obj_desc = next;
 		next = obj_desc->mutex.next;
@@ -494,5 +499,11 @@ void acpi_ex_release_all_mutexes(struct
 
 		thread->current_sync_level =
--
 		while (parent_node) {
 			parent_node->flags |= ANOBJ_SUBTREE_HAS_INI;
 			parent_node = parent_node->parent;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (this_name->repair_function) {
 		if (ACPI_COMPARE_NAME(node->name.ascii, this_name->name)) {
 			return (this_name);
 		}
 		this_name++;
+		if (_cur < timeout) {
--
-	while (current_value) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (current_value) {
 		(void)acpi_ut_short_divide(current_value, base, &current_value,
 					   NULL);
 		num_digits++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (next_node != node) {
 		prev_node = next_node;
 		next_node = next_node->peer;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (child_node->peer) {
 			child_node = child_node->peer;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (next_node) {
 
 		/* Grandchildren should have all been deleted already */
@@ -316,6 +343,12 @@ void acpi_ns_delete_children(struct acpi
 		node_to_delete = next_node;
 		next_node = next_node->peer;
--
 	while (node) {
 
 		/* Check for match against the name */
@@ -155,6 +160,12 @@ acpi_ns_search_one_scope(u32 target_name
 		/* Didn't match name, move on to the next peer object */
 
--
-	while (parent_node) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (parent_node) {
 		/*
 		 * Search parent scope. Use TYPE_ANY because we don't care about the
 		 * object type at this point, we only care about the existence of
@@ -251,6 +267,12 @@ acpi_ns_search_parent_tree(u32 target_na
 		/* Not found here, go up another level (until we reach the root) */
--
-		while (GET_CURRENT_ARG_TYPE(walk_state->arg_types)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (GET_CURRENT_ARG_TYPE(walk_state->arg_types)
 		       && !walk_state->arg_count) {
 			walk_state->aml_offset =
 			    (u32) ACPI_PTR_DIFF(walk_state->parser_state.aml,
@@ -452,6 +457,12 @@ acpi_ps_get_arguments(struct acpi_walk_s
 			}
--
 	while (next) {
 		prev = next;
 		next = next->method.mutex;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	/* Iterative parsing loop, while there is more AML to process: */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while ((parser_state->aml < parser_state->aml_end) || (op)) {
 		aml_op_start = parser_state->aml;
 		if (!op) {
@@ -1203,6 +1230,12 @@ acpi_status acpi_ps_parse_loop(struct ac
 			return_ACPI_STATUS(status);
 		}
--
 	}			/* while parser_state->Aml */
 
 	status = acpi_ps_complete_final_op(walk_state, op, status);
diff -u -p a/acpi/acpica/evgpeutil.c b/acpi/acpica/evgpeutil.c
--- a/acpi/acpica/evgpeutil.c
+++ b/acpi/acpica/evgpeutil.c
--
 	while (gpe_xrupt_info) {
 
 		/* Walk all Gpe Blocks attached to this interrupt level */
 
 		gpe_block = gpe_xrupt_info->gpe_block_list_head;
-		while (gpe_block) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (gpe_block) {
 
 			/* One callback per GPE block */
 
@@ -95,9 +105,21 @@ acpi_ev_walk_gpe_list(acpi_gpe_callback
 			}
--
 	while (gpe_xrupt_block) {
 		gpe_block = gpe_xrupt_block->gpe_block_list_head;
 
 		/* Walk the GPE blocks on this interrupt level */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (gpe_block) {
 			if ((&gpe_block->event_info[0] <= gpe_event_info) &&
 			    (&gpe_block->event_info[gpe_block->gpe_count] >
@@ -144,9 +176,21 @@ u8 acpi_ev_valid_gpe_event(struct acpi_g
 			}
 
--
 	while (next_gpe_xrupt) {
 		if (next_gpe_xrupt->interrupt_number == interrupt_number) {
 			return_PTR(next_gpe_xrupt);
 		}
 
 		next_gpe_xrupt = next_gpe_xrupt->next;
--
 		while (next_gpe_xrupt->next) {
 			next_gpe_xrupt = next_gpe_xrupt->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (this_name->info.name[0]) {
 		if (ACPI_COMPARE_NAME(node->name.ascii, this_name->info.name)) {
 			return (this_name);
@@ -401,6 +406,12 @@ const union acpi_predefined_info *acpi_n
 		}
 
--
 	while (arg) {
 
 		/* Ignore OFFSET and ACCESSAS terms here */
@@ -749,6 +754,12 @@ acpi_ds_eval_bank_field_operands(struct
 		/* Move to next field in the list */
 
--
 	while (count) {
 		previous_target = target;
 		target = ACPI_ADD_PTR(u8, resource, table->offset);
@@ -506,6 +511,12 @@ acpi_rs_dump_descriptor(void *resource,
 
 		table++;
--
 	while (next_node) {
 
 		/* If type matches, we are done */
@@ -140,6 +145,12 @@ struct acpi_namespace_node *acpi_ns_get_
 		/* Otherwise, move on to the next peer node */
 
--
 		while ((length < operand[0]->buffer.length) &&
 		       (length < operand[1]->integer.value) &&
 		       (operand[0]->buffer.pointer[length])) {
 			length++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (op) {
 
 		/* Check if we are not ascending */
@@ -104,6 +109,12 @@ void acpi_ps_delete_parse_tree(union acp
 		} else {
 			op = parent;
--
-	while (aml < end_aml) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (aml < end_aml) {
 
 		/* Validate the (internal) Resource Type */
 
@@ -195,6 +200,12 @@ acpi_rs_convert_resources_to_aml(struct
 		resource =
--
 	while (arg) {
 		if (index >= ACPI_OBJ_NUM_OPERANDS) {
 			return_ACPI_STATUS(AE_BAD_DATA);
@@ -725,6 +730,12 @@ acpi_ds_create_operands(struct acpi_walk
 		arg = arg->common.next;
 		arg_count++;
--
 	while (num_segments) {
 		for (i = 0; i < 4; i++) {
 			ACPI_IS_PRINT(pathname[i]) ?
@@ -98,6 +103,12 @@ void acpi_ns_print_pathname(u32 num_segm
 		if (num_segments) {
 			acpi_os_printf(".");
--
 	while (obj_desc) {
 		obj_type = ACPI_TYPE_INVALID;
 		acpi_os_printf("Attached Object %p: ", obj_desc);
@@ -590,6 +606,12 @@ acpi_ns_dump_one_object(acpi_handle obj_
 		}
 
--
 		while (extra_op && !extra_op->common.node) {
 			extra_op = extra_op->common.parent;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
--
 	while (walk_state->control_state) {
 		state = walk_state->control_state;
 		walk_state->control_state = state->common.next;
 
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
--
 	while (walk_state->scope_info) {
 		state = walk_state->scope_info;
 		walk_state->scope_info = state->common.next;
 
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
--
 	while (walk_state->results) {
 		state = walk_state->results;
 		walk_state->results = state->common.next;
 
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
--
-		while (arg) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (arg) {
 			/*
 			 * We must delete any package elements that were created earlier
 			 * and are not going to be used because of the package truncation.
@@ -522,6 +527,12 @@ acpi_ds_build_internal_package_obj(struc
 
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (count) {
 		target = ACPI_ADD_PTR(u8, obj_desc, info->offset);
 		name = info->name;
 
@@ -433,6 +438,12 @@ acpi_ex_dump_object(union acpi_operand_o
 
--
 	while (num_operands) {
 		acpi_ex_dump_operand(*operands, 0);
 		operands++;
 		num_operands--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (gpe_block) {
 		/*
 		 * Read all of the 8-bit GPE status and enable registers in this GPE
@@ -436,6 +441,12 @@ u32 acpi_ev_gpe_detect(struct acpi_gpe_x
 		}
 
--
-		while (ACPI_SUCCESS(status) && notify_object) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (ACPI_SUCCESS(status) && notify_object) {
 			status = acpi_ev_queue_notify_request(
 					notify_object->node,
 					ACPI_NOTIFY_DEVICE_WAKE);
 			notify_object = notify_object->next;
+			if (_cur < timeout) {
--
 	while (length && *string) {
 		if (!ACPI_IS_PRINT(*string)) {
 			*string = '?';
 		}
 		string++;
 		length--;
--
 	while (buffer < end) {
 		sum = (u8) (sum + *(buffer++));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (handler_obj) {
 
 		/* We have a handler, see if user requested this one */
@@ -241,6 +246,11 @@ acpi_remove_address_space_handler(acpi_h
 
 			/* Walk the handler's region list */
--
 			while (region_obj) {
 				/*
 				 * First disassociate the handler from the region.
@@ -258,6 +268,12 @@ acpi_remove_address_space_handler(acpi_h
 				region_obj =
 				    handler_obj->address_space.region_list;
--
 	while (aml < end_aml) {
 
 		/* Validate the Resource Type and Resource Length */
@@ -329,6 +334,12 @@ acpi_ut_walk_aml_resources(u8 * aml,
 
 		aml += length;
--
-		while (notifier) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (notifier) {
 			notifier->handler(notify_info->notify.node,
 					  notify_info->notify.value,
 					  notifier->context);
 			notifier = notifier->next;
+			if (_cur < timeout) {
--
-	while (walk_state->scope_info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (walk_state->scope_info) {
 
 		/* Pop a scope off the stack */
 
@@ -78,6 +83,12 @@ void acpi_ds_scope_stack_clear(struct ac
 				  acpi_ut_get_type_name(scope_info->common.
--
 	while (arg && argn) {
 		argn--;
 		arg = arg->common.next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (prev_arg->common.next) {
 			prev_arg = prev_arg->common.next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (arg) {
 		arg->common.parent = op;
 		arg = arg->common.next;
 
 		op->common.arg_list_length++;
+		if (_cur < timeout) {
--
 	while (parent) {
 		arg = acpi_ps_get_arg(parent, 0);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (arg && (arg != origin) && (arg != op)) {
 			arg = arg->common.next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (prefix_count--) {
 			*temp_ptr++ = AML_PARENT_PREFIX;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		/*
 		 * Source is the external AML byte stream buffer,
 		 * destination is the internal resource descriptor
@@ -292,7 +297,13 @@ acpi_rs_convert_aml_to_resource(struct a
 
--
 	while (count) {
 		/*
 		 * Source is the internal resource descriptor,
@@ -517,6 +533,12 @@ acpi_rs_convert_resource_to_aml(struct a
 
 		count--;
--
 		while (handler_desc) {
 			next_desc = handler_desc->address_space.next;
 			acpi_ut_remove_reference(handler_desc);
 			handler_desc = next_desc;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (object) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (object) {
 
 		/* Make sure that this isn't a namespace handle */
 
@@ -604,6 +620,12 @@ acpi_ut_update_object_reference(union ac
 			object = state->update.object;
--
 	while (state_list) {
 		state = acpi_ut_pop_generic_state(&state_list);
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 	while (resource) {
 
 		/* Validate the descriptor type */
@@ -326,6 +331,12 @@ acpi_rs_get_aml_length(struct acpi_resou
 		resource =
 		    ACPI_ADD_PTR(struct acpi_resource, resource,
--
-	while (aml_buffer < end_aml) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (aml_buffer < end_aml) {
 
 		/* Validate the Resource Type and Resource Length */
 
@@ -484,6 +500,12 @@ acpi_rs_get_list_length(u8 * aml_buffer,
 		 * contained in the resource descriptor header
--
 	while (parser_state->scope) {
 		scope = acpi_ut_pop_generic_state(&parser_state->scope);
 		acpi_ut_delete_generic_state(scope);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (node) {
 
 		/* Check to see if a handler exists */
@@ -601,7 +606,12 @@ acpi_ev_initialize_region(union acpi_ope
 				break;
 			}
--
-			while (handler_obj) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+					while (handler_obj) {
 
 				/* Is this handler of the correct type? */
 
@@ -655,12 +665,24 @@ acpi_ev_initialize_region(union acpi_ope
 				/* Try next handler in the list */
--
 	while (num_segments && current_node) {
 		num_segments--;
 		if (!num_segments) {
@@ -647,6 +652,12 @@ acpi_ns_lookup(union acpi_generic_state
 
 		path += ACPI_NAME_SIZE;
--
 			while (handler_obj->handler != handler) {
 				if (handler_obj->next) {
 					parent_obj = handler_obj;
@@ -637,6 +642,12 @@ acpi_remove_notify_handler(acpi_handle d
 				} else {
 					break;
--
 	while (((unsigned long)entry) + sizeof(struct acpi_subtable_header) <
 	       table_end) {
 		if (entry->type == entry_id
@@ -247,6 +252,12 @@ acpi_table_parse_entries(char *id,
 
 		entry = (struct acpi_subtable_header *)
--
 	while (!acpi_is_root_bridge(phandle)) {
 		node = kzalloc(sizeof(struct acpi_handle_node), GFP_KERNEL);
 		if (!node)
@@ -331,6 +336,12 @@ struct pci_dev *acpi_get_pci_dev(acpi_ha
 		status = acpi_get_parent(phandle, &phandle);
 		if (ACPI_FAILURE(status))
--
 	while (bridge) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 
@@ -405,6 +410,12 @@ static struct acpi_prt_entry *acpi_pci_i
 
 		dev = bridge;
--
 	while (!kthread_should_stop()) {
 		int cpu;
 		u64 expire_time;
@@ -221,6 +226,12 @@ static int power_saving_thread(void *dat
 		 */
 		if (do_sleep)
--
-		while (ps_tsk_num < num) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while (ps_tsk_num < num) {
 			if (create_power_saving_task())
 				return;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 		while (ps_tsk_num > num)
diff -u -p a/acpi/apei/ghes.c b/acpi/apei/ghes.c
--- a/acpi/apei/ghes.c
+++ b/acpi/apei/ghes.c
@@ -724,14 +724,30 @@ static void ghes_proc_in_irq(struct irq_
 	 * revert it back to proper order.
--
 	while (llnode) {
 		next = llnode->next;
 		llnode->next = tail;
 		tail = llnode;
 		llnode = next;
+		if (_cur < timeout) {
--
-	while (llnode) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (llnode) {
 		next = llnode->next;
 		estatus_node = llist_entry(llnode, struct ghes_estatus_node,
 					   llnode);
@@ -747,6 +763,12 @@ static void ghes_proc_in_irq(struct irq_
 		gen_pool_free(ghes_estatus_pool, (unsigned long)estatus_node,
--
 	while (&res1->list != res_list1) {
 		list_for_each_entry(res2, res_list2, list) {
 			if (res1->start >= res2->end ||
@@ -377,6 +382,12 @@ static int apei_res_sub(struct list_head
 		}
 		res1 = resn1;
--
-	while (repeat--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (repeat--) {
 		unsigned long delay = jiffies +
 			msecs_to_jiffies(ec_delay);
 		do {
@@ -239,6 +244,12 @@ static int ec_poll(struct acpi_ec *ec)
 		spin_lock_irqsave(&ec->curr_lock, flags);
--
 	while (i--) {
 		if (!pbats[i])
 			continue;
 		power_supply_unregister(&pbats[i]->bat);
 		kfree(pbats[i]);
+		if (_cur < timeout) {
--
 	while (map->key) {
 		if (strncasecmp(map->key, buf, MAX_KEYLENGTH) == 0)
 			return map->value;
 		map++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (map->key) {
 		if (map->value == value)
 			return map->key;
 		map++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (req) {
 		struct jsfd_part *jdp = req->rq_disk->private_data;
 		unsigned long offset = blk_rq_pos(req) << 9;
@@ -212,6 +217,12 @@ static void jsfd_do_request(struct reque
 	end:
 		if (!__blk_end_request_cur(req, err))
--
 	while (dp) {
 		if (!strcmp(dp->name, "gpio")) {
 			i2c_childlist[index].i2ctype = I2C_GPIO;
@@ -1052,6 +1057,12 @@ static int __devinit envctrl_probe(struc
 		}
 
--
                 while(1) {
                         if(crc8_addr(addr))
                                 break;
@@ -364,6 +369,12 @@ static void probe_nic(struct ioc3_driver
                         addr = nic_find(idd, &save, addr);
                         if(addr == first)
--
 	while (bus->parent) {
 		if (!acpi_pm_device_sleep_wake(&bus->self->dev, enable))
 			return;
 		bus = bus->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (bus->parent) {
 		struct pci_dev *bridge = bus->self;
 
@@ -317,6 +333,12 @@ static void acpi_pci_propagate_run_wake(
 		if (!acpi_dev_run_wake(&bridge->dev, enable))
 			return;
--
 	while (out_of_order) {
 		out_of_order = 0;
 
@@ -336,6 +341,11 @@ static int sort_by_size(struct pci_resou
 
 		current_res = *head;
--
 		while (current_res->next && current_res->next->next) {
 			if (current_res->next->length > current_res->next->next->length) {
 				out_of_order++;
@@ -346,6 +356,18 @@ static int sort_by_size(struct pci_resou
 				current_res->next = next_res;
 			} else
--
 	while (out_of_order) {
 		out_of_order = 0;
 
@@ -384,6 +411,11 @@ static int sort_by_max_size(struct pci_r
 
 		current_res = *head;
--
 		while (current_res->next && current_res->next->next) {
 			if (current_res->next->length < current_res->next->next->length) {
 				out_of_order++;
@@ -394,6 +426,18 @@ static int sort_by_max_size(struct pci_r
 				current_res->next = next_res;
 			} else
--
 	while (node->next) {
 		prevnode = node;
 		node = node->next;
 		kfree(prevnode);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (temp && temp->next != max) {
 				temp = temp->next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
--
 	while (out_of_order) {
 		out_of_order = 0;
 
@@ -857,6 +928,11 @@ int cpqhp_resource_sort_and_combine(stru
 
 		node1 = (*head);
--
 		while (node1->next && node1->next->next) {
 			if (node1->next->base > node1->next->next->base) {
 				out_of_order++;
@@ -867,11 +943,28 @@ int cpqhp_resource_sort_and_combine(stru
 				node1->next = node2;
 			} else
--
 	while (node1 && node1->next) {
 		if ((node1->base + node1->length) == node1->next->base) {
 			/* Combine */
@@ -882,6 +975,12 @@ int cpqhp_resource_sort_and_combine(stru
 			kfree(node2);
 		} else
--
 		while (func) {
 			res_lists.io_head = ctrl->io_head;
 			res_lists.mem_head = ctrl->mem_head;
@@ -1713,6 +1817,12 @@ static u32 remove_board(struct pci_func
 				slot_remove(func);
 
--
 	while (change) {
 		change = 0;
 
@@ -1909,6 +2024,12 @@ static void interrupt_event_handler(stru
 				change = 1;
 			}
--
 	while (func && !rc) {
 		pci_bus->number = func->bus;
 		devfn = PCI_DEVFN(func->device, func->function);
@@ -2132,6 +2258,12 @@ int cpqhp_process_SS(struct controller *
 		}
 
--
 			while (new_slot) {
 				new_slot = cpqhp_slot_find(new_slot->bus, new_slot->device, index++);
 
 				if (new_slot)
 					cpqhp_return_board_resources(new_slot, resources);
+					if (_cur < timeout) {
--
 		while ((function < max_functions) && (!stop_it)) {
 			pci_bus_read_config_dword (ctrl->pci_bus, PCI_DEVFN(func->device, function), 0x00, &ID);
 
@@ -2341,6 +2489,12 @@ static u32 configure_new_device(struct c
 
 				stop_it++;
--
 	} while (function < max_functions);
diff -u -p a/pci/hotplug/cpqphp_core.c b/pci/hotplug/cpqphp_core.c
--- a/pci/hotplug/cpqphp_core.c
+++ b/pci/hotplug/cpqphp_core.c
@@ -144,11 +144,22 @@ static int init_SERR(struct controller *
 
--
 	while (number_of_slots) {
 		physical_slot = tempdword;
 		writeb(0, ctrl->hpc_reg + SLOT_SERR);
 		tempdword++;
 		number_of_slots--;
+		if (_cur < timeout) {
--
 	while ((p_temp < p_max) && !bail) {
 		/* Look for the double NULL terminator
 		 * The first condition is the previous byte
@@ -233,6 +249,12 @@ static void __iomem *get_subsequent_smbi
 
 		previous_byte = readb(p_temp);
--
 	while (old_slot) {
 		/* memory will be freed by the release_slot callback */
 		next_slot = old_slot->next;
 		pci_hp_deregister (old_slot->hotplug_slot);
 		old_slot = next_slot;
+		if (_cur < timeout) {
--
-	while (number_of_slots) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (number_of_slots) {
 		slot = kzalloc(sizeof(*slot), GFP_KERNEL);
 		if (!slot)
 			goto error;
@@ -647,10 +685,21 @@ static int ctrl_slot_setup(struct contro
 		slot_entry = get_SMBIOS_entry(smbios_start, smbios_table, 9,
--
-		while (slot_entry && (readw(slot_entry + SMBIOS_SLOT_NUMBER) !=
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (slot_entry && (readw(slot_entry + SMBIOS_SLOT_NUMBER) !=
 				slot->number)) {
 			slot_entry = get_SMBIOS_entry(smbios_start,
 						smbios_table, 9, slot_entry);
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (ctrl) {
 		if (ctrl->hpc_reg) {
 			u16 misc;
@@ -1331,31 +1391,75 @@ static void __exit unload_cpqphpd(void)
 		ctrl_slot_cleanup(ctrl);
 
--
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (next != NULL) {
 			res = next->io_head;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
--
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (slot) {
 		next = slot->next;
 		list_for_each_entry_safe(func, tmp, &slot->funcs, sibling) {
@@ -561,6 +566,12 @@ static void cleanup_bridge(struct acpiph
 		list_del(&slot->funcs);
 		kfree(slot);
--
 	while ((pci_bus = pci_find_next_bus(pci_bus))) {
 		if (!pci_bus->sysdata)
 			continue;
@@ -710,6 +715,12 @@ static int __init sn_pci_hotplug_init(vo
 			registered = 0;
 			break;
--
-		while (!done) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!done) {
 			rc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar,
 							&status);
 			if (!rc) {
@@ -756,6 +761,12 @@ int ibmphp_hpc_writeslot (struct slot *
 				} else
--
 	while (!kthread_should_stop()) {
 		/* try to get the lock to do some kind of hardware access */
 		down (&semOperations);
@@ -907,6 +923,12 @@ static int poll_hpc(void *data)
 		/* sleep for a short time just for good measure */
 out_sleep:
--
 	while (!done) {
 		*pstatus = ctrl_read (ctlr_ptr, wpg_bbar, WPG_CTLR_INDEX);
 		if (*pstatus == HPC_ERROR) {
@@ -1126,6 +1153,12 @@ static int hpc_wait_ctlr_notworking (int
 			} else
 				timeout--;
--
-			while (func_cur) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (func_cur) {
 				if ((func_cur->busno == busno) &&
 						(func_cur->device == device) &&
 						(func_cur->function == function))
 					return func_cur;
 				func_cur = func_cur->next;
--
 	while (i <= slot_cur->bus_on->slot_max) {
 		if (i == slot_cur->number) {
 			i++;
@@ -837,6 +853,12 @@ static int is_bus_empty(struct slot * sl
 					SLOT_PWRGD(tmp_slot->status))
 			return 0;
--
 			while (temp_end < end_address) {
 				if (ibmphp_find_resource (bus, start_address, &io, IO) < 0) {
 					err ("cannot find corresponding IO resource to remove\n");
@@ -1285,6 +1290,12 @@ static int unconfigure_boot_device (u8 b
 				temp_end = io->end;
 				start_address = io->end + 1;
--
 		while (cur_func) {
 			/* TO DO: WILL MOST LIKELY NEED TO GET RID OF THE BUS STRUCTURE FROM RESOURCES AS WELL */
 			if (cur_func->bus) {
@@ -1619,6 +1635,12 @@ int ibmphp_unconfigure_card (struct slot
 			temp_func = cur_func->next;
 			kfree (cur_func);
--
 	while (res && index--) {
 		out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 		res = res->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (res && index--) {
 		out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 		res = res->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (res && index--) {
 		out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 		res = res->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (res && index--) {
 		out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 		res = res->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (res && index--) {
 			out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 			res = res->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (res && index--) {
 			out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 			res = res->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (res && index--) {
 			out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 			res = res->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (res && index--) {
 			out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 			res = res->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((d = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371SB_0, d))) {
 		pci_read_config_byte(d, 0x82, &dlc);
 		if (!(dlc & 1<<1)) {
@@ -132,6 +137,12 @@ static void quirk_passive_release(struct
 			dlc |= 1<<1;
 			pci_write_config_byte(d, 0x82, dlc);
--
 	while (pos && ttl--) {
 		u8 flags;
 
@@ -2277,6 +2293,12 @@ static int __devinit msi_ht_cap_enabled(
 
 		pos = pci_find_next_ht_capability(dev, pos,
--
-	while (pos && ttl--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (pos && ttl--) {
 		u8 flags;
 
 		if (pci_read_config_byte(dev, pos + HT_MSI_FLAGS,
@@ -2337,6 +2364,12 @@ static void __devinit ht_enable_msi_mapp
 		}
--
 	while (pos && ttl--) {
 		u8 flags;
 
@@ -2542,6 +2580,12 @@ static void __devinit ht_disable_msi_map
 		}
 		pos = pci_find_next_ht_capability(dev, pos,
--
 	while (f < end) {
 		if ((f->vendor == dev->vendor || f->vendor == (u16) PCI_ANY_ID) &&
 		    (f->device == dev->device || f->device == (u16) PCI_ANY_ID)) {
@@ -2955,6 +3004,12 @@ static void pci_do_fixups(struct pci_dev
 			f->hook(dev);
 		}
--
-	while (test_bit(_XEN_PCIF_active,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (test_bit(_XEN_PCIF_active,
 			(unsigned long *)&pdev->sh_info->flags)) {
 		xen_poll_irq_timeout(irq, jiffies + 3*HZ);
 		xen_clear_irq_pending(irq);
@@ -149,6 +154,12 @@ static int do_pci_op(struct pcifront_dev
 			err = XEN_PCI_ERR_dev_not_found;
--
-	while (!list_empty(&bus->devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&bus->devices)) {
 		dev = container_of(bus->devices.next, struct pci_dev,
 				   bus_list);
 		dev_dbg(&dev->dev, "removing device\n");
 		pci_remove_bus_device(dev);
+		if (_cur < timeout) {
--
 	while (link) {
 		/* Check upstream direction L0s latency */
 		if ((link->aspm_capable & ASPM_STATE_L0S_UP) &&
@@ -346,6 +351,12 @@ static void pcie_aspm_check_latency(stru
 		l1_switch_latency += 1000;
 
--
 	while (link) {
 		pcie_config_aspm_link(link, policy_to_aspm_state(link));
 		link = link->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((bus_ops = pci_bus_ops_pop())) {
 		pci_bus_set_ops(bus_ops->bus, bus_ops->ops);
 		kfree(bus_ops);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (kfifo_get(&aer_recover_ring, &entry)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (kfifo_get(&aer_recover_ring, &entry)) {
 		pdev = pci_get_domain_bus_and_slot(entry.domain, entry.bus,
 						   entry.devfn);
 		if (!pdev) {
@@ -638,6 +643,12 @@ static void aer_recover_work_func(struct
 		}
--
 	while (ids->vendor || ids->subvendor || ids->class_mask) {
 		found = pci_get_dev_by_id(ids, NULL);
 		if (found)
 			goto exit;
 		ids++;
-	}
--
 	while (parent->parent && parent->subordinate < max) {
 		parent->subordinate = max;
 		pci_write_config_byte(parent->self, PCI_SUBORDINATE_BUS, max);
 		parent = parent->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 				while (parent->parent) {
 					if ((!pcibios_assign_all_busses()) &&
 					    (parent->subordinate > max) &&
@@ -786,6 +802,12 @@ int __devinit pci_scan_bridge(struct pci
 						j = 1;
 					}
--
 	while (bus->parent) {
 		if ((child->subordinate > bus->subordinate) ||
 		    (child->number > bus->subordinate) ||
@@ -828,6 +855,12 @@ int __devinit pci_scan_bridge(struct pci
 				bus->number, bus->subordinate);
 		}
--
 		while (ids->vendor || ids->subvendor || ids->class_mask) {
 			if (pci_match_one_device(ids, dev))
 				return ids;
 			ids++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while ((id = strsep(&p, ","))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((id = strsep(&p, ","))) {
 		unsigned int vendor, device, subvendor = PCI_ANY_ID,
 			subdevice = PCI_ANY_ID, class=0, class_mask=0;
 		int fields;
@@ -80,6 +85,12 @@ static int __init pci_stub_init(void)
 		if (rc)
--
 	while (pos) {
 		rc = pci_read_config_byte(dev, pos + 3, &cap);
 		if (rc != PCIBIOS_SUCCESSFUL)
@@ -385,6 +390,12 @@ static int __pci_find_next_ht_cap(struct
 		pos = __pci_find_next_cap_ttl(dev->bus, dev->devfn,
 					      pos + PCI_CAP_LIST_NEXT,
--
 	while (cap->size) {
 		struct pci_cap_saved_state *tmp;
 
@@ -1052,6 +1068,12 @@ int pci_load_saved_state(struct pci_dev
 		memcpy(tmp->cap.data, cap->data, tmp->cap.size);
 		cap = (struct pci_cap_saved_data *)((u8 *)cap +
--
 	while (bus->parent) {
 		struct pci_dev *bridge = bus->self;
 
@@ -1770,6 +1797,12 @@ bool pci_dev_run_wake(struct pci_dev *de
 			return true;
 
--
 	while (!pci_is_root_bus(dev->bus)) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!pci_is_root_bus(dev->bus)) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (bus) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (bus) {
 		bridge = bus->self;
 		if (bridge) {
 			pci_read_config_word(bridge, PCI_BRIDGE_CONTROL,
@@ -3425,6 +3485,12 @@ int pci_set_vga_state(struct pci_dev *de
 					      cmd);
--
 	while (str) {
 		char *k = strchr(str, ',');
 		if (k)
@@ -3611,6 +3682,12 @@ static int __init pci_setup(char *str)
 			}
 		}
--
 	while (clocks->xfer_speed) {
 		if (clocks->xfer_speed == speed)
 			return clocks->timing;
 		clocks++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (sg_len) {
 			u32 offset = addr & 0xffff;
 			u32 len = sg_len;
@@ -1782,6 +1787,12 @@ static void mv_fill_sg(struct ata_queued
 
 			last_sg = mv_sg;
--
 	while (in_index != pp->resp_idx) {
 		unsigned int tag;
 		struct mv_crpb *response = &pp->crpb[pp->resp_idx];
@@ -2797,6 +2813,12 @@ static void mv_process_crpb_entries(stru
 		if (mv_process_crpb_response(ap, response, tag, ncq_enabled))
 			done_mask |= 1 << tag;
--
 	while (status & 0x03) {
 		udelay(1);
 		pci_read_config_byte(dev, 0x43, &status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (sg_len) {
 			/* table overflow should never happen */
 			BUG_ON (pi++ >= MAX_DCMDS);
@@ -549,6 +554,12 @@ static void pata_macio_qc_prep(struct at
 			addr += len;
 			sg_len -= len;
--
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -624,6 +629,12 @@ static void pdc_fill_sg(struct ata_queue
 			idx++;
 			sg_len -= len;
--
 	while (clocks->xfer_mode) {
 		if (clocks->xfer_mode == speed)
 			return clocks->timing;
 		clocks++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (lap->device) {
 		if (lap->device == pdev->device &&
 		    lap->subvendor == pdev->subsystem_vendor &&
@@ -765,6 +770,12 @@ static int ich_pata_cable_detect(struct
 			return ATA_CBL_PATA40_SHORT;
 
--
-	while (time_before(jiffies, timeout)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (time_before(jiffies, timeout)) {
 		if ((readl(fifo_reg) >> 28) == 0)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-	while (sglen) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sglen) {
 		xfer_cnt = min(sglen, MAX_XFER_COUNT);
 		spin_lock_irqsave(&acdev->host->lock, flags);
 		xfer_ctr = readl(acdev->vbase + XFER_CTR) &
@@ -464,6 +469,11 @@ static int sg_xfer(struct arasan_cf_dev
 		spin_unlock_irqrestore(&acdev->host->lock, flags);
--
 		while (xfer_cnt) {
 			/* wait for read to complete */
 			if (!write) {
@@ -494,6 +504,18 @@ static int sg_xfer(struct arasan_cf_dev
 				if (ret)
 					goto fail;
--
 	while(cb->device) {
 		if (cb->device == pdev->device &&
 		    (cb->subvendor == pdev->subsystem_vendor ||
@@ -112,6 +117,12 @@ static int serverworks_cable_detect(stru
 			return cb->cable_detect(ap);
 		}
--
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -2670,6 +2675,12 @@ static void ata_bmdma_fill_sg(struct ata
 			pi++;
 			sg_len -= len;
--
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -2730,6 +2746,12 @@ static void ata_bmdma_fill_sg_dumb(struc
 			pi++;
 			sg_len -= len;
--
 	while (clocks->xfer_speed) {
 		if (clocks->xfer_speed == speed)
 			return clocks->timing;
 		clocks++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--ata_dev >= link->device) {
 		ata_tdev_delete(ata_dev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
 	while (ap->pflags & (ATA_PFLAG_EH_PENDING | ATA_PFLAG_EH_IN_PROGRESS)) {
 		prepare_to_wait(&ap->eh_wait_q, &wait, TASK_UNINTERRUPTIBLE);
 		spin_unlock_irqrestore(ap->lock, flags);
 		schedule();
 		spin_lock_irqsave(ap->lock, flags);
+		if (_cur < timeout) {
--
 	while (1) {
 		unsigned long now = jiffies;
 		int ready, tmp;
@@ -3413,6 +3418,12 @@ int ata_wait_ready(struct ata_link *link
 		}
 
--
 	while (1) {
 		ata_msleep(link->ap, interval);
 		if ((rc = sata_scr_read(link, SCR_STATUS, &cur)))
@@ -3505,6 +3521,12 @@ int sata_link_debounce(struct ata_link *
 		 */
 		if (time_after(jiffies, deadline))
--
 		while (*text) {
 			if (glob_match(text, pattern) == 0)
 				return 0;  /* Remainder matched */
 			++text;  /* Absorb (match) this char and try again */
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (ad->model_num) {
 		if (!glob_match(model_num, ad->model_num)) {
 			if (ad->model_rev == NULL)
@@ -4259,6 +4297,12 @@ static unsigned long ata_dev_blacklisted
 				return ad->horkage;
 		}
--
 	while (done_mask) {
 		struct ata_queued_cmd *qc;
 		unsigned int tag = __ffs(done_mask);
@@ -4998,6 +5047,12 @@ int ata_qc_complete_multiple(struct ata_
 			nr_done++;
 		}
--
 	while ((tmp & mask) == val && time_before(jiffies, deadline)) {
 		ata_msleep(ap, interval);
 		tmp = ioread32(reg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while (addr < length) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (addr < length) {
 			pdc20621_put_to_dimm(host, buf, addr,
 					     ECC_ERASE_BUF_SZ);
 			addr += ECC_ERASE_BUF_SZ;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (cur_len) {
 			unsigned int tc = min(cur_len, MAX_DMA_BUFFER_SIZE);
 			bd = (struct bcom_ata_bd *)
@@ -486,6 +491,12 @@ mpc52xx_ata_build_dmatable(struct ata_qu
 					"too small\n");
 				goto use_pio_instead;
--
 	while (tag_mask) {
 		num_processed++;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (!(tag_mask & 0x00000001)) {
 			tag++;
 			tag_mask <<= 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	} /* while tag_mask */
 
 	/*
diff -u -p a/ata/pata_octeon_cf.c b/ata/pata_octeon_cf.c
--- a/ata/pata_octeon_cf.c
+++ b/ata/pata_octeon_cf.c
--
 		while (words--) {
 			iowrite8(*buffer, data_addr);
 			buffer++;
@@ -270,6 +275,12 @@ static unsigned int octeon_cf_data_xfer8
 				ioread8(ap->ioaddr.altstatus_addr);
 				count = 16;
--
 		while (words--) {
 			iowrite16(*(uint16_t *)buffer, data_addr);
 			buffer += sizeof(uint16_t);
@@ -309,11 +325,28 @@ static unsigned int octeon_cf_data_xfer1
 				ioread8(ap->ioaddr.altstatus_addr);
 				count = 16;
--
 		while (words--) {
 			*(uint16_t *)buffer = ioread16(data_addr);
 			buffer += sizeof(uint16_t);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (lap->device) {
 		if (lap->device == dev->device &&
 		    lap->subvendor == dev->subsystem_vendor &&
 		    lap->subdevice == dev->subsystem_device)
 			return 1;
 		lap++;
--
-			while ((pos = ffs(check_commands))) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((pos = ffs(check_commands))) {
 				pos--;
 				rc = nv_adma_check_cpb(ap, pos,
 						notifier_error & (1 << pos));
@@ -1019,6 +1024,12 @@ static irqreturn_t nv_adma_interrupt(int
 				else if (unlikely(rc < 0))
--
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -2033,6 +2049,12 @@ static void nv_swncq_fill_sg(struct ata_
 			idx++;
 			sg_len -= len;
--
 	while ((fbs & PORT_FBS_DEC) && retries--) {
 		udelay(1);
 		fbs = readl(port_mmio + PORT_FBS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (status) {
 		if (status & 1)
 			do_IRQ(dev->irq_start + virq);
 		status >>= 1;
 		virq++;
+		if (_cur < timeout) {
--
-	while (ids->id) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ids->id) {
 		if (ids->id == vdev->dev_id) {
 			vdev->divisor = ids->divisor;
 			vlynq_set_drvdata(vdev, ids);
@@ -337,6 +353,12 @@ static int vlynq_device_match(struct dev
 		printk(KERN_DEBUG "Not using the %08x VLYNQ device's driver"
--
 		while (id->name[0] || id->vendor[0]) {
 			if (strcmp(tdev->name, id->name) == 0 &&
 			    strcmp(tdev->vendor, id->vendor) == 0)
 				return id;
 			id++;
+			if (_cur < timeout) {
--
 	while (begin != end) {
 		int middle = begin + (end - begin) / 2;
 		entry = applesmc_get_entry_by_index(middle);
@@ -365,6 +370,12 @@ static int applesmc_get_lower_bound(unsi
 			begin = middle + 1;
 		else
--
 	while (begin != end) {
 		int middle = begin + (end - begin) / 2;
 		entry = applesmc_get_entry_by_index(middle);
@@ -387,6 +403,12 @@ static int applesmc_get_upper_bound(unsi
 			end = middle;
 		else
--
 	while (inb_p(data->addr + ABIT_UGURU_DATA) != state) {
 		timeout--;
 		if (timeout == 0)
@@ -240,6 +245,12 @@ static int abituguru_wait(struct abitugu
 		   this where ABIT_UGURU_WAIT_TIMEOUT_SLEEP is defined. */
 		if (timeout <= ABIT_UGURU_WAIT_TIMEOUT_SLEEP)
--
 	while (len--) {
 		crc = sht15_crc8_table[*value ^ crc];
 		value++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
@@ -621,7 +621,12 @@ static int abituguru3_wait_while_busy(st
 	u8 x;
 	int timeout = ABIT_UGURU3_WAIT_TIMEOUT;
 
-	while ((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
 			ABIT_UGURU3_STATUS_BUSY) {
 		timeout--;
 		if (timeout == 0)
@@ -630,6 +635,12 @@ static int abituguru3_wait_while_busy(st
 		   last chance to respond. */
 		if (timeout == 1)
 			msleep(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (!((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
 			ABIT_UGURU3_STATUS_READY_FOR_READ)) {
 		timeout--;
 		if (timeout == 0)
@@ -649,6 +665,12 @@ static int abituguru3_wait_for_read(stru
 		   last chance to respond. */
--
-	while (!aem_find_aem2(probe, &fi_resp, i)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!aem_find_aem2(probe, &fi_resp, i)) {
 		if (fi_resp.major != 2) {
 			dev_err(probe->bmc_device, "Unknown AEM v%d; please "
 				"report this to the maintainer.\n",
@@ -780,6 +785,12 @@ static void aem_init_aem2(struct aem_ipm
 				err, fi_resp.module_handle);
--
 	while (ro->label) {
 		sysfs_attr_init(&sensors->dev_attr.attr);
 		sensors->dev_attr.attr.name = ro->label;
@@ -942,9 +958,20 @@ static int aem_register_sensors(struct a
 		}
 		sensors++;
--
 	while (rw->label) {
 		sysfs_attr_init(&sensors->dev_attr.attr);
 		sensors->dev_attr.attr.name = rw->label;
@@ -960,6 +987,12 @@ static int aem_register_sensors(struct a
 		}
 		sensors++;
--
 	while (end > start) {
 		mid = start + (end - start) / 2;
 		if (data->comp[mid].ohm < ohm)
@@ -183,6 +188,12 @@ static int lookup_comp(struct ntc_data *
 			start = mid + 1;
 		else
--
 	while (ro->label) {
 		sensors->dev_attr.attr.name = ro->label;
 		sensors->dev_attr.attr.mode = S_IRUGO;
@@ -640,6 +645,12 @@ static int register_ro_attrs(struct acpi
 		sensors++;
 		resource->num_sensors++;
--
 	while (rw->label) {
 		sensors->dev_attr.attr.name = rw->label;
 		sensors->dev_attr.attr.mode = S_IRUGO | S_IWUSR;
@@ -669,6 +685,12 @@ static int register_rw_attrs(struct acpi
 		sensors++;
 		resource->num_sensors++;
--
 	while (eromptr < eromend) {
 		struct bcma_device *core = kzalloc(sizeof(*core), GFP_KERNEL);
 		if (!core)
@@ -419,6 +424,12 @@ int bcma_bus_scan(struct bcma_bus *bus)
 			core->id.class);
 
--
 	while (eromptr < eromend) {
 		memset(core, 0, sizeof(*core));
 		INIT_LIST_HEAD(&core->list);
@@ -477,6 +493,12 @@ int __init bcma_bus_scan_early(struct bc
 		list_add(&core->list, &bus->cores);
 		err = 0;
--
 		while (count) {
 			*buf = __raw_readb(addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le32)__raw_readl(addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writeb(*buf, addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writel((__force u32)(*buf), addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while ((tfsb != fsb) && (tfsb <= max_fsb) && (tfsb >= min_fsb)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((tfsb != fsb) && (tfsb <= max_fsb) && (tfsb >= min_fsb)) {
 		if (diff < 0)
 			tfsb++;
 		else
@@ -219,6 +224,12 @@ static int nforce2_set_fsb(unsigned int
 #ifdef NFORCE2_DELAY
--
 	while ((drv_attr) && (*drv_attr)) {
 		ret = sysfs_create_file(&policy->kobj, &((*drv_attr)->attr));
 		if (ret)
 			goto err_out_kobj_put;
 		drv_attr++;
+		if (_cur < timeout) {
--
 	while (msr_tmp != msr_decode_fsb[i].bitmap) {
 		if (msr_decode_fsb[i].bitmap == 0xff)
 			return 0;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (msr_lo != msr_decode_mult[j].bitmap) {
 		if (msr_decode_mult[j].bitmap == 0xff)
 			return 0;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	/* Wait while CPU is busy */
 	rdmsr(MSR_IA32_PERF_STATUS, lo, hi);
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (lo & ((1 << 16) | (1 << 17))) {
 		udelay(16);
 		rdmsr(MSR_IA32_PERF_STATUS, lo, hi);
@@ -127,6 +132,12 @@ static int eps_set_state(struct eps_cpu_
 			err = -ENODEV;
 			goto postchange;
--
-	while (data->currvid > reqvid) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (data->currvid > reqvid) {
 		pr_debug("ph1: curr 0x%x, req vid 0x%x\n",
 			data->currvid, reqvid);
 		if (decrease_vid_code_by_step(data, reqvid, data->vidmvs))
 			return 1;
+			if (_cur < timeout) {
--
 	while ((rvosteps > 0) &&
diff -u -p a/cpufreq/longhaul.c b/cpufreq/longhaul.c
--- a/cpufreq/longhaul.c
+++ b/cpufreq/longhaul.c
@@ -286,11 +286,22 @@ retry_loop:
 	    || ((pr != NULL) && pr->flags.bm_control))) {
--
 		while (bm_status && bm_timeout) {
 			outw(1 << 4, acpi_regs_addr);
 			bm_timeout--;
 			bm_status = inw(acpi_regs_addr);
 			bm_status &= 1 << 4;
+			if (_cur < timeout) {
--
 		while (i != table_index) {
 			vid = (longhaul_table[i].index >> 8) & 0x1f;
 			if (vid != current_vid) {
@@ -670,6 +686,12 @@ static int longhaul_target(struct cpufre
 				i++;
 			else
--
 	while (tmp_freq < policy->min) {
 		tmp_freq += stock_freq / max_duration;
 		tmp_freq = gx_validate_speed(tmp_freq, &tmp1, &tmp2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (tmp_freq > policy->max) {
 		tmp_freq -= stock_freq / max_duration;
 		tmp_freq = gx_validate_speed(tmp_freq, &tmp1, &tmp2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
