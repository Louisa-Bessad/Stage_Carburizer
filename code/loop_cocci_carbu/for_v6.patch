diff -u -p a/vhost/vhost.c b/vhost/vhost.c
--- a/vhost/vhost.c
+++ b/vhost/vhost.c
@@ -422,6 +422,11 @@ int vhost_zerocopy_signal_used(struct vh
 	int i;
 	int j = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = vq->done_idx; i != vq->upend_idx; i = (i + 1) % UIO_MAXIOV) {
 		if ((vq->heads[i].len == VHOST_DMA_DONE_LEN)) {
 			vq->heads[i].len = VHOST_DMA_CLEAR_LEN;
@@ -430,6 +435,12 @@ int vhost_zerocopy_signal_used(struct vh
 			++j;
 		} else
 			break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (j)
 		vq->done_idx = i;
diff -u -p a/pcmcia/rsrc_nonstatic.c b/pcmcia/rsrc_nonstatic.c
--- a/pcmcia/rsrc_nonstatic.c
+++ b/pcmcia/rsrc_nonstatic.c
@@ -423,6 +423,11 @@ static int do_mem_probe(struct pcmcia_so
 	/* cis_readable wants to map 2x map_size */
 	if (step < 2 * s->map_size)
 		step = 2 * s->map_size;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = j = base; i < base+num; i = j + step) {
 		if (!fail) {
 			for (j = i; j < base+num; j += step) {
@@ -443,6 +448,12 @@ static int do_mem_probe(struct pcmcia_so
 			sub_interval(&s_data->mem_db, i, j-i);
 			bad += j-i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(bad ? "\n" : " clean.\n");
 	return num - bad;
@@ -500,6 +511,11 @@ static int validate_mem(struct pcmcia_so
 		return -ENODEV;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = s_data->mem_db.next; m != &s_data->mem_db; m = mm.next) {
 		mm = *m;
 		/* Only probe < 1 MB */
@@ -521,6 +537,12 @@ static int validate_mem(struct pcmcia_so
 							   readable, checksum);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ok > 0)
@@ -544,9 +566,20 @@ static int validate_mem(struct pcmcia_so
 	struct socket_data *s_data = s->resource_data;
 	unsigned long ok = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = s_data->mem_db.next; m != &s_data->mem_db; m = mm.next) {
 		mm = *m;
 		ok += do_mem_probe(s, mm.base, mm.num, readable, checksum);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (ok > 0)
 		return 0;
@@ -658,6 +691,11 @@ static int __nonstatic_adjust_io_region(
 	struct socket_data *s_data = s->resource_data;
 	int ret = -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = s_data->io_db.next; m != &s_data->io_db; m = m->next) {
 		unsigned long start = m->base;
 		unsigned long end = m->base + m->num - 1;
@@ -666,6 +704,12 @@ static int __nonstatic_adjust_io_region(
 			continue;
 
 		ret = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
@@ -1040,17 +1084,50 @@ static void nonstatic_release_resource_d
 	struct socket_data *data = s->resource_data;
 	struct resource_map *p, *q;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db_valid.next; p != &data->mem_db_valid; p = q) {
 		q = p->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db.next; p != &data->mem_db; p = q) {
 		q = p->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->io_db.next; p != &data->io_db; p = q) {
 		q = p->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1078,6 +1155,11 @@ static ssize_t show_io_db(struct device
 	mutex_lock(&s->ops_mutex);
 	data = s->resource_data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->io_db.next; p != &data->io_db; p = p->next) {
 		if (ret > (PAGE_SIZE - 10))
 			continue;
@@ -1085,6 +1167,12 @@ static ssize_t show_io_db(struct device
 				"0x%08lx - 0x%08lx\n",
 				((unsigned long) p->base),
 				((unsigned long) p->base + p->num - 1));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&s->ops_mutex);
@@ -1134,6 +1222,11 @@ static ssize_t show_mem_db(struct device
 	mutex_lock(&s->ops_mutex);
 	data = s->resource_data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db_valid.next; p != &data->mem_db_valid;
 	     p = p->next) {
 		if (ret > (PAGE_SIZE - 10))
@@ -1142,8 +1235,19 @@ static ssize_t show_mem_db(struct device
 				"0x%08lx - 0x%08lx\n",
 				((unsigned long) p->base),
 				((unsigned long) p->base + p->num - 1));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db.next; p != &data->mem_db; p = p->next) {
 		if (ret > (PAGE_SIZE - 10))
 			continue;
@@ -1151,6 +1255,12 @@ static ssize_t show_mem_db(struct device
 				"0x%08lx - 0x%08lx\n",
 				((unsigned long) p->base),
 				((unsigned long) p->base + p->num - 1));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&s->ops_mutex);
diff -u -p a/input/touchscreen/max11801_ts.c b/input/touchscreen/max11801_ts.c
--- a/input/touchscreen/max11801_ts.c
+++ b/input/touchscreen/max11801_ts.c
@@ -121,6 +121,11 @@ static irqreturn_t max11801_ts_interrupt
 		if (ret < XY_BUFSIZE)
 			goto out;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < XY_BUFSIZE; i += XY_BUFSIZE / 2) {
 			if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_X_TAG)
 				x = (buf[i] << XY_BUF_OFFSET) +
@@ -128,6 +133,12 @@ static irqreturn_t max11801_ts_interrupt
 			else if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_Y_TAG)
 				y = (buf[i] << XY_BUF_OFFSET) +
 				    (buf[i + 1] >> XY_BUF_OFFSET);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if ((buf[1] & EVENT_TAG_MASK) != (buf[3] & EVENT_TAG_MASK))
diff -u -p a/gpu/drm/nouveau/nouveau_ramht.c b/gpu/drm/nouveau/nouveau_ramht.c
--- a/gpu/drm/nouveau/nouveau_ramht.c
+++ b/gpu/drm/nouveau/nouveau_ramht.c
@@ -38,9 +38,20 @@ nouveau_ramht_hash_handle(struct nouveau
 
 	NV_DEBUG(dev, "ch%d handle=0x%08x\n", chan->id, handle);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 32; i > 0; i -= ramht->bits) {
 		hash ^= (handle & ((1 << ramht->bits) - 1));
 		handle >>= ramht->bits;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (dev_priv->card_type < NV_50)
diff -u -p a/gpu/drm/mga/mga_dma.c b/gpu/drm/mga/mga_dma.c
--- a/gpu/drm/mga/mga_dma.c
+++ b/gpu/drm/mga/mga_dma.c
@@ -234,10 +234,21 @@ static void mga_freelist_print(struct dr
 				dev_priv->primary->offset));
 	DRM_INFO("current freelist:\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (entry = dev_priv->head->next; entry; entry = entry->next) {
 		DRM_INFO("   %p   idx=%2d  age=0x%x 0x%06lx\n",
 			 entry, entry->buf->idx, entry->age.head,
 			 (unsigned long)(entry->age.head - dev_priv->primary->offset));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	DRM_INFO("\n");
 }
diff -u -p a/gpu/drm/mga/mga_warp.c b/gpu/drm/mga/mga_warp.c
--- a/gpu/drm/mga/mga_warp.c
+++ b/gpu/drm/mga/mga_warp.c
@@ -88,11 +88,22 @@ int mga_warp_install_microcode(drm_mga_p
 
 	size = 0;
 	where = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)fw->data;
 	     rec;
 	     rec = ihex_next_binrec(rec)) {
 		size += WARP_UCODE_SIZE(be16_to_cpu(rec->len));
 		where++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (where != n_pipes) {
@@ -112,6 +123,11 @@ int mga_warp_install_microcode(drm_mga_p
 	memset(dev_priv->warp_pipe_phys, 0, sizeof(dev_priv->warp_pipe_phys));
 
 	where = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)fw->data;
 	     rec;
 	     rec = ihex_next_binrec(rec)) {
@@ -125,6 +141,12 @@ int mga_warp_install_microcode(drm_mga_p
 		pcbase += dst_size;
 		vcbase += dst_size;
 		where++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
diff -u -p a/gpu/drm/vmwgfx/vmwgfx_fb.c b/gpu/drm/vmwgfx/vmwgfx_fb.c
--- a/gpu/drm/vmwgfx/vmwgfx_fb.c
+++ b/gpu/drm/vmwgfx/vmwgfx_fb.c
@@ -237,9 +237,20 @@ static void vmw_fb_dirty_flush(struct vm
 	par->dirty.y1 = par->dirty.y2 = 0;
 	spin_unlock_irqrestore(&par->dirty.lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = y * stride; i < info->fix.smem_len / 4; i += stride) {
 		for (k = i+x; k < i+x+w && k < info->fix.smem_len / 4; k++)
 			iowrite32(src[k], vram_mem + k);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 #if 0
diff -u -p a/gpu/drm/i915/i915_mem.c b/gpu/drm/i915/i915_mem.c
--- a/gpu/drm/i915/i915_mem.c
+++ b/gpu/drm/i915/i915_mem.c
@@ -137,10 +137,21 @@ static struct mem_block *alloc_block(str
 	struct mem_block *p;
 	int mask = (1 << align2) - 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = heap->next; p != heap; p = p->next) {
 		int start = (p->start + mask) & ~mask;
 		if (p->file_priv == NULL && start + size <= p->start + p->size)
 			return split_block(p, start, size, file_priv);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
@@ -217,16 +228,32 @@ void i915_mem_release(struct drm_device
 	if (!heap || !heap->next)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = heap->next; p != heap; p = p->next) {
 		if (p->file_priv == file_priv) {
 			p->file_priv = NULL;
 			mark_block(dev, p, 0);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Assumes a single contiguous range.  Needs a special file_priv in
 	 * 'heap' to stop it being subsumed.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = heap->next; p != heap; p = p->next) {
 		while (p->file_priv == NULL && p->next->file_priv == NULL) {
 			struct mem_block *q = p->next;
@@ -235,6 +262,12 @@ void i915_mem_release(struct drm_device
 			p->next->prev = p;
 			kfree(q);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/drm_edid.c b/gpu/drm/drm_edid.c
--- a/gpu/drm/drm_edid.c
+++ b/gpu/drm/drm_edid.c
@@ -1455,6 +1455,11 @@ void drm_edid_to_eld(struct drm_connecto
 	eld[18] = edid->prod_code[0];
 	eld[19] = edid->prod_code[1];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (db = cea + 4; db < cea + cea[2]; db += dbl + 1) {
 		dbl = db[0] & 0x1f;
 
@@ -1474,6 +1479,12 @@ void drm_edid_to_eld(struct drm_connecto
 		default:
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	eld[5] |= sad_count << 4;
 	eld[2] = (20 + mnl + sad_count * 3 + 3) / 4;
@@ -1619,6 +1630,11 @@ bool drm_detect_monitor_audio(struct edi
 	start_offset = 4;
 	end_offset = edid_ext[2];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start_offset; i < end_offset;
 			i += ((edid_ext[i] & 0x1f) + 1)) {
 		if ((edid_ext[i] >> 5) == AUDIO_BLOCK) {
@@ -1628,6 +1644,12 @@ bool drm_detect_monitor_audio(struct edi
 					      (edid_ext[i + j] >> 3) & 0xf);
 			goto end;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 end:
 	return has_audio;
diff -u -p a/mfd/htc-egpio.c b/mfd/htc-egpio.c
--- a/mfd/htc-egpio.c
+++ b/mfd/htc-egpio.c
@@ -236,6 +236,11 @@ static void egpio_write_cache(struct egp
 		if (!egpio->is_out)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (shift = 0; shift < egpio->chip.ngpio;
 				shift += (1<<ei->reg_shift)) {
 
@@ -250,6 +255,12 @@ static void egpio_write_cache(struct egp
 
 			egpio_writew((egpio->cached_values >> shift)
 					& ei->reg_mask, ei, reg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
diff -u -p a/oprofile/buffer_sync.c b/oprofile/buffer_sync.c
--- a/oprofile/buffer_sync.c
+++ b/oprofile/buffer_sync.c
@@ -229,6 +229,11 @@ static unsigned long get_exec_dcookie(st
 	if (!mm)
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
 		if (!vma->vm_file)
 			continue;
@@ -236,6 +241,12 @@ static unsigned long get_exec_dcookie(st
 			continue;
 		cookie = fast_get_dcookie(&vma->vm_file->f_path);
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
@@ -254,6 +265,11 @@ lookup_dcookie(struct mm_struct *mm, uns
 	unsigned long cookie = NO_COOKIE;
 	struct vm_area_struct *vma;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vma = find_vma(mm, addr); vma; vma = vma->vm_next) {
 
 		if (addr < vma->vm_start || addr >= vma->vm_end)
@@ -269,6 +285,12 @@ lookup_dcookie(struct mm_struct *mm, uns
 		}
 
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!vma)
diff -u -p a/gpio/gpio-msm-v2.c b/gpio/gpio-msm-v2.c
--- a/gpio/gpio-msm-v2.c
+++ b/gpio/gpio-msm-v2.c
@@ -317,12 +317,23 @@ static void msm_summary_irq_handler(unsi
 
 	chained_irq_enter(chip, desc);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = find_first_bit(msm_gpio.enabled_irqs, NR_GPIO_IRQS);
 	     i < NR_GPIO_IRQS;
 	     i = find_next_bit(msm_gpio.enabled_irqs, NR_GPIO_IRQS, i + 1)) {
 		if (readl(GPIO_INTR_STATUS(i)) & BIT(INTR_STATUS))
 			generic_handle_irq(msm_gpio_to_irq(&msm_gpio.gpio_chip,
 							   i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	chained_irq_exit(chip, desc);
diff -u -p a/ata/libata-core.c b/ata/libata-core.c
--- a/ata/libata-core.c
+++ b/ata/libata-core.c
@@ -5804,12 +5804,23 @@ static void ata_finalize_port_ops(struct
 
 	spin_lock(&lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur = ops->inherits; cur; cur = cur->inherits) {
 		void **inherit = (void **)cur;
 
 		for (pp = begin; pp < end; pp++, inherit++)
 			if (!*pp)
 				*pp = *inherit;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (pp = begin; pp < end; pp++)
@@ -6460,6 +6471,11 @@ static void __init ata_parse_force_param
 	}
 
 	/* parse and populate the table */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur = ata_force_param_buf; *cur != '\0'; cur = next) {
 		const char *reason = "";
 		struct ata_force_ent te = { .port = -1, .device = -1 };
@@ -6481,6 +6497,12 @@ static void __init ata_parse_force_param
 
 		last_port = te.port;
 		last_device = te.device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ata_force_tbl_size = idx;
diff -u -p a/staging/rtl8192e/rtllib_crypt.c b/staging/rtl8192e/rtllib_crypt.c
--- a/staging/rtl8192e/rtllib_crypt.c
+++ b/staging/rtl8192e/rtllib_crypt.c
@@ -39,6 +39,11 @@ void rtllib_crypt_deinit_entries(struct
 	struct list_head *ptr, *n;
 	struct rtllib_crypt_data *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
 	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct rtllib_crypt_data, list);
@@ -51,6 +56,12 @@ void rtllib_crypt_deinit_entries(struct
 		if (entry->ops)
 			entry->ops->deinit(entry->priv);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -227,6 +238,11 @@ void __exit rtllib_crypto_deinit(void)
 	if (hcrypt == NULL)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;
 	     ptr = n, n = ptr->next) {
 		struct rtllib_crypto_alg *alg =
@@ -235,6 +251,12 @@ void __exit rtllib_crypto_deinit(void)
 		printk(KERN_DEBUG "rtllib_crypt: unregistered algorithm "
 		       "'%s' (deinit)\n", alg->ops->name);
 		kfree(alg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(hcrypt);
diff -u -p a/staging/rtl8187se/r8180_core.c b/staging/rtl8187se/r8180_core.c
--- a/staging/rtl8187se/r8180_core.c
+++ b/staging/rtl8187se/r8180_core.c
@@ -621,6 +621,11 @@ void fix_rx_fifo(struct net_device *dev)
 
 	rx_desc_size = 8; /* 4*8 = 32 bytes */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tmp = priv->rxring, rxbuf = priv->rxbufferhead;
 	     (tmp < (priv->rxring)+(priv->rxringcount)*rx_desc_size);
 	     tmp += rx_desc_size, rxbuf = rxbuf->next) {
@@ -628,6 +633,12 @@ void fix_rx_fifo(struct net_device *dev)
 		*tmp = *tmp & ~0xfff;
 		*tmp = *tmp | priv->rxbuffersize;
 		*tmp |= (1<<31);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	priv->rxringtail = priv->rxring;
diff -u -p a/staging/rtl8187se/ieee80211/ieee80211_crypt.c b/staging/rtl8187se/ieee80211/ieee80211_crypt.c
--- a/staging/rtl8187se/ieee80211/ieee80211_crypt.c
+++ b/staging/rtl8187se/ieee80211/ieee80211_crypt.c
@@ -43,6 +43,11 @@ void ieee80211_crypt_deinit_entries(stru
 	struct list_head *ptr, *n;
 	struct ieee80211_crypt_data *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
 	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct ieee80211_crypt_data, list);
@@ -55,6 +60,12 @@ void ieee80211_crypt_deinit_entries(stru
 		if (entry->ops)
 			entry->ops->deinit(entry->priv);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/comedi/drivers/amplc_dio200.c b/staging/comedi/drivers/amplc_dio200.c
--- a/staging/comedi/drivers/amplc_dio200.c
+++ b/staging/comedi/drivers/amplc_dio200.c
@@ -562,6 +562,11 @@ dio200_find_pci(struct comedi_device *de
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
@@ -596,6 +601,12 @@ dio200_find_pci(struct comedi_device *de
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/amplc_pc236.c b/staging/comedi/drivers/amplc_pc236.c
--- a/staging/comedi/drivers/amplc_pc236.c
+++ b/staging/comedi/drivers/amplc_pc236.c
@@ -267,6 +267,11 @@ pc236_find_pci(struct comedi_device *dev
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
@@ -301,6 +306,12 @@ pc236_find_pci(struct comedi_device *dev
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/dyna_pci10xx.c b/staging/comedi/drivers/dyna_pci10xx.c
--- a/staging/comedi/drivers/dyna_pci10xx.c
+++ b/staging/comedi/drivers/dyna_pci10xx.c
@@ -286,6 +286,11 @@ static int dyna_pci10xx_attach(struct co
 	/*
 	 * Probe the PCI bus and located the matching device
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
@@ -310,6 +315,12 @@ static int dyna_pci10xx_attach(struct co
 		}
 
 		goto found;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "comedi: dyna_pci10xx: no supported device found!\n");
 	mutex_unlock(&start_stop_sem);
diff -u -p a/staging/comedi/drivers/ni_65xx.c b/staging/comedi/drivers/ni_65xx.c
--- a/staging/comedi/drivers/ni_65xx.c
+++ b/staging/comedi/drivers/ni_65xx.c
@@ -809,6 +809,11 @@ static int ni_65xx_find_device(struct co
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -824,6 +829,12 @@ static int ni_65xx_find_device(struct co
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_WARNING "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/ni_pcimio.c b/staging/comedi/drivers/ni_pcimio.c
--- a/staging/comedi/drivers/ni_pcimio.c
+++ b/staging/comedi/drivers/ni_pcimio.c
@@ -1769,6 +1769,11 @@ static int pcimio_find_device(struct com
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -1786,6 +1791,12 @@ static int pcimio_find_device(struct com
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/ni_670x.c b/staging/comedi/drivers/ni_670x.c
--- a/staging/comedi/drivers/ni_670x.c
+++ b/staging/comedi/drivers/ni_670x.c
@@ -362,6 +362,11 @@ static int ni_670x_find_device(struct co
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -379,6 +384,12 @@ static int ni_670x_find_device(struct co
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_INFO "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/amplc_pc263.c b/staging/comedi/drivers/amplc_pc263.c
--- a/staging/comedi/drivers/amplc_pc263.c
+++ b/staging/comedi/drivers/amplc_pc263.c
@@ -169,6 +169,11 @@ pc263_find_pci(struct comedi_device *dev
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
@@ -203,6 +208,12 @@ pc263_find_pci(struct comedi_device *dev
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/mite.c b/staging/comedi/drivers/mite.c
--- a/staging/comedi/drivers/mite.c
+++ b/staging/comedi/drivers/mite.c
@@ -212,10 +212,21 @@ void mite_cleanup(void)
 {
 	struct mite_struct *mite, *next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = next) {
 		pci_dev_put(mite->pcidev);
 		next = mite->next;
 		kfree(mite);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -248,13 +259,25 @@ void mite_list_devices(void)
 	struct mite_struct *mite, *next;
 
 	printk(KERN_INFO "Available NI device IDs:");
-	if (mite_devices)
+	if (mite_devices) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (mite = mite_devices; mite; mite = next) {
 			next = mite->next;
 			printk(KERN_INFO " 0x%04x", mite_device_id(mite));
 			if (mite->used)
 				printk(KERN_INFO "(used)");
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
+	}
 	printk(KERN_INFO "\n");
 }
 EXPORT_SYMBOL(mite_list_devices);
diff -u -p a/staging/comedi/drivers/amplc_pci224.c b/staging/comedi/drivers/amplc_pci224.c
--- a/staging/comedi/drivers/amplc_pci224.c
+++ b/staging/comedi/drivers/amplc_pci224.c
@@ -1327,6 +1327,11 @@ pci224_find_pci(struct comedi_device *de
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID,
@@ -1359,6 +1364,12 @@ pci224_find_pci(struct comedi_device *de
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/ni_660x.c b/staging/comedi/drivers/ni_660x.c
--- a/staging/comedi/drivers/ni_660x.c
+++ b/staging/comedi/drivers/ni_660x.c
@@ -1251,6 +1251,11 @@ static int ni_660x_find_device(struct co
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -1267,6 +1272,12 @@ static int ni_660x_find_device(struct co
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_WARNING "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/ni_labpc.c b/staging/comedi/drivers/ni_labpc.c
--- a/staging/comedi/drivers/ni_labpc.c
+++ b/staging/comedi/drivers/ni_labpc.c
@@ -779,6 +779,11 @@ static int labpc_find_device(struct come
 {
 	struct mite_struct *mite;
 	int i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -798,6 +803,12 @@ static int labpc_find_device(struct come
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/ni_6527.c b/staging/comedi/drivers/ni_6527.c
--- a/staging/comedi/drivers/ni_6527.c
+++ b/staging/comedi/drivers/ni_6527.c
@@ -469,6 +469,11 @@ static int ni6527_find_device(struct com
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -484,6 +489,12 @@ static int ni6527_find_device(struct com
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "comedi 6527: no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/adv_pci_dio.c b/staging/comedi/drivers/adv_pci_dio.c
--- a/staging/comedi/drivers/adv_pci_dio.c
+++ b/staging/comedi/drivers/adv_pci_dio.c
@@ -1077,10 +1077,21 @@ static int CheckAndAllocCard(struct come
 {
 	struct pci_dio_private *pr, *prev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pr = pci_priv, prev = NULL; pr != NULL; prev = pr, pr = pr->next) {
 		if (pr->pcidev == pcidev)
 			return 0; /* this card is used, look for another */
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (prev) {
diff -u -p a/staging/comedi/drivers/ni_pcidio.c b/staging/comedi/drivers/ni_pcidio.c
--- a/staging/comedi/drivers/ni_pcidio.c
+++ b/staging/comedi/drivers/ni_pcidio.c
@@ -1295,6 +1295,11 @@ static int nidio_find_device(struct come
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -1311,6 +1316,12 @@ static int nidio_find_device(struct come
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_WARNING "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/daqboard2000.c b/staging/comedi/drivers/daqboard2000.c
--- a/staging/comedi/drivers/daqboard2000.c
+++ b/staging/comedi/drivers/daqboard2000.c
@@ -746,6 +746,11 @@ static int daqboard2000_attach(struct co
 	if (result < 0) {
 		return -ENOMEM;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (card = pci_get_device(0x1616, 0x0409, NULL);
 	     card != NULL; card = pci_get_device(0x1616, 0x0409, card)) {
 		if (bus || slot) {
@@ -756,6 +761,12 @@ static int daqboard2000_attach(struct co
 			}
 		}
 		break;		/* found one */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!card) {
 		if (bus || slot)
diff -u -p a/staging/comedi/drivers/dt3000.c b/staging/comedi/drivers/dt3000.c
--- a/staging/comedi/drivers/dt3000.c
+++ b/staging/comedi/drivers/dt3000.c
@@ -1010,6 +1010,11 @@ static struct pci_dev *dt_pci_find_devic
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (from = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from);
 	     from != NULL;
 	     from = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from)) {
@@ -1022,6 +1027,12 @@ static struct pci_dev *dt_pci_find_devic
 		printk
 		    ("unknown Data Translation PCI device found with device_id=0x%04x\n",
 		     from->device);
+		    if (_cur < timeout) {
+			rdstcll(_cur);
+		    }
+		    else {
+			break;
+		    }
 	}
 	*board = -1;
 	return from;
diff -u -p a/staging/comedi/proc.c b/staging/comedi/proc.c
--- a/staging/comedi/proc.c
+++ b/staging/comedi/proc.c
@@ -69,6 +69,11 @@ static int comedi_read(char *buf, char *
 	if (!devices_q)
 		l += sprintf(buf + l, "no devices\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		l += sprintf(buf + l, "%s:\n", driv->driver_name);
 		for (i = 0; i < driv->num_names; i++) {
@@ -78,6 +83,12 @@ static int comedi_read(char *buf, char *
 		}
 		if (!driv->num_names)
 			l += sprintf(buf + l, " %s\n", driv->driver_name);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return l;
diff -u -p a/staging/comedi/drivers.c b/staging/comedi/drivers.c
--- a/staging/comedi/drivers.c
+++ b/staging/comedi/drivers.c
@@ -115,6 +115,11 @@ int comedi_device_attach(struct comedi_d
 	if (dev->attached)
 		return -EBUSY;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
 			printk(KERN_INFO "comedi: failed to increment module count, skipping\n");
@@ -142,10 +147,21 @@ int comedi_device_attach(struct comedi_d
 			return ret;
 		}
 		goto attached;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*  recognize has failed if we get here */
 	/*  report valid board names before returning error */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
 			printk(KERN_INFO
@@ -154,6 +170,12 @@ int comedi_device_attach(struct comedi_d
 		}
 		comedi_report_boards(driv);
 		module_put(driv->module);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EIO;
 
@@ -216,11 +238,22 @@ int comedi_driver_unregister(struct come
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = comedi_drivers; prev->next; prev = prev->next) {
 		if (prev->next == driver) {
 			prev->next = driver->next;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EINVAL;
 }
diff -u -p a/staging/sbe-2t3e3/main.c b/staging/sbe-2t3e3/main.c
--- a/staging/sbe-2t3e3/main.c
+++ b/staging/sbe-2t3e3/main.c
@@ -77,6 +77,11 @@ int t3e3_if_start_xmit(struct sk_buff *s
 	dev_dbg(&sc->pdev->dev, "sending mbuf (current_write = %d)\n",
 		current_write);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (skb2 = skb; skb2 != NULL; skb2 = NULL) {
 		if (skb2->len) {
 			dev_dbg(&sc->pdev->dev,
@@ -106,6 +111,12 @@ int t3e3_if_start_xmit(struct sk_buff *s
 			last_write = current_write;
 			current_write = (current_write + 1) % SBE_2T3E3_TX_DESC_RING_SIZE;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sc->ether.tx_data[last_write] = skb;
diff -u -p a/staging/rtl8192u/ieee80211/ieee80211_crypt.c b/staging/rtl8192u/ieee80211/ieee80211_crypt.c
--- a/staging/rtl8192u/ieee80211/ieee80211_crypt.c
+++ b/staging/rtl8192u/ieee80211/ieee80211_crypt.c
@@ -43,6 +43,11 @@ void ieee80211_crypt_deinit_entries(stru
 	struct list_head *ptr, *n;
 	struct ieee80211_crypt_data *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
 	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct ieee80211_crypt_data, list);
@@ -55,6 +60,12 @@ void ieee80211_crypt_deinit_entries(stru
 		if (entry->ops)
 			entry->ops->deinit(entry->priv);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -227,6 +238,11 @@ void __exit ieee80211_crypto_deinit(void
 	if (hcrypt == NULL)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;
 	     ptr = n, n = ptr->next) {
 		struct ieee80211_crypto_alg *alg =
@@ -235,6 +251,12 @@ void __exit ieee80211_crypto_deinit(void
 		printk(KERN_DEBUG "ieee80211_crypt: unregistered algorithm "
 		       "'%s' (deinit)\n", alg->ops->name);
 		kfree(alg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(hcrypt);
diff -u -p a/staging/media/solo6x10/v4l2-enc.c b/staging/media/solo6x10/v4l2-enc.c
--- a/staging/media/solo6x10/v4l2-enc.c
+++ b/staging/media/solo6x10/v4l2-enc.c
@@ -275,6 +275,11 @@ static void enc_write_sg(struct scatterl
 	struct scatterlist *sg;
 	u8 *src = buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sg = sglist; sg && size > 0; sg = sg_next(sg)) {
 		u8 *p = sg_virt(sg);
 		size_t len = sg_dma_len(sg);
@@ -282,6 +287,12 @@ static void enc_write_sg(struct scatterl
 
 		for (i = 0; i < len && size; i++)
 			p[i] = *(src++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -395,6 +406,11 @@ static void solo_jpeg_header(struct solo
 	size_t copied = 0;
 	size_t to_copy = sizeof(jpeg_header);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sg = vbuf->sglist; sg && copied < to_copy; sg = sg_next(sg)) {
 		size_t this_copy = min(sg_dma_len(sg),
 				       (unsigned int)(to_copy - copied));
@@ -414,6 +430,12 @@ static void solo_jpeg_header(struct solo
 			p[(SOF0_START + 8) - copied] = 0xff & solo_enc->width;
 
 		copied += this_copy;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/media/solo6x10/g723.c b/staging/media/solo6x10/g723.c
--- a/staging/media/solo6x10/g723.c
+++ b/staging/media/solo6x10/g723.c
@@ -87,6 +87,11 @@ void solo_g723_isr(struct solo_dev *solo
 
 	solo_reg_write(solo_dev, SOLO_IRQ_STAT, SOLO_IRQ_G723);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ss = pstr->substream; ss != NULL; ss = ss->next) {
 		if (snd_pcm_substream_chip(ss) == NULL)
 			continue;
@@ -101,6 +106,12 @@ void solo_g723_isr(struct solo_dev *solo
 			continue;
 
 		snd_pcm_period_elapsed(ss);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/media/go7007/go7007-fw.c b/staging/media/go7007/go7007-fw.c
--- a/staging/media/go7007/go7007-fw.c
+++ b/staging/media/go7007/go7007-fw.c
@@ -395,6 +395,11 @@ static int gen_mjpeghdr_to_package(struc
 	memmove(buf + size, buf + size + 80, chunk - 80);
 	size += chunk - 80;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < size; i += chunk * 2) {
 		if (space - off < 32) {
 			off = -1;
@@ -421,6 +426,12 @@ static int gen_mjpeghdr_to_package(struc
 
 		memcpy(&code[off + 2], buf + i, chunk * 2);
 		off += 32;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 done:
 	kfree(buf);
@@ -686,6 +697,11 @@ static int gen_mpeg1hdr_to_package(struc
 	i += 1632 + 16;
 	mpeg1_sequence_header(go, buf + i, 0);
 	i += 40;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 5120; i += chunk * 2) {
 		if (space - off < 32) {
 			off = -1;
@@ -715,6 +731,12 @@ static int gen_mpeg1hdr_to_package(struc
 
 		memcpy(&code[off + 2], buf + i, chunk * 2);
 		off += 32;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 done:
 	kfree(buf);
@@ -855,6 +877,11 @@ static int gen_mpeg4hdr_to_package(struc
 	i += 16;
 	mpeg4_sequence_header(go, buf + i, 0);
 	i += 40;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 5120; i += chunk * 2) {
 		if (space - off < 32) {
 			off = -1;
@@ -884,6 +911,12 @@ static int gen_mpeg4hdr_to_package(struc
 
 		memcpy(&code[off + 2], buf + i, chunk * 2);
 		off += 32;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mem = 0x3e00;
 	addr = go->ipb ? 0x14f9 : 0x0af9;
@@ -898,6 +931,11 @@ static int gen_mpeg4hdr_to_package(struc
 	i += 1632;
 	mpeg4_frame_header(go, buf + i, 1, BFRAME_EMPTY);
 	i += 16;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 5120; i += chunk * 2) {
 		if (space - off < 32) {
 			off = -1;
@@ -927,6 +965,12 @@ static int gen_mpeg4hdr_to_package(struc
 
 		memcpy(&code[off + 2], buf + i, chunk * 2);
 		off += 32;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 done:
 	kfree(buf);
diff -u -p a/staging/media/lirc/lirc_sir.c b/staging/media/lirc/lirc_sir.c
--- a/staging/media/lirc/lirc_sir.c
+++ b/staging/media/lirc/lirc_sir.c
@@ -713,6 +713,11 @@ static void send_pulse(unsigned long len
 	 * due to integer arithmetic, but we can accept this inaccuracy
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = flag = 0; k < length; k += delay, flag = !flag) {
 		if (flag) {
 			off();
@@ -722,6 +727,12 @@ static void send_pulse(unsigned long len
 			delay = pulse_width;
 		}
 		safe_udelay(delay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	off();
 }
diff -u -p a/staging/tidspbridge/gen/gh.c b/staging/tidspbridge/gen/gh.c
--- a/staging/tidspbridge/gen/gh.c
+++ b/staging/tidspbridge/gen/gh.c
@@ -79,11 +79,22 @@ void gh_delete(struct gh_t_hash_tab *has
 	if (hash_tab != NULL) {
 		if (hash_tab->buckets != NULL) {
 			for (i = 0; i < hash_tab->max_bucket; i++) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (elem = hash_tab->buckets[i]; elem != NULL;
 				     elem = next) {
 					next = elem->next;
 					(*hash_tab->delete) (elem->data);
 					kfree(elem);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 
diff -u -p a/staging/tidspbridge/rmgr/dspdrv.c b/staging/tidspbridge/rmgr/dspdrv.c
--- a/staging/tidspbridge/rmgr/dspdrv.c
+++ b/staging/tidspbridge/rmgr/dspdrv.c
@@ -79,12 +79,23 @@ u32 dsp_init(u32 *init_status)
 		 * unloading. Get the Driver Object iterate through and remove.
 		 * Reset the status to E_FAIL to avoid going through
 		 * api_init_complete2. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (device_node = drv_get_first_dev_extension();
 		     device_node != 0;
 		     device_node = drv_get_next_dev_extension(device_node)) {
 			(void)dev_remove_device((struct cfg_devnode *)
 						device_node);
 			(void)drv_release_resources((u32) device_node, drv_obj);
+			if (_cur < timeout) {
+			    rdstcll(_cur);
+			}
+			else {
+			    break;
+			}
 		}
 		/* Remove the Driver Object */
 		(void)drv_destroy(drv_obj);
diff -u -p a/staging/tidspbridge/rmgr/pwr.c b/staging/tidspbridge/rmgr/pwr.c
--- a/staging/tidspbridge/rmgr/pwr.c
+++ b/staging/tidspbridge/rmgr/pwr.c
@@ -45,6 +45,11 @@ int pwr_sleep_dsp(const u32 sleep_code,
 	u32 ioctlcode = 0;
 	u32 arg = timeout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj =
@@ -71,6 +76,12 @@ int pwr_sleep_dsp(const u32 sleep_code,
 							      ioctlcode,
 							      (void *)&arg);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 }
@@ -87,6 +98,11 @@ int pwr_wake_dsp(const u32 timeout)
 	struct dev_object *hdev_obj = NULL;
 	u32 arg = timeout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
@@ -102,6 +118,12 @@ int pwr_wake_dsp(const u32 timeout)
 							(void *)&arg);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 }
@@ -121,6 +143,11 @@ int pwr_pm_pre_scale(u16 voltage_domain,
 	arg[0] = voltage_domain;
 	arg[1] = level;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
@@ -136,6 +163,12 @@ int pwr_pm_pre_scale(u16 voltage_domain,
 						(void *)&arg);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 }
@@ -155,6 +188,11 @@ int pwr_pm_post_scale(u16 voltage_domain
 	arg[0] = voltage_domain;
 	arg[1] = level;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
@@ -170,6 +208,12 @@ int pwr_pm_post_scale(u16 voltage_domain
 						(void *)&arg);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 
diff -u -p a/staging/tidspbridge/dynload/tramp.c b/staging/tidspbridge/dynload/tramp.c
--- a/staging/tidspbridge/dynload/tramp.c
+++ b/staging/tidspbridge/dynload/tramp.c
@@ -183,6 +183,11 @@ static struct tramp_string *priv_tramp_s
 	u32 i;
 	u32 str_len = strlen(str);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_str = dlthis->tramp.string_head;
 	     (ret_val == NULL) && (cur_str != NULL); cur_str = cur_str->next) {
 		/*  If the string lengths aren't equal, don't bother
@@ -201,6 +206,12 @@ static struct tramp_string *priv_tramp_s
 
 		if (i == str_len)
 			ret_val = cur_str;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret_val;
@@ -1094,6 +1105,11 @@ void dload_tramp_cleanup(struct dload_st
 		return;
 
 	/*  Destroy all tramp information */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_sym = tramp->symbol_head;
 	     cur_sym != NULL; cur_sym = tramp->symbol_head) {
 		tramp->symbol_head = cur_sym->next;
@@ -1101,12 +1117,23 @@ void dload_tramp_cleanup(struct dload_st
 			tramp->symbol_tail = NULL;
 
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_sym);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (tramp->final_sym_table != NULL)
 		dlthis->mysym->dload_deallocate(dlthis->mysym,
 						tramp->final_sym_table);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_string = tramp->string_head;
 	     cur_string != NULL; cur_string = tramp->string_head) {
 		tramp->string_head = cur_string->next;
@@ -1114,30 +1141,69 @@ void dload_tramp_cleanup(struct dload_st
 			tramp->string_tail = NULL;
 
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_string);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (tramp->final_string_table != NULL)
 		dlthis->mysym->dload_deallocate(dlthis->mysym,
 						tramp->final_string_table);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_tramp_pkt = tramp->tramp_pkts;
 	     cur_tramp_pkt != NULL; cur_tramp_pkt = tramp->tramp_pkts) {
 		tramp->tramp_pkts = cur_tramp_pkt->next;
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_tramp_pkt);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_dup_pkt = tramp->dup_pkts;
 	     cur_dup_pkt != NULL; cur_dup_pkt = tramp->dup_pkts) {
 		tramp->dup_pkts = cur_dup_pkt->next;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cur_dup_relo = cur_dup_pkt->relo_chain;
 		     cur_dup_relo != NULL;
 		     cur_dup_relo = cur_dup_pkt->relo_chain) {
 			cur_dup_pkt->relo_chain = cur_dup_relo->next;
 			dlthis->mysym->dload_deallocate(dlthis->mysym,
 							cur_dup_relo);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_dup_pkt);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
diff -u -p a/staging/tidspbridge/pmgr/dmm.c b/staging/tidspbridge/pmgr/dmm.c
--- a/staging/tidspbridge/pmgr/dmm.c
+++ b/staging/tidspbridge/pmgr/dmm.c
@@ -500,6 +500,11 @@ u32 dmm_mem_map_dump(struct dmm_object *
 	spin_lock(&dmm_mgr->dmm_lock);
 
 	if (virtual_mapping_table != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < table_size; i +=
 		     virtual_mapping_table[i].region_size) {
 			curr_node = virtual_mapping_table + i;
@@ -518,6 +523,12 @@ u32 dmm_mem_map_dump(struct dmm_object *
 				if (curr_node->region_size > bigsize)
 					bigsize = curr_node->region_size;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	spin_unlock(&dmm_mgr->dmm_lock);
diff -u -p a/staging/tidspbridge/pmgr/dspapi.c b/staging/tidspbridge/pmgr/dspapi.c
--- a/staging/tidspbridge/pmgr/dspapi.c
+++ b/staging/tidspbridge/pmgr/dspapi.c
@@ -387,6 +387,11 @@ int api_init_complete2(void)
 	/*  Walk the list of DevObjects, get each devnode, and attempting to
 	 *  autostart the board. Note that this requires COF loading, which
 	 *  requires KFILE. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = dev_get_first(); hdev_obj != NULL;
 	     hdev_obj = dev_get_next(hdev_obj)) {
 		if (dev_get_dev_node(hdev_obj, &dev_node))
@@ -401,6 +406,12 @@ int api_init_complete2(void)
 			if (drv_datap && drv_datap->base_img)
 				proc_auto_start(dev_node, hdev_obj);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return status;
diff -u -p a/staging/usbip/userspace/src/usbipd.c b/staging/usbip/userspace/src/usbipd.c
--- a/staging/usbip/userspace/src/usbipd.c
+++ b/staging/usbip/userspace/src/usbipd.c
@@ -355,6 +355,11 @@ static int listen_all_addrinfo(struct ad
 	struct addrinfo *ai;
 	int ret, nsockfd = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ai = ai_head; ai && nsockfd < MAXSOCKFD; ai = ai->ai_next) {
 		sockfdlist[nsockfd] = socket(ai->ai_family, ai->ai_socktype,
 					     ai->ai_protocol);
@@ -386,6 +391,12 @@ static int listen_all_addrinfo(struct ad
 
 		log_addrinfo(ai);
 		nsockfd++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nsockfd == 0)
diff -u -p a/staging/speakup/main.c b/staging/speakup/main.c
--- a/staging/speakup/main.c
+++ b/staging/speakup/main.c
@@ -909,9 +909,20 @@ static void say_screen_from_to(struct vc
 	if (to > vc->vc_rows)
 		to = vc->vc_rows;
 	end = vc->vc_origin + (to * vc->vc_size_row);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (from = start; from < end; from = to) {
 		to = from + vc->vc_size_row;
 		say_from_to(vc, from, to, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/bcm/HandleControlPacket.c b/staging/bcm/HandleControlPacket.c
--- a/staging/bcm/HandleControlPacket.c
+++ b/staging/bcm/HandleControlPacket.c
@@ -203,6 +203,11 @@ INT flushAllAppQ(void)
 	PMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);
 	PPER_TARANG_DATA	pTarang = NULL;
 	struct sk_buff *PacketToDrop = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(pTarang = Adapter->pTarangs; pTarang; pTarang = pTarang->next)
 	{
 		while(pTarang->RxAppControlHead != NULL)
@@ -215,6 +220,12 @@ INT flushAllAppQ(void)
 		//dropped contrl packet statistics also should be reset.
 		memset((PVOID)&pTarang->stDroppedAppCntrlMsgs, 0, sizeof(S_MIBS_DROPPED_APP_CNTRL_MESSAGES));
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return STATUS_SUCCESS ;
 }
diff -u -p a/staging/bcm/IPv6Protocol.c b/staging/bcm/IPv6Protocol.c
--- a/staging/bcm/IPv6Protocol.c
+++ b/staging/bcm/IPv6Protocol.c
@@ -285,6 +285,11 @@ static BOOLEAN MatchSrcIpv6Address(S_CLA
 		aulSrcIP[uiIpv6AddIndex]=ntohl(pstIpv6Header->ulSrcIpAddress[uiIpv6AddIndex]);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(uiLoopIndex=0;uiLoopIndex<uiCountIPSrcAddresses;uiLoopIndex+=uiIpv6AddrNoLongWords)
 	{
 		BCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Src Ipv6 Address In Received Packet : \n ");
@@ -310,6 +315,12 @@ static BOOLEAN MatchSrcIpv6Address(S_CLA
 				return TRUE;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return FALSE;
 }
@@ -338,6 +349,11 @@ static BOOLEAN MatchDestIpv6Address(S_CL
 		aulDestIP[uiIpv6AddIndex]=ntohl(pstIpv6Header->ulDestIpAddress[uiIpv6AddIndex]);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(uiLoopIndex=0;uiLoopIndex<uiCountIPDestinationAddresses;uiLoopIndex+=uiIpv6AddrNoLongWords)
 	{
 		BCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Destination Ipv6 Address In Received Packet : \n ");
@@ -363,6 +379,12 @@ static BOOLEAN MatchDestIpv6Address(S_CL
 				return TRUE;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return FALSE;
 
diff -u -p a/staging/bcm/nvm.c b/staging/bcm/nvm.c
--- a/staging/bcm/nvm.c
+++ b/staging/bcm/nvm.c
@@ -1254,6 +1254,11 @@ static INT BeceemFlashBulkWrite(
 		//do_gettimeofday(&te);
 		//BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Total time taken by Erase :%ld ms\n", (te.tv_sec *1000 + te.tv_usec/1000) - (tr.tv_sec *1000 + tr.tv_usec/1000));
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(uiIndex = 0; uiIndex < Adapter->uiSectorSize; uiIndex +=Adapter->ulFlashWriteSize)
 		{
 			if(Adapter->device_removed)
@@ -1266,6 +1271,12 @@ static INT BeceemFlashBulkWrite(
 				Status = -1;
 				goto BeceemFlashBulkWrite_EXIT;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		//do_gettimeofday(&tw);
@@ -1460,6 +1471,11 @@ static INT BeceemFlashBulkWriteStatus(
 
 		FlashSectorErase(Adapter,uiPartOffset,1);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(uiIndex = 0; uiIndex < Adapter->uiSectorSize; uiIndex +=Adapter->ulFlashWriteSize)
 
 		{
@@ -1474,6 +1490,12 @@ static INT BeceemFlashBulkWriteStatus(
 				Status = -1;
 				goto BeceemFlashBulkWriteStatus_EXIT;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if(bVerify)
diff -u -p a/staging/cxt1e1/musycc.c b/staging/cxt1e1/musycc.c
--- a/staging/cxt1e1/musycc.c
+++ b/staging/cxt1e1/musycc.c
@@ -1835,6 +1835,11 @@ musycc_start_xmit (ci_t * ci, int channu
     /***********************************************/
     m2 = mem_token;
     txd_need_cnt = 0;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (len = OS_mem_token_tlen (m2); len > 0;
          m2 = (void *) OS_mem_token_next (m2))
     {
@@ -1842,6 +1847,12 @@ musycc_start_xmit (ci_t * ci, int channu
             continue;
         txd_need_cnt++;
         len -= OS_mem_token_len (m2);
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
 
     if (txd_need_cnt == 0)
@@ -1893,6 +1904,11 @@ musycc_start_xmit (ci_t * ci, int channu
     m2 = mem_token;
     md = ch->txd_usr_add;           /* get current available descriptor */
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (len = OS_mem_token_tlen (m2); len > 0; m2 = OS_mem_token_next (m2))
     {
         int         u = OS_mem_token_len (m2);
@@ -1946,6 +1962,12 @@ musycc_start_xmit (ci_t * ci, int channu
         md->status = cpu_to_le32 (u);
         --ch->txd_free;
         md = md->snext;
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
     FLUSH_MEM_WRITE ();
 
diff -u -p a/block/drbd/drbd_receiver.c b/block/drbd/drbd_receiver.c
--- a/block/drbd/drbd_receiver.c
+++ b/block/drbd/drbd_receiver.c
@@ -3391,6 +3391,11 @@ recv_bm_rle_bits(struct drbd_conf *mdev,
 	if (bits < 0)
 		return -EIO;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (have = bits; have > 0; s += rl, toggle = !toggle) {
 		bits = vli_decode_bits(&rl, look_ahead);
 		if (bits <= 0)
@@ -3420,6 +3425,12 @@ recv_bm_rle_bits(struct drbd_conf *mdev,
 			return -EIO;
 		look_ahead |= tmp << have;
 		have += bits;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	c->bit_offset = s;
diff -u -p a/pnp/pnpbios/core.c b/pnp/pnpbios/core.c
--- a/pnp/pnpbios/core.c
+++ b/pnp/pnpbios/core.c
@@ -445,6 +445,11 @@ static int __init pnpbios_probe_system(v
 	 * structure and, if one is found, sets up the selectors and
 	 * entry points
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (check = (union pnp_bios_install_struct *)__va(0xf0000);
 	     check < (union pnp_bios_install_struct *)__va(0xffff0);
 	     check = (void *)check + 16) {
@@ -480,6 +485,12 @@ static int __init pnpbios_probe_system(v
 		       check->fields.pm16dseg);
 		pnp_bios_install = check;
 		return 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_INFO "PnPBIOS: PnP BIOS support was not detected.\n");
diff -u -p a/crypto/n2_core.c b/crypto/n2_core.c
--- a/crypto/n2_core.c
+++ b/crypto/n2_core.c
@@ -125,8 +125,19 @@ static irqreturn_t cwq_intr(int irq, voi
 	pr_err("CPU[%d]: CWQ gethead[%lx] hv_ret[%lu]\n",
 	       smp_processor_id(), new_head, hv_ret);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (off = q->head; off != new_head; off = spu_next_offset(q, off)) {
 		/* XXX ... XXX */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	hv_ret = sun4v_ncs_sethead_marker(q->qhandle, new_head);
diff -u -p a/firmware/dmi_scan.c b/firmware/dmi_scan.c
--- a/firmware/dmi_scan.c
+++ b/firmware/dmi_scan.c
@@ -671,6 +671,11 @@ const struct dmi_device * dmi_find_devic
 	const struct list_head *head = from ? &from->list : &dmi_devices;
 	struct list_head *d;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(d = head->next; d != &dmi_devices; d = d->next) {
 		const struct dmi_device *dev =
 			list_entry(d, struct dmi_device, list);
@@ -678,6 +683,12 @@ const struct dmi_device * dmi_find_devic
 		if (((type == DMI_DEV_TYPE_ANY) || (dev->type == type)) &&
 		    ((name == NULL) || (strcmp(dev->name, name) == 0)))
 			return dev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/firmware/pcdp.c b/firmware/pcdp.c
--- a/firmware/pcdp.c
+++ b/firmware/pcdp.c
@@ -119,6 +119,11 @@ efi_setup_pcdp_console(char *cmdline)
 	}
 
 	end = (struct pcdp_device *) ((u8 *) pcdp + pcdp->length);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = (struct pcdp_device *) (pcdp->uart + pcdp->num_uarts);
 	     dev < end;
 	     dev = (struct pcdp_device *) ((u8 *) dev + dev->length)) {
@@ -128,6 +133,12 @@ efi_setup_pcdp_console(char *cmdline)
 				goto out;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
diff -u -p a/isdn/gigaset/capi.c b/isdn/gigaset/capi.c
--- a/isdn/gigaset/capi.c
+++ b/isdn/gigaset/capi.c
@@ -1698,12 +1698,23 @@ static void do_connect_resp(struct gigas
 			spin_unlock_irqrestore(&bcs->aplock, flags);
 			return;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (oap = bcs->ap; oap != NULL; oap = oap->bcnext) {
 			if (oap->bcnext == ap) {
 				oap->bcnext = oap->bcnext->bcnext;
 				spin_unlock_irqrestore(&bcs->aplock, flags);
 				return;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		spin_unlock_irqrestore(&bcs->aplock, flags);
 		dev_err(cs->dev, "%s: application %u not found\n",
diff -u -p a/isdn/i4l/isdn_net.c b/isdn/i4l/isdn_net.c
--- a/isdn/i4l/isdn_net.c
+++ b/isdn/i4l/isdn_net.c
@@ -2983,6 +2983,11 @@ isdn_net_getphones(isdn_net_ioctl_phone
 	if (!p)
 		return -ENODEV;
 	inout &= 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = p->local->phone[inout]; n; n = n->next) {
 		if (more) {
 			put_user(' ', phones++);
@@ -2994,6 +2999,12 @@ isdn_net_getphones(isdn_net_ioctl_phone
 		phones += strlen(n->num);
 		count += strlen(n->num);
 		more = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	put_user(0, phones);
 	count++;
diff -u -p a/isdn/pcbit/drv.c b/isdn/pcbit/drv.c
--- a/isdn/pcbit/drv.c
+++ b/isdn/pcbit/drv.c
@@ -1064,6 +1064,11 @@ static int pcbit_check_msn(struct pcbit_
 {
 	struct msn_entry *ptr;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr=dev->msn_list; ptr; ptr=ptr->next) {
 
 		if (ptr->msn == NULL) 
@@ -1071,6 +1076,12 @@ static int pcbit_check_msn(struct pcbit_
 		
 		if (strcmp(ptr->msn, msn) == 0)
 			return 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/isdn/hisax/ipacx.c b/isdn/hisax/ipacx.c
--- a/isdn/hisax/ipacx.c
+++ b/isdn/hisax/ipacx.c
@@ -210,8 +210,19 @@ dbusy_timer_handler(struct IsdnCardState
       debugl1(cs, "D-Channel Busy RBCHD %02x STARD %02x", rbchd, stard);
 		if (!(stard &0x40)) { // D-Channel Busy
 			set_bit(FLG_L1_DBUSY, &cs->HW_Flags);
-      for (st = cs->stlist; st; st = st->next) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (st = cs->stlist; st; st = st->next) {
 				st->l1.l1l2(st, PH_PAUSE | INDICATION, NULL); // flow control on
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
 			// seems we lost an interrupt; reset transceiver */
diff -u -p a/isdn/capi/capilib.c b/isdn/capi/capilib.c
--- a/isdn/capi/capilib.c
+++ b/isdn/capi/capilib.c
@@ -62,6 +62,11 @@ static inline int mq_enqueue(struct capi
 static inline int mq_dequeue(struct capilib_ncci * np, u16 msgid)
 {
 	struct capilib_msgidqueue **pp;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pp = &np->msgidqueue; *pp; pp = &(*pp)->next) {
 		if ((*pp)->msgid == msgid) {
 			struct capilib_msgidqueue *mq = *pp;
@@ -73,6 +78,12 @@ static inline int mq_dequeue(struct capi
 			np->nmsg--;
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/isdn/capi/capidrv.c b/isdn/capi/capidrv.c
--- a/isdn/capi/capidrv.c
+++ b/isdn/capi/capidrv.c
@@ -380,6 +380,11 @@ static void free_plci(capidrv_contr * ca
 {
 	capidrv_plci **pp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pp = &card->plci_list; *pp; pp = &(*pp)->next) {
 		if (*pp == plcip) {
 			*pp = (*pp)->next;
@@ -389,6 +394,12 @@ static void free_plci(capidrv_contr * ca
 			kfree(plcip);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "capidrv-%d: free_plci %p (0x%x) not found, Huh?\n",
 	       card->contrnr, plcip, plcip->plci);
@@ -488,6 +499,11 @@ static int capidrv_del_ack(struct capidr
 	struct ncci_datahandle_queue **pp, *p;
 	int len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pp = &nccip->ackqueue; *pp; pp = &(*pp)->next) {
  		if ((*pp)->datahandle == datahandle) {
 			p = *pp;
@@ -496,6 +512,12 @@ static int capidrv_del_ack(struct capidr
 		        kfree(p);
 			return len;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -1;
 }
diff -u -p a/acpi/pci_irq.c b/acpi/pci_irq.c
--- a/acpi/pci_irq.c
+++ b/acpi/pci_irq.c
@@ -311,11 +311,22 @@ static int bridge_has_boot_interrupt_var
 {
 	struct pci_bus *bus_it;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bus_it = bus ; bus_it ; bus_it = bus_it->parent) {
 		if (!bus_it->self)
 			return 0;
 		if (bus_it->self->irq_reroute_variant)
 			return bus_it->self->irq_reroute_variant;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/uwb/allocator.c b/uwb/allocator.c
--- a/uwb/allocator.c
+++ b/uwb/allocator.c
@@ -28,6 +28,11 @@ static void uwb_rsv_fill_column_alloc(st
 	struct uwb_rsv_col_info *ci = ai->ci;
 	unsigned char c;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = ci->csi.start_col; col < UWB_NUM_ZONES; col += ci->csi.interval) {
     
 		safe_mas   = ci->csi.safe_mas_per_col;
@@ -48,6 +53,12 @@ static void uwb_rsv_fill_column_alloc(st
 				bm[col * UWB_MAS_PER_ZONE + mas] = c;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -157,6 +168,11 @@ static int uwb_rsv_find_best_column_set(
 		for (set = 1; set <= (1 << deep); set++) {
 			max_mas_in_set = 0;
 			start_col = start_col_deep + col_start_set;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (col = start_col; col < UWB_NUM_ZONES; col += interval) {
                 
 				if (ci[col].max_avail_safe >= num_safe_mas &&
@@ -167,6 +183,12 @@ static int uwb_rsv_find_best_column_set(
 					max_mas_in_set = 0;
 					break;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if ((lowest_max_mas_in_deep > max_mas_in_set) && max_mas_in_set) {
 				lowest_max_mas_in_deep = max_mas_in_set;
diff -u -p a/uwb/i1480/dfu/usb.c b/uwb/i1480/dfu/usb.c
--- a/uwb/i1480/dfu/usb.c
+++ b/uwb/i1480/dfu/usb.c
@@ -160,6 +160,11 @@ int i1480_usb_read(struct i1480 *i1480,
 	if (addr >= 0x8000d200 && addr < 0x8000d400)	/* Yeah, HW quirk */
 		read_size = 4;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (itr = 0; itr < size; itr += read_size) {
 		size_t itr_addr = addr + itr;
 		size_t itr_size = min(read_size, size - itr);
@@ -182,6 +187,12 @@ int i1480_usb_read(struct i1480 *i1480,
 			goto out;
 		}
 		bytes += result;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	result = bytes;
 out:
diff -u -p a/md/raid5.c b/md/raid5.c
--- a/md/raid5.c
+++ b/md/raid5.c
@@ -2208,12 +2208,23 @@ static int add_stripe_bio(struct stripe_
 	if (forwrite) {
 		/* check if page is covered */
 		sector_t sector = sh->dev[dd_idx].sector;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (bi=sh->dev[dd_idx].towrite;
 		     sector < sh->dev[dd_idx].sector + STRIPE_SECTORS &&
 			     bi && bi->bi_sector <= sector;
 		     bi = r5_next_bio(bi, sh->dev[dd_idx].sector)) {
 			if (bi->bi_sector + (bi->bi_size>>9) >= sector)
 				sector = bi->bi_sector + (bi->bi_size>>9);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (sector >= sh->dev[dd_idx].sector + STRIPE_SECTORS)
 			set_bit(R5_OVERWRITE, &sh->dev[dd_idx].flags);
diff -u -p a/md/dm-region-hash.c b/md/dm-region-hash.c
--- a/md/dm-region-hash.c
+++ b/md/dm-region-hash.c
@@ -526,10 +526,21 @@ void dm_rh_inc_pending(struct dm_region_
 {
 	struct bio *bio;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bio = bios->head; bio; bio = bio->bi_next) {
 		if (bio->bi_rw & (REQ_FLUSH | REQ_DISCARD))
 			continue;
 		rh_inc(rh, dm_rh_bio_to_region(rh, bio));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(dm_rh_inc_pending);
diff -u -p a/media/video/saa7164/saa7164-fw.c b/media/video/saa7164/saa7164-fw.c
--- a/media/video/saa7164/saa7164-fw.c
+++ b/media/video/saa7164/saa7164-fw.c
@@ -132,6 +132,11 @@ int saa7164_downloadimage(struct saa7164
 		goto out;
 
 	/* Deal with the raw firmware, in the appropriate chunk size */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; srcsize > dstsize;
 		srcsize -= dstsize, offset += dstsize) {
 
@@ -150,6 +155,12 @@ int saa7164_downloadimage(struct saa7164
 		if (ret < 0)
 			goto out;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dprintk(DBGLVL_FW, "%s() memcpy(l) %d\n", __func__, dstsize);
diff -u -p a/media/video/cx23885/cx23885-core.c b/media/video/cx23885/cx23885-core.c
--- a/media/video/cx23885/cx23885-core.c
+++ b/media/video/cx23885/cx23885-core.c
@@ -561,6 +561,11 @@ void cx23885_sram_channel_dump(struct cx
 		printk(KERN_WARNING "%s:   risc%d: ", dev->name, i);
 		cx23885_risc_decode(risc);
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (64 >> 2); i += n) {
 		risc = cx_read(ch->ctrl_start + 4 * i);
 		/* No consideration for bits 63-32 */
@@ -573,6 +578,12 @@ void cx23885_sram_channel_dump(struct cx
 			printk(KERN_WARNING "%s:   iq %x: 0x%08x [ arg #%d ]\n",
 			       dev->name, i+j, risc, j);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_WARNING "%s: fifo: 0x%08x -> 0x%x\n",
diff -u -p a/media/video/bt8xx/bttv-risc.c b/media/video/bt8xx/bttv-risc.c
--- a/media/video/bt8xx/bttv-risc.c
+++ b/media/video/bt8xx/bttv-risc.c
@@ -183,6 +183,11 @@ bttv_risc_planar(struct bttv *btv, struc
 			break;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (todo = ybpl; todo > 0; todo -= ylen) {
 			/* go to next sg entry if needed */
 			while (yoffset && yoffset >= sg_dma_len(ysg)) {
@@ -228,6 +233,12 @@ bttv_risc_planar(struct bttv *btv, struc
 				*(rp++)=cpu_to_le32(sg_dma_address(vsg)+voffset);
 				voffset += ylen >> hshift;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		yoffset += ypadding;
 		if (chroma) {
@@ -294,6 +305,11 @@ bttv_risc_overlay(struct bttv *btv, stru
 					skips, &nskips, ov->clips, ov->nclips);
 
 		/* write out risc code */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (start = 0, skip = 0; start < ov->w.width; start = end) {
 			if (skip >= nskips) {
 				ri  = BT848_RISC_WRITE;
@@ -320,6 +336,12 @@ bttv_risc_overlay(struct bttv *btv, stru
 			*(rp++)=cpu_to_le32(ri);
 			if (0 != ra)
 				*(rp++)=cpu_to_le32(ra);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/media/video/vino.c b/media/video/vino.c
--- a/media/video/vino.c
+++ b/media/video/vino.c
@@ -894,9 +894,20 @@ static inline int vino_fifo_has_id(struc
 {
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = f->head; i == (f->tail - 1); i = (i + 1) % f->length) {
 		if (f->data[i] == id)
 			return 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/media/video/pvrusb2/pvrusb2-eeprom.c b/media/video/pvrusb2/pvrusb2-eeprom.c
--- a/media/video/pvrusb2/pvrusb2-eeprom.c
+++ b/media/video/pvrusb2/pvrusb2-eeprom.c
@@ -90,6 +90,11 @@ static u8 *pvr2_eeprom_fetch(struct pvr2
 	   getting the whole thing our I2C driver can't grab it in one
 	   pass - which is what tveeprom is otherwise going to attempt */
 	memset(eeprom,0,EEPROM_SIZE);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tcnt = 0; tcnt < EEPROM_SIZE; tcnt += pcnt) {
 		pcnt = 16;
 		if (pcnt + tcnt > EEPROM_SIZE) pcnt = EEPROM_SIZE-tcnt;
@@ -109,6 +114,12 @@ static u8 *pvr2_eeprom_fetch(struct pvr2
 			kfree(eeprom);
 			return NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return eeprom;
 }
diff -u -p a/media/video/pvrusb2/pvrusb2-sysfs.c b/media/video/pvrusb2/pvrusb2-sysfs.c
--- a/media/video/pvrusb2/pvrusb2-sysfs.c
+++ b/media/video/pvrusb2/pvrusb2-sysfs.c
@@ -491,6 +491,11 @@ static void pvr2_sysfs_add_controls(stru
 static void pvr2_sysfs_tear_down_controls(struct pvr2_sysfs *sfp)
 {
 	struct pvr2_sysfs_ctl_item *cip1,*cip2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cip1 = sfp->item_first; cip1; cip1 = cip2) {
 		cip2 = cip1->item_next;
 		if (cip1->created_ok) {
@@ -498,6 +503,12 @@ static void pvr2_sysfs_tear_down_control
 		}
 		pvr2_sysfs_trace("Destroying pvr2_sysfs_ctl_item id=%p",cip1);
 		kfree(cip1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/pvrusb2/pvrusb2-hdw.c b/media/video/pvrusb2/pvrusb2-hdw.c
--- a/media/video/pvrusb2/pvrusb2-hdw.c
+++ b/media/video/pvrusb2/pvrusb2-hdw.c
@@ -3533,6 +3533,11 @@ static u8 *pvr2_full_eeprom_fetch(struct
 	   getting the whole thing our I2C driver can't grab it in one
 	   pass - which is what tveeprom is otherwise going to attempt */
 	memset(eeprom,0,EEPROM_SIZE);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tcnt = 0; tcnt < EEPROM_SIZE; tcnt += pcnt) {
 		pcnt = 16;
 		if (pcnt + tcnt > EEPROM_SIZE) pcnt = EEPROM_SIZE-tcnt;
@@ -3552,6 +3557,12 @@ static u8 *pvr2_full_eeprom_fetch(struct
 			kfree(eeprom);
 			return NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return eeprom;
 }
diff -u -p a/media/video/pvrusb2/pvrusb2-context.c b/media/video/pvrusb2/pvrusb2-context.c
--- a/media/video/pvrusb2/pvrusb2-context.c
+++ b/media/video/pvrusb2/pvrusb2-context.c
@@ -140,9 +140,20 @@ static void pvr2_context_check(struct pv
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ch1 = mp->mc_first; ch1; ch1 = ch2) {
 		ch2 = ch1->mc_next;
 		if (ch1->check_func) ch1->check_func(ch1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (mp->disconnect_flag && !mp->mc_first) {
@@ -251,9 +262,20 @@ static void pvr2_context_reset_input_lim
 	struct pvr2_hdw *hdw = mp->hdw;
 	mmsk = pvr2_hdw_get_input_available(hdw);
 	tmsk = mmsk;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cp = mp->mc_first; cp; cp = cp->mc_next) {
 		if (!cp->input_mask) continue;
 		tmsk &= cp->input_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	pvr2_hdw_set_input_allowed(hdw,mmsk,tmsk);
 	pvr2_hdw_commit_ctl(hdw);
@@ -355,10 +377,21 @@ int pvr2_channel_limit_inputs(struct pvr
 			break;
 		}
 		tmsk = mmsk;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (p2 = cp->mc_head->mc_first; p2; p2 = p2->mc_next) {
 			if (p2 == cp) continue;
 			if (!p2->input_mask) continue;
 			tmsk &= p2->input_mask;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!(tmsk & cmsk)) {
 			ret = -EPERM;
diff -u -p a/media/video/cx25821/cx25821-core.c b/media/video/cx25821/cx25821-core.c
--- a/media/video/cx25821/cx25821-core.c
+++ b/media/video/cx25821/cx25821-core.c
@@ -633,6 +633,11 @@ void cx25821_sram_channel_dump(struct cx
 		i += cx25821_risc_decode(risc);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (64 >> 2); i += n) {
 		risc = cx_read(ch->ctrl_start + 4 * i);
 		/* No consideration for bits 63-32 */
@@ -645,6 +650,12 @@ void cx25821_sram_channel_dump(struct cx
 			pr_warn("ctrl + 0x%2x :   iq %x: 0x%08x [ arg #%d ]\n",
 				4 * (i + j), i + j, risc, j);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_warn("        :   fifo: 0x%08x -> 0x%x\n",
@@ -700,6 +711,11 @@ void cx25821_sram_channel_dump_audio(str
 		i += cx25821_risc_decode(risc);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (64 >> 2); i += n) {
 		risc = cx_read(ch->ctrl_start + 4 * i);
 		/* No consideration for bits 63-32 */
@@ -713,6 +729,12 @@ void cx25821_sram_channel_dump_audio(str
 			pr_warn("ctrl + 0x%2x :   iq %x: 0x%08x [ arg #%d ]\n",
 				4 * (i + j), i + j, risc, j);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_warn("        :   fifo: 0x%08x -> 0x%x\n",
diff -u -p a/media/video/cx18/cx18-queue.c b/media/video/cx18/cx18-queue.c
--- a/media/video/cx18/cx18-queue.c
+++ b/media/video/cx18/cx18-queue.c
@@ -289,6 +289,11 @@ void cx18_load_queues(struct cx18_stream
 	 * Excess buffers are left in buf_pool and/or on an MDL in q_idle
 	 */
 	mdl_id = s->mdl_base_idx;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mdl = cx18_dequeue(s, &s->q_idle), i = s->bufs_per_mdl;
 	     mdl != NULL && i == s->bufs_per_mdl;
 	     mdl = cx18_dequeue(s, &s->q_idle)) {
@@ -329,6 +334,12 @@ void cx18_load_queues(struct cx18_stream
 			cx18_push(s, mdl, &s->q_idle);
 		}
 		mdl_id += i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/usbvision/usbvision-core.c b/media/video/usbvision/usbvision-core.c
--- a/media/video/usbvision/usbvision-core.c
+++ b/media/video/usbvision/usbvision-core.c
@@ -516,6 +516,11 @@ static enum parse_state usbvision_parse_
 	clipmask_index = frame->curline * MAX_FRAME_WIDTH;
 	clipmask_add = usbvision->stretch_width;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < frame->frmwidth; i += (2 * usbvision->stretch_width)) {
 		scratch_get(usbvision, &yuyv[0], 4);
 
@@ -586,6 +591,12 @@ static enum parse_state usbvision_parse_
 		}
 		clipmask_index += clipmask_add;
 		f += stretch_bytes;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	frame->curline += usbvision->stretch_height;
diff -u -p a/media/video/cx88/cx88-core.c b/media/video/cx88/cx88-core.c
--- a/media/video/cx88/cx88-core.c
+++ b/media/video/cx88/cx88-core.c
@@ -464,6 +464,11 @@ void cx88_sram_channel_dump(struct cx88_
 		else
 			n = cx88_risc_decode(risc);
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i += n) {
 		risc = cx_read(ch->ctrl_start + 4 * i);
 		printk("%s:   iq %x: ", core->name, i);
@@ -473,6 +478,12 @@ void cx88_sram_channel_dump(struct cx88_
 			printk("%s:   iq %x: 0x%08x [ arg #%d ]\n",
 			       core->name, i+j, risc, j);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk("%s: fifo: 0x%08x -> 0x%x\n",
diff -u -p a/media/video/cx88/cx88-input.c b/media/video/cx88/cx88-input.c
--- a/media/video/cx88/cx88-input.c
+++ b/media/video/cx88/cx88-input.c
@@ -525,12 +525,23 @@ void cx88_ir_irq(struct cx88_core *core)
 		return;
 
 	init_ir_raw_event(&ev);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (todo = 32; todo > 0; todo -= bits) {
 		ev.pulse = samples & 0x80000000 ? false : true;
 		bits = min(todo, 32U - fls(ev.pulse ? samples : ~samples));
 		ev.duration = (bits * (NSEC_PER_SEC / 1000)) / ir_samplerate;
 		ir_raw_event_store_with_filter(ir->dev, &ev);
 		samples <<= bits;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ir_raw_event_handle(ir->dev);
 }
diff -u -p a/media/radio/si4713-i2c.c b/media/radio/si4713-i2c.c
--- a/media/radio/si4713-i2c.c
+++ b/media/radio/si4713-i2c.c
@@ -824,11 +824,22 @@ static int si4713_set_rds_ps_name(struct
 
 	if (sdev->power_state) {
 		/* Write the new ps name and clear the padding */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < MAX_RDS_PS_NAME; i += (RDS_BLOCK / 2)) {
 			rval = si4713_tx_rds_ps(sdev, (i / (RDS_BLOCK / 2)),
 						ps_name + i);
 			if (rval < 0)
 				goto unlock;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Setup the size to be sent */
diff -u -p a/media/dvb/dvb-usb/it913x.c b/media/dvb/dvb-usb/it913x.c
--- a/media/dvb/dvb-usb/it913x.c
+++ b/media/dvb/dvb-usb/it913x.c
@@ -444,6 +444,11 @@ static int it913x_download_firmware(stru
 	/* This uses scatter write firmware headers follow */
 	/* 03 XX 00     XX = chip number? */ 
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fw->size; i += packet_size) {
 			if (i > 0)
 				packet_size = 0x39;
@@ -453,6 +458,12 @@ static int it913x_download_firmware(stru
 			ret |= it913x_io(udev, WRITE_DATA, DEV_0,
 				CMD_SCATTER_WRITE, 0, 0, fw_data, dlen);
 			udelay(1000);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	ret |= it913x_io(udev, WRITE_CMD, DEV_0,
diff -u -p a/media/dvb/dvb-usb/lmedm04.c b/media/dvb/dvb-usb/lmedm04.c
--- a/media/dvb/dvb-usb/lmedm04.c
+++ b/media/dvb/dvb-usb/lmedm04.c
@@ -718,6 +718,11 @@ static int lme2510_download_firmware(str
 	for (i = 1; i < 3; i++) {
 		start = (i == 1) ? 0 : 512;
 		end = (i == 1) ? 512 : fw->size;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = start; j < end; j += (packet_size+1)) {
 			fw_data = (u8 *)(fw->data + j);
 			if ((end - j) > packet_size) {
@@ -736,6 +741,12 @@ static int lme2510_download_firmware(str
 			ret |= lme2510_bulk_write(dev, data,  wlen, 1);
 			ret |= lme2510_bulk_read(dev, data, len_in , 1);
 			ret |= (data[0] == 0x88) ? 0 : -1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/media/dvb/frontends/cx24116.c b/media/dvb/frontends/cx24116.c
--- a/media/dvb/frontends/cx24116.c
+++ b/media/dvb/frontends/cx24116.c
@@ -610,6 +610,11 @@ static int cx24116_load_firmware(struct
 	else
 		max = INT_MAX; /* enough for 32k firmware */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (remaining = fw->size; remaining > 0; remaining -= max - 1) {
 		len = remaining;
 		if (len > max - 1)
@@ -617,6 +622,12 @@ static int cx24116_load_firmware(struct
 
 		cx24116_writeregN(state, 0xF7, &fw->data[fw->size - remaining],
 			len);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	cx24116_writereg(state, 0xF4, 0x10);
diff -u -p a/media/dvb/frontends/tda10071.c b/media/dvb/frontends/tda10071.c
--- a/media/dvb/frontends/tda10071.c
+++ b/media/dvb/frontends/tda10071.c
@@ -971,6 +971,11 @@ static int tda10071_init(struct dvb_fron
 		/* do not download last byte */
 		fw_size = fw->size - 1;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (remaining = fw_size; remaining > 0;
 			remaining -= (priv->cfg.i2c_wr_max - 1)) {
 			len = remaining;
@@ -984,6 +989,12 @@ static int tda10071_init(struct dvb_fron
 				if (ret)
 					goto error_release_firmware;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		release_firmware(fw);
 
diff -u -p a/media/dvb/siano/smscoreapi.c b/media/dvb/siano/smscoreapi.c
--- a/media/dvb/siano/smscoreapi.c
+++ b/media/dvb/siano/smscoreapi.c
@@ -107,6 +107,11 @@ static struct smscore_registry_entry_t *
 	struct list_head *next;
 
 	kmutex_lock(&g_smscore_registrylock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (next = g_smscore_registry.next;
 	     next != &g_smscore_registry;
 	     next = next->next) {
@@ -115,6 +120,12 @@ static struct smscore_registry_entry_t *
 			kmutex_unlock(&g_smscore_registrylock);
 			return entry;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	entry = kmalloc(sizeof(struct smscore_registry_entry_t), GFP_KERNEL);
 	if (entry) {
@@ -211,12 +222,23 @@ int smscore_register_hotplug(hotplug_t h
 	if (notifyee) {
 		/* now notify callback about existing devices */
 		first = &g_smscore_devices;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (next = first->next;
 		     next != first && !rc;
 		     next = next->next) {
 			struct smscore_device_t *coredev =
 				(struct smscore_device_t *) next;
 			rc = hotplug(coredev, coredev->device, 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (rc >= 0) {
@@ -948,6 +970,11 @@ smscore_client_t *smscore_find_client(st
 
 	spin_lock_irqsave(&coredev->clientslock, flags);
 	first = &coredev->clients;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (next = first->next;
 	     (next != first) && !client;
 	     next = next->next) {
@@ -962,6 +989,12 @@ smscore_client_t *smscore_find_client(st
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&coredev->clientslock, flags);
 	return client;
diff -u -p a/infiniband/core/mad.c b/infiniband/core/mad.c
--- a/infiniband/core/mad.c
+++ b/infiniband/core/mad.c
@@ -834,6 +834,11 @@ static int alloc_send_rmpp_list(struct i
 	pad = send_wr->pad;
 
 	/* Allocate data segments. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (left = send_buf->data_len + pad; left > 0; left -= seg_size) {
 		seg = kmalloc(sizeof (*seg) + seg_size, gfp_mask);
 		if (!seg) {
@@ -845,6 +850,12 @@ static int alloc_send_rmpp_list(struct i
 		}
 		seg->num = ++send_buf->seg_count;
 		list_add_tail(&seg->list, &send_wr->rmpp_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Zero any padding */
diff -u -p a/infiniband/core/user_mad.c b/infiniband/core/user_mad.c
--- a/infiniband/core/user_mad.c
+++ b/infiniband/core/user_mad.c
@@ -289,6 +289,11 @@ static ssize_t copy_recv_mad(struct ib_u
 		offset = ib_get_mad_data_offset(recv_buf->mad->mad_hdr.mgmt_class);
 		max_seg_payload = sizeof (struct ib_mad) - offset;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (left = packet->length - seg_payload, buf += seg_payload;
 		     left; left -= seg_payload, buf += seg_payload) {
 			recv_buf = container_of(recv_buf->list.next,
@@ -297,6 +302,12 @@ static ssize_t copy_recv_mad(struct ib_u
 			if (copy_to_user(buf, ((void *) recv_buf->mad) + offset,
 					 seg_payload))
 				return -EFAULT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return hdr_size(file) + packet->length;
diff -u -p a/infiniband/core/multicast.c b/infiniband/core/multicast.c
--- a/infiniband/core/multicast.c
+++ b/infiniband/core/multicast.c
@@ -754,6 +754,11 @@ static void mcast_groups_event(struct mc
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&port->table); node; node = rb_next(node)) {
 		group = rb_entry(node, struct mcast_group, node);
 		spin_lock(&group->lock);
@@ -764,6 +769,12 @@ static void mcast_groups_event(struct mc
 		if (group->state != MCAST_GROUP_ERROR)
 			group->state = state;
 		spin_unlock(&group->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&port->lock, flags);
 }
diff -u -p a/infiniband/hw/ipath/ipath_user_pages.c b/infiniband/hw/ipath/ipath_user_pages.c
--- a/infiniband/hw/ipath/ipath_user_pages.c
+++ b/infiniband/hw/ipath/ipath_user_pages.c
@@ -70,6 +70,11 @@ static int __ipath_get_user_pages(unsign
 	ipath_cdbg(VERBOSE, "pin %lx pages from vaddr %lx\n",
 		   (unsigned long) num_pages, start_page);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (got = 0; got < num_pages; got += ret) {
 		ret = get_user_pages(current, current->mm,
 				     start_page + got * PAGE_SIZE,
@@ -77,6 +82,12 @@ static int __ipath_get_user_pages(unsign
 				     p + got, vma);
 		if (ret < 0)
 			goto bail_release;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	current->mm->pinned_vm += num_pages;
diff -u -p a/infiniband/hw/ipath/ipath_driver.c b/infiniband/hw/ipath/ipath_driver.c
--- a/infiniband/hw/ipath/ipath_driver.c
+++ b/infiniband/hw/ipath/ipath_driver.c
@@ -1176,6 +1176,11 @@ void ipath_kreceive(struct ipath_portdat
 	}
 
 reloop:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last = 0, i = 1; !last; i += !last) {
 		hdr = dd->ipath_f_get_msgheader(dd, rhf_addr);
 		eflags = ipath_hdrget_err_flags(rhf_addr);
@@ -1286,6 +1291,12 @@ reloop:
 				updegr = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!dd->ipath_rhdrhead_intr_off && !reloop &&
diff -u -p a/infiniband/hw/mthca/mthca_memfree.c b/infiniband/hw/mthca/mthca_memfree.c
--- a/infiniband/hw/mthca/mthca_memfree.c
+++ b/infiniband/hw/mthca/mthca_memfree.c
@@ -324,10 +324,21 @@ int mthca_table_get_range(struct mthca_d
 	int inc = MTHCA_TABLE_CHUNK_SIZE / table->obj_size;
 	int i, err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i <= end; i += inc) {
 		err = mthca_table_get(dev, table, i);
 		if (err)
 			goto fail;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/infiniband/hw/mthca/mthca_cmd.c b/infiniband/hw/mthca/mthca_cmd.c
--- a/infiniband/hw/mthca/mthca_cmd.c
+++ b/infiniband/hw/mthca/mthca_cmd.c
@@ -670,6 +670,11 @@ static int mthca_map_cmd(struct mthca_de
 	memset(mailbox->buf, 0, MTHCA_MAILBOX_SIZE);
 	pages = mailbox->buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mthca_icm_first(icm, &iter);
 	     !mthca_icm_last(&iter);
 	     mthca_icm_next(&iter)) {
@@ -707,6 +712,12 @@ static int mthca_map_cmd(struct mthca_de
 				nent = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nent)
diff -u -p a/infiniband/hw/mthca/mthca_qp.c b/infiniband/hw/mthca/mthca_qp.c
--- a/infiniband/hw/mthca/mthca_qp.c
+++ b/infiniband/hw/mthca/mthca_qp.c
@@ -1827,6 +1827,11 @@ int mthca_tavor_post_receive(struct ib_q
 
 	ind = qp->rq.next_ind;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nreq = 0; wr; wr = wr->next) {
 		if (mthca_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {
 			mthca_err(dev, "RQ %06x full (%u head, %u tail,"
@@ -1886,6 +1891,12 @@ int mthca_tavor_post_receive(struct ib_q
 			qp->rq.next_ind = ind;
 			qp->rq.head += MTHCA_TAVOR_MAX_WQES_PER_RECV_DB;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
diff -u -p a/infiniband/hw/qib/qib_user_pages.c b/infiniband/hw/qib/qib_user_pages.c
--- a/infiniband/hw/qib/qib_user_pages.c
+++ b/infiniband/hw/qib/qib_user_pages.c
@@ -65,6 +65,11 @@ static int __qib_get_user_pages(unsigned
 		goto bail;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (got = 0; got < num_pages; got += ret) {
 		ret = get_user_pages(current, current->mm,
 				     start_page + got * PAGE_SIZE,
@@ -72,6 +77,12 @@ static int __qib_get_user_pages(unsigned
 				     p + got, vma);
 		if (ret < 0)
 			goto bail_release;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	current->mm->pinned_vm += num_pages;
diff -u -p a/infiniband/hw/qib/qib_driver.c b/infiniband/hw/qib/qib_driver.c
--- a/infiniband/hw/qib/qib_driver.c
+++ b/infiniband/hw/qib/qib_driver.c
@@ -469,6 +469,11 @@ u32 qib_kreceive(struct qib_ctxtdata *rc
 		smp_rmb();  /* prevent speculative reads of dma'ed hdrq */
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last = 0, i = 1; !last; i += !last) {
 		hdr = dd->f_get_msgheader(dd, rhf_addr);
 		eflags = qib_hdrget_err_flags(rhf_addr);
@@ -542,6 +547,12 @@ move_along:
 			dd->f_update_usrhead(rcd, lval, updegr, etail, i);
 			updegr = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * Notify qib_destroy_qp() if it is waiting
diff -u -p a/char/rtc.c b/char/rtc.c
--- a/char/rtc.c
+++ b/char/rtc.c
@@ -973,6 +973,11 @@ static int __init rtc_init(void)
 #ifdef CONFIG_SPARC32
 	for_each_node_by_name(ebus_dp, "ebus") {
 		struct device_node *dp;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (dp = ebus_dp; dp; dp = dp->sibling) {
 			if (!strcmp(dp->name, "rtc")) {
 				op = of_find_device_by_node(dp);
@@ -982,6 +987,12 @@ static int __init rtc_init(void)
 					goto found;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	rtc_has_irq = 0;
diff -u -p a/base/power/trace.c b/base/power/trace.c
--- a/base/power/trace.c
+++ b/base/power/trace.c
@@ -173,6 +173,11 @@ static int show_file_hash(unsigned int v
 	char *tracedata;
 
 	match = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tracedata = &__tracedata_start ; tracedata < &__tracedata_end ;
 			tracedata += 2 + sizeof(unsigned long)) {
 		unsigned short lineno = *(unsigned short *)tracedata;
@@ -182,6 +187,12 @@ static int show_file_hash(unsigned int v
 			continue;
 		pr_info("  hash matches %s:%u\n", file, lineno);
 		match++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return match;
 }
diff -u -p a/base/regmap/regcache-rbtree.c b/base/regmap/regcache-rbtree.c
--- a/base/regmap/regcache-rbtree.c
+++ b/base/regmap/regcache-rbtree.c
@@ -253,6 +253,11 @@ static int regcache_rbtree_write(struct
 					     map->cache_word_size);
 	} else {
 		/* look for an adjacent register to the one we are about to add */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (node = rb_first(&rbtree_ctx->root); node;
 		     node = rb_next(node)) {
 			rbnode_tmp = rb_entry(node, struct regcache_rbtree_node, node);
@@ -273,6 +278,12 @@ static int regcache_rbtree_write(struct
 				rbtree_ctx->cached_rbnode = rbnode_tmp;
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* we did not manage to find a place to insert it in an existing
 		 * block so create a new rbnode with a single register in its block.
@@ -309,6 +320,11 @@ static int regcache_rbtree_sync(struct r
 	int i;
 
 	rbtree_ctx = map->cache;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&rbtree_ctx->root); node; node = rb_next(node)) {
 		rbnode = rb_entry(node, struct regcache_rbtree_node, node);
 		for (i = 0; i < rbnode->blklen; i++) {
@@ -329,6 +345,12 @@ static int regcache_rbtree_sync(struct r
 			dev_dbg(map->dev, "Synced register %#x, value %#x\n",
 				regtmp, val);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/usb/misc/emi62.c b/usb/misc/emi62.c
--- a/usb/misc/emi62.c
+++ b/usb/misc/emi62.c
@@ -177,6 +177,11 @@ static int emi62_load_firmware (struct u
 	}
 
 	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)loader_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		err = emi62_writememory(dev, be32_to_cpu(rec->addr),
@@ -186,6 +191,12 @@ static int emi62_load_firmware (struct u
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
@@ -198,6 +209,11 @@ static int emi62_load_firmware (struct u
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (!INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -209,6 +225,12 @@ static int emi62_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Assert reset (stop the CPU in the EMI) */
@@ -218,6 +240,11 @@ static int emi62_load_firmware (struct u
 		goto wraperr;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -229,6 +256,12 @@ static int emi62_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
diff -u -p a/usb/misc/emi26.c b/usb/misc/emi26.c
--- a/usb/misc/emi26.c
+++ b/usb/misc/emi26.c
@@ -170,6 +170,11 @@ static int emi26_load_firmware (struct u
 	}
 
 	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)loader_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		err = emi26_writememory(dev, be32_to_cpu(rec->addr),
@@ -179,6 +184,12 @@ static int emi26_load_firmware (struct u
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	msleep(250);	/* let device settle */
 
@@ -191,6 +202,11 @@ static int emi26_load_firmware (struct u
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (!INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -202,6 +218,12 @@ static int emi26_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	/* Assert reset (stop the CPU in the EMI) */
@@ -211,6 +233,11 @@ static int emi26_load_firmware (struct u
 		goto wraperr;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -222,6 +249,12 @@ static int emi26_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
diff -u -p a/usb/gadget/amd5536udc.c b/usb/gadget/amd5536udc.c
--- a/usb/gadget/amd5536udc.c
+++ b/usb/gadget/amd5536udc.c
@@ -970,6 +970,11 @@ static int udc_create_dma_chain(
 
 	td = req->td_data;
 	/* gen. required number of descriptors and buffers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = buf_len; i < bytes; i += buf_len) {
 		/* create or determine next desc. */
 		if (create_new_chain) {
@@ -1037,6 +1042,12 @@ static int udc_create_dma_chain(
 			}
 		}
 		last = td;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* set last bit */
 	if (td) {
diff -u -p a/usb/gadget/f_mass_storage.c b/usb/gadget/f_mass_storage.c
--- a/usb/gadget/f_mass_storage.c
+++ b/usb/gadget/f_mass_storage.c
@@ -1588,6 +1588,11 @@ static int throw_away_data(struct fsg_co
 	u32			amount;
 	int			rc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bh = common->next_buffhd_to_drain;
 	     bh->state != BUF_STATE_EMPTY || common->usb_amount_left > 0;
 	     bh = common->next_buffhd_to_drain) {
@@ -1632,6 +1637,12 @@ static int throw_away_data(struct fsg_co
 		rc = sleep_thread(common);
 		if (rc)
 			return rc;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/usb/serial/ftdi_sio.c b/usb/serial/ftdi_sio.c
--- a/usb/serial/ftdi_sio.c
+++ b/usb/serial/ftdi_sio.c
@@ -2157,9 +2157,20 @@ static void ftdi_process_read_urb(struct
 	if (!tty)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < urb->actual_length; i += priv->max_packet_size) {
 		len = min_t(int, urb->actual_length - i, priv->max_packet_size);
 		count += ftdi_process_packet(tty, port, priv, &data[i], len);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (count)
diff -u -p a/usb/atm/ueagle-atm.c b/usb/atm/ueagle-atm.c
--- a/usb/atm/ueagle-atm.c
+++ b/usb/atm/ueagle-atm.c
@@ -1948,6 +1948,11 @@ static int load_XILINX_firmware(struct u
 		ret = -EILSEQ;
 		goto err1;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (u = 0; u < size; u += ln) {
 		ln = min(size - u, 64);
 		ret = uea_request(sc, 0xe, 0, ln, pfw + u);
@@ -1956,6 +1961,12 @@ static int load_XILINX_firmware(struct u
 			       "elsa download data failed (%d)\n", ret);
 			goto err1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* finish to send the fpga */
diff -u -p a/usb/atm/usbatm.c b/usb/atm/usbatm.c
--- a/usb/atm/usbatm.c
+++ b/usb/atm/usbatm.c
@@ -477,6 +477,11 @@ static unsigned int usbatm_write_cells(s
 	vdbg("%s: skb->len=%d, avail_space=%u", __func__, skb->len, avail_space);
 	UDSL_ASSERT(instance, !(avail_space % stride));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bytes_written = 0; bytes_written < avail_space && ctrl->len;
 	     bytes_written += stride, target += stride) {
 		unsigned int data_len = min_t(unsigned int, skb->len, ATM_CELL_PAYLOAD);
@@ -518,6 +523,12 @@ static unsigned int usbatm_write_cells(s
 			ctrl->len = 0;		/* tag this skb finished */
 		} else
 			ctrl->crc = crc32_be(ctrl->crc, ptr, left);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return bytes_written;
diff -u -p a/usb/host/ehci-sched.c b/usb/host/ehci-sched.c
--- a/usb/host/ehci-sched.c
+++ b/usb/host/ehci-sched.c
@@ -570,6 +570,11 @@ static int qh_link_periodic (struct ehci
 	if (period == 0)
 		period = 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = qh->start; i < ehci->periodic_size; i += period) {
 		union ehci_shadow	*prev = &ehci->pshadow[i];
 		__hc32			*hw_p = &ehci->periodic[i];
@@ -605,6 +610,12 @@ static int qh_link_periodic (struct ehci
 			prev->qh = qh;
 			*hw_p = QH_NEXT (ehci, qh->qh_dma);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	qh->qh_state = QH_STATE_LINKED;
 	qh->xacterrs = 0;
diff -u -p a/usb/host/sl811-hcd.c b/usb/host/sl811-hcd.c
--- a/usb/host/sl811-hcd.c
+++ b/usb/host/sl811-hcd.c
@@ -449,6 +449,11 @@ static void finish_request(
 
 	/* periodic deschedule */
 	DBG("deschedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
 		struct sl811h_ep	*temp;
 		struct sl811h_ep	**prev = &sl811->periodic[i];
@@ -458,6 +463,12 @@ static void finish_request(
 		if (*prev)
 			*prev = ep->next;
 		sl811->load[i] -= ep->load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ep->branch = PERIODIC_SIZE;
 	sl811->periodic_count--;
@@ -919,6 +930,11 @@ static int sl811h_urb_enqueue(
 		 * dummy/placeholder nodes
 		 */
 		DBG("schedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
 			struct sl811h_ep	**prev = &sl811->periodic[i];
 			struct sl811h_ep	*here = *prev;
@@ -934,6 +950,12 @@ static int sl811h_urb_enqueue(
 				*prev = ep;
 			}
 			sl811->load[i] += ep->load;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		sl811->periodic_count++;
 		hcd->self.bandwidth_allocated += ep->load / ep->period;
diff -u -p a/usb/host/uhci-q.c b/usb/host/uhci-q.c
--- a/usb/host/uhci-q.c
+++ b/usb/host/uhci-q.c
@@ -663,9 +663,20 @@ static void uhci_reserve_bandwidth(struc
 	int load = qh->load;
 	char *p = "??";
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = qh->phase; i < MAX_PHASE; i += qh->period) {
 		uhci->load[i] += load;
 		uhci->total_load += load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+	}
 	}
 	uhci_to_hcd(uhci)->self.bandwidth_allocated =
 			uhci->total_load / MAX_PHASE;
@@ -696,9 +707,20 @@ static void uhci_release_bandwidth(struc
 	int load = qh->load;
 	char *p = "??";
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = qh->phase; i < MAX_PHASE; i += qh->period) {
 		uhci->load[i] -= load;
 		uhci->total_load -= load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+	}
 	}
 	uhci_to_hcd(uhci)->self.bandwidth_allocated =
 			uhci->total_load / MAX_PHASE;
diff -u -p a/usb/host/xhci-ring.c b/usb/host/xhci-ring.c
--- a/usb/host/xhci-ring.c
+++ b/usb/host/xhci-ring.c
@@ -2078,12 +2078,23 @@ static int process_isoc_td(struct xhci_h
 		frame->actual_length = frame->length;
 		td->urb->actual_length += frame->length;
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cur_trb = ep_ring->dequeue,
 		     cur_seg = ep_ring->deq_seg; cur_trb != event_trb;
 		     next_trb(xhci, ep_ring, &cur_seg, &cur_trb)) {
 			if (!TRB_TYPE_NOOP_LE32(cur_trb->generic.field[3]) &&
 			    !TRB_TYPE_LINK_LE32(cur_trb->generic.field[3]))
 				len += TRB_LEN(le32_to_cpu(cur_trb->generic.field[2]));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		len += TRB_LEN(le32_to_cpu(cur_trb->generic.field[2])) -
 			EVENT_TRB_LEN(le32_to_cpu(event->transfer_len));
@@ -2211,6 +2222,11 @@ static int process_bulk_intr_td(struct x
 		 * pointer, to get the actual length transferred.
 		 */
 		td->urb->actual_length = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cur_trb = ep_ring->dequeue, cur_seg = ep_ring->deq_seg;
 				cur_trb != event_trb;
 				next_trb(xhci, ep_ring, &cur_seg, &cur_trb)) {
@@ -2218,6 +2234,12 @@ static int process_bulk_intr_td(struct x
 			    !TRB_TYPE_LINK_LE32(cur_trb->generic.field[3]))
 				td->urb->actual_length +=
 					TRB_LEN(le32_to_cpu(cur_trb->generic.field[2]));
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		/* If the ring didn't stop on a Link or No-op TRB, add
 		 * in the actual bytes transferred from the Normal TRB
diff -u -p a/usb/host/isp116x-hcd.c b/usb/host/isp116x-hcd.c
--- a/usb/host/isp116x-hcd.c
+++ b/usb/host/isp116x-hcd.c
@@ -174,6 +174,11 @@ static void pack_fifo(struct isp116x *is
 	isp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);
 	isp116x_write_reg16(isp116x, HCXFERCTR, buflen);
 	isp116x_write_addr(isp116x, HCATLPORT | ISP116x_WRITE_OFFSET);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		ptd = &ep->ptd;
 		dump_ptd(ptd);
@@ -188,6 +193,12 @@ static void pack_fifo(struct isp116x *is
 			write_ptddata_to_fifo(isp116x, ep->data, ep->length);
 			buflen -= ALIGN(ep->length, 4);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	BUG_ON(buflen);
 }
@@ -206,6 +217,11 @@ static void unpack_fifo(struct isp116x *
 	isp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);
 	isp116x_write_reg16(isp116x, HCXFERCTR, buflen);
 	isp116x_write_addr(isp116x, HCATLPORT);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		ptd = &ep->ptd;
 		ptd->count = isp116x_read_data16(isp116x);
@@ -220,6 +236,12 @@ static void unpack_fifo(struct isp116x *
 		}
 		dump_ptd(ptd);
 		dump_ptd_in_data(ptd, ep->data);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	BUG_ON(buflen);
 }
@@ -236,6 +258,11 @@ static void preproc_atl_queue(struct isp
 	struct ptd *ptd;
 	u16 len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		u16 toggle = 0, dir = PTD_DIR_SETUP;
 
@@ -285,6 +312,12 @@ static void preproc_atl_queue(struct isp
 		}
 		isp116x->atl_bufshrt = sizeof(struct ptd) + isp116x->atl_buflen;
 		isp116x->atl_buflen = isp116x->atl_bufshrt + ALIGN(len, 4);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -322,6 +355,11 @@ __releases(isp116x->lock) __acquires(isp
 
 	/* periodic deschedule */
 	DBG("deschedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
 		struct isp116x_ep *temp;
 		struct isp116x_ep **prev = &isp116x->periodic[i];
@@ -331,6 +369,12 @@ __releases(isp116x->lock) __acquires(isp
 		if (*prev)
 			*prev = ep->next;
 		isp116x->load[i] -= ep->load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+	    else {
+			break;
+	    }
 	}
 	ep->branch = PERIODIC_SIZE;
 	isp116x_to_hcd(isp116x)->self.bandwidth_allocated -=
@@ -356,6 +400,11 @@ static void postproc_atl_queue(struct is
 	int status;
 	u8 cc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		BUG_ON(list_empty(&ep->hep->urb_list));
 		urb =
@@ -471,6 +520,12 @@ static void postproc_atl_queue(struct is
  done:
 		if (status != -EINPROGRESS || urb->unlinked)
 			finish_request(isp116x, ep, urb, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -793,6 +848,11 @@ static int isp116x_urb_enqueue(struct us
 		   to share the faster parts of the tree without needing
 		   dummy/placeholder nodes */
 		DBG("schedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
 			struct isp116x_ep **prev = &isp116x->periodic[i];
 			struct isp116x_ep *here = *prev;
@@ -808,6 +868,12 @@ static int isp116x_urb_enqueue(struct us
 				*prev = ep;
 			}
 			isp116x->load[i] += ep->load;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		hcd->self.bandwidth_allocated += ep->load / ep->period;
 
diff -u -p a/usb/host/xhci-mem.c b/usb/host/xhci-mem.c
--- a/usb/host/xhci-mem.c
+++ b/usb/host/xhci-mem.c
@@ -419,6 +419,11 @@ static int xhci_test_radix_tree(struct x
 		int trb_size = sizeof(union xhci_trb);
 
 		cur_ring = stream_info->stream_rings[cur_stream];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (addr = cur_ring->first_seg->dma;
 				addr < cur_ring->first_seg->dma + SEGMENT_SIZE;
 				addr += trb_size) {
@@ -432,6 +437,12 @@ static int xhci_test_radix_tree(struct x
 						mapped_ring);
 				return -EINVAL;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* One TRB after the end of the ring segment shouldn't return a
 		 * pointer to the current ring (although it may be a part of a
diff -u -p a/usb/host/oxu210hp-hcd.c b/usb/host/oxu210hp-hcd.c
--- a/usb/host/oxu210hp-hcd.c
+++ b/usb/host/oxu210hp-hcd.c
@@ -500,6 +500,11 @@ static int oxu_buf_alloc(struct oxu_hcd
 		;
 
 	/* Find a suitable available data buffer */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < BUFFER_NUM;
 			i += max(a_blocks, (int)oxu->db_used[i])) {
 
@@ -521,6 +526,12 @@ static int oxu_buf_alloc(struct oxu_hcd
 		spin_unlock(&oxu->mem_lock);
 
 		return 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Failed */
@@ -1942,6 +1953,11 @@ static int qh_link_periodic(struct oxu_h
 	if (period == 0)
 		period = 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = qh->start; i < oxu->periodic_size; i += period) {
 		union ehci_shadow	*prev = &oxu->pshadow[i];
 		__le32			*hw_p = &oxu->periodic[i];
@@ -1977,6 +1993,12 @@ static int qh_link_periodic(struct oxu_h
 			prev->qh = qh;
 			*hw_p = QH_NEXT(qh->qh_dma);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	qh->qh_state = QH_STATE_LINKED;
 	qh_get(qh);
diff -u -p a/usb/host/ohci-q.c b/usb/host/ohci-q.c
--- a/usb/host/ohci-q.c
+++ b/usb/host/ohci-q.c
@@ -130,6 +130,11 @@ static void periodic_link (struct ohci_h
 		(ed->hwINFO & cpu_to_hc32 (ohci, ED_ISO)) ? "iso " : "",
 		ed, ed->branch, ed->load, ed->interval);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ed->branch; i < NUM_INTS; i += ed->interval) {
 		struct ed	**prev = &ohci->periodic [i];
 		__hc32		*prev_p = &ohci->hcca->int_table [i];
@@ -156,6 +161,12 @@ static void periodic_link (struct ohci_h
 			wmb();
 		}
 		ohci->load [i] += ed->load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ohci_to_hcd(ohci)->self.bandwidth_allocated += ed->load / ed->interval;
 }
@@ -256,6 +267,11 @@ static void periodic_unlink (struct ohci
 {
 	int	i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ed->branch; i < NUM_INTS; i += ed->interval) {
 		struct ed	*temp;
 		struct ed	**prev = &ohci->periodic [i];
@@ -270,6 +286,12 @@ static void periodic_unlink (struct ohci
 			*prev = ed->ed_next;
 		}
 		ohci->load [i] -= ed->load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ohci_to_hcd(ohci)->self.bandwidth_allocated -= ed->load / ed->interval;
 
@@ -904,6 +926,11 @@ finish_unlinks (struct ohci_hcd *ohci, u
 	struct ed	*ed, **last;
 
 rescan_all:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last = &ohci->ed_rm_list, ed = *last; ed != NULL; ed = *last) {
 		struct list_head	*entry, *tmp;
 		int			completed, modified;
@@ -1018,6 +1045,12 @@ rescan_this:
 
 		if (modified)
 			goto rescan_all;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* maybe reenable control and bulk lists */
diff -u -p a/iommu/iova.c b/iommu/iova.c
--- a/iommu/iova.c
+++ b/iommu/iova.c
@@ -423,6 +423,11 @@ copy_reserved_iova(struct iova_domain *f
 	struct rb_node *node;
 
 	spin_lock_irqsave(&from->iova_rbtree_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&from->rbroot); node; node = rb_next(node)) {
 		struct iova *iova = container_of(node, struct iova, node);
 		struct iova *new_iova;
@@ -430,6 +435,12 @@ copy_reserved_iova(struct iova_domain *f
 		if (!new_iova)
 			printk(KERN_ERR "Reserve iova range %lx@%lx failed\n",
 				iova->pfn_lo, iova->pfn_lo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&from->iova_rbtree_lock, flags);
 }
diff -u -p a/video/ps3fb.c b/video/ps3fb.c
--- a/video/ps3fb.c
+++ b/video/ps3fb.c
@@ -657,11 +657,22 @@ static int ps3fb_set_par(struct fb_info
 	if (par->full_offset)
 		lines++;
 	maxlines = info->fix.smem_len / ddr_line_length;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dst = 0; lines; dst += maxlines * ddr_line_length) {
 		unsigned int l = min(lines, maxlines);
 		ps3fb_sync_image(info->device, 0, dst, 0, vmode->xres, l,
 				 ddr_line_length, ddr_line_length);
 		lines -= l;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/riva/riva_hw.c b/video/riva/riva_hw.c
--- a/video/riva/riva_hw.c
+++ b/video/riva/riva_hw.c
@@ -538,8 +538,18 @@ static char nv3_get_param(nv3_fifo_info
     done = 0;
     for (p=0; p < 2; p++)
     {
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for (g=128 ; g > 32; g= g>> 1)
         {
+            unsigned long long delta = (cpu / khz / HZ) * 2;
+            unsigned long long _start = 0;
+            unsigned long long _cur = 0;
+            unsigned long long timeout;
+            timeout = rdstcll(start) + delta;
             for (v=128; v >=32; v = v>> 1)
             {
                 ainfo->priority = p;
@@ -551,6 +561,18 @@ static char nv3_get_param(nv3_fifo_info
                         done = 0;
                 if (done)
                     goto Done;
+                if (_cur < timeout) {
+                    rdstcll(_cur);
+                }
+                else {
+                    break;
+                }
+            }
+            if (_cur < timeout) {
+                rdstcll(_cur);
+            }
+            else {
+                break;
             }
         }
     }
diff -u -p a/video/atafb_mfb.c b/video/atafb_mfb.c
--- a/video/atafb_mfb.c
+++ b/video/atafb_mfb.c
@@ -65,11 +65,22 @@ void atafb_mfb_fillrect(struct fb_info *
 		else
 			fb_memclear(dest, height * (width >> 3));
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (rows = height; rows--; dest += next_line) {
 			if (color)
 				fb_memset255(dest, width >> 3);
 			else
 				fb_memclear_small(dest, width >> 3);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
diff -u -p a/video/matrox/g450_pll.c b/video/matrox/g450_pll.c
--- a/video/matrox/g450_pll.c
+++ b/video/matrox/g450_pll.c
@@ -435,6 +435,11 @@ static int __g450_setclk(struct matrox_f
 		unsigned int mnp;
 		unsigned int xvco;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (mnp = g450_firstpll(minfo, pi, &xvco, fout); mnp != NO_MORE_MNP; mnp = g450_nextpll(minfo, pi, &xvco, mnp)) {
 			unsigned int idx;
 			unsigned int vco;
@@ -485,6 +490,12 @@ static int __g450_setclk(struct matrox_f
 			mnparray[idx] = mnp;
 			deltaarray[idx] = delta;
 			mnpcount++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	/* VideoPLL and PixelPLL matched: do nothing... In all other cases we should get at least one frequency */
diff -u -p a/video/matrox/matroxfb_base.c b/video/matrox/matroxfb_base.c
--- a/video/matrox/matroxfb_base.c
+++ b/video/matrox/matroxfb_base.c
@@ -1931,6 +1931,11 @@ int matroxfb_register_driver(struct matr
 	struct matrox_fb_info* minfo;
 
 	list_add(&drv->node, &matroxfb_driver_list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (minfo = matroxfb_l(matroxfb_list.next);
 	     minfo != matroxfb_l(&matroxfb_list);
 	     minfo = matroxfb_l(minfo->next_fb.next)) {
@@ -1943,6 +1948,12 @@ int matroxfb_register_driver(struct matr
 			minfo->drivers_data[minfo->drivers_count] = p;
 			minfo->drivers[minfo->drivers_count++] = drv;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1951,6 +1962,11 @@ void matroxfb_unregister_driver(struct m
 	struct matrox_fb_info* minfo;
 
 	list_del(&drv->node);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (minfo = matroxfb_l(matroxfb_list.next);
 	     minfo != matroxfb_l(&matroxfb_list);
 	     minfo = matroxfb_l(minfo->next_fb.next)) {
@@ -1965,6 +1981,12 @@ void matroxfb_unregister_driver(struct m
 			} else
 				i++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/omap2/vrfb.c b/video/omap2/vrfb.c
--- a/video/omap2/vrfb.c
+++ b/video/omap2/vrfb.c
@@ -104,11 +104,22 @@ void omap_vrfb_restore_context(void)
 	int i;
 	unsigned long map = ctx_map;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ffs(map); i; i = ffs(map)) {
 		/* i=1..32 */
 		i--;
 		map &= ~(1 << i);
 		restore_hw_context(i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/fbmem.c b/video/fbmem.c
--- a/video/fbmem.c
+++ b/video/fbmem.c
@@ -207,6 +207,11 @@ static void fb_set_logocmap(struct fb_in
 	palette_cmap.blue = palette_blue;
 	palette_cmap.transp = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < logo->clutsize; i += n) {
 		n = logo->clutsize - i;
 		/* palette_cmap provides space for only 16 colors at once */
@@ -221,6 +226,12 @@ static void fb_set_logocmap(struct fb_in
 			clut += 3;
 		}
 		fb_set_cmap(&palette_cmap, info);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/spi/spi-tegra.c b/spi/spi-tegra.c
--- a/spi/spi-tegra.c
+++ b/spi/spi-tegra.c
@@ -213,12 +213,23 @@ static unsigned spi_tegra_fill_tx_fifo(s
 	val |= SLINK_WORD_SIZE(len / tspi->cur_bytes_per_word - 1);
 	spi_tegra_writel(tspi, val, SLINK_COMMAND);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i += tspi->cur_bytes_per_word) {
 		val = 0;
 		for (j = 0; j < tspi->cur_bytes_per_word; j++)
 			val |= tx_buf[i + j] << j * 8;
 
 		spi_tegra_writel(tspi, val, SLINK_TX_FIFO);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tspi->rx_dma_req.size = len / tspi->cur_bytes_per_word * 4;
@@ -234,10 +245,21 @@ static unsigned spi_tegra_drain_rx_fifo(
 	int i, j;
 	unsigned long val;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i += tspi->cur_bytes_per_word) {
 		val = tspi->rx_bb[i / tspi->cur_bytes_per_word];
 		for (j = 0; j < tspi->cur_bytes_per_word; j++)
 			rx_buf[i + j] = (val >> (j * 8)) & 0xff;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return len;
diff -u -p a/s390/block/dasd_eckd.c b/s390/block/dasd_eckd.c
--- a/s390/block/dasd_eckd.c
+++ b/s390/block/dasd_eckd.c
@@ -2235,6 +2235,11 @@ static struct dasd_ccw_req *dasd_eckd_bu
 			if (copy)
 				dst = copy + bv->bv_offset;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (off = 0; off < bv->bv_len; off += blksize) {
 			sector_t trkid = recid;
 			unsigned int recoffs = sector_div(trkid, blk_per_trk);
@@ -2278,6 +2283,12 @@ static struct dasd_ccw_req *dasd_eckd_bu
 			ccw++;
 			dst += blksize;
 			recid++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (blk_noretry_request(req) ||
@@ -2987,6 +2998,11 @@ dasd_eckd_free_cp(struct dasd_ccw_req *c
 		ccw++;
 	rq_for_each_segment(bv, req, iter) {
 		dst = page_address(bv->bv_page) + bv->bv_offset;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (off = 0; off < bv->bv_len; off += blksize) {
 			/* Skip locate record. */
 			if (private->uses_cdl && recid <= 2*blk_per_trk)
@@ -3006,6 +3022,12 @@ dasd_eckd_free_cp(struct dasd_ccw_req *c
 			}
 			ccw++;
 			recid++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 out:
diff -u -p a/s390/block/dasd_eer.c b/s390/block/dasd_eer.c
--- a/s390/block/dasd_eer.c
+++ b/s390/block/dasd_eer.c
@@ -319,10 +319,21 @@ static void dasd_eer_write_standard_trig
 	list_for_each_entry(eerb, &bufferlist, list) {
 		dasd_eer_start_record(eerb, header.total_size);
 		dasd_eer_write_buffer(eerb, (char *) &header, sizeof(header));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (temp_cqr = cqr; temp_cqr; temp_cqr = temp_cqr->refers) {
 			sense = dasd_get_sense(&temp_cqr->irb);
 			if (sense)
 				dasd_eer_write_buffer(eerb, sense, 32);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dasd_eer_write_buffer(eerb, "EOR", 4);
 	}
diff -u -p a/s390/block/dasd_3990_erp.c b/s390/block/dasd_3990_erp.c
--- a/s390/block/dasd_3990_erp.c
+++ b/s390/block/dasd_3990_erp.c
@@ -2707,6 +2707,11 @@ dasd_3990_erp_action(struct dasd_ccw_req
 		/* print current erp_chain */
 		dev_err(&device->cdev->dev,
 			    "ERP chain at BEGINNING of ERP-ACTION\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (temp_erp = cqr;
 		     temp_erp != NULL; temp_erp = temp_erp->refers) {
 
@@ -2714,6 +2719,12 @@ dasd_3990_erp_action(struct dasd_ccw_req
 				    "ERP %p (%02x) refers to %p\n",
 				    temp_erp, temp_erp->status,
 				    temp_erp->refers);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -2748,6 +2759,11 @@ dasd_3990_erp_action(struct dasd_ccw_req
 		/* print current erp_chain */
 		dev_err(&device->cdev->dev,
 			    "ERP chain at END of ERP-ACTION\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (temp_erp = erp;
 		     temp_erp != NULL; temp_erp = temp_erp->refers) {
 
@@ -2755,6 +2771,12 @@ dasd_3990_erp_action(struct dasd_ccw_req
 				    "ERP %p (%02x) refers to %p\n",
 				    temp_erp, temp_erp->status,
 				    temp_erp->refers);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/s390/block/dasd_fba.c b/s390/block/dasd_fba.c
--- a/s390/block/dasd_fba.c
+++ b/s390/block/dasd_fba.c
@@ -333,6 +333,11 @@ static struct dasd_ccw_req *dasd_fba_bui
 			if (copy)
 				dst = copy + bv->bv_offset;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (off = 0; off < bv->bv_len; off += blksize) {
 			/* Locate record for stupid devices. */
 			if (private->rdc_data.mode.bits.data_chain == 0) {
@@ -361,6 +366,12 @@ static struct dasd_ccw_req *dasd_fba_bui
 			ccw++;
 			dst += blksize;
 			recid++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (blk_noretry_request(req) ||
@@ -398,6 +409,11 @@ dasd_fba_free_cp(struct dasd_ccw_req *cq
 		ccw++;
 	rq_for_each_segment(bv, req, iter) {
 		dst = page_address(bv->bv_page) + bv->bv_offset;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (off = 0; off < bv->bv_len; off += blksize) {
 			/* Skip locate record. */
 			if (private->rdc_data.mode.bits.data_chain == 0)
@@ -416,6 +432,12 @@ dasd_fba_free_cp(struct dasd_ccw_req *cq
 				dst = NULL;
 			}
 			ccw++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 out:
diff -u -p a/s390/block/dasd.c b/s390/block/dasd.c
--- a/s390/block/dasd.c
+++ b/s390/block/dasd.c
@@ -2133,6 +2133,11 @@ static int _dasd_sleep_on(struct dasd_cc
 	maincqr->status = DASD_CQR_FILLED;
 	device = maincqr->startdev;
 	list_add(&maincqr->blocklist, &ccw_queue);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cqr = maincqr;  __dasd_sleep_on_loop_condition(cqr);
 	     cqr = list_first_entry(&ccw_queue,
 				    struct dasd_ccw_req, blocklist)) {
@@ -2185,6 +2190,12 @@ static int _dasd_sleep_on(struct dasd_cc
 			}
 		} else
 			wait_event(generic_waitq, _wait_for_wakeup(cqr));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	maincqr->endclk = get_clock();
diff -u -p a/s390/block/dasd_diag.c b/s390/block/dasd_diag.c
--- a/s390/block/dasd_diag.c
+++ b/s390/block/dasd_diag.c
@@ -546,6 +546,11 @@ static struct dasd_ccw_req *dasd_diag_bu
 	recid = first_rec;
 	rq_for_each_segment(bv, req, iter) {
 		dst = page_address(bv->bv_page) + bv->bv_offset;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (off = 0; off < bv->bv_len; off += blksize) {
 			memset(dbio, 0, sizeof (struct dasd_diag_bio));
 			dbio->type = rw_cmd;
@@ -554,6 +559,12 @@ static struct dasd_ccw_req *dasd_diag_bu
 			dbio++;
 			dst += blksize;
 			recid++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	cqr->retries = DIAG_MAX_RETRIES;
diff -u -p a/s390/net/qeth_l3_main.c b/s390/net/qeth_l3_main.c
--- a/s390/net/qeth_l3_main.c
+++ b/s390/net/qeth_l3_main.c
@@ -1682,6 +1682,11 @@ static void qeth_l3_add_mc(struct qeth_c
 	char buf[MAX_ADDR_LEN];
 
 	QETH_CARD_TEXT(card, 4, "addmc");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (im4 = rcu_dereference(in4_dev->mc_list); im4 != NULL;
 	     im4 = rcu_dereference(im4->next_rcu)) {
 		qeth_l3_get_mac_for_ipm(im4->multiaddr, buf, in4_dev->dev);
@@ -1693,6 +1698,12 @@ static void qeth_l3_add_mc(struct qeth_c
 		ipm->is_multicast = 1;
 		if (!qeth_l3_add_ip(card, ipm))
 			kfree(ipm);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1747,6 +1758,11 @@ static void qeth_l3_add_mc6(struct qeth_
 	char buf[MAX_ADDR_LEN];
 
 	QETH_CARD_TEXT(card, 4, "addmc6");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (im6 = in6_dev->mc_list; im6 != NULL; im6 = im6->next) {
 		ndisc_mc_map(&im6->mca_addr, buf, in6_dev->dev, 0);
 		ipm = qeth_l3_get_addr_buffer(QETH_PROT_IPV6);
@@ -1758,6 +1774,12 @@ static void qeth_l3_add_mc6(struct qeth_
 		       sizeof(struct in6_addr));
 		if (!qeth_l3_add_ip(card, ipm))
 			kfree(ipm);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1819,6 +1841,11 @@ static void qeth_l3_free_vlan_addresses4
 	in_dev = in_dev_get(netdev);
 	if (!in_dev)
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {
 		addr = qeth_l3_get_addr_buffer(QETH_PROT_IPV4);
 		if (addr) {
@@ -1828,6 +1855,12 @@ static void qeth_l3_free_vlan_addresses4
 			if (!qeth_l3_delete_ip(card, addr))
 				kfree(addr);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	in_dev_put(in_dev);
 }
diff -u -p a/net/phy/dp83640.c b/net/phy/dp83640.c
--- a/net/phy/dp83640.c
+++ b/net/phy/dp83640.c
@@ -729,6 +729,11 @@ static void decode_status_frame(struct d
 
 	ptr = skb->data + 2;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (len = skb_headlen(skb) - 2; len > sizeof(type); len -= size) {
 
 		type = *(u16 *)ptr;
@@ -758,6 +763,12 @@ static void decode_status_frame(struct d
 			break;
 		}
 		ptr += size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/iwlegacy/iwl-tx.c b/net/wireless/iwlegacy/iwl-tx.c
--- a/net/wireless/iwlegacy/iwl-tx.c
+++ b/net/wireless/iwlegacy/iwl-tx.c
@@ -576,6 +576,11 @@ static void iwl_legacy_hcmd_queue_reclai
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = iwl_legacy_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;
 	     q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd)) {
 
@@ -585,6 +590,12 @@ static void iwl_legacy_hcmd_queue_reclai
 			queue_work(priv->workqueue, &priv->restart);
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/iwlegacy/iwl-3945.c b/net/wireless/iwlegacy/iwl-3945.c
--- a/net/wireless/iwlegacy/iwl-3945.c
+++ b/net/wireless/iwlegacy/iwl-3945.c
@@ -283,6 +283,11 @@ static void iwl3945_tx_queue_reclaim(str
 
 	BUG_ON(txq_id == IWL39_CMD_QUEUE_NUM);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = iwl_legacy_queue_inc_wrap(index, q->n_bd);
 		q->read_ptr != index;
 		q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd)) {
@@ -291,6 +296,12 @@ static void iwl3945_tx_queue_reclaim(str
 		ieee80211_tx_status_irqsafe(priv->hw, tx_info->skb);
 		tx_info->skb = NULL;
 		priv->cfg->ops->lib->txq_free_tfd(priv, txq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (iwl_legacy_queue_space(q) > q->low_mark && (txq_id >= 0) &&
diff -u -p a/net/wireless/iwlegacy/iwl-4965-tx.c b/net/wireless/iwlegacy/iwl-4965-tx.c
--- a/net/wireless/iwlegacy/iwl-4965-tx.c
+++ b/net/wireless/iwlegacy/iwl-4965-tx.c
@@ -1127,6 +1127,11 @@ int iwl4965_tx_queue_reclaim(struct iwl_
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = iwl_legacy_queue_inc_wrap(index, q->n_bd);
 	     q->read_ptr != index;
 	     q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd)) {
@@ -1145,6 +1150,12 @@ int iwl4965_tx_queue_reclaim(struct iwl_
 		tx_info->skb = NULL;
 
 		priv->cfg->ops->lib->txq_free_tfd(priv, txq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return nfreed;
 }
diff -u -p a/net/wireless/brcm80211/brcmsmac/mac80211_if.c b/net/wireless/brcm80211/brcmsmac/mac80211_if.c
--- a/net/wireless/brcm80211/brcmsmac/mac80211_if.c
+++ b/net/wireless/brcm80211/brcmsmac/mac80211_if.c
@@ -857,12 +857,23 @@ static void brcms_free(struct brcms_info
 		schedule();
 
 	/* free timers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (t = wl->timers; t; t = next) {
 		next = t->next;
 #ifdef BCMDBG
 		kfree(t->name);
 #endif
 		kfree(t);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c b/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c
--- a/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c
+++ b/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c
@@ -3729,7 +3729,17 @@ wlc_lcnphy_a1(struct brcms_phy *pi, int
 		else if (phy_c5 > 7)
 			phy_c5 = 7;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (k = -phy_c7; k <= phy_c7; k += phy_c7) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (l = -phy_c7; l <= phy_c7; l += phy_c7) {
 				phy_c11 = phy_c15 + k;
 				phy_c12 = phy_c16 + l;
@@ -3773,6 +3783,18 @@ wlc_lcnphy_a1(struct brcms_phy *pi, int
 					phy_c14 = phy_c12;
 				}
 				phy_c23 = 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 		phy_c23 = 1;
diff -u -p a/net/wireless/brcm80211/brcmsmac/main.c b/net/wireless/brcm80211/brcmsmac/main.c
--- a/net/wireless/brcm80211/brcmsmac/main.c
+++ b/net/wireless/brcm80211/brcmsmac/main.c
@@ -3879,11 +3879,22 @@ static void brcms_c_txflowcontrol_reset(
 {
 	struct brcms_txq_info *qi;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qi = wlc->tx_queues; qi != NULL; qi = qi->next) {
 		if (qi->stopped) {
 			brcms_c_txflowcontrol_signal(wlc, qi, OFF, ALLPRIO);
 			qi->stopped = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/brcm80211/brcmsmac/dma.c b/net/wireless/brcm80211/brcmsmac/dma.c
--- a/net/wireless/brcm80211/brcmsmac/dma.c
+++ b/net/wireless/brcm80211/brcmsmac/dma.c
@@ -1251,6 +1251,11 @@ int dma_txfast(struct dma_pub *pub, stru
 	 * Walk the chain of packet buffers
 	 * allocating and initializing transmit descriptor entries.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = p0; p; p = next) {
 		data = p->data;
 		len = p->len;
@@ -1283,6 +1288,12 @@ int dma_txfast(struct dma_pub *pub, stru
 		dma64_dd_upd(di, di->txd64, pa, txout, &flags, len);
 
 		txout = nexttxd(di, txout);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if last txd eof not set, fix it */
@@ -1368,6 +1379,11 @@ struct sk_buff *dma_getnexttxp(struct dm
 	if ((start == 0) && (end > di->txout))
 		goto bogus;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i != end && !txp; i = nexttxd(di, i)) {
 		dma_addr_t pa;
 		uint size;
@@ -1385,6 +1401,12 @@ struct sk_buff *dma_getnexttxp(struct dm
 		di->txp[i] = NULL;
 
 		pci_unmap_single(di->pbus, pa, size, PCI_DMA_TODEVICE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	di->txin = i;
diff -u -p a/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c b/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c
--- a/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c
+++ b/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -223,6 +223,11 @@ brcmf_sdioh_request_packet(struct brcmf_
 
 	/* Claim host controller */
 	sdio_claim_host(sdiodev->func[func]);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pnext = pkt; pnext; pnext = pnext->next) {
 		uint pkt_len = pnext->len;
 		pkt_len += 3;
@@ -260,6 +265,12 @@ brcmf_sdioh_request_packet(struct brcmf_
 			addr += pkt_len;
 		SGCount++;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Release host controller */
diff -u -p a/net/wireless/zd1211rw/zd_chip.c b/net/wireless/zd1211rw/zd_chip.c
--- a/net/wireless/zd1211rw/zd_chip.c
+++ b/net/wireless/zd1211rw/zd_chip.c
@@ -204,6 +204,11 @@ int zd_iowrite16a_locked(struct zd_chip
 	ZD_ASSERT(mutex_is_locked(&chip->mutex));
 	zd_usb_iowrite16v_async_start(&chip->usb);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i += j + t) {
 		t = 0;
 		max = count-i;
@@ -224,6 +229,12 @@ int zd_iowrite16a_locked(struct zd_chip
 				  r);
 			return r;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return zd_usb_iowrite16v_async_end(&chip->usb, 50 /* ms */);
@@ -241,6 +252,11 @@ int zd_iowrite32a_locked(struct zd_chip
 
 	zd_usb_iowrite16v_async_start(&chip->usb);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i += j + t) {
 		t = 0;
 		max = count-i;
@@ -261,6 +277,12 @@ int zd_iowrite32a_locked(struct zd_chip
 				" Error number %d\n", r);
 			return r;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return zd_usb_iowrite16v_async_end(&chip->usb, 50 /* ms */);
diff -u -p a/net/wireless/ath/ath9k/ar9003_eeprom.c b/net/wireless/ath/ath9k/ar9003_eeprom.c
--- a/net/wireless/ath/ath9k/ar9003_eeprom.c
+++ b/net/wireless/ath/ath9k/ar9003_eeprom.c
@@ -3170,6 +3170,11 @@ static bool ar9300_uncompress_block(stru
 
 	spot = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (it = 0; it < size; it += (length+2)) {
 		offset = block[it];
 		offset &= 0xff;
@@ -3189,6 +3194,12 @@ static bool ar9300_uncompress_block(stru
 				it, spot, offset, length);
 			return false;
 		}
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return true;
 }
diff -u -p a/net/wireless/ath/ath6kl/debug.c b/net/wireless/ath/ath6kl/debug.c
--- a/net/wireless/ath/ath6kl/debug.c
+++ b/net/wireless/ath/ath6kl/debug.c
@@ -256,6 +256,11 @@ static void ath6kl_debug_fwlog_add(struc
 		fwlog->tail = (fwlog->tail + ATH6KL_FWLOG_SLOT_SIZE) &
 			(ATH6KL_FWLOG_SIZE - 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < buf_len; i += space) {
 		space = CIRC_SPACE_TO_END(fwlog->head, fwlog->tail,
 					  ATH6KL_FWLOG_SIZE);
@@ -265,6 +270,12 @@ static void ath6kl_debug_fwlog_add(struc
 
 		memcpy(&fwlog->buf[fwlog->head], buf, space);
 		fwlog->head = (fwlog->head + space) & (ATH6KL_FWLOG_SIZE - 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
diff -u -p a/net/wireless/libertas/if_cs.c b/net/wireless/libertas/if_cs.c
--- a/net/wireless/libertas/if_cs.c
+++ b/net/wireless/libertas/if_cs.c
@@ -694,6 +694,11 @@ static int if_cs_prog_real(struct if_cs_
 		goto done;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sent = 0; sent < fw->size; sent += len) {
 		len = if_cs_read16(card, IF_CS_SQ_READ_LOW);
 		if (len & 1) {
@@ -727,6 +732,12 @@ static int if_cs_prog_real(struct if_cs_
 			pr_err("can't download firmware at 0x%x\n", sent);
 			goto done;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = if_cs_poll_while_fw_download(card, IF_CS_SCRATCH, 0x5a);
diff -u -p a/net/wireless/prism54/isl_ioctl.c b/net/wireless/prism54/isl_ioctl.c
--- a/net/wireless/prism54/isl_ioctl.c
+++ b/net/wireless/prism54/isl_ioctl.c
@@ -1800,11 +1800,22 @@ prism54_clear_mac(struct islpci_acl *acl
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = acl->mac_list.next, next = ptr->next;
 	     ptr != &acl->mac_list; ptr = next, next = ptr->next) {
 		entry = list_entry(ptr, struct mac_entry, _list);
 		list_del(ptr);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	acl->size = 0;
 	mutex_unlock(&acl->lock);
diff -u -p a/net/wireless/iwlwifi/iwl-trans-pcie-tx.c b/net/wireless/iwlwifi/iwl-trans-pcie-tx.c
--- a/net/wireless/iwlwifi/iwl-trans-pcie-tx.c
+++ b/net/wireless/iwlwifi/iwl-trans-pcie-tx.c
@@ -923,6 +923,11 @@ static void iwl_hcmd_queue_reclaim(struc
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = iwl_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;
 	     q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd)) {
 
@@ -932,6 +937,12 @@ static void iwl_hcmd_queue_reclaim(struc
 			iwlagn_fw_error(priv(trans), false);
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/hostap/hostap_ap.c b/net/wireless/hostap/hostap_ap.c
--- a/net/wireless/hostap/hostap_ap.c
+++ b/net/wireless/hostap/hostap_ap.c
@@ -395,6 +395,11 @@ int ap_control_del_mac(struct mac_restri
 	struct mac_entry *entry;
 
 	spin_lock_bh(&mac_restrictions->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = mac_restrictions->mac_list.next;
 	     ptr != &mac_restrictions->mac_list; ptr = ptr->next) {
 		entry = list_entry(ptr, struct mac_entry, list);
@@ -406,6 +411,12 @@ int ap_control_del_mac(struct mac_restri
 			spin_unlock_bh(&mac_restrictions->lock);
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_bh(&mac_restrictions->lock);
 	return -1;
@@ -446,12 +457,23 @@ void ap_control_flush_macs(struct mac_re
 		return;
 
 	spin_lock_bh(&mac_restrictions->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = mac_restrictions->mac_list.next, n = ptr->next;
 	     ptr != &mac_restrictions->mac_list;
 	     ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct mac_entry, list);
 		list_del(ptr);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mac_restrictions->entries = 0;
 	spin_unlock_bh(&mac_restrictions->lock);
@@ -495,6 +517,11 @@ void ap_control_kickall(struct ap_data *
 	struct sta_info *sta;
 
 	spin_lock_bh(&ap->sta_table_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ap->sta_list.next, n = ptr->next; ptr != &ap->sta_list;
 	     ptr = n, n = ptr->next) {
 		sta = list_entry(ptr, struct sta_info, list);
@@ -503,6 +530,12 @@ void ap_control_kickall(struct ap_data *
 		if ((sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)
 			hostap_event_expired_sta(sta->local->dev, sta);
 		ap_free_sta(ap, sta);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_bh(&ap->sta_table_lock);
 }
@@ -2383,6 +2416,11 @@ int prism2_ap_translate_scan(struct net_
 
 	spin_lock_bh(&ap->sta_table_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ap->sta_list.next; ptr != NULL && ptr != &ap->sta_list;
 	     ptr = ptr->next) {
 		struct sta_info *sta = (struct sta_info *) ptr;
@@ -2470,6 +2508,12 @@ int prism2_ap_translate_scan(struct net_
 		sta->last_rx_updated = IW_QUAL_DBM;
 
 		/* To be continued, we should make good use of IWEVCUSTOM */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_bh(&ap->sta_table_lock);
diff -u -p a/net/wireless/ipw2x00/ipw2200.c b/net/wireless/ipw2x00/ipw2200.c
--- a/net/wireless/ipw2x00/ipw2200.c
+++ b/net/wireless/ipw2x00/ipw2200.c
@@ -1354,6 +1354,11 @@ static ssize_t show_cmd_log(struct devic
 	u32 len = 0, i;
 	if (!priv->cmdlog)
 		return 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = (priv->cmdlog_pos + 1) % priv->cmdlog_len;
 	     (i != priv->cmdlog_pos) && (PAGE_SIZE - len);
 	     i = (i + 1) % priv->cmdlog_len) {
@@ -1367,6 +1372,12 @@ static ssize_t show_cmd_log(struct devic
 				 (u8 *) priv->cmdlog[i].cmd.param,
 				 priv->cmdlog[i].cmd.len);
 		len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
 	return len;
diff -u -p a/net/wireless/wl12xx/event.c b/net/wireless/wl12xx/event.c
--- a/net/wireless/wl12xx/event.c
+++ b/net/wireless/wl12xx/event.c
@@ -343,6 +343,11 @@ static int wl1271_event_process(struct w
 		const u8 *addr;
 		int h;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (h = find_first_bit(&sta_bitmap, AP_MAX_LINKS);
 		     h < AP_MAX_LINKS;
 		     h = find_next_bit(&sta_bitmap, AP_MAX_LINKS, h+1)) {
@@ -358,6 +363,12 @@ static int wl1271_event_process(struct w
 				ieee80211_report_low_ack(sta, num_packets);
 			}
 			rcu_read_unlock();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/ethernet/sis/sis900.c b/net/ethernet/sis/sis900.c
--- a/net/ethernet/sis/sis900.c
+++ b/net/ethernet/sis/sis900.c
@@ -725,6 +725,11 @@ static u16 sis900_default_phy(struct net
 		*default_phy = NULL, *phy_lan = NULL;
 	u16 status;
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for (phy=sis_priv->first_mii; phy; phy=phy->next) {
 		status = mdio_read(net_dev, phy->phy_addr, MII_STATUS);
 		status = mdio_read(net_dev, phy->phy_addr, MII_STATUS);
@@ -742,6 +747,12 @@ static u16 sis900_default_phy(struct net
 			else if(phy->phy_types == LAN)
 				phy_lan = phy;
 		 }
+		 if (_cur < timeout) {
+			rdstcll(_cur);
+		 }
+		else {
+		break;
+		}
 	}
 
 	if (!default_phy && phy_home)
diff -u -p a/net/ethernet/broadcom/b44.c b/net/ethernet/broadcom/b44.c
--- a/net/ethernet/broadcom/b44.c
+++ b/net/ethernet/broadcom/b44.c
@@ -597,6 +597,11 @@ static void b44_tx(struct b44 *bp)
 	cur /= sizeof(struct dma_desc);
 
 	/* XXX needs updating when NETIF_F_SG is supported */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cons = bp->tx_cons; cons != cur; cons = NEXT_TX(cons)) {
 		struct ring_info *rp = &bp->tx_buffers[cons];
 		struct sk_buff *skb = rp->skb;
@@ -609,6 +614,12 @@ static void b44_tx(struct b44 *bp)
 				 DMA_TO_DEVICE);
 		rp->skb = NULL;
 		dev_kfree_skb_irq(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bp->tx_cons = cons;
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_sp.c b/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
@@ -3013,11 +3013,22 @@ static inline void bnx2x_mcast_hdl_resto
 {
 	int bit;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit = bnx2x_mcast_get_next_bin(o, 0);
 	     bit >= 0;
 	     bit = bnx2x_mcast_get_next_bin(o, bit + 1)) {
 		BNX2X_57711_SET_MC_FILTER(mc_filter, bit);
 		DP(BNX2X_MSG_SP, "About to set bin %d\n", bit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_link.c b/net/ethernet/broadcom/bnx2x/bnx2x_link.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_link.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_link.c
@@ -5495,6 +5495,11 @@ static void bnx2x_set_gmii_tx_driver(str
 	if (lp_up2 == 0)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bank = MDIO_REG_BANK_TX0; bank <= MDIO_REG_BANK_TX3;
 	      bank += (MDIO_REG_BANK_TX1 - MDIO_REG_BANK_TX0)) {
 		CL22_RD_OVER_CL45(bp, phy,
@@ -5510,6 +5515,12 @@ static void bnx2x_set_gmii_tx_driver(str
 					  bank,
 					  MDIO_TX0_TX_DRIVER, tx_driver);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/pasemi/pasemi_mac.c b/net/ethernet/pasemi/pasemi_mac.c
--- a/net/ethernet/pasemi/pasemi_mac.c
+++ b/net/ethernet/pasemi/pasemi_mac.c
@@ -570,6 +570,11 @@ static void pasemi_mac_free_tx_resources
 	if (start > limit)
 		limit += TX_RING_SIZE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i < limit; i += freed) {
 		info = &txring->ring_info[(i+1) & (TX_RING_SIZE-1)];
 		if (info->dma && info->skb) {
@@ -581,6 +586,12 @@ static void pasemi_mac_free_tx_resources
 							info->skb, dmas);
 		} else
 			freed = 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(txring->ring_info);
diff -u -p a/net/ethernet/dec/tulip/de4x5.c b/net/ethernet/dec/tulip/de4x5.c
--- a/net/ethernet/dec/tulip/de4x5.c
+++ b/net/ethernet/dec/tulip/de4x5.c
@@ -1696,6 +1696,11 @@ de4x5_tx(struct net_device *dev)
     int entry;
     s32 status;
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (entry = lp->tx_old; entry != lp->tx_new; entry = lp->tx_old) {
 	status = (s32)le32_to_cpu(lp->tx_ring[entry].status);
 	if (status < 0) {                     /* Buffer not sent yet */
@@ -1727,6 +1732,12 @@ de4x5_tx(struct net_device *dev)
 
 	/* Update all the pointers */
 	lp->tx_old = (lp->tx_old + 1) % lp->txRingSize;
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
 
     /* Any resources available? */
@@ -4991,6 +5002,11 @@ mii_get_phy(struct net_device *dev)
     lp->useMII = true;
 
     /* Search the MII address space for possible PHY devices */
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (n=0, lp->mii_cnt=0, i=1; !((i==1) && (n==1)); i=(i+1)%DE4X5_MAX_MII) {
 	lp->phy[lp->active].addr = i;
 	if (i==0) n++;                             /* Count cycles */
@@ -5027,6 +5043,12 @@ mii_get_phy(struct net_device *dev)
 	    de4x5_debug = j;
 	    printk("\n");
 	}
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
   purgatory:
     lp->active = 0;
diff -u -p a/net/ethernet/toshiba/ps3_gelic_net.c b/net/ethernet/toshiba/ps3_gelic_net.c
--- a/net/ethernet/toshiba/ps3_gelic_net.c
+++ b/net/ethernet/toshiba/ps3_gelic_net.c
@@ -215,10 +215,21 @@ static void gelic_card_free_chain(struct
 {
 	struct gelic_descr *descr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (descr = descr_in; descr && descr->bus_addr; descr = descr->next) {
 		dma_unmap_single(ctodev(card), descr->bus_addr,
 				 GELIC_DESCR_SIZE, DMA_BIDIRECTIONAL);
 		descr->bus_addr = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -497,6 +508,11 @@ static void gelic_card_release_tx_chain(
 	struct net_device *netdev;
 	int release = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tx_chain = &card->tx_chain;
 	     tx_chain->head != tx_chain->tail && tx_chain->tail;
 	     tx_chain->tail = tx_chain->tail->next) {
@@ -531,6 +547,12 @@ static void gelic_card_release_tx_chain(
 		}
 		gelic_descr_release_tx(card, tx_chain->tail);
 		release ++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 out:
 	if (!stop && release)
diff -u -p a/net/ethernet/marvell/skge.c b/net/ethernet/marvell/skge.c
--- a/net/ethernet/marvell/skge.c
+++ b/net/ethernet/marvell/skge.c
@@ -2845,10 +2845,21 @@ static void skge_tx_clean(struct net_dev
 	struct skge_port *skge = netdev_priv(dev);
 	struct skge_element *e;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (e = skge->tx_ring.to_clean; e != skge->tx_ring.to_use; e = e->next) {
 		struct skge_tx_desc *td = e->desc;
 		skge_tx_free(skge, e, td->control);
 		td->control = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	skge->tx_ring.to_clean = e;
@@ -3652,11 +3663,22 @@ static int skge_debug_show(struct seq_fi
 		   skge_read32(hw, B0_IMSK));
 
 	seq_printf(seq, "Tx Ring: (%d)\n", skge_avail(&skge->tx_ring));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (e = skge->tx_ring.to_clean; e != skge->tx_ring.to_use; e = e->next) {
 		const struct skge_tx_desc *t = e->desc;
 		seq_printf(seq, "%#x dma=%#x%08x %#x csum=%#x/%x/%x\n",
 			   t->control, t->dma_hi, t->dma_lo, t->status,
 			   t->csum_offs, t->csum_write, t->csum_start);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	seq_printf(seq, "\nRx Ring:\n");
diff -u -p a/net/ethernet/marvell/sky2.c b/net/ethernet/marvell/sky2.c
--- a/net/ethernet/marvell/sky2.c
+++ b/net/ethernet/marvell/sky2.c
@@ -1988,10 +1988,21 @@ static netdev_tx_t sky2_xmit_frame(struc
 	return NETDEV_TX_OK;
 
 mapping_unwind:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = sky2->tx_prod; i != slot; i = RING_NEXT(i, sky2->tx_ring_size)) {
 		re = sky2->tx_ring + i;
 
 		sky2_tx_unmap(hw->pdev, re);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 mapping_error:
@@ -2018,6 +2029,11 @@ static void sky2_tx_complete(struct sky2
 
 	BUG_ON(done >= sky2->tx_ring_size);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = sky2->tx_cons; idx != done;
 	     idx = RING_NEXT(idx, sky2->tx_ring_size)) {
 		struct tx_ring_info *re = sky2->tx_ring + idx;
@@ -2039,6 +2055,12 @@ static void sky2_tx_complete(struct sky2
 
 			sky2->tx_next = RING_NEXT(idx, sky2->tx_ring_size);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sky2->tx_cons = idx;
@@ -4520,11 +4542,22 @@ static int sky2_debug_show(struct seq_fi
 		seq_puts(seq, "Status ring (empty)\n");
 	else {
 		seq_puts(seq, "Status ring\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (idx = hw->st_idx; idx != last && idx < hw->st_size;
 		     idx = RING_NEXT(idx, hw->st_size)) {
 			const struct sky2_status_le *le = hw->st_le + idx;
 			seq_printf(seq, "[%d] %#x %d %#x\n",
 				   idx, le->opcode, le->length, le->status);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		seq_puts(seq, "\n");
 	}
@@ -4536,6 +4569,11 @@ static int sky2_debug_show(struct seq_fi
 
 	/* Dump contents of tx ring */
 	sop = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = sky2->tx_next; idx != sky2->tx_prod && idx < sky2->tx_ring_size;
 	     idx = RING_NEXT(idx, sky2->tx_ring_size)) {
 		const struct sky2_tx_le *le = sky2->tx_le + idx;
@@ -4576,6 +4614,12 @@ static int sky2_debug_show(struct seq_fi
 			seq_putc(seq, '\n');
 			sop = 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	seq_printf(seq, "\nRx ring hw get=%d put=%d last=%d\n",
diff -u -p a/net/ethernet/chelsio/cxgb4/sge.c b/net/ethernet/chelsio/cxgb4/sge.c
--- a/net/ethernet/chelsio/cxgb4/sge.c
+++ b/net/ethernet/chelsio/cxgb4/sge.c
@@ -1890,7 +1890,12 @@ static void sge_rx_timer_cb(unsigned lon
 	struct adapter *adap = (struct adapter *)data;
 	struct sge *s = &adap->sge;
 
-	for (i = 0; i < ARRAY_SIZE(s->starving_fl); i++)
+	for (i = 0; i < ARRAY_SIZE(s->starving_fl); i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (m = s->starving_fl[i]; m; m &= m - 1) {
 			struct sge_eth_rxq *rxq;
 			unsigned int id = __ffs(m) + i * BITS_PER_LONG;
@@ -1906,7 +1911,14 @@ static void sge_rx_timer_cb(unsigned lon
 				else
 					set_bit(id, s->starving_fl);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
+	}
 
 	t4_write_reg(adap, SGE_DEBUG_INDEX, 13);
 	cnt[0] = t4_read_reg(adap, SGE_DEBUG_DATA_HIGH);
@@ -1935,14 +1947,26 @@ static void sge_tx_timer_cb(unsigned lon
 	struct adapter *adap = (struct adapter *)data;
 	struct sge *s = &adap->sge;
 
-	for (i = 0; i < ARRAY_SIZE(s->txq_maperr); i++)
+	for (i = 0; i < ARRAY_SIZE(s->txq_maperr); i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (m = s->txq_maperr[i]; m; m &= m - 1) {
 			unsigned long id = __ffs(m) + i * BITS_PER_LONG;
 			struct sge_ofld_txq *txq = s->egr_map[id];
 
 			clear_bit(id, s->txq_maperr);
 			tasklet_schedule(&txq->qresume_tsk);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
+	}
 
 	budget = MAX_TIMER_TX_RECLAIM;
 	i = s->ethtxq_rover;
diff -u -p a/net/ethernet/chelsio/cxgb4/t4_hw.c b/net/ethernet/chelsio/cxgb4/t4_hw.c
--- a/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -220,6 +220,11 @@ int t4_wr_mbox_meat(struct adapter *adap
 	delay_idx = 0;
 	ms = delay[0];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < FW_CMD_MAX_TIMEOUT; i += ms) {
 		if (sleep_ok) {
 			ms = delay[delay_idx];  /* last element may repeat */
@@ -248,6 +253,12 @@ int t4_wr_mbox_meat(struct adapter *adap
 			t4_write_reg(adap, ctl_reg, 0);
 			return -FW_CMD_RETVAL_GET((int)res);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dump_mbox(adap, mbox, data_reg);
@@ -585,6 +596,11 @@ static int t4_write_flash(struct adapter
 	    (ret = sf1_write(adapter, 4, 1, 1, val)) != 0)
 		goto unlock;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (left = n; left; left -= c) {
 		c = min(left, 4U);
 		for (val = 0, i = 0; i < c; ++i)
@@ -593,6 +609,12 @@ static int t4_write_flash(struct adapter
 		ret = sf1_write(adapter, c, c != left, 1, val);
 		if (ret)
 			goto unlock;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = flash_wait_op(adapter, 8, 1);
 	if (ret)
diff -u -p a/net/ethernet/chelsio/cxgb3/t3_hw.c b/net/ethernet/chelsio/cxgb3/t3_hw.c
--- a/net/ethernet/chelsio/cxgb3/t3_hw.c
+++ b/net/ethernet/chelsio/cxgb3/t3_hw.c
@@ -892,6 +892,11 @@ static int t3_write_flash(struct adapter
 	    (ret = sf1_write(adapter, 4, 1, val)) != 0)
 		return ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (left = n; left; left -= c) {
 		c = min(left, 4U);
 		for (val = 0, i = 0; i < c; ++i)
@@ -900,6 +905,12 @@ static int t3_write_flash(struct adapter
 		ret = sf1_write(adapter, c, c != left, val);
 		if (ret)
 			return ret;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if ((ret = flash_wait_op(adapter, 5, 1)) != 0)
 		return ret;
diff -u -p a/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c b/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
--- a/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
+++ b/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
@@ -170,6 +170,11 @@ int t4vf_wr_mbox_core(struct adapter *ad
 	delay_idx = 0;
 	ms = delay[0];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < FW_CMD_MAX_TIMEOUT; i += ms) {
 		if (sleep_ok) {
 			ms = delay[delay_idx];
@@ -219,6 +224,12 @@ int t4vf_wr_mbox_core(struct adapter *ad
 				     MBOWNER(MBOX_OWNER_NONE));
 			return -FW_CMD_RETVAL_GET(v);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/net/ethernet/chelsio/cxgb4vf/sge.c b/net/ethernet/chelsio/cxgb4vf/sge.c
--- a/net/ethernet/chelsio/cxgb4vf/sge.c
+++ b/net/ethernet/chelsio/cxgb4vf/sge.c
@@ -1940,6 +1940,11 @@ static void sge_rx_timer_cb(unsigned lon
 	for (i = 0; i < ARRAY_SIZE(s->starving_fl); i++) {
 		unsigned long m;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (m = s->starving_fl[i]; m; m &= m - 1) {
 			unsigned int id = __ffs(m) + i * BITS_PER_LONG;
 			struct sge_fl *fl = s->egr_map[id];
@@ -1962,6 +1967,12 @@ static void sge_rx_timer_cb(unsigned lon
 				else
 					set_bit(id, s->starving_fl);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/ethernet/amd/7990.c b/net/ethernet/amd/7990.c
--- a/net/ethernet/amd/7990.c
+++ b/net/ethernet/amd/7990.c
@@ -296,6 +296,11 @@ static int lance_rx (struct net_device *
 	blinken_leds(0x40, 0);
 #endif
         WRITERDP(lp, LE_C0_RINT | LE_C0_INEA);     /* ack Rx int, reenable ints */
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for (rd = &ib->brx_ring [lp->rx_new];     /* For each Rx ring we own... */
              !((bits = rd->rmd1_bits) & LE_R1_OWN);
              rd = &ib->brx_ring [lp->rx_new]) {
@@ -343,6 +348,12 @@ static int lance_rx (struct net_device *
                 rd->mblength = 0;
                 rd->rmd1_bits = LE_R1_OWN;
                 lp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;
+                if (_cur < timeout) {
+			rdstcll(_cur);
+                }
+                else {
+			break;
+                }
         }
         return 0;
 }
diff -u -p a/net/ethernet/amd/a2065.c b/net/ethernet/amd/a2065.c
--- a/net/ethernet/amd/a2065.c
+++ b/net/ethernet/amd/a2065.c
@@ -265,6 +265,11 @@ static int lance_rx(struct net_device *d
 #endif
 
 	ll->rdp = LE_C0_RINT | LE_C0_INEA;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = &ib->brx_ring[lp->rx_new];
 	     !((bits = rd->rmd1_bits) & LE_R1_OWN);
 	     rd = &ib->brx_ring[lp->rx_new]) {
@@ -316,6 +321,12 @@ static int lance_rx(struct net_device *d
 		rd->mblength = 0;
 		rd->rmd1_bits = LE_R1_OWN;
 		lp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/amd/declance.c b/net/ethernet/amd/declance.c
--- a/net/ethernet/amd/declance.c
+++ b/net/ethernet/amd/declance.c
@@ -580,6 +580,11 @@ static int lance_rx(struct net_device *d
 	}
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = lib_ptr(ib, brx_ring[lp->rx_new], lp->type);
 	     !((bits = *rds_ptr(rd, rmd1, lp->type)) & LE_R1_OWN);
 	     rd = lib_ptr(ib, brx_ring[lp->rx_new], lp->type)) {
@@ -637,6 +642,12 @@ static int lance_rx(struct net_device *d
 		*rds_ptr(rd, rmd1, lp->type) =
 			((lp->rx_buf_ptr_lnc[entry] >> 16) & 0xff) | LE_R1_OWN;
 		lp->rx_new = (entry + 1) & RX_RING_MOD_MASK;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/amd/sunlance.c b/net/ethernet/amd/sunlance.c
--- a/net/ethernet/amd/sunlance.c
+++ b/net/ethernet/amd/sunlance.c
@@ -515,6 +515,11 @@ static void lance_rx_dvma(struct net_dev
 	int len, entry = lp->rx_new;
 	struct sk_buff *skb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = &ib->brx_ring [entry];
 	     !((bits = rd->rmd1_bits) & LE_R1_OWN);
 	     rd = &ib->brx_ring [entry]) {
@@ -562,6 +567,12 @@ static void lance_rx_dvma(struct net_dev
 		rd->mblength = 0;
 		rd->rmd1_bits = LE_R1_OWN;
 		entry = RX_NEXT(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lp->rx_new = entry;
@@ -687,6 +698,11 @@ static void lance_rx_pio(struct net_devi
 	struct sk_buff *skb;
 
 	entry = lp->rx_new;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = &ib->brx_ring [entry];
 	     !((bits = sbus_readb(&rd->rmd1_bits)) & LE_R1_OWN);
 	     rd = &ib->brx_ring [entry]) {
@@ -732,6 +748,12 @@ static void lance_rx_pio(struct net_devi
 		sbus_writew(0, &rd->mblength);
 		sbus_writeb(LE_R1_OWN, &rd->rmd1_bits);
 		entry = RX_NEXT(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lp->rx_new = entry;
diff -u -p a/net/ethernet/amd/depca.c b/net/ethernet/amd/depca.c
--- a/net/ethernet/amd/depca.c
+++ b/net/ethernet/amd/depca.c
@@ -1022,6 +1022,11 @@ static int depca_rx(struct net_device *d
 	int i, entry;
 	s32 status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (entry = lp->rx_new; !(readl(&lp->rx_ring[entry].base) & R_OWN); entry = lp->rx_new) {
 		status = readl(&lp->rx_ring[entry].base) >> 16;
 		if (status & R_STP) {	/* Remember start of frame */
@@ -1104,6 +1109,12 @@ static int depca_rx(struct net_device *d
 		   ** Update entry information
 		 */
 		lp->rx_new = (lp->rx_new + 1) & lp->rxRingMask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1120,6 +1131,11 @@ static int depca_tx(struct net_device *d
 	s32 status;
 	u_long ioaddr = dev->base_addr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (entry = lp->tx_old; entry != lp->tx_new; entry = lp->tx_old) {
 		status = readl(&lp->tx_ring[entry].base) >> 16;
 
@@ -1149,6 +1165,12 @@ static int depca_tx(struct net_device *d
 
 		/* Update all the pointers */
 		lp->tx_old = (lp->tx_old + 1) & lp->txRingMask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1804,12 +1826,23 @@ static int load_packet(struct net_device
 
 		/* set up the buffer descriptors */
 		len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = entry; i != end; i = (i+1) & lp->txRingMask) {
 			/* clean out flags */
 			writel(readl(&lp->tx_ring[i].base) & ~T_FLAGS, &lp->tx_ring[i].base);
 			writew(0x0000, &lp->tx_ring[i].misc);	/* clears other error flags */
 			writew(-TX_BUFF_SZ, &lp->tx_ring[i].length);	/* packet length in buffer */
 			len -= TX_BUFF_SZ;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* clean out flags */
 		writel(readl(&lp->tx_ring[end].base) & ~T_FLAGS, &lp->tx_ring[end].base);
diff -u -p a/net/ethernet/mellanox/mlx4/fw.c b/net/ethernet/mellanox/mlx4/fw.c
--- a/net/ethernet/mellanox/mlx4/fw.c
+++ b/net/ethernet/mellanox/mlx4/fw.c
@@ -487,6 +487,11 @@ int mlx4_map_cmd(struct mlx4_dev *dev, u
 	memset(mailbox->buf, 0, MLX4_MAILBOX_SIZE);
 	pages = mailbox->buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mlx4_icm_first(icm, &iter);
 	     !mlx4_icm_last(&iter);
 	     mlx4_icm_next(&iter)) {
@@ -525,6 +530,12 @@ int mlx4_map_cmd(struct mlx4_dev *dev, u
 				nent = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nent)
diff -u -p a/net/ethernet/mellanox/mlx4/icm.c b/net/ethernet/mellanox/mlx4/icm.c
--- a/net/ethernet/mellanox/mlx4/icm.c
+++ b/net/ethernet/mellanox/mlx4/icm.c
@@ -330,10 +330,21 @@ int mlx4_table_get_range(struct mlx4_dev
 	int inc = MLX4_TABLE_CHUNK_SIZE / table->obj_size;
 	int i, err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i <= end; i += inc) {
 		err = mlx4_table_get(dev, table, i);
 		if (err)
 			goto fail;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/net/ethernet/cadence/macb.c b/net/ethernet/cadence/macb.c
--- a/net/ethernet/cadence/macb.c
+++ b/net/ethernet/cadence/macb.c
@@ -326,6 +326,11 @@ static void macb_tx(struct macb *bp)
 		bp->tx_ring[TX_RING_SIZE - 1].ctrl |= MACB_BIT(TX_WRAP);
 
 		/* free transmit buffer in upper layer*/
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (tail = bp->tx_tail; tail != head; tail = NEXT_TX(tail)) {
 			struct ring_info *rp = &bp->tx_skb[tail];
 			struct sk_buff *skb = rp->skb;
@@ -338,6 +343,12 @@ static void macb_tx(struct macb *bp)
 							 DMA_TO_DEVICE);
 			rp->skb = NULL;
 			dev_kfree_skb_irq(skb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		bp->tx_head = bp->tx_tail = 0;
diff -u -p a/net/ethernet/sun/sunvnet.c b/net/ethernet/sun/sunvnet.c
--- a/net/ethernet/sun/sunvnet.c
+++ b/net/ethernet/sun/sunvnet.c
@@ -751,9 +751,20 @@ static struct vnet_mcast_entry *__vnet_m
 {
 	struct vnet_mcast_entry *m;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = vp->mcast_list; m; m = m->next) {
 		if (!memcmp(m->addr, addr, ETH_ALEN))
 			return m;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -799,6 +810,11 @@ static void __send_mc_list(struct vnet *
 	info.set = 1;
 
 	n_addrs = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = vp->mcast_list; m; m = m->next) {
 		if (m->sent)
 			continue;
@@ -812,6 +828,12 @@ static void __send_mc_list(struct vnet *
 					    sizeof(info));
 			n_addrs = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (n_addrs) {
 		info.count = n_addrs;
diff -u -p a/net/ethernet/sun/sunhme.c b/net/ethernet/sun/sunhme.c
--- a/net/ethernet/sun/sunhme.c
+++ b/net/ethernet/sun/sunhme.c
@@ -2536,6 +2536,11 @@ static int __init quattro_sbus_register_
 {
 	struct quattro *qp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qp = qfe_sbus_list; qp != NULL; qp = qp->next) {
 		struct platform_device *op = qp->quattro_dev;
 		int err, qfe_slot, skip = 0;
@@ -2556,6 +2561,12 @@ static int __init quattro_sbus_register_
 			       "error %d.\n", err);
 			return err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -2565,6 +2576,11 @@ static void quattro_sbus_free_irqs(void)
 {
 	struct quattro *qp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qp = qfe_sbus_list; qp != NULL; qp = qp->next) {
 		struct platform_device *op = qp->quattro_dev;
 		int qfe_slot, skip = 0;
@@ -2577,6 +2593,12 @@ static void quattro_sbus_free_irqs(void)
 			continue;
 
 		free_irq(op->archdata.irqs[0], qp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 #endif /* CONFIG_SBUS */
@@ -2588,11 +2610,22 @@ static struct quattro * __devinit quattr
 	struct quattro *qp;
 
 	if (!bdev) return NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qp = qfe_pci_list; qp != NULL; qp = qp->next) {
 		struct pci_dev *qpdev = qp->quattro_dev;
 
 		if (qpdev == bdev)
 			return qp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	qp = kmalloc(sizeof(struct quattro), GFP_KERNEL);
 	if (qp != NULL) {
diff -u -p a/net/ethernet/sgi/ioc3-eth.c b/net/ethernet/sgi/ioc3-eth.c
--- a/net/ethernet/sgi/ioc3-eth.c
+++ b/net/ethernet/sgi/ioc3-eth.c
@@ -841,11 +841,22 @@ static inline void ioc3_clean_rx_ring(st
 	ip->rx_pi &= 511;
 	ip->rx_ci &= 511;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ip->rx_ci; i != ip->rx_pi; i = (i+1) & 511) {
 		struct ioc3_erxbuf *rxb;
 		skb = ip->rx_skbs[i];
 		rxb = (struct ioc3_erxbuf *) (skb->data - RX_OFFSET);
 		rxb->w0 = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/sfc/mtd.c b/net/ethernet/sfc/mtd.c
--- a/net/ethernet/sfc/mtd.c
+++ b/net/ethernet/sfc/mtd.c
@@ -163,6 +163,11 @@ efx_spi_erase(struct efx_mtd_partition *
 
 	/* Verify the entire region has been wiped */
 	memset(empty, 0xff, sizeof(empty));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pos = 0; pos < len; pos += block_len) {
 		block_len = min(len - pos, sizeof(buffer));
 		rc = falcon_spi_read(efx, spi, start + pos, block_len,
@@ -176,6 +181,12 @@ efx_spi_erase(struct efx_mtd_partition *
 		cond_resched();
 		if (signal_pending(current))
 			return -EINTR;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return rc;
diff -u -p a/net/ethernet/intel/e100.c b/net/ethernet/intel/e100.c
--- a/net/ethernet/intel/e100.c
+++ b/net/ethernet/intel/e100.c
@@ -1778,6 +1778,11 @@ static int e100_tx_clean(struct nic *nic
 	spin_lock(&nic->cb_lock);
 
 	/* Clean CBs marked complete */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cb = nic->cb_to_clean;
 	    cb->status & cpu_to_le16(cb_complete);
 	    cb = nic->cb_to_clean = cb->next) {
@@ -1801,6 +1806,12 @@ static int e100_tx_clean(struct nic *nic
 		}
 		cb->status = 0;
 		nic->cbs_avail++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock(&nic->cb_lock);
diff -u -p a/net/wan/pc300_drv.c b/net/wan/pc300_drv.c
--- a/net/wan/pc300_drv.c
+++ b/net/wan/pc300_drv.c
@@ -375,6 +375,11 @@ static void tx_dma_buf_check(pc300_t * c
 	printk("#CH%d: f_bd = %d(0x%08zx), n_bd = %d(0x%08zx)\n", ch,
 	       first_bd, TX_BD_ADDR(ch, first_bd),
 	       next_bd, TX_BD_ADDR(ch, next_bd));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = first_bd,
 	     ptdescr = (card->hw.rambase + TX_BD_ADDR(ch, first_bd));
 	     i != ((next_bd + 1) & (N_DMA_TX_BUF - 1));
@@ -384,6 +389,12 @@ static void tx_dma_buf_check(pc300_t * c
 		       ch, i, cpc_readl(&ptdescr->next),
 		       cpc_readl(&ptdescr->ptbuf),
 		       cpc_readb(&ptdescr->status), cpc_readw(&ptdescr->len));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("\n");
 }
diff -u -p a/net/wan/hdlc_ppp.c b/net/wan/hdlc_ppp.c
--- a/net/wan/hdlc_ppp.c
+++ b/net/wan/hdlc_ppp.c
@@ -385,6 +385,11 @@ static void ppp_cp_parse_cr(struct net_d
 		return;	/* out of memory, ignore CR packet */
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (opt = data; len; len -= opt[1], opt += opt[1]) {
 		if (len < 2 || len < opt[1]) {
 			dev->stats.rx_errors++;
@@ -417,6 +422,12 @@ static void ppp_cp_parse_cr(struct net_d
 		/* reject this option */
 		memcpy(out + rej_len, opt, opt[1]);
 		rej_len += opt[1];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (rej_len)
diff -u -p a/net/can/sja1000/peak_pci.c b/net/can/sja1000/peak_pci.c
--- a/net/can/sja1000/peak_pci.c
+++ b/net/can/sja1000/peak_pci.c
@@ -217,12 +217,23 @@ failure_remove_channels:
 	/* Disable interrupts */
 	writew(0x0, cfg_base + PITA_ICR + 2);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = dev0; dev; dev = chan->next_dev) {
 		unregister_sja1000dev(dev);
 		free_sja1000dev(dev);
 		priv = netdev_priv(dev);
 		chan = priv->priv;
 		dev = chan->next_dev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pci_iounmap(pdev, reg_base);
diff -u -p a/net/irda/vlsi_ir.c b/net/irda/vlsi_ir.c
--- a/net/irda/vlsi_ir.c
+++ b/net/irda/vlsi_ir.c
@@ -692,6 +692,11 @@ static void vlsi_unarm_rx(vlsi_irda_dev_
 	struct ring_descr *rd;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = ring_first(r); rd != NULL; rd = ring_get(r)) {
 
 		ret = 0;
@@ -729,6 +734,12 @@ static void vlsi_unarm_rx(vlsi_irda_dev_
 			ndev->stats.rx_packets++;
 			ndev->stats.rx_bytes += ret;
 		}
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1129,6 +1140,11 @@ static void vlsi_unarm_tx(vlsi_irda_dev_
 	struct ring_descr *rd;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = ring_first(r); rd != NULL; rd = ring_get(r)) {
 
 		ret = 0;
@@ -1158,6 +1174,12 @@ static void vlsi_unarm_tx(vlsi_irda_dev_
 			ndev->stats.tx_packets++;
 			ndev->stats.tx_bytes += ret;
 		}
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 }
diff -u -p a/net/bonding/bond_3ad.c b/net/bonding/bond_3ad.c
--- a/net/bonding/bond_3ad.c
+++ b/net/bonding/bond_3ad.c
@@ -699,12 +699,23 @@ static void __set_agg_ports_ready(struct
 {
 	struct port *port;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (port = aggregator->lag_ports; port;
 	     port = port->next_port_in_aggregator) {
 		if (val)
 			port->sm_vars |= AD_PORT_READY;
 		else
 			port->sm_vars &= ~AD_PORT_READY;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1558,6 +1569,11 @@ static void ad_agg_selection_logic(struc
 			 best->lag_ports, best->slave,
 			 best->slave ? best->slave->dev->name : "NULL");
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (agg = __get_first_agg(best->lag_ports); agg;
 		     agg = __get_next_agg(agg)) {
 
@@ -1566,6 +1582,12 @@ static void ad_agg_selection_logic(struc
 				 agg->actor_oper_aggregator_key,
 				 agg->partner_oper_aggregator_key,
 				 agg->is_individual, agg->is_active);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		// check if any partner replys
@@ -1585,9 +1607,20 @@ static void ad_agg_selection_logic(struc
 
 		// disable the ports that were related to the former active_aggregator
 		if (active) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (port = active->lag_ports; port;
 			     port = port->next_port_in_aggregator) {
 				__disable_port(port);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -1600,9 +1633,20 @@ static void ad_agg_selection_logic(struc
 
 	if (active) {
 		if (!__agg_has_partner(active)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (port = active->lag_ports; port;
 			     port = port->next_port_in_aggregator) {
 				__enable_port(port);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -2025,10 +2069,21 @@ void bond_3ad_unbind_slave(struct slave
 				new_aggregator->num_of_ports = aggregator->num_of_ports;
 
 				// update the information that is written on the ports about the aggregator
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (temp_port = aggregator->lag_ports; temp_port;
 				     temp_port = temp_port->next_port_in_aggregator) {
 					temp_port->aggregator = new_aggregator;
 					temp_port->actor_port_aggregator_identifier = new_aggregator->aggregator_identifier;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				// clear the aggregator
@@ -2129,6 +2184,11 @@ void bond_3ad_state_machine_handler(stru
 	}
 
 	// for each port run the state machines
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (port = __get_first_port(bond); port; port = __get_next_port(port)) {
 		if (!port->slave) {
 			pr_warning("%s: Warning: Found an uninitialized port\n",
@@ -2153,6 +2213,12 @@ void bond_3ad_state_machine_handler(stru
 			port->sm_vars &= ~AD_PORT_BEGIN;
 
 		__release_state_machine_lock(port);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 re_arm:
diff -u -p a/net/appletalk/ipddp.c b/net/appletalk/ipddp.c
--- a/net/appletalk/ipddp.c
+++ b/net/appletalk/ipddp.c
@@ -254,12 +254,23 @@ static struct ipddp_route* __ipddp_find_
 {
         struct ipddp_route *f;
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for(f = ipddp_route_list; f != NULL; f = f->next)
         {
                 if(f->ip == rt->ip &&
 		   f->at.s_net == rt->at.s_net &&
 		   f->at.s_node == rt->at.s_node)
                         return f;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
         }
 
         return NULL;
diff -u -p a/net/fddi/defxx.c b/net/fddi/defxx.c
--- a/net/fddi/defxx.c
+++ b/net/fddi/defxx.c
@@ -2931,7 +2931,12 @@ static int dfx_rcv_init(DFX_board_t *bp,
 
 	if (get_buffers) {
 #ifdef DYNAMIC_BUFFERS
-	for (i = 0; i < (int)(bp->rcv_bufs_to_post); i++)
+	for (i = 0; i < (int)(bp->rcv_bufs_to_post); i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)
 		{
 			struct sk_buff *newskb = __netdev_alloc_skb(bp->dev, NEW_SKB_SIZE, GFP_NOIO);
@@ -2954,16 +2959,35 @@ static int dfx_rcv_init(DFX_board_t *bp,
 			 * kernel so we put the skb pointer here.
 			 */
 			bp->p_rcv_buff_va[i+j] = (char *) newskb;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
+	}
 #else
-	for (i=0; i < (int)(bp->rcv_bufs_to_post); i++)
-		for (j=0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)
+	for (i=0; i < (int)(bp->rcv_bufs_to_post); i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j=0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)
 			{
 			bp->descr_block_virt->rcv_data[i+j].long_0 = (u32) (PI_RCV_DESCR_M_SOP |
 				((PI_RCV_DATA_K_SIZE_MAX / PI_ALIGN_K_RCV_DATA_BUFF) << PI_RCV_DESCR_V_SEG_LEN));
 			bp->descr_block_virt->rcv_data[i+j].long_1 = (u32) (bp->rcv_block_phys + (i * PI_RCV_DATA_K_SIZE_MAX));
 			bp->p_rcv_buff_va[i+j] = (char *) (bp->rcv_block_virt + (i * PI_RCV_DATA_K_SIZE_MAX));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 			}
+	}
 #endif
 	}
 
@@ -3453,7 +3477,12 @@ static void dfx_rcv_flush( DFX_board_t *
 	{
 	int i, j;
 
-	for (i = 0; i < (int)(bp->rcv_bufs_to_post); i++)
+	for (i = 0; i < (int)(bp->rcv_bufs_to_post); i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)
 		{
 			struct sk_buff *skb;
@@ -3461,7 +3490,14 @@ static void dfx_rcv_flush( DFX_board_t *
 			if (skb)
 				dev_kfree_skb(skb);
 			bp->p_rcv_buff_va[i+j] = NULL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
+	}
 
 	}
 #else
diff -u -p a/net/fddi/skfp/smttimer.c b/net/fddi/skfp/smttimer.c
--- a/net/fddi/skfp/smttimer.c
+++ b/net/fddi/skfp/smttimer.c
@@ -48,6 +48,11 @@ void smt_timer_stop(struct s_smc *smc, s
 	if (smc->t.st_queue == timer && !timer->tm_next) {
 		hwt_stop(smc) ;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = &smc->t.st_queue ; (tm = *prev) ; prev = &tm->tm_next ) {
 		if (tm == timer) {
 			*prev = tm->tm_next ;
@@ -56,6 +61,12 @@ void smt_timer_stop(struct s_smc *smc, s
 			}
 			return ;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -145,9 +156,20 @@ static void timer_done(struct s_smc *smc
 	next = smc->t.st_queue ;
 	smc->t.st_queue = tm ;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for ( tm = next ; tm ; tm = next) {
 		next = tm->tm_next ;
 		timer_event(smc,tm->tm_token) ;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (restart && smc->t.st_queue)
diff -u -p a/pci/hotplug/acpiphp_glue.c b/pci/hotplug/acpiphp_glue.c
--- a/pci/hotplug/acpiphp_glue.c
+++ b/pci/hotplug/acpiphp_glue.c
@@ -333,11 +333,22 @@ static struct acpiphp_func *acpiphp_brid
 	struct acpiphp_func *func;
 
 	list_for_each_entry(bridge, &bridge_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (slot = bridge->slots; slot; slot = slot->next) {
 			list_for_each_entry(func, &slot->funcs, sibling) {
 				if (func->handle == handle)
 					return func;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1019,6 +1030,11 @@ static int acpiphp_check_bridge(struct a
 
 	enabled = disabled = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (slot = bridge->slots; slot; slot = slot->next) {
 		unsigned int status = get_slot_status(slot);
 		if (slot->flags & SLOT_ENABLED) {
@@ -1042,6 +1058,12 @@ static int acpiphp_check_bridge(struct a
 			}
 			enabled++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dbg("%s: %d enabled, %d disabled\n", __func__, enabled, disabled);
diff -u -p a/pci/hotplug/cpqphp_ctrl.c b/pci/hotplug/cpqphp_ctrl.c
--- a/pci/hotplug/cpqphp_ctrl.c
+++ b/pci/hotplug/cpqphp_ctrl.c
@@ -553,6 +553,11 @@ static struct pci_resource *get_io_resou
 	if (sort_by_size(head))
 		return NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = *head; node; node = node->next) {
 		if (node->length < size)
 			continue;
@@ -619,6 +624,12 @@ static struct pci_resource *get_io_resou
 		}
 		node->next = NULL;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return node;
@@ -647,6 +658,11 @@ static struct pci_resource *get_max_reso
 	if (sort_by_max_size(head))
 		return NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (max = *head; max; max = max->next) {
 		/* If not big enough we could probably just bail,
 		 * instead we'll continue to the next.
@@ -714,6 +730,12 @@ static struct pci_resource *get_max_reso
 
 		max->next = NULL;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return max;
@@ -744,6 +766,11 @@ static struct pci_resource *get_resource
 	if (sort_by_size(head))
 		return NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = *head; node; node = node->next) {
 		dbg("%s: req_size =%x node=%p, base=%x, length=%x\n",
 		    __func__, size, node, node->base, node->length);
@@ -809,6 +836,12 @@ static struct pci_resource *get_resource
 		}
 		node->next = NULL;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return node;
 }
@@ -1142,6 +1175,11 @@ static u8 set_controller_speed(struct co
 	/* We don't allow freq/mode changes if we find another adapter running
 	 * in another slot on this controller
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(slot = ctrl->slot; slot; slot = slot->next) {
 		if (slot->device == (hp_slot + ctrl->slot_device_offset))
 			continue;
@@ -1157,6 +1195,12 @@ static u8 set_controller_speed(struct co
 			return 0;
 
 		return 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If the controller doesn't support freq/mode changes and the
diff -u -p a/pci/setup-bus.c b/pci/setup-bus.c
--- a/pci/setup-bus.c
+++ b/pci/setup-bus.c
@@ -199,6 +199,11 @@ static void assign_requested_resources_s
 	struct resource_list *list;
 	int idx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (list = head->next; list; list = list->next) {
 		res = list->res;
 		idx = res - &list->dev->resource[0];
@@ -214,6 +219,12 @@ static void assign_requested_resources_s
 			}
 			reset_resource(res);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/pci/probe.c b/pci/probe.c
--- a/pci/probe.c
+++ b/pci/probe.c
@@ -1319,6 +1319,11 @@ int pci_scan_slot(struct pci_bus *bus, i
 	else if (dev->multifunction)
 		next_fn = next_trad_fn;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (fn = next_fn(dev, 0); fn > 0; fn = next_fn(dev, fn)) {
 		dev = pci_scan_single_device(bus, devfn + fn);
 		if (dev) {
@@ -1326,6 +1331,12 @@ int pci_scan_slot(struct pci_bus *bus, i
 				nr++;
 			dev->multifunction = 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* only one slot has pcie device */
diff -u -p a/tty/isicom.c b/tty/isicom.c
--- a/tty/isicom.c
+++ b/tty/isicom.c
@@ -1416,6 +1416,11 @@ static int __devinit load_firmware(struc
 
 	retval = -EIO;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (frame = (struct stframe *)fw->data;
 			frame < (struct stframe *)(fw->data + fw->size);
 			frame = (struct stframe *)((u8 *)(frame + 1) +
@@ -1460,10 +1465,21 @@ static int __devinit load_firmware(struc
 				"Status:0x%x\n", index + 1, status);
 			goto errrelfw;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 /* XXX: should we test it by reading it back and comparing with original like
  * in load firmware package? */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (frame = (struct stframe *)fw->data;
 			frame < (struct stframe *)(fw->data + fw->size);
 			frame = (struct stframe *)((u8 *)(frame + 1) +
@@ -1524,6 +1540,12 @@ static int __devinit load_firmware(struc
 				"Card Status:0x%x\n", index + 1, status);
 			goto errrelfw;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* xfer ctrl */
diff -u -p a/tty/synclink_gt.c b/tty/synclink_gt.c
--- a/tty/synclink_gt.c
+++ b/tty/synclink_gt.c
@@ -2354,6 +2354,11 @@ static void isr_gpio(struct slgt_info *i
 	struct cond_wait *w, *prev;
 
 	/* wake processes waiting for specific transitions */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (w = info->gpio_wait_q, prev = NULL ; w != NULL ; w = w->next) {
 		if (w->data & changed) {
 			w->data = state;
@@ -2364,6 +2369,12 @@ static void isr_gpio(struct slgt_info *i
 				info->gpio_wait_q = w->next;
 		} else
 			prev = w;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/n_r3964.c b/tty/n_r3964.c
--- a/tty/n_r3964.c
+++ b/tty/n_r3964.c
@@ -536,11 +536,22 @@ static void on_receive_block(struct r396
 	add_rx_queue(pInfo, pBlock);
 
 	/* notify attached client processes: */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pClient = pInfo->firstClient; pClient; pClient = pClient->next) {
 		if (pClient->sig_flags & R3964_SIG_DATA) {
 			add_msg(pClient, R3964_MSG_DATA, length, R3964_OK,
 				pBlock);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	wake_up_interruptible(&pInfo->read_wait);
 
@@ -739,10 +750,21 @@ static struct r3964_client_info *findCli
 {
 	struct r3964_client_info *pClient;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pClient = pInfo->firstClient; pClient; pClient = pClient->next) {
 		if (pClient->pid == pid) {
 			return pClient;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -755,6 +777,11 @@ static int enable_signals(struct r3964_i
 
 	if ((arg & R3964_SIG_ALL) == 0) {
 		/* Remove client from client list */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (ppClient = &pInfo->firstClient; *ppClient;
 		     ppClient = &(*ppClient)->next) {
 			pClient = *ppClient;
@@ -776,6 +803,12 @@ static int enable_signals(struct r3964_i
 				TRACE_M("enable_signals - kfree %p", pClient);
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		return -EINVAL;
 	} else {
diff -u -p a/tty/hvc/hvc_beat.c b/tty/hvc/hvc_beat.c
--- a/tty/hvc/hvc_beat.c
+++ b/tty/hvc/hvc_beat.c
@@ -75,11 +75,22 @@ static int hvc_beat_put_chars(uint32_t v
 	unsigned long kb[2];
 	int rest, nlen;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rest = cnt; rest > 0; rest -= nlen) {
 		nlen = (rest > 16) ? 16 : rest;
 		memcpy(kb, buf, nlen);
 		beat_put_term_char(vtermno, nlen, kb[0], kb[1]);
 		buf += nlen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return cnt;
 }
diff -u -p a/tty/serial/mrst_max3110.c b/tty/serial/mrst_max3110.c
--- a/tty/serial/mrst_max3110.c
+++ b/tty/serial/mrst_max3110.c
@@ -369,12 +369,23 @@ receive_chars(struct uart_max3110 *max,
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (r = 0; w; r += usable, w -= usable) {
 		usable = tty_buffer_request_room(tty, w);
 		if (usable) {
 			tty_insert_flip_string(tty, buf + r, usable);
 			port->icount.rx += usable;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	tty_flip_buffer_push(tty);
 	tty_kref_put(tty);
diff -u -p a/tty/serial/pch_uart.c b/tty/serial/pch_uart.c
--- a/tty/serial/pch_uart.c
+++ b/tty/serial/pch_uart.c
@@ -458,11 +458,22 @@ static int pch_uart_hal_read(struct eg20
 	u8 rbr, lsr;
 
 	lsr = ioread8(priv->membase + UART_LSR);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, lsr = ioread8(priv->membase + UART_LSR);
 	     i < rx_size && lsr & UART_LSR_DR;
 	     lsr = ioread8(priv->membase + UART_LSR)) {
 		rbr = ioread8(priv->membase + PCH_UART_RBR);
 		buf[i++] = rbr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return i;
 }
diff -u -p a/mtd/tests/mtd_torturetest.c b/mtd/tests/mtd_torturetest.c
--- a/mtd/tests/mtd_torturetest.c
+++ b/mtd/tests/mtd_torturetest.c
@@ -447,6 +447,11 @@ static void report_corrupt(unsigned char
 	printk(PRINT_PREF "The following is a list of all differences between"
 	       " what was read from flash and what was expected\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < check_len; i += pgsize) {
 		cond_resched();
 		bytes = bits = 0;
@@ -467,6 +472,12 @@ static void report_corrupt(unsigned char
 		len = ((first + bytes) | 0x7) + 1 - offset;
 
 		print_bufs(read, written, offset, len);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/chips/cfi_cmdset_0020.c b/mtd/chips/cfi_cmdset_0020.c
--- a/mtd/chips/cfi_cmdset_0020.c
+++ b/mtd/chips/cfi_cmdset_0020.c
@@ -523,11 +523,22 @@ static inline int do_write_buffer(struct
 	map_write(map, CMD(len/map_bankwidth(map)-1), cmd_adr );
 
 	/* Write data */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (z = 0; z < len;
 	     z += map_bankwidth(map), buf += map_bankwidth(map)) {
 		map_word d;
 		d = map_word_load(map, buf);
 		map_write(map, d, adr+z);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* GO GO GO */
 	map_write(map, CMD(0xd0), cmd_adr);
diff -u -p a/mtd/redboot.c b/mtd/redboot.c
--- a/mtd/redboot.c
+++ b/mtd/redboot.c
@@ -220,11 +220,22 @@ static int parse_redboot_partitions(stru
 		nulllen = sizeof(nullstring);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tmp_fl = fl; tmp_fl->next; tmp_fl = tmp_fl->next) {
 		if (tmp_fl->img->flash_base + tmp_fl->img->size + master->erasesize <= tmp_fl->next->img->flash_base) {
 			nrparts++;
 			nulllen = sizeof(nullstring);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 #endif
 	parts = kzalloc(sizeof(*parts)*nrparts + nulllen + namelen, GFP_KERNEL);
diff -u -p a/mtd/devices/m25p80.c b/mtd/devices/m25p80.c
--- a/mtd/devices/m25p80.c
+++ b/mtd/devices/m25p80.c
@@ -471,6 +471,11 @@ static int m25p80_write(struct mtd_info
 		*retlen = m.actual_length - m25p_cmdsz(flash);
 
 		/* write everything in flash->page_size chunks */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = page_size; i < len; i += page_size) {
 			page_size = len - i;
 			if (page_size > flash->page_size)
@@ -489,6 +494,12 @@ static int m25p80_write(struct mtd_info
 			spi_sync(flash->spi, &m);
 
 			*retlen += m.actual_length - m25p_cmdsz(flash);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/mtd/devices/sst25l.c b/mtd/devices/sst25l.c
--- a/mtd/devices/sst25l.c
+++ b/mtd/devices/sst25l.c
@@ -290,6 +290,11 @@ static int sst25l_write(struct mtd_info
 	if (ret)
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i += mtd->writesize) {
 		ret = sst25l_wait_till_ready(flash);
 		if (ret)
@@ -321,6 +326,12 @@ static int sst25l_write(struct mtd_info
 			if (ret)
 				goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
diff -u -p a/mtd/cmdlinepart.c b/mtd/cmdlinepart.c
--- a/mtd/cmdlinepart.c
+++ b/mtd/cmdlinepart.c
@@ -326,6 +326,11 @@ static int parse_cmdline_partitions(stru
 	if (!cmdline_parsed)
 		mtdpart_setup_real(cmdline);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(part = partitions; part; part = part->next)
 	{
 		if ((!mtd_id) || (!strcmp(part->mtd_id, mtd_id)))
@@ -355,6 +360,12 @@ static int parse_cmdline_partitions(stru
 				return -ENOMEM;
 			return part->num_parts;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/mtd/nand/nand_base.c b/mtd/nand/nand_base.c
--- a/mtd/nand/nand_base.c
+++ b/mtd/nand/nand_base.c
@@ -1211,6 +1211,11 @@ static int nand_read_subpage(struct mtd_
 		chip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + index]];
 
 	p = bufpoi + data_col_addr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
 		int stat;
 
@@ -1220,6 +1225,12 @@ static int nand_read_subpage(struct mtd_
 			mtd->ecc_stats.failed++;
 		else
 			mtd->ecc_stats.corrected += stat;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/mtd/nand/diskonchip.c b/mtd/nand/diskonchip.c
--- a/mtd/nand/diskonchip.c
+++ b/mtd/nand/diskonchip.c
@@ -1071,6 +1071,11 @@ static int __init find_media_headers(str
 	int ret;
 	size_t retlen;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offs = 0; offs < mtd->size; offs += mtd->erasesize) {
 		ret = mtd->read(mtd, offs, mtd->writesize, &retlen, buf);
 		if (retlen != mtd->writesize)
@@ -1089,6 +1094,12 @@ static int __init find_media_headers(str
 		}
 		doc->mh1_page = offs >> this->page_shift;
 		return 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (doc->mh0_page == -1) {
 		printk(KERN_WARNING "DiskOnChip %s Media Header not found.\n", id);
@@ -1586,6 +1597,11 @@ static int __init doc_probe(unsigned lon
 		goto notfound;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mtd = doclist; mtd; mtd = doc->nextdoc) {
 		unsigned char oldval;
 		unsigned char newval;
@@ -1618,6 +1634,12 @@ static int __init doc_probe(unsigned lon
 			printk(KERN_DEBUG "Found alias of DOC at 0x%lx to 0x%lx\n", doc->physadr, physadr);
 			goto notfound;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_NOTICE "DiskOnChip found at 0x%lx\n", physadr);
@@ -1702,6 +1724,11 @@ static void release_nanddoc(void)
 	struct nand_chip *nand;
 	struct doc_priv *doc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mtd = doclist; mtd; mtd = nextmtd) {
 		nand = mtd->priv;
 		doc = nand->priv;
@@ -1710,6 +1737,12 @@ static void release_nanddoc(void)
 		nand_release(mtd);
 		iounmap(doc->virtadr);
 		kfree(mtd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/parport/share.c b/parport/share.c
--- a/parport/share.c
+++ b/parport/share.c
@@ -978,6 +978,11 @@ void parport_release(struct pardevice *d
 	/* If anybody is waiting, find out who's been there longest and
 	   then wake them up. (Note: no locking required) */
 	/* !!! LOCKING IS NEEDED HERE */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pd = port->waithead; pd; pd = pd->waitnext) {
 		if (pd->waiting & 2) { /* sleeping in claim_or_block */
 			parport_claim(pd);
@@ -991,14 +996,31 @@ void parport_release(struct pardevice *d
 		} else {
 			printk(KERN_ERR "%s: don't know how to wake %s\n", port->name, pd->name);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Nobody was waiting, so walk the list to see if anyone is
 	   interested in being woken up. (Note: no locking required) */
 	/* !!! LOCKING IS NEEDED HERE */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pd = port->devices; (port->cad == NULL) && pd; pd = pd->next) {
 		if (pd->wakeup && pd != dev)
 			pd->wakeup(pd->private);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/parport/procfs.c b/parport/procfs.c
--- a/parport/procfs.c
+++ b/parport/procfs.c
@@ -47,10 +47,21 @@ static int do_active_device(ctl_table *t
 		return 0;
 	}
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = port->devices; dev ; dev = dev->next) {
 		if(dev == port->cad) {
 			len += sprintf(buffer, "%s\n", dev->name);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if(!len) {
diff -u -p a/scsi/qla2xxx/qla_dbg.c b/scsi/qla2xxx/qla_dbg.c
--- a/scsi/qla2xxx/qla_dbg.c
+++ b/scsi/qla2xxx/qla_dbg.c
@@ -83,6 +83,11 @@ qla24xx_dump_ram(struct qla_hw_data *ha,
 	clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
 
 	dwords = GID_LIST_SIZE / 4;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < ram_dwords && rval == QLA_SUCCESS;
 	    cnt += dwords, addr += dwords) {
 		if (cnt + dwords > ram_dwords)
@@ -133,6 +138,12 @@ qla24xx_dump_ram(struct qla_hw_data *ha,
 		} else {
 			rval = QLA_FUNCTION_FAILED;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*nxt = rval == QLA_SUCCESS ? &ram[cnt]: NULL;
@@ -258,6 +269,11 @@ qla2xxx_dump_ram(struct qla_hw_data *ha,
 	clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
 
 	words = GID_LIST_SIZE / 2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < ram_words && rval == QLA_SUCCESS;
 	    cnt += words, addr += words) {
 		if (cnt + words > ram_words)
@@ -318,6 +334,12 @@ qla2xxx_dump_ram(struct qla_hw_data *ha,
 		} else {
 			rval = QLA_FUNCTION_FAILED;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*nxt = rval == QLA_SUCCESS ? &ram[cnt]: NULL;
diff -u -p a/scsi/sg.c b/scsi/sg.c
--- a/scsi/sg.c
+++ b/scsi/sg.c
@@ -892,6 +892,11 @@ sg_ioctl(struct file *filp, unsigned int
 		if (!access_ok(VERIFY_WRITE, ip, sizeof (int)))
 			return -EFAULT;
 		read_lock_irqsave(&sfp->rq_list_lock, iflags);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (srp = sfp->headrp; srp; srp = srp->nextrp) {
 			if ((1 == srp->done) && (!srp->sg_io_owned)) {
 				read_unlock_irqrestore(&sfp->rq_list_lock,
@@ -899,15 +904,32 @@ sg_ioctl(struct file *filp, unsigned int
 				__put_user(srp->header.pack_id, ip);
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 		__put_user(-1, ip);
 		return 0;
 	case SG_GET_NUM_WAITING:
 		read_lock_irqsave(&sfp->rq_list_lock, iflags);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (val = 0, srp = sfp->headrp; srp; srp = srp->nextrp) {
 			if ((1 == srp->done) && (!srp->sg_io_owned))
 				++val;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 		return put_user(val, ip);
@@ -1141,11 +1163,22 @@ sg_poll(struct file *filp, poll_table *
 		return POLLERR;
 	poll_wait(filp, &sfp->read_wait, wait);
 	read_lock_irqsave(&sfp->rq_list_lock, iflags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (srp = sfp->headrp; srp; srp = srp->nextrp) {
 		/* if any read waiting, flag it */
 		if ((0 == res) && (1 == srp->done) && (!srp->sg_io_owned))
 			res = POLLIN | POLLRDNORM;
 		++count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 
diff -u -p a/scsi/sun3_NCR5380.c b/scsi/sun3_NCR5380.c
--- a/scsi/sun3_NCR5380.c
+++ b/scsi/sun3_NCR5380.c
@@ -737,18 +737,40 @@ static int NCR5380_proc_info(struct Scsi
 				pos, buffer, length);
     SPRINTF("scsi%d: issue_queue\n", HOSTNO);
     check_offset();
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (ptr = (struct scsi_cmnd *) hostdata->issue_queue; ptr; ptr = NEXT(ptr))
     {
 	pos = lprint_Scsi_Cmnd (ptr, pos, buffer, length);
 	check_offset();
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
     }
 
     SPRINTF("scsi%d: disconnected_queue\n", HOSTNO);
     check_offset();
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (ptr = (struct scsi_cmnd *) hostdata->disconnected_queue; ptr;
 	 ptr = NEXT(ptr)) {
 	pos = lprint_Scsi_Cmnd (ptr, pos, buffer, length);
 	check_offset();
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
     }
 
     local_irq_restore(flags);
diff -u -p a/scsi/wd33c93.c b/scsi/wd33c93.c
--- a/scsi/wd33c93.c
+++ b/scsi/wd33c93.c
@@ -569,6 +569,11 @@ wd33c93_execute(struct Scsi_Host *instan
 		goto yes;
 	if (!(hostdata->input_Q))	/* input_Q empty? */
 		goto no;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = (struct scsi_cmnd *) hostdata->input_Q; prev;
 	     prev = (struct scsi_cmnd *) prev->host_scribble) {
 		if ((prev->device->id != cmd->device->id) ||
@@ -578,6 +583,12 @@ wd33c93_execute(struct Scsi_Host *instan
 				prev->SCp.phase = 1;
 			goto yes;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	goto no;
diff -u -p a/scsi/device_handler/scsi_dh_alua.c b/scsi/device_handler/scsi_dh_alua.c
--- a/scsi/device_handler/scsi_dh_alua.c
+++ b/scsi/device_handler/scsi_dh_alua.c
@@ -546,12 +546,23 @@ static int alua_rtpg(struct scsi_device
 		goto retry;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 4, ucp = h->buff + 4; k < len; k += off, ucp += off) {
 		if (h->group_id == (ucp[2] << 8) + ucp[3]) {
 			h->state = ucp[0] & 0x0f;
 			valid_states = ucp[1];
 		}
 		off = 8 + (ucp[7] * 4);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sdev_printk(KERN_INFO, sdev,
diff -u -p a/scsi/bnx2fc/bnx2fc_fcoe.c b/scsi/bnx2fc/bnx2fc_fcoe.c
--- a/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -130,6 +130,11 @@ static void bnx2fc_clean_rx_queue(struct
 	spin_lock_bh(&bg->fcoe_rx_list.lock);
 	list = &bg->fcoe_rx_list;
 	head = list->next;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (skb = head; skb != (struct sk_buff *)list;
 	     skb = next) {
 		next = skb->next;
@@ -138,6 +143,12 @@ static void bnx2fc_clean_rx_queue(struct
 			__skb_unlink(skb, list);
 			kfree_skb(skb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_bh(&bg->fcoe_rx_list.lock);
 }
diff -u -p a/scsi/scsi_devinfo.c b/scsi/scsi_devinfo.c
--- a/scsi/scsi_devinfo.c
+++ b/scsi/scsi_devinfo.c
@@ -501,6 +501,11 @@ static int scsi_dev_info_list_add_str(ch
 	 * For the leading and trailing '"' case, the for loop comes
 	 * through the last time with vendor[0] == '\0'.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vendor = strsep(&next, ":"); vendor && (vendor[0] != '\0')
 	     && (res == 0); vendor = strsep(&next, ":")) {
 		strflags = NULL;
@@ -515,6 +520,12 @@ static int scsi_dev_info_list_add_str(ch
 		} else
 			res = scsi_dev_info_list_add(0 /* compatible */, vendor,
 						     model, strflags, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return res;
 }
diff -u -p a/scsi/arm/msgqueue.c b/scsi/arm/msgqueue.c
--- a/scsi/arm/msgqueue.c
+++ b/scsi/arm/msgqueue.c
@@ -152,9 +152,20 @@ void msgqueue_flush(MsgQueue_t *msgq)
 {
 	struct msgqueue_entry *mq, *mqnext;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mq = msgq->qe; mq; mq = mqnext) {
 		mqnext = mq->next;
 		mqe_free(msgq, mq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	msgq->qe = NULL;
 }
diff -u -p a/scsi/ncr53c8xx.c b/scsi/ncr53c8xx.c
--- a/scsi/ncr53c8xx.c
+++ b/scsi/ncr53c8xx.c
@@ -5509,6 +5509,11 @@ static void ncr_set_sync_wide_status (st
 	/*
 	**	patch ALL ccbs of this target.
 	*/
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cp = np->ccb; cp; cp = cp->link_ccb) {
 		if (!cp->cmd) continue;
 		if (scmd_id(cp->cmd) != target) continue;
@@ -5518,6 +5523,12 @@ static void ncr_set_sync_wide_status (st
 #endif
 		cp->phys.select.sel_scntl3 = tp->wval;
 		cp->phys.select.sel_sxfer  = tp->sval;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/scsi_debug.c b/scsi/scsi_debug.c
--- a/scsi/scsi_debug.c
+++ b/scsi/scsi_debug.c
@@ -1889,6 +1889,11 @@ static int prot_verify_write(struct scsi
 		daddr = kmap_atomic(sg_page(dsgl), KM_IRQ0) + dsgl->offset;
 
 		/* For each sector-sized chunk in data page */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0 ; j < dsgl->length ; j += scsi_debug_sector_size) {
 
 			/* If we're at the end of the current
@@ -1969,6 +1974,12 @@ static int prot_verify_write(struct scsi
 			ei_lba++;
 			daddr += scsi_debug_sector_size;
 			ppage_offset += sizeof(struct sd_dif_tuple);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kunmap_atomic(daddr, KM_IRQ0);
diff -u -p a/scsi/aic7xxx/aicasm/aicasm.c b/scsi/aic7xxx/aicasm/aicasm.c
--- a/scsi/aic7xxx/aicasm/aicasm.c
+++ b/scsi/aic7xxx/aicasm/aicasm.c
@@ -321,6 +321,11 @@ back_patch()
 {
 	struct instruction *cur_instr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_instr = STAILQ_FIRST(&seq_program);
 	     cur_instr != NULL;
 	     cur_instr = STAILQ_NEXT(cur_instr, links)) {
@@ -342,6 +347,12 @@ back_patch()
 			address += cur_instr->patch_label->info.linfo->address;
 			f3_instr->address = address;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -363,6 +374,11 @@ output_code()
 "%s */\n", versions);
 
 	fprintf(ofile, "static const uint8_t seqprog[] = {\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_instr = STAILQ_FIRST(&seq_program);
 	     cur_instr != NULL;
 	     cur_instr = STAILQ_NEXT(cur_instr, links)) {
@@ -381,6 +397,12 @@ output_code()
 			cur_instr->format.bytes[0]);
 #endif
 		instrcount++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	fprintf(ofile, "\n};\n\n");
 
@@ -394,6 +416,11 @@ output_code()
 	fprintf(ofile,
 "typedef int %spatch_func_t (%s);\n", prefix, patch_arg_list);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_node = SLIST_FIRST(&patch_functions);
 	     cur_node != NULL;
 	     cur_node = SLIST_NEXT(cur_node,links)) {
@@ -412,6 +439,12 @@ output_code()
 			cur_node->symbol->info.condinfo->func_num,
 			patch_arg_list,
 			cur_node->symbol->name);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	fprintf(ofile,
@@ -422,6 +455,11 @@ output_code()
 "				 skip_patch	:12;\n"
 "} patches[] = {\n", prefix);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_patch = STAILQ_FIRST(&patches);
 	     cur_patch != NULL;
 	     cur_patch = STAILQ_NEXT(cur_patch,links)) {
@@ -430,6 +468,12 @@ output_code()
 			prefix,
 			cur_patch->patch_func, cur_patch->begin,
 			cur_patch->skip_instr, cur_patch->skip_patch);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	fprintf(ofile, "\n};\n\n");
@@ -440,12 +484,23 @@ output_code()
 "	uint16_t	end;\n"
 "} critical_sections[] = {\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cs = TAILQ_FIRST(&cs_tailq);
 	     cs != NULL;
 	     cs = TAILQ_NEXT(cs, links)) {
 		fprintf(ofile, "%s\t{ %d, %d }",
 			cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
 			cs->begin_addr, cs->end_addr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	fprintf(ofile, "\n};\n\n");
diff -u -p a/scsi/aic7xxx/aic79xx_core.c b/scsi/aic7xxx/aic79xx_core.c
--- a/scsi/aic7xxx/aic79xx_core.c
+++ b/scsi/aic7xxx/aic79xx_core.c
@@ -8307,6 +8307,11 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 	tid_next = ahd_inw(ahd, WAITING_TID_HEAD);
 	tid_prev = SCB_LIST_NULL;
 	targets = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (scbid = tid_next; !SCBID_IS_NULL(scbid); scbid = tid_next) {
 		u_int tid_head;
 		u_int tid_tail;
@@ -8415,6 +8420,12 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 			tid_prev = tid_head;
 		if (action == SEARCH_PRINT)
 			printk(")\n");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Restore saved state. */
@@ -8440,6 +8451,11 @@ ahd_search_scb_list(struct ahd_softc *ah
 	prev = SCB_LIST_NULL;
 	next = *list_head;
 	*list_tail = SCB_LIST_NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (scbid = next; !SCBID_IS_NULL(scbid); scbid = next) {
 		if (scbid >= ahd->scb_data.numscbs) {
 			printk("%s:SCB List inconsistency. "
@@ -8483,6 +8499,12 @@ ahd_search_scb_list(struct ahd_softc *ah
 		}
 		if (found > AHD_SCB_MAX)
 			panic("SCB LIST LOOP");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (action == SEARCH_COMPLETE
 	 || action == SEARCH_REMOVE)
diff -u -p a/scsi/fcoe/fcoe.c b/scsi/fcoe/fcoe.c
--- a/scsi/fcoe/fcoe.c
+++ b/scsi/fcoe/fcoe.c
@@ -2214,6 +2214,11 @@ void fcoe_percpu_clean(struct fc_lport *
 		spin_lock_bh(&pp->fcoe_rx_list.lock);
 		list = &pp->fcoe_rx_list;
 		head = list->next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (skb = head; skb != (struct sk_buff *)list;
 		     skb = next) {
 			next = skb->next;
@@ -2222,6 +2227,12 @@ void fcoe_percpu_clean(struct fc_lport *
 				__skb_unlink(skb, list);
 				kfree_skb(skb);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (!pp->thread || !cpu_online(cpu)) {
diff -u -p a/scsi/atari_NCR5380.c b/scsi/atari_NCR5380.c
--- a/scsi/atari_NCR5380.c
+++ b/scsi/atari_NCR5380.c
@@ -795,17 +795,39 @@ static int NCR5380_proc_info(struct Scsi
 				       pos, buffer, length);
 	SPRINTF("scsi%d: issue_queue\n", HOSTNO);
 	check_offset();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = (Scsi_Cmnd *)hostdata->issue_queue; ptr; ptr = NEXT(ptr)) {
 		pos = lprint_Scsi_Cmnd(ptr, pos, buffer, length);
 		check_offset();
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	SPRINTF("scsi%d: disconnected_queue\n", HOSTNO);
 	check_offset();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr;
 	     ptr = NEXT(ptr)) {
 		pos = lprint_Scsi_Cmnd(ptr, pos, buffer, length);
 		check_offset();
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	local_irq_restore(flags);
@@ -2721,6 +2743,11 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 	 * Case 2 : If the command hasn't been issued yet, we simply remove it
 	 *	    from the issue queue.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = (Scsi_Cmnd **)&(hostdata->issue_queue),
 	     tmp = (Scsi_Cmnd *)hostdata->issue_queue;
 	     tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp)) {
@@ -2738,6 +2765,12 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 			falcon_release_lock_if_possible(hostdata);
 			return SCSI_ABORT_SUCCESS;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -2782,6 +2815,11 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 	 * it from the disconnected queue.
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tmp = (Scsi_Cmnd *) hostdata->disconnected_queue; tmp;
 	     tmp = NEXT(tmp)) {
 		if (cmd == tmp) {
@@ -2796,6 +2834,11 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 			do_abort(instance);
 
 			local_irq_save(flags);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (prev = (Scsi_Cmnd **)&(hostdata->disconnected_queue),
 			     tmp = (Scsi_Cmnd *)hostdata->disconnected_queue;
 			     tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp)) {
@@ -2818,8 +2861,20 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 					falcon_release_lock_if_possible(hostdata);
 					return SCSI_ABORT_SUCCESS;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/of/base.c b/of/base.c
--- a/of/base.c
+++ b/of/base.c
@@ -497,11 +497,22 @@ struct device_node *of_find_node_with_pr
 	read_lock(&devtree_lock);
 	np = from ? from->allnext : allnodes;
 	for (; np; np = np->allnext) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (pp = np->properties; pp != 0; pp = pp->next) {
 			if (of_prop_cmp(pp->name, prop_name) == 0) {
 				of_node_get(np);
 				goto out;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 out:
@@ -750,12 +761,23 @@ int of_property_read_string_index(struct
 
 	p = prop->value;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; total < prop->length; total += l, p += l) {
 		l = strlen(p) + 1;
 		if ((*p != 0) && (i++ == index)) {
 			*output = p;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -ENODATA;
 }
@@ -790,10 +812,21 @@ int of_property_count_strings(struct dev
 
 	p = prop->value;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; total < prop->length; total += l, p += l) {
 		l = strlen(p) + 1;
 		if (*p != 0)
 			i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return i;
 }
diff -u -p a/dma/dw_dmac.c b/dma/dw_dmac.c
--- a/dma/dw_dmac.c
+++ b/dma/dw_dmac.c
@@ -648,6 +648,11 @@ dwc_prep_dma_memcpy(struct dma_chan *cha
 			| DWC_CTLL_FC_M2M;
 	prev = first = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < len; offset += xfer_count << src_width) {
 		xfer_count = min_t(size_t, (len - offset) >> src_width,
 				DWC_MAX_COUNT);
@@ -672,6 +677,12 @@ dwc_prep_dma_memcpy(struct dma_chan *cha
 					&first->tx_list);
 		}
 		prev = desc;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 
diff -u -p a/dma/ep93xx_dma.c b/dma/ep93xx_dma.c
--- a/dma/ep93xx_dma.c
+++ b/dma/ep93xx_dma.c
@@ -912,6 +912,11 @@ ep93xx_dma_prep_dma_memcpy(struct dma_ch
 	size_t bytes, offset;
 
 	first = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < len; offset += bytes) {
 		desc = ep93xx_dma_desc_get(edmac);
 		if (!desc) {
@@ -929,6 +934,12 @@ ep93xx_dma_prep_dma_memcpy(struct dma_ch
 			first = desc;
 		else
 			list_add_tail(&desc->node, &first->tx_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	first->txd.cookie = -EBUSY;
@@ -1058,6 +1069,11 @@ ep93xx_dma_prep_dma_cyclic(struct dma_ch
 
 	/* Split the buffer into period size chunks */
 	first = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < buf_len; offset += period_len) {
 		desc = ep93xx_dma_desc_get(edmac);
 		if (!desc) {
@@ -1079,6 +1095,12 @@ ep93xx_dma_prep_dma_cyclic(struct dma_ch
 			first = desc;
 		else
 			list_add_tail(&desc->node, &first->tx_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	first->txd.cookie = -EBUSY;
diff -u -p a/dma/txx9dmac.c b/dma/txx9dmac.c
--- a/dma/txx9dmac.c
+++ b/dma/txx9dmac.c
@@ -771,6 +771,11 @@ txx9dmac_prep_dma_memcpy(struct dma_chan
 
 	prev = first = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < len; offset += xfer_count) {
 		xfer_count = min_t(size_t, len - offset, TXX9_DMA_MAX_COUNT);
 		/*
@@ -826,6 +831,12 @@ txx9dmac_prep_dma_memcpy(struct dma_chan
 			list_add_tail(&desc->desc_node, &first->tx_list);
 		}
 		prev = desc;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Trigger interrupt after last block */
diff -u -p a/dma/at_hdmac.c b/dma/at_hdmac.c
--- a/dma/at_hdmac.c
+++ b/dma/at_hdmac.c
@@ -611,6 +611,11 @@ atc_prep_dma_memcpy(struct dma_chan *cha
 		src_width = dst_width = 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < len; offset += xfer_count << src_width) {
 		xfer_count = min_t(size_t, (len - offset) >> src_width,
 				ATC_BTSIZE_MAX);
@@ -627,6 +632,12 @@ atc_prep_dma_memcpy(struct dma_chan *cha
 		desc->txd.cookie = 0;
 
 		atc_desc_chain(&first, &prev, desc);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* First descriptor of the chain embedds additional information */
diff -u -p a/atm/suni.c b/atm/suni.c
--- a/atm/suni.c
+++ b/atm/suni.c
@@ -60,6 +60,11 @@ static void suni_hz(unsigned long from_t
 	struct atm_dev *dev;
 	struct k_sonet_stats *stats;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (walk = sunis; walk; walk = walk->next) {
 		dev = walk->dev;
 		stats = &walk->sonet_stats;
@@ -85,6 +90,12 @@ static void suni_hz(unsigned long from_t
 		ADD_LIMITED(tx_cells,(GET(TACP_TCCL) & 0xff) |
 		    ((GET(TACP_TCC) & 0xff) << 8) |
 		    ((GET(TACP_TCCM) & 7) << 16));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (from_timer) mod_timer(&poll_timer,jiffies+HZ);
 }
diff -u -p a/atm/idt77105.c b/atm/idt77105.c
--- a/atm/idt77105.c
+++ b/atm/idt77105.c
@@ -88,6 +88,11 @@ static void idt77105_stats_timer_func(un
 	struct idt77105_stats *stats;
 
         DPRINTK("IDT77105 gathering statistics\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (walk = idt77105_all; walk; walk = walk->next) {
 		dev = walk->dev;
                 
@@ -96,7 +101,13 @@ static void idt77105_stats_timer_func(un
                 stats->tx_cells += get_counter(dev, IDT77105_CTRSEL_TCC);
                 stats->rx_cells += get_counter(dev, IDT77105_CTRSEL_RCC);
                 stats->rx_hec_errors += get_counter(dev, IDT77105_CTRSEL_RHEC);
-	}
+                if (_cur < timeout) {
+                	rdstcll(_cur);
+                }
+                else {
+                	break;
+                }
+        }
         if (!start_timer) mod_timer(&stats_timer,jiffies+IDT77105_STATS_TIMER_PERIOD);
 }
 
@@ -117,6 +128,11 @@ static void idt77105_restart_timer_func(
         unsigned char istat;
 
         DPRINTK("IDT77105 checking for cable re-insertion\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (walk = idt77105_all; walk; walk = walk->next) {
 		dev = walk->dev;
                 
@@ -134,7 +150,13 @@ static void idt77105_restart_timer_func(
                     /* re-enable interrupts */
 	            PUT( walk->old_mcr ,MCR);
                 }
-	}
+                if (_cur < timeout) {
+	            rdstcll(_cur);
+                }
+                else {
+	            break;
+                }
+        }
         if (!start_timer) mod_timer(&restart_timer,jiffies+IDT77105_RESTART_TIMER_PERIOD);
 }
 
diff -u -p a/atm/firestream.c b/atm/firestream.c
--- a/atm/firestream.c
+++ b/atm/firestream.c
@@ -1962,6 +1962,11 @@ static void __devexit firestream_remove_
 	}
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = fs_boards;dev != NULL;dev=nxtdev) {
 		fs_dprintk (FS_DEBUG_CLEANUP, "Releasing resources for dev at %p.\n", dev);
 
@@ -1981,6 +1986,11 @@ static void __devexit firestream_remove_
 		/* XXX Wait a while for the chip to release all buffers. */
 
 		for (i=0;i < FS_NR_FREE_POOLS;i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (fp=bus_to_virt (read_fs (dev, FP_SA(dev->rx_fp[i].offset)));
 			     !(fp->flags & FP_FLAGS_EPI);fp = nxt) {
 				fs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p\n", fp->skb);
@@ -1988,6 +1998,12 @@ static void __devexit firestream_remove_
 				nxt = bus_to_virt (fp->next);
 				fs_dprintk (FS_DEBUG_ALLOC, "Free rec-d: %p\n", fp);
 				kfree (fp);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			fs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p\n", fp->skb);
 			dev_kfree_skb_any (fp->skb);
@@ -2022,6 +2038,12 @@ static void __devexit firestream_remove_
 		fs_dprintk (FS_DEBUG_ALLOC, "Free fs-dev: %p\n", dev);
 		nxtdev = dev->next;
 		kfree (dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	func_exit ();
diff -u -p a/atm/solos-pci.c b/atm/solos-pci.c
--- a/atm/solos-pci.c
+++ b/atm/solos-pci.c
@@ -588,6 +588,11 @@ static int flash_upgrade(struct solos_ca
 	iowrite32(1, card->config_regs + WRITE_FLASH);
 	wait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < fw->size; offset += blocksize) {
 		int i;
 
@@ -611,6 +616,12 @@ static int flash_upgrade(struct solos_ca
 		iowrite32(offset / blocksize, card->config_regs + FLASH_BLOCK);
 		iowrite32(1, card->config_regs + WRITE_FLASH);
 		wait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	release_firmware(fw);
