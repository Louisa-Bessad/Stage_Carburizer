
--
 	while (len > 0) {

 	while (idx < count) {
 		addr = off + idx;
 		len = W1_PAGE_SIZE - (addr & W1_PAGE_MASK);
@@ -248,6 +253,12 @@ static ssize_t w1_f23_write_bin(struct f
 			goto out_up;
 		}
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		reg_val = __raw_readb(dev->regs + MXC_W1_CONTROL);
 
 		if (((reg_val >> 7) & 0x1) == 0 ||
@@ -74,6 +79,12 @@ static u8 mxc_w1_ds2_reset_bus(void *dat
 			timeout_cnt++;
--
 		while (((*status = hdq_reg_in(hdq_data, offset)) & flag)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (!((*status = hdq_reg_in(hdq_data, offset)) & flag)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (!(hdq_data->hdq_irqstatus
 			& OMAP_HDQ_INT_STATUS_RXCOMPLETE)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+					rdstcll(_cur);
--
-	while (itr_size >= sizeof(*hdr)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (itr_size >= sizeof(*hdr)) {
 		hdr = (struct usb_descriptor_header *) itr;
 		dev_dbg(dev, "Extra device descriptor: "
 			"type %02x/%u bytes @ %zu (%zu left)\n",
@@ -763,6 +768,12 @@ static int hwarc_get_version(struct uwb_
 			goto found;
--
 	while (hdr) {
 		next = hdr->next;
 		kfree(hdr);
 		hdr = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (data_itr < data_top) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (data_itr < data_top) {
 		result = -ENOMEM;
 		hdr = kmalloc(sizeof(*hdr), GFP_KERNEL);
 		if (hdr == NULL) {
@@ -138,6 +154,12 @@ int fw_hdrs_load(struct i1480 *i1480, st
 		*prev_hdr = hdr;
--
 	while (size > 0) {
 		chunk_size = size < i1480->buf_size ? size : i1480->buf_size;
 		result = i1480->read(i1480, hdr->address + src_itr, chunk_size);
@@ -194,6 +221,12 @@ ssize_t i1480_fw_cmp(struct i1480 *i1480
 		}
 		src_itr += result;
--
 	while (itr < top) {
 		val <<= 8;
 		val |= array[top - 1];
 		top--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (itr < buffer_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (itr < buffer_size) {
 		len = buffer_size - itr >= sizeof(val) ?
 			sizeof(val) : buffer_size - itr;
 		val = get_val(buffer, itr, len);
 		bmp_itr[itr / sizeof(val)] = val;
 		itr += sizeof(val);
--
-			while(mycustomttable[i].chipID != 0) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while(mycustomttable[i].chipID != 0) {
 				printk(KERN_WARNING "\t\"%s\" (for %s %s)\n",
 					mycustomttable[i].optionName,
 					mycustomttable[i].vendorName,
 					mycustomttable[i].cardName);
 				i++;
--
 	while(pohThis != &memheap->oh_free) {
 		if(pohThis->offset == ulUpper) {
 			poh_next = pohThis;
@@ -3354,6 +3370,12 @@ sisfb_poh_free(struct SIS_HEAP *memheap,
 			poh_prev = pohThis;
 		}
--
 				while((p2_01 <= 0) || (p2_02 <= 0)) {
 					p2_01 += 2;
 					p2_02 += 2;
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
--
 	while((this_opt = strsep(&options, ",")) != NULL) {
 
 		if(!(*this_opt)) continue;
@@ -4055,6 +4093,12 @@ static int __init sisfb_setup(char *opti
 			printk(KERN_INFO "sisfb: Invalid option %s\n", this_opt);
 		}
--
    while(delay--) {
       SiS_GenericDelay(SiS_Pr, 6623);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
--
    while(delay--) {
       SiS_GenericDelay(SiS_Pr, 66);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
--
   while(*dataptr) {
      dataptr = SiS_SetTrumpBlockLoop(SiS_Pr, dataptr);
      if(!dataptr) return false;
+     if (_cur < timeout) {
+       rdstcll(_cur);
+     }
--
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
 		else
 			fb_mode = opt;
+			if (_cur < timeout) {
--
     while ((this_opt = strsep(&options, ",")) != NULL) {
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
--
 	while (i--) {
 		WAIT_FIFO(p, 3);
 		pm2_WR(p, PM2R_RD_PALETTE_DATA, 0);
 		pm2_WR(p, PM2R_RD_PALETTE_DATA, 0);
 		pm2_WR(p, PM2R_RD_PALETTE_DATA, 0);
+		if (_cur < timeout) {
--
 	while (height--) {
 		int width = ((image->width + 7) >> 3)
 				+ info->pixmap.scan_align - 1;
 		width >>= 2;
 		WAIT_FIFO(par, width);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (width--) {
 			pm2_WR(par, PM2R_BIT_MASK_PATTERN, *src);
 			src++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 		while (pos < (1024 + PM2VI_RD_CURSOR_PATTERN)) {
 			pm2_WR(par, PM2VR_RD_INDEX_HIGH, pos >> 8);
 			pm2v_RDAC_WR(par, pos++, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -1801,6 +1850,12 @@ static int __init pm2fb_setup(char *opti
 			noaccel = 1;
 		else
--
 	while (width >= 32) {
 		const u8 *next_data = data + 4;
 
@@ -601,6 +606,12 @@ static void ffb_imageblit(struct fb_info
 
 		data = next_data;
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "vmode:", 6)) {
 	    		int vmode = simple_strtoul(this_opt+6, NULL, 0);
@@ -582,6 +587,12 @@ int __init valkyriefb_setup(char *option
 				break;
 			}
--
-		while (tmio_ioread16(par->lcr + LCR_CCS) > ccs) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (tmio_ioread16(par->lcr + LCR_CCS) > ccs) {
 			udelay(1);
 			i++;
 			if (i > 10000) {
@@ -374,6 +379,12 @@ tmiofb_acc_wait(struct fb_info *info, un
 				return -ETIMEDOUT;
--
 	while (tmio_ioread16(par->lcr + LCR_BBES) & 2) { /* blit active */
 		udelay(1);
 		i++ ;
@@ -428,6 +444,12 @@ static int tmiofb_sync(struct fb_info *f
 			printk(KERN_ERR "timeout waiting for blit to end!\n");
 			return -ETIMEDOUT;
--
-	while ((this_opt = strsep(&options, ",")) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
 		/*
 		 * FIXME
 		 */
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "monitor:", 8)) {
 			if (!strncmp(this_opt + 8, "crt", 3))
@@ -738,6 +743,12 @@ int __init sgivwfb_setup(char *options)
 			else if (!strncmp(this_opt + 8, "1600sw", 6))
 				flatpanel_id = FLATPANEL_SGI_1600SW;
--
-		while (n--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (n--) {
 			if (p->fix.visual == FB_VISUAL_TRUECOLOR ||
 			    p->fix.visual == FB_VISUAL_DIRECTCOLOR )
 				color = palette[*src];
@@ -90,6 +95,12 @@ static void color_imageblit(const struct
 			shift += bpp;
--
 		while (j--) {
 			l--;
 			color = (*s & (1 << l)) ? fgcolor : bgcolor;
@@ -153,7 +169,13 @@ static void slow_imageblit(const struct
 			shift += bpp;
 			shift &= (32 - 1);
--
 		while ((lcd->intstatus & LCD_INT_SS) == 0) {
 			au_sync();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while ((this_opt = strsep(&options,",")) != NULL) {
 			/* Panel option - can be panel name,
 			 * "bs" for board-switch, or number/index */
@@ -1830,6 +1846,12 @@ static int au1200fb_setup(void)
 			else {
 				print_warn("Unsupported option \"%s\"", this_opt);
--
 	while ((opt = strsep(&options, ",")) != NULL) {
 
 		if (!*opt)
@@ -1527,6 +1532,12 @@ static int  __init s3fb_setup(char *opti
 			fasttext = simple_strtoul(opt + 9, NULL, 0);
 		else
--
 	while (!kthread_should_stop()) {
 		try_to_freeze();
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -908,6 +913,12 @@ static int ps3fbd(void *arg)
 			console_unlock();
 		}
--
-			while (height--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (height--) {
 #if defined(__BIG_ENDIAN)
 				fb_writel((*chardata) << 24, mmio.vaddr);
 #else
 				fb_writel(*chardata, mmio.vaddr);
 #endif
--
-			while (height--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (height--) {
 #if defined(__BIG_ENDIAN)
 				fb_writel((*(u_int16_t*)chardata) << 16, mmio.vaddr);
 #else
 				fb_writel(*(u_int16_t*)chardata, mmio.vaddr);
 #endif
--
 			while (height--) {
 				size_t i;
 				
@@ -487,6 +514,12 @@ static void matroxfb_1bpp_imageblit(stru
 					fb_writel(get_unaligned((u_int32_t*)(chardata + i)),mmio.vaddr);
 				}
--
 			while ((nl = mga_inl(0x3C48) & 0xFFF) >= lastl) {
 				lastl = nl;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 	while (divider & 3) {
 		hd >>= 1;
 		hs >>= 1;
 		he >>= 1;
 		ht >>= 1;
 		divider <<= 1;
--
 	while (divider > 8) {
 		hd <<= 1;
 		hs <<= 1;
 		he <<= 1;
 		ht <<= 1;
 		divider >>= 1;
--
 			while (m1) {
 				int t;
 
@@ -598,6 +603,12 @@ static int matroxfb_decode_var(const str
 				t = m1;
 				m1 = m2;
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt) continue;
 
@@ -2424,6 +2440,12 @@ static int __init matroxfb_setup(char *o
 				strlcpy(videomode, this_opt, sizeof(videomode));
 			}
--
 		while (p && (tvco > vcomax)) {
 			p--;
 			tvco >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (sptr >= sarray) {
 			unsigned int mnp = *sptr--;
 		
@@ -291,6 +307,12 @@ static inline unsigned int g450_findwork
 				mnpfound = mnp;
 				found = 1;
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -2366,6 +2371,12 @@ static int __init cirrusfb_setup(char *o
 			mode_option = this_opt + 5;
 		else
--
 	while (name != NULL) {
 		reg = va_arg(list, int);
 
@@ -2867,6 +2883,12 @@ static void cirrusfb_dbg_print_regs(stru
 		dev_dbg(info->device, "%8s = 0x%02X\n", name, val);
 
--
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
@@ -1512,6 +1517,12 @@ static int cyber2000fb_setup(char *optio
 		}
 
--
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -1046,6 +1051,12 @@ static int __init pvr2fb_setup(char *opt
 		} else {
 			mode_option = this_opt;
--
 		while (n >= 8) {
 			*dst++ = pat;
 			*dst++ = pat;
@@ -60,6 +65,12 @@ bitfill_aligned(struct fb_info *p, unsig
 			*dst++ = pat;
 			*dst++ = pat;
--
 		while (n--)
 			*dst++ = pat;
@@ -106,6 +117,11 @@ bitfill_unaligned(struct fb_info *p, uns
 
 		/* Main chunk */
 		n /= bits;
--
 		while (n >= 4) {
 			*dst++ = pat;
 			pat = pat << left | pat >> right;
@@ -116,10 +132,27 @@ bitfill_unaligned(struct fb_info *p, uns
 			*dst++ = pat;
 			pat = pat << left | pat >> right;
--
 		while (n--) {
 			*dst++ = pat;
 			pat = pat << left | pat >> right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (n >= 8) {
 			*dst++ ^= val;
 			*dst++ ^= val;
@@ -170,6 +208,12 @@ bitfill_aligned_rev(struct fb_info *p, u
 			*dst++ ^= val;
 			*dst++ ^= val;
--
 		while (n--)
 			*dst++ ^= val;
@@ -218,6 +262,11 @@ bitfill_unaligned_rev(struct fb_info *p,
 
 		/* Main chunk */
 		n /= bits;
--
 		while (n >= 4) {
 			*dst++ ^= pat;
 			pat = pat << left | pat >> right;
@@ -228,10 +277,27 @@ bitfill_unaligned_rev(struct fb_info *p,
 			*dst++ ^= pat;
 			pat = pat << left | pat >> right;
--
 		while (n--) {
 			*dst ^= pat;
 			pat = pat << left | pat >> right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (height--) {
 			dst += dst_idx >> (ffs(bits) - 1);
 			dst_idx &= (bits - 1);
 			fill_op32(p, dst, dst_idx, pat, width*bpp, bits);
 			dst_idx += p->fix.line_length*8;
+			if (_cur < timeout) {
--
 		while (height--) {
 			dst += dst_idx / bits;
 			dst_idx &= (bits - 1);
@@ -324,6 +406,12 @@ void sys_fillrect(struct fb_info *p, con
 			fill_op(p, dst, dst_idx, pat2, left, right,
 				width*bpp, bits);
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "monitor:", 8)) {
 			if (!strncmp(this_opt + 8, "crt", 3)) {
@@ -1125,6 +1130,12 @@ static int __devinit gbefb_setup(char *o
 				gbe_mem_size = TILE_SIZE;
 		} else
--
 	while (!kthread_should_stop()) {
 
 		if (try_to_freeze())
@@ -1282,6 +1287,12 @@ static int pxafb_smart_thread(void *arg)
 
 		set_current_state(TASK_INTERRUPTIBLE);
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		ret = parse_opt(dev, this_opt);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (next) {
 		next = false;
 		for (i = 0; i < ARRAY_SIZE(device_mapping); i++) {
@@ -929,6 +934,12 @@ u32 via_parse_odev(char *input, char **e
 				}
 			}
--
-		while (!(readl(engine + VIA_REG_STATUS) &
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!(readl(engine + VIA_REG_STATUS) &
 				VIA_VR_QUEUE_BUSY) && (loop < MAXLOOP)) {
 			loop++;
 			cpu_relax();
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while ((readl(engine + VIA_REG_STATUS) & mask) && (loop < MAXLOOP)) {
 		loop++;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (regset->regnum != VGA_REGSET_END_VAL) {
 		regval = vga_rcrt(regbase, regset->regnum);
 		bitnum = regset->lowbit;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (bitnum <= regset->highbit) {
 			bitval = 1 << bitnum;
 			regval = regval & ~bitval;
 			if (value & 1) regval = regval | bitval;
 			bitnum ++;
 			value = value >> 1;
--
 	while (regset->regnum != VGA_REGSET_END_VAL) {
 		regval = vga_rseq(regbase, regset->regnum);
 		bitnum = regset->lowbit;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (bitnum <= regset->highbit) {
 			bitval = 1 << bitnum;
 			regval = regval & ~bitval;
 			if (value & 1) regval = regval | bitval;
 			bitnum ++;
 			value = value >> 1;
--
 	while (regset->regnum != VGA_REGSET_END_VAL) {
 		count += regset->highbit - regset->lowbit + 1;
 		regset ++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((ar > pll->r_min) && (f_vco > pll->f_vco_max)) {
 		ar--;
 		f_vco = f_vco >> 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((am <= pll->m_max) && (an <= pll->n_max)) {
 		f_current = (pll->f_base * am) / an;
 		delta_current = abs_diff (f_current, f_vco);
@@ -427,6 +498,12 @@ int svga_compute_pll(const struct svga_p
 		} else {
 			an ++;
--
 	while (frm->bits_per_pixel != SVGA_FORMAT_END_VAL)
 	{
 		if ((var->bits_per_pixel == frm->bits_per_pixel) &&
@@ -617,6 +699,12 @@ static inline int match_format(const str
 			stored = i;
 		i++;
--
-			while (i < priv->used_meram_cache_regions - 1) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (i < priv->used_meram_cache_regions - 1) {
 				priv->used_meram_cache[i] =
 					priv->used_meram_cache[i + 1] ;
 				i++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (n > 1) {
 		u16 v;
 		if (__get_user(v, src))
@@ -348,6 +353,12 @@ static inline unsigned long copy_from_us
 
 		src++, dst++;
--
 	while (n > 1) {
 		u16 v = fb_readw(src);
 
@@ -378,6 +394,12 @@ static inline unsigned long copy_to_user
 
 		src++, dst++;
--
 	while (n > 1) {
 		fb_writew(0, dst);
 		dst++, n -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (actual_count--) {
 		lv =	 ((lv << 1) |
 			(((lv >> 15) ^ (lv >> 4) ^ (lv >> 2) ^ (lv >> 1)) & 1))
 			& 0xFFFF;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (size > 0) {
 		page = vmalloc_to_pfn((void *)pos);
 		if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))
@@ -342,6 +358,12 @@ static int dlfb_ops_mmap(struct fb_info
 			size -= PAGE_SIZE;
 		else
--
 	while ((pixel_end > pixel) &&
 	       (cmd_buffer_end - MIN_RLX_CMD_BYTES > cmd)) {
 		uint8_t *raw_pixels_count_byte = 0;
@@ -455,6 +482,11 @@ static void dlfb_compress_hline(
 
 		prefetch_range((void *) pixel, (cmd_pixel_end - pixel) * bpp);
--
 		while (pixel < cmd_pixel_end) {
 			const uint16_t * const repeating_pixel = pixel;
 
@@ -468,9 +500,20 @@ static void dlfb_compress_hline(
 				*raw_pixels_count_byte = ((repeating_pixel -
 						raw_pixel_start) + 1) & 0xFF;
--
 				while ((pixel < cmd_pixel_end)
 				       && (*pixel == *repeating_pixel)) {
 					pixel++;
+					if (_cur < timeout) {
+									rdstcll(_cur);
+					}
--
-	while (next_pixel < line_end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (next_pixel < line_end) {
 
 		dlfb_compress_hline((const uint16_t **) &next_pixel,
 			     (const uint16_t *) line_end, &dev_addr,
@@ -562,6 +622,12 @@ static int dlfb_render_hline(struct dlfb
 			cmd = urb->transfer_buffer;
--
 		while (desc < desc_end) {
 			u8 length;
 			u16 key;
@@ -1555,6 +1626,12 @@ static int dlfb_parse_vendor_descriptor(
 				break;
 			}
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "vmode:", 6)) {
 	    		int vmode = simple_strtoul(this_opt+6, NULL, 0);
@@ -521,6 +526,12 @@ static int __init platinumfb_setup(char
 			    break;
 			}
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -2226,6 +2231,12 @@ static int __init neofb_setup(char *opti
 			libretto = 1;
 		else
--
 		while (n >= 8) {
 			FB_WRITEL(pat, dst++);
 			FB_WRITEL(pat, dst++);
@@ -70,6 +75,12 @@ bitfill_aligned(struct fb_info *p, unsig
 			FB_WRITEL(pat, dst++);
 			FB_WRITEL(pat, dst++);
--
 		while (n--)
 			FB_WRITEL(pat, dst++);
@@ -117,6 +128,11 @@ bitfill_unaligned(struct fb_info *p, uns
 
 		// Main chunk
 		n /= bits;
--
 		while (n >= 4) {
 			FB_WRITEL(pat, dst++);
 			pat = pat << left | pat >> right;
@@ -127,10 +143,27 @@ bitfill_unaligned(struct fb_info *p, uns
 			FB_WRITEL(pat, dst++);
 			pat = pat << left | pat >> right;
--
 		while (n--) {
 			FB_WRITEL(pat, dst++);
 			pat = pat << left | pat >> right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (n >= 8) {
 			FB_WRITEL(FB_READL(dst) ^ val, dst);
 			dst++;
@@ -192,10 +230,27 @@ bitfill_aligned_rev(struct fb_info *p, u
 			FB_WRITEL(FB_READL(dst) ^ val, dst);
 			dst++;
--
 		while (n--) {
 			FB_WRITEL(FB_READL(dst) ^ val, dst);
 			dst++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (n >= 4) {
 			FB_WRITEL(FB_READL(dst) ^ pat, dst);
 			dst++;
@@ -260,11 +320,28 @@ bitfill_unaligned_rev(struct fb_info *p,
 			dst++;
 			pat = pat << left | pat >> right;
--
 		while (n--) {
 			FB_WRITEL(FB_READL(dst) ^ pat, dst);
 			dst++;
 			pat = pat << left | pat >> right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-		while (height--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (height--) {
 			dst += dst_idx >> (ffs(bits) - 1);
 			dst_idx &= (bits - 1);
 			fill_op32(p, dst, dst_idx, pat, width*bpp, bits,
 				  bswapmask);
 			dst_idx += p->fix.line_length*8;
--
 		while (height--) {
 			dst += dst_idx / bits;
 			dst_idx &= (bits - 1);
@@ -360,6 +453,12 @@ void cfb_fillrect(struct fb_info *p, con
 			fill_op(p, dst, dst_idx, pat2, left, right,
 				width*bpp, bits);
--
 	while (t_inb(par, STATUS) & 0x80) {
 		count++;
 		if (count == 10000000) {
@@ -302,6 +307,12 @@ static void xp_wait_engine(struct triden
 			}
 		}
--
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
@@ -1628,6 +1644,12 @@ static int __init tridentfb_setup(char *
 			nativex = simple_strtoul(opt + 8, NULL, 0);
 		else
--
 	while (left <= right) {
 		val = 0;
 		for (i = 0; i < 8; i++) {
@@ -287,6 +292,12 @@ static void arcfb_lcd_update_page(struct
 			bitmask <<= 1;
 			rightshift++;
--
 	while (distance > 0) {
 		distance -= 8;
 		arcfb_lcd_update_page(par, upper, left, right, 8);
 		upper = lower + 1;
 		lower = upper + 7;
+		if (_cur < timeout) {
--
 	while (distance > 0) {
 		distance -= ((lower - upper) + 1 );
 		arcfb_lcd_update_vert(par, upper, lower, left, right);
 		upper = lower + 1;
 		lower = min(upper + distance - 1, ceil64(upper));
+		if (_cur < timeout) {
--
 	while (distance > 0) {
 		arcfb_lcd_update_horiz(par, left, right, y, h);
 		distance -= ((right - left) + 1);
 		left = right + 1;
 		right = min(left + distance - 1, ceil64(left));
+		if (_cur < timeout) {
--
 		while (p < buf + len) {
 			int found;
 			if (num_ovls == OMAPFB_MAX_OVL_PER_FB) {
@@ -241,6 +246,12 @@ static ssize_t store_overlays(struct dev
 				ovls[num_ovls++] = fbdev->overlays[ovlnum];
 
--
 		while (p < buf + len) {
 			int rot;
 
@@ -395,6 +411,12 @@ static ssize_t store_overlays_rotate(str
 			rotation[num_ovls++] = rot;
 
--
-	while (!gpio_get_value(picodlp_pdata->emu_done_gpio)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!gpio_get_value(picodlp_pdata->emu_done_gpio)) {
 		if (!trial--) {
 			dev_err(&dssdev->dev, "emu_done signal not"
 						" going high\n");
 			return -ETIMEDOUT;
 		}
--
 	while (dss_read_reg(DSS_SDI_STATUS) & (1 << 6)) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("PLL lock request timed out\n");
 			goto err1;
 		}
+		if (_cur < timeout) {
--
 	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 5))) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("PLL lock timed out\n");
 			goto err1;
 		}
+		if (_cur < timeout) {
--
 	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 2))) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("SDI reset timed out\n");
 			goto err2;
 		}
+		if (_cur < timeout) {
--
 	while ((attr = display_sysfs_attrs[i++]) != NULL) {
 		r = device_create_file(&dssdev->dev, attr);
 		if (r)
 			DSSERR("failed to create sysfs file\n");
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while ((dssdev = omap_dss_get_next_device(dssdev)) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while ((dssdev = omap_dss_get_next_device(dssdev)) != NULL) {
 		if (match(dssdev, data))
 			return dssdev;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (REG_GET(dsidev, idx, bitnum, bitnum) != value) {
 		if (--t == 0)
 			return !value;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-	while (FLD_GET(dsi_read_reg(dsidev, DSI_CLK_CTRL), 29, 28) != state) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (FLD_GET(dsi_read_reg(dsidev, DSI_CLK_CTRL), 29, 28) != state) {
 		if (++t > 1000) {
 			DSSERR("Failed to set DSI PLL power mode to %d\n",
 					state);
 			return -ENODEV;
 		}
--
-	while (FLD_GET(dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1),
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (FLD_GET(dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1),
 			26, 25) != state) {
 		if (++t > 1000) {
 			DSSERR("failed to set complexio power state to "
@@ -2024,6 +2051,12 @@ static int dsi_cio_power(struct platform
 			return -ENODEV;
--
 	while (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {
 		u32 val;
 		val = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));
@@ -2826,6 +2864,12 @@ static void dsi_vc_flush_long_data(struc
 				(val >> 8) & 0xff,
 				(val >> 16) & 0xff,
--
 	while (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {
 		u32 val;
 		u8 dt;
@@ -2892,6 +2941,12 @@ static u16 dsi_vc_flush_receive_data(str
 		} else {
 			DSSERR("\tunknown datatype 0x%02x\n", dt);
--
-	while (!list_empty(&manager_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&manager_list)) {
 		mgr = list_first_entry(&manager_list,
 				struct omap_overlay_manager, list);
 		list_del(&mgr->list);
 		kobject_del(&mgr->kobj);
 		kobject_put(&mgr->kobj);
--
 	while (venc_read_reg(VENC_F_CONTROL) & (1<<8)) {
 		if (--t == 0) {
 			DSSERR("Failed to reset venc\n");
 			return;
 		}
+		if (_cur < timeout) {
--
 	while (val != REG_GET(base_addr, idx, b2, b1)) {
 		udelay(1);
 		if (t++ > 10000)
 			return !val;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (REG_GET(base, HDMI_CORE_DDC_STATUS, 2, 2) == 1) {
 			if (t++ > 10000) {
 				DSSERR("timeout reading edid\n");
 				return -ETIMEDOUT;
 			}
 			udelay(1);
--
-	while (!list_empty(&overlay_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&overlay_list)) {
 		ovl = list_first_entry(&overlay_list,
 				struct omap_overlay, list);
 		list_del(&ovl->list);
 		kobject_del(&ovl->kobj);
 		kobject_put(&ovl->kobj);
--
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
@@ -1709,6 +1714,12 @@ static int __init fsl_diu_setup(char *op
 				default_bpp = val;
 		} else
--
 			while (n >= 8) {
 				*dst++ = *src++;
 				*dst++ = *src++;
@@ -64,6 +69,12 @@ bitcpy(struct fb_info *p, unsigned long
 				*dst++ = *src++;
 				*dst++ = *src++;
--
 			while (n--)
 				*dst++ = *src++;
@@ -124,6 +135,11 @@ bitcpy(struct fb_info *p, unsigned long
 			/* Main chunk */
 			m = n % bits;
 			n /= bits;
--
 			while (n >= 4) {
 				d1 = *src++;
 				*dst++ = d0 << left | d1 >> right;
@@ -138,11 +154,28 @@ bitcpy(struct fb_info *p, unsigned long
 				*dst++ = d0 << left | d1 >> right;
 				d0 = d1;
--
 			while (n--) {
 				d1 = *src++;
 				*dst++ = d0 << left | d1 >> right;
 				d0 = d1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (n >= 8) {
 				*dst-- = *src--;
 				*dst-- = *src--;
@@ -218,6 +256,12 @@ bitcpy_rev(struct fb_info *p, unsigned l
 				*dst-- = *src--;
 				*dst-- = *src--;
--
 			while (n--)
 				*dst-- = *src--;
@@ -275,6 +319,11 @@ bitcpy_rev(struct fb_info *p, unsigned l
 			/* Main chunk */
 			m = n % bits;
 			n /= bits;
--
 			while (n >= 4) {
 				d1 = *src--;
 				*dst-- = d0 >> right | d1 << left;
@@ -289,11 +338,28 @@ bitcpy_rev(struct fb_info *p, unsigned l
 				*dst-- = d0 >> right | d1 << left;
 				d0 = d1;
--
 			while (n--) {
 				d1 = *src--;
 				*dst-- = d0 >> right | d1 << left;
 				d0 = d1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 		while (height--) {
 			dst_idx -= bits_per_line;
 			src_idx -= bits_per_line;
@@ -354,8 +425,19 @@ void sys_copyarea(struct fb_info *p, con
 			src_idx &= (bytes - 1);
 			bitcpy_rev(p, dst, dst_idx, src, src_idx, bits,
--
 		while (height--) {
 			dst += dst_idx >> (ffs(bits) - 1);
 			dst_idx &= (bytes - 1);
@@ -365,6 +447,12 @@ void sys_copyarea(struct fb_info *p, con
 				width*p->var.bits_per_pixel);
 			dst_idx += bits_per_line;
--
 	while (running) {
 		next = running->next;
 		running->next = priv->free;
 		priv->free = running;
 		running = next;
+		if (_cur < timeout) {
--
 	while (ready) {
 		shared->buffer[num++] = 0x00000001;
 		shared->buffer[num++] = ready->phys;
 		ready = ready->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (buffer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (buffer) {
 		next = buffer->next;
 
 		dma_free_coherent(&dev->dev, PXA3XX_GCU_BATCH_WORDS * 4,
@@ -572,6 +599,12 @@ free_buffers(struct platform_device *dev
 		kfree(buffer);
--
 	while (size > 0) {
 		SetPageReserved(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
 		size -= PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((long) size > 0) {
 		ClearPageReserved(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
 		size -= PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (size > 0) {
 		page = vmalloc_to_pfn((void *)pos);
 		if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED)) {
@@ -437,6 +464,12 @@ static int vfb_mmap(struct fb_info *info
 			size -= PAGE_SIZE;
 		else
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
 		/* Test disable for backwards compatibility */
 		if (!strcmp(this_opt, "disable"))
 			vfb_enable = 0;
--
 	while (len >= 4) {
 		sossi_write_reg(SOSSI_FIFO_REG, *(const u32 *) data);
 		len -= 4;
 		data += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len >= 2) {
 		sossi_write_reg16(SOSSI_FIFO_REG, *(const u16 *) data);
 		len -= 2;
 		data += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len) {
 		sossi_write_reg8(SOSSI_FIFO_REG, *(const u8 *) data);
 		len--;
 		data++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len >= 4) {
 		*(u32 *) data = sossi_read_reg(SOSSI_FIFO_REG);
 		len -= 4;
 		data += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len >= 2) {
 		*(u16 *) data = sossi_read_reg16(SOSSI_FIFO_REG);
 		len -= 2;
 		data += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len) {
 		*(u8 *) data = sossi_read_reg8(SOSSI_FIFO_REG);
 		len--;
 		data++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (size < PAGE_SIZE && plane < OMAPFB_PLANE_NUM) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size < PAGE_SIZE && plane < OMAPFB_PLANE_NUM) {
 		omapfb_get_caps(fbdev, plane, &caps);
 		size += snprintf(&buf[size], PAGE_SIZE - size,
 			"plane#%d %#010x %#010x %#010x\n",
 			plane, caps.ctrl, caps.plane_color, caps.wnd_color);
 		plane++;
--
-	while (size < PAGE_SIZE && plane < OMAPFB_PLANE_NUM) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size < PAGE_SIZE && plane < OMAPFB_PLANE_NUM) {
 		omapfb_get_caps(fbdev, plane, &caps);
 		size += snprintf(&buf[size], PAGE_SIZE - size,
 				 "plane#%d:\n", plane);
@@ -1355,6 +1371,12 @@ static ssize_t omapfb_show_caps_text(str
 		}
--
 	while (!r && (this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "accel", 5))
 			def_accel = 1;
@@ -1957,6 +1984,12 @@ static int __init omapfb_setup(char *opt
 			pr_debug("omapfb: invalid option\n");
 			r = -1;
--
 		while (!(dispc_read_reg(DISPC_SYSSTATUS) & 1)) {
 			if (!--tmo) {
 				dev_err(dispc.fbdev->dev, "soft reset failed\n");
@@ -1423,6 +1428,12 @@ static int omap_dispc_init(struct omapfb
 				enable_digit_clocks(0);
 				goto fail1;
--
-	while (!list_empty(&hwa742.pending_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&hwa742.pending_req_list)) {
 		struct hwa742_request *req;
 		void (*complete)(void *);
 		void *complete_data;
@@ -302,6 +307,12 @@ static void process_pending_requests(voi
 			complete(complete_data);
--
-	while (!list_empty(&blizzard.pending_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&blizzard.pending_req_list)) {
 		struct blizzard_request *req;
 		void (*complete)(void *);
 		void *complete_data;
@@ -430,6 +435,12 @@ static void process_pending_requests(voi
 			complete(complete_data);
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt) continue;
 		
@@ -222,6 +227,12 @@ static int __init vesafb_setup(char *opt
 			vram_total = simple_strtoul(this_opt+7, NULL, 0);
 		else if (! strncmp(this_opt, "vremap:", 7))
--
 	while ((this_opt = strsep(&options, " ")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -323,6 +328,12 @@ static int __init grvga_parse_custom(cha
 		default:
 			return -1;
--
 		while (width >= 32) {
 			u32 val;
 
@@ -440,6 +445,12 @@ static void cg6_imageblit(struct fb_info
 			data += 4;
 			x += 32;
--
 	while (count != 0)
 	{
 		vga_wseq(par->state.vgabase, 0x1C, regval | (code[0] & 4 ? 0x80 : 0));
 		code[1] = vga_r(par->state.vgabase, dac_regs[code[0] & 3]);
 		count--;
 		code += 2;
--
 	while (count != 0)
 	{
 		vga_wseq(par->state.vgabase, 0x1C, regval | (code[0] & 4 ? 0x80 : 0));
 		vga_w(par->state.vgabase, dac_regs[code[0] & 3], code[1]);
 		count--;
 		code += 2;
--
 	while (i++ < 500) {
 		status = ufx_reg_read(dev, 0x0000, &tmp);
 		check_warn_return(status, "error reading 0x0000");
 
 		if (all_bits_set(tmp, 0xC0000000))
 			return 0;
--
 	while (size > 0) {
 		page = vmalloc_to_pfn((void *)pos);
 		if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))
@@ -801,6 +817,12 @@ static int ufx_ops_mmap(struct fb_info *
 			size -= PAGE_SIZE;
 		else
--
 	while (start_line < height) {
 		struct urb *urb = ufx_get_urb(dev);
 		if (!urb) {
@@ -885,6 +912,12 @@ int ufx_handle_damage(struct ufx_data *d
 		check_warn_return(status, "Error submitting URB");
 
--
-	while (bytecount) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (bytecount) {
 		cur_addr = wfm_addr + offset;
 		maxlen = roundup(cur_addr, sector_size) - cur_addr;
 		writecount = min(bytecount, maxlen);
@@ -705,6 +710,12 @@ static int broadsheet_write_spiflash(str
 
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "forceCRTC", 9)) {
 			char *p;
@@ -1517,6 +1522,12 @@ static int __devinit nvidiafb_setup(char
 			bpp = simple_strtoul(this_opt+4, NULL, 0);
 		} else
--
 	while (found != 1) {
 		fifo->valid = 1;
 		found = 1;
@@ -374,6 +379,12 @@ static void nv4CalcArbitration(nv4_fifo_
 		data = (int)((vlwm + 15));
 		fifo->video_lwm = data;
--
 	while (found != 1) {
 		fifo->valid = 1;
 		found = 1;
@@ -612,6 +628,12 @@ static void nv10CalcArbitration(nv10_fif
 
 		fifo->video_lwm = 1024;
--
 	while (par->dmaFree < size && --count && !par->lockup) {
 		dmaGet = READ_GET(par);
 
@@ -144,6 +149,12 @@ static void NVDmaWait(struct fb_info *in
 			}
 		} else
--
-	while (dsize >= RECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (dsize >= RECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS) {
 		NVDmaStart(info, par, RECT_EXPAND_TWO_COLOR_DATA(0),
 			   RECT_EXPAND_TWO_COLOR_DATA_MAX_DWORDS);
 
@@ -387,6 +403,12 @@ static void nvidiafb_mono_color_expand(s
 		}
--
 	while (count--) {
 		head = i810_readl(IRING + 4, mmio) & RBUFFER_HEAD_MASK;	
 		if ((tail == head) || 
@@ -71,6 +76,12 @@ static inline int wait_for_space(struct
 		    (tail < head && (head - tail) >= space)) {
 			return 0;	
--
 	while(!((1000000 * p_divisor)/(16 * 24 * target_freq)) && 
 	      p_divisor <= 32) {
 		p_divisor <<= 1;
 		p_target++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (diff_min && mod_min && (n_target < n_target_max)) {
 		f_out = (p_divisor * n_reg * 1000000)/(4 * 24 * m_reg);
 		mod = (p_divisor * n_reg * 1000000) % (4 * 24 * m_reg);
@@ -750,6 +766,12 @@ static void i810_calc_dclk(u32 freq, u32
 			n_best = n_target;
 			m_best = m_target;
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "mtrr", 4))
 			mtrr = 1;
@@ -2002,6 +2029,12 @@ static int __devinit i810fb_setup(char *
 			ddc3 = 3;
 		else
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -1243,6 +1248,12 @@ int __init amifb_setup(char *options)
 			min_fstrt = simple_strtoul(this_opt+7, NULL, 0);
 		else
--
 			while (n >= 8) {
 				*dst++ = *src++;
 				*dst++ = *src++;
@@ -1428,6 +1444,12 @@ static void bitcpy(unsigned long *dst, i
 				*dst++ = *src++;
 				*dst++ = *src++;
--
 			while (n--)
 				*dst++ = *src++;
@@ -1481,6 +1503,11 @@ static void bitcpy(unsigned long *dst, i
 			// Main chunk
 			m = n % BITS_PER_LONG;
 			n /= BITS_PER_LONG;
--
 			while (n >= 4) {
 				d1 = *src++;
 				*dst++ = d0 << left | d1 >> right;
@@ -1495,11 +1522,28 @@ static void bitcpy(unsigned long *dst, i
 				*dst++ = d0 << left | d1 >> right;
 				d0 = d1;
--
 			while (n--) {
 				d1 = *src++;
 				*dst++ = d0 << left | d1 >> right;
 				d0 = d1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (n >= 8) {
 				*dst-- = *src--;
 				*dst-- = *src--;
@@ -1579,6 +1628,12 @@ static void bitcpy_rev(unsigned long *ds
 				*dst-- = *src--;
 				*dst-- = *src--;
--
 			while (n--)
 				*dst-- = *src--;
@@ -1632,6 +1687,11 @@ static void bitcpy_rev(unsigned long *ds
 			// Main chunk
 			m = n % BITS_PER_LONG;
 			n /= BITS_PER_LONG;
--
 			while (n >= 4) {
 				d1 = *src--;
 				*dst-- = d0 >> right | d1 << left;
@@ -1646,11 +1706,28 @@ static void bitcpy_rev(unsigned long *ds
 				*dst-- = d0 >> right | d1 << left;
 				d0 = d1;
--
 			while (n--) {
 				d1 = *src--;
 				*dst-- = d0 >> right | d1 << left;
 				d0 = d1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (n >= 8) {
 				*dst++ = ~*src++;
 				*dst++ = ~*src++;
@@ -1720,6 +1802,12 @@ static void bitcpy_not(unsigned long *ds
 				*dst++ = ~*src++;
 				*dst++ = ~*src++;
--
 			while (n--)
 				*dst++ = ~*src++;
@@ -1773,6 +1861,11 @@ static void bitcpy_not(unsigned long *ds
 			// Main chunk
 			m = n % BITS_PER_LONG;
 			n /= BITS_PER_LONG;
--
 			while (n >= 4) {
 				d1 = ~*src++;
 				*dst++ = d0 << left | d1 >> right;
@@ -1787,11 +1880,28 @@ static void bitcpy_not(unsigned long *ds
 				*dst++ = d0 << left | d1 >> right;
 				d0 = d1;
--
 			while (n--) {
 				d1 = ~*src++;
 				*dst++ = d0 << left | d1 >> right;
 				d0 = d1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 		while (n >= 8) {
 			*dst++ = val;
 			*dst++ = val;
@@ -1856,6 +1971,12 @@ static void bitfill32(unsigned long *dst
 			*dst++ = val;
 			*dst++ = val;
--
 		while (n--)
 			*dst++ = val;
@@ -1902,12 +2023,23 @@ static void bitxor32(unsigned long *dst,
 
 		// Main chunk
 		n /= BITS_PER_LONG;
--
 		while (n >= 4) {
 			*dst++ ^= val;
 			*dst++ ^= val;
 			*dst++ ^= val;
 			*dst++ ^= val;
 			n -= 4;
--
 		while (n--)
 			*dst++ ^= val;
@@ -1975,7 +2107,12 @@ static void amifb_fillrect(struct fb_inf
 		((unsigned long)info->screen_base & ~(BYTES_PER_LONG-1));
 	dst_idx = ((unsigned long)info->screen_base & (BYTES_PER_LONG-1))*8;
 	dst_idx += rect->dy*par->next_line*8+rect->dx;
-	while (height--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		    while (height--) {
 		switch (rect->rop) {
 		    case ROP_COPY:
 			fill_one_line(info->var.bits_per_pixel,
@@ -1989,6 +2126,12 @@ static void amifb_fillrect(struct fb_inf
 			break;
--
 		while (height--) {
 			dst_idx -= par->next_line*8;
 			src_idx -= par->next_line*8;
 			copy_one_line_rev(info->var.bits_per_pixel,
 					  par->next_plane, dst, dst_idx, src,
 					  src_idx, width);
--
-		while (height--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (height--) {
 			copy_one_line(info->var.bits_per_pixel,
 				      par->next_plane, dst, dst_idx, src,
 				      src_idx, width);
 			dst_idx += par->next_line*8;
 			src_idx += par->next_line*8;
--
-		while (height--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (height--) {
 			expand_one_line(info->var.bits_per_pixel,
 					par->next_plane, dst, dst_idx, width,
 					src, image->bg_color,
 					image->fg_color);
 			dst_idx += par->next_line*8;
--
-		while (--words >= 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (--words >= 0) {
 #ifdef __mc68000__
 			asm volatile ("moveql #0,%%d0 ; movew %%d0,%0@(%2:w:2) ; movew %%d0,%0@+"
 				: "=a" (lspr) : "0" (lspr), "d" (delta) : "d0");
@@ -3487,6 +3668,12 @@ static int ami_set_var_cursorinfo(struct
 			*(lspr+delta) = 0;
--
 				while (line >= 512) {
 					(copl++)->l = CWAIT(h_end1, 510);
 					line -= 512;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
--
 					while (line >= 512) {
 						(cops++)->l = CWAIT(h_end1, 510);
 						line -= 512;
+						if (_cur < timeout) {
+					rdstcll(_cur);
+						}
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		mode_option = this_opt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
@@ -650,6 +655,12 @@ static int __init lxfb_setup(char *optio
 			nocrt = 1;
 		else
--
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
 
 		mode_option = opt;
+		if (_cur < timeout) {
--
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -424,6 +429,12 @@ static void __init gx1fb_setup(char *opt
 			strlcpy(panel_option, this_opt + 6, sizeof(panel_option));
 		else
--
 	while(1) {
 		if (__sst_read(vbase, STATUS) & STATUS_FBI_BUSY) {
 			f_dddprintk("status: busy\n");
@@ -231,6 +236,12 @@ static int __sst_wait_idle(u8 __iomem *v
 		}
 		if (count >= 5) return 1;
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt) continue;
 
@@ -1301,6 +1317,12 @@ static int  __devinit sstfb_setup(char *
 			gfxclk = simple_strtoul (this_opt+7, NULL, 0);
 		else
--
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
@@ -1577,6 +1582,12 @@ static int __init mx3fb_setup(void)
 			default_bpp = simple_strtoul(opt + 4, NULL, 0);
 		else
--
 	while (dinfo->ring_space < n) {
 		dinfo->ring_head = INREG(PRI_RING_HEAD) & RING_HEAD_MASK;
 		dinfo->ring_space = get_ring_space(dinfo);
@@ -1543,6 +1548,12 @@ static int wait_ring(struct intelfb_info
 			}
 		}
--
 	while (ndwords--) {
 		dat = 0;
 		for (j = 0; j < 2; ++j) {
@@ -1828,6 +1844,12 @@ int intelfbhw_do_drawglyph(struct intelf
 			}
 		}
--
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -370,6 +375,12 @@ static int __init intelfb_setup(char *op
 			mode = get_opt_string(this_opt, "mode=");
 		else
--
 		while (dvo) {
 			if (dvo & 1) {
 				s = intelfbhw_dvo_to_string(1 << i);
@@ -811,6 +827,12 @@ static int __devinit intelfb_pci_registe
 			}
 			dvo >>= 1;
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -1613,6 +1618,12 @@ static void __init tdfxfb_setup(char *op
 		} else {
 			mode_option = this_opt;
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "vmode:", 6)) {
 			int vmode = simple_strtoul(this_opt+6, NULL, 0);
@@ -586,6 +591,12 @@ static void __init control_setup(char *o
 				break;
 			}
--
 	while (size >= 16) {
 		RIVA_FIFO_FREE(par->riva, Bitmap, 16);
 		for (i = 0; i < 16; i++) {
@@ -1569,6 +1574,12 @@ static void rivafb_imageblit(struct fb_i
 			NV_WR32(d, i*4, tmp);
 		}
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "forceCRTC", 9)) {
 			char *p;
@@ -2177,6 +2193,12 @@ static int __devinit rivafb_setup(char *
 			noaccel = 1;
 		} else
--
 	while (height--) {
 		int width = ((image->width + 7) >> 3)
 				+ info->pixmap.scan_align - 1;
 		width >>= 2;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (width >= PM3_FIFO_SIZE) {
 			int i = PM3_FIFO_SIZE - 1;
 
 			PM3_WAIT(par, PM3_FIFO_SIZE);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
--
 			while (i--) {
 				PM3_WRITE_REG(par, PM3BitMaskPattern, *src);
 				src++;
+				if (_cur < timeout) {
+	rdstcll(_cur);
+				}
--
 		while (width--) {
 			PM3_WRITE_REG(par, PM3BitMaskPattern, *src);
 			src++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -1542,6 +1591,12 @@ static int __init pm3fb_setup(char *opti
 #endif
 		else
--
 			while (n >= 8) {
 				FB_WRITEL(FB_READL(src++), dst++);
 				FB_WRITEL(FB_READL(src++), dst++);
@@ -94,6 +99,12 @@ bitcpy(struct fb_info *p, unsigned long
 				FB_WRITEL(FB_READL(src++), dst++);
 				FB_WRITEL(FB_READL(src++), dst++);
--
 			while (n--)
 				FB_WRITEL(FB_READL(src++), dst++);
@@ -161,6 +172,11 @@ bitcpy(struct fb_info *p, unsigned long
 			// Main chunk
 			m = n % bits;
 			n /= bits;
--
 			while ((n >= 4) && !bswapmask) {
 				d1 = FB_READL(src++);
 				FB_WRITEL(d0 >> right | d1 << left, dst++);
@@ -175,7 +191,18 @@ bitcpy(struct fb_info *p, unsigned long
 				FB_WRITEL(d0 >> right | d1 << left, dst++);
 				d0 = d1;
--
 			while (n--) {
 				d1 = FB_READL(src++);
 				d1 = fb_rev_pixels_in_long(d1, bswapmask);
@@ -183,6 +210,12 @@ bitcpy(struct fb_info *p, unsigned long
 				d0 = fb_rev_pixels_in_long(d0, bswapmask);
 				FB_WRITEL(d0, dst++);
--
 			while (n >= 8) {
 				FB_WRITEL(FB_READL(src--), dst--);
 				FB_WRITEL(FB_READL(src--), dst--);
@@ -267,6 +305,12 @@ bitcpy_rev(struct fb_info *p, unsigned l
 				FB_WRITEL(FB_READL(src--), dst--);
 				FB_WRITEL(FB_READL(src--), dst--);
--
 			while (n--)
 				FB_WRITEL(FB_READL(src--), dst--);
@@ -332,6 +376,11 @@ bitcpy_rev(struct fb_info *p, unsigned l
 			// Main chunk
 			m = n % bits;
 			n /= bits;
--
 			while ((n >= 4) && !bswapmask) {
 				d1 = FB_READL(src--);
 				FB_WRITEL(d0 << left | d1 >> right, dst--);
@@ -346,7 +395,18 @@ bitcpy_rev(struct fb_info *p, unsigned l
 				FB_WRITEL(d0 << left | d1 >> right, dst--);
 				d0 = d1;
--
 			while (n--) {
 				d1 = FB_READL(src--);
 				d1 = fb_rev_pixels_in_long(d1, bswapmask);
@@ -354,6 +414,12 @@ bitcpy_rev(struct fb_info *p, unsigned l
 				d0 = fb_rev_pixels_in_long(d0, bswapmask);
 				FB_WRITEL(d0, dst--);
--
 		while (height--) {
 			dst_idx -= bits_per_line;
 			src_idx -= bits_per_line;
 			bitcpy_rev(p, base + (dst_idx / bits), dst_idx % bits,
 				base + (src_idx / bits), src_idx % bits, bits,
 				width*p->var.bits_per_pixel, bswapmask);
--
-		while (height--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (height--) {
 			bitcpy(p, base + (dst_idx / bits), dst_idx % bits,
 				base + (src_idx / bits), src_idx % bits, bits,
 				width*p->var.bits_per_pixel, bswapmask);
 			dst_idx += bits_per_line;
 			src_idx += bits_per_line;
--
 	while (ulBits) {
 		if (!(ulPattern & 1))
 			ulCount++;
 		ulBits--;
 		ulPattern = ulPattern >> 1;
+		if (_cur < timeout) {
--
 		while (ulScale > 0x800) {
 			ulhDecim++;
 			ulScale = (((ulSrcRight - ulSrcLeft) - 1) << (11 - ulhDecim)) / (ulRight - ulLeft + 2);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
--
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -577,6 +582,12 @@ static int __init kyrofb_setup(char *opt
 		} else {
 			mode_option = this_opt;
--
 		while (R <= STG4K3_PLL_MAX_R) {
 			/* estimate required feedback multiplier */
 			ulTmp = R * (ulScaleClockReq << OD);
@@ -162,6 +167,11 @@ u32 ProgramClock(u32 refClock,
 			 * achievable with current OD & R) let's iterate
 			 * through F for best fit
--
 			while ((F >= STG4K3_PLL_MIN_F) &&
 			       (F <= STG4K3_PLL_MAX_F)) {
 				/* Calc VCO at full accuracy */
@@ -217,8 +227,20 @@ u32 ProgramClock(u32 refClock,
 					}
 				}
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "font:", 5)) {
 			char *p;
@@ -1598,6 +1603,12 @@ imsttfb_setup(char *options)
 			}
 		}
--
 	while (list != &global_no_mode) {
 		list_del_init(list);
 		entry = list_entry(list, struct vml_info, head);
@@ -1144,6 +1149,12 @@ int vmlfb_register_subsys(struct vml_sys
 		}
 		vmlfb_blank_locked(entry);
--
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
@@ -1167,6 +1172,12 @@ static int __devinit acornfb_setup(char
 		if (!optp->name)
 			printk(KERN_ERR "acornfb: unknown parameter: %s\n",
--
 	while (virtual_start < virtual_end) {
 		struct page *page;
 
@@ -1211,6 +1227,12 @@ free_unused_pages(unsigned int virtual_s
 
 		virtual_start += PAGE_SIZE;
--
 	while (height--) {
 		c = src;
 		p = dst;
@@ -129,6 +134,11 @@ void c2p_planar(void *dst, const void *s
 				w = width-w;
 			}
--
 			while (w >= 32) {
 				memcpy(d.pixels, c, 32);
 				c += 32;
@@ -136,6 +146,12 @@ void c2p_planar(void *dst, const void *s
 				store_planar(p, dst_nextplane, bpp, d.words);
 				p += 4;
--
 	while (*mode != 0xffff) {
 		par->vbe_modes_cnt++;
 		mode++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (*mode != 0xffff) {
 		struct vbe_mode_ib *mib;
 
@@ -543,6 +559,12 @@ static int __devinit uvesafb_vbe_getmode
 		if (mib->depth == 0 || (mib->depth == 24 &&
 					mib->bits_per_pixel == 32))
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt) continue;
 
@@ -1920,6 +1947,12 @@ static int __devinit uvesafb_setup(char
 			printk(KERN_WARNING
 				"uvesafb: unrecognized option %s\n", this_opt);
--
-		while (n--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (n--) {
 			if (p->fix.visual == FB_VISUAL_TRUECOLOR ||
 			    p->fix.visual == FB_VISUAL_DIRECTCOLOR )
 				color = palette[*src];
@@ -116,6 +121,12 @@ static inline void color_imageblit(const
 			shift += bpp;
--
 		while (j--) {
 			l--;
 			color = (*s & (1 << l)) ? fgcolor : bgcolor;
@@ -182,7 +198,13 @@ static inline void slow_imageblit(const
 			shift += bpp;
 			shift &= (32 - 1);
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -537,6 +542,12 @@ static void __init macfb_setup(char *opt
 		else
 			if (!strcmp(this_opt, "vidtest"))
--
 	while ((ndev = nubus_find_type(NUBUS_CAT_DISPLAY,
 				       NUBUS_TYPE_VIDEO, ndev)))
 	{
@@ -708,6 +724,12 @@ static int __init macfb_init(void)
 			strcpy(macfb_fix.id, "Generic NuBus");
 			break;
--
 	while (((multiplier | divider) & 1) == 0) {
 		multiplier = multiplier >> 1;
 		divider = divider >> 1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 		while (ecp > par->pll_limits.ecp_max && ecp_div < 2) {
 			ecp >>= 1;
 			ecp_div++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 	while ((this_opt = strsep (&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -2512,6 +2517,12 @@ static int __init radeonfb_setup (char *
 #endif
 		} else
--
 		while (MHz100 < MIN_FREQ_2595) {
 			MHz100 *= 2;
 			post_divider *= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (mhz100 < (mach64MinFreq << 3)) {
 			mhz100 <<= 1;
 			divider += 0x20;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (mhz100 < (mach64MinFreq << 3)) {
 			mhz100 <<= 1;
 			k++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (mhz100 < (mach64MinFreq << 3)) {
 			mhz100 <<= 1;
 			divider += 0x40;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((Remainder = Multiplier % Divider)) {
 		Multiplier = Divider;
 		Divider = Remainder;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-						while (--Index >= 0) {
+						unsigned long long delta = (cpu / khz / HZ) * 2;
+						unsigned long long _start = 0;
+						unsigned long long _cur = 0;
+						unsigned long long timeout;
+							timeout = rdstcll(start) + delta;
+							while (--Index >= 0) {
 							if (Accumulator > 0)
 								horz_stretch_ratio |= reuse_previous;
 							else
 								Accumulator += Denominator;
 							Accumulator -= Numerator;
--
-	while ((this_opt = strsep(&options, ",")) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "noaccel", 7)) {
 			noaccel = 1;
 #ifdef CONFIG_MTRR
@@ -3914,6 +3941,12 @@ static int __init atyfb_setup(char *opti
 #endif
--
 	while (db) {
 		for (i = 0; i < dbsize; i++) {
 			int d;
@@ -1001,6 +1006,12 @@ int  radeon_match_mode(struct radeonfb_i
 			dbsize = 34;
 			native_db = 0;
--
 	while (x) {
 		x >>= 1;
 		b++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "lcd:", 4)) {
 			default_lcd_on = simple_strtoul(this_opt+4, NULL, 0);
@@ -1692,6 +1708,12 @@ static int __devinit aty128fb_setup(char
 		}
 #endif /* CONFIG_PPC_PMAC */
--
 		while (*name) {
 			if (!strcmp(vname, *name))
 				return i + 1;
 			name++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (height--) {
 
 			if (info->var.bits_per_pixel == 1)
@@ -2650,6 +2666,12 @@ static void atafb_imageblit(struct fb_in
 							image->bg_color, image->fg_color);
 			dy++;
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -3069,6 +3096,12 @@ int __init atafb_setup(char *options)
 			DontCalcRes = 1;
 		else if (!strncmp(this_opt, "R", 1))
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "pal", 3))
 			fm2fb_mode = FM2FB_MODE_PAL;
 		else if (!strncmp(this_opt, "ntsc", 4))
 			fm2fb_mode = FM2FB_MODE_NTSC;
+			if (_cur < timeout) {
--
 	while ((options = strsep(&this_opt, ",")) != NULL) {
 		if (!strncmp(options, "font:", 5))
 			strcpy(fontname, options + 5);
@@ -501,6 +506,12 @@ static int __init fb_console_setup(char
 			if (initial_rotation > 3)
 				initial_rotation = 0;
--
 	while (count--) {
 		unsigned short *start;
 		unsigned short *le;
@@ -1649,6 +1665,12 @@ static void fbcon_redraw_softback(struct
 			s = (u16 *) softback_buf;
 		if (s == (u16 *) softback_in)
--
 	while (count--) {
 		unsigned short *start = s;
 		unsigned short *le = advance_row(s, 1);
@@ -1683,6 +1710,12 @@ static void fbcon_redraw_move(struct vc_
 			fbcon_putcs(vc, start, s - start, dy, x);
 		console_conditional_schedule();
--
 	while (count--) {
 		unsigned short *start = s;
 		unsigned short *le = advance_row(s, 1);
@@ -1733,6 +1771,12 @@ static void fbcon_redraw_blit(struct vc_
 			s -= vc->vc_size_row;
 			d -= vc->vc_size_row;
--
 	while (count--) {
 		unsigned short *start = s;
 		unsigned short *le = advance_row(s, 1);
@@ -1788,6 +1837,12 @@ static void fbcon_redraw(struct vc_data
 			s -= vc->vc_size_row;
 			d -= vc->vc_size_row;
--
 	while (count) {
 		scr_memcpyw((u16 *) softback_in, p, vc->vc_size_row);
 		count--;
@@ -1812,6 +1872,12 @@ static inline void fbcon_softback_note(s
 			if (softback_top == softback_end)
 				softback_top = softback_buf;
--
 	while (cnt--) {
 		u16 a = scr_readw(p);
 		if (!vc->vc_can_do_color)
@@ -2782,6 +2853,12 @@ static void fbcon_invert_region(struct v
 			p = (u16 *) softback_buf;
 		if (p == (u16 *) softback_in)
--
 	while (cnt--) {
 		src = ops->fontbuffer + (scr_readw(s++) & charmask)*cellsize;
 
@@ -107,6 +112,12 @@ static inline void cw_putcs_aligned(stru
 					      vc->vc_font.width);
 
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -162,6 +178,12 @@ static void cw_putcs(struct vc_data *vc,
 		image.dy += image.height;
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count--) {
 		scr_memcpyw(vgacon_scrollback + vgacon_scrollback_tail,
 			    p, c->vc_size_row);
 		vgacon_scrollback_cnt++;
@@ -232,6 +237,12 @@ static void vgacon_scrollback_update(str
 			vgacon_scrollback_cnt = vgacon_scrollback_rows;
--
 	while (count--) {
 		u16 a = scr_readw(p);
 		if (col)
@@ -647,6 +663,12 @@ static void vgacon_invert_region(struct
 		else
 			a ^= ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;
--
 	while (cnt--) {
 		src = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;
 
@@ -121,6 +126,12 @@ static inline void ccw_putcs_aligned(str
 					      vc->vc_font.width);
 
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -178,6 +194,12 @@ static void ccw_putcs(struct vc_data *vc
 		image.dy += image.height;
--
     while (count--) {
 	sti_putc(sticon_sti, scr_readw(s++), ypos, xpos++);
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	    }
+	    else {
--
     while (count--) {
 	u16 a = scr_readw(p);
 
@@ -338,6 +354,12 @@ static void sticon_invert_region(struct
 		a = ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;
 
--
 	while (cnt--) {
 		src = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;
 
@@ -108,6 +113,12 @@ static inline void ud_putcs_aligned(stru
 					      image->height);
 
--
 	while (cnt--) {
 		src = ops->fontbuffer + (scr_readw(s--) & charmask)*cellsize;
 
@@ -142,6 +158,12 @@ static inline void ud_putcs_unaligned(st
 		dst += (shift_low >= 8) ? s_pitch : s_pitch - 1;
 		shift_low &= 7;
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -209,6 +236,12 @@ static void ud_putcs(struct vc_data *vc,
 		count -= cnt;
--
-	while (cnt--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cnt--) {
 		src = vc->vc_font.data + (scr_readw(s++)&
 					  charmask)*cellsize;
 
@@ -100,6 +105,12 @@ static inline void bit_putcs_aligned(str
 					      image->height);
--
-	while (cnt--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cnt--) {
 		src = vc->vc_font.data + (scr_readw(s++)&
 					  charmask)*cellsize;
 
@@ -134,6 +150,12 @@ static inline void bit_putcs_unaligned(s
 		dst += (shift_low >= 8) ? s_pitch : s_pitch - 1;
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -192,6 +219,12 @@ static void bit_putcs(struct vc_data *vc
 		image.dx += cnt * vc->vc_font.width;
--
 		while (count--) {
 			chattr = scr_readw(s++);
 			if (chattr != scr_readw(d)) {
@@ -629,6 +634,12 @@ static int newport_scroll(struct vc_data
 				x = 0;
 				y++;
--
 		while (count--) {
 			chattr = scr_readw(s--);
 			if (chattr != scr_readw(d)) {
@@ -664,6 +680,12 @@ static int newport_scroll(struct vc_data
 				x = vc->vc_cols - 1;
 				y--;
--
 	while (count >= 4) {
 		count -= 4;
 		*(u32 *)dest = gsc_readl(base);
 		base += 4;
 		dest += 4;
+		if (_cur < timeout) {
--
 	while (count) {
 		count--;
 		*(u8 *)dest = gsc_readb(base);
 		base++;
 		dest++;
+		if (_cur < timeout) {
--
 	while (i<MAX_STI_ROMS && str && *str) {
 		if (*str>='0' && *str<='9') {
 			if ((x = strchr(str, 'x')) || (x = strchr(str, '*'))) {
@@ -313,6 +340,12 @@ static int __devinit sti_font_setup(char
 		str = x;
 
--
 	while (raw_font->next_font) {
 		raw_font = ((void *)font_start) + (raw_font->next_font);
 
@@ -613,6 +651,12 @@ sti_cook_fonts(struct sti_cooked_rom *co
 		cooked_font = cooked_font->next_font;
 
--
 	while (size--) {
 		*p = *q++;
 		p+=4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (count) {
 		count--;
 		*(u8 *)dest = gsc_readl(base);
 		base += 4;
 		dest++;
+		if (_cur < timeout) {
--
 		while (raw_font->next_font) {
 			BMODE_RELOCATE (raw_font->next_font);
 			raw_font = ((void *)font_start) + raw_font->next_font;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((inreg(dram_ctrl, GC_DCTL_RSV0_STATES) & GC_DCTL_STATES_MSK)) {
 		udelay(GC_DCTL_INIT_WAIT_INTERVAL);
 		if (i++ > GC_DCTL_INIT_WAIT_CNT) {
 			dev_err(par->dev, "VRAM init failed.\n");
 			return -EINVAL;
 		}
--
 	while (total < count) {
 		if (free) {
 			outreg(geo, GDC_GEO_REG_INPUT_FIFO, data[total]);
@@ -40,6 +45,12 @@ static void mb862xxfb_write_fifo(u32 cou
 		} else {
 			free = (u32) inreg(draw, GDC_REG_FIFO_COUNT);
--
-	while (i < height) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (i < height) {
 		memcpy(&cmd[9 + i * step], line, step << 2);
 #ifdef __LITTLE_ENDIAN
 		{
@@ -114,6 +130,12 @@ static void mb86290fb_imageblit1(u32 *cm
 #endif
--
 	while (i < height) {
 		ptr = line;
 		for (j = 0; j < step; j++) {
@@ -153,6 +180,12 @@ static void mb86290fb_imageblit8(u32 *cm
 
 		line += bytes;
--
 	while (i < height) {
 		memcpy(&cmd[3 + i * step], line, step);
 		line += bytes;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (height--) {
 		c = src;
 		p = dst;
@@ -127,6 +132,11 @@ void c2p_iplan2(void *dst, const void *s
 				w = width-w;
 			}
--
 			while (w >= 16) {
 				memcpy(d.pixels, c, 16);
 				c += 16;
@@ -134,6 +144,12 @@ void c2p_iplan2(void *dst, const void *s
 				store_iplan2(p, bpp, d.words);
 				p += bpp*2;
--
                 while (height--) {
                         int x;
 
@@ -856,6 +861,12 @@ static void vga_8planes_fillrect(struct
                                 where++;
                         }
--
 				while (height--) {
 					for (x = 0; x < width; x++) {
 						writeb(0, dst);
 						dst++;
 					}
 					dst += line_ofs;
--
 				while (height--) {
 					for (x = 0; x < width; x++) {
 						rmw(dst);
 						dst++;
 					}
 					dst += line_ofs;
--
                 while (height--) {
                         for (x = 0; x < width; x++) {
                                 readb(src);
@@ -983,6 +1021,12 @@ static void vga_8planes_copyarea(struct
                         }
                         src += line_ofs;
--
                 while (height--) {
                         for (x = 0; x < width; x++) {
                                 --src;
@@ -999,6 +1048,12 @@ static void vga_8planes_copyarea(struct
                         }
                         src -= line_ofs;
--
 				while (height--) {
 					for (x = 0; x < width; x++) {
 						readb(src);
@@ -1074,12 +1134,23 @@ static void vga16fb_copyarea(struct fb_i
 					}
 					src += line_ofs;
--
 				while (height--) {
 					for (x = 0; x < width; x++) {
 						dst--;
@@ -1089,6 +1160,12 @@ static void vga16fb_copyarea(struct fb_i
 					}
 					src -= line_ofs;
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt) continue;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt) continue;
 
@@ -326,6 +331,12 @@ static int __init efifb_setup(char *opti
 			screen_info.lfb_height = simple_strtoul(this_opt+7, NULL, 0);
 		else if (!strncmp(this_opt, "width:", 6))
--
 	while ((sid = search_tc_card("PMAG-AA")) >= 0) {
 		found = 1;
 		claim_tc_card(sid);
 		init_one(sid);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((sid = search_tc_card("PMAG-AA")) >= 0) {
 		exit_one(sid);
 		release_tc_card(sid);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (pos < edid[2]) {
 		u8 len = edid[pos] & 0x1f, type = (edid[pos] >> 5) & 7;
 		pr_debug("Data block %u of %u bytes\n", type, len);
@@ -1018,6 +1023,12 @@ void fb_edid_add_monspecs(unsigned char
 					 edid[pos + i] & 0x80 ? "" : "on-n", idx);
 			}
--
 	while (Ftarget < 100000000) {
 		divisor += 0x10;
 		Ftarget <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (base < 449) {
 		for (n = base < 7 ? 7 : base; n < base + target && n < 449; n++) {
 			m = ((n + 3) / 7) - 1;
@@ -495,6 +500,12 @@ tgafb_set_pll(struct tga_par *par, int f
 		}
 		r++;
--
 		while ((this_opt = strsep(&arg, ","))) {
 			if (!*this_opt)
 				continue;
@@ -1582,6 +1598,12 @@ tgafb_setup(char *arg)
 				printk(KERN_ERR
 				       "tgafb: unknown parameter %s\n",
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		/* Panel option */
 		if (!strncmp(this_opt, "panel:", 6)) {
@@ -448,6 +453,12 @@ static int au1100fb_setup(struct au1100f
 		/* Unsupported option */
 		else
--
 	while(len)
 	{
 		v <<= 8;
@@ -94,6 +99,12 @@ static unsigned long nubus_get_rom(unsig
 			p++;
 		v |= *p++;
--
 	while(len)
 	{
 		do
@@ -114,6 +130,12 @@ static void nubus_rewind(unsigned char *
 		}
 		while(not_useful(p, map));
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while(len)
 	{
 		while(not_useful(p,map))
 			p++;
 		p++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(len)
 	{
 		*t++ = nubus_get_rom(&p, 1, dirent->mask);
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (itor) {
 		if (itor->category == category
 		    && itor->type == type
@@ -310,6 +359,12 @@ nubus_find_device(unsigned short categor
 		    && itor->dr_sw == dr_sw)
 			return itor;
--
 	while (itor) {
 		if (itor->category == category
 		    && itor->type == type)
 			return itor;
 		itor = itor->next;
+		if (_cur < timeout) {
--
 	while (itor) {
 		if (itor->board->slot == slot)
 			return itor;
 		itor = itor->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (nubus_readdir(dir, ent) != -1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (nubus_readdir(dir, ent) != -1) {
 		if (ent->type == rsrc_type)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (nubus_readdir(&dir, &ent) != -1)
 	{
 		switch(ent.type)
@@ -548,6 +641,12 @@ static struct nubus_dev* __init
 			   function */
 			nubus_show_private_resource(dev, &ent);
--
 	while(nubus_readdir(&dir, &ent) != -1)
 	{
 		struct vidmode mode;
@@ -589,6 +693,12 @@ static int __init nubus_get_vidnames(str
 		nubus_get_rsrc_mem(&mode, &ent, size);
 		printk (KERN_INFO "      %02X: (%02X) %s\n", ent.type,
--
 	while(nubus_readdir(&dir, &ent) != -1)
 	{
 		char name[64];
@@ -645,6 +760,12 @@ static int __init nubus_get_vendorinfo(s
 			ent.type = 5;
 		printk(KERN_INFO "    %s: %s\n",
--
 	while(nubus_readdir(&dir, &ent) != -1)
 	{
 		switch (ent.type) {
@@ -716,6 +842,12 @@ static int __init nubus_get_board_resour
 			printk(KERN_INFO "    unknown resource %02X, data 0x%06x\n",
 			       ent.type, ent.data);
--
 	while (nubus_readdir(&dir, &ent) != -1) {
 		struct nubus_dev*  dev;
 		struct nubus_dev** devp;
@@ -902,6 +1039,12 @@ static struct nubus_board* __init nubus_
 			/* spin */;
 		*devp = dev;
--
-	while (dev) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (dev) {
 		seq_printf(m, "%x\t%04x %04x %04x %04x",
 			      dev->board->slot,
 			      dev->category,
@@ -42,6 +47,12 @@ nubus_devices_proc_show(struct seq_file
 			      dev->dr_hw);
--
 	while (nubus_readdir(dir, &ent) != -1) {
 		char name[8];
 		struct proc_dir_entry* e;
@@ -76,6 +92,12 @@ static void nubus_proc_subdir(struct nub
 		e = create_proc_entry(name, S_IFREG | S_IRUGO |
 				      S_IWUSR, parent);
--
 	while (nubus_readdir(root, &ent) != -1) {
 		char name[8];
 		struct proc_dir_entry* e;
@@ -107,6 +134,12 @@ static void nubus_proc_populate(struct n
 		} else {
 			nubus_proc_subdir(dev, e, &dir);
--
-	while (*c) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*c) {
 		if (*c == '"')
 			fprintf(f, "\\\"");
 		else
 			fputc(*c, f);
 		c++;
--
 	while (fgets(line, sizeof(line)-1, stdin)) {
 		lino++;
 		if ((c = strchr(line, '\n')))
@@ -94,6 +110,12 @@ main(void)
 			fprintf(stderr, "Line %d: Syntax error in mode %d: %s\n", lino, mode, line);
 			return 1;
--
 	while (ids->id) {
 		if (ids->id == ZORRO_WILDCARD || ids->id == z->id)
 			return ids;
 		ids++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (ids->id) {
 		if (ids->id == ZORRO_WILDCARD || ids->id == z->id)
 			return 1;
 		ids++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (i > 0) {
 			if (prod_p->prod ==
 			    ((ZORRO_PROD(dev->id)<<8) | ZORRO_EPC(dev->id)))
 				goto match_prod;
 			prod_p++;
 			i--;
--
-	while (start < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (start < end) {
 		u32 chunk = start>>Z2RAM_CHUNKSHIFT;
 		if (flag)
 			set_bit(chunk, zorro_unused_z2ram);
 		else
 			clear_bit(chunk, zorro_unused_z2ram);
--
-	while (!pvt->branchmap_werrors || !pvt->fsb_error_regs) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!pvt->branchmap_werrors || !pvt->fsb_error_regs) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_5400_ERR, pdev);
 		if (!pdev) {
@@ -759,6 +764,12 @@ static int i5400_get_devices(struct mem_
 			pvt->fsb_error_regs = pdev;
--
 	while ((cpunode = of_get_next_child(cpus, cpunode)) != NULL) {
 		const u32 *reg = of_get_property(cpunode, "reg", NULL);
 
@@ -614,6 +619,12 @@ static u32 cpc925_cpu_mask_disabled(void
 		}
 
--
-	while ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7300_MCH_ERR,
 				      pdev))) {
 		/* Store device 16 funcs 1 and 2 */
@@ -978,6 +983,12 @@ static int __devinit i7300_get_devices(s
 							pci_dev_get(pdev);
--
 	 * and while we are looking at it have its reference count
 	 * bumped until we are done with it
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
 		fn(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (sysfs_attrib) {
 		debugf4("%s() sysfs_attrib = %p\n",__func__, sysfs_attrib);
 		if (sysfs_attrib->grp) {
@@ -829,6 +834,12 @@ static int edac_create_mci_instance_attr
 			break;
 
--
 	while (sysfs_attrib) {
 		debugf4("%s() sysfs_attrib = %p\n",__func__, sysfs_attrib);
 		if (sysfs_attrib->grp) {
@@ -877,6 +893,12 @@ static void edac_remove_mci_instance_att
 		} else
 			break;
--
 	while (table && table->descr) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL, table->descr[0].dev_id, NULL);
 		if (unlikely(!pdev)) {
@@ -1319,6 +1324,12 @@ static void __init i7core_xeon_pci_fixup
 		}
 		pci_dev_put(pdev);
--
 	while ((b = pci_find_next_bus(b)) != NULL) {
 		bus = b->number;
 		debugf0("Found bus %d\n", bus);
 		if (bus > last_bus)
 			last_bus = bus;
+			if (_cur < timeout) {
--
 	while (table && table->descr) {
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
@@ -1488,6 +1515,12 @@ static int i7core_get_all_devices(void)
 			} while (pdev);
 		}
 		table++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while (sysfs_attrib->attr.name != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (sysfs_attrib->attr.name != NULL) {
 			err = sysfs_create_file(&edac_dev->kobj,
 				(struct attribute*) sysfs_attrib);
 			if (err)
 				goto err_out;
 
--
-		while (sysfs_attrib->attr.name != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (sysfs_attrib->attr.name != NULL) {
 			sysfs_remove_file(&edac_dev->kobj,
 					(struct attribute *) sysfs_attrib);
 			sysfs_attrib++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while (mci_pdev == NULL && id->vendor != 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (mci_pdev == NULL && id->vendor != 0) {
 			mci_pdev = pci_get_device(id->vendor,
 					id->device, NULL);
 			i++;
 			id = &i82443bxgx_pci_tbl[i];
+			if (_cur < timeout) {
--
 	while (table && table->descr) {
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
@@ -1276,6 +1281,12 @@ static int sbridge_get_all_devices(u8 *n
 			} while (pdev);
 		}
 		table++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (count && pos < sel->area_length) {
 		count--;
 		*(buf++) = io_reader(sel, pos++);
 		wrote++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count && pos < sel->area_length) {
 		count--;
 		*(buf++) = readb(mapped + pos++);
 		wrote++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!packet_data_temp_buf) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!packet_data_temp_buf) {
 		packet_data_temp_buf = (unsigned char *)
 			__get_free_pages(GFP_KERNEL, ordernum);
 		if (!packet_data_temp_buf) {
@@ -180,6 +185,12 @@ static int create_packet(void *data, siz
 			invalid_addr_packet_array[idx++] = packet_data_temp_buf;
--
 	while (!done) {
 		if ((temp + rbu_data.packetsize) < end)
 			packet_length = rbu_data.packetsize;
@@ -252,6 +268,12 @@ static int packetize_data(const u8 *data
 
 		pr_debug("%p:%td\n", temp, (end - temp));
--
-	while (!list_empty(ptemp_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(ptemp_list)) {
 		newpacket =
 			list_entry(ptemp_list, struct packet_data, list);
 		pnext_list = ptemp_list->next;
@@ -352,6 +379,12 @@ static void packet_empty_list(void)
 		free_pages((unsigned long) newpacket->data,
--
 	while (1) {
 		if (len == 0)
 			return 0;
@@ -203,6 +208,12 @@ utf16_strncmp(const efi_char16_t *a, con
 		a++;
 		b++;
--
 	while (offset <= len - sizeof(*node) &&
 	       node->length >= sizeof(*node) &&
 		node->length <= len - offset) {
@@ -229,6 +245,12 @@ validate_device_path(struct efi_variable
 			return true;
 
--
 	while (&efivars->walk_entry->list != &efivars->list) {
 		if (!efi_guidcmp(efivars->walk_entry->var.VendorGuid,
 				 vendor)) {
@@ -753,6 +780,12 @@ static ssize_t efi_pstore_read(u64 *id,
 		}
 		efivars->walk_entry = list_entry(efivars->walk_entry->list.next,
--
 	while (1) {
 		variable_name = kzalloc(variable_name_size, GFP_KERNEL);
 		if (!variable_name) {
@@ -1107,6 +1145,12 @@ static void efivar_update_sysfs_entries(
 						  variable_name_size,
 						  variable_name, &vendor);
--
 		while (s > 0 && *bp) {
 			bp += strlen(bp) + 1;
 			s--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((i < num) && (data - buf + sizeof(struct dmi_header)) <= len) {
 		const struct dmi_header *dm = (const struct dmi_header *)data;
 
@@ -95,6 +111,12 @@ static void dmi_table(u8 *buf, int len,
 			decode(dm, private_data);
 		data += 2;
--
-		while ((cmd_status = inb(PCAT_APM_STATUS_PORT))
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while ((cmd_status = inb(PCAT_APM_STATUS_PORT))
 		       == ESM_STATUS_CMD_UNSUCCESSFUL) {
 			num_ticks--;
 			if (num_ticks == EXPIRED_TIMER)
 				return -ETIME;
+				if (_cur < timeout) {
--
-		while (apm_cmd->status == ESM_STATUS_CMD_UNSUCCESSFUL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while (apm_cmd->status == ESM_STATUS_CMD_UNSUCCESSFUL) {
 			num_ticks--;
 			if (num_ticks == EXPIRED_TIMER)
 				return -ETIME;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 			while (--i >= 0) {
 				info = &ab8500_regulator_info[i];
 				regulator_unregister(info->regulator);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
 			while (--i >= 0) {
 				info = &db8500_regulator_info[i];
 				regulator_unregister(info->rdev);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (eff[i].uA_load_min != -1) {
 		if (uA >= eff[i].uA_load_min && uA <= eff[i].uA_load_max)
 			return eff[i].mode;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (*mode) {
 		if (rdev->constraints->valid_modes_mask & *mode)
 			return 0;
 		*mode /= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while (debugfs_file_list[i].ptr != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (debugfs_file_list[i].ptr != NULL) {
 			debugfs_file_list[i].file = debugfs_create_file(
 					debugfs_file_list[i].name,
 					S_IRUSR,
@@ -581,6 +586,12 @@ static int __init i7300_idle_init(void)
 					debugfs_file_list[i].ptr,
--
 		while (debugfs_file_list[i].file != NULL) {
 			debugfs_remove(debugfs_file_list[i].file);
 			i++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (prop) {
 		struct property *next = prop->next;
 		kfree(prop->name);
@@ -143,6 +148,12 @@ static void of_node_release(struct kref
 			prop = node->deadprops;
 			node->deadprops = NULL;
--
 	while (cplen > 0) {
 		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 			return 1;
 		l = strlen(cp) + 1;
 		cp += l;
 		cplen -= l;
--
 	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
 		int match = 1;
 		if (matches->name[0])
@@ -538,6 +565,12 @@ const struct of_device_id *of_match_node
 		if (match)
 			return matches;
--
 	while (*next) {
 		if (strcmp(prop->name, (*next)->name) == 0) {
 			/* duplicate ! don't insert it */
@@ -958,6 +996,12 @@ int prom_add_property(struct device_node
 			return -1;
 		}
--
-	while(tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(tail) {
 		tail->next = of_pdt_build_one_prop(node, tail->name,
 					    NULL, NULL, 0);
 		tail = tail->next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (compat && *compat && cplen > 0) {
 		if (add_uevent_var(env, "OF_COMPATIBLE_%d=%s", seen, compat))
 			return -ENOMEM;
@@ -155,6 +160,12 @@ int of_device_uevent(struct device *dev,
 		compat += sl;
 		cplen -= sl;
--
 	while (cplen > 0) {
 		score++;
 		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
@@ -98,6 +103,12 @@ int of_fdt_is_compatible(struct boot_par
 		l = strlen(cp) + 1;
 		cp += l;
--
 	while (*compat) {
 		tmp = of_fdt_is_compatible(blob, node, *compat);
 		if (tmp && (score == 0 || (tmp < score)))
 			score = tmp;
 		compat++;
+		if (_cur < timeout) {
--
 		while (*p1) {
 			if ((*p1) == '@')
 				pa = p1;
 			if ((*p1) == '/')
 				ps = p1 + 1;
 			p1++;
--
-	while (tag == OF_DT_BEGIN_NODE || tag == OF_DT_NOP) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (tag == OF_DT_BEGIN_NODE || tag == OF_DT_NOP) {
 		if (tag == OF_DT_NOP)
 			*p += 4;
 		else
 			mem = unflatten_dt_node(blob, mem, p, np, allnextpp,
 						fpsize);
--
 	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
 		u64 base, size;
 
@@ -659,6 +708,12 @@ int __init early_init_dt_scan_memory(uns
 		    (unsigned long long)size);
 
--
 	while (dn) {
 		if (of_address_to_resource(dn, 0, &res))
 			continue;
 		if (res.start == base_address)
 			return dn;
 		dn = of_find_matching_node(dn, matches);
--
 	while (ipar != NULL) {
 		/* Now check if cursor is an interrupt-controller and if it is
 		 * then we are done
@@ -188,6 +193,11 @@ int of_irq_map_raw(struct device_node *p
 
 		/* Parse interrupt-map */
--
 		while (imaplen > (addrsize + intsize + 1) && !match) {
 			/* Compare specifiers */
 			match = 1;
@@ -242,6 +252,12 @@ int of_irq_map_raw(struct device_node *p
 			imaplen -= newaddrsize + newintsize;
 
--
 	while (ts->nsec >= NSEC_PER_SEC) {
 		ts->nsec -= NSEC_PER_SEC;
 		ts->sec++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (ts->nsec < 0) {
 		ts->nsec += NSEC_PER_SEC;
 		ts->sec--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (num--) {
 		list_add_tail(&cl->node, &clocks);
 		cl++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cnt < sprom_size_words) {
 		memcpy(tmp, dump, 4);
 		dump += 4;
@@ -58,6 +63,12 @@ static int hex2sprom(u16 *sprom, const c
 		if (err)
 			return err;
--
 	while (tuple) {
 		switch (tuple->code) {
 		case 0x22: /* extended function */
@@ -583,6 +588,12 @@ int ssb_sdio_get_invariants(struct ssb_b
 			break;
 		}
--
 		while (count) {
 			*buf = __raw_readb(addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le32)__raw_readl(addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writeb(*buf, addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writel((__force u32)(*buf), addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = __raw_readb(addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			*buf = (__force __le16)__raw_readw(addr + 2);
 			buf++;
 			count -= 4;
--
 		while (count) {
 			__raw_writeb(*buf, addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			__raw_writew((__force u16)(*buf), addr + 2);
 			buf++;
 			count -= 4;
--
 	while (j < 7*cmd->cmd_num) {
 		for (i = 0; i < 7; i++)
 			report->field[0]->value[i] = cmd->cmd[j++];
 
 		usbhid_submit_report(hid, report, USB_DIR_OUT);
+		if (_cur < timeout) {
--
 	while (ret == 0) {
 		if (list->head == list->tail) {
 			add_wait_queue(&list->hidraw->wait, &wait);
@@ -98,6 +103,12 @@ static ssize_t hidraw_read(struct file *
 		kfree(list->buffer[list->tail].value);
 		list->buffer[list->tail].value = NULL;
--
 	while (s > 0) {
 		err = -EIO;
 		len_off = _picolcd_flash_setaddr(data, raw_data, *off);
@@ -1676,6 +1681,12 @@ skip:
 		kfree(resp);
 		if (err)
--
 		while (list != &report_enum->report_list) {
 			report = (struct hid_report *) list;
 			tab(2, f);
@@ -561,6 +566,12 @@ void hid_dump_device(struct hid_device *
 				hid_dump_field(report->field[k], 6, f);
 			}
--
 	while (ret == 0) {
 		if (list->head == list->tail) {
 			add_wait_queue(&list->hdev->debug_wait, &wait);
@@ -1019,6 +1035,12 @@ copy_rest:
 			goto copy_rest;
 		}
--
 	while (*pkeys != 0) {
 		set_bit(*pkeys, pm->input_ep82->keybit);
 		++pkeys;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (retval == 0) {
 		if (list->head == list->tail) {
 			prepare_to_wait(&list->hiddev->wait, &wait, TASK_INTERRUPTIBLE);
@@ -392,6 +397,11 @@ static ssize_t hiddev_read(struct file *
 		}
 
--
 		while (list->head != list->tail &&
 		       retval + event_size <= count) {
 			if ((list->flags & HIDDEV_FLAG_UREF) == 0) {
@@ -418,8 +428,20 @@ static ssize_t hiddev_read(struct file *
 				}
 			}
--
 	while (ret) {
 		err |= ret;
 		if (test_bit(HID_CTRL_RUNNING, &usbhid->iofl))
@@ -720,6 +725,12 @@ void usbhid_init_reports(struct hid_devi
 		if (test_bit(HID_OUT_RUNNING, &usbhid->iofl))
 			usb_kill_urb(usbhid->urbout);
--
-	while (wdata->head != wdata->tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (wdata->head != wdata->tail) {
 		spin_unlock_irqrestore(&wdata->qlock, flags);
 		wiimote_hid_send(wdata->hdev, wdata->outq[wdata->tail].data,
 						wdata->outq[wdata->tail].size);
 		spin_lock_irqsave(&wdata->qlock, flags);
 
--
 		while (--idx > 1) {
 			if (data[idx] < 0xE0 || data[idx] > 0xE7)
 				continue;
 			data[0] |= (1 << (data[idx] - 0xE0));
 			data[idx] = 0;
+			if (_cur < timeout) {
--
 	while ((start = fetch_item(start, end, &item)) != NULL) {
 
 		if (item.format != HID_ITEM_FORMAT_SHORT) {
@@ -706,6 +711,12 @@ int hid_parse_report(struct hid_device *
 			vfree(parser);
 			return 0;
--
-	while (n--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (n--) {
 		if (*array++ == value)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((fifo_size-- > 0) && (actual < len)) {
 		/* Transmit next byte */
 		outb(buf[actual], iobase + UART_TX);
 		actual++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count) {
 		struct sk_buff *skb = data->rx_skb[queue];
 		struct { __u8 type; int expect; } *scb;
@@ -159,6 +164,12 @@ static int bpa10x_recv(struct hci_dev *h
 		}
 
--
 	while (count) {
 		if (bcsp->rx_count) {
 			if (*ptr == 0xc0) {
@@ -660,6 +665,12 @@ static int bcsp_recv(struct hci_uart *hu
 			}
 			break;
--
 	while ((skb = __skb_dequeue_tail(&bcsp->unack)) != NULL) {
 		bcsp->msgq_txseq = (bcsp->msgq_txseq - 1) & 0x07;
 		skb_queue_head(&bcsp->rel, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (count) {
 		size = min_t(uint, count, BULK_SIZE);
 		pipe = usb_sndbulkpipe(udev, 0x02);
@@ -193,6 +198,12 @@ static int ath3k_load_firmware(struct us
 
 		sent  += size;
--
 	while (count) {
 		size = min_t(uint, count, BULK_SIZE);
 		pipe = usb_sndbulkpipe(udev, 0x02);
@@ -269,6 +285,12 @@ static int ath3k_load_fwfile(struct usb_
 		}
 		sent  += size;
--
 	while ((fifo_size-- > 0) && (actual < len)) {
 		/* Transmit next byte */
 		outb(buf[actual], iobase + UART_TX);
 		actual++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (actual < len) {
 		/* Transmit next byte */
 		bt3c_put(iobase, buf[actual]);
 		actual++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (size < avail) {
 		size++;
 		info->hdev->stat.byte_rx++;
@@ -329,6 +345,12 @@ static void bt3c_receive(bt3c_info_t *in
 
 		}
--
 	while (count) {
 		if (ptr[0] != 'S') {
 			BT_ERR("Bad address in firmware");
@@ -536,6 +563,12 @@ static int bt3c_load_firmware(bt3c_info_
 
 		ptr   += (size * 2) + 6;
--
 	while (tuple) {
 		BT_DBG("code 0x%x size %d", tuple->code, tuple->size);
 		tuple = tuple->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (n < len) {
 
 		if (i == 16) {
@@ -361,6 +366,12 @@ static int bluecard_read(unsigned int io
 		n++;
 		i++;
--
 	while ((skb = skb_dequeue(&data->pending_q))) {
 		urb = ((struct bfusb_data_scb *) skb->cb)->urb;
 		usb_kill_urb(urb);
 		skb_queue_tail(&data->completed_q, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((urb = bfusb_get_completed(data)))
@@ -362,6 +373,11 @@ static void bfusb_rx_complete(struct urb
 
 	skb_put(skb, count);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
--
 	while (count) {
 		hdr = buf[0] | (buf[1] << 8);
 
@@ -385,6 +401,12 @@ static void bfusb_rx_complete(struct urb
 
 		count -= len;
--
 	while (count) {
 		size = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE);
 
@@ -523,6 +550,12 @@ static int bfusb_send_frame(struct sk_bu
 
 		sent  += size;
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count) {
 		size = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE + 3);
 
 		memcpy(buf, firmware + sent, size);
@@ -602,6 +640,12 @@ static int bfusb_load_firmware(struct bf
 
--
 		while (wait_remove_device == devfreq) {
 			mutex_unlock(&devfreq_list_lock);
 			schedule();
 			mutex_lock(&devfreq_list_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		path = rb_entry(n, struct ipoib_path, rb_node);
 
 		ret = memcmp(gid, path->pathrec.dgid.raw,
@@ -227,6 +232,12 @@ static struct ipoib_path *__path_find(st
 			n = n->rb_right;
--
-	while (*n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*n) {
 		pn = *n;
 		tpath = rb_entry(pn, struct ipoib_path, rb_node);
 
@@ -252,6 +268,12 @@ static int __path_add(struct net_device
 			n = &pn->rb_right;
--
 	while ((skb = __skb_dequeue(&skqueue))) {
 		skb->dev = dev;
 		if (dev_queue_xmit(skb))
 			ipoib_warn(priv, "dev_queue_xmit failed "
 				   "to requeue packet\n");
+			if (_cur < timeout) {
--
 	while ((skb = __skb_dequeue(&neigh->queue))) {
 		++dev->stats.tx_dropped;
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&priv->cm.passive_ids)) {
 		p = list_entry(priv->cm.passive_ids.next, typeof(*p), list);
 		list_move(&p->list, &priv->cm.rx_error_list);
@@ -913,6 +918,12 @@ void ipoib_cm_dev_stop(struct net_device
 		if (ret)
 			ipoib_warn(priv, "unable to move qp to error state: %d\n", ret);
--
 	while ((skb = __skb_dequeue(&skqueue))) {
 		skb->dev = p->dev;
 		if (dev_queue_xmit(skb))
 			ipoib_warn(priv, "dev_queue_xmit failed "
 				   "to requeue packet\n");
+			if (_cur < timeout) {
--
-		while ((int) p->tx_tail - (int) p->tx_head < 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((int) p->tx_tail - (int) p->tx_head < 0) {
 			if (time_after(jiffies, begin + 5 * HZ)) {
 				ipoib_warn(priv, "timing out; %d sends not completed\n",
 					   p->tx_head - p->tx_tail);
@@ -1175,11 +1202,22 @@ static void ipoib_cm_tx_destroy(struct i
 			}
--
 	while ((int) p->tx_tail - (int) p->tx_head < 0) {
 		tx_req = &p->tx_ring[p->tx_tail & (ipoib_sendq_size - 1)];
 		ib_dma_unmap_single(priv->ca, tx_req->mapping, tx_req->skb->len,
@@ -1192,6 +1230,12 @@ timeout:
 		    test_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags))
 			netif_wake_queue(p->dev);
--
 	while (!list_empty(&priv->cm.start_list)) {
 		p = list_entry(priv->cm.start_list.next, typeof(*p), list);
 		list_del_init(&p->list);
@@ -1331,6 +1380,12 @@ static void ipoib_cm_tx_start(struct wor
 			list_del(&p->list);
 			kfree(p);
--
 	while (!list_empty(&priv->cm.reap_list)) {
 		p = list_entry(priv->cm.reap_list.next, typeof(*p), list);
 		list_del(&p->list);
@@ -1356,6 +1416,12 @@ static void ipoib_cm_tx_reap(struct work
 		ipoib_cm_tx_destroy(p);
 		netif_tx_lock_bh(dev);
--
 	while ((skb = skb_dequeue(&priv->cm.skb_queue))) {
 		spin_unlock_irqrestore(&priv->lock, flags);
 		netif_tx_unlock_bh(dev);
@@ -1388,6 +1459,12 @@ static void ipoib_cm_skb_reap(struct wor
 
 		netif_tx_lock_bh(dev);
--
 	while (!skb_queue_empty(&mcast->pkt_queue)) {
 		++tx_dropped;
 		dev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		struct ipoib_mcast *mcast;
 		int ret;
 
@@ -146,6 +162,12 @@ static struct ipoib_mcast *__ipoib_mcast
 			n = n->rb_right;
--
 	while (*n) {
 		struct ipoib_mcast *tmcast;
 		int ret;
@@ -171,6 +198,12 @@ static int __ipoib_mcast_add(struct net_
 			n = &pn->rb_right;
 		else
--
 	while (!skb_queue_empty(&mcast->pkt_queue)) {
 		struct sk_buff *skb = skb_dequeue(&mcast->pkt_queue);
 
@@ -280,6 +318,12 @@ static int ipoib_mcast_join_finish(struc
 			ipoib_warn(priv, "dev_queue_xmit failed to requeue packet\n");
 
--
 		while (!skb_queue_empty(&mcast->pkt_queue)) {
 			++dev->stats.tx_dropped;
 			dev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (n--) {
 		if (ipoib_mcast_iter_next(iter)) {
 			kfree(iter);
 			return NULL;
 		}
+		if (_cur < timeout) {
--
 	while (n--) {
 		if (ipoib_path_iter_next(iter)) {
 			kfree(iter);
 			return NULL;
 		}
+		if (_cur < timeout) {
--
 	while (priv->tx_head != priv->tx_tail || recvs_pending(dev)) {
 		if (time_after(jiffies, begin + 5 * HZ)) {
 			ipoib_warn(priv, "timing out; %d sends %d receives not completed\n",
@@ -839,13 +844,24 @@ int ipoib_ib_dev_stop(struct net_device
 			 * assume the HW is wedged and just free up
 			 * all our pending work requests.
--
-			while ((int) priv->tx_tail - (int) priv->tx_head < 0) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((int) priv->tx_tail - (int) priv->tx_head < 0) {
 				tx_req = &priv->tx_ring[priv->tx_tail &
 							(ipoib_sendq_size - 1)];
 				ipoib_dma_unmap_tx(priv->ca, tx_req);
 				dev_kfree_skb_any(tx_req->skb);
 				++priv->tx_tail;
--
 	while (ib_poll_cq(cq, 1, &wc) == 1) {
 		tx_desc	= (struct iser_tx_desc *) (unsigned long) wc.wr_id;
 		ib_conn = wc.qp->qp_context;
@@ -802,6 +807,12 @@ static int iser_drain_tx_cq(struct iser_
 			iser_handle_comp_error(tx_desc, ib_conn);
 		}
--
 	while (ib_poll_cq(cq, 1, &wc) == 1) {
 		desc	 = (struct iser_rx_desc *) (unsigned long) wc.wr_id;
 		BUG_ON(desc == NULL);
@@ -839,6 +855,12 @@ static void iser_cq_tasklet_fn(unsigned
 		completed_rx++;
 		if (!(completed_rx & 63))
--
 	/* Send data-out PDUs while there's still unsolicited data to send */
-	while (iscsi_task_has_unsol_data(task)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (iscsi_task_has_unsol_data(task)) {
 		iscsi_prep_data_out_pdu(task, r2t, &hdr);
 		iser_dbg("Sending data-out: itt 0x%x, data count %d\n",
 			   hdr.itt, r2t->data_count);
@@ -231,6 +236,12 @@ iscsi_iser_task_xmit_unsol_data(struct i
 		r2t->sent += r2t->data_count;
--
-	while ((cqe->owner_sr_opcode & MLX4_CQE_OPCODE_MASK) != MLX4_CQE_OPCODE_RESIZE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((cqe->owner_sr_opcode & MLX4_CQE_OPCODE_MASK) != MLX4_CQE_OPCODE_RESIZE) {
 		new_cqe = get_cqe_from_buf(&cq->resize_buf->buf,
 					   (i + 1) & cq->resize_buf->cqe);
 		memcpy(new_cqe, get_cqe(cq, i & cq->ibcq.cqe), sizeof(struct mlx4_cqe));
 		new_cqe->owner_sr_opcode = (cqe->owner_sr_opcode & ~MLX4_CQE_OWNER_MASK) |
 			(((i + 1) & (cq->resize_buf->cqe + 1)) ? MLX4_CQE_OWNER_MASK : 0);
--
 	while ((int) --prod_index - (int) cq->mcq.cons_index >= 0) {
 		cqe = get_cqe(cq, prod_index & cq->ibcq.cqe);
 		if ((be32_to_cpu(cqe->vlan_my_qpn) & MLX4_CQE_QPN_MASK) == qpn) {
@@ -800,6 +816,12 @@ void __mlx4_ib_cq_clean(struct mlx4_ib_c
 			dest->owner_sr_opcode = owner_bit |
 				(dest->owner_sr_opcode & ~MLX4_CQE_OWNER_MASK);
--
 	while (start < end) {
 		if (avail) {
 			unsigned long dma;
@@ -1719,6 +1724,12 @@ void ipath_chg_pioavailkernel(struct ipa
 			__clear_bit(start, dd->ipath_pioavailkernel);
 		}
--
 	while (clock_cycles_left--) {
 		scl_out(dd, i2c_line_high);
 
@@ -396,6 +401,12 @@ static int eeprom_reset(struct ipath_dev
 		}
 
--
 	while (len-- > 0) {
 		/* get and store data */
 		*bp++ = rd_byte(dd);
 		/* send ack if not the last byte */
 		if (len)
 			send_ack(dd);
--
-	while (len > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (len > 0) {
 		if (icd->eeprom_dev == IPATH_NO_DEV) {
 			if (i2c_startcmd(dd,
 					 (eeprom_offset << 1) | WRITE_CMD)) {
@@ -607,17 +634,34 @@ static int ipath_eeprom_internal_write(s
 		 * whether we have real eeprom_dev. legacy likes any address.
--
-		while (i2c_startcmd(dd, icd->eeprom_dev | READ_CMD)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i2c_startcmd(dd, icd->eeprom_dev | READ_CMD)) {
 			stop_cmd(dd);
 			if (!--max_wait_time) {
 				ipath_dbg("Did not get successful read to "
 					  "complete write\n");
 				goto failed_write;
--
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		int ret;
 
 		mcast = rb_entry(n, struct ipath_mcast, rb_node);
@@ -142,6 +147,12 @@ struct ipath_mcast *ipath_mcast_find(uni
 			spin_unlock_irqrestore(&mcast_lock, flags);
--
 	while (*n) {
 		struct ipath_mcast *tmcast;
 		struct ipath_mcast_qp *p;
@@ -205,6 +221,12 @@ static int ipath_mcast_add(struct ipath_
 		list_add_tail_rcu(&mqp->list, &tmcast->qp_list);
 		ret = EEXIST;
--
 	while (1) {
 		if (n == NULL) {
 			spin_unlock_irq(&mcast_lock);
@@ -312,6 +339,12 @@ int ipath_multicast_detach(struct ib_qp
 			n = n->rb_right;
 		else
--
 		while (tail != head) {
 			wc.wr_id = get_rwqe_ptr(&qp->r_rq, tail)->wr_id;
 			if (++tail >= qp->r_rq.size)
 				tail = 0;
 			ipath_cq_enter(to_icq(qp->ibqp.recv_cq), &wc, 1);
+			if (_cur < timeout) {
--
 		while (tail != head) {
 			struct ipath_rwqe *wqe;
 			int i;
@@ -295,6 +300,12 @@ int ipath_modify_srq(struct ib_srq *ibsr
 			p = (struct ipath_rwqe *)((char *) p + sz);
 			if (++tail >= srq->rq.size)
--
 	while (reg_addr < reg_end) {
 		u64 data = readq(reg_addr);
 		if (copy_to_user(uaddr, &data, sizeof(u64))) {
@@ -155,6 +160,12 @@ static int ipath_read_umem64(struct ipat
 		}
 		reg_addr++;
--
 	while (reg_addr < reg_end) {
 		u64 data;
 		if (copy_from_user(&data, uaddr, sizeof(data))) {
@@ -194,6 +210,12 @@ static int ipath_write_umem64(struct ipa
 
 		reg_addr++;
--
 	while (reg_addr < reg_end) {
 		u32 data = readl(reg_addr);
 		if (copy_to_user(uaddr, &data, sizeof(data))) {
@@ -233,6 +260,12 @@ static int ipath_read_umem32(struct ipat
 		reg_addr++;
 		uaddr += sizeof(u32);
--
 	while (reg_addr < reg_end) {
 		u32 data;
 		if (copy_from_user(&data, uaddr, sizeof(data))) {
@@ -272,6 +310,12 @@ static int ipath_write_umem32(struct ipa
 
 		reg_addr++;
--
 	while (i) {
 		i--;
 		kfree(mr->mr.map[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (i) {
 		i--;
 		kfree(mr->mr.map[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (off >= mr->map[m]->segs[n].length) {
 		off -= mr->map[m]->segs[n].length;
 		n++;
@@ -171,6 +176,12 @@ int ipath_lkey_ok(struct ipath_qp *qp, s
 			m++;
 			n = 0;
--
 	while (off >= mr->map[m]->segs[n].length) {
 		off -= mr->map[m]->segs[n].length;
 		n++;
@@ -253,6 +269,12 @@ int ipath_rkey_ok(struct ipath_qp *qp, s
 			m++;
 			n = 0;
--
 	while (dd->ipath_sdma_descq_head != dmahead) {
 		if (txp && txp->flags & IPATH_SDMA_TXREQ_F_FREEDESC &&
 		    dd->ipath_sdma_descq_head == start_idx) {
@@ -147,6 +152,12 @@ int ipath_sdma_make_progress(struct ipat
 			}
 		}
--
-	while (tail != dd->ipath_sdma_descq_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tail != dd->ipath_sdma_descq_tail) {
 		if (!tail)
 			tail = dd->ipath_sdma_descq_cnt - 1;
 		else
 			tail--;
 		unmap_desc(dd, tail);
--
 	while (j) {
 		struct qib_sge *sge = --j ? &ss->sg_list[j - 1] : &ss->sge;
 
 		atomic_dec(&sge->mr->refcount);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-		while (qp->r_sge.num_sge) {
-			atomic_dec(&qp->r_sge.sge.mr->refcount);
-			if (--qp->r_sge.num_sge)
+	if (release) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
--
+			while (qp->r_sge.num_sge) {
+				atomic_dec(&qp->r_sge.sge.mr->refcount);
+				if (--qp->r_sge.num_sge)
 				qp->r_sge.sge = *qp->r_sge.sg_list++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!(piobuf = get_7220_link_buf(ppd, &pnum))) {
 		if (i++ > 5)
 			return;
 		udelay(2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		int ret;
 
 		mcast = rb_entry(n, struct qib_mcast, rb_node);
@@ -132,6 +137,12 @@ struct qib_mcast *qib_mcast_find(struct
 			spin_unlock_irqrestore(&ibp->lock, flags);
--
 	while (*n) {
 		struct qib_mcast *tmcast;
 		struct qib_mcast_qp *p;
@@ -194,6 +210,12 @@ static int qib_mcast_add(struct qib_ibde
 		list_add_tail_rcu(&mqp->list, &tmcast->qp_list);
 		ret = EEXIST;
--
 	while (1) {
 		if (n == NULL) {
 			spin_unlock_irq(&ibp->lock);
@@ -316,6 +343,12 @@ int qib_multicast_detach(struct ib_qp *i
 			n = n->rb_right;
 		else
--
 		while (off >= mr->map[m]->segs[n].length) {
 			off -= mr->map[m]->segs[n].length;
 			n++;
@@ -197,6 +202,12 @@ int qib_lkey_ok(struct qib_lkey_table *r
 				m++;
 				n = 0;
--
 		while (off >= mr->map[m]->segs[n].length) {
 			off -= mr->map[m]->segs[n].length;
 			n++;
@@ -291,6 +307,12 @@ int qib_rkey_ok(struct qib_qp *qp, struc
 				m++;
 				n = 0;
--
 	while (qp->r_sge.num_sge) {
 		atomic_dec(&qp->r_sge.sge.mr->refcount);
 		if (--qp->r_sge.num_sge)
 			qp->r_sge.sge = *qp->r_sge.sg_list++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (qp->r_sge.num_sge) {
 		atomic_dec(&qp->r_sge.sge.mr->refcount);
 		if (--qp->r_sge.num_sge)
 			qp->r_sge.sge = *qp->r_sge.sg_list++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (cnt < len) {
 		unsigned in_page;
 		int wlen = len - cnt;
@@ -113,6 +118,12 @@ static int qsfp_read(struct qib_pportdat
 		}
 		addr += wlen;
--
 	while (cnt < len) {
 		unsigned in_page;
 		int wlen = len - cnt;
@@ -217,6 +233,12 @@ static int qib_qsfp_write(struct qib_ppo
 		}
 		addr += wlen;
--
 	while (first < next) {
 		ret = qsfp_read(ppd, first, &bval, 1);
 		if (ret < 0)
 			goto bail;
 		cks += bval;
 		++first;
--
 	while (bidx < QSFP_DEFAULT_HDR_CNT) {
 		int iidx;
 		ret = qsfp_read(ppd, bidx, bin_buff, QSFP_DUMP_CHUNK);
@@ -549,6 +587,12 @@ int qib_qsfp_dump(struct qib_pportdata *
 		}
 		sofar += scnprintf(buf + sofar, len - sofar, "\n");
--
 		while (tail != head) {
 			struct qib_rwqe *wqe;
 			int i;
@@ -291,6 +296,12 @@ int qib_modify_srq(struct ib_srq *ibsrq,
 			p = (struct qib_rwqe *)((char *) p + sz);
 			if (++tail >= srq->rq.size)
--
 	while (clock_cycles_left--) {
 		scl_out(dd, 0);
 		scl_out(dd, 1);
 		/* Note if SDA is high, but keep clocking to sync slave */
 		was_high |= sda_in(dd, 0);
+		if (_cur < timeout) {
--
 	while (len-- > 0) {
 		/*
 		 * Get and store data, sending ACK if length remaining,
 		 * else STOP
 		 */
 		*bp++ = rd_byte(dd, !len);
--
-	while (len > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (len > 0) {
 		if (dev == QIB_TWSI_NO_DEV) {
 			if (qib_twsi_wr(dd, (addr << 1) | WRITE_CMD,
 					QIB_TWSI_START)) {
@@ -477,13 +504,30 @@ int qib_twsi_blk_wr(struct qib_devdata *
 		 * whether we have real eeprom_dev. Legacy likes any address.
--
 		while (qib_twsi_wr(dd, dev | READ_CMD, QIB_TWSI_START)) {
 			stop_cmd(dd);
 			if (!--max_wait_time)
 				goto failed_write;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
-			while (idx != txp->next_descq_idx) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+		while (idx != txp->next_descq_idx) {
 				unmap_desc(ppd, idx);
 				if (++idx == ppd->sdma_descq_cnt)
 					idx = 0;
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (ppd->sdma_descq_head != hwhead) {
 		/* if desc is part of this txp, unmap if needed */
 		if (txp && (txp->flags & QIB_SDMA_TXREQ_F_FREEDESC) &&
@@ -400,6 +416,12 @@ int qib_sdma_make_progress(struct qib_pp
 			}
 		}
--
 	while (client_pool) {
 		dc = client_pool;
 		client_pool = dc->next;
 		kfree(dc);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (reg_addr < reg_end) {
 		u64 data = readq(reg_addr);
 
@@ -358,6 +374,12 @@ static int qib_read_umem64(struct qib_de
 		}
 		reg_addr++;
--
 	while (reg_addr < reg_end) {
 		u64 data;
 		if (copy_from_user(&data, uaddr, sizeof(data))) {
@@ -403,6 +430,12 @@ static int qib_write_umem64(struct qib_d
 
 		reg_addr++;
--
 	while (reg_addr < reg_end) {
 		u32 data = readl(reg_addr);
 
@@ -448,6 +486,12 @@ static int qib_read_umem32(struct qib_de
 		reg_addr++;
 		uaddr += sizeof(u32);
--
 	while (reg_addr < reg_end) {
 		u32 data;
 
@@ -493,6 +542,12 @@ static int qib_write_umem32(struct qib_d
 
 		reg_addr++;
--
 	while (olp) {
 		/* Pop one observer, let go of lock */
 		dd->diag_observer_list = olp->next;
@@ -726,6 +786,12 @@ static void qib_unregister_observers(str
 		/* try again. */
 		spin_lock_irqsave(&dd->qib_diag_trans_lock, flags);
--
 		while (qp->r_sge.num_sge) {
 			atomic_dec(&qp->r_sge.sge.mr->refcount);
 			if (--qp->r_sge.num_sge)
 				qp->r_sge.sge = *qp->r_sge.sg_list++;
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (start < end) {
 		if (avail) {
 			unsigned long dma;
@@ -428,6 +433,12 @@ void qib_chg_pioavailkernel(struct qib_d
 			__clear_bit(start, dd->pioavailkernel);
 		}
--
 	while (errs && msp && msp->mask) {
 		multi = (msp->mask & (msp->mask - 1));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (errs & msp->mask) {
 			these = (errs & msp->mask);
 			lmask = (these & (these - 1)) ^ these;
@@ -1324,16 +1334,39 @@ static void err_decode(char *msg, size_t
 				/* More than one bit this mask */
 				int idx = -1;
--
 				while (lmask & msp->mask) {
 					++idx;
 					lmask >>= 1;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
--
 	while (!(piobuf = qib_7322_getsendbuf(ppd, pbc, &pnum))) {
 		if (i++ > 15)
 			return;
 		udelay(2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (chan_done &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (chan_done &&
 	       !time_after64(get_jiffies_64(),
 			tstart + msecs_to_jiffies(500))) {
 		msleep(20);
@@ -7631,6 +7680,12 @@ static int serdes_7322_init_new(struct q
 			    (~chan_done & (1 << chan)) == 0)
--
-		while (qp->s_rdma_read_sge.num_sge) {
-			atomic_dec(&qp->s_rdma_read_sge.sge.mr->refcount);
-			if (--qp->s_rdma_read_sge.num_sge)
-				qp->s_rdma_read_sge.sge =
-					*qp->s_rdma_read_sge.sg_list++;
+	if (test_and_clear_bit(QIB_R_REWIND_SGE, &qp->r_aflags)) {
--
+			while (qp->s_rdma_read_sge.num_sge) {
+				atomic_dec(&qp->s_rdma_read_sge.sge.mr->refcount);
+				if (--qp->s_rdma_read_sge.num_sge)
+			qp->s_rdma_read_sge.sge =
+			*qp->s_rdma_read_sge.sg_list++;
+			if (_cur < timeout) {
--
 	while (qp->r_sge.num_sge) {
 		atomic_dec(&qp->r_sge.sge.mr->refcount);
 		if (--qp->r_sge.num_sge)
 			qp->r_sge.sge = *qp->r_sge.sg_list++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (qp->s_last != qp->s_head) {
 			struct qib_swqe *wqe = get_swqe_ptr(qp, qp->s_last);
 			unsigned i;
@@ -435,6 +463,12 @@ static void clear_mr_refs(struct qib_qp
 				atomic_dec(&to_iah(wqe->wr.wr.ud.ah)->refcount);
 			if (++qp->s_last >= qp->s_size)
--
 		while (tail != head) {
 			wc.wr_id = get_rwqe_ptr(&qp->r_rq, tail)->wr_id;
 			if (++tail >= qp->r_rq.size)
 				tail = 0;
 			qib_cq_enter(to_icq(qp->ibqp.recv_cq), &wc, 1);
+			if (_cur < timeout) {
--
 	while (count > 0) {
 		/*
 		 * If the addition of this SGE causes the
@@ -686,6 +691,12 @@ move_sgl(struct c2_data_addr * dst, stru
 		}
 		src++;
--
-	while (msg == NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (msg == NULL) {
 		pr_debug("%s:%d no available msg in VQ, waiting...\n",
 		       __func__, __LINE__);
 		init_waitqueue_entry(&__wait, current);
@@ -218,6 +223,12 @@ int vq_send_wr(struct c2_dev *c2dev, uni
 		remove_wait_queue(&c2dev->req_vq_wo, &__wait);
--
 		while (priv != be16_to_cpu(*q->shared)) {
 			msg = (struct c2wr_ce *)
 				(q->msg_pool.host + priv * q->msg_size);
@@ -101,6 +106,12 @@ void c2_cq_clean(struct c2_dev *c2dev, s
 				msg->qp_user_context = (u64) 0;
 			}
--
 	while ((qp =
 		(struct c2_qp *) (unsigned long) ce->qp_user_context) == NULL) {
 		c2_mq_free(&cq->mq);
 		ce = c2_mq_consume(&cq->mq);
 		if (!ce)
 			return -EAGAIN;
--
 	while (pbl_depth) {
 		count = min(pbe_count, pbl_depth);
 		wr->addrs_length = cpu_to_be32(count);
@@ -142,6 +147,12 @@ send_pbl_messages(struct c2_dev *c2dev,
 		}
 		pbl_depth -= count;
--
-	while (root) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (root) {
 		next = root->next;
 		dma_free_coherent(&c2dev->pcidev->dev, PAGE_SIZE, root,
 				  dma_unmap_addr(root, mapping));
 		root = next;
+		if (_cur < timeout) {
--
 	while (head) {
 		mqsp = head->head;
 		if (mqsp != 0xFFFF) {
@@ -107,6 +123,12 @@ __be16 *c2_alloc_mqsp(struct c2_dev *c2d
 				return NULL;
 		} else
--
 	while (wqe_count--) {
 		BUG_ON(c2_mq_empty(q));
 		*q->shared = cpu_to_be16((be16_to_cpu(*q->shared)+1) % q->q_size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (offset < optionsize) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset < optionsize) {
 		all_options = (union all_known_options *)(optionsloc + offset);
 		switch (all_options->as_base.optionnum) {
 		case OPTION_NUMBER_END:
@@ -1587,6 +1592,12 @@ static int process_options(struct nes_cm
 			break;
--
 	while (nesvnic->nic.rq_head != nesvnic->nic.rq_tail) {
 		rx_skb = nesvnic->nic.rx_skb[nesvnic->nic.rq_tail];
 		cb = (struct nes_rskb_cb *)&rx_skb->cb[0];
@@ -1942,9 +1947,20 @@ void nes_destroy_nic_qp(struct nes_vnic
 
 		dev_kfree_skb(nesvnic->nic.rx_skb[nesvnic->nic.rq_tail++]);
--
 	while (nesvnic->nic.sq_head != nesvnic->nic.sq_tail) {
 		nic_sqe = &nesvnic->nic.sq_vbase[nesvnic->nic.sq_tail];
 		wqe_fragment_index = 1;
@@ -1995,6 +2011,12 @@ void nes_destroy_nic_qp(struct nes_vnic
 
 		nesvnic->nic.sq_tail = (nesvnic->nic.sq_tail + 1)
--
-	while ((!list_empty(&nesdev->cqp_pending_reqs)) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((!list_empty(&nesdev->cqp_pending_reqs)) &&
 			((((nesdev->cqp.sq_tail+nesdev->cqp.sq_size)-nesdev->cqp.sq_head) &
 			(nesdev->cqp.sq_size - 1)) != 1)) {
 		cqp_request = list_entry(nesdev->cqp_pending_reqs.next,
@@ -3115,6 +3142,12 @@ static void nes_cqp_ce_handler(struct ne
 		/* Ring doorbell (1 WQEs) */
--
 	while (nesdev->netdev_count > 0) {
 		nesdev->netdev_count--;
 		nesdev->nesadapter->netdev_count--;
 
 		unregister_netdev(nesdev->netdev[nesdev->netdev_count]);
 		nes_netdev_destroy(nesdev->netdev[nesdev->netdev_count]);
--
 	while (1) {
 		rc = get_fpdu_info(nesdev, nesqp, &fpdu_info);
 		if (fpdu_info == NULL)
@@ -475,6 +480,12 @@ static int forward_fpdus(struct nes_vnic
 
 		atomic_set(&cqp_request->refcount, 1);
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		wait_event_interruptible(nesvnic->mgt_wait_queue,
 					 skb_queue_len(&nesvnic->mgt_skb_list) || kthread_should_stop());
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while ((skb_queue_len(&nesvnic->mgt_skb_list)) && !kthread_should_stop()) {
 			skb = skb_dequeue(&nesvnic->mgt_skb_list);
 			cb = (struct nes_rskb_cb *)&skb->cb[0];
@@ -591,15 +612,38 @@ static int mgt_thread(void *context)
 			cb->busaddr = pci_map_single(nesvnic->nesdev->pcidev, cb->data_start,
 						     nesvnic->max_frame_size, PCI_DMA_TODEVICE);
--
 	while (skb_queue_len(&nesvnic->mgt_skb_list)) {
 		skb = skb_dequeue(&nesvnic->mgt_skb_list);
 		cb = (struct nes_rskb_cb *)&skb->cb[0];
 		nes_rem_ref_cm_node(cb->nesqp->cm_node);
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
--
 	while (skb_queue_len(&nesqp->pau_list)) {
 		skb = skb_dequeue(&nesqp->pau_list);
 		nes_mgt_free_skb(nesdev, skb, PCI_DMA_TODEVICE);
 		nes_rem_ref_cm_node(nesqp->cm_node);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (mgtvnic->mgt.rq_head != mgtvnic->mgt.rq_tail) {
 			rx_skb = mgtvnic->mgt.rx_skb[mgtvnic->mgt.rq_tail];
 			nes_mgt_free_skb(nesdev, rx_skb, PCI_DMA_FROMDEVICE);
 			mgtvnic->mgt.rq_tail++;
 			mgtvnic->mgt.rq_tail &= (mgtvnic->mgt.rq_size - 1);
+			if (_cur < timeout) {
--
-			while (nesadapter->pft_mcast_map[mc_index] < 16 &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (nesadapter->pft_mcast_map[mc_index] < 16 &&
 				nesadapter->pft_mcast_map[mc_index] !=
 					nesvnic->nic_index &&
 					mc_index < max_pft_entries_avaiable) {
@@ -939,6 +944,12 @@ static void nes_netdev_set_multicast_lis
 					nesvnic->nic_index,
--
 		while (((nes_read32(nesdev->regs+NES_SOFTWARE_RESET)
 				& 0x00000040) != 0x00000040) && (i++ < 5000)) {
 			/* mdelay(1); */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (num_ascii < 17) {
 			if (num_ascii == 8) {
 				hex_buf[num_hex++] = ' ';
@@ -965,6 +981,12 @@ void nes_dump_mem(unsigned int dump_debu
 			hex_buf[num_hex++] = ' ';
 			hex_buf[num_hex++] = ' ';
--
 	while (le32_to_cpu(nescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_OPCODE_IDX]) & NES_CQE_VALID) {
 		rmb();
 		lo = le32_to_cpu(nescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_COMP_COMP_CTX_LOW_IDX]);
@@ -1444,6 +1449,12 @@ static void nes_clean_cq(struct nes_qp *
 
 		if (++cq_head >= nescq->hw_cq.cq_size)
--
 	while (wqe_count) {
 		counter = min(wqe_count, ((u32)255));
 		wqe_count -= counter;
 		nes_write32(nesdev->regs + NES_WQE_ALLOC,
 				(counter << 24) | 0x00800000 | nesqp->hwqp.qp_id);
+		if (_cur < timeout) {
--
 	while (wqe_count) {
 		counter = min(wqe_count, ((u32)255));
 		wqe_count -= counter;
 		nes_write32(nesdev->regs+NES_WQE_ALLOC, (counter<<24) | nesqp->hwqp.qp_id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (i > 0) {
 				i--;
 				device_remove_file(&nesibdev->ibdev.dev,
 						   nes_dev_attributes[i]);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (size > 0) {
 		PDBG("TPT %08x: %016llx\n", m->addr, (unsigned long long) *data);
 		size -= 8;
 		data++;
 		m->addr += 8;
+		if (_cur < timeout) {
--
 	while (size > 0) {
 		PDBG("PBL %08x: %016llx\n", m->addr, (unsigned long long) *data);
 		size -= 8;
 		data++;
 		m->addr += 8;
+		if (_cur < timeout) {
--
-	while (size > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size > 0) {
 		PDBG("WQE %p: %016llx\n", data,
 		     (unsigned long long) be64_to_cpu(*data));
 		size--;
 		data++;
+		if (_cur < timeout) {
--
-	while (size > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size > 0) {
 		PDBG("WCE %p: %016llx\n", data,
 		     (unsigned long long) be64_to_cpu(*data));
 		size -= 8;
 		data++;
+		if (_cur < timeout) {
--
 	while (size > 0) {
 		PDBG("RQT %08x: %016llx\n", m->addr, (unsigned long long) *data);
 		size -= 8;
 		data++;
 		m->addr += 8;
+		if (_cur < timeout) {
--
 	while (size > 0) {
 		printk("%2u: %08x %08x %08x %08x %08x %08x %08x %08x\n",
 			m->addr,
@@ -201,6 +261,12 @@ void cxio_dump_tcb(struct cxio_rdev *rde
 		size -= 32;
 		data += 8;
--
 	while ((skb = skb_dequeue(&rxq))) {
 		ep = *((void **) (skb->cb));
 		tdev = *((struct t3cdev **) (skb->cb + sizeof(void *)));
@@ -2188,6 +2193,12 @@ static void process_work(struct work_str
 		 * ep was referenced in sched(), and is freed here.
 		 */
--
-	while (pbl_start < rdev_p->rnic_info.pbl_top) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pbl_start < rdev_p->rnic_info.pbl_top) {
 		pbl_chunk = min(rdev_p->rnic_info.pbl_top - pbl_start + 1,
 				pbl_chunk);
 		if (gen_pool_add(rdev_p->pbl_pool, pbl_start, pbl_chunk, -1)) {
@@ -295,6 +300,12 @@ int cxio_hal_pblpool_create(struct cxio_
 			     __func__, pbl_start, pbl_chunk);
--
 	while ((count+1) != 0 && fw_riwrh_opcode((struct fw_riwrh *)wqe) == T3_WR_RCV) {
 		count++;
 		wqe++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while (!CQ_VLD_ENTRY(rptr, cq->size_log2, cqe)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!CQ_VLD_ENTRY(rptr, cq->size_log2, cqe)) {
 			udelay(1);
 			if (i++ > 1000000) {
 				printk(KERN_ERR "%s: stalled rnic\n",
 				       rdev_p->dev_name);
 				return -EIO;
--
 	while (ptr++ != wq->rq_wptr) {
 		insert_recv_cqe(wq, cq);
 		flushed++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (ptr != wq->sq_wptr) {
 		sqp->signaled = 0;
 		insert_sq_cqe(wq, cq, sqp);
 		ptr++;
 		sqp = wq->sq + Q_PTR2IDX(ptr, wq->sq_size_log2);
 		flushed++;
--
-	while (cqe) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cqe) {
 		PDBG("%s flushing hwcq rptr 0x%x to swcq wptr 0x%x\n",
 		     __func__, cq->rptr, cq->sw_wptr);
 		swcqe = cq->sw_queue + Q_PTR2IDX(cq->sw_wptr, cq->size_log2);
@@ -440,6 +478,12 @@ void cxio_flush_hw_cq(struct t3_cq *cq)
 		cq->sw_wptr++;
--
 	while (!Q_EMPTY(ptr, cq->sw_wptr)) {
 		cqe = cq->sw_queue + (Q_PTR2IDX(ptr, cq->size_log2));
 		if ((SQ_TYPE(*cqe) ||
@@ -475,6 +524,12 @@ void cxio_count_scqes(struct t3_cq *cq,
 		    (CQE_QPID(*cqe) == wq->qpid))
 			(*count)++;
--
 	while (!Q_EMPTY(ptr, cq->sw_wptr)) {
 		cqe = cq->sw_queue + (Q_PTR2IDX(ptr, cq->size_log2));
 		if (RQ_TYPE(*cqe) && (CQE_OPCODE(*cqe) != T3_READ_RESP) &&
 		    (CQE_QPID(*cqe) == wq->qpid) && cqe_completes_wr(cqe, wq))
 			(*count)++;
 		ptr++;
--
 	while (Q_PTR2IDX(rptr, wq->sq_size_log2) != wptr) {
 		wq->oldest_read = wq->sq + Q_PTR2IDX(rptr, wq->sq_size_log2);
 
 		if (wq->oldest_read->opcode == T3_READ_REQ)
 			return;
 		rptr++;
--
 		while (rem) {
 			if (dstp == (u8 *)&sq->queue[sq->size])
 				dstp = (u8 *)sq->queue;
@@ -312,6 +317,12 @@ static int build_immd(struct t4_sq *sq,
 			dstp += len;
 			srcp += len;
--
 	while (rem) {
 		*p = 0;
 		rem -= sizeof *p;
 		if (++p == (__be64 *)&sq->queue[sq->size])
 			p = (__be64 *)sq->queue;
+			if (_cur < timeout) {
--
 	while (pbl_start < pbl_top) {
 		pbl_chunk = min(pbl_top - pbl_start + 1, pbl_chunk);
 		if (gen_pool_add(rdev->pbl_pool, pbl_start, pbl_chunk, -1)) {
@@ -354,6 +359,12 @@ int c4iw_pblpool_create(struct c4iw_rdev
 			     __func__, pbl_start, pbl_chunk);
 			pbl_start += pbl_chunk;
--
 	while (rqt_start < rqt_top) {
 		rqt_chunk = min(rqt_top - rqt_start + 1, rqt_chunk);
 		if (gen_pool_add(rdev->rqt_pool, rqt_start, rqt_chunk, -1)) {
@@ -415,6 +431,12 @@ int c4iw_rqtpool_create(struct c4iw_rdev
 			     __func__, rqt_start, rqt_chunk);
 			rqt_start += rqt_chunk;
--
 	while (start < top) {
 		chunk = min(top - start + 1, chunk);
 		if (gen_pool_add(rdev->ocqp_pool, start, chunk, -1)) {
@@ -471,6 +498,12 @@ int c4iw_ocqp_pool_create(struct c4iw_rd
 			     __func__, start, chunk);
 			start += chunk;
--
 	while (in_use--) {
 		insert_recv_cqe(wq, cq);
 		flushed++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (in_use--) {
 		swsqe->signaled = 0;
 		insert_sq_cqe(wq, cq, swsqe);
@@ -239,6 +255,12 @@ int c4iw_flush_sq(struct t4_wq *wq, stru
 		if (swsqe == (wq->sq.sw_sq + wq->sq.size))
 			swsqe = wq->sq.sw_sq;
--
-	while (!ret) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!ret) {
 		PDBG("%s flushing hwcq cidx 0x%x swcq pidx 0x%x\n",
 		     __func__, cq->cidx, cq->sw_pidx);
 		swcqe = &cq->sw_queue[cq->sw_pidx];
@@ -262,6 +289,12 @@ void c4iw_flush_hw_cq(struct t4_cq *cq)
 		t4_swcq_produce(cq);
--
 	while (ptr != cq->sw_pidx) {
 		cqe = &cq->sw_queue[ptr];
 		if ((SQ_TYPE(cqe) || ((CQE_OPCODE(cqe) == FW_RI_READ_RESP) &&
@@ -296,6 +334,12 @@ void c4iw_count_scqes(struct t4_cq *cq,
 			(*count)++;
 		if (++ptr == cq->size)
--
 	while (ptr != cq->sw_pidx) {
 		cqe = &cq->sw_queue[ptr];
 		if (RQ_TYPE(cqe) && (CQE_OPCODE(cqe) != FW_RI_READ_RESP) &&
@@ -315,6 +364,12 @@ void c4iw_count_rcqes(struct t4_cq *cq,
 			(*count)++;
 		if (++ptr == cq->size)
--
 	while (rptr != wq->sq.pidx) {
 		wq->sq.oldest_read = &wq->sq.sw_sq[rptr];
 
@@ -379,6 +439,12 @@ static void advance_oldest_read(struct t
 			return;
 		if (++rptr == wq->sq.size)
--
 		while (hwentries > T4_MAX_IQ_SIZE) {
 			memsize -= PAGE_SIZE;
 			hwentries = memsize / sizeof *chp->cq.queue;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!list_empty(&timeout_list)) {
 		struct list_head *tmp;
 
@@ -2609,6 +2614,12 @@ static void process_timedout_eps(void)
 		ep = list_entry(tmp, struct c4iw_ep, entry);
 		process_timeout(ep);
--
 	while ((skb = skb_dequeue(&rxq))) {
 		rpl = cplhdr(skb);
 		dev = *((struct c4iw_dev **) (skb->cb + sizeof(void *)));
@@ -2630,6 +2646,12 @@ static void process_work(struct work_str
 		ret = work_handlers[opcode](dev, skb);
 		if (!ret)
--
 		while (t & ((1 << shift) - 1)) {
 			--shift;
 			npages *= 2;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (o > order) {
 		--o;
 		seg <<= 1;
 		set_bit(seg ^ 1, buddy->bits[o]);
 		++buddy->num_free[o];
+		if (_cur < timeout) {
--
 	while (test_bit(seg ^ 1, buddy->bits[order])) {
 		clear_bit(seg ^ 1, buddy->bits[order]);
 		--buddy->num_free[order];
 		seg >>= 1;
 		++order;
+		if (_cur < timeout) {
--
-	while (list_len > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (list_len > 0) {
 		mtt_entry[0] = cpu_to_be64(dev->mr_table.mtt_base +
 					   mtt->first_seg * dev->limits.mtt_seg_size +
 					   start_index * 8);
@@ -289,6 +316,12 @@ static int __mthca_write_mtt(struct mthc
 		list_len    -= i;
--
-	while (list_len > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (list_len > 0) {
 		chunk = min(size, list_len);
 		if (mthca_is_memfree(dev))
 			mthca_arbel_write_mtt_seg(dev, mtt, start_index,
@@ -377,6 +415,12 @@ int mthca_write_mtt(struct mthca_dev *de
 		list_len    -= chunk;
--
 	while ((eqe = next_eqe_sw(eq))) {
 		/*
 		 * Make sure we read EQ entry contents after we've
@@ -379,6 +384,12 @@ static int mthca_eq_int(struct mthca_dev
 			set_eq_ci(dev, eq, eq->cons_index);
 			set_ci = 0;
--
 	while ((int) --prod_index - (int) cq->cons_index >= 0) {
 		cqe = get_cqe(cq, prod_index & cq->ibcq.cqe);
 		if (cqe->my_qpn == cpu_to_be32(qpn)) {
@@ -314,6 +319,12 @@ void mthca_cq_clean(struct mthca_dev *de
 		} else if (nfreed)
 			memcpy(get_cqe(cq, (prod_index + nfreed) & cq->ibcq.cqe),
--
 		while (go_bit(dev) && time_before(jiffies, end)) {
 			set_current_state(TASK_RUNNING);
 			schedule();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (go_bit(dev) && time_before(jiffies, end)) {
 		set_current_state(TASK_RUNNING);
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (npages > 0) {
 		if (!chunk) {
 			chunk = kmalloc(sizeof *chunk,
@@ -201,6 +206,12 @@ struct mthca_icm *mthca_alloc_icm(struct
 			if (cur_order < 0)
 				goto fail;
--
 	while (i > start) {
 		i -= inc;
 		mthca_table_put(dev, table, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (send_wr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (send_wr) {
 		struct ib_mad_hdr *mad_hdr = send_wr->wr.ud.mad_hdr;
 		struct ib_sge *sge = send_wr->sg_list;
 		ehca_gen_dbg("send_wr#%x wr_id=%lx num_sge=%x "
@@ -147,6 +152,12 @@ static void trace_send_wr_ud(const struc
 		} /* eof for j */
--
 	} /* eof while send_wr */
 }
 
@@ -478,6 +489,11 @@ int ehca_post_send(struct ib_qp *qp,
 	}
 
--
 	while (send_wr) {
 		ret = post_one_send(my_qp, send_wr, 0);
 		if (unlikely(ret)) {
@@ -485,6 +501,12 @@ int ehca_post_send(struct ib_qp *qp,
 		}
 		wqe_cnt++;
--
 	while (recv_wr) {
 		u64 start_offset = my_qp->ipz_rqueue.current_q_offset;
 		/* get pointer next to free WQE */
@@ -564,6 +591,12 @@ static int internal_post_recv(struct ehc
 
 		wqe_cnt++;
--
 	while ((nr < num_entries) && (qmap_entry->reported == 0)) {
 		/* generate flush CQE */
 
@@ -864,6 +902,12 @@ static int generate_flush_cqes(struct eh
 		qmap_entry = &qmap->map[qmap->next_wqe_idx];
 
--
 	while (f < nr_of_pages) {
 		kpage = (u8 *)get_zeroed_page(GFP_KERNEL);
 		if (!kpage)
@@ -114,6 +119,12 @@ static int alloc_queue_pages(struct ipz_
 			kpage += EHCA_PAGESIZE;
 			f++;
--
 	while (eqe) {
 		if (!EHCA_BMASK_GET(NEQE_COMPLETION_EVENT, eqe->entry))
 			parse_ec(shca, eqe->entry);
 
 		eqe = ehca_poll_eq(shca, &shca->neq);
+		if (_cur < timeout) {
--
 	while (!list_empty(&cct->cq_list)) {
 		cq = list_entry(cct->cq_list.next, struct ehca_cq, entry);
 		spin_unlock_irqrestore(&cct->task_lock, flags);
@@ -739,6 +755,12 @@ static void run_comp_task(struct ehca_cp
 			cct->cq_jobs--;
 		}
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		add_wait_queue(&cct->wait_queue, &wait);
 
 		spin_lock_irq(&cct->task_lock);
@@ -771,6 +798,12 @@ static int comp_task(void *__cct)
 			run_comp_task(__cct);
--
 	while (!list_empty(&list)) {
 		cq = list_entry(cct->cq_list.next, struct ehca_cq, entry);
 
 		list_del(&cq->entry);
 		__queue_comp_task(cq, this_cpu_ptr(pool->cpu_comp_tasks));
+		if (_cur < timeout) {
--
 	while (wqe->optype != 0xff && wqe->wqef != 0xff) {
 		if (ehca_debug_level >= 2)
 			ehca_dmp(wqe, 32, "qp_num=%x wqe", qp_num);
@@ -1115,6 +1120,12 @@ static int prepare_sqe_rts(struct ehca_q
 		q_ofs = ipz_queue_advance_offset(squeue, q_ofs);
 		wqe = (struct ehca_wqe *)ipz_qeit_calc(squeue, q_ofs);
--
 	while (tail_idx != wqe_idx) {
 		if (qmap->map[tail_idx].cqe_req)
 			qmap->left_to_poll++;
 		tail_idx = next_index(tail_idx, qmap->entries);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (page < page_count) {
 		u64 rnum;
 		for (rnum = 0; (rnum < MAX_RPAGES) && (page < page_count);
@@ -1564,6 +1569,12 @@ static u64 ehca_reg_mr_section(int top,
 			ehca_err(&shca->ib_device, "register_rpage_mr failed");
 			return h_ret;
--
-	while (i < number) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < number) {
 		pbuf   = pginfo->u.phy.phys_buf_array + pginfo->u.phy.next_buf;
 		num_hw  = NUM_CHUNKS((pbuf->addr % pginfo->hwpage_size) +
 				     pbuf->size, pginfo->hwpage_size);
@@ -2110,6 +2126,12 @@ static int ehca_set_pagebuf_phys(struct
 			(pginfo->u.phy.next_buf)++;
--
 	while (pfn < end_pfn) {
 		if (ehca_is_hugepage(pfn)) {
 			/* Add mem found in front of the hugepage */
@@ -2447,6 +2474,12 @@ static int ehca_create_busmap_callback(u
 			start_pfn = pfn;
 		} else
--
-	while (list_empty(&file->recv_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->recv_list)) {
 		mutex_unlock(&file->mutex);
 
 		if (filp->f_flags & O_NONBLOCK)
@@ -344,6 +349,12 @@ static ssize_t ib_umad_read(struct file
 			return -ERESTARTSYS;
--
 	while (new_buf && (get_seg_num(new_buf) == rmpp_recv->seg_num + 1)) {
 		rmpp_recv->cur_seg_buf = new_buf;
 		rmpp_recv->seg_num++;
 		new_buf = get_next_seg(rmpp_list, new_buf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count--) {
 		work = kmalloc(sizeof(struct iwcm_work), GFP_KERNEL);
 		if (!work) {
@@ -128,6 +133,12 @@ static int alloc_work_entries(struct iwc
 		work->cm_id = cm_id_priv;
 		INIT_LIST_HEAD(&work->list);
--
-	while (!empty) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!empty) {
 		work = list_entry(cm_id_priv->work_list.next,
 				  struct iwcm_work, list);
 		list_del_init(&work->list);
@@ -877,6 +893,12 @@ static void cm_work_handler(struct work_
 			return;
--
 	while (!list_empty(&xrcd->tgt_qp_list)) {
 		qp = list_entry(xrcd->tgt_qp_list.next, struct ib_qp, xrcd_list);
 		ret = ib_destroy_qp(qp);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
--
-	while (!list_empty(&ctx->events)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ctx->events)) {
 
 		uevent = list_entry(ctx->events.next,
 				    struct ib_ucm_event, ctx_list);
@@ -172,6 +177,12 @@ static void ib_ucm_cleanup_events(struct
 
--
-	while (list_empty(&file->events)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->events)) {
 		mutex_unlock(&file->file_mutex);
 
 		if (file->filp->f_flags & O_NONBLOCK)
@@ -420,6 +436,12 @@ static ssize_t ib_ucm_event(struct ib_uc
 			return -ERESTARTSYS;
--
-	while (!list_empty(&file->ctxs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&file->ctxs)) {
 		ctx = list_entry(file->ctxs.next,
 				 struct ib_ucm_context, file_list);
 		mutex_unlock(&file->file_mutex);
@@ -1199,6 +1226,12 @@ static int ib_ucm_close(struct inode *in
 		kfree(ctx);
--
-	while (list_empty(&file->event_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->event_list)) {
 		spin_unlock_irq(&file->lock);
 
 		if (filp->f_flags & O_NONBLOCK)
@@ -305,6 +310,12 @@ static ssize_t ib_uverbs_event_read(stru
 			return -ERESTARTSYS;
--
 	while (node) {
 		group = rb_entry(node, struct mcast_group, node);
 		ret = memcmp(mgid->raw, group->rec.mgid.raw, sizeof *mgid);
@@ -144,6 +149,12 @@ static struct mcast_group *mcast_find(st
 			node = node->rb_left;
 		else
--
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_group = rb_entry(parent, struct mcast_group, node);
 
@@ -171,6 +187,12 @@ static struct mcast_group *mcast_insert(
 			link = &(*link)->rb_left;
--
-	while (!list_empty(&group->active_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&group->active_list)) {
 		member = list_entry(group->active_list.next,
 				    struct mcast_member, list);
 		atomic_inc(&member->refcount);
@@ -421,6 +448,12 @@ static void process_group_error(struct m
 		if (ret)
--
 	while (!list_empty(&group->pending_list) ||
 	       (group->state != MCAST_BUSY)) {
 
@@ -478,6 +516,12 @@ retest:
 		if (ret)
 			ib_sa_free_multicast(&member->multicast);
--
-	while (list_empty(&file->event_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->event_list)) {
 		mutex_unlock(&file->mut);
 
 		if (file->filp->f_flags & O_NONBLOCK)
@@ -336,6 +341,12 @@ static ssize_t ucma_get_event(struct ucm
 			return -ERESTARTSYS;
--
 	while (*p) {
 		parent = *p;
 		scan = rb_entry(parent, struct xrcd_table_entry, node);
@@ -639,6 +644,12 @@ static int xrcd_table_insert(struct ib_u
 			kfree(entry);
 			return -EEXIST;
--
 	while (p) {
 		entry = rb_entry(p, struct xrcd_table_entry, node);
 
@@ -662,6 +678,12 @@ static struct xrcd_table_entry *xrcd_tab
 			p = p->rb_right;
 		else
--
 	while (wr) {
 		if (is_ud && wr->wr.ud.ah)
 			put_ah_read(wr->wr.ud.ah);
 		next = wr->next;
 		kfree(wr);
 		wr = next;
--
 	while (wr) {
 		next = wr->next;
 		kfree(wr);
 		wr = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (wr) {
 		next = wr->next;
 		kfree(wr);
 		wr = next;
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (wr) {
 		next = wr->next;
 		kfree(wr);
 		wr = next;
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
-	while (!list_empty(&id_priv->listen_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&id_priv->listen_list)) {
 		dev_id_priv = list_entry(id_priv->listen_list.next,
 					 struct rdma_id_private, listen_list);
 		/* sync with device removal to avoid duplicate destruction */
@@ -840,6 +845,12 @@ static void cma_cancel_listens(struct rd
 
--
-	while (!list_empty(&id_priv->mc_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&id_priv->mc_list)) {
 		mc = container_of(id_priv->mc_list.next,
 				  struct cma_multicast, list);
 		list_del(&mc->list);
@@ -899,6 +915,12 @@ static void cma_leave_mc_groups(struct r
 		default:
--
-	while (!list_empty(&cma_dev->id_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cma_dev->id_list)) {
 		id_priv = list_entry(cma_dev->id_list.next,
 				     struct rdma_id_private, list);
 
@@ -3337,6 +3364,12 @@ static void cma_process_remove(struct cm
 			rdma_destroy_id(&id_priv->id);
--
-	while (npages) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (npages) {
 		ret = get_user_pages(current, current->mm, cur_base,
 				     min_t(unsigned long, npages,
 					   PAGE_SIZE / sizeof (struct page *)),
@@ -162,7 +167,12 @@ struct ib_umem *ib_umem_get(struct ib_uc
 
--
-		while (ret) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (ret) {
 			chunk = kmalloc(sizeof *chunk + sizeof (struct scatterlist) *
 					min_t(int, ret, IB_UMEM_MAX_PAGE_CHUNK),
 					GFP_KERNEL);
@@ -197,10 +207,22 @@ struct ib_umem *ib_umem_get(struct ib_uc
 			ret -= chunk->nents;
--
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_cm_id_priv = rb_entry(parent, struct cm_id_private,
 					  service_node);
@@ -526,6 +531,12 @@ static struct cm_id_private * cm_insert_
 			link = &(*link)->rb_left;
--
-	while (node) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (node) {
 		cm_id_priv = rb_entry(node, struct cm_id_private, service_node);
 		data_cmp = cm_compare_private_data(private_data,
 						   cm_id_priv->compare_data);
@@ -561,6 +577,12 @@ static struct cm_id_private * cm_find_li
 			node = node->rb_left;
--
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_timewait_info = rb_entry(parent, struct cm_timewait_info,
 					     remote_id_node);
@@ -588,6 +615,12 @@ static struct cm_timewait_info * cm_inse
 			link = &(*link)->rb_right;
--
-	while (node) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (node) {
 		timewait_info = rb_entry(node, struct cm_timewait_info,
 					 remote_id_node);
 		if (be32_lt(remote_id, timewait_info->work.remote_id))
@@ -614,6 +652,12 @@ static struct cm_timewait_info * cm_find
 			node = node->rb_right;
--
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_timewait_info = rb_entry(parent, struct cm_timewait_info,
 					     remote_qp_node);
@@ -641,6 +690,12 @@ static struct cm_timewait_info * cm_inse
 			link = &(*link)->rb_right;
--
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_cm_id_priv = rb_entry(parent, struct cm_id_private,
 					  sidr_id_node);
@@ -676,6 +736,12 @@ static struct cm_id_private * cm_insert_
 			else
--
 	while (!ret && !atomic_add_negative(-1, &cm_id_priv->work_count)) {
 		spin_lock_irq(&cm_id_priv->lock);
 		work = cm_dequeue_work(cm_id_priv);
@@ -1326,6 +1397,12 @@ static void cm_process_work(struct cm_id
 		ret = cm_id_priv->id.cm_handler(&cm_id_priv->id,
 						&work->cm_event);
--
 	while (--i) {
 		port = cm_dev->port[i-1];
 		ib_modify_port(ib_device, port->port_num, 0, &port_modify);
 		ib_unregister_mad_agent(port->mad_agent);
 		cm_remove_port_fs(port);
+		if (_cur < timeout) {
--
 	while (ib_poll_cq(port_priv->cq, 1, &wc) == 1) {
 		if (wc.status == IB_WC_SUCCESS) {
 			switch (wc.opcode) {
@@ -2255,6 +2260,12 @@ static void ib_mad_completion_handler(st
 			}
 		} else
--
-	while (!list_empty(&mad_agent_priv->local_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mad_agent_priv->local_list)) {
 		local = list_entry(mad_agent_priv->local_list.next,
 				   struct ib_mad_local_private,
 				   completion_list);
@@ -2432,6 +2448,12 @@ local_send_completion:
 		if (free_mad)
--
-	while (!list_empty(&qp_info->recv_queue.list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&qp_info->recv_queue.list)) {
 
 		mad_list = list_entry(qp_info->recv_queue.list.next,
 				      struct ib_mad_list_head, list);
@@ -2631,6 +2658,12 @@ static void cleanup_recv_queue(struct ib
 				      sizeof(struct ib_mad_private_header),
--
 	while (i >= start) {
 		if (ib_agent_port_close(device, i))
 			printk(KERN_ERR PFX "Couldn't close %s port %d "
@@ -2975,6 +3013,12 @@ error:
 			printk(KERN_ERR PFX "Couldn't close %s port %d\n",
 			       device->name, i);
--
 	while (nents) {
 		sg_dma_address(sglist) = ccio_map_single(dev, sglist->address, sglist->length, direction);
 		sg_dma_len(sglist) = sglist->length;
 		nents--;
 		sglist++;
+		if (_cur < timeout) {
--
 	while(card->next) {
 		card = card->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while(byte_cnt > chain_size) {
 		WRITE_U32(CMD_TLB_PURGE | iovp, &ioc->ioc_regs->io_command);
 		iovp += chain_size;
 		byte_cnt -= chain_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(byte_cnt > 0) {
 		/* invalidate one page at a time */
 		unsigned int idx = PDIR_INDEX(iovp);
@@ -688,6 +704,12 @@ ccio_mark_invalid(struct ioc *ioc, dma_a
 
 		iovp     += IOVP_SIZE;
--
 	while(size > 0) {
 		ccio_io_pdir_entry(pdir_start, KERNEL_SPACE, (unsigned long)addr, hint);
 
@@ -780,6 +807,12 @@ ccio_map_single(struct device *dev, void
 		++pdir_start;
 		addr += IOVP_SIZE;
--
-	while(sg_dma_len(sglist) && nents--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(sg_dma_len(sglist) && nents--) {
 
 #ifdef CCIO_COLLECT_STATS
 		ioc->usg_pages += sg_dma_len(sglist) >> PAGE_SHIFT;
@@ -998,6 +1036,12 @@ ccio_unmap_sg(struct device *dev, struct
 		ccio_unmap_single(dev, sg_dma_address(sglist),
--
-	while (ioc != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (ioc != NULL) {
 		unsigned int total_pages = ioc->res_size << 3;
 #ifdef CCIO_COLLECT_STATS
 		unsigned long avg = 0, min, max;
@@ -1081,6 +1130,12 @@ static int ccio_proc_info(struct seq_fil
 #endif	/* CCIO_COLLECT_STATS */
--
 	while (ioc != NULL) {
 		u32 *res_ptr = (u32 *)ioc->res_map;
 		int j;
@@ -1117,6 +1177,12 @@ static int ccio_proc_bitmap_info(struct
 		len += seq_puts(m, "\n\n");
 		ioc = ioc->next;
--
-	while (idx < ioc->res_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (idx < ioc->res_size) {
  		res_ptr[idx] |= 0xff;
 		idx += PDIR_INDEX(CUJO_20_STEP) >> 3;
+		if (_cur < timeout) {
+ 		rdstcll(_cur);
+		}
--
 	while (cur != NULL) {
 		char *pe;
 		
@@ -447,6 +452,12 @@ static int __init eisa_irq_setup(char *s
 		} else {
 			break;
--
-	while (rcnt < BITS_PER_LONG) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (rcnt < BITS_PER_LONG) {
 		printk(KERN_DEBUG "%s %2d %p %016Lx\n",
 			(rcnt == (pide & (BITS_PER_LONG - 1)))
 				? "    -->" : "       ",
 			rcnt, ptr, *ptr );
 		rcnt++;
--
 	while (rptr < rptr_end) {
 		u32 rval = *rptr;
 		int rcnt = 32;	/* number of bits we might check */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
--
 		while (rcnt) {
 			/* Get last byte and highest bit from that */
 			u32 pde = ((u32) (((char *)pptr)[7])) << 24;
@@ -253,8 +274,20 @@ sba_check_pdir(struct ioc *ioc, char *ms
 			rval <<= 1;	/* try the next bit */
 			pptr++;
--
-	while (nents-- > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nents-- > 0) {
 		printk(KERN_DEBUG " %d : %08lx/%05x %p/%05x\n",
 				nents,
 				(unsigned long) sg_dma_address(startsg),
 				sg_dma_len(startsg),
 				sg_virt_addr(startsg), startsg->length);
--
 	while (size > 0) {
 		sba_io_pdir_entry(pdir_start, KERNEL_SPACE, (unsigned long) addr, 0);
 
@@ -763,6 +812,12 @@ sba_map_single(struct device *dev, void
 		addr += IOVP_SIZE;
 		size -= IOVP_SIZE;
--
 		while (cnt--) {
 			sba_free_range(ioc, d->iova, d->size);
 			d--;
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
--
-	while (sg_dma_len(sglist) && nents--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (sg_dma_len(sglist) && nents--) {
 
 		sba_unmap_single(dev, sg_dma_address(sglist), sg_dma_len(sglist), direction);
 #ifdef SBA_COLLECT_STATS
@@ -1046,6 +1117,12 @@ sba_unmap_sg(struct device *dev, struct
 		ioc->usingle_calls--;	/* kluge since call is unmap_sg() */
--
 			while (pdir_order < (19-12)) {
 				new_pdir += pdir_size;
 				free_pages(new_pdir, pdir_order);
 				pdir_order +=1;
 				pdir_size <<=1;
+				if (_cur < timeout) {
--
 	while (host->io_pos && length) {
 		buf[off++] = host->io_word[0] & 0xff;
 		host->io_word[0] >>= 8;
 		length--;
 		host->io_pos--;
+		if (_cur < timeout) {
--
 	while (host->io_pos > 4 && length) {
 		buf[off++] = host->io_word[0] & 0xff;
 		host->io_word[0] >>= 8;
 		length--;
 		host->io_pos--;
+		if (_cur < timeout) {
--
 	while (host->io_pos && length) {
 		buf[off++] = host->io_word[1] & 0xff;
 		host->io_word[1] >>= 8;
 		length--;
 		host->io_pos--;
+		if (_cur < timeout) {
--
 		while (host->io_pos < 4 && length) {
 			host->io_word[0] |=  buf[off++] << (host->io_pos * 8);
 			host->io_pos++;
 			length--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (host->io_pos < 4 && length) {
 		host->io_word[0] &= ~(0xff << (host->io_pos * 8));
 		host->io_word[0] |=  buf[off++] << (host->io_pos * 8);
 		host->io_pos++;
 		length--;
+		if (_cur < timeout) {
--
 	while (host->io_pos < 8 && length) {
 		host->io_word[1] &= ~(0xff << (host->io_pos * 8));
 		host->io_word[1] |=  buf[off++] << (host->io_pos * 8);
 		host->io_pos++;
 		length--;
+		if (_cur < timeout) {
--
 	while (host->io_pos && length) {
 		buf[off++] = host->io_word & 0xff;
 		host->io_word >>= 8;
 		length--;
 		host->io_pos--;
+		if (_cur < timeout) {
--
 		while (host->io_pos < 4 && length) {
 			host->io_word |=  buf[off++] << (host->io_pos * 8);
 			host->io_pos++;
 			length--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (time_before(jiffies, timeout)) {
 
 		reg = r592_read_reg(dev, R592_STATUS);
@@ -126,6 +131,12 @@ static int r592_wait_status(struct r592_
 			return -EIO;
 
--
 	while (len >= 4) {
 		r592_write_reg_raw_be(dev, R592_FIFO_PIO, *(u32 *)buffer);
 		buffer += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len >= 4) {
 		*(u32 *)buffer = r592_read_reg_raw_be(dev, R592_FIFO_PIO);
 		buffer += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!kthread_should_stop()) {
 		spin_lock_irqsave(&dev->io_thread_lock, flags);
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -589,6 +627,12 @@ static int r592_process_thread(void *dat
 			set_current_state(TASK_RUNNING);
 			r592_execute_tpc(dev);
--
 	while (!error && dev->req) {
 		dev->req->error = -ETIME;
 		error = memstick_next_req(dev->host, &dev->req);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (chunk) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (chunk) {
 		msb->current_page = 0;
 		msb->current_seg = 0;
 		msb->seg_count = blk_rq_map_sg(msb->block_req->q,
@@ -728,6 +733,12 @@ try_again:
 
--
 		while (ids->match_flags) {
 			if (memstick_dev_match(card, ids))
 				return 1;
 			++ids;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (1) {
 		if (!idr_pre_get(&memstick_host_idr, GFP_KERNEL))
 			return -ENOMEM;
@@ -523,6 +539,12 @@ int memstick_add_host(struct memstick_ho
 			break;
 		else if (rc != -EAGAIN)
--
 	while(inb(G2STAT(base)) & G2STAT_INTPEND) {
 		handled = 1;
 		DEB(printk("aha1740_intr top of loop.\n"));
@@ -325,6 +330,12 @@ static irqreturn_t aha1740_intr_handle(i
 			break;
 		}
--
 	while (!in_irq() && falcon_got_lock && stdma_others_waiting())
 		sleep_on(&falcon_fairness_wait);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (!falcon_got_lock) {
 		if (in_irq())
 			panic("Falcon SCSI hasn't ST-DMA lock in interrupt");
@@ -564,6 +569,12 @@ static void falcon_get_lock(void)
 		} else {
 			sleep_on(&falcon_try_wait);
--
 	while (d < h->buff + len) {
 		switch (d[1] & 0xf) {
 		case 0x4:
@@ -389,6 +394,12 @@ static int alua_vpd_inquiry(struct scsi_
 			break;
 		}
--
 	/* while there are valid entries */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->hba_index != q->host_index) {
 		temp_eqe = q->qe[q->host_index].eqe;
 		bf_set_le32(lpfc_eqe_valid, temp_eqe, 0);
 		released++;
 		q->host_index = ((q->host_index + 1) % q->entry_count);
+		if (_cur < timeout) {
--
 	/* while there are valid entries */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->hba_index != q->host_index) {
 		temp_qe = q->qe[q->host_index].cqe;
 		bf_set_le32(lpfc_cqe_valid, temp_qe, 0);
 		released++;
 		q->host_index = ((q->host_index + 1) % q->entry_count);
+		if (_cur < timeout) {
--
 	while (!found) {
 		if (!sglq)
 			return NULL;
@@ -875,6 +902,12 @@ __lpfc_sli_get_sglq(struct lpfc_hba *phb
 		found = 1;
 		phba->sli4_hba.lpfc_sglq_active_list[sglq->sli4_lxritag] = sglq;
--
 	while (!list_empty(iocblist)) {
 		list_remove_head(iocblist, piocb, struct lpfc_iocbq, list);
 
@@ -1052,6 +1090,12 @@ lpfc_sli_cancel_iocbs(struct lpfc_hba *p
 			piocb->iocb.un.ulpWord[4] = ulpWord4;
 			(piocb->iocb_cmpl) (phba, piocb, piocb);
--
-	while (!list_empty(&hbq_buf_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&hbq_buf_list)) {
 		list_remove_head(&hbq_buf_list, hbq_buffer, struct hbq_dmabuf,
 				 dbuf.list);
 		hbq_buffer->tag = (phba->hbqs[hbqno].buffer_count |
@@ -1818,15 +1867,32 @@ lpfc_sli_hbqbuf_fill_hbqs(struct lpfc_hb
 			posted++;
--
-	while (!list_empty(&hbq_buf_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&hbq_buf_list)) {
 		list_remove_head(&hbq_buf_list, hbq_buffer, struct hbq_dmabuf,
 				 dbuf.list);
 		(phba->hbqs[hbqno].hbq_free_buffer)(phba, hbq_buffer);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (pring->rspidx != portRspPut) {
 		/*
 		 * Fetch an entry off the ring and copy it into a local data
@@ -2971,6 +3042,12 @@ lpfc_sli_handle_fast_ring_event(struct l
 
 		if (pring->rspidx == portRspPut)
--
-	while (!list_empty(&phba->sli4_hba.sp_queue_event)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->sli4_hba.sp_queue_event)) {
 		/* Get the response iocb from the head of work queue */
 		spin_lock_irqsave(&phba->hbalock, iflag);
 		list_remove_head(&phba->sli4_hba.sp_queue_event,
@@ -3370,6 +3452,12 @@ lpfc_sli_handle_slow_ring_event_s4(struc
 		default:
--
 	while (++i < 500) {
 		if (lpfc_readl(phba->HAregaddr, &ha_copy))
 			return;
@@ -3661,6 +3754,12 @@ clear_errat:
 			mdelay(1);
 		else
--
 	while ((i++ < 30) && !(ha_copy & HA_ERATT)) {
 		mdelay(100);
 		if (lpfc_readl(phba->HAregaddr, &ha_copy))
 			return 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((status & (HS_FFRDY | HS_MBRDY)) != (HS_FFRDY | HS_MBRDY)) {
 
 		/* Check every 10ms for 10 retries, then every 100ms for 90
@@ -4105,6 +4220,12 @@ lpfc_sli_chipset_init(struct lpfc_hba *p
 		/* Read the HBA Host Status Register */
 		if (lpfc_readl(phba->HSregaddr, &status))
--
 		while (rsrc_id < (rsrc_start + rsrc_size)) {
 			ids[j] = rsrc_id;
 			rsrc_id++;
 			j++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&completions)) {
 		list_remove_head(&completions, pmb, LPFC_MBOXQ_t, list);
 		pmb->u.mb.mbxStatus = MBX_NOT_FINISHED;
 		if (pmb->mbox_cmpl)
 			pmb->mbox_cmpl(phba, pmb);
+			if (_cur < timeout) {
--
-	while (!list_empty(&completions)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&completions)) {
 		list_remove_head(&completions, buf_ptr,
 			struct lpfc_dmabuf, list);
 		lpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);
 		kfree(buf_ptr);
+		if (_cur < timeout) {
--
-	while (!list_empty(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue)) {
 		/* Get the first event from the head of the event queue */
 		spin_lock_irq(&phba->hbalock);
 		list_remove_head(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue,
@@ -10424,6 +10583,12 @@ void lpfc_sli4_fcp_xri_abort_event_proc(
 		lpfc_sli4_fcp_xri_aborted(phba, &cq_event->cqe.wcqe_axri);
--
-	while (!list_empty(&phba->sli4_hba.sp_els_xri_aborted_work_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->sli4_hba.sp_els_xri_aborted_work_queue)) {
 		/* Get the first event from the head of the event queue */
 		spin_lock_irq(&phba->hbalock);
 		list_remove_head(&phba->sli4_hba.sp_els_xri_aborted_work_queue,
@@ -10453,6 +10623,12 @@ void lpfc_sli4_els_xri_abort_event_proc(
 		lpfc_sli4_els_xri_aborted(phba, &cq_event->cqe.wcqe_axri);
--
 		while ((cqe = lpfc_sli4_cq_get(cq))) {
 			workposted |= lpfc_sli4_sp_handle_mcqe(phba, cqe);
 			if (!(++ecount % cq->entry_repost))
 				lpfc_sli4_cq_release(cq, LPFC_QUEUE_NOARM);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
-		while ((cqe = lpfc_sli4_cq_get(cq))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((cqe = lpfc_sli4_cq_get(cq))) {
 			if (cq->subtype == LPFC_FCP)
 				workposted |= lpfc_sli4_fp_handle_wcqe(phba, cq,
 								       cqe);
@@ -11033,6 +11225,12 @@ lpfc_sli4_sp_handle_eqe(struct lpfc_hba
 								      cqe);
--
 	while ((cqe = lpfc_sli4_cq_get(cq))) {
 		workposted |= lpfc_sli4_fp_handle_wcqe(phba, cq, cqe);
 		if (!(++ecount % cq->entry_repost))
 			lpfc_sli4_cq_release(cq, LPFC_QUEUE_NOARM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((eqe = lpfc_sli4_eq_get(speq))) {
 		lpfc_sli4_sp_handle_eqe(phba, eqe);
 		if (!(++ecount % speq->entry_repost))
 			lpfc_sli4_eq_release(speq, LPFC_QUEUE_NOARM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((eqe = lpfc_sli4_eq_get(fpeq))) {
 		lpfc_sli4_fp_handle_eqe(phba, eqe, fcp_eqidx);
 		if (!(++ecount % fpeq->entry_repost))
 			lpfc_sli4_eq_release(fpeq, LPFC_QUEUE_NOARM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&queue->page_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&queue->page_list)) {
 		list_remove_head(&queue->page_list, dmabuf, struct lpfc_dmabuf,
 				 list);
 		dma_free_coherent(&queue->phba->pcidev->dev, SLI4_PAGE_SIZE,
 				  dmabuf->virt, dmabuf->phys);
 		kfree(dmabuf);
--
 	while (!list_empty(&mbox_cmd_list)) {
 		list_remove_head(&mbox_cmd_list, mb, LPFC_MBOXQ_t, list);
 		if (mb->u.mb.mbxCommand == MBX_REG_LOGIN64) {
@@ -15571,6 +15818,12 @@ lpfc_cleanup_pending_mbox(struct lpfc_vp
 			}
 		}
--
 	while (i > 0) {
 		len +=  snprintf(buf+len, size-len,
 		"%08x: %08x %08x %08x %08x %08x %08x %08x %08x\n",
@@ -421,6 +426,12 @@ lpfc_debugfs_dumpHBASlim_data(struct lpf
 		ptr += 8;
 		i -= (8 * sizeof(uint32_t));
--
 	while (i > 0) {
 		len +=  snprintf(buf+len, size-len,
 		"%08x: %08x %08x %08x %08x %08x %08x %08x %08x\n",
@@ -469,11 +485,22 @@ lpfc_debugfs_dumpHostSlim_data(struct lp
 		ptr += 8;
 		i -= (8 * sizeof(uint32_t));
--
 	while (i > 0) {
 		len +=  snprintf(buf+len, size-len,
 		"%08x: %08x %08x %08x %08x %08x %08x %08x %08x\n",
@@ -482,6 +509,12 @@ lpfc_debugfs_dumpHostSlim_data(struct lp
 		ptr += 8;
 		i -= (8 * sizeof(uint32_t));
--
-	while (esize > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (esize > 0) {
 		len += snprintf(pbuffer+len, LPFC_QUE_ACC_BUF_SIZE-len,
 				"%08x ", *pentry);
 		pentry++;
@@ -2217,6 +2255,12 @@ lpfc_idiag_queacc_read_qe(char *pbuffer,
 		if (esize > 0 && !(offset % (4 * sizeof(uint32_t))))
--
 				while (num > 1) {
 					num = num >> 1;
 					i++;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 			while (num > 1) {
 				num = num >> 1;
 				i++;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
 		while (payload_len) {
 			rscn_did.un.word = be32_to_cpu(*lp++);
 			payload_len -= sizeof(uint32_t);
@@ -4429,6 +4434,12 @@ lpfc_rscn_payload_check(struct lpfc_vpor
 			case RSCN_ADDRESS_FORMAT_FABRIC:
 				goto return_did_out;
--
 		while (i > 0) {
 			nportid = *datap++;
 			nportid = ((be32_to_cpu(nportid)) & Mask_DID);
@@ -4593,6 +4609,12 @@ lpfc_els_rcv_rscn(struct lpfc_vport *vpo
 			rscn_id++;
 			if (lpfc_find_vport_by_did(phba, nportid))
--
 	while (time_before(jiffies, wait_time_max)) {
 		if ((vport->num_disc_nodes > 0)    ||
 		    (vport->fc_flag & wait_flags)  ||
@@ -277,6 +282,12 @@ static void lpfc_discovery_wait(struct l
 						- start_time));
 			break;
--
 		while (check_count < ((phba->fc_ratov * 3) + 3) &&
 		       vport->port_state > LPFC_VPORT_FAILED &&
 		       vport->port_state < LPFC_VPORT_READY) {
 			check_count++;
 			msleep(1000);
+			if (_cur < timeout) {
--
 	while (!list_empty(&evt->events_to_get)) {
 		ed = list_entry(evt->events_to_get.next, typeof(*ed), node);
 		list_del(&ed->node);
 		kfree(ed->data);
 		kfree(ed);
+		if (_cur < timeout) {
--
 	while (!list_empty(&evt->events_to_see)) {
 		ed = list_entry(evt->events_to_see.next, typeof(*ed), node);
 		list_del(&ed->node);
 		kfree(ed->data);
 		kfree(ed);
+		if (_cur < timeout) {
--
 		while (phba->link_state != LPFC_LINK_DOWN) {
 			if (i++ > timeout) {
 				rc = -ETIMEDOUT;
@@ -1617,6 +1644,12 @@ lpfc_sli3_bsg_diag_loopback_mode(struct
 			}
 
--
 	while (phba->link_state != LPFC_LINK_DOWN) {
 		if (i++ > timeout) {
 			rc = -ETIMEDOUT;
 			goto loopback_mode_exit;
 		}
 		msleep(10);
--
-	while (size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size) {
 		/* We get chunks of 4K */
 		if (size > BUF_SZ_4K)
 			cnt = BUF_SZ_4K;
@@ -2456,6 +2505,12 @@ diag_cmd_data_alloc(struct lpfc_hba *phb
 		i++;
--
 	while (size) {
 		/* Allocate buffer for rsp payload */
 		mp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);
@@ -262,6 +267,12 @@ lpfc_alloc_ct_rsp(struct lpfc_hba *phba,
 
 		i++;
--
 		while (Cnt >= sizeof (uint32_t)) {
 			/* Get next DID from NameServer List */
 			CTentry = *ctptr++;
@@ -570,6 +586,12 @@ lpfc_ns_rsp(struct lpfc_vport *vport, st
 			if (CTentry & (be32_to_cpu(SLI_CT_LAST_ENTRY)))
 				goto nsout1;
--
 	while (sgde) {
 		src = sg_virt(sgde);
 		memcpy(dst, src, sgde->length);
 		dst += sgde->length;
 		sgde = sg_next(sgde);
+		if (_cur < timeout) {
--
 	while (sgde) {
 		src = sg_virt(sgde);
 		memcpy(dst, src, sgde->length);
 		dst += sgde->length;
 		sgde = sg_next(sgde);
+		if (_cur < timeout) {
--
-		while (!list_empty(&sblist)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&sblist)) {
 			list_remove_head(&sblist, psb, struct lpfc_scsi_buf,
 					 list);
 			if (status) {
@@ -774,6 +801,12 @@ lpfc_sli4_repost_scsi_sgl_list(struct lp
 			}
--
-		while (!list_empty(&sblist)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&sblist)) {
 			list_remove_head(&sblist, psb, struct lpfc_scsi_buf,
 				 list);
 			if (status) {
@@ -961,6 +999,12 @@ lpfc_new_scsi_buf_s4(struct lpfc_vport *
 			}
--
 	while (time_after(later, jiffies)) {
 		if (!pnode || !NLP_CHK_NODE_ACT(pnode))
 			return FAILED;
@@ -3658,6 +3707,12 @@ lpfc_chk_tgt_mapped(struct lpfc_vport *v
 		if (!rdata)
 			return FAILED;
--
 	while (time_after(later, jiffies) && cnt) {
 		schedule_timeout_uninterruptible(msecs_to_jiffies(20));
 		cnt = lpfc_sli_sum_iocb(vport, tgt_id, lun_id, context);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&phba->work_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->work_list)) {
 		list_remove_head((&phba->work_list), evtp, typeof(*evtp),
 				 evt_listp);
 		spin_unlock_irq(&phba->hbalock);
@@ -572,6 +577,12 @@ lpfc_work_list_done(struct lpfc_hba *phb
 		if (free_evt)
--
 			while (!((new_fcf_record->vlan_bitmap[i] >> j) & 1)) {
 				j++;
 				fcf_vlan_id++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 				while (j < numalpa) {
 					memset(un.pamap, 0, 16);
 					for (k = 1; j < numalpa; k++) {
@@ -2997,6 +3024,12 @@ lpfc_mbx_process_link_up(struct lpfc_hba
 							"x%x x%x x%x\n",
 							un.pa.wd1, un.pa.wd2,
--
 	while ((offset + rec_length * sizeof(uint32_t) + sizeof(uint32_t))
 		<= size) {
 		if (buff[offset] == rec_type)
@@ -6004,6 +6042,12 @@ lpfc_get_rec_conf23(uint8_t *buff, uint3
 
 		offset += rec_length * sizeof(uint32_t) + sizeof(uint32_t);
--
 	while ((skb = skb_dequeue(&fnic->frame_queue))) {
 
 		spin_lock_irqsave(&fnic->fnic_lock, flags);
@@ -125,6 +130,12 @@ void fnic_handle_frame(struct work_struc
 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 
--
 	while ((skb = skb_dequeue(&fnic->tx_queue))) {
 		fp = (struct fc_frame *)skb;
 		fnic_send_frame(fnic, fp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((type = ioread8(&r->type)) != RES_TYPE_EOL) {
 
 		u8 bar_num = ioread8(&r->bar);
@@ -128,6 +133,12 @@ static int vnic_dev_discover_res(struct
 
 		vdev->res[type].count = count;
--
 	while (vnic_rq_desc_used(rq) > 0) {
 
 		(*buf_clean)(rq, buf);
 
 		buf = rq->to_clean = buf->next;
 		rq->ring.desc_avail++;
--
 	while (vnic_wq_desc_used(wq) > 0) {
 
 		(*buf_clean)(wq, buf);
 
 		buf = wq->to_clean = buf->next;
 		wq->ring.desc_avail++;
--
 	while(len && timeout)
 	{
 		bytes_left = inb(base + PIO_FIFO_CNT); /* Number of bytes in the PIO FIFO */
@@ -277,6 +282,12 @@ static __inline__ unsigned int sym53c416
 			if(inb(base + PIO_INT_REG) & EMPTY)
 				timeout = 0;
--
 	while(len && timeout)
 	{
 		bufferfree = PIO_SIZE - inb(base + PIO_FIFO_CNT);
@@ -320,6 +336,12 @@ static __inline__ unsigned int sym53c416
 			if(inb(base + PIO_INT_REG) & FULL)
 				timeout = 0;
--
 		while((idev=pnp_find_dev(NULL, id_table[i].vendor,
 					id_table[i].function, idev))!=NULL)
 		{
@@ -674,6 +701,12 @@ int __init sym53c416_detect(struct scsi_
 			printk(KERN_INFO "sym53c416: ISAPnP card found and configured at 0x%X, IRQ %d.\n",
 				i[1], i[2]);
--
 	while (!list_empty(&shost->free_list)) {
 		struct scsi_cmnd *cmd;
 
 		cmd = list_entry(shost->free_list.next, struct scsi_cmnd, list);
 		list_del_init(&cmd->list);
 		scsi_pool_free_command(shost->cmd_pool, cmd);
--
-	while (kfifo_out(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (kfifo_out(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {
 		kfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,
 			    sizeof(void*));
 		ISCSI_DBG_TCP(task->conn, "pending r2t dropped\n");
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (1) {
 		unsigned int avail;
 		const u8 *ptr;
@@ -921,6 +937,12 @@ int iscsi_tcp_recv_skb(struct iscsi_conn
 			skb_abort_seq_read(&seq);
 			goto segment_done;
--
 	while (count && qe) {
 		qe_next = bfa_q_next(qe);
 		lps = (struct bfa_lps_s *)qe;
@@ -1614,6 +1619,12 @@ bfa_lps_no_res(struct bfa_lps_s *first_l
 		bfa_sm_send_event(lps, BFA_LPS_SM_FWRSP);
 		qe = qe_next;
--
 		while (num_entries > 0) {
 			if (strncmp(gmal_entry->prefix,
 				CT_GMAL_RESP_PREFIX_HTTP,
@@ -2828,6 +2833,12 @@ bfa_fcs_lport_ms_gmal_response(void *fcs
 				--num_entries;
 				++gmal_entry;
--
 	while ((qe != qh) && (i < *nrports)) {
 		rport = (struct bfa_fcs_rport_s *) qe;
 		if (bfa_ntoh3b(rport->pid) > 0xFFF000) {
@@ -4924,6 +4940,12 @@ bfa_fcs_lport_get_rports(struct bfa_fcs_
 
 		i++;
--
 	while (qe != qh) {
 		rport = (struct bfa_fcs_rport_s *) qe;
 		if ((bfa_ntoh3b(rport->pid) > 0xFFF000) ||
@@ -4982,6 +5009,12 @@ bfa_fcs_lport_get_rport_max_speed(bfa_fc
 			max_speed = rport_speed;
 
--
-	while (i < iocmd->attr.total_vc_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i < iocmd->attr.total_vc_count) {
 		iocmd->attr.vc_info[i].vc_credit =
 				bfa_vc_attr->vc_info[i].vc_credit;
 		iocmd->attr.vc_info[i].borrow_credit =
@@ -2289,6 +2294,12 @@ bfad_iocmd_qos_get_vc_attr(struct bfad_s
 		iocmd->attr.vc_info[i].priority =
--
 	while ((struct bfa_ioim_s *) cmnd->host_scribble == hal_io) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(timeout);
 		if (timeout < 4 * HZ)
 			timeout *= 2;
+			if (_cur < timeout) {
--
 	while (!list_empty(&bfad->active_aen_q)) {
 		spin_lock_irqsave(&bfad->bfad_aen_spinlock, flags);
 		bfa_q_deq(&bfad->active_aen_q, &aen_entry);
@@ -680,6 +696,12 @@ static void bfad_aen_im_notify_handler(s
 		spin_lock_irqsave(&bfad->bfad_aen_spinlock, flags);
 		list_add_tail(&aen_entry->qe, &bfad->free_aen_q);
--
 	while ((r32 & 1) && (cnt < BFA_SEM_SPINCNT)) {
 		cnt++;
 		udelay(2);
 		r32 = readl(sem_reg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (qe != qh) {
 		qe_next = bfa_q_next(qe);
 
@@ -3003,14 +3019,31 @@ bfa_timer_beat(struct bfa_timer_mod_s *m
 		}
 
--
 	while (!list_empty(&timedout_q)) {
 		bfa_q_deq(&timedout_q, &elem);
 		elem->timercb(elem->arg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!kthread_should_stop()) {
 
 		/* Send event BFAD_E_INIT_SUCCESS */
@@ -1132,6 +1137,12 @@ bfad_worker(void *ptr)
 		spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 
--
 	while (ci != pi) {
 		m = bfa_rspq_elem(bfa, qid, ci);
 		WARN_ON(m->mhdr.msg_class >= BFI_MC_MAX);
 
 		bfa_isrs[m->mhdr.msg_class] (bfa, m);
 		CQ_INCR(ci, bfa->iocfc.cfg.drvcfg.num_rspq_elems);
--
 	while (!list_empty(comp_q)) {
 		bfa_q_deq(comp_q, &qe);
 		hcb_qe = (struct bfa_cb_qe_s *) qe;
 		WARN_ON(hcb_qe->pre_rmv);
 		hcb_qe->cbfn(hcb_qe->cbarg, BFA_FALSE);
+		if (_cur < timeout) {
--
 	while (!list_empty(&itnim->pending_q)) {
 		bfa_q_deq(&itnim->pending_q, &ioim);
 		list_add_tail(&ioim->qe, &itnim->io_q);
 		bfa_ioim_start(ioim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&itnim->pending_q)) {
 		bfa_q_deq(&itnim->pending_q, &ioim);
 		list_add_tail(&ioim->qe, &ioim->fcpim->ioim_comp_q);
 		bfa_ioim_tov(ioim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (desc < buf + vpd_len) {
 		enum scsi_protocol proto = desc[0] >> 4;
 		u8 code_set = desc[0] & 0x0f;
@@ -488,6 +493,12 @@ static void ses_match_to_enclosure(struc
 				(u64)desc[11];
 
--
 		while ((edev = enclosure_find(&sdev->host->shost_gendev, prev)) != NULL) {
 			ses_match_to_enclosure(edev, sdev);
 			prev = edev;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 			while (len >= sizeof(*pattr)) {
 				u32 attr_page = be32_to_cpu(pattr->attr_page);
 				u32 attr_id = be32_to_cpu(pattr->attr_id);
@@ -1867,6 +1872,12 @@ int osd_req_decode_sense_full(struct osd
 					"osd_sense_attribute_identification"
 					"attr_page=0x%x attr_id=0x%x\n",
--
 	while( n-- > 0)
 	{
 		r = NCR5380_read(reg);
 		if((r & bit) == val)
 			return 0;
 		cpu_relax();
--
 	while(time_before(jiffies, end))
 	{
 		r = NCR5380_read(reg);
@@ -349,6 +365,12 @@ static int NCR5380_poll_politely(struct
 			cond_resched();
 		else
--
-	while (sges_in_segment) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sges_in_segment) {
 		if (sges_in_segment == 1)
 			ioc->base_add_sg_single(sg_local,
 			    sgl_flags_last_element | sg_dma_len(sg_scmd),
@@ -1096,6 +1101,12 @@ _scsih_build_scatter_gather(struct MPT2S
 		sg_local += ioc->sge_size;
--
-		while (sges_in_segment) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (sges_in_segment) {
 			if (sges_in_segment == 1)
 				ioc->base_add_sg_single(sg_local,
 				    sgl_flags_last_element |
@@ -1138,6 +1154,12 @@ _scsih_build_scatter_gather(struct MPT2S
 			sg_local += ioc->sge_size;
--
-	while (sges_left) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sges_left) {
 		if (sges_left == 1)
 			ioc->base_add_sg_single(sg_local, sgl_flags_end_buffer |
 			    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));
@@ -1161,6 +1188,12 @@ _scsih_build_scatter_gather(struct MPT2S
 		sg_scmd = sg_next(sg_scmd);
--
 			while (_scsih_add_device(ioc, handle, retry_count++,
 				1)) {
 					ssleep(1);
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 			while (_scsih_add_device(ioc, handle, retry_count++,
 				0)) {
 					ssleep(1);
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 		if (wait_state_count++ == 10) {
 			printk(MPT2SAS_ERR_FMT
 			    "%s: failed due to ioc not operational\n",
@@ -3095,6 +3100,12 @@ mpt2sas_base_sas_iounit_control(struct M
 		printk(MPT2SAS_INFO_FMT "%s: waiting for "
--
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 		if (wait_state_count++ == 10) {
 			printk(MPT2SAS_ERR_FMT
 			    "%s: failed due to ioc not operational\n",
@@ -3200,6 +3216,12 @@ mpt2sas_base_scsi_enclosure_processor(st
 		printk(MPT2SAS_INFO_FMT "%s: waiting for "
--
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 		if (wait_state_count++ == 10) {
 			printk(MPT2SAS_ERR_FMT
 			    "%s: failed due to ioc not operational\n",
@@ -332,6 +337,12 @@ _transport_expander_report_manufacture(s
 		printk(MPT2SAS_INFO_FMT "%s: waiting for "
--
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 		if (wait_state_count++ == 10) {
 			printk(MPT2SAS_ERR_FMT
 			    "%s: failed due to ioc not operational\n",
@@ -1116,6 +1132,12 @@ _transport_get_expander_phy_error_log(st
 		printk(MPT2SAS_INFO_FMT "%s: waiting for "
--
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 		if (wait_state_count++ == 10) {
 			printk(MPT2SAS_ERR_FMT
 			    "%s: failed due to ioc not operational\n",
@@ -1435,6 +1462,12 @@ _transport_expander_phy_control(struct M
 		printk(MPT2SAS_INFO_FMT "%s: waiting for "
--
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 		if (wait_state_count++ == 10) {
 			printk(MPT2SAS_ERR_FMT
 			    "%s: failed due to ioc not operational\n",
@@ -1886,6 +1924,12 @@ _transport_smp_handler(struct Scsi_Host
 		printk(MPT2SAS_INFO_FMT "%s: waiting for "
--
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 		if (wait_state_count++ == MPT2_CONFIG_PAGE_DEFAULT_TIMEOUT) {
 			printk(MPT2SAS_ERR_FMT
 			    "%s: failed due to ioc not operational\n",
@@ -364,6 +369,12 @@ _config_request(struct MPT2SAS_ADAPTER *
 		printk(MPT2SAS_INFO_FMT "%s: waiting for "
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		mpi_request.PageAddress = cpu_to_le32(config_num +
 		    MPI2_RAID_PGAD_FORM_GET_NEXT_CONFIGNUM);
 		r = _config_request(ioc, &mpi_request, &mpi_reply,
@@ -1421,6 +1437,12 @@ mpt2sas_config_get_volume_handle(struct
 			}
--
-	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 		if (wait_state_count++ == 10) {
 			printk(MPT2SAS_ERR_FMT
 			    "%s: failed due to ioc not operational\n",
@@ -674,6 +679,12 @@ _ctl_do_mpt_command(struct MPT2SAS_ADAPT
 		printk(MPT2SAS_INFO_FMT "%s: waiting for "
--
 	while (!list_empty(cmd_list)) {
 		scmd = list_entry(cmd_list->next, struct scsi_cmnd, eh_entry);
 		sdev = scmd->device;
@@ -1003,6 +1008,12 @@ static int scsi_eh_test_devices(struct l
 				else
 					list_move_tail(&scmd->eh_entry, work_q);
--
 	while (!list_empty(&tmp_list)) {
 		struct scsi_cmnd *next, *scmd;
 		int rtn;
@@ -1232,6 +1248,12 @@ static int scsi_eh_target_reset(struct S
 				/* push back on work queue for further processing */
 				list_move(&scmd->eh_entry, work_q);
--
 	while (!kthread_should_stop()) {
 		if ((shost->host_failed == 0 && shost->host_eh_scheduled == 0) ||
 		    shost->host_failed != shost->host_busy) {
@@ -1859,6 +1886,12 @@ int scsi_error_handler(void *data)
 		scsi_restart_operations(shost);
 		scsi_autopm_put_host(shost);
--
-	while (s->cmpConsIdx != s->cmpProdIdx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (s->cmpConsIdx != s->cmpProdIdx) {
 		struct PVSCSIRingCmpDesc *e = ring + (s->cmpConsIdx &
 						      MASK(cmp_entries));
 		/*
@@ -610,6 +615,12 @@ static void pvscsi_process_completion_ri
 		 */
--
-	while (pvscsi_msg_pending(adapter)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pvscsi_msg_pending(adapter)) {
 		struct PVSCSIRingMsgDesc *e = ring + (s->msgConsIdx &
 						      MASK(msg_entries));
 
@@ -996,6 +1012,12 @@ static void pvscsi_process_msg_ring(cons
 		pvscsi_process_msg(adapter, e);
--
 	while ((req = blk_fetch_request(q)) != NULL) {
 		spin_unlock_irq(q->queue_lock);
 
@@ -183,6 +188,12 @@ static void sas_smp_request(struct reque
 		blk_end_request_all(req, ret);
 
--
 	while (time_before_eq(jiffies, WAITtimeout)) {
 		WAITbits = inb(port) & mask;
 
 		if (((WAITbits & allof) == allof) && ((WAITbits & noneof) == 0))
 			return (0);
+			if (_cur < timeout) {
--
 		while (len--) {
 			do {
 				outb(*cmd, host->iobase + ASC_COMMAND);
@@ -785,6 +801,12 @@ static inline int command_out(Adapter *
 			} while (inb(host->iobase + ASC_STAT) & CMD_REJ);
 
 			cmd++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (freescbs < needed) {
 		timeout = jiffies + WAITnexttimeout;
 		do {
@@ -835,6 +862,12 @@ static inline Scb *alloc_scbs(struct Scs
 			printk(KERN_ERR "wd7000: can't get enough free SCBs.\n");
 			return (NULL);
--
 	while (icb.phase) {
 		cpu_relax();	/* wait for completion */
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (tmp) {
 		if (tmp == cmd) {
 			if (prev)
@@ -1644,6 +1649,12 @@ wd33c93_abort(struct scsi_cmnd * cmd)
 		}
 		prev = tmp;
--
-	while (tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (tmp) {
 		if (tmp == cmd) {
 			printk
 			    ("scsi%d: Abort - command found on disconnected_Q - ",
@@ -1735,6 +1751,12 @@ wd33c93_abort(struct scsi_cmnd * cmd)
 			return FAILED;
--
 	while (*p1 && (i < MAX_SETUP_ARGS)) {
 		p2 = strchr(p1, ',');
 		if (p2) {
@@ -1797,6 +1824,12 @@ wd33c93_setup(char *str)
 			setup_args[i] = p1;
 			break;
--
-		while (cmd) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)",
 				cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (struct scsi_cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
--
-		while (cmd) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)",
 				cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (struct scsi_cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
--
 	while(ptr) {
 		Scsi_Cmnd *next;
 
@@ -1241,6 +1246,12 @@ static void free_hard_reset_SCs(struct S
 		}
 
--
 	while(MSGO_I<MSGOLEN) {
 		DPRINTK(debug_msgo, DEBUG_LEAD "message byte %02x (%d/%d)\n", CMDINFO(CURRENT_SC), MSGO(MSGO_I), MSGO_I, MSGOLEN);
 
@@ -2054,6 +2070,12 @@ static void msgo_run(struct Scsi_Host *s
 			CURRENT_SC->SCp.phase |= resetted;
 
--
 	while(CMD_I<CURRENT_SC->cmd_len) {
 		DPRINTK(debug_cmd, DEBUG_LEAD "command byte %02x (%d/%d)\n", CMDINFO(CURRENT_SC), CURRENT_SC->cmnd[CMD_I], CMD_I, CURRENT_SC->cmd_len);
 
@@ -2113,6 +2140,12 @@ static void cmd_run(struct Scsi_Host *sh
 		}
 
--
-			while(fifodata>0 && CURRENT_SC->SCp.this_residual>0) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while(fifodata>0 && CURRENT_SC->SCp.this_residual>0) {
                         	data_count = fifodata>CURRENT_SC->SCp.this_residual ?
 						CURRENT_SC->SCp.this_residual :
 						fifodata;
@@ -2240,17 +2278,34 @@ static void datai_run(struct Scsi_Host *
                                		CURRENT_SC->SCp.ptr           = SG_ADDRESS(CURRENT_SC->SCp.buffer);
--
 			while(fifodata>0) {
 				int data;
 				data=GETPORT(DATAPORT);
 				DPRINTK(debug_datai, DEBUG_LEAD "data=%02x\n", CMDINFO(CURRENT_SC), data);
 				fifodata--;
 				DATA_LEN++;
--
 		while(data_count>0) {
 			CURRENT_SC->SCp.buffer--;
 			CURRENT_SC->SCp.buffers_residual++;
 			data_count -= CURRENT_SC->SCp.buffer->length;
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while(ptr) {
 		Scsi_Cmnd *next = SCNEXT(ptr);
 
@@ -2494,6 +2565,12 @@ static void rsti_run(struct Scsi_Host *s
 		}
 
--
 		while ( setup_count<ARRAY_SIZE(setup) &&
 			(dev=pnp_find_dev(NULL, id_table[i].vendor, id_table[i].function, dev)) ) {
 			if (pnp_device_attach(dev) < 0)
@@ -3824,6 +3906,12 @@ static int __init aha152x_init(void)
 				"aha152x: found ISAPnP adapter at io=0x%03x, irq=%d\n",
 				setup[setup_count].io_port, setup[setup_count].irq);
--
 		while (tag_mask & dcb->tag_mask
 		       && tag_number < dcb->max_command) {
 			tag_mask = tag_mask << 1;
 			tag_number++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (left_io) {
 				unsigned char *virt, *base = NULL;
 				unsigned long flags = 0;
@@ -2325,6 +2341,12 @@ static void data_in_phase0(struct Adapte
 
 				scsi_kunmap_atomic_sg(base);
--
 			while (left_io) {
 				unsigned char *virt, *base = NULL;
 				unsigned long flags = 0;
@@ -2503,6 +2530,11 @@ static void data_io_transfer(struct Adap
 
 				left_io -= len;
--
 				while (len--) {
 					if (debug_enabled(DBG_PIO))
 						printk(" %02x", *virt);
@@ -2510,10 +2542,22 @@ static void data_io_transfer(struct Adap
 					DC395x_write8(acb, TRM_S1040_SCSI_FIFO, *virt++);
 
--
-	while (pages--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (pages--) {
 		ptr = kmalloc(PAGE_SIZE, GFP_KERNEL);
 		if (!ptr) {
 			adapter_sg_tables_free(acb);
@@ -4286,6 +4335,12 @@ static int __devinit adapter_sg_tables_a
 		while (i < srbs_per_page && srb_idx < DC395x_MAX_SRB_CNT)
 			acb->srb_array[srb_idx++].segment_x =
 			    ptr + (i++ * DC395x_MAX_SG_LISTENTRY);
+			    if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((status_reg_value & TW_STATUS_RESPONSE_QUEUE_EMPTY) == 0) && (count < TW_MAX_RESPONSE_DRAIN)) {
 		response_que_value = readl(TW_RESPONSE_QUEUE_REG_ADDR(tw_dev));
 		status_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((response_que_value & TW_9550SX_DRAIN_COMPLETED) != TW_9550SX_DRAIN_COMPLETED) {
 			response_que_value = readl(TW_RESPONSE_QUEUE_REG_ADDR_LARGE(tw_dev));
 			msleep(1);
 			if (time_after(jiffies, before + HZ * 30))
 				goto out;
+				if (_cur < timeout) {
--
 		while (tw_dev->pending_request_count > 0) {
 			request_id = tw_dev->pending_queue[tw_dev->pending_head];
 			if (tw_dev->state[request_id] != TW_S_PENDING) {
@@ -1285,6 +1312,12 @@ static irqreturn_t twa_interrupt(int irq
 				/* If we get here, we will continue re-posting on the next command interrupt */
 				break;
--
 		while ((status_reg_value & TW_STATUS_RESPONSE_QUEUE_EMPTY) == 0) {
 			/* Complete the response */
 			response_que.value = readl(TW_RESPONSE_QUEUE_REG_ADDR(tw_dev));
@@ -1367,6 +1405,12 @@ static irqreturn_t twa_interrupt(int irq
 					goto twa_interrupt_bail;
 				}
--
 	while ((status_reg_value & flag) != flag) {
 		status_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));
 
@@ -1494,6 +1543,12 @@ static int twa_poll_status(TW_Device_Ext
 			goto out;
 
--
 	while ((status_reg_value & flag) != 0) {
 		status_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));
 		if (twa_check_bits(status_reg_value))
@@ -1522,6 +1582,12 @@ static int twa_poll_status_gone(TW_Devic
 			goto out;
 
--
 	while (tries < TW_MAX_RESET_TRIES) {
 		if (do_soft_reset) {
 			TW_SOFT_RESET(tw_dev);
@@ -1705,6 +1776,12 @@ static int twa_reset_sequence(TW_Device_
 		/* If we got here, controller is in a good state */
 		retval = 0;
--
 	while ((status_reg_value & flag) != flag) {
 		status_reg_value = inl(TW_STATUS_REG_ADDR(tw_dev));
 
@@ -318,6 +323,12 @@ static int tw_poll_status(TW_Device_Exte
 			goto out;
 
--
 	while ((status_reg_value & flag) != 0) {
 		status_reg_value = inl(TW_STATUS_REG_ADDR(tw_dev));
 
@@ -347,6 +363,12 @@ static int tw_poll_status_gone(TW_Device
 			goto out;
 
--
 	while ((status_reg_value & TW_STATUS_RESPONSE_QUEUE_EMPTY) == 0) {
 		response_que_value = inl(TW_RESPONSE_QUEUE_REG_ADDR(tw_dev));
 		status_reg_value = inl(TW_STATUS_REG_ADDR(tw_dev));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (tries < TW_MAX_RESET_TRIES) {
 		TW_SOFT_RESET(tw_dev);
 
@@ -1226,6 +1264,12 @@ static int tw_reset_sequence(TW_Device_E
 
 		/* Now the controller is in a good state */
--
 	while (phy != &mvi->phy[phy_no]) {
 		phy_no++;
 		if (phy_no >= MVS_MAX_PHYS)
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (mvi->rx_cons != rx_prod_idx) {
 		/* increment our internal RX consumer pointer */
 		rx_prod_idx = (rx_prod_idx + 1) & (MVS_RX_RING_SZ - 1);
@@ -2190,6 +2206,12 @@ int mvs_int_rx(struct mvs_info *mvi, boo
 		} else if (rx_desc & RXQ_SLOT_RESET) {
 			mvs_slot_free(mvi, rx_desc);
--
 	while (waits--) {
 		if (atomic_read(&pinstance->outstanding_cmds) <=
 		    PMCRAID_MAX_HCAM_CMD)
 			return SUCCESS;
 		msleep(interval);
+		if (_cur < timeout) {
--
 	while ((resp & HRRQ_TOGGLE_BIT) ==
 		pinstance->host_toggle_bit[id]) {
 
@@ -4649,6 +4665,12 @@ static void pmcraid_tasklet_function(uns
 		/* loop over until we are done with all responses */
 		spin_lock_irqsave(lockp, hrrq_lock_flags);
--
-	while ((req = readl(&hba->u.itl.iop->outbound_queue)) !=
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((req = readl(&hba->u.itl.iop->outbound_queue)) !=
 						IOPMU_QUEUE_EMPTY) {
 
 		if (req & IOPMU_QUEUE_MASK_HOST_BITS)
@@ -110,6 +115,12 @@ static void hptiop_drain_outbound_queue_
 			else
--
 	while ((key = strsep(&ips_str, ",."))) {
 		if (!*key)
 			continue;
@@ -539,6 +544,12 @@ ips_setup(char *ips_str)
 				break;
 			}
--
 		while ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {
 			scb->scsi_cmd->result = DID_ERROR << 16;
 			scb->scsi_cmd->scsi_done(scb->scsi_cmd);
 			ips_freescb(ha, scb);
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while ((scsi_cmd = ips_removeq_wait_head(&ha->scb_waitlist))) {
 			scsi_cmd->result = DID_ERROR;
 			scsi_cmd->scsi_done(scsi_cmd);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {
 			scb->scsi_cmd->result = DID_ERROR << 16;
 			scb->scsi_cmd->scsi_done(scb->scsi_cmd);
 			ips_freescb(ha, scb);
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while ((scsi_cmd = ips_removeq_wait_head(&ha->scb_waitlist))) {
 			scsi_cmd->result = DID_ERROR << 16;
 			scsi_cmd->scsi_done(scsi_cmd);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {
 		scb->scsi_cmd->result = DID_RESET << 16;
 		scb->scsi_cmd->scsi_done(scb->scsi_cmd);
 		ips_freescb(ha, scb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (TRUE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (TRUE) {
 		sp = &ha->sp;
 
 		intrstatus = (*ha->func.isintr) (ha);
@@ -1321,6 +1392,12 @@ ips_intr_copperhead(ips_ha_t * ha)
 		 * NOTE: interrupts are OFF for this
--
 	}			/* end while */
 	return 1;
 }
@@ -2648,6 +2725,11 @@ ips_next(ips_ha_t * ha, int intr)
 	 * since we limit the number that can be active
 	 * on the card at any one time
--
 	while ((ha->num_ioctl < IPS_MAX_IOCTL) &&
 	       (ha->copp_waitlist.head) && (scb = ips_getscb(ha))) {
 
@@ -2710,6 +2792,12 @@ ips_next(ips_ha_t * ha, int intr)
 			break;
 		}		/* end case */
--
 	while ((p) && (scb = ips_getscb(ha))) {
 		if ((scmd_channel(p) > 0)
 		    && (ha->
@@ -2824,6 +2917,12 @@ ips_next(ips_ha_t * ha, int intr)
 
 		p = (struct scsi_cmnd *) p->host_scribble;
--
 	}			/* end while */
 
 	if (intr == IPS_INTR_ON)
@@ -4673,11 +4772,22 @@ ips_flush_and_reset(ips_ha_t *ha)
 	        time = 60 * IPS_ONE_SEC;	              /* Max Wait time is 60 seconds */
 	        done = 0;
--
 	        while ((time > 0) && (!done)) {
 		   done = ips_poll_for_flush_complete(ha);
 	           /* This may look evil, but it's only done during extremely rare start-up conditions ! */
 	           udelay(1000);
 	           time--;
+	           if (_cur < timeout) {
--
 	while (reset_counter < 2) {
 		reset_counter++;
 
@@ -5119,6 +5234,12 @@ ips_reset_copperhead(ips_ha_t * ha)
 
 			return (0);
--
 	while (reset_counter < 2) {
 		reset_counter++;
 
@@ -5164,6 +5290,12 @@ ips_reset_copperhead_memio(ips_ha_t * ha
 
 			return (0);
--
 	while (reset_counter < 2) {
 		reset_counter++;
 
@@ -5208,6 +5345,12 @@ ips_reset_morpheus(ips_ha_t * ha)
 
 			return (0);
--
 	while (days < 0 || days >= year_lengths[yleap = IPS_IS_LEAP_YEAR(year)]) {
 		int newy;
 
@@ -6114,6 +6262,12 @@ ips_fix_ffdc_time(ips_ha_t * ha, ips_scb
 		    IPS_NUM_LEAP_YEARS_THROUGH(newy - 1) -
 		    IPS_NUM_LEAP_YEARS_THROUGH(year - 1);
--
 	while (tmp) {
 		if (tmp == cmd) {
 			if (prev)
@@ -1709,6 +1714,12 @@ static int __in2000_abort(Scsi_Cmnd * cm
 		}
 		prev = tmp;
--
 	while (*p1 && (i < MAX_SETUP_ARGS)) {
 		p2 = strchr(p1, ',');
 		if (p2) {
@@ -1836,6 +1852,12 @@ static void __init in2000_setup(char *st
 			setup_args[i] = p1;
 			break;
--
 		while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)", cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (Scsi_Cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)", cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (Scsi_Cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&cmds)) {
 		tcmd = list_entry(cmds.next, struct scsi_tgt_cmd, hash_list);
 		list_del(&tcmd->hash_list);
@@ -288,6 +293,12 @@ void scsi_tgt_free_queue(struct Scsi_Hos
 
 		shost->hostt->eh_abort_handler(cmd);
--
 					while ((cmd->SCp.Status) && ((z > 0) || (odd))) {
 						if (odd) {
 							*(cmd->SCp.ptr) = zwickel >> 8;
@@ -243,15 +248,37 @@ static irqreturn_t eata_pio_int_handler(
 							z--;
 							odd = 1;
--
 					while (z > 0) {
 						zwickel = inw(base + HA_RDATA);
 						z--;
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
--
 					while ((cmd->SCp.Status) && ((z > 0) || (odd))) {
 						if (odd) {
 							zwickel += *(cmd->SCp.ptr) << 8;
@@ -270,11 +297,28 @@ static irqreturn_t eata_pio_int_handler(
 							IncStat(&cmd->SCp, 1);
 							odd = 1;
--
 					while (z > 0 || odd) {
 						outw(zwickel, base + HA_RDATA);
 						z--;
 						odd = 0;
+						if (_cur < timeout) {
+							rdstcll(_cur);
--
 	while ((dev = pci_get_device(PCI_VENDOR_ID_DPT, PCI_DEVICE_ID_DPT, dev)) != NULL) {
 		DBG(DBG_PROBE && DBG_PCI, printk("eata_pio: find_PCI, HBA at %s\n", pci_name(dev)));
 		if (pci_enable_device(dev))
@@ -941,6 +990,12 @@ static void find_pio_PCI(struct get_conf
 			}
 #endif
--
 	while (!done) {
 		/* Pull all the valid messages off the CRQ */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while ((crq = crq_queue_next_crq(&hostdata->queue)) != NULL) {
 			ibmvscsi_handle_crq(crq, hostdata);
 			crq->valid = 0x00;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!list_empty(&hostdata->sent)) {
 		evt = list_first_entry(&hostdata->sent, struct srp_event_struct, list);
 		list_del(&evt->list);
@@ -494,6 +499,12 @@ static void purge_requests(struct ibmvsc
 			evt->done(evt);
 		free_event_struct(&evt->hostdata->pool, evt);
--
 	while (!done) {
 		/* Pull all the valid messages off the async CRQ */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while ((async = ibmvfc_next_async_crq(vhost)) != NULL) {
 			ibmvfc_handle_async(async, vhost);
 			async->valid = 0;
 			wmb();
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while ((crq = ibmvfc_next_crq(vhost)) != NULL) {
 			ibmvfc_handle_crq(crq, vhost);
 			crq->valid = 0;
 			wmb();
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!done) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((crq = next_crq(&vport->crq_queue)) != NULL) {
 			process_crq(crq, target);
 			crq->valid = 0x00;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while((siop = ffz(sir)) < p->siops) {
 		sir |= 1<<siop;
 		ncr53c8xx_intr(irq, p->hosts[siop]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (first != NULL) {
 		if (first->opcode != ExecSCSI)
 			return first;
@@ -788,6 +793,12 @@ static struct scsi_ctrl_blk *initio_find
 			return first;
 		}
--
 	while (tmp != NULL) {
 		/* 07/27/98 */
 		if (tmp->srb == srbp) {
@@ -990,9 +1006,20 @@ static int initio_abort_srb(struct initi
 		}
 		prev = tmp;
--
 	while (tmp != NULL) {
 		if (tmp->srb == srbp) {
 			if (tmp == host->active) {
@@ -1024,6 +1051,12 @@ static int initio_abort_srb(struct initi
 		}
 		prev = tmp;
--
 	while ((scb = initio_pop_busy_scb(host)) != NULL) {
 		scb->hastat = HOST_BAD_PHAS;
 		initio_append_done_scb(host, scb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((scb = initio_pop_busy_scb(host)) != NULL) {
 		scb->hastat = HOST_BAD_PHAS;
 		initio_append_done_scb(host, scb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((scb = initio_pop_busy_scb(host)) != NULL) {
 		scb->hastat = HOST_BAD_PHAS;
 		initio_append_done_scb(host, scb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (tmp != NULL) {
 		if (tmp->target == tar) {
 			/* unlink it */
@@ -2420,6 +2491,12 @@ int initio_bus_device_reset(struct initi
 			prev = tmp;
 		}
--
-   while (pDCB->TargetID != id || pDCB->TargetLUN != lun)
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
+     while (pDCB->TargetID != id || pDCB->TargetLUN != lun)
      {
 	pDCB = pDCB->pNextDCB;
 	if (pDCB == pACB->pLinkDCB)
 	     return NULL;
+	     if (_cur < timeout) {
--
-		while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
-		    spin_unlock_irq(pACB->pScsiHost->host_lock);
-		    udelay(50);
-		    spin_lock_irq(pACB->pScsiHost->host_lock);
+	    if (pSRB->SGToBeXferLen) {
+		    unsigned long long delta = (cpu / khz / HZ) * 2;
--
+		    while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
+		        spin_unlock_irq(pACB->pScsiHost->host_lock);
+		        udelay(50);
+		        spin_lock_irq(pACB->pScsiHost->host_lock);
+		        if (_cur < timeout) {
+		            rdstcll(_cur);
--
-		while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
-		    spin_unlock_irq(pACB->pScsiHost->host_lock);
-		    udelay(50);
-		    spin_lock_irq(pACB->pScsiHost->host_lock);
+	    if (pSRB->SGToBeXferLen) {
+		    unsigned long long delta = (cpu / khz / HZ) * 2;
--
+		    while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
+			    spin_unlock_irq(pACB->pScsiHost->host_lock);
+			    udelay(50);
+			    spin_lock_irq(pACB->pScsiHost->host_lock);
+			    if (_cur < timeout) {
+			        rdstcll(_cur);
--
 	    while( bval & 0x1f )
 	    {
 		DEBUG1(printk (KERN_DEBUG "Check for residuals,"));
@@ -882,6 +922,12 @@ dc390_DataIn_0(struct dc390_acb* pACB, s
 		}
 		else
--
 	while (pSRB->TotalXferredLen + (unsigned long) sg_dma_len(psgl) < pSRB->Saved_Ptr)
 	{
 	    pSRB->TotalXferredLen += (unsigned long) sg_dma_len(psgl);
@@ -1160,6 +1211,12 @@ dc390_restore_ptr (struct dc390_acb* pAC
 	    }
 	    else
--
-#define ACCEPT_MSG(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
+#define ACCEPT_MSG(port) {unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
--
-#define ACCEPT_MSG_ATN(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
+#define ACCEPT_MSG_ATN(port) {unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
--
 		while (RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST) {
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
--
 	while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
 	       (TimeOutLoop++ < 20000)) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 			while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
 			       (TimeOutLoop++ < 20000)) {
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 		while (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {
 			if (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {
 
 				WRW_HARPOON((port + hp_intstat), PHASE);
 				return;
 			}
--
 	while (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {
 		if (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {
 
 			WRW_HARPOON((port + hp_intstat), PHASE);
 			return;
 		}
--
 			while (!
 			       (RDW_HARPOON((port + hp_intstat)) &
 				(BUS_FREE | PHASE))) {
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
 			       (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))
 			{
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
 			       (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))
 			{
+				if (_cur < timeout) {
+				    rdstcll(_cur);
+				}
--
 	while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (!(RDW_HARPOON((port + hp_intstat)) & TIMEOUT)) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET)) &&
 	       (curr_phz ==
 		(RD_HARPOON(p_port + hp_scsisig) & (unsigned char)S_SCSI_PHZ)))
@@ -3783,6 +3931,12 @@ static void FPT_sxfrp(unsigned long p_po
 				WR_HARPOON(p_port + hp_fifodata_0, 0xFA);
 			}
--
 	while (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET))) {
@@ -3792,14 +3946,36 @@ static void FPT_sxfrp(unsigned long p_po
 
 	WR_HARPOON(p_port + hp_portctrl_0,
 		   (SCSI_PORT | HOST_PORT | SCSI_INBIT));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
--
 	while (!(RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY)) {
 		RD_HARPOON(p_port + hp_fifodata_0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 		while (!(RDW_HARPOON((p_port + hp_intstat)) & AUTO_INT)) {
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
--
 	while (RD_HARPOON(port + hp_scsisig) & SCSI_ACK) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 		while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | PHASE))) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
--
 		while ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) &&
 		       (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 			while ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY))
 			       && (RD_HARPOON(port + hp_ext_status) &
 				   BM_CMD_BUSY)) {
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while ((sg_count < (unsigned char)SG_BUF_CNT) &&
 	       ((unsigned long)(sg_index * (unsigned int)SG_ELEMENT_SIZE) <
 		pcurrSCCB->DataLength)) {
@@ -5030,6 +5255,12 @@ static void FPT_busMstrSGDataXferStart(u
 		sg_index++;
 		sg_count++;
--
 	while ((!(RD_HARPOON(p_port + hp_ext_status) & CMD_ABORTED))
 	       && timeout--) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 		while ((RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY)
 		       && timeout--) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 			while ((RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)
 			       && timeout--) {
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
--
 			while (remain_cnt < 0x01000000L) {
 
 				sg_ptr--;
@@ -5263,6 +5532,12 @@ static void FPT_hostDataXferAbort(unsign
 
 					break;
--
 				while ((RD_HARPOON(port + hp_ext_status) &
 					BM_CMD_BUSY)
 				       && ((RD_HARPOON(port + hp_fifo_cnt)) >=
 					   BM_THRESHOLD) && timeout--) {
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 				while ((RD_HARPOON(port + hp_ext_status) &
 					BM_CMD_BUSY) && timeout--) {
+						if (_cur < timeout) {
+					rdstcll(_cur);
+						}
+						else {
--
 			while ((RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)
 			       && timeout--) {
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 		while (data_count < currSCCB->Sccb_ATC) {
 
 			sg_index++;
 			data_count += *(sg_ptr + (sg_index * 2));
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (RD_HARPOON(p_port + hp_scsisig) & (SCSI_SEL | SCSI_BSY)) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
--
 	while (!i) {
 
 		for (k = 0; k < ID_STRING_LENGTH; k++) {
@@ -5866,6 +6201,12 @@ static void FPT_scasid(unsigned char p_c
 			i = 1;
 		}
--
 	}			/*End while */
 
 	FPT_scxferc(p_port, SYNC_PTRN);
@@ -6080,6 +6421,11 @@ static void FPT_scwirod(unsigned long p_
 	unsigned char i;
 
--
 	while (i < MAX_SCSI_TAR) {
 
 		if (RD_HARPOON(p_port + hp_scsidata_0) & p_data_bit)
@@ -6090,6 +6436,12 @@ static void FPT_scwirod(unsigned long p_
 
 			i++;
--
 	while (i < MAX_SCSI_TAR) {
 
 		if (RD_HARPOON(p_port + hp_scsisig) & p_data_bit)
@@ -6117,6 +6474,12 @@ static void FPT_scwiros(unsigned long p_
 
 			i++;
--
 	while (!(RDW_HARPOON((p_port + hp_intstat)) &
 		 (RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
-		while (!(RDW_HARPOON((p_port + hp_intstat)) & BUS_FREE)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!(RDW_HARPOON((p_port + hp_intstat)) & BUS_FREE)) {
 			if (RD_HARPOON(p_port + hp_scsisig) & SCSI_REQ) {
 				WR_HARPOON(p_port + hp_scsisig,
 					   (SCSI_ACK + S_ILL_PH));
 				ACCEPT_MSG(p_port);
 			}
--
 	while (!(RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL)) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (i > 0) {
 		i--;
 
@@ -6380,6 +6781,12 @@ static unsigned char FPT_scmachid(unsign
 			else
 				match = MAX_SCSI_TAR - 1;
--
 	while (i > 0) {
 
 		i--;
@@ -6424,6 +6836,12 @@ static unsigned char FPT_scmachid(unsign
 			else
 				match = MAX_SCSI_TAR - 1;
--
 	while (q_ptr != NULL) {
 
 		if (q_ptr == p_SCCB) {
@@ -7183,6 +7606,12 @@ static unsigned char FPT_queueFindSccb(s
 		else {
 			q_ptr = q_ptr->Sccb_forwardlink;
--
 		while (((unsigned long)sg_index *
 			(unsigned long)SG_ELEMENT_SIZE) < p_SCCB->DataLength) {
 
 			partial_cnt += *(sg_ptr + (sg_index * 2));
 			sg_index++;
+			if (_cur < timeout) {
--
-	while (i != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i != 0) {
 
 		if (i & ee_addr)
 			ee_value |= SEE_DO;
@@ -7537,6 +7982,12 @@ static void FPT_utilEESendCmdAddr(unsign
 		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
--
 		while (MCA_NOTFOUND != (slot = mca_find_adapter(fd_mcs_adapters[loop].id, slot))) {
 
 			/* if we get this far, an adapter has been detected and is
@@ -511,6 +516,12 @@ static int fd_mcs_detect(struct scsi_hos
 				outb(PARITY_MASK, TMC_Cntl_port);
 				/* done reset */
--
-		while ((data_count = FIFO_Size - inw(FIFO_Data_Count_port)) > 512) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((data_count = FIFO_Size - inw(FIFO_Data_Count_port)) > 512) {
 #if EVERY_ACCESS
 			printk("DC=%d, ", data_count);
 #endif
@@ -979,9 +995,20 @@ static irqreturn_t fd_mcs_intr(int irq,
 				} else
--
-		while ((data_count = inw(FIFO_Data_Count_port)) > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((data_count = inw(FIFO_Data_Count_port)) > 0) {
 #if EVERY_ACCESS
 			printk("DC=%d, ", data_count);
 #endif
@@ -1010,6 +1037,12 @@ static irqreturn_t fd_mcs_intr(int irq,
 				current_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);
--
 	while (!kthread_should_stop()) {
 		schedule();
 		spin_lock_bh(&bg->fcoe_rx_list.lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while ((skb = __skb_dequeue(&bg->fcoe_rx_list)) != NULL) {
 			spin_unlock_bh(&bg->fcoe_rx_list.lock);
 			bnx2fc_recv_frame(skb);
 			spin_lock_bh(&bg->fcoe_rx_list.lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!kthread_should_stop()) {
 		schedule();
 		spin_lock_bh(&p->fp_work_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (!list_empty(&p->work_list)) {
 			list_splice_init(&p->work_list, &work_list);
 			spin_unlock_bh(&p->fp_work_lock);
@@ -614,9 +646,21 @@ int bnx2fc_percpu_io_thread(void *arg)
 			}
 
--
-	while (sg_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (sg_len) {
 		if (sg_len >= BNX2FC_BD_SPLIT_SZ)
 			frag_size = BNX2FC_BD_SPLIT_SZ;
 		else
@@ -1598,6 +1603,12 @@ static int bnx2fc_split_bd(struct bnx2fc
 		addr += (u64) frag_size;
--
 	while (((wqe = cqe->wqe) & FCOE_CQE_TOGGLE_BIT) ==
 	       (tgt->cq_curr_toggle_bit <<
 	       FCOE_CQE_TOGGLE_BIT_SHIFT)) {
@@ -1071,6 +1076,12 @@ unlock:
 			tgt->cq_curr_toggle_bit =
 				1 - tgt->cq_curr_toggle_bit;
--
 	while (i < num_cqe) {
 		kcqe = (struct fcoe_kcqe *) kcq[i++];
 
@@ -1384,6 +1400,12 @@ void bnx2fc_indicate_kcqe(void *context,
 			printk(KERN_ERR PFX "unknown opcode 0x%x\n",
 								kcqe->op_code);
--
-			while (--i >= 0) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (--i >= 0) {
 				dma_free_coherent(&hba->pcidev->dev,
 						    BNX2FC_HASH_TBL_CHUNK_SIZE,
 						    hba->hash_tbl_segments[i],
 						    dma_segment_array[i]);
 				hba->hash_tbl_segments[i] = NULL;
--
 	while (*pbl && *(pbl + 1)) {
 		u32 lo;
 		u32 hi;
@@ -2076,6 +2114,12 @@ static int bnx2fc_allocate_hash_table(st
 		hi = *pbl;
 		++pbl;
--
 	while (hba->tgt_ofld_list[conn_id] != NULL) {
 		conn_id++;
 		if (conn_id == BNX2FC_NUM_MAX_SESS)
@@ -611,6 +616,12 @@ static u32 bnx2fc_alloc_conn_id(struct b
 			spin_unlock_bh(&hba->hba_lock);
 			return -1;
--
 	while (num_pages--) {
 		*pbl = (u32)page;
 		pbl++;
 		*pbl = (u32)((u64)page >> 32);
 		pbl++;
 		page += PAGE_SIZE;
--
 	while (num_pages--) {
 		*pbl = (u32)page;
 		pbl++;
 		*pbl = (u32)((u64)page >> 32);
 		pbl++;
 		page += PAGE_SIZE;
--
 	while (inb(iobase + REG_AUX_STATUS) & ABSY_ASSERTED) {
 		udelay(1L);
 		if (--loop == 0)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (!(inb(iobase + REG_STATUS) & DRQ_ASSERTED)) {
 			udelay(1L);
 			if (--loop == 0)
 				return 1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
-	while ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {
 		addr = pci_resource_start(dev, 0);
 
 #if defined(DEBUG_PCI_DETECT)
@@ -1048,6 +1075,12 @@ static struct pci_dev *get_pci_dev(unsig
 		pci_dev_put(dev);
--
-	while ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {
 #if defined(DEBUG_PCI_DETECT)
 		printk("%s: enable_pci_ports, bus %d, devfn 0x%x.\n",
 		       driver_name, dev->bus->number, dev->devfn);
@@ -1068,6 +1106,12 @@ static void enable_pci_ports(void)
 			printk
--
 	while (cur && (pc = strchr(cur, ':'))) {
 		int val = 0, c = *++pc;
 
@@ -1498,6 +1547,12 @@ static void internal_setup(char *str, in
 
 		if ((cur = strchr(cur, ',')))
--
 	while (cur && isdigit(*cur) && i < MAX_INT_PARAM) {
 		ints[i++] = simple_strtoul(cur, NULL, 0);
 
 		if ((cur = strchr(cur, ',')) != NULL)
 			cur++;
+			if (_cur < timeout) {
--
 		while (reset_status(shpnt) == IM_RESET_IN_PROGRESS && --ticks) {
 			udelay((1 + 999 / HZ) * 1000);
 			barrier();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (immediate_feature(shpnt, speedrun, adapter_timeout) == 2) {
 		probe_display(1);
 		if (speedrun == 7)
@@ -1146,6 +1162,12 @@ static void check_devices(struct Scsi_Ho
 		speedrun++;
 		if (speedrun > 7)
--
 		while ((token = strsep(&str, ",")) != NULL) {
 			if (!strcmp(token, "activity"))
 				display_mode |= LED_ACTIVITY;
@@ -1423,6 +1450,12 @@ static void internal_ibmmca_scsi_setup(c
 					scsi_id[id_base++] = simple_strtoul(token, NULL, 0);
 				j++;
--
 			while (ld(shpnt)[next_ldn(shpnt)].cmd) {	/* search for a occupied, but not in */
 				/* command-processing ldn. */
 				next_ldn(shpnt)++;
@@ -1745,6 +1783,12 @@ static int ibmmca_queuecommand_lck(Scsi_
 						done(cmd);
 					return 0;
--
 	 * interrupt will not be executed, while we are in here! */
 	 
 	/* FIXME: This is really really icky we so want a sleeping version of this ! */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (reset_status(shpnt) == IM_RESET_IN_PROGRESS && --ticks && ((inb(IM_INTR_REG(shpnt)) & 0x8f) != 0x8f)) {
 		udelay((1 + 999 / HZ) * 1000);
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cur && isdigit(*cur) && i < IM_MAX_HOSTS) {
 		ints[i++] = simple_strtoul(cur, NULL, 0);
 		if ((cur = strchr(cur, ',')) != NULL)
 			cur++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!iscsi_tcp_segment_done(tcp_conn, segment, 0, r)) {
 		struct scatterlist *sg;
 		unsigned int offset, copy;
@@ -301,6 +306,12 @@ static int iscsi_sw_tcp_xmit_segment(str
 			return r;
 		}
--
 	while (iscsi_sw_tcp_xmit_qlen(conn)) {
 		rc = iscsi_sw_tcp_xmit(conn);
 		if (rc == 0)
 			return -EAGAIN;
 		if (rc < 0)
 			return rc;
--
 	while (reqlen) {
 		i = inb(base + PIO_STATUS);
 		/* VDEB(printk("pio_status=%x\n", i)); */
@@ -286,12 +291,29 @@ SYM53C500_pio_read(int fast_pio, int bas
 				request += len & 0xfc; 
 				reqlen -= len & 0xfc; 
--
 				while (len--) {
 					*request++ = inb(base + PIO_FIFO);
 					reqlen--;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 	while (reqlen && !(i & 0x40)) {
 		i = inb(base + PIO_STATUS);
 		/* VDEB(printk("pio_status=%x\n", i)); */
@@ -337,12 +364,29 @@ SYM53C500_pio_write(int fast_pio, int ba
 				request += len & 0xfc;
 				reqlen -= len & 0xfc;
--
 				while (len--) {
 					outb(*request++, base + PIO_FIFO);
 					reqlen--;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
-    while (len > 0) {
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+	while (len > 0) {
 	unsigned int this_len;
 
 	if (len + offset > (1 << 12))
@@ -942,6 +947,12 @@ void acornscsi_data_read(AS_Host *host,
 	    page ++;
--
-    while (len > 0) {
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+	while (len > 0) {
 	unsigned int this_len;
 
 	if (len + offset > (1 << 12))
@@ -987,6 +1003,12 @@ void acornscsi_data_write(AS_Host *host,
 	    page ++;
--
 	while ((s = strsep(&str, ",")) != NULL) {
 		switch (s[0]) {
 		case 'a':
@@ -133,6 +138,12 @@ static int __init fas216_log_setup(char
 			level_mask |= LOG_FUNCTIONDONE;
 			break;
--
 		while (fifo && info->scsi.SCp.ptr) {
 			*info->scsi.SCp.ptr = fas216_readb(info, REG_FF);
 			fas216_updateptrs(info, 1);
 			fifo--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {
 			int i;
 
@@ -1329,6 +1356,12 @@ static void fas216_send_messageout(FAS21
 
 			msg->fifo = tot_msglen - (fas216_readb(info, REG_CFIS) & CFIS_CF);
--
 		while ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {
 			printk("{ ");
 			for (i = 0; i < msg->length; i++)
 				printk("%02x ", msg->msg[i]);
 			printk("} ");
+			if (_cur < timeout) {
--
 		while ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {
 			for (i = 0; i < msg->length; i++)
 				fas216_writeb(info, REG_FF, msg->msg[i]);
 			msg->fifo = tot_msglen - (fas216_readb(info, REG_CFIS) & CFIS_CF);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!info->internal_done) {
 		/*
 		 * If we don't have an IRQ, then we must poll the card for
@@ -2303,6 +2363,12 @@ static int fas216_noqueue_command_lck(st
 			fas216_intr(info);
 			spin_unlock_irq(info->host->host_lock);
--
   while(1)
   {
     int status;
     while (((status = readw(base + STAT)) & 0x100)==0);
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
--
   while(len > 0)
   {
     unsigned int status, timeout;
@@ -79,6 +95,11 @@ printk("reading %p len %d\n", addr, len)
     
     timeout = 0x01FFFFFF;
--
     while (((status = readw(base + STAT)) & 0x100)==0)
     {
       timeout--;
@@ -87,6 +108,12 @@ printk("reading %p len %d\n", addr, len)
         printk("status = %08X\n", status);
         return 1;
--
 			while (length >= 256) {
 				unsigned int status = readb(info->base + CUMANASCSI2_STATUS);
 
@@ -251,9 +256,20 @@ cumanascsi_2_dma_pseudo(struct Scsi_Host
 				       addr, 256 >> 1);
 				addr += 256;
--
 		while (length > 0) {
 			unsigned long word;
 			unsigned int status = readb(info->base + CUMANASCSI2_STATUS);
@@ -270,6 +286,12 @@ cumanascsi_2_dma_pseudo(struct Scsi_Host
 				*addr++ = word >> 8;
 				length --;
--
-	while (time_before(jiffies, i) && !priv->qabort &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, i) && !priv->qabort &&
 					!((k = inb(qbase + 4)) & 0xe0)) {
 		barrier();
 		cpu_relax();
+		if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!priv->qabort && ((i & 0x20) != 0x20)) {
 		barrier();
 		cpu_relax();
 		i |= inb(qbase + 5);
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (priv->qlcmd != NULL) {
 		barrier();
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (len >= plen) {
 		rdata->spp_type = rspp->spp_type;
 		spp->spp_type = rspp->spp_type;
@@ -1765,6 +1770,12 @@ static void fc_rport_recv_prli_req(struc
 		len -= plen;
 		rspp = (struct fc_els_spp *)((char *)rspp + plen);
--
 	while (remaining > 0 && sg) {
 		if (offset >= sg->length) {
 			offset -= sg->length;
@@ -684,6 +689,12 @@ static int fc_fcp_send_data(struct fc_fc
 			return error;
 		}
--
 	while (fc_exch_ptr_get(pool, index)) {
 		index = index == mp->pool_max_index ? 0 : index + 1;
 		if (index == pool->next_index)
 			goto err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (fc_cpu_mask < nr_cpu_ids) {
 		fc_cpu_mask <<= 1;
 		fc_cpu_order++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (hba->status_tail != hba->status_head) {
 		resp = stex_get_status(hba);
 		tag = le16_to_cpu(resp->tag);
@@ -846,6 +851,12 @@ static void stex_mu_intr(struct st_hba *
 			stex_scsi_done(ccb);
 		} else
--
 	while (count < hba->sts_count) {
 		scratch = hba->scratch + hba->status_tail;
 		value = le32_to_cpu(*scratch);
@@ -951,6 +967,12 @@ static void stex_ss_mu_intr(struct st_hb
 			stex_scsi_done(ccb);
 		} else
--
-		while (readl(base + OMR0) != MU_HANDSHAKE_SIGNATURE) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (readl(base + OMR0) != MU_HANDSHAKE_SIGNATURE) {
 			if (time_after(jiffies, before + MU_MAX_DELAY * HZ)) {
 				printk(KERN_ERR DRV_NAME
 					"(%s): no handshake signature\n",
@@ -1000,6 +1027,12 @@ static int stex_common_handshake(struct
 			}
--
-	while (readl(base + OMR0) != MU_HANDSHAKE_SIGNATURE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (readl(base + OMR0) != MU_HANDSHAKE_SIGNATURE) {
 		if (time_after(jiffies, before + MU_MAX_DELAY * HZ)) {
 			printk(KERN_ERR DRV_NAME
 				"(%s): no signature after handshake frame\n",
@@ -1050,6 +1088,12 @@ static int stex_common_handshake(struct
 		}
--
-	while ((readl(base + YIOA_STATUS) & SS_MU_OPERATIONAL) == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((readl(base + YIOA_STATUS) & SS_MU_OPERATIONAL) == 0) {
 		if (time_after(jiffies, before + MU_MAX_DELAY * HZ)) {
 			printk(KERN_ERR DRV_NAME
 				"(%s): firmware not operational\n",
@@ -1082,6 +1131,12 @@ static int stex_ss_handshake(struct st_h
 			return -1;
--
-	while (hba->mu_status == MU_STATE_RESETTING) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (hba->mu_status == MU_STATE_RESETTING) {
 		spin_unlock_irqrestore(hba->host->host_lock, flags);
 		wait_event_timeout(hba->reset_waitq,
 				   hba->mu_status != MU_STATE_RESETTING,
 				   MU_MAX_DELAY * HZ);
 		spin_lock_irqsave(hba->host->host_lock, flags);
--
 	while (hba->ccb[tag].req_type & PASSTHRU_REQ_TYPE) {
 		if (time_after(jiffies, before + ST_INTERNAL_TIMEOUT * HZ)) {
 			hba->ccb[tag].req_type = 0;
 			return;
 		}
 		msleep(1);
--
 	while (hostdata->eh_complete != NULL) {
 		spin_unlock_irq(SCp->device->host->host_lock);
 		msleep_interruptible(100);
 		spin_lock_irq(SCp->device->host->host_lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-		while (!list_empty(&fc_host_rport_bindings(shost))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&fc_host_rport_bindings(shost))) {
 			get_list_head_entry(rport,
 				&fc_host_rport_bindings(shost), peers);
 			list_del(&rport->peers);
 			rport->port_state = FC_PORTSTATE_DELETED;
 			fc_queue_work(shost, &rport->rport_delete_work);
--
 	while (rport->port_state == FC_PORTSTATE_BLOCKED &&
 	       !(rport->flags & FC_RPORT_FAST_FAIL_TIMEDOUT)) {
 		spin_unlock_irqrestore(shost->host_lock, flags);
 		msleep(1000);
 		spin_lock_irqsave(shost->host_lock, flags);
+		if (_cur < timeout) {
--
-	while (!list_empty(&conn->mgmtqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&conn->mgmtqueue)) {
 		conn->task = list_entry(conn->mgmtqueue.next,
 					 struct iscsi_task, running);
 		list_del_init(&conn->task->running);
@@ -1473,10 +1478,21 @@ check_mgmt:
 		rc = iscsi_xmit_task(conn);
--
-	while (!list_empty(&conn->cmdqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&conn->cmdqueue)) {
 		conn->task = list_entry(conn->cmdqueue.next, struct iscsi_task,
 					running);
 		list_del_init(&conn->task->running);
@@ -1505,6 +1521,12 @@ check_mgmt:
 		 */
--
 	while (!list_empty(&conn->requeue)) {
diff -u -p a/scsi/mvumi.c b/scsi/mvumi.c
--- a/scsi/mvumi.c
+++ b/scsi/mvumi.c
@@ -370,12 +370,23 @@ static void mvumi_free_cmds(struct mvumi
 {
--
-	while (!list_empty(&mhba->cmd_pool)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->cmd_pool)) {
 		cmd = list_first_entry(&mhba->cmd_pool, struct mvumi_cmd,
 							queue_pointer);
 		list_del(&cmd->queue_pointer);
 		kfree(cmd->frame);
 		kfree(cmd);
--
-	while (!list_empty(&mhba->cmd_pool)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->cmd_pool)) {
 		cmd = list_first_entry(&mhba->cmd_pool, struct mvumi_cmd,
 						queue_pointer);
 		list_del(&cmd->queue_pointer);
 		kfree(cmd->frame);
 		kfree(cmd);
--
 	while ((tmp != HANDSHAKE_READYSTATE) && (tmp != HANDSHAKE_DONESTATE)) {
 		if (tmp != HANDSHAKE_READYSTATE)
 			iowrite32(DRBL_MU_RESET,
@@ -1080,6 +1107,12 @@ static unsigned char mvumi_check_handsha
 		usleep_range(1000, 2000);
 		rmb();
--
-	while (!list_empty(&mhba->free_ob_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->free_ob_list)) {
 		pool = list_first_entry(&mhba->free_ob_list,
 						struct mvumi_ob_data, list);
 		list_del_init(&pool->list);
@@ -1307,6 +1345,12 @@ static void mvumi_handle_clob(struct mvu
 			mvumi_complete_cmd(mhba, cmd, ob_frame);
--
-	while (!list_empty(&mhba->waiting_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->waiting_req_list)) {
 		cmd = list_first_entry(&mhba->waiting_req_list,
 					 struct mvumi_cmd, queue_pointer);
 		list_del_init(&cmd->queue_pointer);
@@ -1395,6 +1444,12 @@ static void mvumi_fire_cmd(struct mvumi_
 
--
 	while(pos != NULL && (next = strchr(pos, ':')) != NULL) {
 		int val = (int)simple_strtoul(++next, NULL, 0);
 
@@ -152,6 +157,12 @@ param_setup(char *string)
 		}
 		if((pos = strchr(pos, ARG_SEP)) != NULL)
--
 	while (len) {
 		/*
 		 * even cntinfo could be up to 16383, without
@@ -86,6 +91,12 @@ void fill_hpc_entries(struct ip22_hostda
 		hcp++;
 		len -= count;
--
 	while (start < end) {
 		hcp->desc.pnext = (u32) (dma + sizeof(struct hpc_chunk));
 		hcp->desc.cntinfo = HPCDMA_EOX;
 		hcp++;
 		dma += sizeof(struct hpc_chunk);
 		start += sizeof(struct hpc_chunk);
--
 	while (sdev->device_busy) {
 		msleep_interruptible(200);
 		scsi_run_queue(sdev->request_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (reqlen) {
 		i = inb(PIO_STATUS);
 		/*    VDEB(printk("pio_status=%x\n", i)); */
@@ -387,12 +392,29 @@ static __inline__ int NCR53c406a_pio_rea
 				request += len & 0xfc;
 				reqlen -= len & 0xfc;
--
 				while (len--) {
 					*request++ = inb(PIO_FIFO);
 					reqlen--;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 	while (reqlen && !(i & 0x40)) {
 		i = inb(PIO_STATUS);
 		/*    VDEB(printk("pio_status=%x\n", i)); */
@@ -437,12 +464,29 @@ static __inline__ int NCR53c406a_pio_wri
 				request += len & 0xfc;
 				reqlen -= len & 0xfc;
--
 				while (len--) {
 					outb(*request++, PIO_FIFO);
 					reqlen--;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
-		while(((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while(((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF)
 				&& (i++ < ARCMSR_MAX_OUTSTANDING_CMD)) {
 			pARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));/*frame must be 32 bytes aligned*/
 			pCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);
 			error = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;
 			arcmsr_drain_donequeue(acb, pCCB, error);
--
 		while ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) && (i++ < ARCMSR_MAX_OUTSTANDING_CMD)) {
 			/*need to do*/
 			flag_ccb = readl(&reg->outbound_queueport_low);
@@ -988,6 +1004,12 @@ static void arcmsr_done4abort_postqueue(
 			pCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);
 			error = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;
--
 		while (iop_len > 0) {
 			pQbuffer = (struct QBUFFER *)&acb->rqbuffer[rqbuf_lastindex];
 			memcpy(pQbuffer, iop_data, 1);
@@ -1395,6 +1422,12 @@ static void arcmsr_iop2drv_data_wrote_ha
 			rqbuf_lastindex %= ARCMSR_MAX_QBUFFER;
 			iop_data++;
--
 		while ((acb->wqbuf_firstindex != acb->wqbuf_lastindex) && \
 							(allxfer_len < 124)) {
 			pQbuffer = &acb->wqbuffer[acb->wqbuf_firstindex];
@@ -1426,6 +1464,12 @@ static void arcmsr_iop2drv_data_read_han
 			acb->wqbuf_firstindex %= ARCMSR_MAX_QBUFFER;
 			iop_data++;
--
 	while ((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF) {
 		pARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));/*frame must be 32 bytes aligned*/
 		pCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);
 		error = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;
 		arcmsr_drain_donequeue(acb, pCCB, error);
+		if (_cur < timeout) {
--
 	while ((flag_ccb = readl(&reg->done_qbuffer[index])) != 0) {
 		writel(0, &reg->done_qbuffer[index]);
 		pARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+(flag_ccb << 5));/*frame must be 32 bytes aligned*/
@@ -1507,6 +1567,12 @@ static void arcmsr_hbb_postqueue_isr(str
 		index++;
 		index %= ARCMSR_MAX_HBB_POSTQUEUE;
--
 		while ((wqbuf_firstindex != wqbuf_lastindex) && (allxfer_len < 124)) {
 			pQbuffer = &acb->wqbuffer[wqbuf_firstindex];
 			memcpy(iop_data, pQbuffer, 1);
@@ -1716,6 +1787,12 @@ void arcmsr_post_ioctldata2iop(struct Ad
 			wqbuf_firstindex %= ARCMSR_MAX_QBUFFER;
 			iop_data++;
--
 		while ((acb->rqbuf_firstindex != acb->rqbuf_lastindex)
 			&& (allxfer_len < 1031)) {
 			pQbuffer = &acb->rqbuffer[acb->rqbuf_firstindex];
@@ -1770,6 +1852,12 @@ static int arcmsr_iop_message_xfer(struc
 			acb->rqbuf_firstindex %= ARCMSR_MAX_QBUFFER;
 			ptmpQbuffer++;
--
 			while (iop_len > 0) {
 				acb->rqbuffer[acb->rqbuf_lastindex] = readb(iop_data);
 				acb->rqbuf_lastindex++;
 				acb->rqbuf_lastindex %= ARCMSR_MAX_QBUFFER;
 				iop_data++;
 				iop_len--;
--
 				while (user_len > 0) {
 					pQbuffer =
 					&acb->wqbuffer[acb->wqbuf_lastindex];
@@ -1846,6 +1950,12 @@ static int arcmsr_iop_message_xfer(struc
 					acb->wqbuf_lastindex %= ARCMSR_MAX_QBUFFER;
 					ptmpuserbuffer++;
--
 	while (count){
 		*acb_firm_model = readb(iop_firm_model);
 		acb_firm_model++;
 		iop_firm_model++;
 		count--;
+		if (_cur < timeout) {
--
 	while (count){
 		*acb_firm_version = readb(iop_firm_version);
 		acb_firm_version++;
 		iop_firm_version++;
 		count--;
+		if (_cur < timeout) {
--
 	while(count){
 		*acb_device_map = readb(iop_device_map);
 		acb_device_map++;
 		iop_device_map++;
 		count--;
+		if (_cur < timeout) {
--
 	while (count) {
 		*acb_firm_model = readb(iop_firm_model);
 		acb_firm_model++;
 		iop_firm_model++;
 		count--;
+		if (_cur < timeout) {
--
 	while (count) {
 		*acb_firm_version = readb(iop_firm_version);
 		acb_firm_version++;
 		iop_firm_version++;
 		count--;
+		if (_cur < timeout) {
--
 	while ((acb->rqbuf_firstindex != acb->rqbuf_lastindex)
 		&& (allxfer_len < 1031)) {
 		pQbuffer = &acb->rqbuffer[acb->rqbuf_firstindex];
@@ -84,6 +89,12 @@ static ssize_t arcmsr_sysfs_iop_message_
 		acb->rqbuf_firstindex %= ARCMSR_MAX_QBUFFER;
 		ptmpQbuffer++;
--
 		while (iop_len > 0) {
 			acb->rqbuffer[acb->rqbuf_lastindex] = readb(iop_data);
 			acb->rqbuf_lastindex++;
 			acb->rqbuf_lastindex %= ARCMSR_MAX_QBUFFER;
 			iop_data++;
 			iop_len--;
--
 			while (user_len > 0) {
 				pQbuffer =
 				&acb->wqbuffer[acb->wqbuf_lastindex];
@@ -142,6 +169,12 @@ static ssize_t arcmsr_sysfs_iop_message_
 				acb->wqbuf_lastindex %= ARCMSR_MAX_QBUFFER;
 				ptmpuserbuffer++;
--
 	while (ms->phase == idle) {
 		prev = NULL;
 		for (cmd = ms->request_q; ; cmd = (struct scsi_cmnd *) cmd->host_scribble) {
@@ -583,6 +588,12 @@ static void mesh_start(struct mesh_state
 			ms->request_qtail = prev;
 
--
 	while ((in_8(&mr->bus_status1) & BS1_BSY) == 0) {
 		static int mesh_aborted_resels;
 		mesh_aborted_resels++;
@@ -912,6 +928,12 @@ static void reselected(struct mesh_state
 		udelay(5);
 		dlog(ms, "extra resel err/exc/fc = %.6x",
--
 	while ((cmd = ms->request_q) != NULL) {
 		ms->request_q = (struct scsi_cmnd *) cmd->host_scribble;
 		cmd->result = DID_RESET << 16;
 		mesh_completed(ms, cmd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		/* wait a little while until the fifo drains */
 		t = 50;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (t > 0 && in_8(&mr->fifo_count) != 0
 		       && (in_le32(&md->status) & ACTIVE) != 0) {
 			--t;
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while(ms->phase != idle) {
 		spin_unlock_irqrestore(ms->host->host_lock, flags);
 		msleep(10);
 		spin_lock_irqsave(ms->host->host_lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while (!list_empty(&list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&list)) {
 		struct isci_request *ireq = list_entry(list.next, typeof(*ireq), dev_node);
 
 		/* Change state to "terminating" if it is currently
@@ -829,6 +834,12 @@ void isci_terminate_pending_requests(str
 		 */
--
 	while (parity_check != 0) {
 		if (parity_check & 0x1)
 			parity_count++;
 		parity_check >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (uf_control->buffers.array[frame_get].state == UNSOLICITED_FRAME_RELEASED) {
 		uf_control->buffers.array[frame_get].state = UNSOLICITED_FRAME_EMPTY;
 
@@ -217,6 +222,12 @@ bool sci_unsolicited_frame_control_relea
 			frame_get = 0;
 		} else
--
-		while (phy_index < SCI_MAX_PHYS) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (phy_index < SCI_MAX_PHYS) {
 			if ((phy_mask & (1 << phy_index)) == 0)
 				continue;
 			sci_phy_get_sas_address(&ihost->phys[phy_index],
@@ -311,6 +316,12 @@ sci_mpc_agent_validate_phy_configuration
 					      &ihost->phys[phy_index]);
--
-	while (phy_index < SCI_MAX_PHYS) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (phy_index < SCI_MAX_PHYS) {
 		port_index = phy_index;
 
 		/* Get the assigned SAS Address for the first PHY on the controller. */
 		sci_phy_get_sas_address(&ihost->phys[phy_index],
 					    &sas_address);
--
-		while (++phy_index < SCI_MAX_PHYS) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (++phy_index < SCI_MAX_PHYS) {
 			sci_phy_get_sas_address(&ihost->phys[phy_index],
 						     &phy_assigned_address);
 
@@ -460,6 +481,18 @@ sci_apc_agent_validate_phy_configuration
 				port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
--
-	while (
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (
 		NORMALIZE_GET_POINTER_CYCLE_BIT(get_cycle)
 		== COMPLETION_QUEUE_CYCLE_BIT(ihost->completion_queue[get_index])
 		) {
@@ -550,6 +555,12 @@ static void sci_controller_process_compl
 				 ent);
--
 		while (sg) {
 			scu_sg = to_sgl_element_pair(ireq, sg_idx);
 			init_sgl_element(&scu_sg->A, sg);
@@ -135,6 +140,12 @@ static void sci_request_build_sgl(struct
 
 			prev_sg = scu_sg;
--
 		while (total_len > 0) {
 			struct page *page = sg_page(sg);
 
@@ -1310,6 +1326,12 @@ sci_stp_request_pio_data_in_copy_data_bu
 			total_len -= copy_len;
 			src_addr += copy_len;
--
 		while (i--) {
 			id = i / SCI_NUM_MSI_X_INT;
 			ihost = pci_info->hosts[id];
 			msix = &pci_info->msix_entries[i];
 			devm_free_irq(&pdev->dev, msix->vector, ihost);
+			if (_cur < timeout) {
--
 	while (fcnt--) {
 		esp->fifo[idx++] = esp_read8(ESP_FDATA);
 		esp->fifo[idx++] = esp_read8(ESP_FDATA);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((compl = be_mcc_compl_get(phba))) {
 		if (compl->flags & CQE_FLAGS_ASYNC_MASK) {
 			/* Interpret flags as an async trailer */
@@ -287,6 +292,12 @@ int beiscsi_process_mcc(struct beiscsi_h
 		}
 		be_mcc_compl_use(compl);
--
-	while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 				& EQE_VALID_MASK) {
 		if (((eqe->dw[offsetof(struct amap_eq_entry,
 		     resource_id) / 32] &
@@ -640,6 +645,12 @@ static irqreturn_t be_isr_mcc(int irq, v
 		queue_tail_inc(eq);
--
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 					& EQE_VALID_MASK) {
 			if (!blk_iopoll_sched_prep(&pbe_eq->iopoll))
 				blk_iopoll_sched(&pbe_eq->iopoll);
@@ -683,13 +699,24 @@ static irqreturn_t be_isr_msix(int irq,
 			queue_tail_inc(eq);
--
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 						& EQE_VALID_MASK) {
 			spin_lock_irqsave(&phba->isr_lock, flags);
 			phba->todo_cq = 1;
@@ -698,6 +725,12 @@ static irqreturn_t be_isr_msix(int irq,
 			queue_tail_inc(eq);
--
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 					& EQE_VALID_MASK) {
 			if (((eqe->dw[offsetof(struct amap_eq_entry,
 			     resource_id) / 32] &
@@ -767,6 +805,12 @@ static irqreturn_t be_isr(int irq, void
 			AMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);
--
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 						& EQE_VALID_MASK) {
 
 			if (((eqe->dw[offsetof(struct amap_eq_entry,
@@ -804,6 +853,12 @@ static irqreturn_t be_isr(int irq, void
 			queue_tail_inc(eq);
--
-	while ((*pep_read_ptr) != cq_index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((*pep_read_ptr) != cq_index) {
 		(*pep_read_ptr)++;
 		*pep_read_ptr = (*pep_read_ptr) % num_entries;
 
@@ -1477,6 +1537,12 @@ hwi_update_async_writables(struct hwi_as
 		}
--
-	while (mcc_compl->flags & CQE_FLAGS_VALID_MASK) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (mcc_compl->flags & CQE_FLAGS_VALID_MASK) {
 
 		if (num_processed >= 32) {
 			hwi_ring_cq_db(phba, mcc_cq->id,
@@ -1810,6 +1881,12 @@ static void  beiscsi_process_mcc_isr(str
 		mcc_compl = queue_tail_node(mcc_cq);
--
 	while (sol->dw[offsetof(struct amap_sol_cqe, valid) / 32] &
 	       CQE_VALID_MASK) {
 		be_dws_le_to_cpu(sol, sizeof(struct sol_cqe));
@@ -1949,6 +2031,12 @@ static unsigned int beiscsi_process_cq(s
 		queue_tail_inc(cq);
 		sol = queue_tail_node(cq);
--
 	while ((i) || (j)) {
 		for (j = mem_descr->num_elements; j > 0; j--) {
 			pci_free_consistent(phba->pcidev,
@@ -2310,6 +2403,12 @@ free_mem:
 			kfree(mem_descr->mem_array);
 			mem_descr--;
--
 	while (idx < mem_descr_sglh->num_elements) {
 		psgl_handle = mem_descr_sglh->mem_array[idx].virtual_address;
 
@@ -3349,6 +3453,12 @@ static int beiscsi_init_sgl_handle(struc
 			psgl_handle++;
 		}
--
 	while (idx < mem_descr_sg->num_elements) {
 		pfrag = mem_descr_sg->mem_array[idx].virtual_address;
 
@@ -3381,6 +3496,12 @@ static int beiscsi_init_sgl_handle(struc
 				phba->fw_config.iscsi_icd_start + arr_index++;
 		}
--
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 					& EQE_VALID_MASK) {
 			AMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);
 			queue_tail_inc(eq);
 			eqe = queue_tail_node(eq);
 			num_processed++;
--
 		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
 		{
 			// FIXME - no timeout
-		}
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 			while ((abs_state <= MFI_STATE_FW_INIT) &&
 			       (retry++ < 1000)) {
 				msleep(100);
 				abs_state =
 				instance->instancet->read_fw_status_reg(
 					instance->reg_set) & MFI_STATE_MASK;
--
-	while ( !( HostDiag & DIAG_WRITE_ENABLE) ) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ( !( HostDiag & DIAG_WRITE_ENABLE) ) {
 		msleep(100);
 		HostDiag = (u32)readl(hostdiag_offset);
 		printk(KERN_NOTICE "RESETGEN2: retry=%x, hostdiag=%x\n",
@@ -780,6 +785,12 @@ megasas_adp_reset_gen2(struct megasas_in
 		if (retry++ >= 100)
--
-	while ( ( HostDiag & DIAG_RESET_ADAPTER) ) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ( ( HostDiag & DIAG_RESET_ADAPTER) ) {
 		msleep(100);
 		HostDiag = (u32)readl(hostdiag_offset);
 		printk(KERN_NOTICE "RESET_GEN2: retry=%x, hostdiag=%x\n",
@@ -798,6 +814,12 @@ megasas_adp_reset_gen2(struct megasas_in
 		if (retry++ >= 1000)
--
-	while (consumer != producer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (consumer != producer) {
 		context = instance->reply_queue[consumer];
 		if (context >= instance->max_fw_cmds) {
 			printk(KERN_ERR "Unexpected context value %x\n",
@@ -1668,6 +1695,12 @@ static void megasas_complete_cmd_dpc(uns
 		if (consumer == (instance->max_fw_cmds + 1)) {
--
-		while (!list_empty(&clist_local)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&clist_local)) {
 			reset_cmd	= list_entry((&clist_local)->next,
 						struct megasas_cmd, list);
 			list_del_init(&reset_cmd->list);
@@ -1780,6 +1818,12 @@ static int megasas_wait_for_outstanding(
 					reset_cmd);
--
-	while (!list_empty(&clist_local)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&clist_local)) {
 		cmd	= list_entry((&clist_local)->next,
 					struct megasas_cmd, list);
 		list_del_init(&cmd->list);
@@ -2393,6 +2442,12 @@ megasas_issue_pending_cmds_again(struct
 				"internal reset defer list while re-issue!!\n",
 				cmd);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (fw_state != MFI_STATE_READY) {
 
 		abs_state =
@@ -2804,6 +2864,12 @@ megasas_transition_to_ready(struct megas
 			       "in %d secs\n", fw_state, max_wait);
 			return -ENODEV;
--
 	while (!list_empty(&adapter->pend_list)) {
 
 		assert_spin_locked(PENDING_LIST_LOCK(adapter));
@@ -1964,6 +1969,12 @@ megaraid_mbox_runpendq(adapter_t *adapte
 		}
 
--
 	while ( STp->buffer->syscall_result && time_before(jiffies, startwait + timeout*HZ) &&
 	       (( SRpnt->sense[2]  == 2 && SRpnt->sense[12] == 4    &&
 		 (SRpnt->sense[13] == 1 || SRpnt->sense[13] == 8)    ) ||
@@ -786,6 +791,12 @@ static int osst_wait_ready(struct osst_t
 	    cmd[0] = TEST_UNIT_READY;
 
--
-	while ( STp->buffer->syscall_result && time_before(jiffies, startwait + timeout*HZ) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while ( STp->buffer->syscall_result && time_before(jiffies, startwait + timeout*HZ) &&
 		SRpnt->sense[2] == 2 && SRpnt->sense[12] == 0x3a && SRpnt->sense[13] == 0  ) {
 #if DEBUG
 	    if (debugging) {
@@ -844,6 +860,12 @@ static int osst_wait_for_medium(struct o
 	    cmd[0] = TEST_UNIT_READY;
--
 	while (++retries < 10) {
 	   if (ppos_estimate > STp->eod_frame_ppos-2) {
 	       frame_seq_estimate += STp->eod_frame_ppos - 2 - ppos_estimate;
@@ -1356,6 +1383,12 @@ static int osst_seek_logical_blk(struct
 	      ppos_estimate += frame_seq_estimate - STp->frame_seq_number;
 	   else
--
 				while ( !flag && time_before(jiffies, startwait + 60*HZ) ) {
 
 					memset(cmd, 0, MAX_COMMAND_SIZE);
@@ -1621,6 +1659,12 @@ static int osst_read_back_buffer_and_rew
 					if (STp->buffer->syscall_result)
 						flag = 1;
--
 	while (cnt != mt_count) {
 		last_mark_ppos = ntohl(STp->buffer->aux->last_mark_ppos);
 		if (last_mark_ppos == -1)
@@ -1927,7 +1976,13 @@ static int osst_space_over_filemarks_bac
 					 name, last_mark_ppos);
 			return (-EIO);
--
 		while (cnt != mt_count) {
 			next_mark_ppos = ntohl(STp->buffer->aux->next_mark_ppos);
 			if (!next_mark_ppos || next_mark_ppos > STp->eod_frame_ppos) {
@@ -2132,6 +2192,12 @@ static int osst_space_over_filemarks_for
 						 name, next_mark_ppos);
 				return (-EIO);
--
 	while (count--) {
 		memcpy(STp->buffer->b_data, "Filler", 6);
 		STp->buffer->buffer_bytes = 6;
@@ -2250,6 +2321,12 @@ static int osst_write_filler(struct osst
 			printk(KERN_INFO "%s:I: Couldn't write filler frame\n", name);
 			return (-EIO);
--
 	while (count--) {
 		osst_copy_to_buffer(STp->buffer, (unsigned char *)STp->header_cache);
 		STp->buffer->buffer_bytes = sizeof(os_header_t);
@@ -2276,6 +2358,12 @@ static int __osst_write_header(struct os
 			printk(KERN_INFO "%s:I: Couldn't write header frame\n", name);
 			return (-EIO);
--
 	while ((STp->buffer)->buffer_bytes + count > write_threshold)
 	{
 		doing_write = 1;
@@ -3634,6 +3727,12 @@ if (SRpnt) printk(KERN_ERR "%s:A: Not su
 		}
 		STp->buffer->buffer_bytes = 0;
--
 	}  /* end while write threshold exceeded */
 
 	if (count != 0) {
@@ -5592,6 +5691,11 @@ static int __init osst_setup (char *str)
 	for (i = 0; i < ints[0] && i < ARRAY_SIZE(parms); i++)
 		  *parms[i].val = ints[i + 1];
--
 	while (stp != NULL) {
 		for (i = 0; i < ARRAY_SIZE(parms); i++) {
 			int len = strlen(parms[i].name);
@@ -5608,6 +5712,12 @@ static int __init osst_setup (char *str)
 		stp = strchr(stp, ',');
 		if (stp)
--
-		while((nstatus = (volatile u8)adapter->mbox->m_in.numstatus)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while((nstatus = (volatile u8)adapter->mbox->m_in.numstatus)
 				== 0xFF) {
 			cpu_relax();
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (r != (unsigned char) 0xf0) {
 		/*
 		 * If we have been running for more than a full timer tick
@@ -617,6 +622,12 @@ static int ppa_completion(struct scsi_cm
 		/* If not, drop back down to the scheduler and wait a timer tick */
 		if (!(r & 0x80))
--
 	while (!kthread_should_stop()) {
 
 		spin_lock_bh(&p->fcoe_rx_list.lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while ((skb = __skb_dequeue(&p->fcoe_rx_list)) == NULL) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			spin_unlock_bh(&p->fcoe_rx_list.lock);
@@ -1746,9 +1756,21 @@ int fcoe_percpu_receive_thread(void *arg
 			if (kthread_should_stop())
 				return 0;
--
-		while (len > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (len > 0) {
 			clen = min(len, PAGE_SIZE - (off & ~PAGE_MASK));
 			data = kmap_atomic(
 				skb_frag_page(frag) + (off >> PAGE_SHIFT),
@@ -216,6 +221,12 @@ u32 fcoe_fc_crc(struct fc_frame *fp)
 			kunmap_atomic(data, KM_SKB_DATA_SOFTIRQ);
--
 	while ((skb = __skb_dequeue(&port->fcoe_pending_queue)) != NULL) {
 		spin_unlock_bh(&port->fcoe_pending_queue.lock);
 		kfree_skb(skb);
 		spin_lock_bh(&port->fcoe_pending_queue.lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--loop_count && (sbus_readw(qpti->qregs + HCCTRL) & HCCTRL_HIRQ)) {
 		barrier();
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (sg_count > 0) {
 			struct Continuation_Entry *cont;
 
@@ -937,6 +953,12 @@ static inline int load_cmd(struct scsi_c
 			}
 			sg_count -= n;
--
 	while (out_ptr != in_ptr) {
 		u_int cmd_slot;
 
@@ -1184,6 +1211,12 @@ static struct scsi_cmnd *qlogicpti_intr_
 		sbus_writew(out_ptr, qpti->qregs + MBOX5);
 		Cmnd->host_scribble = (unsigned char *) done_queue;
--
 	while (len > 0) {
 		rtrc(2);
 		while (NCR5380_read(DTC_CONTROL_REG) & CSR_HOST_BUF_NOT_RDY)
@@ -386,6 +391,12 @@ static inline int NCR5380_pread(struct S
 		rtrc(7);
 		/*** with int's on, it sometimes hangs after here.
 		 * Looks like something makes HBNR go away. */
+		if (_cur < timeout) {
--
 	while (!(NCR5380_read(DTC_CONTROL_REG) & D_CR_ACCESS))
diff -u -p a/scsi/qla4xxx/ql4_os.c b/scsi/qla4xxx/ql4_os.c
--- a/scsi/qla4xxx/ql4_os.c
+++ b/scsi/qla4xxx/ql4_os.c
@@ -2198,6 +2198,11 @@ static int qla4xxx_cmd_wait(struct scsi_
 	DEBUG2(ql4_printk(KERN_INFO, ha, "Wait up to %d seconds for cmds to "
--
 	while (!time_after_eq(jiffies, wtime)) {
 		spin_lock_irqsave(&ha->hardware_lock, flags);
 		/* Find a command that hasn't completed. */
@@ -2219,6 +2224,12 @@ static int qla4xxx_cmd_wait(struct scsi_
 			return QLA_SUCCESS;
 
--
 	while (time_before(jiffies, wait_online)) {
 
 		if (adapter_up(ha))
 			return QLA_SUCCESS;
 
 		msleep(2000);
--
-	while (done == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (done == 0) {
 		done = qla4_8xxx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);
 		done &= 2;
 		timeout++;
@@ -901,6 +906,12 @@ qla4_8xxx_wait_rom_done(struct scsi_qla_
 					DRIVER_NAME);
--
 	while ((qla4_8xxx_rom_lock(ha) != 0) && (loops < 50000)) {
 		udelay(100);
 		loops++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((state != PHAN_PEG_RCV_INITIALIZED) && (loops < 30000)) {
 		udelay(100);
 		/* Window 1 call */
@@ -1478,6 +1505,12 @@ static int qla4_8xxx_rcvpeg_ready(struct
 		read_unlock(&ha->hw_lock);
 
--
 	while (1) {
 		qla4_8xxx_idc_lock(ha);
 
@@ -1860,6 +1898,12 @@ int qla4_8xxx_device_state_handler(struc
 			rval = QLA_ERROR;
 			goto exit;
--
 	while ((qla4_8xxx_rom_lock(ha) != 0) && (loops < 50000)) {
 		udelay(100);
 		cond_resched();
 		loops++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((ha->response_ptr->signature != RESPONSE_PROCESSED)) {
 		sts_entry = (struct status_entry *) ha->response_ptr;
 		count++;
@@ -474,6 +479,12 @@ void qla4xxx_process_response_queue(stru
 		}
 		((struct response *)sts_entry)->signature = RESPONSE_PROCESSED;
--
 	while (ha->aen_out != ha->aen_in) {
 		aen = &ha->aen_q[ha->aen_out];
 		/* copy aen information to local structure */
@@ -1083,6 +1099,12 @@ void qla4xxx_process_aen(struct scsi_qla
 			}
 		}
--
 	while (drvr_wait) {
 		if (ql4xxx_lock_drvr(a) == 0) {
 			ssleep(QL4_LOCK_DRVR_SLEEP);
@@ -645,6 +650,12 @@ int ql4xxx_lock_drvr_wait(struct scsi_ql
 				      "acquired\n", a->host_no, __func__));
 			return QLA_SUCCESS;
--
 	while (!kthread_should_stop() &&
 	       !list_empty(&core->task_queue)) {
 
@@ -907,6 +912,12 @@ static void sas_queue(struct sas_ha_stru
 			list_splice_init(&q, &core->task_queue); /*at head*/
 			core->task_queue_size += can_queue;
--
 	while (res == 0 && dev) {
 		struct expander_device *ex = &dev->ex_dev;
 		int i = 0, phy_id;
@@ -1983,6 +1988,12 @@ int sas_ex_revalidate_domain(struct doma
 
 		dev = NULL;
--
 	while (delay < max_delay) {
 		pcii_reg = readl(ioa_cfg->regs.sense_interrupt_reg);
 
@@ -2582,6 +2587,12 @@ static int ipr_wait_iodbg_ack(struct ipr
 			udelay(delay);
 
--
-	while (delay < IPR_LDUMP_MAX_SHORT_ACK_DELAY_IN_USEC) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (delay < IPR_LDUMP_MAX_SHORT_ACK_DELAY_IN_USEC) {
 		temp_pcii_reg =
 		    readl(ioa_cfg->regs.sense_uproc_interrupt_reg32);
 
@@ -2697,6 +2713,12 @@ static int ipr_get_ldump_data_section(st
 
--
 	while (bytes_copied < length &&
 	       (ioa_dump->hdr.len + bytes_copied) < max_dump_size) {
 		if (ioa_dump->page_offset >= PAGE_SIZE ||
@@ -2768,6 +2795,12 @@ static int ipr_sdt_copy(struct ipr_ioa_c
 			break;
 		}
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count) {
 		if ((off & PAGE_MASK) != ((off + count) & PAGE_MASK))
 			len = PAGE_ALIGN(off) - off;
 		else
@@ -3926,6 +3986,12 @@ static ssize_t ipr_read_dump(struct file
 		buf += len;
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		ipr_cmd = NULL;
 
-		while ((be32_to_cpu(*ioa_cfg->hrrq_curr) & IPR_HRRQ_TOGGLE_BIT) ==
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((be32_to_cpu(*ioa_cfg->hrrq_curr) & IPR_HRRQ_TOGGLE_BIT) ==
 		       ioa_cfg->toggle_bit) {
 
 			cmd_index = (be32_to_cpu(*ioa_cfg->hrrq_curr) &
@@ -5139,6 +5226,12 @@ static irqreturn_t ipr_isr(int irq, void
 				ioa_cfg->hrrq_curr = ioa_cfg->hrrq_start;
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (length) {
 		if (IPR_GET_MODE_PAGE_CODE(mode_hdr) == page_code) {
 			if (mode_hdr->page_length >= (len - sizeof(struct ipr_mode_page_hdr)))
@@ -6512,6 +6638,12 @@ static void *ipr_get_mode_page(struct ip
 			mode_hdr = (struct ipr_mode_page_hdr *)
 				((unsigned long)mode_hdr + page_length);
--
 	while (i-- > 0) {
 		pci_free_consistent(pdev, sizeof(struct ipr_hostrcb),
 				    ioa_cfg->hostrcb[i],
 				    ioa_cfg->hostrcb_dma[i]);
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	 * while (device is not ready to send status byte)
 	 *     loop;
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (r != (unsigned char) 0xb8) {
 		/*
 		 * If we have been running for more than a full timer tick
@@ -723,6 +728,12 @@ static int imm_completion(struct scsi_cm
 		/* If not, drop back down to the scheduler and wait a timer tick */
 		if (!(r & 0x80))
--
 	while (!found) {
 		if (sizeof(dma_addr_t) > 4) {
 			regh = readl(TWL_HOBQPH_REG_ADDR(tw_dev));
@@ -583,6 +588,12 @@ static int twl_poll_response(TW_Device_E
 			goto out;
 
--
 	while (reg & TWL_HISTATUS_RESPONSE_INTERRUPT) {
 		if (sizeof(dma_addr_t) > 4) {
 			regh = readl(TWL_HOBQPH_REG_ADDR(tw_dev));
@@ -1274,6 +1290,12 @@ static irqreturn_t twl_interrupt(int irq
 
 		/* Check for another response interrupt */
--
-        while ((reg_value & value) != result) {
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+	while ((reg_value & value) != result) {
 		reg_value = readl(reg);
 		if (time_after(jiffies, before + HZ * seconds))
 			goto out;
 		msleep(50);
+		if (_cur < timeout) {
--
 	while (tries < TW_MAX_RESET_TRIES) {
 		/* Do a soft reset if one is needed */
 		if (do_soft_reset) {
@@ -1346,6 +1384,11 @@ static int twl_reset_sequence(TW_Device_
 		}
 
--
 		while (i < TW_Q_LENGTH) {
 			writel((u32)((u64)tw_dev->sense_buffer_phys[i] >> 32), TWL_HOBQPH_REG_ADDR(tw_dev));
 			writel((u32)tw_dev->sense_buffer_phys[i], TWL_HOBQPL_REG_ADDR(tw_dev));
@@ -1354,6 +1397,12 @@ static int twl_reset_sequence(TW_Device_
 			status = readl(TWL_STATUS_REG_ADDR(tw_dev));
 			if (!(status & TWL_STATUS_OVERRUN_SUBMIT))
--
-      while ((data_count = FIFO_Size - inw(port_base + FIFO_Data_Count)) > 512) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((data_count = FIFO_Size - inw(port_base + FIFO_Data_Count)) > 512) {
 #if EVERY_ACCESS
 	 printk( "DC=%d, ", data_count ) ;
 #endif
@@ -1329,11 +1334,22 @@ static irqreturn_t do_fdomain_16x0_intr(
 	    } else
--
-      while ((data_count = inw(port_base + FIFO_Data_Count)) > 0) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((data_count = inw(port_base + FIFO_Data_Count)) > 0) {
 #if EVERY_ACCESS
 	 printk( "DC=%d, ", data_count );
 #endif
@@ -1360,6 +1376,12 @@ static irqreturn_t do_fdomain_16x0_intr(
 	    current_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);
--
 			while ((max > 0) && *vendor == ' ') {
 				max--;
 				vendor++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while ((max > 0) && *model == ' ') {
 				max--;
 				model++;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
 			while ((max > 0) && *vendor == ' ') {
 				max--;
 				vendor++;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
--
 			while ((max > 0) && *model == ' ') {
 				max--;
 				model++;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
 	while (&devinfo_table->scsi_dev_info_list == dl->bottom) {
 		dl->top = dl->top->next;
 		if (dl->top == &scsi_dev_info_list) {
@@ -692,6 +741,12 @@ static void *devinfo_seq_next(struct seq
 					   struct scsi_dev_info_list_table,
 					   node);
--
 	while (pdev) {
 		struct domain_device *pdev_p = pdev->parent;
 		if (!pdev_p)
 			return pdev->port->id;
 		pdev = pdev->parent;
+		if (_cur < timeout) {
--
 	while (skb->len >= NLMSG_SPACE(0)) {
 		err = 0;
 
@@ -147,6 +152,12 @@ next_msg:
 			netlink_ack(skb, nlh, err);
 
--
 		while (transports[tport].refcnt != 0) {
 			spin_unlock_irqrestore(&scsi_nl_lock, flags);
 			schedule_timeout_uninterruptible(HZ/4);
 			spin_lock_irqsave(&scsi_nl_lock, flags);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 			while (driver->refcnt != 0) {
 				spin_unlock_irqrestore(&scsi_nl_lock, flags);
 				schedule_timeout_uninterruptible(HZ/4);
 				spin_lock_irqsave(&scsi_nl_lock, flags);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while(pos != NULL && (next = strchr(pos, ':')) != NULL) {
 		int val = (int)simple_strtoul(++next, NULL, 0);
 
@@ -83,6 +88,12 @@ param_setup(char *str)
 		}
 		if((pos = strchr(pos, ARG_SEP)) != NULL)
--
-	while (skb) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (skb) {
 		int frags = skb_shinfo(skb)->nr_frags +
 				(skb->len != skb->data_len);
 
@@ -914,7 +919,13 @@ static int cxgbi_sock_send_pdus(struct c
 		csk->write_seq += skb->len +
--
 	while (i < ddp->nppods) {
 		struct cxgbi_gather_list *gl = ddp->gl_map[i];
 
@@ -1348,6 +1364,12 @@ static void ddp_destroy(struct kref *kre
 			i += npods;
 		} else
--
 	while (i < h->ndevices) {
 		csd = h->dev[i];
 		device_change = hpsa_scsi_find_entry(csd, sd, nsds, &entry);
@@ -906,6 +911,12 @@ static void adjust_hpsa_scsi_table(struc
 			sd[entry] = NULL;
 		}
--
 	while (left) {
 		sz = (left > ioc->malloc_size) ? ioc->malloc_size : left;
 		buff_size[sg_used] = sz;
@@ -2777,6 +2793,12 @@ static int hpsa_big_passthru_ioctl(struc
 		left -= sz;
 		data_ptr += sz;
--
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
 		while (raw_tag != FIFO_EMPTY)
 			raw_tag = next_command(h);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (raw_tag != FIFO_EMPTY) {
 			if (hpsa_tag_contains_index(raw_tag))
 				raw_tag = process_indexed_cmd(h, raw_tag);
 			else
 				raw_tag = process_nonindexed_cmd(h, raw_tag);
+				if (_cur < timeout) {
--
 	while (raw_tag != FIFO_EMPTY) {
 		if (hpsa_tag_contains_index(raw_tag))
 			raw_tag = process_indexed_cmd(h, raw_tag);
 		else
 			raw_tag = process_nonindexed_cmd(h, raw_tag);
+			if (_cur < timeout) {
--
 	while (!list_empty(list)) {
 		c = list_entry(list->next, struct CommandList, list);
 		c->err_info->CommandStatus = CMD_HARDWARE_ERR;
 		finish_cmd(c, c->Header.Tag.lower);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {
 		ahc_delay(1000);  /* delay 1 msec */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {
 
 		scb_index = ahc->qoutfifo[ahc->qoutfifonext];
@@ -923,6 +928,12 @@ ahc_run_qoutfifo(struct ahc_softc *ahc)
 		 */
 		ahc_update_residual(ahc, scb);
--
 	while (syncrate->rate != NULL) {
 
 		if ((ahc->features & AHC_ULTRA2) != 0) {
@@ -2376,6 +2392,12 @@ ahc_find_period(struct ahc_softc *ahc, u
 				return (syncrate->period);
 		}
--
-		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
 			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
 			ahc_dmamap_unload(ahc, scb_data->sg_dmat,
 					  sg_map->sg_dmamap);
@@ -4931,6 +4958,12 @@ ahc_fini_scbdata(struct ahc_softc *ahc)
 					sg_map->sg_vaddr,
--
-	while (qinpos != qintail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (qinpos != qintail) {
 		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinpos]);
 		if (scb == NULL) {
 			printk("qinpos = %d, SCB index = %d\n",
@@ -5944,6 +5982,12 @@ ahc_search_qinfifo(struct ahc_softc *ahc
 			prev_scb = scb;
--
 	while (next != SCB_LIST_NULL) {
 		uint8_t scb_index;
 
@@ -6057,6 +6106,12 @@ ahc_search_qinfifo(struct ahc_softc *ahc
 			prev = next;
 			next = ahc_inb(ahc, SCB_NEXT);
--
 		while (next_scb != NULL) {
 
 			scb = next_scb;
@@ -6158,6 +6218,12 @@ ahc_search_untagged_queues(struct ahc_so
 			case SEARCH_COUNT:
 				break;
--
 	while (scbp_next != NULL) {
 		scbp = scbp_next;
 		scbp_next = LIST_NEXT(scbp, pending_links);
@@ -6454,6 +6525,12 @@ ahc_abort_scbs(struct ahc_softc *ahc, in
 			ahc_done(ahc, scbp);
 			found++;
--
 		while ((ahc_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {
 			sg++;
 			resid += ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (lstate->event_r_idx != lstate->event_w_idx
 	    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {
 		struct ahc_tmode_event *event;
@@ -6819,6 +6912,12 @@ ahc_send_lstate_events(struct ahc_softc
 		lstate->event_r_idx++;
 		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
--
 	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
 
 		if (cur_patch->patch_func(ahc) == 0) {
@@ -6982,6 +7086,12 @@ ahc_check_patch(struct ahc_softc *ahc, c
 			 */
 			cur_patch++;
--
 	while (qinpos != qintail) {
 		printk("%d ", ahc->qinfifo[qinpos]);
 		qinpos++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (scb_index != SCB_LIST_NULL && i++ < 256) {
 		ahc_outb(ahc, SCBPTR, scb_index);
 		printk("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
 		scb_index = ahc_inb(ahc, SCB_NEXT);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (scb_index != SCB_LIST_NULL && i++ < 256) {
 		ahc_outb(ahc, SCBPTR, scb_index);
 		printk("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
 		scb_index = ahc_inb(ahc, SCB_NEXT);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (ahc->qoutfifo[qoutpos] != SCB_LIST_NULL && i++ < 256) {
 		printk("%d ", ahc->qoutfifo[qoutpos]);
 		qoutpos++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (scb_index != SCB_LIST_NULL && i++ < 256) {
 		ahc_outb(ahc, SCBPTR, scb_index);
 		printk("%d ", scb_index);
 		scb_index = ahc_inb(ahc, SCB_NEXT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (symtable->seq(symtable, &key, &data, R_FIRST) == 0) {
 			symbol_t *stored_ptr;
 
 			memcpy(&stored_ptr, data.data, sizeof(stored_ptr));
 			symbol_delete(stored_ptr);
+			if (_cur < timeout) {
--
 	while (node1 != NULL) {
 		node2 = SLIST_NEXT(node1, links);
 		free(node1);
 		node1 = node2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while((node = SLIST_FIRST(symlist_src2)) != NULL) {
 		SLIST_REMOVE_HEAD(symlist_src2, links);
 		SLIST_INSERT_HEAD(symlist_dest, node, links);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (symtable->seq(symtable, &key, &data, flag) == 0) {
 		symbol_t *cursym;
 
@@ -530,6 +568,12 @@ symtable_dump(FILE *ofile, FILE *dfile)
 			break;
 		}
--
 	while (SLIST_FIRST(&masks) != NULL) {
 		char *regname;
 
@@ -587,9 +636,20 @@ symtable_dump(FILE *ofile, FILE *dfile)
 		regname = regnode->symbol->name;
 		regnode = symlist_search(&registers, regname);
--
 	while (SLIST_FIRST(&aliases) != NULL) {
 		char *regname;
 
@@ -599,9 +659,20 @@ symtable_dump(FILE *ofile, FILE *dfile)
 		regname = curnode->symbol->info.ainfo->parent->name;
 		regnode = symlist_search(&registers, regname);
--
 	while (SLIST_FIRST(&registers) != NULL) {
 		symbol_node_t *curnode;
 		u_int value;
@@ -649,10 +720,21 @@ symtable_dump(FILE *ofile, FILE *dfile)
 			tab_str, curnode->symbol->name, tab_str2,
 			value);
--
-	while (SLIST_FIRST(&constants) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (SLIST_FIRST(&constants) != NULL) {
 		symbol_node_t *curnode;
 
 		curnode = SLIST_FIRST(&constants);
@@ -661,6 +743,12 @@ symtable_dump(FILE *ofile, FILE *dfile)
 			curnode->symbol->name,
--
-	while (SLIST_FIRST(&exported_labels) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (SLIST_FIRST(&exported_labels) != NULL) {
 		symbol_node_t *curnode;
 
 		curnode = SLIST_FIRST(&exported_labels);
@@ -688,6 +781,12 @@ symtable_dump(FILE *ofile, FILE *dfile)
 			curnode->symbol->name,
--
 	while ((ch = getopt(argc, argv, "d:i:l:n:o:p:r:I:")) != -1) {
 		switch(ch) {
 		case 'd':
@@ -249,6 +254,12 @@ main(int argc, char *argv[])
 			usage();
 			/* NOTREACHED */
--
 	while (cur_scope != NULL) {
 
 		dump_scope(cur_scope);
 
 		cur_scope = TAILQ_NEXT(cur_scope, scope_links);
+		if (_cur < timeout) {
--
 		while (line < cur_instr->srcline) {
 			fgets(buf, sizeof(buf), ifile);
 				fprintf(listfile, "             \t%s", buf);
 				line++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (cur_patch != NULL && start_instr == cur_patch->begin) {
 		if (func_vals[cur_patch->patch_func] == 0) {
 			int skip;
@@ -670,6 +708,12 @@ check_patch(patch_t **start_patch, int s
 			 */
 			cur_patch = STAILQ_NEXT(cur_patch, links);
--
 	while (cur_scope != NULL) {
 		u_int patch0_patch_skip;
 
@@ -840,5 +889,11 @@ process_scope(scope_t *scope)
 		}
 
--
 	while ((ahd_inb(ahd, LQISTAT2) & LQIGSAVAIL) != 0) {
 		u_int fifo_mode;
 		u_int i;
@@ -1288,6 +1293,12 @@ rescan_fifos:
 			}
 		} else
--
 	while (!SCBID_IS_NULL(scbid)) {
 		uint8_t *hscb_ptr;
 		u_int	 i;
@@ -1349,11 +1365,22 @@ rescan_fifos:
 
 		ahd_complete_scb(ahd, scb);
--
 	while (!SCBID_IS_NULL(scbid)) {
 
 		ahd_set_scbptr(ahd, scbid);
@@ -1367,10 +1394,21 @@ rescan_fifos:
 
 		ahd_complete_scb(ahd, scb);
--
 	while (!SCBID_IS_NULL(scbid)) {
 
 		ahd_set_scbptr(ahd, scbid);
@@ -1384,6 +1422,12 @@ rescan_fifos:
 
 		ahd_complete_scb(ahd, scb);
--
 	while ((sg_list_size + sg_list_increment) <= max_list_size
 	   &&  (sg_list_size % PAGE_SIZE) != 0) {
 		bus_size_t new_mod;
@@ -6060,6 +6109,12 @@ ahd_sglist_allocsize(struct ahd_softc *a
 		if (new_mod > best_mod || new_mod == 0) {
 			best_list_size = sg_list_size;
--
-		while ((sns_map = SLIST_FIRST(&scb_data->sense_maps)) != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((sns_map = SLIST_FIRST(&scb_data->sense_maps)) != NULL) {
 			SLIST_REMOVE_HEAD(&scb_data->sense_maps, links);
 			ahd_dmamap_unload(ahd, scb_data->sense_dmat,
 					  sns_map->dmamap);
 			ahd_dmamem_free(ahd, scb_data->sense_dmat,
 					sns_map->vaddr, sns_map->dmamap);
--
-		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps)) != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((sg_map = SLIST_FIRST(&scb_data->sg_maps)) != NULL) {
 			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
 			ahd_dmamap_unload(ahd, scb_data->sg_dmat,
 					  sg_map->dmamap);
 			ahd_dmamem_free(ahd, scb_data->sg_dmat,
 					sg_map->vaddr, sg_map->dmamap);
--
-		while ((hscb_map = SLIST_FIRST(&scb_data->hscb_maps)) != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((hscb_map = SLIST_FIRST(&scb_data->hscb_maps)) != NULL) {
 			SLIST_REMOVE_HEAD(&scb_data->hscb_maps, links);
 			ahd_dmamap_unload(ahd, scb_data->hscb_dmat,
 					  hscb_map->dmamap);
 			ahd_dmamem_free(ahd, scb_data->hscb_dmat,
 					hscb_map->vaddr, hscb_map->dmamap);
--
-	while (qinpos != qintail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (qinpos != qintail) {
 		scb = ahd_lookup_scb(ahd, ahd->qinfifo[qinpos]);
 		if (scb == NULL) {
 			printk("qinpos = %d, SCB index = %d\n",
@@ -8283,6 +8376,12 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 			prev_scb = scb;
--
 	while (scbp_next != NULL) {
 		scbp = scbp_next;
 		scbp_next = LIST_NEXT(scbp, pending_links);
@@ -8668,6 +8772,12 @@ ahd_abort_scbs(struct ahd_softc *ahd, in
 			ahd_done(ahd, scbp);
 			found++;
--
 		while ((ahd_le32toh(sg->len) & AHD_DMA_LAST_SEG) == 0) {
 			sg++;
 			resid += ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (lstate->event_r_idx != lstate->event_w_idx
 	    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {
 		struct ahd_tmode_event *event;
@@ -9319,6 +9445,12 @@ ahd_send_lstate_events(struct ahd_softc
 		lstate->event_r_idx++;
 		if (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)
--
 	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
 
 		if (cur_patch->patch_func(ahd) == 0) {
@@ -9534,6 +9671,12 @@ ahd_check_patch(struct ahd_softc *ahd, c
 			 */
 			cur_patch++;
--
 	while (1) {
 		int i;
 
@@ -9672,6 +9820,12 @@ ahd_probe_stack_size(struct ahd_softc *a
 				goto sized;
 		}
--
 	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
 		ahd_set_scbptr(ahd, scb_index);
 		printk("%d ", scb_index);
 		scb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
 		ahd_set_scbptr(ahd, scb_index);
 		printk("%d ", scb_index);
 		scb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
 		ahd_set_scbptr(ahd, scb_index);
 		printk("%d ", scb_index);
 		scb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
 		ahd_set_scbptr(ahd, scb_index);
 		printk("%d ", scb_index);
 		scb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (usec > 0) {
 		udelay(usec % 1024);
 		usec -= 1024;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!done) {
 		switch (*opt_arg) {
 		case '{':
@@ -1129,6 +1145,12 @@ ahd_parse_brace_option(char *opt_name, c
 			opt_arg = tok_end;
 			break;
--
 	while ((p = strsep(&s, ",.")) != NULL) {
 		if (*p == '\0')
 			continue;
@@ -1211,6 +1238,12 @@ aic79xx_setup(char *s)
 		} else {
 			*(options[i].flag) ^= 0xFFFFFFFF;
--
 	while (usec > 0) {
 		udelay(usec % 1024);
 		usec -= 1024;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!done) {
 		switch (*opt_arg) {
 		case '{':
@@ -1018,6 +1034,12 @@ ahc_parse_brace_option(char *opt_name, c
 			opt_arg = tok_end;
 			break;
--
 	while ((p = strsep(&s, ",.")) != NULL) {
 		if (*p == '\0')
 			continue;
@@ -1085,6 +1112,12 @@ aic7xxx_setup(char *s)
 		} else {
 			*(options[i].flag) ^= 0xFFFFFFFF;
--
 	while (!list_empty(&adapter_list)) {
 		hba = list_entry(adapter_list.next, struct bnx2i_hba, link);
 		list_del(&hba->link);
@@ -548,6 +553,12 @@ static void __exit bnx2i_mod_exit(void)
 		}
 
--
 		while (buf_off >= (cur_offset + bd_tbl->buffer_length)) {
 			cur_offset += bd_tbl->buffer_length;
 			cur_bd_idx++;
 			bd_tbl++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (lpcnt--) {
 		memcpy(&dword, (const void *) srcp, 4);
 		*dstp = cpu_to_be32(dword);
 		srcp += 4;
 		dstp++;
+		if (_cur < timeout) {
--
 	while (val) {
 		val = val >> 1;
 		power++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (num_pages--) {
 		if (cnic_dev_10g) {
 			/* PTE is written in little endian format for 57710 */
@@ -983,6 +999,12 @@ static void setup_qp_page_tables(struct
 			ptbl++;
 			page += PAGE_SIZE;
--
 	while (num_pages--) {
 		if (cnic_dev_10g) {
 			/* PTE is written in little endian format for 57710 */
@@ -1011,6 +1038,12 @@ static void setup_qp_page_tables(struct
 			ptbl++;
 			page += PAGE_SIZE;
--
 	while (num_pages--) {
 		if (cnic_dev_10g) {
 			/* PTE is written in little endian format for 57710 */
@@ -1039,6 +1077,12 @@ static void setup_qp_page_tables(struct
 			ptbl++;
 			page += PAGE_SIZE;
--
 	while (!kthread_should_stop()) {
 		spin_lock_bh(&p->p_work_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (!list_empty(&p->work_list)) {
 			list_splice_init(&p->work_list, &work_list);
 			spin_unlock_bh(&p->p_work_lock);
@@ -1873,10 +1927,22 @@ int bnx2i_percpu_io_thread(void *arg)
 				kfree(work);
 			}
--
 	while (i < num_cqe) {
 		ikcqe = (struct iscsi_kcqe *) kcqe[i++];
 
@@ -2517,6 +2588,12 @@ static void bnx2i_indicate_kcqe(void *co
 		else
 			printk(KERN_ALERT "bnx2i: unknown opcode 0x%x\n",
--
 	while (!list_empty(done_q)) {
 		sp = list_entry(done_q->next, struct srb, list);
 
@@ -1319,6 +1324,12 @@ qla1280_done(struct scsi_qla_host *ha)
 			(*(cmd)->scsi_done)(cmd);
 		else
--
 	while (risc_code_size > 0) {
 		int warn __attribute__((unused)) = 0;
 
@@ -1846,6 +1862,12 @@ qla1280_load_firmware_dma(struct scsi_ql
 		risc_code_size = risc_code_size - cnt;
 		fw_data = fw_data + cnt;
--
-		while (remseg > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (remseg > 0) {
 			/* Update sg start */
 			sg = s;
 			/* Adjust ring index. */
@@ -3006,6 +3033,12 @@ qla1280_64bit_start_scsi(struct scsi_qla
 				SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
--
-		while (remseg > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (remseg > 0) {
 			/* Continue from end point */
 			sg = s;
 			/* Adjust ring index. */
@@ -3253,6 +3291,12 @@ qla1280_32bit_start_scsi(struct scsi_qla
 				SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
--
-	while (ha->rsp_ring_index != mailbox[5]) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ha->rsp_ring_index != mailbox[5]) {
 		pkt = ha->response_ring_ptr;
 
 		dprintk(5, "qla1280_isr: ha->rsp_ring_index = 0x%x, mailbox[5]"
@@ -3626,6 +3675,12 @@ qla1280_isr(struct scsi_qla_host *ha, st
 				ha->response_ring_ptr++;
--
 		while (ha->flags.reset_marker) {
 			/* Issue marker command. */
 			ha->flags.reset_marker = 0;
@@ -3660,6 +3720,12 @@ qla1280_rst_aen(struct scsi_qla_host *ha
 						       MK_SYNC_ALL);
 				}
--
 	while (cp && (ptr = strchr(cp, ':'))) {
 		ptr++;
 		if (!strcmp(ptr, "yes")) {
@@ -4184,6 +4255,12 @@ qla1280_setup(char *s)
 		else {
 			break;
--
 		while (offset < len) {
 			u8 page_code = buffer[offset] & 0x3F;
 			u8 spf       = buffer[offset] & 0x40;
@@ -2134,6 +2139,12 @@ sd_read_cache_type(struct scsi_disk *sdk
 					goto defaults;
 				}
--
 		while (entry != &dev->fib_list) {
 			context = list_entry(entry, struct aac_fib_context, next);
 			if (context->unique == fibctx->unique) {
@@ -216,6 +221,12 @@ static int open_getadapter_fib(struct aa
 			} else {
 				entry = entry->next;
--
 	while (!list_empty(&fibctx->fib_list)) {
 		struct list_head * entry;
 		/*
@@ -358,6 +374,12 @@ int aac_close_fib_context(struct aac_dev
 		 */
 		kfree(fib->hw_fib_va);
--
 	while (!((status = src_readl(dev, MUnit.OMR)) &
 		KERNEL_UP_AND_RUNNING)) {
 		if ((restart &&
@@ -535,6 +540,12 @@ int aac_src_init(struct aac_dev *dev)
 			++restart;
 		}
--
 	while (!((status = rx_readl(dev, MUnit.OMRx[0])) & KERNEL_UP_AND_RUNNING))
 	{
 		if ((restart &&
@@ -618,6 +623,12 @@ int _aac_rx_init(struct aac_dev *dev)
 			++restart;
 		}
--
 	while(aac_consumer_get(dev, q, &entry))
 	{
 		int fast;
@@ -147,6 +152,12 @@ unsigned int aac_response_normal(struct
 		}
 		consumed++;
--
 	while(aac_consumer_get(dev, q, &entry))
 	{
 		struct fib fibctx;
@@ -224,6 +240,12 @@ unsigned int aac_command_normal(struct a
 			aac_fib_adapter_complete(fib, sizeof(u32));
 			spin_lock_irqsave(q->lock, flags);
--
-	while (!(sa_readl(dev, Mailbox7) & KERNEL_UP_AND_RUNNING)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(sa_readl(dev, Mailbox7) & KERNEL_UP_AND_RUNNING)) {
 		if (time_after(jiffies, start+startup_timeout*HZ)) {
 			status = sa_readl(dev, Mailbox7);
 			printk(KERN_WARNING "%s%d: adapter kernel failed to start, init status = %lx.\n", 
@@ -359,6 +364,12 @@ int aac_sa_init(struct aac_dev *dev)
 			goto error_iounmap;
--
     while (inb(eisa_adr+EDOORREG) != 0xff) {
         if (--retries == 0) {
             printk("GDT-EISA: Initialization error (DEINIT failed)\n");
@@ -683,6 +688,12 @@ static int __init gdth_init_eisa(u16 eis
         }
         gdth_delay(1);
--
         while (inb(eisa_adr+EDOORREG) != 0xfe) {
             if (--retries == 0) {
                 printk("GDT-EISA: Initialization error (get IRQ failed)\n");
                 return 0;
             }
             gdth_delay(1);
--
     while (readb(&dp2_ptr->u.ic.S_Status) != 0xff) {
         if (--retries == 0) {
             printk("GDT-ISA: Initialization error (DEINIT failed)\n");
@@ -814,6 +841,12 @@ static int __init gdth_init_isa(u32 bios
             return 0;
         }
--
     while (readb(&dp2_ptr->u.ic.S_Status) != 0xfe) {
         if (--retries == 0) {
             printk("GDT-ISA: Initialization error\n");
@@ -846,6 +884,12 @@ static int __init gdth_init_isa(u32 bios
             return 0;
         }
--
         while (readb(&dp6_ptr->u.ic.S_Status) != 0xff) {
             if (--retries == 0) {
                 printk("GDT-PCI: Initialization error (DEINIT failed)\n");
@@ -949,6 +998,12 @@ static int __devinit gdth_init_pci(struc
                 return 0;
             }
--
         while (readb(&dp6_ptr->u.ic.S_Status) != 0xfe) {
             if (--retries == 0) {
                 printk("GDT-PCI: Initialization error\n");
@@ -978,6 +1038,12 @@ static int __devinit gdth_init_pci(struc
                 return 0;
             }
--
         while (readb(&dp6c_ptr->u.ic.S_Status) != 0xff) {
             if (--retries == 0) {
                 printk("GDT-PCI: Initialization error (DEINIT failed)\n");
@@ -1061,6 +1132,12 @@ static int __devinit gdth_init_pci(struc
                 return 0;
             }
--
         while (readb(&dp6c_ptr->u.ic.S_Status) != 0xfe) {
             if (--retries == 0) {
                 printk("GDT-PCI: Initialization error\n");
@@ -1091,6 +1173,12 @@ static int __devinit gdth_init_pci(struc
                 return 0;
             }
--
         while (readb(&dp6m_ptr->u.ic.S_Status) != 0xff) {
             if (--retries == 0) {
                 printk("GDT-PCI: Initialization error (DEINIT failed)\n");
@@ -1182,6 +1275,12 @@ static int __devinit gdth_init_pci(struc
                 return 0;
             }
--
         while (readb(&dp6m_ptr->u.ic.S_Status) != 0xfe) {
             if (--retries == 0) {
                 printk("GDT-PCI: Initialization error\n");
@@ -1210,6 +1314,12 @@ static int __devinit gdth_init_pci(struc
                 return 0;
             }
--
         while (readb(&dp6m_ptr->u.ic.S_Status) != 0xfd) {
             if (--retries == 0) {
                 printk("GDT-PCI: Initialization error (DEINIT failed)\n");
@@ -1225,6 +1340,12 @@ static int __devinit gdth_init_pci(struc
                 return 0;
             }
--
         while (nscp && gdth_cmnd_priv(nscp)->priority <= priority) {
             pscp = nscp;
             nscp = (Scsi_Cmnd *)pscp->SCp.ptr;
+            if (_cur < timeout) {
+                rdstcll(_cur);
+            }
--
     while (cur && isdigit(*cur) && i < MAXHA) {
         ints[i++] = simple_strtoul(cur, NULL, 0);
         if ((cur = strchr(cur, ',')) != NULL) cur++;
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
--
 	while ((pDev = pci_get_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
 		if(pDev->device == PCI_DPT_DEVICE_ID ||
 		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
@@ -206,6 +211,12 @@ static int adpt_detect(struct scsi_host_
 			}
 			pci_dev_get(pDev);
--
 			while(d){
 				len += sprintf(buffer+len,"\t%-24.24s", d->pScsi_dev->vendor);
 				len += sprintf(buffer+len," Rev: %-8.8s\n", d->pScsi_dev->rev);
@@ -653,6 +669,12 @@ static int adpt_proc_info(struct Scsi_Ho
 				}
 
--
 	while(*status == 0){
 		if(time_after(jiffies,timeout)){
 			printk(KERN_WARNING"%s: IOP Reset Timeout\n",pHba->name);
@@ -1498,6 +1525,12 @@ static s32 adpt_i2o_reset_hba(adpt_hba*
 		}
 		rmb();
--
 		while(sg_index) {
 			if(sg_list[--sg_index]) {
 				dma_free_coherent(&pHba->pDev->dev,
@@ -1978,6 +2016,12 @@ cleanup:
 					sg_list[sg_index],
 					sg[sg_index].addr_bus);
--
 	while( readl(pHba->irq_mask) & I2O_INTERRUPT_PENDING_B) {
 		m = readl(pHba->reply_port);
 		if(m == EMPTY_QUEUE){
@@ -2295,6 +2344,12 @@ static irqreturn_t adpt_isr(int irq, voi
 		writel(m, pHba->reply_port);
 		wmb();
--
 					while (pDev->next_lun) {
 						pDev = pDev->next_lun;
+						if (_cur < timeout) {
+					rdstcll(_cur);
+						}
+						else {
--
-	while(status_block[87]!=0xff){
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(status_block[87]!=0xff){
 		if(time_after(jiffies,timeout)){
 			printk(KERN_ERR"dpti%d: Get status timeout.\n",
 				pHba->unit);
@@ -3061,6 +3132,12 @@ static s32 adpt_i2o_status_get(adpt_hba*
 		}
--
 		while (data & NVR_BUSY) {
 			udelay(100);
 			data = RD_REG_WORD(&reg->nvram);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while ((data & BIT_0) == 0) {
 			/* Lock failed */
 			udelay(100);
@@ -44,6 +60,12 @@ qla2x00_lock_nvram_access(struct qla_hw_
 			RD_REG_WORD(&reg->u.isp2300.host_semaphore);
 			udelay(5);
--
-	while (left != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (left != 0) {
 		if (burst > left)
 			burst = left;
 
@@ -2445,6 +2472,12 @@ try_fast:
 		left -= burst;
--
 		while ((iter < iend) && !do_next) {
 			iter++;
 			if (qla2x00_read_flash_byte(ha, iter) == '/') {
@@ -2502,16 +2540,33 @@ qla2x00_get_fcode_version(struct qla_hw_
 				    iter + 3) == '/')
 					do_next++;
--
 		while ((iter > istart) && !do_next) {
 			iter--;
 			if (qla2x00_read_flash_byte(ha, iter) == ' ')
 				do_next++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while ((iter > istart) && !do_next) {
 			iter--;
 			rbyte = qla2x00_read_flash_byte(ha, iter);
 			if (rbyte == ' ' || rbyte == 0xd || rbyte == 0x10)
 				do_next++;
+				if (_cur < timeout) {
--
 			while (iter <= vend) {
 				*vbyte++ = qla2x00_read_flash_byte(ha, iter);
 				iter++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-	while (done == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (done == 0) {
 		done = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);
 		done &= 4;
 		timeout++;
@@ -883,6 +888,12 @@ qla82xx_wait_rom_busy(struct qla_hw_data
 			    QLA2XXX_DRIVER_NAME);
--
-	while (done == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (done == 0) {
 		done = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);
 		done &= 2;
 		timeout++;
@@ -904,6 +920,12 @@ qla82xx_wait_rom_done(struct qla_hw_data
 			    QLA2XXX_DRIVER_NAME);
--
 	while ((qla82xx_rom_lock(ha) != 0) && (loops < 50000)) {
 		udelay(100);
 		schedule();
 		loops++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((done != 0) && (ret == 0)) {
 		ret = qla82xx_read_status_reg(ha, &val);
 		done = val & 1;
@@ -989,6 +1027,12 @@ qla82xx_flash_wait_write_finish(struct q
 			    "Timeout reached waiting for write finish.\n");
 			return -1;
--
 	while ((qla82xx_rom_lock(ha) != 0) && (loops < 50000)) {
 		udelay(100);
 		cond_resched();
 		loops++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (tot_dsds) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tot_dsds) {
 		avail_dsds = (tot_dsds > QLA_DSDS_PER_IOCB) ?
 		    QLA_DSDS_PER_IOCB : tot_dsds;
 		tot_dsds -= avail_dsds;
@@ -2616,6 +2676,11 @@ qla2xx_build_scsi_type_6_iocbs(srb_t *sp
 			*cur_dsd++ = cpu_to_le32(dsd_list_len);
--
 		while (avail_dsds) {
 			dma_addr_t	sle_dma;
 
@@ -2625,6 +2690,18 @@ qla2xx_build_scsi_type_6_iocbs(srb_t *sp
 			*cur_dsd++ = cpu_to_le32(sg_dma_len(cur_seg));
 			cur_seg = sg_next(cur_seg);
--
-		while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
 			WRT_REG_DWORD(
 				(unsigned long __iomem *)ha->nxdb_wr_ptr,
 				dbval);
 			wmb();
+			if (_cur < timeout) {
--
-		while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
 			WRT_REG_DWORD((unsigned long  __iomem *)ha->nxdb_wr_ptr,
 				dbval);
 			wmb();
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (drv_state != drv_active) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (drv_state != drv_active) {
 
 		if (time_after_eq(jiffies, reset_timeout)) {
 			/* quiescence timeout, other functions didn't ack
@@ -3468,6 +3572,12 @@ qla82xx_need_qsnt_handler(scsi_qla_host_
 		drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
--
 	while (vha->rscn_out_ptr != vha->rscn_in_ptr ||
 	    vha->flags.rscn_queue_overflow) {
 
@@ -3588,6 +3593,12 @@ qla2x00_device_resync(scsi_qla_host_t *v
 				}
 			}
--
 	while (segments && rval == QLA_SUCCESS) {
 		/* Read segment's load information. */
 		qla24xx_read_flash_data(vha, dcode, faddr, 4);
@@ -4704,6 +4720,12 @@ qla24xx_load_risc_flash(scsi_qla_host_t
 
 		/* Next segment. */
--
 	while (*seg && rval == QLA_SUCCESS) {
 		risc_addr = *seg;
 		*srisc_addr = *srisc_addr == 0 ? *seg : *srisc_addr;
@@ -4803,6 +4830,12 @@ qla2x00_load_risc(scsi_qla_host_t *vha,
 
 		/* Next segment. */
--
 	while (segments && rval == QLA_SUCCESS) {
 		risc_addr = be32_to_cpu(fwcode[2]);
 		*srisc_addr = *srisc_addr == 0 ? risc_addr : *srisc_addr;
@@ -4914,6 +4952,12 @@ qla24xx_load_risc_blob(scsi_qla_host_t *
 
 		/* Next segment. */
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		memcpy(sfp, &image->field_info, sizeof(image->field_info));
 		rval = qla2x00_write_sfp(vha, sfp_dma, sfp,
 		    image->field_address.device, image->field_address.offset,
@@ -1482,6 +1487,12 @@ qla2x00_update_fru_versions(struct fc_bs
 			goto dealloc;
--
-			while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
 				WRT_REG_DWORD((unsigned long __iomem *)
 					ha->nxdb_wr_ptr, dbval);
 				wmb();
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (qla24xx_get_one_block_sg(prot_int, &sgx, &partial)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (qla24xx_get_one_block_sg(prot_int, &sgx, &partial)) {
 
 		sle_dma = sgx.dma_addr;
 		sle_dma_len = sgx.dma_len;
@@ -940,6 +956,12 @@ alloc_and_fill:
 			partial = 1; /* So as to not re-enter this block */
--
 	while (CMD_SP(cmd) && wait_iter--) {
 		msleep(ABORT_POLLING_PERIOD);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
 	while (((test_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags)) ||
 	    test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags) ||
 	    test_bit(ISP_ABORT_RETRY, &base_vha->dpc_flags) ||
 	    ha->dpc_active) && time_before(jiffies, wait_online)) {
 
 		msleep(1000);
--
 	while (ha->cur_vport_count) {
 		struct Scsi_Host *scsi_host;
 
@@ -2502,6 +2529,12 @@ qla2x00_remove_one(struct pci_dev *pdev)
 		scsi_host_put(vha->host);
 
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		ql_dbg(ql_dbg_dpc, base_vha, 0x4000,
 		    "DPC handler sleeping.\n");
 
@@ -3623,6 +3661,12 @@ qla2x00_do_dpc(void *data)
 
--
 	} /* End of while(1) */
 	__set_current_state(TASK_RUNNING);
 
diff -u -p a/scsi/qla2xxx/qla_mid.c b/scsi/qla2xxx/qla_mid.c
--- a/scsi/qla2xxx/qla_mid.c
+++ b/scsi/qla2xxx/qla_mid.c
--
 	while (atomic_read(&vha->vref_count)) {
 		spin_unlock_irqrestore(&ha->vport_slock, flags);
 
 		msleep(500);
 
 		spin_lock_irqsave(&ha->vport_slock, flags);
--
 	while (rsp->ring_ptr->signature != RESPONSE_PROCESSED) {
 		pkt = (sts_entry_t *)rsp->ring_ptr;
 
@@ -1384,6 +1389,12 @@ qla2x00_process_response_queue(struct rs
 		}
 		((response_t *)pkt)->signature = RESPONSE_PROCESSED;
--
 	while (rsp->ring_ptr->signature != RESPONSE_PROCESSED) {
 		pkt = (struct sts_entry_24xx *)rsp->ring_ptr;
 
@@ -2075,6 +2091,12 @@ void qla24xx_process_response_queue(stru
 		}
 		((response_t *)pkt)->signature = RESPONSE_PROCESSED;
--
 	while (lba < end) {
 		sector_t block, rem;
 
@@ -2028,6 +2033,12 @@ static void map_region(sector_t lba, uns
 			set_bit(block, map_storep);
 
--
 	while (lba < end) {
 		sector_t block, rem;
 
@@ -2049,6 +2065,12 @@ static void unmap_region(sector_t lba, u
 			clear_bit(block, map_storep);
 
--
-   while (inb(iobase + REG_LCL_INTR) & BSY_ASSERTED) {
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (inb(iobase + REG_LCL_INTR) & BSY_ASSERTED) {
       udelay(1L);
       if (--loop == 0) return TRUE;
+      if (_cur < timeout) {
+            rdstcll(_cur);
+      }
--
    while (cur && (pc = strchr(cur, ':'))) {
       int val = 0, c = *++pc;
 
@@ -1061,6 +1077,12 @@ static void internal_setup(char *str, in
       else if (!strncmp(cur, "et:", 3))  ext_tran = val;
 
--
    while (cur && isdigit(*cur) && i < MAX_INT_PARAM) {
       ints[i++] = simple_strtoul(cur, NULL, 0);
 
       if ((cur = strchr(cur, ',')) != NULL) cur++;
+      if (_cur < timeout) {
+         rdstcll(_cur);
--
 	while ((qp = sym_remque_head(&np->comp_ccbq)) != NULL) {
 		struct scsi_cmnd *cmd;
 		cp = sym_que_entry(qp, struct sym_ccb, link_ccbq);
@@ -1674,6 +1679,12 @@ static void sym_flush_comp_queue(struct
 #endif
 		sym_free_ccb(np, cp);
--
-	while (i != np->squeueput) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (i != np->squeueput) {
 		cp = sym_ccb_from_dsa(np, scr_to_cpu(np->squeue[i]));
 		assert(cp);
 #ifdef SYM_CONF_IARB_SUPPORT
@@ -3010,6 +3026,12 @@ sym_dequeue_from_squeue(struct sym_hcb *
 			if ((j += 2) >= MAX_QUEUE*2) j = 0;
--
 	while ((qp = sym_remque_head(&qtmp)) != NULL) {
 		struct scsi_cmnd *cmd;
 		cp = sym_que_entry(qp, struct sym_ccb, link_ccbq);
@@ -3230,6 +3257,12 @@ int sym_clear_tasks(struct sym_hcb *np,
 #if 0
 printf("XXXX TASK @%p CLEARED\n", cp);
--
 		while ((qp = sym_remque_head(&np->free_ccbq)) != NULL) {
 			cp = sym_que_entry(qp, struct sym_ccb, link_ccbq);
 			sym_mfree_dma(cp, sizeof(*cp), "CCB");
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (size > s) {
 		s <<= 1;
 		++i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (j > i) {
 			j -= 1;
 			s >>= 1;
 			h[j].next = (m_link_p) (a+s);
 			h[j].next->next = NULL;
+			if (_cur < timeout) {
--
 	while (size > s) {
 		s <<= 1;
 		++i;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 		while (q->next && q->next != (m_link_p) b) {
 			q = q->next;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
--
 	while (p && (xi < 8)) {
 		char *next_p;
 		int val = (int) simple_strtoul(p, &next_p, 0);
 		sym_driver_setup.excludes[xi++] = val;
 		p = next_p;
+		if (_cur < timeout) {
--
 		while (len > 0) {
 			SKIP_SPACES(ptr, len);
 			if	((arg_len = is_keyword(ptr, len, "alloc")))
@@ -1136,6 +1152,12 @@ printk("sym_user_command: data=%ld\n", u
 			else
 				return -EINVAL;
--
-		while (len > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (len > 0) {
 			SKIP_SPACES(ptr, len);
 			if	((arg_len = is_keyword(ptr, len, "no_disc")))
 				uc->data &= ~SYM_DISC_ENABLED;
 			else
 				return -EINVAL;
--
 	while ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE)
 	       && (i-- > 0)) {
 		mdelay(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (len < memsize) {
 		AdvWriteWordAutoIncLram(iop_base, 0);
 		len += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((sgblkp = reqp->sgblkp) != NULL) {
 		/* Remove 'sgblkp' from the request list. */
 		reqp->sgblkp = sgblkp->next_sgblkp;
@@ -6787,6 +6814,12 @@ static void adv_isr_callback(ADV_DVC_VAR
 		/* Add 'sgblkp' to the board free list. */
 		sgblkp->next_sgblkp = boardp->adv_sgblkp;
--
-	while (((irq_next_vpa =
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (((irq_next_vpa =
 		 le32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ASC_RQ_DONE) != 0) {
 		/*
 		 * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.
@@ -6926,6 +6964,12 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		 * Fall through and continue processing other completed
--
 			while ((AscGetChipStatus(iop_base) &
 				CSW_SCSI_RESET_ACTIVE) && (i-- > 0)) {
 				mdelay(100);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 				while (((status =
 					 AscIsrQDone(asc_dvc)) & 0x01) != 0) {
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
--
 			while ((sgblkp = reqp->sgblkp) != NULL) {
 				/* Remove 'sgblkp' from the request list. */
 				reqp->sgblkp = sgblkp->next_sgblkp;
@@ -8530,6 +8601,12 @@ adv_get_sglist(struct asc_board *boardp,
 				/* Add 'sgblkp' to the board free list. */
 				sgblkp->next_sgblkp = boardp->adv_sgblkp;
--
 	while (TRUE) {
 		AscSetChipEEPData(iop_base, data_reg);
 		mdelay(1);
@@ -9912,6 +9994,12 @@ static int __devinit AscWriteEEPDataReg(
 		if (retry++ > ASC_EEP_MAX_RETRY) {
 			return (0);
--
 	while (board->adv_sgblkp) {
 		adv_sgblk_t *sgp = board->adv_sgblkp;
 		board->adv_sgblkp = sgp->next_sgblkp;
 		kfree(sgp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (sector_addr < flash_addr+size) {
 		switch (asd_ha->hw_prof.flash.method) {
 		case FLASH_METHOD_A:
@@ -1306,6 +1311,12 @@ int asd_erase_nv_sector(struct asd_ha_st
 			return FAIL_ERASE_FLASH;
 
--
 	while ((l1 || l2) && cnt) {
 
 		if (l1) {
@@ -899,6 +904,12 @@ static enum BC_STATUS crystalhd_stop_tx_
 		msleep_interruptible(100);
 
--
 	while ((l0y || l0uv || l1y || l1uv) && count) {
 
 		if (l0y) {
@@ -1160,6 +1176,12 @@ static void crystalhd_stop_rx_dma_engine
 		}
 		msleep_interruptible(100);
--
 	while (reg_data != BC_BIT(4)) {
 		reg_data = crystalhd_reg_rd(adp, DCI_STATUS);
 		reg_data &= BC_BIT(4);
@@ -1657,6 +1684,12 @@ enum BC_STATUS crystalhd_download_fw(str
 			BCMLOG_ERR("Firmware Download RDY Timeout.\n");
 			return BC_STS_TIMEOUT;
--
 	while ((ioq->count == 0) && count) {
 		spin_unlock_irqrestore(&ioq->lock, flags);
 
@@ -650,6 +655,12 @@ void *crystalhd_dioq_fetch_wait(struct c
 		}
 		spin_lock_irqsave(&ioq->lock, flags);
--
 	while (i > 0) {
 		i--;
 		device_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (i > MASTER_MINOR) {
 		i--;
 		vme_master_free(image[i].resource);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (i > SLAVE_MINOR) {
 		i--;
 		buf_unalloc(i);
 		vme_slave_free(image[i].resource);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (reg_queue) {
 		if (reg_queue == reg->reg_last)
 			reg->reg_last = NULL;
@@ -521,6 +526,12 @@ void Wb35Reg_destroy(struct hw_data *pHw
 		spin_lock_irq(&reg->EP0VM_spin_lock);
 
--
 	while (SizeLeft) {
 		pT00 = (struct T00_descriptor *)buffer;
 		CopySize = SizeLeft;
@@ -235,6 +240,11 @@ static u16 Mds_BodyCopy(struct wbsoft_pr
 		stmp &= ~0x03; /* 4n Alignment */
 		Size += stmp; /* Current 4n offset of mpdu */
--
 		while (CopySize) {
 			/* Copy body */
 			src_buffer = pDes->buffer_address[buf_index];
@@ -255,6 +265,12 @@ static u16 Mds_BodyCopy(struct wbsoft_pr
 			memcpy(buffer, src_buffer, CopyLeft);
 			buffer += CopyLeft;
--
-	while ((copy_out_done == false) && (copy_in_done == false)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((copy_out_done == false) && (copy_in_done == false)) {
 		in_copied = 0;
 		new_entry_flag = false;
 		retval = sst_prepare_input_buffers(str_info,\
@@ -1199,7 +1204,12 @@ int sst_decode(int str_id, struct snd_ss
 							bytes_left);
--
-					while (bytes_left) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+						unsigned long long timeout;
+						timeout = rdstcll(start) + delta;
+						while (bytes_left) {
 						struct snd_sst_buffs *ibufs;
 						struct snd_sst_buff_entry
 								*buff_entry;
@@ -1227,6 +1237,12 @@ int sst_decode(int str_id, struct snd_ss
 							input_index_valid_size =
--
 	while (retry) {
 		if (!sst_drv_ctx->lpe_stalled)
 			return 0;
@@ -104,6 +109,12 @@ int sst_stalled(void)
 		msleep(1);
 
--
 	while (size) {
 		cmd = data;
 		cmd_cmd = __be16_to_cpu(cmd->cmd);
@@ -312,6 +317,12 @@ static int pohmelfs_trans_iter(struct ne
 		err = iterator(e, &sg_dst, &sg_src);
 		if (err)
--
 	while (!list_empty(head)) {
 		struct pohmelfs_crypto_thread *t = NULL;
 
@@ -580,15 +596,32 @@ static void pohmelfs_crypto_flush(struct
 
 		if (t)
--
 	while (!list_empty(&psb->crypto_active_list) || !list_empty(&psb->crypto_ready_list)) {
 		dprintk("%s: crypto_thread_num: %u.\n", __func__, psb->crypto_thread_num);
 		pohmelfs_crypto_flush(psb, &psb->crypto_active_list);
 		pohmelfs_crypto_flush(psb, &psb->crypto_ready_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!t) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!t) {
 		err = wait_event_interruptible_timeout(psb->wait,
 				!list_empty(&psb->crypto_ready_list),
 				psb->wait_on_page_timeout);
@@ -805,6 +843,12 @@ static int pohmelfs_crypto_thread_get(st
 
--
 	while (n) {
 		tmp = rb_entry(n, struct pohmelfs_mcache, mcache_entry);
 
@@ -51,6 +56,12 @@ struct pohmelfs_mcache *pohmelfs_mcache_
 			pohmelfs_mcache_get(ret);
 			break;
--
 	while (*n) {
 		parent = *n;
 
@@ -77,6 +93,12 @@ static int pohmelfs_mcache_insert(struct
 			ret = tmp;
 			break;
--
 	while (size && !err) {
 		revents = netfs_state_poll(st);
 
@@ -148,6 +153,12 @@ static int pohmelfs_data_recv(struct net
 					"should_stop: %d, size: %u, err: %d.\n",
 				__func__, st->socket, st->read_socket,
--
 	while (!kthread_should_stop()) {
 		/*
 		 * If socket will be reset after this statement, then
@@ -969,6 +985,12 @@ static int pohmelfs_recv(void *data)
 				netfs_state_reset(st);
 				break;
--
 	while (!kthread_should_stop())
diff -u -p a/staging/pohmelfs/dir.c b/staging/pohmelfs/dir.c
--- a/staging/pohmelfs/dir.c
+++ b/staging/pohmelfs/dir.c
@@ -38,6 +38,11 @@ static struct pohmelfs_name *pohmelfs_se
 	struct pohmelfs_name *tmp = NULL;
--
 	while (n) {
 		tmp = rb_entry(n, struct pohmelfs_name, hash_node);
 
@@ -49,6 +54,12 @@ static struct pohmelfs_name *pohmelfs_se
 		else
 			break;
--
 	while (*n) {
 		parent = *n;
 
@@ -101,6 +117,12 @@ static struct pohmelfs_name *pohmelfs_in
 			ret = tmp;
 			break;
--
 	while (n) {
 		tmp = rb_entry(n, struct netfs_trans_dst, state_entry);
 		t = tmp->trans;
@@ -220,6 +225,12 @@ struct netfs_trans_dst *netfs_trans_sear
 			ret = tmp;
 			break;
--
 	while (*n) {
 		parent = *n;
 
@@ -248,6 +264,12 @@ static int netfs_trans_insert(struct net
 			ret = tmp;
 			break;
--
 	while (d && d != root && !IS_ROOT(d)) {
 		len += d->d_name.len + 1; /* Plus slash */
 		d = d->d_parent;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (count-- > 0) {
 		size_t x = odev->buf_offs % odev->width;
 		size_t y = odev->buf_offs / odev->width;
@@ -414,6 +419,12 @@ static int append_values(struct asus_ole
 		}
 
--
 	while (offs < count && odev->buf_offs < max_offs) {
 		int ret = 0;
 
@@ -588,6 +604,12 @@ static ssize_t odev_set_picture(struct a
 		}
 
--
 		} while (imem_sz > 0);
 		i = 10;
 		tmp16 = r8712_read16(padapter, TCR);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (((tmp16 & _IMEM_CODE_DONE) == 0) && (i > 0)) {
 			udelay(10);
 			tmp16 = r8712_read16(padapter, TCR);
 			i--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		} while (emem_sz > 0);
 		i = 5;
 		tmp16 = r8712_read16(padapter, TCR);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (((tmp16 & _EMEM_CODE_DONE) == 0) && (i > 0)) {
 			udelay(10);
 			tmp16 = r8712_read16(padapter, TCR);
 			i--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (((tmp16 & _IMEM_RDY) == 0) && (i > 0)) {
 			msleep(20);
 			tmp16 = r8712_read16(padapter, TCR);
 			i--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (((tmp16 & _DMEM_CODE_DONE) == 0) && (i > 0)) {
 			msleep(20);
 			tmp16 = r8712_read16(padapter, TCR);
 			i--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (((tmp16 & _FWRDY) == 0) && (i > 0)) {
 			msleep(100);
 			tmp16 = r8712_read16(padapter, TCR);
 			i--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while ((end_of_queue_search(sta_phead, sta_plist)) == false) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((end_of_queue_search(sta_phead, sta_plist)) == false) {
 			ptxservq = LIST_CONTAINOR(sta_plist, struct tx_servq,
 				  tx_pending);
 			pframe_queue = &ptxservq->sta_pending;
@@ -229,6 +234,12 @@ static struct xmit_frame *dequeue_xframe
 				/*must be done after get_next and before break*/
--
 	while (end_of_queue_search(phead, plist) == false) {
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		plist = get_next(plist);
 		_free_network(pmlmepriv, pnetwork);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		if (end_of_queue_search(phead, pmlmepriv->pscanned) == true) {
 			if ((pmlmepriv->assoc_by_rssi == true) &&
@@ -1206,6 +1222,12 @@ int r8712_select_and_join_from_scan(stru
 				goto ask_for_joinbss;
 			}
--
 	while (bContinual && efuse_one_byte_read(padapter, efuse_addr,
 	       &efuse_data) && (efuse_addr < efuse_available_max_size)) {
 		if (efuse_data != 0xFF) {
@@ -232,6 +237,12 @@ u16 r8712_efuse_get_current_size(struct
 			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
 		} else
--
 	while (end_of_queue_search(phead, plist) == false) {
 		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		plist = get_next(plist);
 		r8712_free_recvframe(precvframe, pfree_recv_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (nbytes > 0) {
 		secmicappendbyte(pmicdata, *src++);
 		nbytes--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (pnetwork->network.SupportedRates[i] != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (pnetwork->network.SupportedRates[i] != 0) {
 		/* Bit rate given in 500 kb/s units */
 		iwe.u.bitrate.value = (pnetwork->network.SupportedRates[i++] &
 				      0x7F) * 500000;
 		current_val = iwe_stream_add_value(info, start, current_val,
 			      stop, &iwe, IW_EV_PARAM_LEN);
--
 			while (cnt < ielen) {
 				eid = buf[cnt];
 
@@ -629,6 +645,12 @@ static int r871x_set_wpa_ie(struct _adap
 					break;
 				} else
--
 		while ((pcur_bss->SupportedRates[i] != 0) &&
 			(pcur_bss->SupportedRates[i] != 0xFF)) {
 			rate = pcur_bss->SupportedRates[i] & 0x7F;
@@ -1473,6 +1500,12 @@ static int r8711_wx_get_rate(struct net_
 			wrqu->bitrate.fixed = 0;	/* no auto select */
 			wrqu->bitrate.value = rate*500000;
--
 	while (end_of_queue_search(phead, plist) == false) {
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 		plist = get_next(plist);
 		r8712_free_xmitframe(pxmitpriv, pxmitframe);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((r8712_read32(padapter, IOCMD_CTRL_REG)) &&
 		       (pollingcnts > 0)) {
 			pollingcnts--;
 			msleep(20);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((0 != r8712_read32(pAdapter, IOCMD_CTRL_REG)) &&
 	       (pollingcnts > 0)) {
 		pollingcnts--;
 		msleep(20);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((end_of_queue_search(phead, plist)) == false) {
 		psta = LIST_CONTAINOR(plist, struct sta_info, list);
 		plist = get_next(plist);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while ((end_of_queue_search(phead, plist)) == false) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((end_of_queue_search(phead, plist)) == false) {
 			psta = LIST_CONTAINOR(plist,
 					      struct sta_info, hash_list);
 			plist = get_next(plist);
 			if (pbcmc_stainfo != psta)
 				r8712_free_stainfo(padapter , psta);
--
 	while (end_of_queue_search(phead, plist) == false) {
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pnfhdr = &pnextrframe->u.hdr;
@@ -254,6 +259,12 @@ static union recv_frame *recvframe_defra
 		recvframe_put(prframe, pnfhdr->len);
 		pfhdr->attrib.icv_len = pnfhdr->attrib.icv_len;
--
 	while (end_of_queue_search(phead, plist) == false) {
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pnextattrib = &pnextrframe->u.hdr.attrib;
@@ -517,6 +533,12 @@ static int enqueue_reorder_recvframe(str
 			return false;
 		else
--
 	while (!is_list_empty(phead)) {
 		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pattrib = &prframe->u.hdr.attrib;
@@ -579,6 +606,12 @@ int r8712_recv_indicatepkts_in_order(str
 			bPktInBuf = true;
 			break;
--
 	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue))) {
 		recvbuf2recvframe(padapter, pskb);
 		skb_reset_tail_pointer(pskb);
 		pskb->len = 0;
 		skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+		if (_cur < timeout) {
--
 	while (rate[i] != 0) {
 		if ((((rate[i]) & 0x7f) == 2) || (((rate[i]) & 0x7f) == 4) ||
 		    (((rate[i]) & 0x7f) == 11) || (((rate[i]) & 0x7f) == 22))
 			return true;
 			i++;
+			if (_cur < timeout) {
--
 	while (rate[i] != 0) {
 		if ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
 		    (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
 			return false;
 		i++;
+		if (_cur < timeout) {
--
 	while (cnt < in_len) {
 		authmode = in_ie[cnt];
 		if ((authmode == _WPA_IE_ID_) &&
@@ -393,6 +420,12 @@ int r8712_get_sec_ie(u8 *in_ie, uint in_
 			} else
 				cnt += in_ie[cnt+1] + 2;   /*get next*/
--
 	while (cnt < in_len) {
 		eid = in_ie[cnt];
 		if ((eid == _WPA_IE_ID_) &&
@@ -416,6 +454,12 @@ int r8712_get_wps_ie(u8 *in_ie, uint in_
 			break;
 		} else
--
 	while ((val = dc_read(sc->addr, SBE_2T3E3_21143_REG_STATUS)) &
 	       (SBE_2T3E3_21143_VAL_RECEIVE_PROCESS_STOPPED |
 		SBE_2T3E3_21143_VAL_RECEIVE_BUFFER_UNAVAILABLE |
@@ -107,6 +112,12 @@ void dc_intr(struct channel *sc)
 					"Transmit process stopped\n");
 			dc_intr_tx(sc);
--
-		while (!(sc->ether.rx_ring[current_read].rdes0 &
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!(sc->ether.rx_ring[current_read].rdes0 &
 			 SBE_2T3E3_RX_DESC_21143_OWN)) {
 			current_desc = &sc->ether.rx_ring[current_read];
 			current_desc->rdes1 &= SBE_2T3E3_RX_DESC_END_OF_RING |
@@ -137,12 +153,23 @@ void dc_intr_rx(struct channel *sc)
 			current_desc->rdes1 |= SBE_2T3E3_MTU;
--
-	while (!(sc->ether.rx_ring[current_read].rdes0 &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(sc->ether.rx_ring[current_read].rdes0 &
 		 SBE_2T3E3_RX_DESC_21143_OWN)) {
 		current_desc = &sc->ether.rx_ring[current_read];
 
@@ -281,6 +308,12 @@ void dc_intr_rx(struct channel *sc)
 		}
--
 		while (port < num_ports) {
 			union cvmx_srxx_spi4_calx srxx_spi4_calx;
 			srxx_spi4_calx.u64 = 0;
@@ -338,6 +343,12 @@ int cvmx_spi_calendar_setup_cb(int inter
 			cvmx_write_csr(CVMX_SRXX_SPI4_CALX(index, interface),
 				       srxx_spi4_calx.u64);
--
 		while (port < num_ports) {
 			union cvmx_stxx_spi4_calx stxx_spi4_calx;
 			stxx_spi4_calx.u64 = 0;
@@ -401,6 +417,12 @@ int cvmx_spi_calendar_setup_cb(int inter
 			cvmx_write_csr(CVMX_STXX_SPI4_CALX(index, interface),
 				       stxx_spi4_calx.u64);
--
 			while (skb_to_free > 0) {
 				struct sk_buff *t = __skb_dequeue(&priv->tx_free_list[qos]);
 				t->next = to_free_list;
 				to_free_list = t;
 				skb_to_free--;
+				if (_cur < timeout) {
--
 			while (to_free_list) {
 				struct sk_buff *t = to_free_list;
 				to_free_list = to_free_list->next;
 				dev_kfree_skb_any(t);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (skb_to_free > 0) {
 		struct sk_buff *t = __skb_dequeue(&priv->tx_free_list[qos]);
 		t->next = to_free_list;
 		to_free_list = t;
 		skb_to_free--;
+		if (_cur < timeout) {
--
 	while (to_free_list) {
 		struct sk_buff *t = to_free_list;
 		to_free_list = to_free_list->next;
 		dev_kfree_skb_any(t);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (segments--) {
 		union cvmx_buf_ptr next_ptr = *(union cvmx_buf_ptr *)
 			cvmx_phys_to_ptr(segment_ptr.s.addr - 8);
@@ -216,6 +221,12 @@ int cvm_oct_free_work(void *work_queue_e
 				      DONT_WRITEBACK(CVMX_FPA_PACKET_POOL_SIZE /
 						     128));
--
 	while (num_blocks--) {
 		cvmx_fpa_free(ptr, pool, 0);
 		ptr += block_size;
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
--
-	while (remaining_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (remaining_bytes) {
 		start_of_buffer =
 		    ((buffer_ptr.s.addr >> 7) - buffer_ptr.s.back) << 7;
 		cvmx_dprintf("    Buffer Start:%llx\n",
@@ -145,7 +150,12 @@ int cvmx_helper_dump_packet(cvmx_wqe_t *
 		data_address = (uint8_t *) cvmx_phys_to_ptr(buffer_ptr.s.addr);
--
-		while (data_address < end_of_data) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (data_address < end_of_data) {
 			if (remaining_bytes == 0)
 				break;
 			else
@@ -157,12 +167,24 @@ int cvmx_helper_dump_packet(cvmx_wqe_t *
 				count = 0;
--
 	while (num_ports--) {
 		__cvmx_helper_port_setup_ipd(ipd_port);
 		ipd_port++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (num_ports--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_ports--) {
 		/*
 		 * Give the user a chance to override the per queue
 		 * priorities.
@@ -403,6 +419,12 @@ static int __cvmx_helper_interface_setup
 				     cvmx_pko_get_num_queues(ipd_port),
--
-				while (segments--) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (segments--) {
 					union cvmx_buf_ptr next_ptr =
 					    *(union cvmx_buf_ptr *)cvmx_phys_to_ptr(segment_ptr.s.addr - 8);
 
@@ -393,6 +398,12 @@ static int cvm_oct_napi_poll(struct napi
 					       segment_size);
--
-				while (true) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (true) {
 					u8 tmp24F = read_nic_byte(dev, 0x24f);
 
 					if ((tmp24F == 0x01) ||
@@ -954,6 +959,12 @@ bool SetZebraRFPowerState8185(struct net
 						} else
--
 	while (true)	{
 		spin_lock_irqsave(&priv->rf_ps_lock, flag);
 		if (priv->RFChangeInProgress)	{
 			spin_unlock_irqrestore(&priv->rf_ps_lock, flag);
 			/*  Set RF after the previous action is done.	*/
+			unsigned long long delta = (cpu / khz / HZ) * 2;
--
 			while (priv->RFChangeInProgress)	{
 				RFWaitCounter++;
 				udelay(1000); /* 1 ms	*/
@@ -1429,12 +1439,24 @@ MgntActSet_RF_State(
 					/* TODO: Reset RF state?	*/
 					return false;
--
 	/* while there are filled descriptors */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(*(priv->rxringtail) & (1<<31))) {
 		if (*(priv->rxringtail) & (1<<26))
 			DMESGW("RX buffer overflow");
@@ -1730,6 +1735,12 @@ drop: /* this is used when we have not e
 			priv->rxringtail = priv->rxring;
 
--
 	while (remain != 0) {
 		mb();
 		if (!buflist) {
@@ -2192,6 +2208,12 @@ short rtl8180_tx(struct net_device *dev,
 			 */
 			break;
--
 	while(1)
 	{
 
@@ -492,6 +497,12 @@ void ieee80211_softmac_scan_syncro(struc
 
 		msleep_interruptible_rtl(IEEE80211_SOFTMAC_SCAN_TIME);
--
-     	while(1)
+     	unsigned long long delta = (cpu / khz / HZ) * 2;
+     	unsigned long long _start = 0;
+     	unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while(1)
         {
                 /* this function can be called in two situations
                  * 1- We have switched to ad-hoc mode and we are
@@ -564,6 +580,12 @@ void ieee80211_softmac_ips_scan_syncro(s
 
--
 		}while(!channel_map[ieee->current_network.channel]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 					while (left >= sizeof(struct ieee80211_info_element_hdr)) {
 						if (sizeof(struct ieee80211_info_element_hdr) + info_element->len > left) {
 							printk(KERN_WARNING "[re]associate reeponse error!");
@@ -1859,6 +1886,12 @@ ieee80211_rx_frame_softmac(struct ieee80
 							info_element->len;
 						info_element = (struct ieee80211_info_element *)
--
 		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){
 
 			header = (struct ieee80211_hdr_3addr  *) skb->data;
@@ -2077,6 +2115,12 @@ void ieee80211_rtl_wake_queue(struct iee
 			//printk(KERN_ALERT "ieee80211_wake_queue \n");
 			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
--
-	while (left >= sizeof(struct ieee80211_info_element_hdr)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+               	while (left >= sizeof(struct ieee80211_info_element_hdr)) {
 		if (sizeof(struct ieee80211_info_element_hdr) + info_element->len > left) {
 			IEEE80211_DEBUG_SCAN("SCAN: parse failed: info_element->len + 2 > left : info_element->len+2=%d left=%d.\n",
 					     info_element->len + sizeof(struct ieee80211_info_element),
@@ -1181,6 +1186,12 @@ inline int ieee80211_network_init(
 			info_element->len;
--
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID) {
@@ -223,6 +228,12 @@ vMgrDecodeBeacon(
 
         }
--
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
         switch (pItem->byElementID) {
         case WLAN_EID_SSID:
@@ -417,6 +433,12 @@ vMgrDecodeAssocRequest(
             break;
         }
--
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID) {
@@ -594,6 +621,12 @@ vMgrDecodeReassocRequest(
             break;
         }
--
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID) {
@@ -669,6 +707,12 @@ vMgrDecodeProbeRequest(
         }
 
--
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
         switch (pItem->byElementID) {
         case WLAN_EID_SSID:
@@ -817,6 +866,12 @@ vMgrDecodeProbeResponse(
         }
 
--
-                while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                    timeout = rdstcll(start) + delta;
+                    while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
                         pMgmt->uScanChannel <= pDevice->byMaxChannel ){
                     pMgmt->uScanChannel++;
+                    if (_cur < timeout) {
+                    rdstcll(_cur);
+                    }
--
                 while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[0].sTxPSQueue)) != NULL) {
                     if (skb_queue_empty(&pMgmt->sNodeDBTable[0].sTxPSQueue)) {
                         pMgmt->abyPSTxMap[0] &= ~byMask[0];
@@ -828,6 +844,12 @@ void vRunCommand(void *hDeviceContext)
                     }
 
--
     while(--length >= 0) {
         unsigned char current_octet = *data++;
         int bit;
@@ -1330,6 +1335,12 @@ static inline u32 ether_crc(int length,
             crc = (crc << 1) ^
                 ((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);
--
-  while (str1_len >= str2_len) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (str1_len >= str2_len) {
        str1_len--;
       if(memcmp(str1,str2,str2_len)==0)
 	return (unsigned char *) str1;
         str1++;
+        if (_cur < timeout) {
--
   while(*tmp_p != 0x00) {
   	if(*tmp_p==' ')
 	    tmp_p++;
          else
 	  break;
-  }
--
 	while (nBytes > 0) {
 		s_vAppendByte(*src++);
 		nBytes--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (cbByte--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cbByte--) {
 		dwCrc = s_adwCrc32Table[(BYTE)((dwCrc ^ (*pbyData)) & 0xFF)] ^
 			(dwCrc >> 8);
 		pbyData++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
     while (ui > RATE_1M) {
         if (pDevice->wBasicRate & ((WORD)1 << ui)) {
             return (WORD)ui;
         }
         ui --;
+        if (_cur < timeout) {
--
     while (ui > RATE_11M) {
         if (pDevice->wBasicRate & ((WORD)1 << ui)) {
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"swGetOFDMControlRate : %d\n", ui);
             return (WORD)ui;
         }
         ui --;
--
-    while ((pDevice->Flags & fMP_POST_READS) &&
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while ((pDevice->Flags & fMP_POST_READS) &&
             MP_IS_READY(pDevice) &&
             (pDevice->NumRecvFreeList != 0) ) {
         pRCB = pDevice->FirstRecvFreeList;
@@ -1513,6 +1518,12 @@ void RXvWorkItem(void *Context)
         ASSERT(pRCB);// cannot be NULL
--
     while ( wLength2 > 0 ) {
 
         if ( wLength2 >= 64 ) {
@@ -1071,9 +1076,20 @@ BYTE    abyArray[256];
         wLength2 -= wLength;
         wValue += wLength;
--
     while ( wLength3 > 0 ) {
 
         if ( wLength3 >= 64 ) {
@@ -1092,6 +1108,12 @@ BYTE    abyArray[256];
         wLength3 -= wLength;
         wValue += wLength;
--
         while ( wLength2 > 0 ) {
 
             if ( wLength2 >= 64 ) {
@@ -1129,6 +1156,12 @@ BYTE    abyArray[256];
             wLength2 -= wLength;
             wValue += wLength;
--
                 while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) != NULL){
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "PS skb != NULL %d\n", ii);
                         dev_kfree_skb(skb);
+                        if (_cur < timeout) {
+                            rdstcll(_cur);
+                        }
--
     while (--count >= 0)
     {
         output = (data & EPROM_ACTIVE_OUT_BIT) ? 1 : 0; /* Get next data bit */
@@ -174,6 +179,12 @@ eeprom_put_byte (long addr, long data, i
 
         eeprom_delay ();
--
     while (--count >= 0)
     {
         eeprom_delay ();
@@ -211,6 +227,12 @@ eeprom_get_byte (long addr)
         data <<= 1;                 /* Shift data over */
         data |= (input & EPROM_ACTIVE_IN_BIT) ? 1 : 0;
--
     while (--index >= 0)
     {
         ptr[index] = (char) (value & 0xFF);
         value >>= 8;
+        if (_cur < timeout) {
+            rdstcll(_cur);
--
     while ((pdev = pci_get_device (PCI_VENDOR_ID_CONEXANT,
                                     PCI_DEVICE_ID_CN8474,
                                     pdev)))
     {
         if (c4_hdw_init (pdev, found))
             found++;
--
     while (count-- != 0)
     {
         temp1 = (crc >> 8) & 0x00FFFFFFL;
         temp2 = tbl[((int) crc ^ *buffer++) & 0xff];
         crc = temp1 ^ temp2;
+        if (_cur < timeout) {
--
     while (ci)
     {
         next = ci->next;            /* protect <next> from upcoming <free> */
@@ -569,6 +574,12 @@ c4_cleanup (void)
         OS_kfree (ci->iqd_p_saved);
         OS_kfree (ci);
--
     while (i > 0)
     {
         /* Don't leak all the previously allocated mbufs in this loop */
         i--;
         OS_mem_token_free (ch->mdr[i].mem_token);
+        if (_cur < timeout) {
--
 	while ((priv = dequeue_from_priv_tx(vdev)) != NULL) {
 		int ret;
 		struct urb *urb = priv->urb;
@@ -129,6 +134,12 @@ static int vhci_send_cmd_submit(struct v
 		usbip_dbg_vhci_tx("send txdata\n");
 
--
 	while ((unlink = dequeue_from_unlink_tx(vdev)) != NULL) {
 		int ret;
 		struct usbip_header pdu_header;
@@ -197,6 +213,12 @@ static int vhci_send_cmd_unlink(struct v
 		usbip_dbg_vhci_tx("send txdata\n");
 
--
 	while ((priv = stub_priv_pop(sdev))) {
 		urb = priv->urb;
 		dev_dbg(&sdev->udev->dev, "free urb %p\n", urb);
@@ -239,6 +244,12 @@ void stub_device_cleanup_urbs(struct stu
 		kfree(urb->transfer_buffer);
 		kfree(urb->setup_packet);
--
 	while ((priv = dequeue_from_priv_tx(sdev)) != NULL) {
 		int ret;
 		struct urb *urb = priv->urb;
@@ -275,6 +280,12 @@ static int stub_send_ret_submit(struct s
 		kfree(iso_buffer);
 
--
 	while ((unlink = dequeue_from_unlink_tx(sdev)) != NULL) {
 		int ret;
 		struct usbip_header pdu_header;
@@ -346,6 +362,12 @@ static int stub_send_ret_unlink(struct s
 
 		usbip_dbg_stub_tx("send txdata\n");
--
 	while (usbip_event_happened(ud)) {
 		usbip_dbg_eh("pending event %lx\n", ud->event);
 
@@ -56,6 +61,12 @@ static int event_handler(struct usbip_de
 		/* Stop the error handler. */
 		if (ud->event & USBIP_EH_BYE)
--
 	while (*c != '\0') {
 		int port, status, speed, devid;
 		unsigned long socket;
@@ -110,6 +115,12 @@ static int parse_status(char *value)
 
 		/* go to the next line */
--
 	while (*c != '\0') {
 		/* go to the next line */
 		c = strchr(c, '\n') + 1;
 		nports += 1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (bit) {
 		u32 prev = prev_status & bit;
 		u32 new = new_status & bit;
@@ -114,6 +119,12 @@ static void dump_port_status_diff(u32 pr
 			pr_debug(" %c%s\n", change, bit_desc[i]);
 		bit <<= 1;
--
-	while (dev->ring_head == dev->ring_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (dev->ring_head == dev->ring_tail) {
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EAGAIN;
 			goto unlock_exit;
@@ -509,6 +514,12 @@ static ssize_t usb_alphatrack_read(struc
 					     dev->interrupt_in_done);
--
 	while ((c < count) && (dev->ring_tail != dev->ring_head)) {
 		if (copy_to_user
 		    (&buffer[c], &(*dev->ring_buffer)[dev->ring_tail],
@@ -527,6 +543,12 @@ static ssize_t usb_alphatrack_read(struc
 		c += INPUT_CMD_SIZE;
 		dbg_info(&dev->intf->dev, "%s: head, tail are %x, %x\n",
--
 	while (i < (MAX_DEFECTIVE_BLOCK + 2)) {
 		if (monitor_card_cd(chip, MS_CARD) == CD_NOT_EXIST)
 			TRACE_RET(chip, STATUS_FAIL);
@@ -2070,6 +2075,12 @@ RE_SEARCH:
 
 		ms_card->boot_block = i;
--
 	while ((N < min_N) && (div < max_div)) {
 		N = (N + 2) * 2 - 2;
 		div++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (desc_cnt) {
 		if (check_card_ready(chip, lun)) {
 			buf[i++] = (unsigned char)((chip->capacity[lun]) >> 24);
@@ -971,6 +976,12 @@ static int read_format_capacity(struct s
 		buf[i++] = 0x00;
 
--
-	while (cnt < buflen && sg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt < buflen && sg) {
 		struct page *page = sg_page(sg) +
 		    ((sg->offset + *offset) >> PAGE_SHIFT);
 		unsigned int poff = (sg->offset + *offset) & (PAGE_SIZE - 1);
@@ -96,7 +101,12 @@ unsigned int rts51x_access_sglist(unsign
 		/* Transfer the data for all the pages in this
--
-		while (sglen > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (sglen > 0) {
 			unsigned int plen = min(sglen, (unsigned int)
 						PAGE_SIZE - poff);
 			unsigned char *ptr = kmap(page);
@@ -112,6 +122,18 @@ unsigned int rts51x_access_sglist(unsign
 			++page;
--
 	while (i < entries && !io->status) {
 		int retval;
 
@@ -661,6 +688,12 @@ int rts51x_sg_wait(struct usb_sg_request
 		spin_lock_irq(&io->lock);
 		if (retval && (io->status == 0 || io->status == -ECONNRESET))
--
         while ( ( p = hcf_dma_rx_get( &lp->hcfCtx ) ) != NULL ) {
             if( p && p->buf_addr == NULL ) {
                 /* A reclaim descriptor is being given back by the HCF. Reclaim
@@ -1436,6 +1441,12 @@ void wl_pci_dma_hcf_reclaim_rx( struct w
             lp->dma.rx_packet[i] = p;
             lp->dma.rx_rsc_ind++;
--
         while ( ( p = hcf_dma_tx_get( &lp->hcfCtx ) ) != NULL ) {
 
             if( p != NULL && p->buf_addr == NULL ) {
@@ -1568,6 +1584,12 @@ void wl_pci_dma_hcf_reclaim_tx( struct w
             lp->dma.tx_packet[i] = p;
             lp->dma.tx_rsc_ind++;
--
 	while ( n-- ) {
 		p = (hcf_16 FAR *)dst;
 		*p++ = (hcf_16)_inpw( prt );
@@ -170,6 +175,12 @@ void IN_PORT_STRING_32( hcf_io prt, hcf_
 			fprintf( log_file, "%s%08lx ", i++ % 0x08 ? " " : "\n", *dst);
 		}
--
 	while ( n-- ) {
 		*p =(hcf_16)_inpw( prt);
 		if ( log_file ) {
@@ -190,6 +206,12 @@ void IN_PORT_STRING_8_16( hcf_io prt, hc
 			}
 		}
--
 	while ( n-- ) {
 		p = (hcf_16 FAR *)src;
 		_outpw( prt, *p++ );
@@ -208,6 +235,12 @@ void OUT_PORT_STRING_32( hcf_io prt, hcf
 			fprintf( log_file, "%s%08lx ", i++ % 0x08 ? " " : "\n", *src);
 		}
--
 	while ( n-- ) {
 		(void)_outpw( prt, *p);
 		if ( log_file ) {
@@ -227,6 +265,12 @@ void OUT_PORT_STRING_8_16( hcf_io prt, h
 			}
 		}
--
 					while ( p ) {
 						//p->buf_cntl.cntl_stat |= DESC_DMA_OWNED;
 						p->BUF_CNT |= DESC_DMA_OWNED;
 						p = p->next_desc_addr;
+						if (_cur < timeout) {
+							rdstcll(_cur);
--
 		while ( ( p->BUF_SIZE & DESC_EOP ) == 0 && p->next_desc_addr ) {
 			if ( ( ifbp->IFB_CntlOpt & DMA_ENABLED ) == 0 ) {   //clear control bits when disabled
 				p->BUF_CNT &= DESC_CNT_MASK;
 			}
 			prev = p;
 			p = p->next_desc_addr;
--
-		} else while ( ifbp->IFB_MICRxCarry < 4 && len ) {      //note for hcf_16 applies: 0xFFFF > 4
+		} else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
--
+				while ( ifbp->IFB_MICRxCarry < 4 && len ) {      //note for hcf_16 applies: 0xFFFF > 4
 				x.x8[ifbp->IFB_MICRxCarry++] = *p++;
 				len--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 		while ( ifbp->IFB_MICRxCarry == 4 ) {   //contrived so we have only 1 call to calc_mic so we could bring it in-line
 			calc_mic( ifbp->IFB_MICRx, x.x32 );
 			x.x32 = CNV_LONGP_TO_LITTLE(p);
@@ -3192,6 +3276,12 @@ calc_mic_rx_frag( IFBP ifbp, wci_bufp p,
 				ifbp->IFB_MICRxCarry = (hcf_16)len;
 			}
--
-		} else while ( ifbp->IFB_MICTxCarry < 4 && len ) {      /* note for hcf_16 applies: 0xFFFF > 4 */
+		} else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
--
+				while ( ifbp->IFB_MICTxCarry < 4 && len ) {      /* note for hcf_16 applies: 0xFFFF > 4 */
 				x.x8[ifbp->IFB_MICTxCarry++] = *p++;
 				len--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 		                                //.  while accu contains complete double word
 		                                //.  and MIC enabled
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while ( ifbp->IFB_MICTxCarry == 4 ) {
 			                        //.  .  pass accu to MIC engine
 			calc_mic( ifbp->IFB_MICTx, x.x32 );
@@ -3287,6 +3395,12 @@ calc_mic_tx_frag( IFBP ifbp, wci_bufp p,
 			}
 			                        //.  .  adjust remaining buffer length
--
-            while( numAPs >= 1 ) {
+            unsigned long long delta = (cpu / khz / HZ) * 2;
+            unsigned long long _start = 0;
+            unsigned long long _cur = 0;
+            unsigned long long timeout;
+                timeout = rdstcll(start) + delta;
+                while( numAPs >= 1 ) {
                 numAPs--;
 
                 pAps[numAPs].channel_id           =
@@ -523,6 +528,12 @@ void wl_endian_translate_event( ltv_t *p
 
--
 		while( (*p).scan_complete == FALSE && ret == HCF_SUCCESS ) {
 			DBG_TRACE( DbgInfo, "Waiting for scan results...\n" );
 			/* Abort the scan if we've waited for more than MAX_SCAN_TIME_SEC */
@@ -935,6 +940,12 @@ static int wireless_get_ap_list (struct
 					schedule( );
 				}
--
 	while (p->len && i == NULL) {					/* check the MFI ranges */
 		if (p->typ  == CFG_MFI_ACT_RANGES_STA) {
 			i = mmd_check_comp((void *)p, &mfi_sup);
 		}
 		p++;
+		if (_cur < timeout) {
--
 		while (p->len && i == NULL) {			/* check the CFI ranges */
 			if (p->typ  == CFG_CFI_ACT_RANGES_STA) {
 				 i = mmd_check_comp((void *)p, &cfi_sup);
 			}
 			p++;
+			if (_cur < timeout) {
--
 		while (p->len) {
 			p->host_addr = (char *)p->host_addr + (hcf_32)fw;
 			p++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 	while ((rc == HCF_SUCCESS) && ((ltvp = pp->ltvp) != NULL)) {
 		ltvp->len = pp++->len;	/* Set len to original len. This len is changed to real len by GET_INFO() */
 		rc = GET_INFO(ltvp);
 		MMDASSERT(rc == HCF_SUCCESS, rc)
 		MMDASSERT(rc == HCF_SUCCESS, ltvp->typ)
 		MMDASSERT(rc == HCF_SUCCESS, ltvp->len)
--
 		while (rc == HCF_SUCCESS && p->len) {
 			rc = PUT_INFO(p);
 			p++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (value[value_offset] != '\0') {
 		/* Skip over the colon chars seperating the bytes, if they exist */
 		if (value[value_offset] == ':') {
@@ -927,6 +932,12 @@ int parse_mac_address(char *value, u_cha
 			field_offset = 0;
 			array_offset++;
--
 		while (( hcf_status != HCF_SUCCESS ) && (retries < 10)) {
 			retries++;
 			hcf_status = wl_disable( lp );
+			if (_cur < timeout) {
+						rdstcll(_cur);
+			}
--
-			while( num_aps >= 1 ) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while( num_aps >= 1 ) {
 				num_aps--;
 
 				aps[num_aps].channel_id =
@@ -2925,6 +2941,12 @@ void wl_endian_translate_mailbox( ltv_t
 					CNV_LITTLE_TO_INT( aps[num_aps].ssid_len );
--
-			while( num_aps >= 1 ) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while( num_aps >= 1 ) {
 				num_aps--;
 
 				DBG_TRACE( DbgInfo, "AP              : %d\n", num_aps );
@@ -3062,6 +3089,12 @@ void wl_process_mailbox( struct wl_priva
 				   adapter struct */
--
-	while (dv_window < 8) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (dv_window < 8) {
 		data_invalid_rhoh = en_lo * CLK_X + Trhoh[mode];
 
 		data_invalid_rloh = (en_lo + en_hi) * CLK_X + Trloh[mode];
@@ -210,6 +215,12 @@ static void NAND_ONFi_Timing_Mode(u16 mo
 
--
-		while (page_count > MAX_PAGES_PER_RW) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (page_count > MAX_PAGES_PER_RW) {
 			if (ioread32(FlashReg + MULTIPLANE_OPERATION))
 				status = NAND_Multiplane_Read(read_data_l,
 					block, page, MAX_PAGES_PER_RW);
@@ -1133,6 +1149,12 @@ u16 NAND_Read_Page_Main_Polling(u8 *read
 					MAX_PAGES_PER_RW;
--
-		while (page_count > MAX_PAGES_PER_RW) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (page_count > MAX_PAGES_PER_RW) {
 			if (ioread32(FlashReg + MULTIPLANE_OPERATION))
 				status = NAND_Multiplane_Read(read_data_l,
 					block, page, MAX_PAGES_PER_RW);
@@ -1345,6 +1372,12 @@ u16 NAND_Read_Page_Main(u8 *read_data, u
 					MAX_PAGES_PER_RW;
--
 		while (page_count > 0) {
 			page_offset = (page_count - 1) * PageSize;
 			j = (DeviceInfo.wPageDataSize / eccSectorSize);
@@ -1450,6 +1488,12 @@ void Conv_Main_Spare_Data_Log2Phy_Format
 				data[page_offset + i + spareSkipBytes] =
 					data[page_offset + i];
--
 		while (page_count > 0) {
 			page_offset = (page_count - 1) * PageSize;
 			for (i = PageDataSize;
@@ -1490,6 +1539,12 @@ void Conv_Main_Spare_Data_Phy2Log_Format
 					data[page_offset +
 					(eccSectorSize + eccBytes) * j + i];
--
-		while (page_count > MAX_PAGES_PER_RW) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (page_count > MAX_PAGES_PER_RW) {
 			if (ioread32(FlashReg + MULTIPLANE_OPERATION))
 				status = NAND_Multiplane_Write(write_data_l,
 					block, page, MAX_PAGES_PER_RW);
@@ -1717,6 +1777,12 @@ u16 NAND_Write_Page_Main(u8 *write_data,
 					MAX_PAGES_PER_RW;
--
 		while ((status != FAIL) && (page_count > 0)) {
 			flash_add = (u64)(block %
 			(DeviceInfo.wTotalBlocks / totalUsedBanks)) *
@@ -1892,6 +1963,12 @@ u16 NAND_Write_Page_Main_Spare(u8 *write
 			page_num++;
 			page_count--;
--
-		while ((status != FAIL) && (page_count > 0)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((status != FAIL) && (page_count > 0)) {
 			flash_add = (u64)(block %
 				(DeviceInfo.wTotalBlocks / totalUsedBanks))
 				* DeviceInfo.wBlockDataSize +
@@ -2036,6 +2118,12 @@ u16 NAND_Read_Page_Main_Spare(u8 *read_d
 			page++;
--
 	while (1) {
 		while (!ioread32(FlashReg + intr_status))
 			;
@@ -2186,6 +2279,12 @@ u16 NAND_Multiplane_Write(u8 *write_data
 				(~INTR_STATUS0__DMA_CMD_COMP),
 				FlashReg + intr_status);
 		}
--
 	while (1) {
 		while (!ioread32(FlashReg + intr_status))
 			;
@@ -2313,6 +2417,12 @@ static void handle_nand_int_write(struct
 				(~INTR_STATUS0__DMA_CMD_COMP),
 				FlashReg + intr_status);
 		}
--
 	while (!kthread_should_stop()) {
 		int res;
 
@@ -450,6 +455,12 @@ static int spectra_trans_thread(void *ar
 
 		if (!__blk_end_request_cur(req, res))
--
-	while (PageCount) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (PageCount) {
 		ret = spectra_mtd->write(spectra_mtd,
 					 (Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),
 					 DeviceInfo.wPageDataSize, &retlen, write_data);
@@ -243,6 +248,12 @@ u16 mtd_Write_Page_Main(u8 *write_data,
 		write_data += DeviceInfo.wPageDataSize;
--
-	while (PageCount) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (PageCount) {
 		ret = spectra_mtd->read(spectra_mtd,
 					(Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),
 					DeviceInfo.wPageDataSize, &retlen, read_data);
@@ -293,6 +309,12 @@ u16 mtd_Read_Page_Main(u8 *read_data, u3
 		read_data += DeviceInfo.wPageDataSize;
--
 	while (PageCount) {
 		struct mtd_oob_ops ops;
 		int ret;
@@ -357,6 +384,12 @@ u16 mtd_Read_Page_Main_Spare(u8 *read_da
 		read_data += DeviceInfo.wPageSize;
 		Page++;
--
 	while (page_count) {
 		struct mtd_oob_ops ops;
 		int ret;
@@ -417,6 +455,12 @@ u16 mtd_Write_Page_Main_Spare(u8 *write_
 		write_data += DeviceInfo.wPageSize;
 		Page++;
--
 	while (PageCount) {
 		struct mtd_oob_ops ops;
 		int ret;
@@ -491,6 +540,12 @@ u16 mtd_Read_Page_Spare(u8 *read_data, u
 		read_data += DeviceInfo.wPageSize;
 		Page++;
--
-			while ((search_result == PASS) && (FAIL == wResult)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((search_result == PASS) && (FAIL == wResult)) {
 				nand_dbg_print(NAND_DBG_DEBUG,
 					"FTL_Read_Block_Table:"
 					"Block: %u Page: %u "
@@ -2669,6 +2674,12 @@ static int FTL_Read_Block_Table(void)
 					else
--
-	while (go_on == PASS) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (go_on == PASS) {
 		nand_dbg_print(NAND_DBG_DEBUG,
 			"starting static wear leveling\n");
 		most_worn_cnt = 0;
@@ -2980,6 +2996,12 @@ int FTL_Static_Wear_Leveling(void)
 				&least_worn_idx, &replaced_blks, &result);
--
-	while ((i < DeviceInfo.wDataBlockNum) && (discard_cnt > 0) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((i < DeviceInfo.wDataBlockNum) && (discard_cnt > 0) &&
 			((ftl_cmd_cnt + 28) < 256)) {
 		if (((pbt[i] & BAD_BLOCK) != BAD_BLOCK) &&
 				(pbt[i] & DISCARD_BLOCK)) {
@@ -3049,6 +3076,12 @@ static int do_garbage_collection(u32 dis
 		}
--
 	while ((i < DeviceInfo.wDataBlockNum) && (discard_cnt > 0)) {
 		if (((pbt[i] & BAD_BLOCK) != BAD_BLOCK) &&
 				(pbt[i] & DISCARD_BLOCK)) {
@@ -3122,6 +3160,12 @@ static int do_garbage_collection(u32 dis
 		}
 
--
 			while(RF3_Final_Value!=RegValueToBeCheck && RetryTimes!=0)
 			{
 				ret = rtl8192_phy_ConfigRFWithHeaderFile(dev,(RF90_RADIO_PATH_E)eRFPath);
 				RF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);
 				RT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);
 				RetryTimes--;
--
 			while(RF3_Final_Value!=RegValueToBeCheck && RetryTimes!=0)
 			{
 				ret = rtl8192_phy_ConfigRFWithHeaderFile(dev,(RF90_RADIO_PATH_E)eRFPath);
 				RF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);
 				RT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);
 				RetryTimes--;
--
 			while(RF3_Final_Value!=RegValueToBeCheck && RetryTimes!=0)
 			{
 				ret = rtl8192_phy_ConfigRFWithHeaderFile(dev,(RF90_RADIO_PATH_E)eRFPath);
 				RF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);
 				RT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);
 				RetryTimes--;
--
 			while(RF3_Final_Value!=RegValueToBeCheck && RetryTimes!=0)
 			{
 				ret = rtl8192_phy_ConfigRFWithHeaderFile(dev,(RF90_RADIO_PATH_E)eRFPath);
 				RF3_Final_Value = rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, RegOffSetToBeCheck, bMask12Bits);
 				RT_TRACE(COMP_RF, "RF %d %d register final value: %x\n", eRFPath, RegOffSetToBeCheck, RF3_Final_Value);
 				RetryTimes--;
--
 		while (nbytes > walk->len_this_page) {
 			memcpy_dir(buf, walk->data, walk->len_this_page, out);
 			buf += walk->len_this_page;
@@ -114,6 +119,12 @@ int scatterwalk_copychunks(void *buf, st
 			crypto_kunmap(walk->data, out);
 			scatterwalk_pagedone(walk, out, 1);
--
 	while(1)
 	{
 
@@ -477,7 +482,13 @@ void ieee80211_softmac_scan_syncro(struc
 
 		msleep_interruptible_rsl(IEEE80211_SOFTMAC_SCAN_TIME);
--
 		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){
 
 			header = (struct ieee80211_hdr_3addr  *) skb->data;
@@ -2253,6 +2269,12 @@ void ieee80211_wake_queue(struct ieee802
 
 			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
--
 	while(pList->next != &pTS->RxPendingPktList)
 	{
 		if( SN_LESS(pReorderEntry->SeqNum, ((PRX_REORDER_ENTRY)list_entry(pList->next,RX_REORDER_ENTRY,List))->SeqNum) )
@@ -539,6 +544,12 @@ AddReorderEntry(
 		{
 			break;
--
 	while (len >= 4) {
 		mctx->l ^= get_le32(data);
 		michael_block(mctx->l, mctx->r);
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
--
 		while(!list_empty(&pRxTs->RxPendingPktList))
 		{
 			pReorderEntry = (PRX_REORDER_ENTRY)list_entry(pRxTs->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
@@ -67,6 +72,12 @@ void RxPktPendingTimeout(unsigned long d
 				bPktInBuf = true;
 				break;
--
 		while(!list_empty(&pRxTS->RxPendingPktList))
 		{
 		//      PlatformAcquireSpinLock(Adapter, RT_RX_SPINLOCK);
@@ -516,6 +532,12 @@ void RemoveTsEntry(
 			list_add_tail(&pRxReorderEntry->List,&ieee->RxReorder_Unused_List);
 			//PlatformReleaseSpinLock(Adapter, RT_RX_SPINLOCK);
--
 	while (read_nic_dword(dev, QPNR)&0x80000000)
 	{
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
@@ -404,10 +409,21 @@ phy_FwRFSerialRead(
 		}
 		else
--
 	while (read_nic_dword(dev, QPNR)&0x80000000)
 	{
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
@@ -418,6 +434,12 @@ phy_FwRFSerialRead(
 		}
 		else
--
 	while (read_nic_dword(dev, QPNR)&0x80000000)
 	{
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
@@ -468,6 +495,12 @@ phy_FwRFSerialWrite(
 		}
 		else
--
 	while ((skb = __skb_dequeue(&priv->rx_queue))) {
 		info = (struct rtl8192_rx_info *) skb->cb;
 		if (!info->urb)
@@ -1048,6 +1053,12 @@ void rtl8192_rtx_disable(struct net_devi
 
 		usb_kill_urb(info->urb);
--
 		while((i--)>=0)
 		{
 			ulStatus = read_nic_dword(dev, RWCAM);
@@ -4044,6 +4060,12 @@ void CAM_read_entry(
 			else{
 				break;
--
 	while (NULL != (skb = skb_dequeue(&priv->skb_queue))) {
 		info = (struct rtl8192_rx_info *)skb->cb;
 		switch (info->out_pipe) {
@@ -5730,6 +5757,12 @@ void rtl8192_irq_rx_tasklet(struct r8192
 				break;
 
--
 	while (total_length > 0 || exe_cnt++ >100)
 	{
 		/* 2007/01/17 MH We support aggregation of different cmd in the same packet. */
@@ -784,6 +789,12 @@ cmpk_message_handle_rx(
 
 		total_length -= cmd_length;
--
 	}	/* while (total_length > 0) */
 	return	1;	/* This is a command packet. */
 
diff -u -p a/staging/serial/68360serial.c b/staging/serial/68360serial.c
--- a/staging/serial/68360serial.c
+++ b/staging/serial/68360serial.c
--
-		while (i-- > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (i-- > 0) {
 			ch = *cp++;
 			icount->rx++;
 
@@ -493,6 +498,12 @@ static _INLINE_ void receive_chars(ser_i
 				 * affect the current character
--
 			while (1) {
 				interruptible_sleep_on(&info->delta_msr_wait);
 				/* see if a signal did it */
@@ -1495,6 +1511,12 @@ static int rs_360_ioctl(struct tty_struc
 					return 0;
 				}
--
 	while (ptr && (count < PAGE_SIZE)) {
 		if (ptr->name) {
 			count += snprintf(buf + count,
@@ -131,6 +136,12 @@ static ssize_t buttons_show(struct devic
 					"%d\t%s\n", ptr->id, ptr->name);
 		}
--
 	while (*ptr) {
 		if (*ptr == data) {
 			*ptr = (*ptr)->next;
@@ -192,6 +208,12 @@ static void quickstart_btnlst_del(struct
 			return;
 		}
--
 	while (ptr) {
 		lptr = ptr;
 		ptr = ptr->next;
 		kfree(lptr->name);
 		kfree(lptr);
+		if (_cur < timeout) {
--
 	while (*ptr) {
 		count++;
 		set_bit(EV_KEY, quickstart_input->evbit);
 		set_bit((*ptr)->id, quickstart_input->keybit);
 		ptr = &((*ptr)->next);
+		if (_cur < timeout) {
--
 	while (!pt) {
 		spin_unlock(lock);
 		pt = psb_mmu_alloc_pt(pd);
@@ -386,6 +391,12 @@ struct psb_mmu_pt *psb_mmu_pt_alloc_map_
 			psb_mmu_clflush(pd->driver, (void *) &v[index]);
 			atomic_set(&pd->driver->needs_tlbflush, 1);
--
 	while (gtt_pages--) {
 		*v++ = gtt_start | pd->pd_mask;
 		gtt_start += PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((timeout < 20000) && (REG_READ(gen_fifo_stat_reg) & DSI_FIFO_GEN_HS_DATA_FULL)) {
 		udelay(100);
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((timeout < 20000) && (REG_READ(gen_fifo_stat_reg) & DSI_FIFO_GEN_HS_CTRL_FULL)) {
 		udelay(100);
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-        while ((timeout < 20000) && ((REG_READ(gen_fifo_stat_reg) & DPI_FIFO_EMPTY)
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+                timeout = rdstcll(start) + delta;
+                while ((timeout < 20000) && ((REG_READ(gen_fifo_stat_reg) & DPI_FIFO_EMPTY)
                                                         != DPI_FIFO_EMPTY)) {
                 udelay(100);
                 timeout++;
+                if (_cur < timeout) {
+		rdstcll(_cur);
--
         while ((timeout < 20000) && (!(REG_READ(intr_stat_reg) & DSI_INTR_STATE_SPL_PKG_SENT))) {
                 udelay(100);
                 timeout++;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
--
 			while ((pipe != 2) && (timeout < 20000) && !(REG_READ(pipeconf_reg) & PIPECONF_DSIPLL_LOCK)) {
 				udelay(150);
 				timeout ++;
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
--
 	while ((timeout < 20000) && !(REG_READ(pipeconf_reg) & PIPECONF_DSIPLL_LOCK)) {
 		udelay(150);
 		timeout ++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (true) {
 		pwr_sts = inl(dev_priv->ospm_base + PSB_PM_SSS);
 		if ((pwr_sts & pwr_mask) == pwr_mask)
 			break;
 		else
 			udelay(10);
--
 	while (true) {
 		pwr_sts = inl(dev_priv->ospm_base + PSB_PM_SSS);
 		if ((pwr_sts & pwr_mask) == 0)
 			break;
 		else
 			udelay(10);
--
 	while (index < total) {
 		current_id = *(base + index);
 		index++;
@@ -47,6 +52,12 @@ static void *find_section(struct bdb_hea
 		if (current_id == section_id)
 			return base + index;
--
 			while ((timeout < 20000) && !(PSB_RVDC32(pipeconf_reg) & PIPECONF_DSIPLL_LOCK)) {
 				udelay(150);
 				timeout++;
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
--
 	while (avail < size) {
 		avail = PSB_RSGX32(PSB_CR_2D_SOCIF);
 		if (time_after(jiffies, t)) {
 			psb_spank(dev_priv);
 			return -EIO;
 		}
--
 	while (status & 1) {
 		udelay(1); /* scu processing time is in few u secods */
 		status = readl(scu_base + 0x04);
@@ -147,6 +152,12 @@ static void scu_busy_loop(void *scu_base
 			DRM_DEBUG_KMS("SCU IPC timed out");
 			return;
--
 	while (retry--) {
 		if ((mask & REG_READ(gen_fifo_stat_reg)) == mask)
 			return 0;
 		udelay(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&sender->pkg_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&sender->pkg_list)) {
 		pkg = list_first_entry(&sender->pkg_list,
 					struct mdfld_dsi_pkg, entry);
 		send_pkg(sender, pkg);
 		list_del_init(&pkg->entry);
 		pkg_sender_put_pkg_locked(sender, pkg);
--
 	while (retry && !(REG_READ(sender->mipi_intr_stat_reg) & (1 << 29))) {
 		udelay(100);
 		retry--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (retry &&
 		    !(REG_READ(sender->mipi_gen_fifo_stat_reg) & (1 << 27))) {
 			udelay(500);
 			retry--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (retry &&
 			(REG_READ(sender->mipi_cmd_addr_reg) & (1 << 0))) {
 			udelay(1);
 			retry--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (retry--) {
 		/* Read the command response */
 		for (i = 0; i < response_len; i++) {
@@ -281,6 +286,12 @@ static u8 psb_intel_sdvo_read_response(
 			return status;
 
--
 	while (1) {
 
 		count = qt_chars_in_buffer(tty);
@@ -1042,6 +1047,12 @@ static void qt_block_until_empty(struct
 		} else {
 			wait = 30;
--
 		while (qt_port != NULL) {
 			interruptible_sleep_on(&qt_port->msr_wait);
 			if (signal_pending(current))
@@ -1223,6 +1239,12 @@ static int qt_ioctl(struct tty_struct *t
 					return 0;
 				}
--
 	while (Media.Sector<CIS_SEARCH_SECT)
 	{
 		if (Media.Sector)
@@ -1600,6 +1605,12 @@ int Search_D_CIS(struct us_data *us)
 		}
 
--
-	while (cnt < buflen && sg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt < buflen && sg) {
 		struct page *page = sg_page(sg) +
 					((sg->offset + *offset) >> PAGE_SHIFT);
 		unsigned int poff = (sg->offset + *offset) & (PAGE_SIZE-1);
@@ -436,7 +441,12 @@ unsigned int usb_stor_access_xfer_buf(st
 			sg = sg_next(sg);
--
-		while (sglen > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (sglen > 0) {
 			unsigned int plen = min(sglen,
 						(unsigned int)PAGE_SIZE - poff);
 			unsigned char *ptr = kmap(page);
@@ -452,6 +462,18 @@ unsigned int usb_stor_access_xfer_buf(st
 			++page;
--
 	while (d) { /* If d=0 finish counting */
 		if (d&BIT0)
 			++i; /* Count number of 1 bit */
 		d >>= 1; /* Right shift */
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (kp->nr < ARRAY_SIZE(kp->objnodes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (kp->nr < ARRAY_SIZE(kp->objnodes)) {
 		preempt_enable_no_resched();
 		objnode = kmem_cache_alloc(zcache_objnode_cache,
 				ZCACHE_GFP_MASK);
@@ -1015,6 +1020,12 @@ static int zcache_do_preload(struct tmem
 			kp->objnodes[kp->nr++] = objnode;
--
-		while (kp->nr) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (kp->nr) {
 			kmem_cache_free(zcache_objnode_cache,
 					kp->objnodes[kp->nr - 1]);
 			kp->objnodes[kp->nr - 1] = NULL;
 			kp->nr--;
+			if (_cur < timeout) {
--
 	while (rbnode) {
 		BUG_ON(RB_EMPTY_NODE(rbnode));
 		obj = rb_entry(rbnode, struct tmem_obj, rb_tree_node);
@@ -93,6 +98,12 @@ static struct tmem_obj *tmem_obj_find(st
 			rbnode = rbnode->rb_right;
 			break;
--
 	while (*new) {
 		BUG_ON(RB_EMPTY_NODE(*new));
 		this = rb_entry(*new, struct tmem_obj, rb_tree_node);
@@ -159,6 +175,12 @@ static void tmem_obj_init(struct tmem_ob
 			new = &(*new)->rb_right;
 			break;
--
 		while (rbnode != NULL) {
 			obj = rb_entry(rbnode, struct tmem_obj, rb_tree_node);
 			rbnode = rb_next(rbnode);
 			tmem_pampd_destroy_all_in_obj(obj);
 			tmem_obj_free(obj, hb);
 			(*tmem_hostops.obj_free)(obj, pool);
--
 	while (height > 0) {
 		if (*slot == NULL)
 			goto out;
@@ -302,6 +340,12 @@ static void **__tmem_pampd_lookup_in_obj
 			 ((index >> shift) & OBJNODE_TREE_MAP_MASK));
 		shift -= OBJNODE_TREE_MAP_SHIFT;
--
 	while (height > 0) {
 		if (slot == NULL) {
 			/* add a child objnode.  */
@@ -386,6 +435,12 @@ insert:
 		slot = objnode->slots[offset];
 		shift -= OBJNODE_TREE_MAP_SHIFT;
--
 	} while (height > 0);
 	if (slot == NULL)
 		goto out;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (pathp->objnode) {
 		pathp->objnode->slots[pathp->offset] = NULL;
 		pathp->objnode->slots_in_use--;
 		if (pathp->objnode->slots_in_use) {
 			if (pathp->objnode == obj->objnode_tree_root) {
-				while (obj->objnode_tree_height > 0 &&
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (obj->objnode_tree_height > 0 &&
 				  obj->objnode_tree_root->slots_in_use == 1 &&
 				  obj->objnode_tree_root->slots[0]) {
 					struct tmem_objnode *to_free =
@@ -450,12 +515,24 @@ static void *tmem_pampd_delete_from_obj(
 					to_free->slots[0] = NULL;
--
-	while (!list_empty(&rx_ring->recv_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&rx_ring->recv_list)) {
 		rfd = (struct rfd *) list_entry(rx_ring->recv_list.next,
 				struct rfd, list_node);
 
 		list_del(&rfd->list_node);
 		rfd->skb = NULL;
--
 	while (tcb != NULL && freed < NUM_TCB) {
 		struct tcb *next = tcb->next;
 
@@ -3725,6 +3741,12 @@ void et131x_free_busy_send_packets(struc
 		spin_lock_irqsave(&adapter->tcb_send_qlock, flags);
 
--
 	while (tcb &&
 	       ((serviced ^ tcb->index) & ET_DMA10_WRAP) &&
 	       index < INDEX10(tcb->index)) {
@@ -3774,7 +3801,18 @@ void et131x_handle_send_interrupt(struct
 
 		/* Goto the next packet */
--
 	while (tcb &&
 	       !((serviced ^ tcb->index) & ET_DMA10_WRAP)
 	       && index > (tcb->index & ET_DMA10_MASK)) {
@@ -3789,6 +3827,12 @@ void et131x_handle_send_interrupt(struct
 
 		/* Goto the next packet */
--
 		while (*esc && cgoffset < 8) {
 			shift ^= 4;
 			if (*esc >= '0' && *esc <= '9')
@@ -1162,6 +1167,12 @@ static inline int handle_lcd_special_cod
 			}
 
--
 		while (max_len-- && keypad_buflen < KEYPAD_BUFFER && *string) {
 			keypad_buffer[(keypad_start + keypad_buflen++) %
 				      KEYPAD_BUFFER] = *string++;
+				      if (_cur < timeout) {
+				      	rdstcll(_cur);
+				      }
--
-	while (*name) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (*name) {
 		int in, out, bit, neg;
 		for (in = 0; (in < sizeof(sigtab)) &&
 			     (sigtab[in] != *name); in++)
@@ -1968,6 +1995,12 @@ static int input_name2mask(char *name, p
 		if (!neg)
--
-	while (write_length >= 4) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (write_length >= 4) {
 		mei_reg_write(dev, H_CB_WW,
 				*(u32 *) (write_buffer + bytes_written));
 		bytes_written += 4;
 		write_length -= 4;
+		if (_cur < timeout) {
--
-	while (buffer_length >= sizeof(u32)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (buffer_length >= sizeof(u32)) {
 		((u32 *) buffer)[i] = mei_mecbrw_read(dev);
 
 		dev_dbg(&dev->pdev->dev,
@@ -230,6 +246,12 @@ void mei_read_slots(struct mei_device *d
 
--
-	while (cb == NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cb == NULL) {
 		/* unlock the Mutex */
 		mutex_unlock(&dev->device_lock);
 
@@ -313,6 +318,12 @@ int amthi_read(struct mei_device *dev, s
 
--
-	while (slots > 0 && !dev->extra_write_index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (slots > 0 && !dev->extra_write_index) {
 		dev_dbg(&dev->pdev->dev, "slots =%08x  extra_write_index =%08x.\n",
 				slots, dev->extra_write_index);
 		dev_dbg(&dev->pdev->dev, "call mei_irq_thread_read_handler.\n");
 		rets = mei_irq_thread_read_handler(&complete_list, dev, &slots);
 		if (rets)
--
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (1) {
 			add_wait_queue(&port_extra->wait, &wait);
 			schedule();
 			dbg("%s(): port %d, cmd == TIOCMIWAIT here\n",
@@ -948,6 +953,12 @@ static int qt2_ioctl(struct tty_struct *
 				__set_current_state(TASK_RUNNING);
--
 		} /* end inifinite while */
 		/* FIXME: This while loop needs a way to break out if the device
 		 * is disconnected while a process is waiting for the MSR to
diff -u -p a/staging/bcm/Qos.c b/staging/bcm/Qos.c
--- a/staging/bcm/Qos.c
+++ b/staging/bcm/Qos.c
@@ -406,6 +406,11 @@ VOID flush_all_queues(PMINI_ADAPTER Adap
 		struct net_device_stats *netstats = &Adapter->dev->stats;
--
 		while(Adapter->PackInfo[iQIndex].FirstTxQueue)
 		{
 			PacketToDrop = Adapter->PackInfo[iQIndex].FirstTxQueue;
@@ -435,6 +440,12 @@ VOID flush_all_queues(PMINI_ADAPTER Adap
 					Adapter->PackInfo[iQIndex].uiDroppedCountBytes,
 					Adapter->PackInfo[iQIndex].uiDroppedCountPackets);
--
 		while((u8IpAddressLen>= nSizeOfIPAddressInBytes) &&
 				(ucLoopIndex < MAX_IP_RANGE_LENGTH))
 		{
@@ -232,6 +237,12 @@ CopyIpAddrToClassifier(S_CLASSIFIER_RULE
 				pstClassifierEntry->bDestIpValid=TRUE;
 			}
--
 	while((ulMaxTry)&&(Adapter->astTargetDsxBuffer[ulTargetDsxBufferIndexToUse].valid != 1))
 	{
 		 ulTargetDsxBufferIndexToUse = (ulTargetDsxBufferIndexToUse+1)%
 					Adapter->ulTotalTargetBuffersAvailable;
 		 ulMaxTry--;
+		 if (_cur < timeout) {
--
 	while(u32NumofSFsinMsg != 0 && u32NumofSFsinMsg < NO_OF_QUEUES)
 	{
 		u32NumofSFsinMsg--;
@@ -2350,6 +2377,12 @@ VOID OverrideServiceFlowParams(PMINI_ADA
 				Adapter->PackInfo[uiSearchRuleIndex].bActive=TRUE;
 			}
--
 	while (pkt) {
 		npkt = pkt->next;
 		kfree_skb(pkt);
 		pkt = npkt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(RxDescCount)
 	{
 		pRcb = GetBulkInRcb(psIntfAdapter);
@@ -258,7 +263,13 @@ BOOLEAN InterfaceRx (PS_INTERFACE_ADAPTE
 		//atomic_inc(&psIntfAdapter->uNumRcbUsed);
 		ReceiveRcb(psIntfAdapter, pRcb);
--
-	while (psIntfAdapter->psAdapter->DeviceAccess) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (psIntfAdapter->psAdapter->DeviceAccess) {
 		BCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,
 			"Device is being accessed.\n");
 		msleep(100);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while(1)
 	{
 		wait_event_interruptible(Adapter->process_rx_cntrlpkt,
@@ -178,6 +183,11 @@ int control_packet_handler  (PMINI_ADAPT
 			continue;
 		}
--
 		while(atomic_read(&Adapter->cntrlpktCnt))
 		{
 			spin_lock_irqsave(&Adapter->control_queue_lock, flags);
@@ -191,9 +201,21 @@ int control_packet_handler  (PMINI_ADAPT
 			spin_unlock_irqrestore (&Adapter->control_queue_lock, flags);
 		 	handle_rx_control_packet(Adapter, ctrl_packet);
--
 		while(pTarang->RxAppControlHead != NULL)
 		{
 			PacketToDrop=pTarang->RxAppControlHead;
 			DEQUEUEPACKET(pTarang->RxAppControlHead,pTarang->RxAppControlTail);
 			dev_kfree_skb(PacketToDrop);
+			if (_cur < timeout) {
--
 	while(uiBytesRemaining && uiFailureRetries != 128)
 	{
 		if(Adapter->device_removed )
@@ -414,6 +419,12 @@ INT BeceemEEPROMBulkRead(
 			}
 		}
--
 		while(uiTemp)
 		{
 			 if(IsOffsetWritable(Adapter, uiOffsetFromSectStart + index * Adapter->uiSectorSize ) == FALSE)
@@ -1207,6 +1223,12 @@ static INT BeceemFlashBulkWrite(
 			 }
 			 uiTemp = uiTemp - 1;
--
 		while(uiTemp)
 		{
 			 if(IsOffsetWritable(Adapter,uiOffsetFromSectStart + index * Adapter->uiSectorSize ) == FALSE)
@@ -1421,10 +1448,21 @@ static INT BeceemFlashBulkWriteStatus(
 			 }
 			 uiTemp = uiTemp - 1;
--
 	while(uiNumSectTobeRead)
 	{
 		uiPartOffset = (uiSectAlignAddr & (FLASH_PART_SIZE - 1)) + GetFlashBaseAddr(Adapter);
@@ -1505,7 +1543,13 @@ static INT BeceemFlashBulkWriteStatus(
 		uiSectBoundary += Adapter->uiSectorSize;
 		uiOffsetFromSectStart += Adapter->uiSectorSize;
--
 	while(uiNumBytes)
 	{
 		if(Adapter->device_removed )
@@ -1757,6 +1806,12 @@ static INT BeceemEEPROMReadBackandVerify
 			uiNumBytes = 0;
 		}
--
 	while ( ( uiStatus & EEPROM_WRITE_QUEUE_EMPTY ) == 0 )
 	{
 		uiRetries--;
@@ -1862,6 +1922,12 @@ static INT BeceemEEPROMWritePage( PMINI_
 			return -ENODEV;
 		}
--
 	while ( uiRetries != 0 )
 	{
 		uiEpromStatus = ReadEEPROMStatusRegister( Adapter) ;
@@ -1900,6 +1971,12 @@ static INT BeceemEEPROMWritePage( PMINI_
 		uiEpromStatus = 0;
 		if( !(uiRetries%RETRIES_PER_DELAY) )
--
 	while(uiBytesToCopy)
 	{
 		if(Adapter->device_removed)
@@ -2003,6 +2085,12 @@ INT BeceemEEPROMBulkWrite(
 			uiBytesToCopy = 0;
 		}
--
 			while(uiNumBytes)
 			{
 				if(uiNumBytes > BUFFER_4K)
@@ -2156,6 +2249,12 @@ INT BeceemNVMWrite(
 					uiNumBytes = 0;
 					break;
--
 				while(uiNumBytes)
 				{
 					if(uiNumBytes > BUFFER_4K)
@@ -2181,6 +2285,12 @@ INT BeceemNVMWrite(
 						uiNumBytes = 0;
 						break;
--
 	while(i < TOTAL_SECTIONS)
 	{
 		if(!(Adapter->psFlash2xVendorInfo->VendorSection[i].AccessFlags & FLASH2X_SECTION_PRESENT))
@@ -2786,6 +2901,12 @@ static VOID UpdateVendorInfo(PMINI_ADAPT
 			break;
 		}
--
 			while (len) {
 				if (*(unsigned int *)&buff_readback[len] != *(unsigned int *)&buff[len]) {
 					BCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Firmware Download is not proper %d", fw_down);
@@ -119,6 +124,12 @@ int InterfaceFileReadbackFromChip(PVOID
 					goto exit;
 				}
--
 	while((phss > 0) && (size < in_buf_len))
 	{
 		bit =  ((*phsm << i)& SUPPRESS);
@@ -1463,6 +1468,12 @@ int phs_decompress(unsigned char *in_buf
 			i=0;
 			phsm++;
--
 	while(phss > 0)
 	{
 		bit = ((*phsm << i)& SUPPRESS);
@@ -1598,6 +1614,12 @@ static int verify_suppress_phsf(unsigned
 			i=0;
 			phsm++;
--
 	while (atomic_read(&Adapter->ApplicationRunning)) {
 		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Waiting for Application to close.. %d\n", atomic_read(&Adapter->ApplicationRunning));
 		msleep(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (Adapter->PackInfo[iQIndex].FirstTxQueue && atomic_read(&Adapter->TotalPacketCount)) {
 		PacketToDrop = Adapter->PackInfo[iQIndex].FirstTxQueue;
 		if (PacketToDrop && PacketToDrop->len) {
@@ -1614,6 +1630,12 @@ void flush_queue(PMINI_ADAPTER Adapter,
 			dev_kfree_skb(PacketToDrop);
 			atomic_dec(&Adapter->TotalPacketCount);
--
-	while (curr_table_data_size < table_data_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (curr_table_data_size < table_data_size) {
 		/* Update the number of entries in table */
 		(*num_table_entries_ptr)++;
 
@@ -1291,6 +1296,12 @@ static void sep_build_lli_table(struct s
 
--
-	while ((unsigned long) lli_table_ptr->bus_address != 0xffffffff) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((unsigned long) lli_table_ptr->bus_address != 0xffffffff) {
 		dev_dbg(&sep->pdev->dev,
 			"lli table %08lx, table_data_size is %lu\n",
 			table_count, table_data_size);
@@ -1408,6 +1424,12 @@ static void sep_debug_print_lli_tables(s
 				(unsigned long)lli_table_ptr->bus_address);
--
-	while (current_entry < sep_lli_entries) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (current_entry < sep_lli_entries) {
 
 		/* Set the new input and output tables */
 		in_lli_table_ptr =
@@ -1614,6 +1641,12 @@ static int sep_prepare_input_dma_table(s
 		}
--
-	while (current_in_entry < sep_in_lli_entries) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (current_in_entry < sep_in_lli_entries) {
 		/* Set the new input and output tables */
 		in_lli_table_ptr =
 			(struct sep_lli_entry *)lli_table_alloc_addr;
@@ -1855,6 +1893,12 @@ static int sep_construct_dma_tables_from
 		dev_dbg(&sep->pdev->dev,
--
 		while (true) {
 			spin_lock_irqsave(&priv->rf_ps_lock, flag);
 			if (priv->RFChangeInProgress) {
@@ -342,7 +347,12 @@ bool MgntActSet_RF_State(struct net_devi
 					 "progress! Wait to set..StateToSet"
 					 "(%d).\n", StateToSet);
--
-				while (priv->RFChangeInProgress) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (priv->RFChangeInProgress) {
 					RFWaitCounter++;
 					RT_TRACE((COMP_PS | COMP_RF),
 						 "MgntActSet_RF_State(): Wait 1"
@@ -356,13 +366,25 @@ bool MgntActSet_RF_State(struct net_devi
 							 "logn to set RF\n");
--
 	while (skb_queue_len(&ring->queue)) {
 		struct tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb = __skb_dequeue(&ring->queue);
@@ -1854,6 +1881,12 @@ static void rtl8192_free_tx_ring(struct
 			skb->len, PCI_DMA_TODEVICE);
 		kfree_skb(skb);
--
 	while (skb_queue_len(&ring->queue)) {
 		struct tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb;
@@ -1965,6 +2003,12 @@ static void rtl8192_tx_isr(struct net_de
 		skb->len, PCI_DMA_TODEVICE);
 
--
-			while (skb_queue_len(&ring->queue)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (skb_queue_len(&ring->queue)) {
 				struct tx_desc *entry = &ring->desc[ring->idx];
 				struct sk_buff *skb =
 						 __skb_dequeue(&ring->queue);
@@ -2210,6 +2259,12 @@ void rtl8192_pci_resetdescring(struct ne
 						 skb->len, PCI_DMA_TODEVICE);
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count--) {
 		struct rx_desc *pdesc = &priv->rx_ring[rx_queue_idx]
 					[priv->rx_idx[rx_queue_idx]];
 		struct sk_buff *skb = priv->rx_buf[rx_queue_idx]
@@ -2412,6 +2472,12 @@ done:
 			pdesc->EOR = 1;
--
 		while ((!skb_queue_empty(&ieee->skb_waitQ[queue_index])) &&
 		(priv->rtllib->check_nic_enough_desc(dev, queue_index) > 0)) {
 			skb = skb_dequeue(&ieee->skb_waitQ[queue_index]);
 			ieee->softmac_data_hard_start_xmit(skb, dev, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 			while ((i--) >= 0) {
 				ulStatus = read_nic_dword(dev, RWCAM);
 				if (ulStatus & BIT31)
 					continue;
 				else
 					break;
--
 			while ((i--) >= 0) {
 				ulStatus = read_nic_dword(dev, RWCAM);
 				if (ulStatus & BIT31)
 					continue;
 				else
 					break;
--
 			while ((i--) >= 0) {
 				ulStatus = read_nic_dword(dev, RWCAM);
 				if (ulStatus & BIT31)
 					continue;
 				else
 					break;
--
 	while (pList->next != &pTS->RxPendingPktList) {
 		if (SN_LESS(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)
 		    list_entry(pList->next, struct rx_reorder_entry,
@@ -458,6 +463,12 @@ static bool AddReorderEntry(struct rx_ts
 				return false;
 		else
--
 		while ((i--) >= 0) {
 			ulStatus = read_nic_dword(dev, RWCAM);
 			if (ulStatus & BIT31)
 				continue;
 			else
 				break;
--
-	while (total_length > 0 || exe_cnt++ > 100) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (total_length > 0 || exe_cnt++ > 100) {
 		element_id = pcmd_buff[0];
 
 		switch (element_id) {
@@ -413,6 +418,12 @@ u32 cmpk_message_handle_rx(struct net_de
 
--
 	while (read_nic_dword(dev, QPNR)&0x80000000) {
 		if (time++ < 100)
 			udelay(10);
 		else
 			break;
+			if (_cur < timeout) {
--
 	while (read_nic_dword(dev, QPNR) & 0x80000000) {
 		if (time++ < 100)
 			udelay(10);
 		else
 			return 0;
+			if (_cur < timeout) {
--
 	while (read_nic_dword(dev, QPNR) & 0x80000000) {
 		if (time++ < 100)
 			udelay(10);
 		else
 			break;
+			if (_cur < timeout) {
--
-			while (RF3_Final_Value != RegValueToBeCheck &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (RF3_Final_Value != RegValueToBeCheck &&
 			       RetryTimes != 0) {
 				ret = rtl8192_phy_ConfigRFWithHeaderFile(dev,
 						(enum rf90_radio_path)eRFPath);
@@ -162,10 +167,21 @@ bool phy_RF8256_Config_ParaFile(struct n
 					 "value: %x\n", eRFPath,
--
-			while (RF3_Final_Value != RegValueToBeCheck &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (RF3_Final_Value != RegValueToBeCheck &&
 			       RetryTimes != 0) {
 				ret = rtl8192_phy_ConfigRFWithHeaderFile(dev,
 						(enum rf90_radio_path)eRFPath);
@@ -177,10 +193,21 @@ bool phy_RF8256_Config_ParaFile(struct n
 					 "value: %x\n", eRFPath,
--
-			while (RF3_Final_Value != RegValueToBeCheck &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (RF3_Final_Value != RegValueToBeCheck &&
 			       RetryTimes != 0) {
 				ret = rtl8192_phy_ConfigRFWithHeaderFile(dev,
 						(enum rf90_radio_path)eRFPath);
@@ -192,10 +219,21 @@ bool phy_RF8256_Config_ParaFile(struct n
 					 "value: %x\n", eRFPath,
--
-			while (RF3_Final_Value != RegValueToBeCheck &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (RF3_Final_Value != RegValueToBeCheck &&
 			       RetryTimes != 0) {
 				ret = rtl8192_phy_ConfigRFWithHeaderFile(dev,
 					       (enum rf90_radio_path)eRFPath);
@@ -206,6 +244,12 @@ bool phy_RF8256_Config_ParaFile(struct n
 					 "value: %x\n", eRFPath,
--
 		while (!list_empty(&pRxTs->RxPendingPktList)) {
 			pReorderEntry = (struct rx_reorder_entry *)
 					list_entry(pRxTs->RxPendingPktList.prev,
@@ -71,6 +76,12 @@ static void RxPktPendingTimeout(unsigned
 				bPktInBuf = true;
 				break;
--
-		while (!list_empty(&pRxTS->RxPendingPktList)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!list_empty(&pRxTS->RxPendingPktList)) {
 			pRxReorderEntry = (struct rx_reorder_entry *)
 					list_entry(pRxTS->RxPendingPktList.prev,
 					struct rx_reorder_entry, List);
@@ -452,6 +468,12 @@ static void RemoveTsEntry(struct rtllib_
 			}
--
 	while (1) {
 		do {
 			ch++;
@@ -576,6 +581,12 @@ void rtllib_softmac_scan_syncro(struct r
 		 * need to wait for a syncro scan to end..
 		 */
--
 		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))) {
 
 			header = (struct rtllib_hdr_3addr  *) skb->data;
@@ -2568,6 +2584,12 @@ void rtllib_wake_queue(struct rtllib_dev
 
 			ieee->softmac_data_hard_start_xmit(skb, ieee->dev,
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 
 		if (!*this_opt)
@@ -1930,6 +1935,12 @@ static int __init XGIfb_setup(char *opti
 		} else {
 			mode = this_opt;
--
-		 while(pDevice->rxManeQueue.packet_num != 0)
+		 unsigned long long delta = (cpu / khz / HZ) * 2;
+		 unsigned long long _start = 0;
+		 unsigned long long _cur = 0;
+	 	unsigned long long timeout;
+	 	timeout = rdstcll(start) + delta;
+	 	while(pDevice->rxManeQueue.packet_num != 0)
 	 	{
 			 pRxMgmtPacket =  DeQueue(pDevice);
         			//pDevice;
@@ -1870,6 +1875,12 @@ int MlmeThread(
 			vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
--
     while(--length >= 0) {
         unsigned char current_octet = *data++;
         int bit;
@@ -2971,6 +2987,12 @@ static inline u32 ether_crc(int length,
             crc = (crc << 1) ^
                 ((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);
--
     while( ((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len) ){
 
         switch (pItem->byElementID) {
@@ -224,6 +229,12 @@ vMgrDecodeBeacon(
 
         }
--
     while (((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len)) {
         switch (pItem->byElementID){
             case WLAN_EID_SSID:
@@ -419,6 +435,12 @@ vMgrDecodeAssocRequest(
                 break;
         }
--
     while(((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID){
@@ -599,6 +626,12 @@ vMgrDecodeReassocRequest(
                 break;
         }
--
     while( ((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len) ) {
 
         switch (pItem->byElementID) {
@@ -674,6 +712,12 @@ vMgrDecodeProbeRequest(
         }
 
--
     while( ((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len) ) {
         switch (pItem->byElementID) {
             case WLAN_EID_SSID:
@@ -823,6 +872,12 @@ vMgrDecodeProbeResponse(
         }
 
--
                 while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[0].sTxPSQueue)) != NULL) {
                     if (skb_queue_empty(&pMgmt->sNodeDBTable[0].sTxPSQueue)) {
                         pMgmt->abyPSTxMap[0] &= ~byMask[0];
@@ -813,6 +818,12 @@ printk("chester-abyDesireSSID=%s\n",((PW
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Multicast ps tx fail \n");
                     }
--
     while (*pvNextBSS == NULL) {
         pBSS++;
         if (pBSS > &(pMgmt->sBSSList[MAX_BSS_NUM])) {
@@ -471,6 +476,12 @@ VNTWIFIvGetNextBSS (
             *pvNextBSS = pBSS;
             return;
--
     while (nBytes > 0)
     {
         s_vAppendByte(*src++);
         nBytes--;
+        if (_cur < timeout) {
+            rdstcll(_cur);
--
     while( nBytesInM != 0 )
     {
         s_vAppendByte(0);
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
--
     while (cbByte--) {
         dwCrc = s_adwCrc32Table[(unsigned char)((dwCrc ^ (*pbyData)) & 0xFF)] ^ (dwCrc >> 8);
         pbyData++;
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
--
     while (ui > RATE_1M) {
         if (pDevice->wBasicRate & ((unsigned short)1 << ui)) {
             return (unsigned short)ui;
         }
         ui --;
+        if (_cur < timeout) {
--
     while (ui > RATE_11M) {
         if (pDevice->wBasicRate & ((unsigned short)1 << ui)) {
             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CARDwGetOFDMControlRate : %d\n", ui);
             return (unsigned short)ui;
         }
         ui --;
--
 	 while(pDevice->rxManeQueue.packet_num != 0)
 	 {
 		 pRxMgmtPacket =  DeQueue(pDevice);
         		vMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);
+        		if (_cur < timeout) {
+        			rdstcll(_cur);
--
                 while ((skb = skb_dequeue(&pMgmt->sNodeDBTable[ii].sTxPSQueue)) != NULL){
                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "PS skb != NULL %d\n", ii);
                         dev_kfree_skb(skb);
+                        if (_cur < timeout) {
+                            rdstcll(_cur);
+                        }
--
-		while (cnt < buflen && *index < scsi_sg_count(srb)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (cnt < buflen && *index < scsi_sg_count(srb)) {
 			struct page *page = sg_page(sg) +
 					((sg->offset + *offset) >> PAGE_SHIFT);
 			unsigned int poff =
@@ -103,7 +108,12 @@ unsigned int rtsx_stor_access_xfer_buf(u
 			/* Transfer the data for all the pages in this
--
-			while (sglen > 0) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (sglen > 0) {
 				unsigned int plen = min(sglen, (unsigned int)
 						PAGE_SIZE - poff);
 				unsigned char *ptr = kmap(page);
@@ -119,6 +129,18 @@ unsigned int rtsx_stor_access_xfer_buf(u
 				++page;
--
 	while ((N < min_N) && (div < max_div)) {
 		N = (N + 2) * 2 - 2;
 		div++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (desc_cnt) {
 		if (check_card_ready(chip, lun)) {
 			card_size = get_card_size(chip, lun);
@@ -887,6 +892,12 @@ static int read_format_capacity(struct s
 		buf[i++] = 0x00;
 
--
 	while (len) {
 		u16 pagelen = SF_PAGE_LEN - (u8)addr;
 
@@ -553,6 +558,12 @@ int spi_read_flash(struct scsi_cmnd *srb
 
 		addr += pagelen;
--
 		while (len) {
 			retval = sf_enable_write(chip, SPI_WREN);
 			if (retval != STATUS_SUCCESS) {
@@ -619,6 +635,12 @@ int spi_write_flash(struct scsi_cmnd *sr
 
 			addr++;
--
 		while (len) {
 			rtsx_stor_access_xfer_buf(buf, 1, srb, &index, &offset, FROM_XFER_BUF);
 
@@ -663,6 +690,12 @@ int spi_write_flash(struct scsi_cmnd *sr
 			}
 
--
 		while (len) {
 			u16 pagelen = SF_PAGE_LEN - (u8)addr;
 
@@ -716,6 +754,12 @@ int spi_write_flash(struct scsi_cmnd *sr
 
 			addr += pagelen;
--
-			while (mcaddr) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (mcaddr) {
 				if (!compare_ether_addr(mcaddr->address,
 							ether_frame->ether_dhost)) {
 					adapter->rcv_multicasts++;
@@ -894,6 +899,12 @@ static bool slic_mac_filter(struct adapt
 					return true;
--
 	while ((len -= 32) >= 0) {
 		sum += w[0];
 		sum += w[1];
@@ -1358,14 +1374,31 @@ static ushort slic_eeprom_cksum(char *m,
 		sum += w[14];
 		sum += w[15];
--
 	while ((len -= 8) >= 0) {
 		sum += w[0];
 		sum += w[1];
 		sum += w[2];
 		sum += w[3];
 		w = (u16 *)((ulong) w + 4);	/* verify */
--
 	while (cmd) {
 		if (cmd->busy) {
 			struct sk_buff *tempskb;
@@ -1564,6 +1602,12 @@ static void slic_cmdq_free(struct adapte
 			}
 		}
--
-	while ((cmdcnt < SLIC_CMDQ_CMDSINPAGE) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((cmdcnt < SLIC_CMDQ_CMDSINPAGE) &&
 	       (adapter->slic_handle_ix < 256)) {
 		/* Allocate and initialize a SLIC_HANDLE for this command */
 		SLIC_GET_SLIC_HANDLE(adapter, pslic_handle);
@@ -1622,6 +1671,12 @@ static void slic_cmdq_addcmdpage(struct
 
--
 	while (hcmd) {
 		if (hcmd->busy) {
 			skb = hcmd->skb;
@@ -1688,6 +1748,12 @@ static void slic_cmdq_reset(struct adapt
 			dev_kfree_skb_irq(skb);
 		}
--
 	while (hcmd) {
 		adapter->cmdq_free.count++;
 		hcmd->next = hcmd->next_all;
 		hcmd = hcmd->next_all;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (i < SLIC_RCVQ_FILLENTRIES) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (i < SLIC_RCVQ_FILLENTRIES) {
 		struct slic_rcvbuf *rcvbuf;
 		struct sk_buff *skb;
 #ifdef KLUDGE_FOR_4GB_BOUNDARY
@@ -1860,6 +1942,12 @@ retry_rcvqfill:
 				i);
--
 	while (rcvq->head) {
 		skb = rcvq->head;
 		rcvq->head = rcvq->head->next;
 		dev_kfree_skb(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (i) {
 		count += slic_rcvqueue_fill(adapter);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (mlist) {
 		if (!compare_ether_addr(mlist->address, address))
 			return 0;
 		mlist = mlist->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (mlist) {
 		mcaddr = mlist;
 		mlist = mlist->next;
 		kfree(mcaddr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((next_percent != NULL) && !found) {
 		next_percent = strchr(next_percent, '%');
 		if (next_percent != NULL) {
@@ -421,6 +426,12 @@ static char *next_specifier(char *input)
 			else if (*next_percent == '\0')
 				next_percent = NULL;
--
 	while (still_comparing && valid) {
 		template_ptr = next_specifier(template_ptr);
 		user_ptr = next_specifier(user_ptr);
@@ -523,6 +539,12 @@ static int fmt_validate(char *template,
 			if (template_ptr || user_ptr)
 				valid = 0;
--
 	while (count > 0) {
 		bytes = min(count, sizeof(buf));
 		if (copy_from_user(buf, ptr, bytes))
@@ -33,6 +38,12 @@ static ssize_t speakup_file_write(struct
 		spk_lock(flags);
 		synth_write(buf, bytes);
--
 	while (!kthread_should_stop()) {
 		/* if no ctl-a in 4, send data anyway */
 		spin_lock_irqsave(&flush_lock, flags);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (is_flushing && timeout) {
 			prepare_to_wait(&flush, &wait, TASK_INTERRUPTIBLE);
 			spin_unlock_irqrestore(&flush_lock, flags);
 			timeout = schedule_timeout(timeout);
 			spin_lock_irqsave(&flush_lock, flags);
+			if (_cur < timeout) {
--
-	while ((ch = *buff)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((ch = *buff)) {
 		if (ch == '\n')
 			ch = synth->procspeech;
 		if (wait_for_xmitr())
@@ -144,6 +149,12 @@ const char *spk_synth_immediate(struct s
 		else
--
 	while (*kp++) {
 		/* count occurrences of each function */
 		for (i = 0; i < nstates; i++, kp++) {
@@ -77,6 +82,12 @@ static void build_key_data(void)
 				continue;
 			counters[*kp]++;
--
 	while ((ch = *kp++)) {
 		for (i = 0; i < nstates; i++) {
 			ch1 = *kp++;
@@ -106,6 +122,12 @@ static void build_key_data(void)
 			p_key = key_data + offset + counters[ch1];
 			*p_key = key;
--
 		while ((i < MAXVARS) && (where == NULL)) {
 			if (strcmp(name, var_ptrs[i]->name) == 0)
 				where = var_ptrs[i];
 			else
 				i++;
+				if (_cur < timeout) {
--
 	while ((where->var_id != -1) && (rv == NULL)) {
 		if (where->var_id == var_id)
 			rv = where;
 		else
 			where++;
+			if (_cur < timeout) {
--
 	while (*start >= '0' && *start <= '9') {
 		val *= 10;
 		val += (*start) - '0';
 		start++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (*start && *start <= SPACE)
 		start++;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while (*start >= '0' && *start <= '9') {
 		val *= 10;
 		val += (*start) - '0';
 		start++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((p = strchr(p, '\\'))) {
 		p1 = p+1;
 		p2 = strchr(finds, *p1);
@@ -372,9 +421,20 @@ char *xlate(char *s)
 			p1++;
 		} else if (*p1 >= '0' && *p1 <= '7') {
--
 			while (num < 256 && *p1 >= '0' && *p1 <= '7') {
 				num <<= 3;
 				num = (*p1++)&7;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 		while (*p1)
 			*p2++ = *p1++;
 		*p2 = '\0';
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((ch = *buf)) {
 		if (ch == '\n')
 			ch = PROCSPEECH;
@@ -167,6 +172,12 @@ static const char *synth_immediate(struc
 		outb_p(ch, synth_port);
 		udelay(70);
--
 	while (--timeout > 0) {
 		if ((dt_getstatus() & bit) == bit)
 			return 1;
 		udelay(50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--timeout > 0) {
 		if ((dt_getstatus()&STAT_dma_state) == state)
 			return 1;
 		udelay(50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((ch = *buf)) {
 		if (ch == '\n')
 			ch = PROCSPEECH;
 		if (dt_sendchar(ch))
 			return buf;
 		buf++;
--
 	while ((ch = *buf)) {
 		int timeout = SPK_XMITR_TIMEOUT;
 		if (ch == '\n')
 			ch = PROCSPEECH;
 		if (synth_full())
 			return buf;
--
 		while (synth_writable()) {
 			if (!--timeout)
 				return buf;
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (var->var_id != MAXVARS) {
 		if (var->var_id != CAPS_START && var->var_id != CAPS_STOP
 			&& var->var_id != DIRECT)
 			cp = cp + sprintf(cp, var->u.n.synth_fmt,
 					  var->u.n.value);
 		var++;
--
 	while (chars_sent < count) {
 		if (speakup_info.flushing) {
 			speakup_info.flushing = 0;
@@ -250,6 +266,12 @@ static ssize_t softsynth_read(struct fil
 		spk_lock(flags);
 		chars_sent++;
--
 	while (inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR) {
 
 		c = inb_p(speakup_info.port_tts+UART_RX);
 		synth->read_buff_add((u_char) c);
 /*printk(KERN_ERR "c = %d\n", c); */
 /*pr_warn("C = %d\n", c); */
--
 	while (spk_serial_tx_busy()) {
 		if (--tmout == 0) {
 			pr_warn("%s: timed out (tx busy)\n", synth->long_name);
@@ -152,8 +168,19 @@ int wait_for_xmitr(void)
 			return 0;
 		}
--
 	while (!((inb_p(speakup_info.port_tts + UART_MSR)) & UART_MSR_CTS)) {
 		/* CTS */
 		if (--tmout == 0) {
@@ -163,6 +190,12 @@ int wait_for_xmitr(void)
 			return 0;
 		}
--
 	while (!(inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR)) {
 		if (--tmout == 0) {
 			pr_warn("time out while waiting for input.\n");
 			return 0xff;
 		}
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((ch = (u_char)*buf)) {
 		if (synth_full())
 			return buf;
@@ -253,6 +258,12 @@ static const char *synth_immediate(struc
 			ch = PROCSPEECH;
 		spk_out(ch);
--
 	while ((ch = (u_char) *cp)) {
 		if (cp != buf)
 			synth_printf(" %s ", delay_str[spell_delay]);
@@ -719,6 +724,12 @@ static void spell_word(struct vc_data *v
 		}
 		synth_printf("%s", cp1);
--
 	while (start <= end) {
 		from = start + (win_left * 2);
 		to = start + (win_right * 2);
 		say_from_to(vc, from, to, 1);
 		start += vc->vc_size_row;
+		if (_cur < timeout) {
--
 	while (count--) {
 		if (cursor_track == read_all_mode) {
 			/* Insert Sentence Index */
@@ -1106,6 +1133,12 @@ static void spkup_write(const char *in_b
 		}
 		old_ch = ch;
--
 	while ((ch = *cp1)) {
 		if (ch >= MAX_KEY)
 			return -4;
 		our_keys[ch] = cp1;
 		cp1 += states + 1;
+		if (_cur < timeout) {
--
 	while ((hi < COLOR_BUFFER_SIZE) && (i < len)) {
 		if ((ic[i] > 32) && (ic[i] < 127)) {
 			speakup_console[vc_num]->ht.highbuf[bi][hi] = ic[i];
@@ -1524,6 +1573,12 @@ static void update_color_buffer(struct v
 			}
 		}
--
 	while (len > 0) {
 		i = len > 64 ? 64 : len;
 		saa_writeb(SAA7134_GPIO_GPMODE0, 0xff);
 		saa_writeb(SAA7134_GPIO_GPSTATUS0, HPI_ADDR_INIT_BUFFER);
 		saa_writeb(SAA7134_GPIO_GPSTATUS2, GPIO_COMMAND_ADDR);
 		saa_writeb(SAA7134_GPIO_GPSTATUS2, GPIO_COMMAND_IDLE);
--
 		while (i-- > 0) {
 			saa_writeb(SAA7134_GPIO_GPSTATUS0, *data);
 			saa_writeb(SAA7134_GPIO_GPSTATUS2, GPIO_COMMAND_WRITE);
 			saa_writeb(SAA7134_GPIO_GPSTATUS2, GPIO_COMMAND_IDLE);
 			++data;
 			--len;
--
 	while (name.b <= 24) { \
 		*name.p = name.a >> 24; \
 		++name.p; \
 		name.a <<= 8; \
 		name.b += 8; \
 		name.len += 8; \
--
 } while (0)
 
@@ -1283,10 +1294,21 @@ static int relative_prime(int big, int l
 {
 	int remainder;
 
--
 	while (little != 0) {
 		remainder = big % little;
 		big = little;
 		little = remainder;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (srclen >= 2) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (srclen >= 2) {
 		chunk_flags = __le16_to_cpu(src[0]);
 		chunk_len = __le16_to_cpu(src[1]);
 		if (chunk_len + 2 > srclen) {
@@ -1623,6 +1650,12 @@ int go7007_construct_fw_image(struct go7
 		}
--
-	while (count-- > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (count-- > 0) {
 		if (go7007_read_interrupt(go, &value, data) == 0 &&
 				value == 0xa000)
 			return 0;
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (usecs > MAX_UDELAY_US) {
 		udelay(MAX_UDELAY_US);
 		usecs -= MAX_UDELAY_US;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (status & UTSR0_EIF) {
 		int bstat;
 
@@ -583,6 +599,12 @@ static irqreturn_t sir_interrupt(int irq
 		bstat = Ser2UTDR;
 		n++;
--
 	while ((iir = inb(io + UART_IIR) & UART_IIR_ID)) {
 		switch (iir&UART_IIR_ID) { /* FIXME toto treba preriedit */
 		case UART_IIR_MSI:
@@ -695,6 +722,12 @@ static irqreturn_t sir_interrupt(int irq
 		default:
 			break;
--
-	while (bytes_out--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (bytes_out--) {
 		outb(PULSE, io + UART_TX);
 		/* FIXME treba seriozne cakanie z char/serial.c */
 		while (!(inb(io + UART_LSR) & UART_LSR_THRE))
 			;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (usecs > MAX_UDELAY_US) {
 		udelay(MAX_UDELAY_US);
 		usecs -= MAX_UDELAY_US;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((now - start) < length) {
 		/* Delay till flip time */
 		do {
@@ -516,6 +532,12 @@ static long send_pulse_homebrew_softcarr
 			target += pulse_width;
 		}
--
 	while (actual < length) {
 		if (flag) {
 			off();
@@ -555,6 +582,12 @@ static long send_pulse_homebrew_softcarr
 		udelay(d);
 		actual += (d << 8) + LIRC_SERIAL_TRANSMITTER_LATENCY;
--
-	while (i < max) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < max) {
 		/* 1 Igor-tick = 85.333333 us */
 		code = (unsigned int)ir->buf_in[i] * 85 +
 			(unsigned int)ir->buf_in[i] / 3;
@@ -293,6 +298,12 @@ static void send_fragment(struct igorplu
 		/* 1 chunk = CODE_LENGTH bytes */
--
 			while (line_len > 0) {
 				int this_write;
 
@@ -318,6 +323,12 @@ static void solo_fillbuf(struct solo_fil
 				sg_size_left -= this_write;
 				sg_dma += this_write;
--
 	while (count--) {
 		**out <<= 1;
 		**out |= !!(value & (1 << 31)); /* MSB */
 		value <<= 1;
 		if (++(*bits) % 8 == 0)
 			(*out)++;
--
 	while (value > max) {
 		max = (max + 2) * 2 - 2;
 		cnt++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (solo_dev->enc_idx != cur_q) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (solo_dev->enc_idx != cur_q) {
 		mpeg_current = solo_reg_read(solo_dev,
 					SOLO_VE_MPEG4_QUE(solo_dev->enc_idx));
 		jpeg_current = solo_reg_read(solo_dev,
@@ -895,6 +922,12 @@ void solo_enc_v4l2_isr(struct solo_dev *
 					SOLO_NR_RING_BUFS;
--
 	while (!list_empty(&pd->dmaq)) {
 		vb = list_first_entry(&pd->dmaq, typeof(*vb), done_entry);
 		list_del(&vb->done_entry);
 		vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (0xFFFFFFFF != easycap_control[i1].id) {
 		if (V4L2_CID_BRIGHTNESS == easycap_control[i1].id) {
 			if ((easycap_control[i1].minimum > value) ||
@@ -679,6 +684,12 @@ int adjust_brightness(struct easycap *pe
 			break;
 		}
--
 	while (0xFFFFFFFF != easycap_control[i1].id) {
 		if (V4L2_CID_CONTRAST == easycap_control[i1].id) {
 			if ((easycap_control[i1].minimum > value) ||
@@ -737,6 +753,12 @@ int adjust_contrast(struct easycap *peas
 			break;
 		}
--
 	while (0xFFFFFFFF != easycap_control[i1].id) {
 		if (V4L2_CID_SATURATION == easycap_control[i1].id) {
 			if ((easycap_control[i1].minimum > value) ||
@@ -795,6 +822,12 @@ int adjust_saturation(struct easycap *pe
 			break;
 		}
--
 	while (0xFFFFFFFF != easycap_control[i1].id) {
 		if (V4L2_CID_HUE == easycap_control[i1].id) {
 			if ((easycap_control[i1].minimum > value) ||
@@ -849,6 +887,12 @@ int adjust_hue(struct easycap *peasycap,
 			break;
 		}
--
 	while (0xFFFFFFFF != easycap_control[i1].id) {
 		if (V4L2_CID_AUDIO_VOLUME == easycap_control[i1].id) {
 			if ((easycap_control[i1].minimum > value) ||
@@ -896,6 +945,12 @@ int adjust_volume(struct easycap *peasyc
 			break;
 		}
--
 	while (0xFFFFFFFF != easycap_control[i1].id) {
 		if (V4L2_CID_AUDIO_MUTE == easycap_control[i1].id) {
 			peasycap->mute = value;
@@ -945,6 +1005,12 @@ static int adjust_mute(struct easycap *p
 			break;
 		}
--
 		while (*p2) {
 			p1 = p2;
 			while (*p2 && ('.' != *p2))
@@ -1050,6 +1121,12 @@ long easycap_unlocked_ioctl(struct file
 				k[i] = (int)lng;
 			}
 			i++;
+			if (_cur < timeout) {
--
 			while (p1 < &bfbar[barwidth]) {
 				*p1++ = uyvy[0] ;
 				*p1++ = uyvy[1] ;
 				*p1++ = uyvy[2] ;
 				*p1++ = uyvy[3] ;
 				total += 4;
--
 			while (more) {
 				if ((FIELD_BUFFER_SIZE/PAGE_SIZE) <= m) {
 					SAM("ERROR:  bad m reached\n");
@@ -148,6 +164,12 @@ easycap_testcard(struct easycap *peasyca
 					m++;
 					n = 0;
--
 		while (more) {
 			much = dma_bytes - peasycap->dma_fill;
 			if (0 > much) {
@@ -249,6 +254,12 @@ easycap_alsa_complete(struct urb *purb)
 					snd_pcm_period_elapsed(pss);
 				}
--
 			while (elem) {
 				callback(&elem->data, user_data);
 				elem = elem->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-	while ((nip -= 1) >= 0) {	/* for each packet */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nip -= 1) >= 0) {	/* for each packet */
 		/* get the fixed header bits */
 		if (dlthis->strm->read_buffer(dlthis->strm, &ipacket,
 					      IPH_SIZE) != IPH_SIZE) {
@@ -360,6 +365,12 @@ int dload_get_section(void *minfo,
 
--
 	while (shift <= fieldsz) {
 		dp += direction;
 		objval += (rvalue) *dp << shift;
 		shift += TGTAU_BITS;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (mask) {
 		dp += direction;
 		*dp = (*dp & ~mask) + objval;
 		objval >>= TGTAU_BITS;
 		mask >>= TGTAU_BITS;
+		if (_cur < timeout) {
--
 	while (rop_map1[rx] != rp->TYPE) {
 		rx = HASH_L(rop_map2[rx]);
 		if (rx < 0) {
@@ -210,6 +237,12 @@ void dload_relocate(struct dload_state *
 #endif
 			return;
--
 		while (cur_string != NULL) {
 			/*  Move the head/tail pointers */
 			dlthis->tramp.string_head = cur_string->next;
@@ -253,6 +258,12 @@ static int priv_string_tbl_finalize(stru
 
 			/*  Move our pointer to the next one */
--
 		while (cur_sym != NULL) {
 			/*  Pop it off the list */
 			dlthis->tramp.symbol_head = cur_sym->next;
@@ -433,6 +449,12 @@ static int priv_tramp_sym_finalize(struc
 			/*  Move to the next node */
 			cur_sym = dlthis->tramp.symbol_head;
--
 	while ((ret_val != 0) && (cur_pkt != NULL)) {
 		/*  Remove the pkt from the list */
 		dlthis->tramp.tramp_pkts = cur_pkt->next;
@@ -613,6 +640,12 @@ static int priv_tramp_pkt_finalize(struc
 			/*  Get the next packet to process */
 			cur_pkt = dlthis->tramp.tramp_pkts;
--
 	while ((ret_val != 0) && (cur_pkt != NULL)) {
 		/*  Remove the node from the list, we'll be freeing it
 		 * shortly */
@@ -683,13 +721,24 @@ static int priv_dup_pkt_finalize(struct
 			}
 
--
-			while (i > 0) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (i > 0) {
 				dlthis->mysym->dload_deallocate(dlthis->mysym,
 						GET_CONTAINER
 						(relos[i - 1],
 						 struct tramp_img_dup_relo,
 						 relo));
--
 	while (*name) {
 		hash <<= 1;
 		hash ^= *name++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while ((token = strsep(&psz_cur, ":")) && *token != '\0') {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((token = strsep(&psz_cur, ":")) && *token != '\0') {
 		strncpy(sz_sec_last_token, sz_last_token,
 			strlen(sz_last_token) + 1);
 		strncpy(sz_last_token, token, strlen(token) + 1);
 		token = strsep(&psz_cur, ":");
 		count++;	/* optimizes processing */
--
 		while (i < chunk->region_size) {
 			if (chunk[i].mapped) {
 				/* Remove mapping from the page tables. */
@@ -384,6 +389,12 @@ int dmm_un_reserve_memory(struct dmm_obj
 				i += chunk_size;
 			} else
--
-	while (total_bytes > 0 && !status) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (total_bytes > 0 && !status) {
 		copy_bytes =
 		    total_bytes > BUFFERSIZE ? BUFFERSIZE : total_bytes;
 		/* Read from External memory */
@@ -1087,6 +1092,12 @@ static int bridge_brd_mem_copy(struct br
 		total_bytes -= copy_bytes;
--
-	while (ul_remain_bytes > 0 && !status) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ul_remain_bytes > 0 && !status) {
 		ul_bytes =
 		    ul_remain_bytes > BUFFERSIZE ? BUFFERSIZE : ul_remain_bytes;
 		if (dsp_addr < (dev_context->dsp_start_add +
@@ -1117,6 +1133,12 @@ static int bridge_brd_mem_write(struct b
 		ul_remain_bytes -= ul_bytes;
--
 	while ((vma) && (ul_mpu_addr + ul_num_bytes > vma->vm_end)) {
 		/* jump to the next VMA region */
 		vma = find_vma(mm, vma->vm_end + 1);
@@ -1240,6 +1267,12 @@ static int bridge_brd_mem_map(struct bri
 			"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n", ul_mpu_addr,
 			ul_num_bytes, vma->vm_start, vma->vm_end,
--
 	while (rem_bytes && !status) {
 		u32 va_curr_orig = va_curr;
 		/* Find whether the L1 PTE points to a valid L2 PT */
@@ -1439,6 +1477,11 @@ static int bridge_brd_mem_un_map(struct
 			else
 				numof4k_pages = 1;
--
 			while (temp++ < numof4k_pages) {
 				if (!pfn_valid(__phys_to_pfn(paddr))) {
 					paddr += HW_PAGE_SIZE4KB;
@@ -1455,6 +1498,12 @@ static int bridge_brd_mem_un_map(struct
 					page_cache_release(pg);
 				}
--
 		while (temp++ < numof4k_pages) {
 			if (pfn_valid(__phys_to_pfn(paddr))) {
 				pg = PHYS_TO_PAGE(paddr);
@@ -1518,6 +1572,12 @@ skip_coarse_page:
 				}
 			}
--
 	while (num_bytes && !status) {
 		/* To find the max. page size with which both PA & VA are
 		 * aligned */
@@ -1610,6 +1681,12 @@ static int pte_update(struct bridge_dev_
 				break;
 			}
--
-		while (++i < num_pages) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (++i < num_pages) {
 			page[0] =
 			    vmalloc_to_page((void *)(va_curr + size_curr));
 			pa_next = page_to_phys(page[0]);
@@ -1761,6 +1843,12 @@ static int mem_map_vmalloc(struct bridge
 			else
--
 		while (temp++ < num_of4k_pages) {
 			get_page(PHYS_TO_PAGE(pa));
 			pa += HW_PAGE_SIZE4KB;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (io_msg_pend) {
 		/* Unblock thread */
 		sync_set_event(msg_queue_obj->sync_done);
 		/* Wait for acknowledgement */
 		sync_wait_on_event(msg_queue_obj->sync_done_ack, SYNC_INFINITE);
 		io_msg_pend = msg_queue_obj->io_msg_pend;
--
-	while (num_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_bytes) {
 		/*
 		 * To find the max. page size with which both PA & VA are
 		 * aligned.
@@ -501,6 +506,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 				break;
--
-	while (num_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_bytes) {
 		/*
 		 * To find the max. page size with which both PA & VA are
 		 * aligned.
@@ -573,6 +589,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 			 */
--
-	while (l4_peripheral_table[i].phys_addr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l4_peripheral_table[i].phys_addr) {
 		status = hio_mgr->intf_fxns->brd_mem_map
 		    (hio_mgr->bridge_context, l4_peripheral_table[i].phys_addr,
 		     l4_peripheral_table[i].dsp_virt_addr, HW_PAGE_SIZE4KB,
@@ -644,6 +671,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 		if (status)
--
-	while (true) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (true) {
 		/* Get the DSP current pointer */
 		ul_gpp_cur_pointer =
 		    *(u32 *) (hio_mgr->trace_buffer_current);
@@ -1740,6 +1778,12 @@ void print_dsp_debug_trace(struct io_mgr
 			/* Print the trace messages */
--
-			while (str_beg < buf_end) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (str_beg < buf_end) {
 				new_line = strnchr(str_beg, ul_num_bytes,
 								'\n');
 				if (new_line && new_line < buf_end) {
@@ -1877,6 +1926,12 @@ int print_dsp_trace_buffer(struct bridge
 					str_beg = buf_end;
--
 			while (str_beg < trace_end) {
 				new_line = strnchr(str_beg, ul_num_bytes, '\n');
 				if (new_line != NULL && new_line < trace_end) {
@@ -1905,6 +1965,12 @@ int print_dsp_trace_buffer(struct bridge
 					str_beg = trace_end;
 					ul_num_bytes = 0;
--
-			while (!list_empty(&pchnl->io_requests) && !status) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&pchnl->io_requests) && !status) {
 				status = bridge_chnl_get_ioc(chnl_obj,
 						timeout, &chnl_ioc_obj);
 				if (status)
@@ -484,6 +489,12 @@ int bridge_chnl_flush_io(struct chnl_obj
 				if (chnl_ioc_obj.status & CHNL_IOCSTATTIMEOUT)
--
 	while ((pwr_state != PWRDM_POWER_OFF) && --timeout) {
 		if (msleep_interruptible(10)) {
 			pr_err("Waiting for DSP OFF mode interrupted\n");
@@ -100,6 +105,12 @@ int handle_hibernation_from_dsp(struct b
 		}
 		pwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD,
--
 	while ((pwr_state != target_pwr_state) && --timeout) {
 		if (msleep_interruptible(10)) {
 			pr_err("Waiting for DSP to Suspend interrupted\n");
@@ -210,6 +226,12 @@ int sleep_dsp(struct bridge_dev_context
 		}
 		pwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD,
--
 	while ((token = strsep(&psz_cur, seps)) && *token != '\0') {
 		if (get_uuids) {
 			if (dep_libs >= *num_libs) {
@@ -1502,7 +1507,13 @@ static int get_dep_lib_info(struct dcd_m
 			/* Just counting number of dependent libraries */
 			(*num_libs)++;
--
 	while ((device_node = drv_get_first_dev_extension()) != 0) {
 		(void)dev_remove_device((struct cfg_devnode *)device_node);
 
 		(void)drv_release_resources((u32) device_node,
 					(struct drv_object *)device_context);
+		if (_cur < timeout) {
--
 			while (next) {
 				hptr = next;
 				next = hptr->next;
 				kfree(hptr);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 		while (head != NULL) {
 			max_free_size = max(max_free_size, head->size);
 			total_free_size += head->size;
 			free_blocks++;
 			head = head->next;
+			if (_cur < timeout) {
--
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (ovly_section && i < alloc_num) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ovly_section && i < alloc_num) {
 		/* 'Deallocate' */
 		/* segid - page not supported yet */
 		/* Reserved memory */
@@ -1132,6 +1181,12 @@ static void free_sects(struct nldr_objec
 		DBC_ASSERT(ret);
--
-	while (ovly_section) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ovly_section) {
 		/* allocate *//* page not supported yet */
 		/* reserve *//* align */
 		status = rmm_alloc(nldr_obj->rmm, 0, ovly_section->size, 0,
@@ -1523,13 +1583,24 @@ static int load_ovly(struct nldr_nodeobj
 		} else {
--
-			while (ovly_section) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (ovly_section) {
 				/* page not supported *//* align */
 				/* reserve */
 				status =
@@ -1543,6 +1614,12 @@ static int load_ovly(struct nldr_nodeobj
 				} else {
--
-			while (ovly_section && !status) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (ovly_section && !status) {
 				bytes =
 				    (*nldr_obj->ovly_fxn) (nldr_node_obj->
 							   priv_ref,
@@ -1564,6 +1646,12 @@ static int load_ovly(struct nldr_nodeobj
 					status = -EPERM;
--
-			while (ovly_section && !status) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (ovly_section && !status) {
 				bytes =
 				    (*nldr_obj->ovly_fxn) (nldr_node_obj->
 							   priv_ref,
@@ -1585,6 +1678,12 @@ static int load_ovly(struct nldr_nodeobj
 					status = -EPERM;
--
 	while (len) {
 		page = get_mapping_page(map_obj, pg_i);
 		if (!page) {
@@ -660,6 +665,12 @@ static int build_dma_sg(struct dmm_map_o
 		len -= rest;
 		start += rest;
--
-	while (atomic_read(&net_device->num_outstanding_sends)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&net_device->num_outstanding_sends)) {
 		dev_info(&device->device,
 			"waiting for %d requests to complete...\n",
 			atomic_read(&net_device->num_outstanding_sends));
 		udelay(100);
+		if (_cur < timeout) {
--
 		while (destlen) {
 			src = bounce_addr + bounce_sgl[j].offset;
 			srclen = bounce_sgl[j].length - bounce_sgl[j].offset;
@@ -884,6 +889,12 @@ static unsigned int copy_from_bounce_buf
 				/* unmap the last bounce that is < PAGE_SIZE */
 				kunmap_atomic((void *)bounce_addr, KM_IRQ0);
--
 		while (srclen) {
 			/* assume bounce offset always == 0 */
 			dest = bounce_addr + bounce_sgl[j].length;
@@ -951,6 +967,12 @@ static unsigned int copy_to_bounce_buffe
 				/* unmap the last bounce that is < PAGE_SIZE */
 				kunmap_atomic((void *)bounce_addr, KM_IRQ0);
--
 	while (!list_empty(&nvec->tx_data)) {
 		msg = list_first_entry(&nvec->tx_data, struct nvec_msg, node);
 		spin_unlock_irqrestore(&nvec->tx_lock, flags);
@@ -347,6 +352,12 @@ static void nvec_request_master(struct w
 			list_del_init(&msg->node);
 			nvec_msg_free(nvec, msg);
--
 	while (!list_empty(&nvec->rx_data)) {
 		msg = list_first_entry(&nvec->rx_data, struct nvec_msg, node);
 		list_del_init(&msg->node);
@@ -408,6 +424,12 @@ static void nvec_dispatch(struct work_st
 			nvec_msg_free(nvec, msg);
 		}
--
-	while (loopcnt < MAX_DSP_WAIT_LOOPS) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (loopcnt < MAX_DSP_WAIT_LOOPS) {
 		if (info->AsicID == ELECTRABUZZ_ID) {
 			ft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,
 					 DWNLD_HANDSHAKE_LOC);
@@ -179,6 +184,12 @@ u16 get_handshake(struct net_device *dev
 			mdelay(DSP_WAIT_SLEEP_TIME);
--
 	while ((Status == SUCCESS) && (uiState != STATE_DONE_FILE)) {
 
 		switch (uiState) {
@@ -768,6 +784,12 @@ int card_download(struct net_device *dev
 			break;
 		}		/* End Switch */
--
 	}			/* End while */
 
 	return Status;
diff -u -p a/staging/ft1000/ft1000-pcmcia/ft1000_hw.c b/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
--- a/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
+++ b/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
--
-	while (list_empty(&info->prov_list) == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (list_empty(&info->prov_list) == 0) {
 		DEBUG(0,
 			  "ft1000_hw:ft1000_reset_card:deleting provisioning record\n");
 		ptr = list_entry(info->prov_list.next, struct prov_record, list);
 		list_del(&ptr->list);
 		kfree(ptr->pprov_data);
--
     while (tempword & FT1000_DB_DPRAM_TX) {
         mdelay(10);
         i++;
@@ -812,7 +828,13 @@ static void ft1000_send_cmd (struct net_
             return;
         }
--
-			while (list_empty(&info->prov_list) == 0) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (list_empty(&info->prov_list) == 0) {
 				DEBUG(0, "Sending a provisioning message\n");
 				// Make sure SLOWQ doorbell is clear
 				tempword =
@@ -1036,6 +1063,12 @@ static void ft1000_proc_drvmsg(struct ne
 				list_del(&ptr->list);
--
     while (inttype) {
 	if (inttype & ISR_DOORBELL_PEND) {
 		ft1000_parse_dpram_msg(dev);
@@ -2033,7 +2071,13 @@ static irqreturn_t ft1000_interrupt(int
         // Read interrupt type
         inttype = ft1000_read_reg (dev, FT1000_REG_SUP_ISR);
--
 	while (list_empty(&info->prov_list) == 0) {
 		ptr = list_entry(info->prov_list.next, struct prov_record, list);
 		list_del(&ptr->list);
 		kfree(ptr->pprov_data);
 		kfree(ptr);
+		if (_cur < timeout) {
--
 	while (!kthread_should_stop()) {
 		msleep(10);
 		if (!gPollingfailed) {
@@ -50,6 +55,12 @@ int ft1000_poll_thread(void *arg)
 				gPollingfailed = TRUE;
 			}
--
 	while (!pft1000info->CardReady) {
 		if (gPollingfailed) {
 			ret = -EIO;
@@ -190,6 +206,12 @@ static int ft1000_probe(struct usb_inter
 		}
 		msleep(100);
--
             while (list_empty(&info->app_info[i].app_sqlist) == 0) {
                 pdpram_blk = list_entry(info->app_info[i].app_sqlist.next, struct dpram_blk, list);
                 list_del(&pdpram_blk->list);
                 ft1000_free_buffer(pdpram_blk, &freercvpool);
 
+                if (_cur < timeout) {
--
             while (list_empty(&freercvpool) == 0) {
 		ptr = list_entry(freercvpool.next, struct dpram_blk, list);
                 list_del(&ptr->list);
                 kfree(ptr->pbuffer);
                 kfree(ptr);
+                if (_cur < timeout) {
--
     while (list_empty(&info->app_info[i].app_sqlist) == 0) {
         DEBUG("Remove and free memory queue up on slow queue\n");
         pdpram_blk = list_entry(info->app_info[i].app_sqlist.next, struct dpram_blk, list);
         list_del(&pdpram_blk->list);
         ft1000_free_buffer(pdpram_blk, &freercvpool);
+        if (_cur < timeout) {
--
-	while (loopcnt < 10) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (loopcnt < 10) {
 		status = ft1000_read_register(ft1000dev, &temp,
 					       FT1000_REG_DOORBELL);
 		DEBUG("check_usb_db: read FT1000_REG_DOORBELL value is %x\n",
@@ -150,10 +155,21 @@ static u32 check_usb_db (struct ft1000_d
 			msleep(10);
--
-	while (loopcnt < 20) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (loopcnt < 20) {
 		status = ft1000_read_register(ft1000dev, &temp,
 					       FT1000_REG_DOORBELL);
 		DEBUG("FT1000:check_usb_db:Doorbell = 0x%x\n", temp);
@@ -164,6 +180,12 @@ static u32 check_usb_db (struct ft1000_d
 			DEBUG("check_usb_db: door bell is cleared, return 0\n");
--
 	while (loopcnt < 100) {
 		if (pft1000info->usbboot == 2) {
 			status = ft1000_read_dpram32(ft1000dev, 0,
@@ -306,6 +333,12 @@ static u16 get_handshake_usb(struct ft10
 		if ((handshake == expected_value) ||
 		    (handshake == HANDSHAKE_RESET_VALUE_USB))
--
-	while (list_empty(&info->prov_list) == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (list_empty(&info->prov_list) == 0) {
 		DEBUG("ft1000_reset_card:deleting provisioning record\n");
 		ptr =
 		    list_entry(info->prov_list.next, struct prov_record, list);
 		list_del(&ptr->list);
 		kfree(ptr->pprov_data);
--
 		while (tempword & FT1000_DB_DPRAM_TX) {
 			mdelay(10);
 			i++;
@@ -1397,6 +1413,12 @@ static int ft1000_dsp_prov(void *arg)
 			}
 			ft1000_read_register(dev, &tempword,
--
-	while (retry--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (retry--) {
 		if (inb(iobase + 3) & 0x80)
 			return 0;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while ((eoc < 0x80) && j < 100) {
 			j++;
 			eoc = readb(sdp->iobase + PCI20341_STATUS_REG);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (timeout &&
 		       !(inb(dev->iobase + AIO12_8_STATUS) & STATUS_ADC_EOC)) {
 			timeout--;
 			printk(KERN_ERR "timeout %d\n", timeout);
 			udelay(1);
+			if (_cur < timeout) {
--
 		while (timeout--) {
 			if (!(inw(dev->iobase + PCI171x_STATUS) & Status_FE))
 				goto conv_finish;
@@ -375,6 +380,12 @@ static int pci171x_insn_read_ai(struct c
 				DPRINTK("adv_pci1710 D n=%d tm=%d ST=%4x\n", n,
 					timeout,
--
-	while (NULL != (pcidev = pci_get_device(PCI_VENDOR_ID_ADVANTECH,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (NULL != (pcidev = pci_get_device(PCI_VENDOR_ID_ADVANTECH,
 						PCI_ANY_ID, pcidev))) {
 		if (strcmp(this_board->name, DRV_NAME) == 0) {
 			for (i = 0; i < n_boardtypes; ++i) {
@@ -1439,6 +1455,12 @@ static int pci1710_attach(struct comedi_
 		/*  fixup board_ptr in case we were using the dummy entry with the driver name */
--
 		while ((devpriv->stc_readw(dev,
 					   AI_Status_1_Register) &
 			AI_FIFO_Empty_St) == 0) {
@@ -1486,9 +1491,20 @@ static void ni_handle_fifo_dregs(struct
 			data[0] = (dl >> 16);
 			data[1] = (dl & 0xffff);
--
 		while (ni_readl(AIFIFO_Status_6143) & 0x04) {
 			dl = ni_readl(AIFIFO_Data_6143);
 
@@ -1497,6 +1513,12 @@ static void ni_handle_fifo_dregs(struct
 			data[1] = (dl & 0xffff);
 			cfc_write_array_to_buffer(s, data, sizeof(data));
--
-		while (fifo_empty == 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while (fifo_empty == 0) {
 			for (i = 0;
 			     i <
 			     sizeof(devpriv->ai_fifo_buffer) /
@@ -1528,6 +1555,12 @@ static void ni_handle_fifo_dregs(struct
 						  i *
--
 	while ((status1 =
 		devpriv->stc_readw(dev,
 				   Joint_Status_1_Register)) &
@@ -4026,6 +4064,12 @@ static int ni_serial_hw_readwrite8(struc
 			err = -ETIME;
 			goto Error;
--
-		while ((sdev = comedi_find_subdevice_by_type(d, COMEDI_SUBD_DIO,
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((sdev = comedi_find_subdevice_by_type(d, COMEDI_SUBD_DIO,
 							     sdev + 1)) > -1) {
 			nchans = comedi_get_n_channels(d, sdev);
 			if (nchans <= 0) {
@@ -455,6 +460,12 @@ static int doDevConfig(struct comedi_dev
 				strncat(devpriv->name, buf, left);
--
 		while (devpriv->ndevs-- && devpriv->devs) {
 			struct BondedDevice *bdev;
 
@@ -482,6 +498,12 @@ static void doDevUnconfig(struct comedi_
 				devs_closed |= (0x1 << bdev->minor);
 			}
--
-		while ((intstat = (inb(subpriv->iobase) & subpriv->valid_isns
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((intstat = (inb(subpriv->iobase) & subpriv->valid_isns
 				   & ~triggered)) != 0) {
 			triggered |= intstat;
 			cur_enabled &= ~triggered;
 			outb(cur_enabled, subpriv->iobase);
+			if (_cur < timeout) {
--
 		while (--i) {
 			hi = inb(dev->iobase + PCL711_AD_HI);
 			if (!(hi & PCL711_DRDY))
 				goto ok;
 			udelay(1);
+			if (_cur < timeout) {
--
 		while (timeout--) {
 			if (inb(dev->iobase + PCL818_STATUS) & 0x10)
 				goto conv_finish;
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (timeout--) {
 		if (inb(dev->iobase + PCL818_STATUS) & 0x10)
 			goto conv_finish;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (timeout--) {
 			if (inl(dev->iobase + PCI9118_ADSTAT) & AdStatus_ADrdy)
 				goto conv_finish;
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (NULL != (pcidev = pci_get_device(PCI_VENDOR_ID_AMCC,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (NULL != (pcidev = pci_get_device(PCI_VENDOR_ID_AMCC,
 						this_board->device_id,
 						pcidev))) {
 		/* Found matching vendor/device. */
@@ -2245,6 +2261,12 @@ static int pci9118_attach(struct comedi_
 			continue;
--
 	/* BEGIN JK 02.07.04 : This while can't be do, it block the process when using severals boards */
 	/* while(i_InterruptFlag==1) */
-	while (s_BoardInfos[dev->minor].i_InterruptFlag == 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (s_BoardInfos[dev->minor].i_InterruptFlag == 1) {
 #ifndef MSXBOX
 		udelay(1);
 #else
@@ -1036,6 +1041,12 @@ int i_APCI3200_ConfigAnalogInput(struct
 		/*  This solution hat to be studied. */
--
 	/* END JK 02.07.04 : This while can't be do, it block the process when using severals boards */
 
diff -u -p a/staging/comedi/drivers/addi-data/hwdrv_apci3501.c b/staging/comedi/drivers/addi-data/hwdrv_apci3501.c
--- a/staging/comedi/drivers/addi-data/hwdrv_apci3501.c
+++ b/staging/comedi/drivers/addi-data/hwdrv_apci3501.c
@@ -364,9 +364,20 @@ int i_APCI3501_WriteAnalogOutput(struct
--
 	while (ul_DAC_Ready == 0) {
 		ul_DAC_Ready = inl(devpriv->iobase + APCI3501_ANALOG_OUTPUT);
 		ul_DAC_Ready = (ul_DAC_Ready >> 8) & 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while (ul_DAC_Ready == 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (ul_DAC_Ready == 0) {
 			ul_DAC_Ready =
 				inl(devpriv->iobase + APCI3501_ANALOG_OUTPUT);
 			ul_DAC_Ready = (ul_DAC_Ready >> 8) & 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (more && count > 0) {
 			unsigned int dummy;
 			more = more && read_idm_word(data, size, &pos, &dummy);
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-				while (more && count > 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (more && count > 0) {
 					if (addr & 0x4000) {
 						/*  16 bit data, never seen in real life!! */
 						unsigned int data1;
@@ -505,6 +521,12 @@ static int jr3_download_firmware(struct
 						}
--
 	while (1) {
 		if (!(inb(dev->iobase + 8) & 0x01))
 			return;
 		comedi_buf_put(s->async, inw(dev->iobase));
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((this_usbduxsub->ai_interval) < (cmd->chanlist_len)) {
 			this_usbduxsub->ai_interval =
 			    (this_usbduxsub->ai_interval) * 2;
+			    if (_cur < timeout) {
+			rdstcll(_cur);
+			    }
--
-		while (timeout--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (timeout--) {
 			if (!(readw(devpriv->io_addr +
 				    ICP_MULTI_ADC_CSR) & ADC_BSY))
 				goto conv_finish;
@@ -322,6 +327,12 @@ static int icp_multi_insn_read_ai(struct
 #endif
--
-		while (timeout--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (timeout--) {
 			if (!(readw(devpriv->io_addr +
 				    ICP_MULTI_DAC_CSR) & DAC_BSY))
 				goto dac_ready;
@@ -436,6 +452,12 @@ static int icp_multi_insn_write_ao(struc
 #endif
--
 				while (position < num_samples) {
 					if (dev_private->chunk_counter <
 					    dev_private->chanlist_len) {
@@ -1086,6 +1091,12 @@ static irqreturn_t pci9111_interrupt(int
 					if (dev_private->chunk_counter >=
 					    dev_private->chunk_num_samples)
--
 		while (timeout--) {
 			if (!pci9111_is_fifo_empty())
 				goto conversion_done;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
 		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (1) {
 		int data = tty_read(f, timeout);
 
@@ -352,6 +357,12 @@ static struct serial_data serial_read(st
 			result.index = data & 0x1f;
 			break;
--
 		while (1) {
 			struct serial_data data;
 
@@ -562,6 +578,12 @@ static int serial_2002_open(struct comed
 					}
 				}
--
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0)
 	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x80)
 	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x0)
 	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x80)
 	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0x80) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0x80) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0x80) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0x80) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0x80) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0x80) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0x0) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0x80) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0x0) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (((tmp & 0x80) == 0x80) && (timeout < C6XDIGIO_TIME_OUT)) {
 		tmp = ReadByteFromHwPort(baseAddr + 1);
 		timeout++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0)
 	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x80)
 	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x0)
 	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((ReadByteFromHwPort(baseAddr + 1) & 0x80) == 0x80)
 	       && (timeout < C6XDIGIO_TIME_OUT)) {
 		timeout++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (RtdFifoStatus(dev) & FS_ADC_NOT_EMPTY) {	/* 1 -> not empty */
 		short sample;
 		s16 d = RtdAdcFifoGet(dev);	/* get 2s comp value */
@@ -1416,6 +1421,12 @@ static int ai_read_dregs(struct comedi_d
 
 		if (devpriv->aiCount > 0)	/* < 0, means read forever */
--
-	while (NULL != (pcidev =
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (NULL != (pcidev =
 			pci_get_device(PCI_VENDOR_ID_ADVANTECH,
 				       this_board->device_id, pcidev))) {
 		/* Found matching vendor/device. */
@@ -369,6 +374,12 @@ static int pci1723_attach(struct comedi_
 			continue;
--
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
 		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
 		spin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);
 		spin_lock_irqsave(&devpriv->isr_spinlock, irqflags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (timeout--) {
 			hi = inb(dev->iobase + PCL812_AD_HI);
 			if (!(hi & PCL812_DRDY))
 				goto conv_finish;
 			udelay(1);
+			if (_cur < timeout) {
--
 		while (timeout--) {
 			if (!(inb(dev->iobase + ACL8216_STATUS) & ACL8216_DRDY))
 				goto conv_finish;
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-			while (flags & TransferReady) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (flags & TransferReady) {
 				work++;
 				if (work > 100) {
 					DPRINTK("too much work in interrupt\n");
@@ -579,6 +584,12 @@ static irqreturn_t nidio_interrupt(int i
 				/* DPRINTK("read:%d, %d\n",data1,data2); */
--
 	while (b & 1) {
 		writew(0xff, devpriv->mite->daq_io_addr + Group_1_FIFO);
 		b = readb(devpriv->mite->daq_io_addr + Group_1_Flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (num_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (num_bytes) {
 		unsigned int block_size;
 
 		if (write_ptr + num_bytes > async->prealloc_bufsz)
@@ -722,6 +727,12 @@ void comedi_buf_memcpy_to(struct comedi_
 		num_bytes -= block_size;
--
-	while (nbytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nbytes) {
 		unsigned int block_size;
 
 		src = async->prealloc_buf + read_ptr;
@@ -749,6 +765,12 @@ void comedi_buf_memcpy_from(struct comed
 		nbytes -= block_size;
--
 		while ((skb = skb_dequeue(&hw->authq))) {
 			inf = (hfa384x_InfFrame_t *) skb->data;
 			prism2sta_inf_authreq_defer(wlandev, inf);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (curroff < (HFA384x_PDA_LEN_MAX / 2) &&
 	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
 		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
@@ -623,6 +628,12 @@ int mkpdrlist(struct pda *pda)
 		(pda->nrec)++;
 		curroff += le16_to_cpu(pda16[curroff]) + 1;
--
 	while (record) {
 
 		rcnt++;
@@ -957,6 +973,12 @@ int read_fwfile(const struct ihex_binrec
 			break;
 		}
--
 	while ((skb = skb_dequeue(&wlandev->nsd_rxq))) {
 		if (wlandev->state == WLAN_DEVICE_OPEN) {
 
@@ -323,6 +328,12 @@ static void p80211netdev_rx_bh(unsigned
 			}
 		}
--
 	while (i < num_channels) {
 		if (bytes % channels[i].bytes == 0)
 			channels[i].location = bytes;
@@ -50,6 +55,12 @@ int size_from_channelarray(struct iio_ch
 				+ channels[i].bytes;
 		bytes = channels[i].location + channels[i].bytes;
--
-	while ((c = getopt(argc, argv, "l:w:c:et:n:")) != -1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((c = getopt(argc, argv, "l:w:c:et:n:")) != -1) {
 		switch (c) {
 		case 'n':
 			device_name = optarg;
@@ -167,6 +183,12 @@ int main(int argc, char **argv)
 		case '?':
--
 	while ((initial_read_p != ring->read_p)
 	       || (initial_write_p != ring->write_p)) {
 		initial_read_p = ring->read_p;
 		initial_write_p = ring->write_p;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (*av_masks) {
 		if (bitmap_subset(mask, av_masks, masklength))
 			return av_masks;
 		av_masks += BITS_TO_LONGS(masklength);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len--) {
 		ret = i2c_smbus_write_byte_data(client, reg++, *data++);
 		if (ret < 0) {
 			dev_err(&client->dev, "I2C write error\n");
 			return ret;
 		}
--
 	while (len--) {
 		ret = i2c_smbus_read_byte_data(client, reg++);
 		if (ret < 0) {
@@ -147,6 +163,12 @@ static int ad5933_i2c_read(struct i2c_cl
 			return ret;
 		}
--
 	while (timeout--) {
 		ret =  ad5933_i2c_read(st->client, AD5933_REG_STATUS, 1, &val);
 		if (ret < 0)
@@ -179,6 +206,12 @@ static int ad5933_wait_busy(struct ad593
 			return val;
 		cpu_relax();
--
-	while (retry) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (retry) {
 		ret = i2c_smbus_read_word_data(client,
 				TSL2563_CMD | TSL2563_REG_DATA0LOW);
 		if (ret < 0)
@@ -343,6 +348,12 @@ static int tsl2563_get_adc(struct tsl256
 		adc1 = ret;
--
-	while ((list_empty(&data->queue) == 0) && --count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((list_empty(&data->queue) == 0) && --count) {
 		dev_dbg(&board_dat->pdev->dev, "%s :queue not empty\n",
 			__func__);
 		spin_unlock_irqrestore(&data->lock, flags);
 		msleep(PCH_SLEEP_TIME);
 		spin_lock_irqsave(&data->lock, flags);
--
 	while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
 	       && (pl022->rx < pl022->rx_end)) {
 		switch (pl022->read) {
@@ -690,10 +695,21 @@ static void readwriter(struct pl022 *pl0
 		}
 		pl022->rx += (pl022->cur_chip->n_bytes);
--
 	while ((pl022->exp_fifo_level < pl022->vendor->fifodepth)
 	       && (pl022->tx < pl022->tx_end)) {
 		switch (pl022->write) {
@@ -718,6 +734,11 @@ static void readwriter(struct pl022 *pl0
 		 * clock starts running when you put things into the TX FIFO,
 		 * and then things are continuously clocked into the RX FIFO.
--
 		while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
 		       && (pl022->rx < pl022->rx_end)) {
 			switch (pl022->read) {
@@ -739,6 +760,18 @@ static void readwriter(struct pl022 *pl0
 			}
 			pl022->rx += (pl022->cur_chip->n_bytes);
--
 		while (pl022->tx < pl022->tx_end || pl022->rx < pl022->rx_end) {
 			time = jiffies;
 			readwriter(pl022);
@@ -1469,6 +1507,12 @@ static void do_polling_transfer(struct p
 				goto out;
 			}
--
 	while ((!list_empty(&pl022->queue) || pl022->busy) && limit--) {
 		spin_unlock_irqrestore(&pl022->queue_lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&pl022->queue_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((cpsdvsr <= CPSDVR_MAX) && !found) {
 		while (scr <= SCR_MAX) {
 			tmp = spi_rate(rate, cpsdvsr, scr);
@@ -1835,6 +1895,12 @@ static int calculate_effective_freq(stru
 		}
 		cpsdvsr += 2;
 		scr = SCR_MIN;
--
 		while (SPIE_RXCNT(events) < min(4, mspi->len)) {
 			cpu_relax();
 			events = mpc8xxx_spi_read_reg(&reg_base->event);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 			while (tmp--) {
 				rx_data_8 = in_8((u8 *)&reg_base->receive);
 				rx_data |= (rx_data_8 << (tmp * 8));
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-	 while (!list_empty(&hw->msg_queue)) {
+	 unsigned long long delta = (cpu / khz / HZ) * 2;
+	 unsigned long long _start = 0;
+	 unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
+		while (!list_empty(&hw->msg_queue)) {
 		struct spi_message	*m;
 		struct spi_device	*spi;
 		struct spi_transfer	*t = NULL;
@@ -229,6 +234,12 @@ static void ti_ssp_spi_work(struct work_
 		m->complete(m->context);
--
 	while (!list_empty(&hw->msg_queue)) {
 		error = wait_for_completion_interruptible(&hw->complete);
 		if (error < 0) {
 			hw->shutdown = 0;
 			return error;
 		}
--
 	while (spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_RBE) {
 		udelay(10);
 		if (timeout-- < 0)
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!(spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_TBE)) {
 		udelay(10);
 		if (timeout-- < 0)
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (remain > 0) {
 		if (remain >= SPI_SH_FIFO_SIZE) {
 			ss->cr1 &= ~SPI_SH_RBF;
@@ -269,6 +296,12 @@ static int spi_sh_receive(struct spi_sh_
 
 		remain -= cur_len;
--
 	while (!list_empty(&ss->queue)) {
 		mesg = list_entry(ss->queue.next, struct spi_message, queue);
 		list_del_init(&mesg->queue);
@@ -320,6 +358,12 @@ static void spi_sh_work(struct work_stru
 
 		mesg->status = 0;
--
 	while (i >= 0) {
 		if (gpio_is_valid(pinfo->gpios[i]))
 			gpio_free(pinfo->gpios[i]);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	 while (!list_empty(&spi100k->msg_queue)) {
 		struct spi_message              *m;
 		struct spi_device               *spi;
@@ -418,6 +423,12 @@ static void omap1_spi100k_work(struct wo
 		m->complete(m->context);
 
--
 	while (!list_empty(&spi100k->msg_queue) && limit--) {
 		spin_unlock_irqrestore(&spi100k->lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&spi100k->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u8 *) (drv_data->tx++)));
 		/* wait until transfer finished.
@@ -236,6 +241,12 @@ static void bfin_spi_u8_writer(struct bf
 			cpu_relax();
 		/* discard RX data and clear RXS */
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, tx_val);
 		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
 			cpu_relax();
 		*(u8 *) (drv_data->rx++) = bfin_read(&drv_data->regs->rdbr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u8 *) (drv_data->tx++)));
 		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
 			cpu_relax();
 		*(u8 *) (drv_data->rx++) = bfin_read(&drv_data->regs->rdbr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u16 *) (drv_data->tx)));
 		drv_data->tx += 2;
@@ -287,6 +325,12 @@ static void bfin_spi_u16_writer(struct b
 			cpu_relax();
 		/* discard RX data and clear RXS */
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, tx_val);
 		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
 			cpu_relax();
 		*(u16 *) (drv_data->rx) = bfin_read(&drv_data->regs->rdbr);
 		drv_data->rx += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u16 *) (drv_data->tx)));
 		drv_data->tx += 2;
@@ -318,6 +378,12 @@ static void bfin_spi_u16_duplex(struct b
 			cpu_relax();
 		*(u16 *) (drv_data->rx) = bfin_read(&drv_data->regs->rdbr);
--
 	while ((!list_empty(&drv_data->queue) || drv_data->busy) && limit--) {
 		spin_unlock_irqrestore(&drv_data->lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&drv_data->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (((sppr - 1) & ~0x7) != 0) {
 		sppr = (sppr + 1) >> 1; /* add '1' to force rounding up */
 		spr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (rc == FSM_CONTINUE) {
 		/* Interrupt cleared by read of STATUS followed by
 		 * read of DATA registers */
 		status = in_8(ms->regs + SPI_STATUS);
 		data = in_8(ms->regs + SPI_DATA);
 		rc = ms->state(irq, ms, status, data);
--
 	while (!(__raw_readl(reg) & bit)) {
 		if (time_after(jiffies, timeout))
 			return -1;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&mcspi->msg_queue)) {
 		struct spi_message		*m;
 		struct spi_device		*spi;
@@ -969,6 +985,12 @@ static void omap2_mcspi_work(struct work
 		m->complete(m->context);
 
--
-			while ((TX_FIFO_LVL(status, sci)
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while ((TX_FIFO_LVL(status, sci)
 				|| !S3C64XX_SPI_ST_TX_DONE(status, sci))
 					&& --val) {
 				cpu_relax();
 				status = readl(regs + S3C64XX_SPI_STATUS);
+				if (_cur < timeout) {
--
-	while (!list_empty(&sdd->queue)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&sdd->queue)
 				&& !(sdd->state & SUSPND)) {
 
 		struct spi_message *msg;
@@ -801,6 +817,12 @@ static void s3c64xx_spi_work(struct work
 		spin_lock_irqsave(&sdd->lock, flags);
--
-	while ((sr & XSPI_SR_TX_FULL_MASK) == 0 && xspi->remaining_bytes > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((sr & XSPI_SR_TX_FULL_MASK) == 0 && xspi->remaining_bytes > 0) {
 		if (xspi->tx_ptr)
 			xspi->tx_fn(xspi);
 		else
 			xspi->write_fn(0, xspi->regs + XSPI_TXD_OFFSET);
 		xspi->remaining_bytes -= xspi->bits_per_word / 8;
--
 		while ((sr & XSPI_SR_RX_EMPTY_MASK) == 0) {
 			xspi->rx_fn(xspi);
 			sr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
--
 		while (len) {
 			unsigned int count = SPI_FIFO_SIZE;
 			int i;
@@ -254,6 +259,12 @@ static void txx9spi_work_one(struct txx9
 				}
 			}
--
 	while (!list_empty(&c->queue)) {
 		struct spi_message *m;
 
@@ -300,6 +316,12 @@ static void txx9spi_work(struct work_str
 		txx9spi_work_one(c, m);
 
--
 		while (read_SSSR(reg) & SSSR_RNE) {
 			read_SSDR(reg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	} while ((read_SSSR(reg) & SSSR_BSY) && --limit);
 	write_SSSR_CS(drv_data, SSSR_ROR);
@@ -264,10 +275,21 @@ static int null_reader(struct driver_dat
 	void __iomem *reg = drv_data->ioaddr;
 	u8 n_bytes = drv_data->n_bytes;
 
--
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		read_SSDR(reg);
 		drv_data->rx += n_bytes;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		*(u8 *)(drv_data->rx) = read_SSDR(reg);
 		++drv_data->rx;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		*(u16 *)(drv_data->rx) = read_SSDR(reg);
 		drv_data->rx += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		*(u32 *)(drv_data->rx) = read_SSDR(reg);
 		drv_data->rx += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((!list_empty(&drv_data->queue) || drv_data->busy) && limit--) {
 		spin_unlock_irqrestore(&drv_data->lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&drv_data->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (rb < t->len) {
 		if (t->len - rb > MPC52xx_PSC_BUFSIZE) {
 			rfalarm = MPC52xx_PSC_RFALARM;
@@ -196,6 +201,12 @@ static int mpc52xx_psc_spi_transfer_rxtx
 			for (; recv_at_once; rb++, recv_at_once--)
 				in_8(&psc->mpc52xx_psc_buffer_8);
--
 	while (!list_empty(&mps->queue)) {
 		struct spi_message *m;
 		struct spi_device *spi;
@@ -256,6 +272,12 @@ static void mpc52xx_psc_spi_work(struct
 		mpc52xx_psc_spi_transfer_setup(spi, NULL);
 
--
 	while (id->name[0]) {
 		if (!strcmp(sdev->modalias, id->name))
 			return id;
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&mpc8xxx_spi->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mpc8xxx_spi->queue)) {
 		struct spi_message *m = container_of(mpc8xxx_spi->queue.next,
 						   struct spi_message, queue);
 
@@ -76,6 +81,12 @@ void mpc8xxx_spi_work(struct work_struct
 			mpc8xxx_spi->spi_do_one_msg(m);
--
-	while (!list_empty(&mcfqspi->msgq)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&mcfqspi->msgq)) {
 		struct spi_message *msg;
 		struct spi_device *spi;
 		struct spi_transfer *xfer;
@@ -376,6 +381,12 @@ static void mcfqspi_work(struct work_str
 		msg->complete(msg->context);
--
 	while (likely(count > 0)) {
 		u8		word = 0;
 
@@ -83,6 +88,12 @@ static unsigned bitbang_txrx_8(
 		if (rx)
 			*rx++ = word;
--
 	while (likely(count > 1)) {
 		u16		word = 0;
 
@@ -109,6 +125,12 @@ static unsigned bitbang_txrx_16(
 		if (rx)
 			*rx++ = word;
--
 	while (likely(count > 3)) {
 		u32		word = 0;
 
@@ -135,6 +162,12 @@ static unsigned bitbang_txrx_32(
 		if (rx)
 			*rx++ = word;
--
 	while (!list_empty(&bitbang->queue)) {
 		struct spi_message	*m;
 		struct spi_device	*spi;
@@ -373,6 +411,12 @@ static void bitbang_work(struct work_str
 		}
 
--
 	while (len) {
 		int count;
 		int i;
@@ -201,12 +206,29 @@ static int mpc512x_psc_spi_transfer_rxtx
 			if (rx_buf)
 				*rx_buf++ = data;
--
 		while (in_be32(&fifo->rxcnt)) {
 			in_8(&fifo->rxdata_8);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (!list_empty(&mps->queue)) {
 		struct spi_message *m;
 		struct spi_device *spi;
@@ -268,6 +295,12 @@ static void mpc512x_psc_spi_work(struct
 		mpc512x_psc_spi_transfer_setup(spi, NULL);
 
--
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx8++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		dummy = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, tx_val);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx8++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx8++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx8++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx16++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		dummy = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, tx_val);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx16++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx16++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx16++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&drv_data->queue) && drv_data->busy && limit--) {
 		spin_unlock_irqrestore(&drv_data->lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&drv_data->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (max--) {
 		/* Set the tx word if the transfer's original "tx" is not null */
 		if (dws->tx_end - dws->len) {
@@ -206,6 +211,12 @@ static void dw_writer(struct dw_spi *dws
 		}
 		dw_writew(dws, DW_SPI_DR, txw);
--
 	while (max--) {
 		rxw = dw_readw(dws, DW_SPI_DR);
 		/* Care rx only if the transfer's original "rx" is not null */
@@ -224,6 +240,12 @@ static void dw_reader(struct dw_spi *dws
 				*(u16 *)(dws->rx) = rxw;
 		}
--
 	while ((!list_empty(&dws->queue) || dws->busy) && limit--) {
 		spin_unlock_irqrestore(&dws->lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&dws->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (1) {
 			unsigned int rxd;
 
 			while (!(readl(hw->base + ALTERA_SPI_STATUS) &
@@ -180,6 +185,12 @@ static int altera_spi_txrx(struct spi_de
 				       hw->base + ALTERA_SPI_TXDATA);
 			else
 				break;
+				if (_cur < timeout) {
--
 	while ((ep93xx_spi_read_u8(espi, SSPSR) & SSPSR_RNE)) {
 		ep93xx_do_read(espi, t);
 		espi->fifo_level--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (espi->fifo_level < SPI_FIFO_SIZE && espi->tx < t->len) {
 		ep93xx_do_write(espi, t);
 		espi->fifo_level++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (ep93xx_spi_read_u16(espi, SSPSR) & SSPSR_RNE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ep93xx_spi_read_u16(espi, SSPSR) & SSPSR_RNE) {
 		if (time_after(jiffies, timeout)) {
 			dev_warn(&espi->pdev->dev,
 				 "timeout while flushing RX FIFO\n");
@@ -842,6 +869,12 @@ static void ep93xx_spi_process_message(s
 			return;
 		}
 		ep93xx_spi_read_u16(espi, SSPDR);
+		if (_cur < timeout) {
--
-	while (!list_empty(&espi->msg_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&espi->msg_queue)) {
 		struct spi_message *msg;
 
 		msg = list_first_entry(&espi->msg_queue,
@@ -1177,6 +1215,12 @@ static int __devexit ep93xx_spi_remove(s
 		spin_unlock_irq(&espi->lock);
--
 	while (!list_empty(&ss->queue)) {
 		m = list_entry(ss->queue.next, struct spi_message, queue);
 		list_del_init(&m->queue);
@@ -401,6 +406,12 @@ static void stmp_spi_handle(struct work_
 		m->complete(m->context);
 
--
 	while (!list_empty(&orion_spi->msg_queue)) {
 		struct spi_message *m;
 		struct spi_device *spi;
@@ -340,6 +345,12 @@ msg_done:
 		m->complete(m->context);
 
--
-		while (len >= 1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (len >= 1) {
 			/* tx bit 15 is first sent; we byteswap multibyte words
 			 * (msb-first) on the way out from memory.
 			 */
@@ -268,6 +273,12 @@ static int uwire_txrx(struct spi_device
 				goto eio;
--
-		while (len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (len) {
 			if (bits > 8) {
 				bytes = 2;
 			} else
@@ -310,6 +326,12 @@ static int uwire_txrx(struct spi_device
 					dev_name(&spi->dev), bits, val);
--
 	while (spi_imx->devtype_data->rx_available(spi_imx)) {
 		spi_imx->rx(spi_imx);
 		spi_imx->txfifo--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 			while (i > 0) {
 				i--;
 				if (spi_imx->chipselect[i] >= 0)
 					gpio_free(spi_imx->chipselect[i]);
+					if (_cur < timeout) {
+					rdstcll(_cur);
--
-	while (*bytes_copied < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*bytes_copied < count) {
 		const unsigned long request = count - *bytes_copied;
 		u64 tmp;
 
@@ -961,6 +966,12 @@ int ps3_lpm_copy_tb(unsigned long offset
 		buf += tmp;
--
-	while (*bytes_copied < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*bytes_copied < count) {
 		const unsigned long request = count - *bytes_copied;
 		u64 tmp;
 
@@ -1024,6 +1040,12 @@ int ps3_lpm_copy_tb_to_user(unsigned lon
 		buf += tmp;
--
 	while (priv->rx_list.bytes_held < bytes) {
 		u64 tmp;
 
@@ -639,6 +644,12 @@ int ps3_vuart_read(struct ps3_system_bus
 			spin_unlock_irqrestore(&priv->rx_list.lock, flags);
 			return -EAGAIN;
--
-	while (loopcnt++ <= timeout) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (loopcnt++ <= timeout) {
 		error = ps3_vuart_read(dev, buf, size);
 		if (!error)
 			return size;
@@ -212,6 +217,12 @@ static int ps3av_vuart_read(struct ps3_s
 			return error;
--
 	while (ps3_sys_manager_handle_msg(dev)) {
 		/* pause until next DEC interrupt */
 		lv1_pause(0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (1) {
 		/* pause, ignoring DEC interrupt */
 		lv1_pause(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (byte_count > 1) {
 			inw(base);
 			byte_count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-		while (byte_count > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (byte_count > 0) {
 				inw(base);
 				byte_count -= 2;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
 	while (i < size_bytes) {
 		if (size_bytes - i == 2) {
 			/* Handle 2 bytes in the end */
@@ -468,6 +473,12 @@ static void read_mem32(u32 *buf, const v
 		}
 		buf++;
--
 	while (i < size_bytes) {
 		if (size_bytes - i == 2) {
 			/* 2 bytes */
@@ -518,6 +534,12 @@ static u32 write_mem32(void __iomem *mem
 		}
 		buf++;
--
 	while (size > 0) {
 		read_mem32((u32 *) buf, addr + offset, RECEIVE_BUF_MAX);
 
@@ -865,6 +892,12 @@ static int receive_data(enum port_type i
 			size -= i;
 			offset += i;
--
 	while ((thead = tty->buf.head) != NULL) {
 		tty->buf.head = thead->next;
 		kfree(thead);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((thead = tty->buf.free) != NULL) {
 		tty->buf.free = thead->next;
 		kfree(thead);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((thead = tty->buf.head->next) != NULL) {
 		tty_buffer_free(tty, tty->buf.head);
 		tty->buf.head = thead;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((*tbh) != NULL) {
 		struct tty_buffer *t = *tbh;
 		if (t->size >= size) {
@@ -181,6 +219,12 @@ static struct tty_buffer *tty_buffer_fin
 			return t;
 		}
--
 	while (again) {
 		spin_lock_irqsave(&hp->lock, flags);
 		again = hvsi_load_chunk(hp, &flip, &hangup, &handshake);
@@ -527,6 +532,12 @@ static irqreturn_t hvsi_interrupt(int ir
 			pr_debug("hvsi%i: attempting re-handshake\n", handshake->index);
 			schedule_work(&handshake->handshaker);
--
 	while ((count > 0) && (hvsi_write_room(hp->tty) > 0)) {
 		int chunksize = min(count, hvsi_write_room(hp->tty));
 
@@ -980,6 +996,12 @@ static int hvsi_write(struct tty_struct
 		source += chunksize;
 		count -= chunksize;
--
 	while (count > 0 || i > 0) {
 		if (count > 0 && i < sizeof(c)) {
 			if (buf[n] == '\n' && !donecr) {
@@ -1155,6 +1182,12 @@ static void hvsi_console_print(struct co
 				i = 0;
 			i -= ret;
--
 	while (len) {
 		int sent = __write_console(data, len);
 		
@@ -97,6 +102,12 @@ static int domU_write_console(uint32_t v
 
 		if (unlikely(len))
--
 	while ((residual = strchr(residual, ',')) != NULL) {
 		residual++;
 		size++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (*residual && count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*residual && count) {
 		residual = hvc_iucv_parse_filter(residual,
 						 array + ((size - count) * 8));
 		if (IS_ERR(residual)) {
@@ -1124,6 +1140,12 @@ static int hvc_iucv_setup_filter(const c
 			goto out_err;
--
 	while(temp_open_count) {
 		--temp_open_count;
 		/*
@@ -1309,6 +1314,12 @@ static void hvcs_hangup(struct tty_struc
 		 * final put will never happen.
 		 */
--
 	while (count > 0 || i > 0) {
 		if (count > 0 && i < sizeof(c)) {
 			if (b[n] == '\n' && !donecr) {
@@ -178,6 +183,12 @@ static void hvc_console_print(struct con
 					memmove(c, c+r, i);
 			}
--
 	while(temp_open_count) {
 		--temp_open_count;
 		tty_kref_put(tty);
 		kref_put(&hp->kref, destroy_hvc_struct);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count > 0 && (rsize = hp->outbuf_size - hp->n_outbuf) > 0) {
 		if (rsize > count)
 			rsize = count;
@@ -500,6 +527,12 @@ static int hvc_write(struct tty_struct *
 		hp->n_outbuf += rsize;
 		written += rsize;
--
 	while ((count > 0) && ((pi->seq - pi->ack) < VIOCHAR_WINDOW)) {
 		int len;
 
@@ -190,6 +195,12 @@ static int put_chars(uint32_t vtermno, c
 		sent += len;
 		count -= len;
--
 		while (wlen) {
 			len2 = (wlen > 2048) ? 2048 : wlen;
 			wlen -= len2;
@@ -587,6 +592,12 @@ static int moxa_real_load_code(struct mo
 			}
 			if (readw(baseAddr + key) != keycode)
--
-		while (c > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (c > 0) {
 			if (head > tail)
 				len = head - tail - 1;
 			else
@@ -1894,10 +1910,21 @@ static int MoxaPortWriteData(struct tty_
 			buffer += len;
--
 		while (c > 0) {
 			len = Page_size - pageofs;
 			if (len > c)
@@ -1910,6 +1937,12 @@ static int MoxaPortWriteData(struct tty_
 				pageno = spage;
 			pageofs = 0;
--
-		while (count > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (count > 0) {
 			ofs = baseAddr + DynPage_addr + bufhead + head;
 			len = (tail >= head) ? (tail - head) :
 					(rx_mask + 1 - head);
@@ -1952,11 +1990,22 @@ static int MoxaPortReadData(struct moxa_
 			memcpy_fromio(dst, ofs, len);
--
-		while (count > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (count > 0) {
 			writew(pageno, baseAddr + Control_reg);
 			ofs = baseAddr + DynPage_addr + pageofs;
 			len = tty_prepare_flip_string(tty, &dst,
@@ -1967,6 +2016,12 @@ static int MoxaPortReadData(struct moxa_
 			pageofs = (pageofs + len) & Page_mask;
--
 	while (call < __con_initcall_end) {
 		(*call)();
 		call++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (i--) {
 		int index = cs[i]->index;
 		struct tty_driver *drv = cs[i]->device(cs[i], &index);
@@ -3333,6 +3349,12 @@ static ssize_t show_cons_active(struct d
 					 cs[i]->name, cs[i]->index);
 
--
 		while ((i & 3) != 2) {
 			outw((unsigned short) 0xDEAD, hw->base_port);
 			i += 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while ((i & 3) != 2) {
 			inw(hw->base_port);
 			i += 2;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (hw->rx_ready && !hw->blocking_rx) {
 		received = 1;
 		hw->rx_ready--;
@@ -939,6 +966,12 @@ static int get_packets_from_hw(struct ip
 		do_receive_packet(hw);
 
--
-		while (len--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+while (len--) {
 			data = cyy_readb(info, CyRDSR);
 			tty_insert_flip_char(tty, data, TTY_NORMAL);
 			info->idle_stats.recv_bytes++;
@@ -561,6 +566,12 @@ static void cyy_chip_rx(struct cyclades_
 #ifdef CY_16Y_HACK
--
 	while (char_count-- > 0) {
 		if (!info->xmit_cnt) {
 			if (cyy_readb(info, CySRER) & CyTxMpty) {
@@ -674,6 +690,12 @@ static void cyy_chip_tx(struct cyclades_
 				char_count--;
 			}
--
 	while ((readl(pci_doorbell) & 0xff) != 0) {
 		if (index++ == 1000)
 			return (int)(readl(pci_doorbell) & 0xff);
 		udelay(50L);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-			while (len--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (len--) {
 				data = readb(cinfo->base_addr + rx_bufaddr +
 						new_rx_get);
 				new_rx_get = (new_rx_get + 1) &
@@ -992,7 +1030,13 @@ static void cyz_handle_rx(struct cyclade
 				tty_insert_flip_char(tty, data, TTY_NORMAL);
--
-		while (0 < (small_count = min_t(unsigned int,
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (0 < (small_count = min_t(unsigned int,
 				tx_bufsize - tx_put, min_t(unsigned int,
 					(SERIAL_XMIT_SIZE - info->xmit_tail),
 					min_t(unsigned int, info->xmit_cnt,
@@ -1071,9 +1120,20 @@ static void cyz_handle_tx(struct cyclade
 			info->xmit_cnt -= small_count;
--
-		while (info->xmit_cnt && char_count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+unsigned long long _start = 0;
+unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+			while (info->xmit_cnt && char_count) {
 			data = info->port.xmit_buf[info->xmit_tail];
 			info->xmit_cnt--;
 			info->xmit_tail = (info->xmit_tail + 1) &
@@ -1083,6 +1143,12 @@ static void cyz_handle_tx(struct cyclade
 			tx_put = (tx_put + 1) & (tx_bufsize - 1);
--
 	while (cyz_fetch_msg(cinfo, &channel, &cmd, &param) == 1) {
 		special_count = 0;
 		delta_count = 0;
@@ -1190,6 +1261,12 @@ static void cyz_handle_cmd(struct cyclad
 		if (special_count)
 			tty_schedule_flip(tty);
--
 	while (limit-- > 0) {
 		unsigned long ra = __pa(con_read_page);
 		unsigned long bytes_read, i;
@@ -158,6 +163,12 @@ static int receive_chars_read(struct uar
 		port->icount.rx += bytes_read;
 
--
-	while (n > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n > 0) {
 		unsigned long ra = __pa(con_write_page);
 		unsigned long page_bytes;
 		unsigned int cpy = fill_con_write_page(s, n,
@@ -466,6 +482,12 @@ static void sunhv_console_write_paged(st
 			page_bytes -= written;
--
 		while ((readl(&port->ip_serial_regs->sscr)
 			& SSCR_PAUSE_STATE) == 0) {
 			spiniter++;
@@ -510,6 +515,12 @@ static inline int local_open(struct ioc3
 				NOT_PROGRESS();
 				return -1;
--
 		while ((readl(&port->ip_serial_regs->sscr)
 			& SSCR_PAUSE_STATE) == 0) {
 			spiniter++;
 			if (spiniter > MAXITER)
 				return -1;
+				if (_cur < timeout) {
--
 	while ((prod_ptr != cons_ptr) && (len > 0)) {
 		int xx;
 
@@ -729,6 +756,12 @@ static inline int do_write(struct ioc3_p
 		/* Go on to next entry */
 		prod_ptr += sizeof(struct ring_entry);
--
 		while ((readl(&port->ip_serial_regs->sscr)
 			& SSCR_PAUSE_STATE) == 0) {
 			spiniter++;
 			if (spiniter > MAXITER)
 				return -1;
+				if (_cur < timeout) {
--
 			while (readl(&port->ip_serial_regs->sscr) &
 			       SSCR_RX_DRAIN) {
 				loop_counter++;
 				if (loop_counter > MAXITER)
 					return -1;
+					if (_cur < timeout) {
--
 	while (status & UTSR1_TO_SM(UTSR1_RNE)) {
 		ch = UART_GET_CHAR(sport);
 
@@ -231,6 +236,12 @@ sa1100_rx_chars(struct sa1100_port *spor
 	ignore_char:
 		status = UTSR1_TO_SM(UART_GET_UTSR1(sport)) |
--
 	while ((termios->c_cflag & CSIZE) != CS7 &&
 	       (termios->c_cflag & CSIZE) != CS8) {
 		termios->c_cflag &= ~CSIZE;
 		termios->c_cflag |= old_csize;
 		old_csize = CS8;
+		if (_cur < timeout) {
--
 	while (1) {
 		if (in_be16(&bdp->status) & BD_SC_READY)
 			/* This BD is not done, so return "not done" */
@@ -269,6 +274,12 @@ static unsigned int qe_uart_tx_empty(str
 			return 1;
 
--
 	while (!(in_be16(&bdp->status) & BD_SC_READY) &&
 	       (xmit->tail != xmit->head)) {
 		count = 0;
@@ -385,6 +401,12 @@ static int qe_uart_tx_pump(struct uart_q
 			bdp = qe_port->tx_bd_base;
 		else
--
 		while (i-- > 0) {
 			ch = *cp++;
 			port->icount.rx++;
@@ -514,6 +541,12 @@ static void qe_uart_int_rx(struct uart_q
 error_return:
 			tty_insert_flip_char(tty, ch, flg);
--
-	while (up) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (up) {
 		struct zilog_channel __iomem *channel
 			= ZILOG_CHANNEL_FROM_PORT(&up->port);
 		struct tty_struct *tty;
@@ -587,6 +592,12 @@ static irqreturn_t sunzilog_interrupt(in
 			tty_flip_buffer_push(tty);
--
 		while (up) {
 			struct zilog_channel __iomem *channel;
 
@@ -1597,6 +1613,12 @@ static int __init sunzilog_init(void)
 			up->curregs[R9] |= MIE;
 			write_zsreg(channel, R9, up->curregs[R9]);
--
 		while (up) {
 			struct zilog_channel __iomem *channel;
 
@@ -1634,6 +1661,12 @@ static void __exit sunzilog_exit(void)
 			up->curregs[R9] &= ~MIE;
 			write_zsreg(channel, R9, up->curregs[R9]);
--
 		while (i-- > 0) {
 			ch = *cp++;
 			port->icount.rx++;
@@ -304,6 +309,12 @@ static void cpm_uart_int_rx(struct uart_
 		      error_return:
 			tty_insert_flip_char(tty, ch, flg);
--
 		}		/* End while (i--) */
 
 		/* This BD is ready to be used again. Clear status. get next */
@@ -457,9 +468,20 @@ static void cpm_uart_shutdown(struct uar
 	/* If the port is not the console, disable Rx and Tx. */
 	if (!(pinfo->flags & FLAG_CONSOLE)) {
--
 		while(!cpm_uart_tx_empty(port)) {
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			schedule_timeout(2);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!(in_be16(&bdp->cbd_sc) & BD_SC_READY) &&
 	       xmit->tail != xmit->head) {
 		count = 0;
@@ -719,6 +746,12 @@ static int cpm_uart_tx_pump(struct uart_
 			bdp = pinfo->tx_bd_base;
 		else
--
-	while (fifocnt--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (fifocnt--) {
 		u8 flag = TTY_NORMAL;
 		ch = ltq_r8(port->membase + LTQ_ASC_RBUF);
 		rsr = (ltq_r32(port->membase + LTQ_ASC_STATE)
@@ -211,6 +216,12 @@ lqasc_rx_chars(struct uart_port *port)
 			 * character
--
-	while (!(readl(s->port.membase + AUART_STAT) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(readl(s->port.membase + AUART_STAT) &
 		 AUART_STAT_TXFF)) {
 		if (s->port.x_char) {
 			s->port.icount.tx++;
@@ -149,6 +154,12 @@ static inline void mxs_auart_tx_chars(st
 				uart_write_wakeup(&s->port);
--
 	while ((status = readl(port->membase + ALTERA_JTAGUART_DATA_REG)) &
 	       ALTERA_JTAGUART_DATA_RVALID_MSK) {
 		ch = status & ALTERA_JTAGUART_DATA_DATA_MSK;
@@ -137,6 +142,12 @@ static void altera_jtaguart_rx_chars(str
 		if (uart_handle_sysrq_char(port, ch))
 			continue;
--
-			while (count--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (count--) {
 				writel(xmit->buf[xmit->tail],
 				       port->membase + ALTERA_JTAGUART_DATA_REG);
 				xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 				port->icount.tx++;
+				if (_cur < timeout) {
--
 	while (((status = readl(port->membase + ALTERA_JTAGUART_CONTROL_REG)) &
 		ALTERA_JTAGUART_CONTROL_WSPACE_MSK) == 0) {
 		if ((status & ALTERA_JTAGUART_CONTROL_AC_MSK) == 0) {
@@ -323,6 +350,12 @@ static void altera_jtaguart_console_putc
 		spin_unlock_irqrestore(&port->lock, flags);
 		cpu_relax();
--
 	while ((readl(port->membase + ALTERA_JTAGUART_CONTROL_REG) &
 		ALTERA_JTAGUART_CONTROL_WSPACE_MSK) == 0) {
 		spin_unlock_irqrestore(&port->lock, flags);
 		cpu_relax();
 		spin_lock_irqsave(&port->lock, flags);
+		if (_cur < timeout) {
--
 	while ((status = readb(port->membase + MCFUART_USR)) & MCFUART_USR_RXREADY) {
 		ch = readb(port->membase + MCFUART_URB);
 		flag = TTY_NORMAL;
@@ -308,6 +313,12 @@ static void mcf_rx_chars(struct mcf_uart
 		if (uart_handle_sysrq_char(port, ch))
 			continue;
--
-	while (!((cmdstat = be32_to_cpu(rxre->cmdstat))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!((cmdstat = be32_to_cpu(rxre->cmdstat))
 				& SDMA_DESC_CMDSTAT_O)) {
 		bytes_in = be16_to_cpu(rxre->bytecnt);
 #ifdef CONFIG_CONSOLE_POLL
@@ -1075,6 +1080,12 @@ next_frame:
 					(ulong)rxre + MPSC_RXRE_SIZE);
--
-	while (CIRC_CNT(pi->txr_head, pi->txr_tail, MPSC_TXR_ENTRIES)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (CIRC_CNT(pi->txr_head, pi->txr_tail, MPSC_TXR_ENTRIES)
 			< (MPSC_TXR_ENTRIES - 1)) {
 		if (pi->port.x_char) {
 			/*
@@ -1157,6 +1173,12 @@ static void mpsc_copy_tx_data(struct mps
 
--
-	while (poll_cnt == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (poll_cnt == 0) {
 		rxre = (struct mpsc_rx_desc *)(pi->rxr +
 		       (pi->rxr_posn*MPSC_RXRE_SIZE));
 		dma_cache_sync(pi->port.dev, (void *)rxre,
@@ -1579,7 +1606,12 @@ static int mpsc_get_poll_char(struct uar
 		 * Loop through Rx descriptors handling ones that have
--
-		while (poll_cnt == 0 &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (poll_cnt == 0 &&
 		       !((cmdstat = be32_to_cpu(rxre->cmdstat)) &
 			 SDMA_DESC_CMDSTAT_O)){
 			bytes_in = be16_to_cpu(rxre->bytecnt);
@@ -1630,11 +1662,23 @@ static int mpsc_get_poll_char(struct uar
 				invalidate_dcache_range((ulong)rxre,
--
 	while (pi->txr_head != pi->txr_tail) {
 		while (mpsc_sdma_tx_active(pi))
 			udelay(100);
 		mpsc_sdma_intr_ack(pi);
 		mpsc_tx_intr(pi);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (mpsc_sdma_tx_active(pi))
 		udelay(100);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (count > 0) {
 		bp = dp = pi->txb + (pi->txr_head * MPSC_TXBE_SIZE);
 
@@ -1751,6 +1811,12 @@ static void mpsc_console_write(struct co
 			udelay(100);
 
--
 	while (!(read_zsreg(zport, R0) & Tx_BUF_EMP) && --loops) {
 		zs_spin_unlock_cond_irq(&scc->zlock, irq);
 		udelay(2);
 		zs_spin_lock_cond_irq(&scc->zlock, irq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!(read_zsreg(zport, R1) & ALL_SNT) && --loops) {
 		zs_spin_unlock_cond_irq(&scc->zlock, irq);
 		udelay(2);
 		zs_spin_lock_cond_irq(&scc->zlock, irq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(UART_GET_FIFO_CNT(&mux_ports[0].port))
 		udelay(1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while(count--) {
 		if(*s == '\n') {
 			UART_PUT_CHAR(&mux_ports[0].port, '\r');
 		}
 		UART_PUT_CHAR(&mux_ports[0].port, *s++);
+		if (_cur < timeout) {
--
 	while ((UART_GET_LSR(uart) & THRE) && xmit->tail != xmit->head) {
 		UART_PUT_CHAR(uart, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		uart->port.icount.tx++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (!(status & SYSFLG_URXFE)) {
 		ch = clps_readl(UARTDR(port));
 
@@ -137,6 +142,12 @@ static irqreturn_t clps711xuart_int_rx(i
 
 	ignore_char:
--
 	while (UART_RX_DATA(status) && (max_chars--)) {
 
 		ch = UART_GET_CHAR(port);
@@ -124,6 +129,12 @@ static void apbuart_rx_chars(struct uart
 
 	      ignore_char:
--
 	while (((status >> 20) & 0x3F) == fifosize) {
 		fifosize++;
 		UART_PUT_CHAR(port, 0);
 		status = UART_GET_STATUS(port);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((status = altera_uart_readl(port, ALTERA_UART_STATUS_REG)) &
 	       ALTERA_UART_STATUS_RRDY_MSK) {
 		ch = altera_uart_readl(port, ALTERA_UART_RXDATA_REG);
@@ -229,6 +234,12 @@ static void altera_uart_rx_chars(struct
 			continue;
 		uart_insert_char(port, status, ALTERA_UART_STATUS_ROE_MSK, ch,
--
-	while (up) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (up) {
 		struct zilog_channel *channel
 			= ZILOG_CHANNEL_FROM_PORT(&up->port);
 		struct tty_struct *tty;
@@ -487,6 +492,12 @@ static irqreturn_t ip22zilog_interrupt(i
 			tty_flip_buffer_push(tty);
--
-		while((readl(&port->ip_serial_regs-> sscr)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while((readl(&port->ip_serial_regs-> sscr)
 				& IOC4_SSCR_PAUSE_STATE) == 0) {
 			spiniter++;
 			if (spiniter > MAXITER) {
 				port->ip_flags = PORT_INACTIVE;
 				return -1;
--
-		while((readl(&port->ip_serial_regs->sscr)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while((readl(&port->ip_serial_regs->sscr)
 						& IOC4_SSCR_PAUSE_STATE) == 0) {
 			spiniter++;
 			if (spiniter > MAXITER)
 				return -1;
+				if (_cur < timeout) {
--
 	while ((prod_ptr != cons_ptr) && (len > 0)) {
 		int xx;
 
@@ -1454,6 +1481,12 @@ static inline int do_write(struct ioc4_p
 		/* Go on to next entry */
 		prod_ptr += sizeof(struct ring_entry);
--
-		while ((readl(&port->ip_serial_regs->sscr)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((readl(&port->ip_serial_regs->sscr)
 					& IOC4_SSCR_PAUSE_STATE) == 0) {
 			spiniter++;
 			if (spiniter > MAXITER)
 				return -1;
+				if (_cur < timeout) {
--
-			while (readl(&port->ip_serial_regs->sscr) &
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (readl(&port->ip_serial_regs->sscr) &
 						IOC4_SSCR_RX_DRAIN) {
 				loop_counter++;
 				if (loop_counter > MAXITER)
 					return -1;
+					if (_cur < timeout) {
--
 	while ((buffer = info->first_recv_buffer) != NULL) {
 		unsigned int count = buffer->length;
 
@@ -2144,6 +2149,12 @@ static void flush_to_flip_buffer(struct
 			memmove(buffer->buffer, buffer->buffer + count, buffer->length);
 			buffer->error = TTY_NORMAL;
--
 		while (irq_mask1_rd) {
 			/* Disable those we are about to handle */
 			*R_IRQ_MASK1_CLR = irq_mask1_rd;
@@ -2682,6 +2698,12 @@ ser_interrupt(int irq, void *dev_id)
 			local_irq_disable();
 			/* Handle reentered TX interrupt */
--
 	while (control_state_str[i].str != NULL) {
 		if (MLines & control_state_str[i].state) {
 			if (s[0] != '\0') {
@@ -3551,6 +3578,12 @@ char *get_control_state_str(int MLines,
 			strcat(s, control_state_str[i].str);
 		}
--
 		while ((xuartps_readl(XUARTPS_SR_OFFSET) &
 			XUARTPS_SR_RXEMPTY) != XUARTPS_SR_RXEMPTY) {
 			data = xuartps_readl(XUARTPS_FIFO_OFFSET);
@@ -191,6 +196,12 @@ static irqreturn_t xuartps_isr(int irq,
 				uart_insert_char(port, isrstatus,
 						XUARTPS_IXR_OVERRUN, data,
--
-	while ((xuartps_readl(XUARTPS_SR_OFFSET) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((xuartps_readl(XUARTPS_SR_OFFSET) &
 		 XUARTPS_SR_RXEMPTY) != XUARTPS_SR_RXEMPTY) {
 		xuartps_readl(XUARTPS_FIFO_OFFSET);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (!(status & 0x10) && max_count--) {
 		ch = *CSR_UARTDR;
 		flag = TTY_NORMAL;
@@ -113,6 +118,12 @@ static irqreturn_t serial21285_rx_chars(
 		uart_insert_char(port, rxs, RXSTAT_OVERRUN, ch, flag);
 
--
-	while ((port->state->xmit.head != temp_tail) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((port->state->xmit.head != temp_tail) &&
 	       (data_count <= XMIT_BUFF_SZ)) {
 
 		ICOM_PORT->xmit_buf[data_count++] =
@@ -646,6 +651,12 @@ static int icom_write(struct uart_port *
 
--
 	while (status & SA_FL_RCV_DONE) {
 		int first = -1;
 
@@ -833,6 +849,12 @@ ignore_char:
 			rcv_buff = 0;
 
--
 	while (!(readl(port->membase + UART_FR) & FR_RXFE)) {
 		rx = readl(port->membase + UART_DR);
 		flg = TTY_NORMAL;
@@ -235,6 +240,12 @@ static void netx_rxint(struct uart_port
 			continue;
 
--
 	while (status) {
 		if (status & IIR_RIS)
 			netx_rxint(port);
@@ -263,6 +279,12 @@ static irqreturn_t netx_int(int irq, voi
 		}
 		writel(0, port->membase + UART_IIR);
--
-	while (psc_ops->raw_rx_rdy(port)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (psc_ops->raw_rx_rdy(port)) {
 		/* Get the char */
 		ch = psc_ops->read_char(port);
 
@@ -991,6 +996,12 @@ mpc52xx_uart_int_rx_chars(struct uart_po
 			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
--
 	while (status & FIFO_TO_SM(PNX8XXX_UART_FIFO_RXFIFO)) {
 		ch = serial_in(sport, PNX8XXX_FIFO) & 0xff;
 
@@ -237,6 +242,12 @@ static void pnx8xxx_rx_chars(struct pnx8
 				PNX8XXX_UART_LCR_RX_NEXT);
 		status = FIFO_TO_SM(serial_in(sport, PNX8XXX_FIFO)) |
--
 	while ((termios->c_cflag & CSIZE) != CS7 &&
 	       (termios->c_cflag & CSIZE) != CS8) {
 		termios->c_cflag &= ~CSIZE;
 		termios->c_cflag |= old_csize;
 		old_csize = CS8;
+		if (_cur < timeout) {
--
 	while (rxlvl) {
 		pr_debug("rxlvl %d\n", rxlvl);
 		/* Clear buffer */
@@ -215,6 +220,12 @@ static void max3107_handlerx(struct max3
 		put_data_to_circ_buf(s, valid_str, rxlvl);
 		/* Get new RX level */
--
 	while ((sr = msm_read(port, UART_SR)) & UART_SR_RX_READY) {
 		unsigned int c;
 		char flag = TTY_NORMAL;
@@ -187,6 +192,12 @@ static void handle_rx(struct uart_port *
 
 		if (!uart_handle_sysrq_char(port, c))
--
 	while (SPORT_GET_STAT(up) & RXNE) {
 		ch = rx_one_byte(up);
 		up->port.icount.rx++;
 
 		if (!uart_handle_sysrq_char(&up->port, ch))
 			tty_insert_flip_char(tty, ch, TTY_NORMAL);
--
 	while(!(SPORT_GET_STAT(up) & TXF) && !uart_circ_empty(xmit)) {
 		tx_one_byte(up, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE -1);
 		up->port.icount.tx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((iid = pch_uart_hal_get_iid(priv)) > 1) {
 		switch (iid) {
 		case PCH_UART_IID_RLS:	/* Receiver Line Status */
@@ -1032,6 +1037,12 @@ static irqreturn_t pch_uart_interrupt(in
 			break;
 		}
--
-		while (qleft < 1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (qleft < 1) {
 			jsm_printk(READ, INFO, &ch->ch_bd->pci_dev,
 				"Queue full, dropping DATA:%x LSR:%x\n",
 				ch->ch_rqueue[tail], ch->ch_equeue[tail]);
@@ -462,6 +467,12 @@ static void neo_copy_data_from_uart_to_q
 			ch->ch_r_tail = tail = (tail + 1) & RQUEUEMASK;
--
 	while (((uart_poll & 0xff) != 0) && (outofloop_count < 0xff)){
 
 		tmp = uart_poll;
@@ -1235,6 +1251,12 @@ static irqreturn_t neo_intr(int irq, voi
 				"%s:%d Unknown Interrupt type: %x\n", __FILE__, __LINE__, type);
 			continue;
--
 	while (!uart_circ_empty(xmit)) {
 		left = uart_circ_chars_pending(xmit);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (left) {
 			len = min(left, WORDS_PER_XFER);
 			blen = len * sizeof(u16);
@@ -299,6 +309,18 @@ static void send_circ_buf(struct uart_ma
 
 			max->port.icount.tx += len;
--
 	while (n >= 640) {
 		n = n / 2;
 		m++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((status = dz_in(dport, DZ_RBUF)) & DZ_DVAL) {
 		dport = &mux->dport[LINE(status)];
 		uport = &dport->port;
@@ -247,6 +252,12 @@ static inline void dz_receive_chars(stru
 
 		uart_insert_char(uport, status, DZ_OERR, ch, flag);
--
 		while ((--n > 0) &&
 		      !(readl(sport->port.membase + USR2) & USR2_TXDC)) {
 			udelay(5);
 			barrier();
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (!uart_circ_empty(xmit) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!uart_circ_empty(xmit) &&
 			!(readl(sport->port.membase + uts_reg(sport))
 				& UTS_TXFULL)) {
 		/* send xmit->buf[xmit->tail]
@@ -393,6 +409,12 @@ static inline void imx_transmit_buffer(s
 		writel(xmit->buf[xmit->tail], sport->port.membase + URTX0);
--
 	while (readl(sport->port.membase + USR2) & USR2_RDR) {
 		flg = TTY_NORMAL;
 		sport->port.icount.rx++;
@@ -542,6 +569,12 @@ static irqreturn_t imx_rxint(int irq, vo
 		}
 
--
 		while (!(readl(sport->port.membase + UCR2) & UCR2_SRST) &&
 		    (--i > 0)) {
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while ((--i > 0) &&
 			(readl(sport->port.membase + URXD0) & URXD_CHARRDY)) {
 			barrier();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((termios->c_cflag & CSIZE) != CS7 &&
 	       (termios->c_cflag & CSIZE) != CS8) {
 		termios->c_cflag &= ~CSIZE;
 		termios->c_cflag |= old_csize;
 		old_csize = CS8;
+		if (_cur < timeout) {
--
 	while (UART_RX_DATA(status) && max_count--) {
 		ch = readb(uap->port.membase + UART01x_DR);
 		flag = TTY_NORMAL;
@@ -163,6 +168,12 @@ static void pl010_rx_chars(struct uart_a
 
 	ignore_char:
--
 	while ((s1 = memchr(s, '\n', count)) != NULL) {
 		puts_raw(s, s1 - s);
 		puts_raw("\r\n", 2);
 		count -= s1 + 1 - s;
 		s = s1 + 1;
+		if (_cur < timeout) {
--
-	while (!(UTX & UTX_TX_AVAIL) && (loops < 1000)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (!(UTX & UTX_TX_AVAIL) && (loops < 1000)) {
         	loops++;
         	udelay(5);
-        }
+        	if (_cur < timeout) {
+        	        rdstcll(_cur);
--
 	while (left != 0) {
 		c = info->xmit_buf[info->xmit_tail];
 		info->xmit_tail = (info->xmit_tail+1) & (SERIAL_XMIT_SIZE-1);
@@ -567,6 +583,12 @@ static void rs_fair_output(void)
 
 		local_irq_save(flags);
--
 	while((c=*(p++)) != 0) {
 		if(c == '\n')
 			rs_put_char('\r');
 		rs_put_char(c);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while(info->xmit_cnt) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(info->xmit_cnt) {
 #endif
 
 		uart->ustcnt |= USTCNT_TXEN;
@@ -709,6 +747,12 @@ static int rs_write(struct tty_struct *
 		}
--
     while (count--) {
         if (*str == '\n')
            rs_put_char('\r');
         rs_put_char( *str++ );
+        if (_cur < timeout) {
+           rdstcll(_cur);
--
 	while (!(uart_circ_empty(xmit) || uart_tx_stopped(&up->port))) {
 		nwpserial_putchar(up, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE-1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((status & URLS_URDR) && max_count--) {
 		ch = UART_GET_CHAR(port);
 		flg = TTY_NORMAL;
@@ -199,6 +204,12 @@ static irqreturn_t ks8695uart_rx_chars(i
 
 ignore_char:
--
 	while (!uart_circ_empty(xmit) && (count-- > 0)) {
 		KS8695_CLR_TX_INT();
 		UART_PUT_CHAR(port, xmit->buf[xmit->tail]);
 
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		port->icount.tx++;
--
 	while (status & ATMEL_US_RXRDY) {
 		ch = UART_GET_CHAR(port);
 
@@ -523,6 +528,12 @@ static void atmel_rx_chars(struct uart_p
 
 		atmel_buffer_rx_char(port, status, ch);
--
 	while (ring->head != ring->tail) {
 		struct atmel_uart_char c;
 
@@ -764,6 +780,12 @@ static void atmel_rx_from_ring(struct ua
 			continue;
 
--
 	while (vt8500_read(port, VT8500_URFIDX) & 0x1f00) {
 		unsigned int c;
 		char flag = TTY_NORMAL;
@@ -165,6 +170,12 @@ static void handle_rx(struct uart_port *
 
 		if (!uart_handle_sysrq_char(port, c))
--
 	while (ioread32(port->membase + TIMBUART_ISR) & RXDP) {
 		u8 ch = ioread8(port->membase + TIMBUART_RXFIFO);
 		port->icount.rx++;
 		tty_insert_flip_char(tty, ch, TTY_NORMAL);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!(ioread32(port->membase + TIMBUART_ISR) & TXBF) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(ioread32(port->membase + TIMBUART_ISR) & TXBF) &&
 		!uart_circ_empty(xmit)) {
 		iowrite8(xmit->buf[xmit->tail],
 			port->membase + TIMBUART_TXFIFO);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		port->icount.tx++;
--
-		while (ToRecv) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (ToRecv) {
 			char flag;
 
 			CharNStat = sInW(sGetTxRxDataIO(cp));
@@ -381,6 +386,12 @@ static void rp_do_receive(struct r_port
 				flag = TTY_NORMAL;
--
 	while ((dev = pci_get_device(PCI_VENDOR_ID_RP, PCI_ANY_ID, dev))) {
 		if (register_PCI(count + boards_found, dev))
 			count++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 				while (pClient->msg_count) {
 					pMsg = remove_msg(pInfo, pClient);
 					if (pMsg) {
@@ -770,6 +775,12 @@ static int enable_signals(struct r3964_i
 						TRACE_M("enable_signals - msg "
 							"kfree %p", pMsg);
--
 	while (pClient) {
 		pNext = pClient->next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (pClient->msg_count) {
 			pMsg = remove_msg(pInfo, pClient);
 			if (pMsg) {
 				kfree(pMsg);
 				TRACE_M("r3964_close - msg kfree %p", pMsg);
 			}
--
 	while (pHeader) {
 		pNextHeader = pHeader->next;
 		kfree(pHeader);
 		pHeader = pNextHeader;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!kthread_should_stop()) {
 		/* no one left to give data to, so sleep */
 		if (bfin_jc_tty == NULL && circ_empty(&bfin_jc_write_buf)) {
@@ -140,6 +145,12 @@ bfin_jc_emudat_manager(void *arg)
 				pr_debug("  outgoing data: 0x%08x (pushing %zu)\n", emudat, ate);
 			}
--
 	while (bfin_read_DBGSTAT() & EMUDOF)
 		continue;
 	bfin_write_emudat(count);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (ate < count) {
 		while (bfin_read_DBGSTAT() & EMUDOF)
 			continue;
 		bfin_write_emudat_chars(buf[ate], buf[ate+1], buf[ate+2], buf[ate+3]);
 		ate += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (sel_buffer && sel_buffer_lth > pasted) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (test_bit(TTY_THROTTLED, &tty->flags)) {
@@ -336,6 +341,12 @@ int paste_selection(struct tty_struct *t
 		tty->ldisc->ops->receive_buf(tty, sel_buffer + pasted,
 								NULL, count);
--
 	while (ct--) {
 		unsigned short unicode, fontpos;
 		__get_user(unicode, &list->unicode);
@@ -587,6 +592,12 @@ int con_set_unimap(struct vc_data *vc, u
 		if ((err1 = con_insert_unipair(p, unicode,fontpos)) != 0)
 			err = err1;
--
 	while (*cp) {
 		tty_insert_flip_char(tty, *cp, 0);
 		cp++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while((action = mgsl_bh_action(info)) != 0) {
 	
 		/* Process work item */
@@ -1092,6 +1097,12 @@ static void mgsl_bh_handler(struct work_
 			printk("Unknown work item ID=%08X!\n", action);
 			break;
--
-	while( (Fifocount = (usc_InReg(info,RICR) >> 8)) ) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while( (Fifocount = (usc_InReg(info,RICR) >> 8)) ) {
 		int flag;
 
 		/* read one byte from RxFIFO */
@@ -1517,6 +1533,12 @@ static void mgsl_isr_receive_data( struc
 			 */
--
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while(info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(info) {
 #if SYNCLINK_GENERIC_HDLC
 		hdlcdev_exit(info);
 #endif
@@ -4420,6 +4458,12 @@ static void synclink_cleanup(void)
 		tmp = info;
--
 	while( (Fifocount = usc_InReg(info, TICR) >> 8) && info->xmit_cnt ) {
 		/* there is more space in the transmit FIFO and */
 		/* there is more data in transmit buffer */
@@ -5745,6 +5794,12 @@ static void usc_load_txfifo( struct mgsl
 			}
 			info->icount.tx++;
--
 	while( !Done ) {
 		pBufEntry = &(info->rx_buffer_list[Index]);
 
@@ -6497,6 +6557,12 @@ static void mgsl_free_rx_frame_buffers(
 		Index++;
 		if ( Index == info->rx_buffer_count )
--
 	while( !info->rx_buffer_list[EndIndex].status ) {
 		/*
 		 * If the count field of the buffer entry is non-zero then
@@ -6562,6 +6633,12 @@ static bool mgsl_get_rx_frame(struct mgs
 			}
 			goto Cleanup;
--
-			while(copy_count) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while(copy_count) {
 				int partial_count;
 				if ( copy_count > DMABUFFERSIZE )
 					partial_count = DMABUFFERSIZE;
@@ -6644,6 +6726,12 @@ static bool mgsl_get_rx_frame(struct mgs
 				
--
 	while( BufferSize ){
 		/* Get a pointer to next DMA buffer entry. */
 		pBufEntry = &info->tx_buffer_list[i++];
@@ -6937,6 +7030,12 @@ static void mgsl_load_tx_dma_buffer(stru
 		BufferSize -= Copycount;
 
--
 	while( EndTime-- && !info->irq_occurred ) {
 		msleep_interruptible(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-	while(count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(count) {
 		if (count > 16)
 			linecount = 16;
 		else
@@ -7526,6 +7641,12 @@ static void mgsl_trace_block(struct mgsl
 		
--
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while((action = bh_action(info)) != 0) {
 
 		/* Process work item */
@@ -2033,6 +2049,12 @@ static void bh_handler(struct work_struc
 				__FILE__,__LINE__,info->device_name,action);
 			break;
--
 	while((status = read_reg(info,CST0)) & BIT0)
 	{
 		int flag = 0;
@@ -2215,6 +2242,12 @@ static void isr_rxrdy(SLMP_INFO * info)
 			if (over)
 				tty_insert_flip_char(tty, 0, TTY_OVERRUN);
--
 	while(info) {
 		reset_port(info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while(info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(info) {
 #if SYNCLINK_GENERIC_HDLC
 		hdlcdev_exit(info);
 #endif
@@ -3945,6 +3994,12 @@ static void synclinkmp_cleanup(void)
 		tmp = info;
--
 	while( info->tx_count && (read_reg(info,SR0) & BIT1) ) {
 
 		/* there is more space in the transmit FIFO and */
@@ -4334,6 +4394,12 @@ static void tx_load_fifo(SLMP_INFO *info
 			}
 			info->icount.tx++;
--
 	while(!done) {
 	        /* reset current buffer for reuse */
 		info->rx_buf_list[first].status = 0xff;
@@ -4822,6 +4893,12 @@ static void rx_free_frame_buffers(SLMP_I
 	        first++;
 		if (first == info->rx_buf_count)
--
-			while(copy_count) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while(copy_count) {
 				int partial_count = min(copy_count,SCABUFSIZE);
 				memcpy( ptmp,
 					info->rx_buf_list_ex[index].virt_addr,
@@ -4974,7 +5056,13 @@ CheckAgain:
 
--
 	while( timeout-- && !info->irq_occurred ) {
 		msleep_interruptible(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-	while(count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(count) {
 		if (count > 16)
 			linecount = 16;
 		else
@@ -5464,6 +5568,12 @@ static void trace_block(SLMP_INFO *info,
 
--
 		while (gdl--) {
 			ch = inb(port->ioaddr + UART_RX);
 			tty_insert_flip_char(tty, ch, 0);
 			cnt++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (test_bit(TTY_LDISC_CHANGING, &tty->flags)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (test_bit(TTY_LDISC_CHANGING, &tty->flags)) {
 		mutex_unlock(&tty->ldisc_mutex);
 		tty_unlock();
 		wait_event(tty_ldisc_wait,
 			test_bit(TTY_LDISC_CHANGING, &tty->flags) == 0);
 		tty_lock();
--
 			while (tty_ldisc_wait_idle(tty, timeout) == -EBUSY) {
 				timeout = MAX_SCHEDULE_TIMEOUT;
 				printk_ratelimited(KERN_WARNING
 					"%s: waiting (%s) for %s took too long, but we keep waiting...\n",
 					__func__, get_task_comm(cur_n, current),
 					tty_name(tty, tty_n));
--
 			while (1) {
 				interruptible_sleep_on(&info->delta_msr_wait);
 				/* see if a signal did it */
@@ -1357,6 +1362,12 @@ static int rs_ioctl(struct tty_struct *t
 					return 0;
 				}
--
 	while (count--) {
 		if (*s == '\n')
 			amiga_serial_putc('\r');
 		amiga_serial_putc(*s++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count) {
 		len = min_t(unsigned int, count, EV_BYTE_CHANNEL_MAX_BYTES);
 		do {
@@ -264,6 +269,12 @@ static int ehv_bc_console_byte_channel_s
 		} while (ret == EV_EAGAIN);
 		count -= len;
 		s += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while(count) {
 		linecount = (count > 16) ? 16 : count;
 		for(i=0; i < linecount; i++)
@@ -571,6 +576,12 @@ static void trace_block(struct slgt_info
 		printk("\n");
 		data  += linecount;
--
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while((action = bh_action(info))) {
 		switch (action) {
 		case BH_RECEIVE:
@@ -2002,6 +2029,12 @@ static void bh_handler(struct work_struc
 			DBGBH(("%s unknown action\n", info->device_name));
 			break;
--
 	while (rd_reg16(info, SSR) & IRQ_RXDATA) {
 		reg = rd_reg16(info, RDR);
 		DBGISR(("isr_rxdata %s RDR=%04X\n", info->device_name, reg));
@@ -2155,6 +2193,12 @@ static void isr_rxdata(struct slgt_info
 				i = 0;
 			info->pending_bh |= BH_RECEIVE;
--
 	while((gsr = rd_reg32(info, GSR) & 0xffffff00)) {
 		DBGISR(("%s gsr=%08x\n", info->device_name, gsr));
 		info->irq_occurred = true;
@@ -2395,12 +2444,23 @@ static irqreturn_t slgt_interrupt(int du
 				isr_tdma(info->port_array[i]);
 			spin_unlock(&info->port_array[i]->lock);
--
 		while ((changed = rd_reg32(info, IOSR)) != 0) {
 			DBGISR(("%s iosr=%08x\n", info->device_name, changed));
 			/* read latched state of GPIO signals */
@@ -2411,6 +2471,12 @@ static irqreturn_t slgt_interrupt(int du
 				if (info->port_array[i] != NULL)
 					isr_gpio(info->port_array[i], changed, state);
--
 	while (*head != NULL) {
 		wake_up_interruptible(&(*head)->q);
 		*head = (*head)->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while(info) {
 		reset_port(info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while(info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(info) {
 #if SYNCLINK_GENERIC_HDLC
 		hdlcdev_exit(info);
 #endif
@@ -3772,6 +3865,12 @@ static void slgt_cleanup(void)
 		tmp = info;
--
 	while(!done) {
 		/* reset current buffer for reuse */
 		info->rbufs[i].status = 0;
@@ -4620,6 +4724,12 @@ static void free_rbufs(struct slgt_info
 			done = 1;
 		if (++i == info->rbuf_count)
--
 			while(copy_count) {
 				int partial_count = min_t(int, copy_count, info->rbuf_fill_level);
 				memcpy(p, info->rbufs[i].buf, partial_count);
@@ -4750,6 +4865,12 @@ check_again:
 				copy_count -= partial_count;
 				if (++i == info->rbuf_count)
--
 	while (size) {
 		d = &info->tbufs[i];
 
@@ -4941,6 +5067,12 @@ static bool tx_load(struct slgt_info *in
 
 		if (++i == info->tbuf_count)
--
 		while (dlen--) {
 			if (ct % 8 == 0) {
 				pr_cont("\n");
@@ -518,6 +523,12 @@ static void gsm_print_packet(const char
 			}
 			pr_cont("%02X ", *data++);
--
 	while (len--) {
 		if (*input == GSM1_SOF || *input == GSM1_ESCAPE
 		    || *input == XON || *input == XOFF) {
@@ -551,6 +567,12 @@ static int gsm_stuff_frame(const u8 *inp
 		} else
 			*output++ = *input++;
--
 	while(1) {
 		len = kfifo_len(dlci->fifo);
 		if (len == 0)
@@ -836,6 +863,12 @@ static int gsm_dlci_data_output(struct g
 		WARN_ON(kfifo_out_locked(dlci->fifo, dp , len, &dlci->lock) != len);
 		__gsm_data_queue(dlci, msg);
--
 	while (gsm_read_ea(&addr, *dp++) == 0) {
 		len--;
 		if (len == 0)
 			return;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (gsm_read_ea(&modem, *dp++) == 0) {
 		len--;
 		if (len == 0)
 			return;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (gsm_read_ea(&brk, *dp++) == 0) {
 			len--;
 			if (len == 0)
 				return;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (gsm_read_ea(&addr, *dp++) == 0) {
 		len--;
 		if (len == 0)
 			return;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (gsm_read_ea(&modem, *data++) == 0) {
 				len--;
 				if (len == 0)
 					return;
+					if (_cur < timeout) {
+								rdstcll(_cur);
--
 	while (len-- > 0) {
 		if (gsm_read_ea(&command, *data++) == 1) {
 			int clen = *data++;
@@ -1623,6 +1716,12 @@ static void gsm_dlci_command(struct gsm_
 								data, clen);
 			return;
--
 	while (CIRC_CNT(head, tail, JOBR_DEPTH) >= 1 &&
 	       rd_reg32(&jrp->rregs->outring_used)) {
 
@@ -127,6 +132,12 @@ static void caam_jr_dequeue(unsigned lon
 
 		head = ACCESS_ONCE(jrp->head);
--
-	while (sg_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (sg_count) {
 		sg_to_link_tbl_one(link_tbl_ptr, sg_dma_address(sg),
 				   sg_dma_len(sg), offset);
 		link_tbl_ptr++;
 		sg = sg_next(sg);
 		sg_count--;
--
 	while (nbytes > 0) {
 		sg_nents++;
 		nbytes -= sg->length;
 		if (!sg_is_last(sg) && (sg + 1)->length == 0)
 			BUG(); /* Not support chaining */
 		sg = scatterwalk_sg_next(sg);
--
 	while (!(omap_aes_read(dd, offset) & bit)) {
 		if (time_is_before_jiffies(timeout)) {
 			dev_err(dd->dev, "omap-aes timeout\n");
 			return -ETIMEDOUT;
 		}
+		if (_cur < timeout) {
--
 	while (buflen && total) {
 		count = min((*sg)->length - *offset, total);
 		count = min(count, buflen);
@@ -422,6 +438,12 @@ static int sg_copy(struct scatterlist **
 			else
 				total = 0;
--
-	while (!(omap_sham_read(dd, offset) & bit)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (!(omap_sham_read(dd, offset) & bit)) {
 		if (time_is_before_jiffies(timeout))
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-	while (nbytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nbytes) {
 		sg = &dst[i];
 		sg_len = sg->length;
 		addr = dma_map_page(dev->core_dev->device, sg_page(sg),
@@ -583,6 +588,12 @@ static void crypto4xx_copy_pkt_to_dst(st
 			}
--
 		while (nbytes) {
 			sd_idx = get_next_sd(sd_idx);
 			sd = crypto4xx_get_sdp(dev, &sd_dma, sd_idx);
@@ -971,6 +987,12 @@ u32 crypto4xx_build_pd(struct crypto_asy
 				 * which is more than nbytes, so done.
 				 */
--
-	while (core_dev->dev->pdr_head != core_dev->dev->pdr_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (core_dev->dev->pdr_head != core_dev->dev->pdr_tail) {
 		tail = core_dev->dev->pdr_tail;
 		pd_uinfo = core_dev->dev->pdr_uinfo +
 			sizeof(struct pd_uinfo)*tail;
@@ -1100,6 +1127,12 @@ static void crypto4xx_bh_tasklet_cb(unsi
 			/* if tail not done, break */
--
 	while (nbytes > 0) {
 		ent = spu_queue_next(qp, ent);
 
@@ -577,6 +582,12 @@ static int n2_do_async_digest(struct aha
 		ent->dest_addr = 0UL;
 
--
 	while (priv->chan[ch].fifo[tail].desc) {
 		request = &priv->chan[ch].fifo[tail];
 
@@ -389,6 +394,12 @@ static void flush_channel(struct device
 			return;
 		spin_lock_irqsave(&priv->chan[ch].tail_lock, flags);
--
 	while (priv->chan[ch].fifo[tail].dma_desc != cur_desc) {
 		tail = (tail + 1) & (priv->fifo_len - 1);
 		if (tail == priv->chan[ch].tail) {
 			dev_err(dev, "couldn't locate current descriptor\n");
 			return 0;
 		}
--
-		while (sg) {
-			dma_map_sg(dev, sg, 1, dir);
-			sg = scatterwalk_sg_next(sg);
+	if (unlikely(chained)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
--
+			while (sg) {
+				dma_map_sg(dev, sg, 1, dir);
+				sg = scatterwalk_sg_next(sg);
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
--
 	while (sg) {
 		dma_unmap_sg(dev, sg, 1, dir);
 		sg = scatterwalk_sg_next(sg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (n_sg--) {
 		to_talitos_ptr(link_tbl_ptr, sg_dma_address(sg));
 		link_tbl_ptr->len = cpu_to_be16(sg_dma_len(sg));
@@ -981,16 +1031,33 @@ static int sg_to_link_tbl(struct scatter
 		link_tbl_ptr++;
 		cryptlen -= sg_dma_len(sg);
--
 	while (be16_to_cpu(link_tbl_ptr->len) <= (-cryptlen)) {
 		/* Empty this entry, and move to previous one */
 		cryptlen += be16_to_cpu(link_tbl_ptr->len);
 		link_tbl_ptr->len = 0;
 		sg_count--;
 		link_tbl_ptr--;
--
 	while (nbytes > 0) {
 		sg_nents++;
 		nbytes -= sg->length;
 		if (!sg_is_last(sg) && (sg + 1)->length == 0)
 			*chained = 1;
 		sg = scatterwalk_sg_next(sg);
--
 	while (sg_miter_next(&miter) && offset < total_buffer) {
 		unsigned int len;
 		unsigned int ignore;
@@ -1193,6 +1276,12 @@ static size_t sg_copy_end_to_buffer(stru
 			boffset += len;
 		}
--
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		padlock_xcrypt_ecb(walk.src.virt.addr, walk.dst.virt.addr,
 				   ctx->E, &ctx->cword.encrypt,
 				   nbytes / AES_BLOCK_SIZE);
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
--
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		padlock_xcrypt_ecb(walk.src.virt.addr, walk.dst.virt.addr,
 				   ctx->D, &ctx->cword.decrypt,
 				   nbytes / AES_BLOCK_SIZE);
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
--
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		u8 *iv = padlock_xcrypt_cbc(walk.src.virt.addr,
 					    walk.dst.virt.addr, ctx->E,
 					    walk.iv, &ctx->cword.encrypt,
@@ -442,6 +469,12 @@ static int cbc_aes_encrypt(struct blkcip
 		memcpy(walk.iv, iv, AES_BLOCK_SIZE);
--
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		padlock_xcrypt_cbc(walk.src.virt.addr, walk.dst.virt.addr,
 				   ctx->D, walk.iv, &ctx->cword.decrypt,
 				   nbytes / AES_BLOCK_SIZE);
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
--
 	while (len) {
 		if (!p->sg_src_left) {
 			ret = sg_miter_next(&p->src_sg_it);
@@ -207,6 +212,12 @@ static void copy_src_to_buf(struct req_p
 
 		len -= copy_len;
--
 	while (sl) {
 		cur_len = sl[i].length;
 		++i;
@@ -491,6 +507,12 @@ static int count_sgs(struct scatterlist
 			total_bytes -= cur_len;
 		else
--
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -328,6 +333,12 @@ geode_cbc_decrypt(struct blkcipher_desc
 
 		nbytes -= ret;
--
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -359,6 +375,12 @@ geode_cbc_encrypt(struct blkcipher_desc
 		ret = geode_aes_crypt(op);
 		nbytes -= ret;
--
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -439,6 +466,12 @@ geode_ecb_decrypt(struct blkcipher_desc
 		ret = geode_aes_crypt(op);
 		nbytes -= ret;
--
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -469,6 +507,12 @@ geode_ecb_encrypt(struct blkcipher_desc
 		ret = geode_aes_crypt(op);
 		nbytes -= ret;
--
 	while (nbytes > 0) {
 		++sg_nents;
 		nbytes -= sg->length;
 		sg = sg_next(sg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&engine->pending) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&engine->pending) &&
 	       engine->in_flight + 1 <= engine->fifo_sz) {
 
 		++engine->in_flight;
@@ -684,6 +700,12 @@ static void spacc_push(struct spacc_engi
 		list_move_tail(&req->list, &engine->in_progress);
--
-	while (!spacc_fifo_stat_empty(engine)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!spacc_fifo_stat_empty(engine)) {
 		req = list_first_entry(&engine->in_progress, struct spacc_req,
 				       list);
 		list_move_tail(&req->list, &engine->completed);
@@ -1190,6 +1217,12 @@ static void spacc_process_done(struct sp
 				break;
--
 	while (n) {
 		spage = sg_page(src);
 		soff = src->offset;
@@ -1387,10 +1392,21 @@ static int hifn_setup_dma(struct hifn_de
 
 		src++;
--
 	while (n) {
 		if (t->length && rctx->walk.flags & ASYNC_FLAGS_MISALIGNED) {
 			BUG_ON(!sg_page(t));
@@ -1410,6 +1426,12 @@ static int hifn_setup_dma(struct hifn_de
 		dst++;
 		t++;
--
-	while (size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size) {
 		copy = min3(drest, size, dst->length);
 
 		size -= copy;
@@ -1478,6 +1505,12 @@ static int ablkcipher_add(unsigned int *
 
--
 	while (nbytes) {
 		if (idx >= w->num && (w->flags & ASYNC_FLAGS_MISALIGNED))
 			return -EINVAL;
@@ -1567,6 +1605,12 @@ static int hifn_cipher_walk(struct ablkc
 		}
 
--
 	while (nbytes) {
 		dst = &req->dst[idx];
 		dlen = min(dst->length, nbytes);
@@ -1597,6 +1646,12 @@ static int hifn_setup_session(struct abl
 
 		nbytes -= dlen;
--
 	while (size) {
 		copy = min3(srest, dst->length, size);
 
@@ -1746,6 +1806,12 @@ static int ablkcipher_get(void *saddr, u
 
 		dst++;
--
 	while ((async_req = crypto_dequeue_request(&dev->queue))) {
 		req = container_of(async_req, struct ablkcipher_request, base);
 		spin_unlock_irqrestore(&dev->lock, flags);
@@ -2040,6 +2111,12 @@ static void hifn_flush(struct hifn_devic
 		hifn_process_ready(req, -ENODEV);
 
--
 	while (buf) {
 		struct buffer_desc *buf1;
 		u32 phys1;
@@ -340,6 +345,12 @@ static void free_buf_chain(struct device
 		dma_pool_free(buffer_pool, buf, phys);
 		buf = buf1;
--
 	while (nbits >= 8) {
 		iwb->data[write++] = data & 0xff;
 		write %= BAS_OUTBUFSIZE;
 		data >>= 8;
 		nbits -= 8;
+		if (_cur < timeout) {
--
 	while (count-- > 0) {
 		if (i > sizeof(dbgline) - 4) {
 			dbgline[i] = '\0';
@@ -233,6 +249,12 @@ static inline void dump_bytes(enum debug
 		i++;
 		dbgline[i++] = hex_asc_hi(c);
--
 	while (count-- > 0) {
 		c = *in++;
 		ones = hdlc_bitstuff_byte(iwb, c, ones);
 		fcs = crc_ccitt_byte(fcs, c);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (count--) {
 		unsigned char c = *src++;
 		unsigned char tabentry = bitcounts[c];
@@ -815,6 +853,12 @@ static inline void hdlc_unpack(unsigned
 			}
 		}
--
 	while (count > 0) {
 		dst = skb_put(skb, count < dobytes ? count : dobytes);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (count > 0 && dobytes > 0) {
 			*dst++ = bitrev8(*src++);
 			count--;
 			dobytes--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (numbytes--) {
 		c = *src++;
 		switch (c) {
@@ -929,6 +1000,12 @@ static void cmd_loop(unsigned char *src,
 				cs->respdata[cbytes] = c;
 			cbytes++;
--
 	while (head != (tail = inbuf->tail)) {
 		gig_dbg(DEBUG_INTR, "buffer state: %u -> %u", head, tail);
 		if (head > tail)
@@ -966,6 +1048,12 @@ void gigaset_isoc_input(struct inbuf_t *
 			head = 0;
 		gig_dbg(DEBUG_INTR, "setting head to %u", head);
--
 	while (cb && !cb->len) {
 		spin_lock_irqsave(&cs->cmdlock, flags);
 		cs->cmdbytes -= cs->curlen;
@@ -148,6 +153,12 @@ static int send_cb(struct cardstate *cs)
 		if (tcb->wake_tasklet)
 			tasklet_schedule(tcb->wake_tasklet);
--
 	while ((cb = cs->cmdbuf) != NULL) {
 		cs->cmdbuf = cb->next;
 		if (cb->wake_tasklet)
 			tasklet_schedule(cb->wake_tasklet);
 		kfree(cb);
+		if (_cur < timeout) {
--
 	while (tail != head) {
 		ev = cs->events + head;
 		kfree(ev->ptr);
 		head = (head + 1) % MAX_EVENTS;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (cb) {
 		tcb = cb;
 		cb = cb->next;
 		kfree(tcb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((cb = cs->cmdbuf) != NULL && (ucs->basstate & BS_ATREADY)) {
 		ucs->retry_cmd_out = 0;
 		rc = atwrite_submit(cs, cb->buf, cb->len);
@@ -1945,6 +1950,12 @@ static int start_cbsend(struct cardstate
 			retval = rc;
 			complete_cb(cs);
--
 	while (*in) {
 		if (!isxdigit(in[0]) || !isxdigit(in[1]) || l >= maxlen)
 			return -1;
 		out[++l] = (hex_to_bin(in[0]) << 4) + hex_to_bin(in[1]);
 		in += 2;
+		if (_cur < timeout) {
--
 	while (i-- > 0) {
 		/* ToDo: conversion to upper case necessary? */
 		*out++ = toupper(hex_asc_hi(*++in));
 		*out++ = toupper(hex_asc_lo(*in));
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count--) {
 		*pout++ = hex_asc_hi(*++ie);
 		*pout++ = hex_asc_lo(*ie);
 		*pout++ = ' ';
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (ap->bcnext) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ap->bcnext) {
 		/* this should never happen */
 		dev_warn(cs->dev, "%s: dropping extra application %u\n",
 			 __func__, ap->bcnext->id);
 		send_disconnect_ind(bcs, ap->bcnext,
 				    CapiCallGivenToOtherApplication);
--
 	while (bcs->ap != NULL) {
 		ap = bcs->ap;
 		bcs->ap = ap->bcnext;
@@ -831,6 +880,12 @@ void gigaset_isdn_hupD(struct bc_state *
 		send_disconnect_b3_ind(bcs, ap);
 		send_disconnect_ind(bcs, ap, 0);
--
-	while (ap->bcnext) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ap->bcnext) {
 		/* this should never happen */
 		dev_warn(cs->dev, "%s: dropping extra application %u\n",
 			 __func__, ap->bcnext->id);
 		send_disconnect_ind(bcs, ap->bcnext,
 				    CapiCallGivenToOtherApplication);
--
 		while (bcs->ap != NULL) {
 			oap = bcs->ap;
 			bcs->ap = oap->bcnext;
@@ -1612,6 +1683,12 @@ static void do_connect_resp(struct gigas
 					CapiCallGivenToOtherApplication);
 				spin_lock_irqsave(&bcs->aplock, flags);
--
 		while (bcs->ap != NULL) {
 			oap = bcs->ap;
 			bcs->ap = oap->bcnext;
@@ -1722,6 +1804,12 @@ static void do_connect_resp(struct gigas
 					CapiCallGivenToOtherApplication);
 				spin_lock_irqsave(&bcs->aplock, flags);
--
 	while (atomic_sub_return(1, &iif->sendqlen) > 0) {
 		skb = skb_dequeue(&iif->sendqueue);
 		if (!skb) {
@@ -2235,6 +2328,12 @@ static u16 gigaset_send_message(struct c
 			continue;
 		}
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -320,6 +325,12 @@ setup_teles3(struct IsdnCard *card)
 			}
 			ipid++;
--
 		while (stptr != NULL) {
 			stptr->l1.l1l2(stptr, PH_PAUSE | CONFIRM, NULL);
 			stptr = stptr->next;
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		/* while Data in Fifo ... */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ( (stat & 2) && ((ptr-cs->rcvbuf) < MAX_DFRAME_LEN_L1) ) {
 			*ptr = rByteAMD(cs, 0x04); // DCRB
 			ptr++;
@@ -328,7 +344,13 @@ Amd7930_empty_Dfifo(struct IsdnCardState
 				cs->rcvidx = 0;
 				schedule_event(cs, D_RCVBUFREADY);
--
         /* while free place in tx-fifo available and data in sk-buffer */
         txstat = 0x10;
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
--
         while((txstat & 0x10) && (cs->tx_cnt < len)) {
                 wByteAMD(cs, 0x04, *ptr);
                 ptr++;
                 cs->tx_cnt++;
                 txstat= rByteAMD(cs, 0x07);
+                if (_cur < timeout) {
--
  while (irflags)
  {
 
@@ -550,6 +588,12 @@ void Amd7930_interrupt(struct IsdnCardSt
 
         /* reads Interrupt-Register again. If there is a new interrupt-flag: restart handler */
--
 			while (stptr != NULL) {
 				stptr->l1.l1l2(stptr, PH_PAUSE | INDICATION, NULL);
 				stptr = stptr->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len--) {
 		if (b & 0x80)
 			*dp++ = '1';
 		else
 			*dp++ = '0';
 		b = b << 1;
--
 	while (l--) {
 		dp += sprintf(dp, "    octet %d%c ", octet, ch);
 		dp += prbits(dp, *p++, 8, 8);
@@ -737,6 +753,12 @@ general(char *dest, u_char * p)
 			ch = 'a';
 		else
--
 	while (l--) {
 		dp += sprintf(dp, "    octet %d%c ", octet, ch);
 		dp += prbits(dp, *p, 8, 8);
@@ -764,6 +791,12 @@ general_ni1(char *dest, u_char * p)
 			ch = 'a';
 		else
--
 	while (l > 0) {
 		tag = *p++;
 		len = *p++;
@@ -903,6 +941,12 @@ disptext_ni1(char *dest, u_char * p)
 			}
 			dp += sprintf(dp, "\n");
--
 	while (l--) {
 		dp += sprintf(dp, "%c", *p++);
 
@@ -929,6 +978,12 @@ display(char *dest, u_char * p)
 
 		else
--
 	while (l > 0) {
 		dp += sprintf(dp, "   octet 4 ");
 		dp += prbits(dp, *p++, 8, 8);
@@ -955,11 +1015,28 @@ prfacility(char *dest, u_char * p)
 		dp += sprintf(dp, "   octet 5 %d\n", l2 = *p++ & 0x7f);
 		l -= 2;
--
 		while (l2--) {
 			dp += sprintf(dp, "%2x ", *p++);
 			l--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (buf < bend) {
 			/* Is it a single octet information element? */
 			if (*buf & 0x80) {
@@ -1349,6 +1431,12 @@ dlogframe(struct IsdnCardState *cs, stru
 				cs_fest = 0;
 			}
--
 		while (buf < bend) {
 			/* Is it a single octet information element? */
 			if (*buf & 0x80) {
@@ -1435,6 +1528,12 @@ dlogframe(struct IsdnCardState *cs, stru
 				cs_fest = 0;
 			}
--
 		while (buf < bend) {
 			/* Is it a single octet information element? */
 			if (*buf & 0x80) {
@@ -1504,6 +1608,12 @@ dlogframe(struct IsdnCardState *cs, stru
 
 			/* Skip to next element */
--
 	while (packet_offset < len) {
 		desc = &urb->iso_frame_desc[num_packets];
 		desc->offset = packet_offset;
@@ -347,6 +352,12 @@ static void usb_d_out(struct st5481_adap
 			desc->length = len - packet_offset;
 		num_packets++;
--
 	while (((sval = bytein(cs->hw.avm.cfg_reg)) & 0xf) != 0x7) {
 		if (!(sval & AVM_A1_STAT_TIMER)) {
 			byteout(cs->hw.avm.cfg_reg, 0x1E);
@@ -123,6 +128,12 @@ avm_a1_interrupt(int intno, void *dev_id
 			if (val)
 				isac_interrupt(cs, val);
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -962,6 +967,12 @@ setup_elsa_isapnp(struct IsdnCard *card)
 			}
 			ipid++;
--
 	while (!(ReadReg(cs, HFCD_DATA, HFCD_STAT) & HFCD_BUSY) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((ReadReg(cs, HFCD_STATUS, HFCD_STATUS) & HFCD_BUSY) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (idx++ < count) {
 			WaitNoBusy(cs);
 			ReadReg(cs, HFCD_DATA_NODEB, cip);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((f1 != f2) && count--) {
 		z1 = ReadZReg(cs, HFCD_FIFO | HFCD_Z1 | HFCD_REC);
 		z2 = ReadZReg(cs, HFCD_FIFO | HFCD_Z2 | HFCD_REC);
@@ -680,6 +718,12 @@ int receive_dmsg(struct IsdnCardState *c
 		cip = HFCD_FIFO | HFCD_F2 | HFCD_REC;
 		WaitNoBusy(cs);
--
 	while (val) {
 		if (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {
 			cs->hw.hfcD.int_s1 |= val;
@@ -896,6 +945,12 @@ hfc2bds0_interrupt(struct IsdnCardState
 				debugl1(cs, "HFCD irq %x loop %d", val, 15-count);
 		} else
--
 	while(ipid->card_vendor) {
 		if ((pnp_c = pnp_find_card(ipid->card_vendor,
 			ipid->card_device, pnp_c))) {
@@ -584,6 +589,12 @@ setup_sedlbauer_isapnp(struct IsdnCard *
 		}
 		ipid++;
--
-			while (bytecnt) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (bytecnt) {
 				ver = ISARVersion(cs, "Sedlbauer:");
 				if (ver < 0)
 					printk(KERN_WARNING
@@ -843,6 +859,12 @@ ready:
 					break;
--
 	while (st) {
 		FsmDelTimer(&st->ma.t202, 1);
 		st = st->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (len < buf_size) {
 		if ((skb = b_out->tx_skb)) {
 			DBG_SKB(0x100, skb);
@@ -105,6 +110,12 @@ static void usb_b_out(struct st5481_bcs
 						       urb->transfer_buffer+len, buf_size-len);
 			}
--
 	/* while there are bytes left... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p < pend) {
 		if ((*p & 0xf0) == 0x90) {
 			codeset = *p & 0x07;
@@ -118,6 +123,12 @@ findie(u_char * p, int size, u_char ie,
 			p += l;
 			codeset = maincodeset;
--
 	while (np) {
 		if (np == p) {
 			StopAllL3Timer(p);
@@ -307,6 +323,12 @@ release_l3_process(struct l3_process *p)
 		}
 		pp = np;
--
 	while (p) {
 		/* p might be kfreed under us, so we need to save where we want to go on */
 		np = p->next;
 		st->l3.l3ml3(st, pr, p);
 		p = np;
+		if (_cur < timeout) {
--
 	while ((skb = skb_dequeue(&st->l3.squeue))) {
 		st->l3.l3l2(st, DL_DATA | REQUEST, skb);
 		dequeued++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = skb_dequeue(&st->l3.squeue))) {
 		st->l3.l3l2(st, DL_DATA | REQUEST, skb);
 		dequeued++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -209,6 +214,12 @@ setup_hfcs(struct IsdnCard *card)
 			}
 			ipid++;
--
 		while (stptr != NULL) {
 			stptr->l1.l1l2(stptr, PH_PAUSE | CONFIRM, NULL);
 			stptr = stptr->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 			while (stptr != NULL) {
 				stptr->l1.l1l2(stptr, PH_PAUSE | INDICATION, NULL);
 				stptr = stptr->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	    while (count) {
 	      count--; /* empty fifo */
 	      Read_hfc(cs, HFCSX_FIF_DRD);
+	      if (_cur < timeout) {
+		  rdstcll(_cur);
+	      }
--
 	while (1) {
 	  Write_hfc(cs, HFCSX_CIRM, HFCSX_RESET | cs->hw.hfcsx.cirm ); /* Reset */
 	  mdelay(30);
@@ -363,6 +379,12 @@ reset_hfcsx(struct IsdnCardState *cs)
 	  cs->hw.hfcsx.last_fifo = 0xff; /* invalidate */
 	  if (!set_fifo_size(cs)) continue;
--
 	while (val) {
 		if (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {
 			cs->hw.hfcsx.int_s1 |= val;
@@ -851,6 +878,12 @@ hfcsx_interrupt(int intno, void *dev_id)
 				debugl1(cs, "HFC-SX irq %x loop %d", val, 15 - count);
 		} else
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -1435,6 +1473,12 @@ setup_hfcsx(struct IsdnCard *card)
 			}
 			ipid++;
--
 	while (i < ((bch) ? cs->chanlimit : (2 + MAX_WAITING_CALLS))) {
 		if (chanp->fi.state == ST_NULL)
 			return (chanp);
 		chanp++;
 		i++;
+		if (_cur < timeout) {
--
 		while (i < (2 + MAX_WAITING_CALLS)) {
 			if (chanp->fi.state == ST_NULL)
 				return (chanp);
 			chanp++;
 			i++;
+			if (_cur < timeout) {
--
 			while (i < 2) {
 				FsmEvent(&chanp->fi, event, NULL);
 				chanp++;
 				i++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (stptr != NULL) {
 			stptr->l1.l1l2(stptr, PH_PAUSE | CONFIRM, NULL);
 			stptr = stptr->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 			while (stptr != NULL) {
 				stptr->l1.l1l2(stptr, PH_PAUSE | INDICATION, NULL);
 				stptr = stptr->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while ((READHSCX(cs, hscx, HSCX_STAR) & 0x04) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((READHSCX(cs, hscx, HSCX_STAR) & 0x44) != 0x40) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((request = init_cmd_table[i++])) {
 		value = init_cmd_table[i++];
 		st5481_usb_device_ctrl_msg(adapter, request, value, NULL, NULL);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 			while (len--) {
 				*dst++ = *src++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
-	while (i>0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i>0) {
 		if (i>16)
 			j=16;
 		else
@@ -181,6 +186,12 @@ static void printframe(struct IsdnCardSt
 		i -= j;
--
 		while (8>bitcnt++) {
 			s_val >>= 1;
 			s_val |= 0x80;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (8>bitcnt++) {
 			s_val >>= 1;
 			s_val |= 0x80;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-	while (!(cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {
 		val = cs->BC_Read_Reg(cs, HFC_DATA, HFC_CIP | HFC_F2 |
 				      (cs->hw.hfc.cip & 3));
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
--
 	while ((cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((f1 != f2) || (z1 != z2)) && cnt--) {
 		if (cs->debug & L1_DEB_HSCX)
 			debugl1(cs, "hfc clear %d f1(%d) f2(%d)",
@@ -116,9 +143,20 @@ hfc_clear_fifo(struct BCState *bcs)
 				bcs->channel, z1, z2, rcnt);
 		cip = HFC_CIP | HFC_FIFO_OUT | HFC_REC | HFC_CHANNEL(bcs->channel);
--
 		while ((idx < rcnt) && WaitNoBusy(cs)) {
 			cs->BC_Read_Reg(cs, HFC_DATA_NODEB, cip);
 			idx++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while ((idx < count) && WaitNoBusy(cs)) {
 			*ptr++ = cs->BC_Read_Reg(cs, HFC_DATA_NODEB, cip);
 			idx++;
+			if (_cur < timeout) {
+			  rdstcll(_cur);
+			}
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -362,6 +367,12 @@ setup_asuscom(struct IsdnCard *card)
 			}
 			ipid++;
--
-	while (st) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (st) {
 		if (test_and_clear_bit(FLG_L1_ACTIVATING, &st->l1.Flags))
 			st->l1.l1l2(st, PH_ACTIVATE | CONFIRM, NULL);
 		else
 			st->l1.l1l2(st, PH_ACTIVATE | INDICATION, NULL);
 		st = st->next;
--
 	while (st) {
 		if (test_bit(FLG_L1_DBUSY, &cs->HW_Flags))
 			st->l1.l1l2(st, PH_PAUSE | CONFIRM, NULL);
 		st->l1.l1l2(st, PH_DEACTIVATE | INDICATION, NULL);
 		st = st->next;
+		if (_cur < timeout) {
--
 	while (stptr != NULL) {
 		if (test_and_clear_bit(FLG_L1_PULL_REQ, &stptr->l1.Flags)) {
 			stptr->l1.l1l2(stptr, PH_PULL | CONFIRM, NULL);
 			break;
 		} else
 			stptr = stptr->next;
--
-	while ((skb = skb_dequeue(&cs->rq))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((skb = skb_dequeue(&cs->rq))) {
 #ifdef L2FRAME_DEBUG		/* psa */
 		if (cs->debug & L1_DEB_LAPD)
 			Logl2Frame(cs, skb, "PH_DATA", 1);
@@ -234,20 +272,42 @@ DChannel_proc_rcv(struct IsdnCardState *
 			dlogframe(cs, skb, 1);
--
-				while (stptr != NULL) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (stptr != NULL) {
 					if ((nskb = skb_clone(skb, GFP_ATOMIC)))
 						stptr->l1.l1l2(stptr, PH_DATA | INDICATION, nskb);
 					else
 						printk(KERN_WARNING "HiSax: isdn broadcast buffer shortage\n");
 					stptr = stptr->next;
--
-				while (stptr != NULL) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (stptr != NULL) {
 					if ((nskb = skb_clone(skb, GFP_ATOMIC)))
 						stptr->l1.l1tei(stptr, PH_DATA | INDICATION, nskb);
 					else
 						printk(KERN_WARNING "HiSax: tei broadcast buffer shortage\n");
 					stptr = stptr->next;
--
 	while ((skb = skb_dequeue(&bcs->rqueue))) {
 		bcs->st->l1.l1l2(bcs->st, PH_DATA | INDICATION, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (st) {
 		switch(pr) {
 			case (HW_RESET | INDICATION):
@@ -871,6 +953,12 @@ l1_msg(struct IsdnCardState *cs, int pr,
 				break;
 		}
--
 		while (stptr != NULL) {
 			stptr->l1.l1l2(stptr, PH_PAUSE | CONFIRM, NULL);
 			stptr = stptr->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 			while (stptr != NULL) {
 				stptr->l1.l1l2(stptr, PH_PAUSE | INDICATION, NULL);
 				stptr = stptr->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (argc && (i < HISAX_MAX_CARDS)) {
 		cards[i].protocol = DEFAULT_PROTO;
 		if (argc) {
@@ -440,7 +445,13 @@ static int __init HiSax_setup(char *line
 			argc--;
 		}
--
-		while (count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (count) {
 			if (count > HISAX_STATUS_BUFSIZE)
 				cnt = HISAX_STATUS_BUFSIZE;
 			else
@@ -627,6 +643,12 @@ static int HiSax_readstatus(u_char __use
 			p += cnt;
--
-	while (cnt) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt) {
 		cs->cardmsg(cs, CARD_INIT, NULL);
 		/* Timeout 10ms */
 		msleep(10);
@@ -848,6 +875,12 @@ static int init_card(struct IsdnCardStat
 			cs->cardmsg(cs, CARD_TEST, NULL);
--
 	while (i <= last) {
 		cards[i] = cards[i + 1];
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = skb_dequeue(&d_if->erq)) != NULL) {
 		if (cs->debug & DEB_DLOG_HEX) {
 			ptr = cs->dlog;
@@ -1911,6 +1960,12 @@ static void EChannel_proc_rcv(struct his
 						skb->len);
 		}
--
 	while (((df->f1 & D_FREG_MASK) != (df->f2 & D_FREG_MASK)) && count--) {
 		zp = &df->za[df->f2 & D_FREG_MASK];
 		rcnt = zp->z1 - zp->z2;
@@ -386,6 +391,12 @@ receive_dmsg(struct IsdnCardState *cs)
 			sched_event_D_pci(cs, D_RCVBUFREADY);
 		} else
--
 		while ((fcnt < 2 * HFCPCI_BTRANS_THRESHOLD) && (bcs->tx_skb)) {
 			if (bcs->tx_skb->len < B_FIFO_SIZE - fcnt) {
 				/* data is suitable for fifo */
@@ -658,6 +674,12 @@ hfcpci_fill_fifo(struct BCState *bcs)
 
 			dev_kfree_skb_any(bcs->tx_skb);
--
 	while (val) {
 		if (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {
 			cs->hw.hfcpci.int_s1 |= val;
@@ -1086,6 +1113,12 @@ hfcpci_interrupt(int intno, void *dev_id
 				debugl1(cs, "HFC-PCI irq %x loop %d", val, 15 - count);
 		} else
--
 	while (((in8 = Read_hfc8(hw, reg)) != ref8)) {
 		ref8 = in8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (((in16 = Read_hfc16(hw, reg)) != ref16)) {
 		ref16 = in16;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-				while (z1 >= 4) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (z1 >= 4) {
 #ifdef HISAX_HFC4S8S_PCIMEM
 					Read_hfc32(l1p->hw, A_FIFO_DATA0);
 #else
 					fRead_hfc32(l1p->hw);
 #endif
--
 				while (z1--)
@@ -757,7 +790,12 @@ rx_d_frame(struct hfc4s8s_l1 *l1p, int e
 		SetRegAddr(l1p->hw, A_FIFO_DATA0);
 #endif
 
-		while (z1 >= 4) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (z1 >= 4) {
 #ifdef HISAX_HFC4S8S_PCIMEM
 			*((unsigned long *) cp) =
 			    Read_hfc32(l1p->hw, A_FIFO_DATA0);
@@ -766,6 +804,12 @@ rx_d_frame(struct hfc4s8s_l1 *l1p, int e
 #endif
--
 		while (z1--)
@@ -863,7 +907,12 @@ rx_b_frame(struct hfc4s8s_btype *bch)
 		SetRegAddr(l1->hw, A_FIFO_DATA0);
 #endif
 
-		while (z1 >= 4) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (z1 >= 4) {
 #ifdef HISAX_HFC4S8S_PCIMEM
 			*((unsigned long *) bch->rx_ptr) =
 			    Read_hfc32(l1->hw, A_FIFO_DATA0);
@@ -873,6 +922,12 @@ rx_b_frame(struct hfc4s8s_btype *bch)
 #endif
--
 		while (z1--)
@@ -944,7 +999,12 @@ tx_d_frame(struct hfc4s8s_l1 *l1p)
 		SetRegAddr(l1p->hw, A_FIFO_DATA0);
 #endif
 
-		while (cnt >= 4) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (cnt >= 4) {
 #ifdef HISAX_HFC4S8S_PCIMEM
 			fWrite_hfc32(l1p->hw, A_FIFO_DATA0,
 				     *(unsigned long *) cp);
@@ -954,7 +1014,13 @@ tx_d_frame(struct hfc4s8s_l1 *l1p)
 #endif
--
 		while (cnt--)
@@ -1040,7 +1106,12 @@ tx_b_frame(struct hfc4s8s_btype *bch)
 #ifndef HISAX_HFC4S8S_PCIMEM
 		SetRegAddr(l1->hw, A_FIFO_DATA0);
 #endif
-		while (cnt >= 4) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (cnt >= 4) {
 #ifdef HISAX_HFC4S8S_PCIMEM
 			fWrite_hfc32(l1->hw, A_FIFO_DATA0,
 				     *(unsigned long *) cp);
@@ -1049,6 +1120,12 @@ tx_b_frame(struct hfc4s8s_btype *bch)
 #endif
--
 		while (cnt--)
@@ -1095,6 +1172,11 @@ hfc4s8s_bh(struct work_struct *work)
 	/* handle layer 1 state changes */
 	b = 1;
 	l1p = hw->l1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
--
 	while (b) {
 		if ((b & hw->mr.r_irq_statech)) {
 			/* reset l1 event */
@@ -1197,12 +1279,23 @@ hfc4s8s_bh(struct work_struct *work)
 		}
 		b <<= 1;
--
 	while (idx < hw->driver_data.max_st_ports) {
 
 		if (hw->mr.timer_irq) {
@@ -1216,6 +1309,11 @@ hfc4s8s_bh(struct work_struct *work)
 		/* ignore fifo 6 (TX E fifo) */
 		*fifo_stat &= 0xff - 0x40;
--
 		while (*fifo_stat) {
 
 			if (!l1p->nt_mode) {
@@ -1255,10 +1353,22 @@ hfc4s8s_bh(struct work_struct *work)
 				*fifo_stat &= ~0x4;
 				tx_b_frame(l1p->b_ch + 1);
--
 		while (ovr) {
 			if ((ovr & 1)) {
 				*ovp |= Read_hfc8(hw, idx);
@@ -1316,6 +1431,12 @@ hfc4s8s_interrupt(int intno, void *dev_i
 			ovp++;
 			idx++;
--
   	while ((READJADE(cs, jade, jade_HDLC_STAR) & mask) && to) {
   		udelay(1);
   		to--;
+  		if (_cur < timeout) {
+  		  	rdstcll(_cur);
+  		}
--
 	while (((sval = bytein(cs->hw.diva.ctrl)) & DIVA_IRQ_REQ) && cnt) {
 		val = readreg(cs->hw.diva.hscx_adr, cs->hw.diva.hscx, HSCX_ISTA + 0x40);
 		if (val)
@@ -303,6 +308,12 @@ diva_interrupt(int intno, void *dev_id)
 		if (val)
 			isac_interrupt(cs, val);
--
 	while ((MemReadHSCX(cs, hscx, HSCX_STAR) & 0x04) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((MemReadHSCX(cs, hscx, HSCX_STAR) & 0x44) != 0x40) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while(ipid->card_vendor) {
 		if ((pnp_c = pnp_find_card(ipid->card_vendor,
 			ipid->card_device, pnp_c))) {
@@ -1134,6 +1172,12 @@ static int __devinit setup_diva_isapnp(s
 		}
 		ipid++;
--
 	while ((sval = (~bytein(cs->hw.avm.cfg_reg+ASL0_OFFSET) & ASL0_R_IRQPENDING))) {
 		if (cs->debug & L1_DEB_INTSTAT)
 			debugl1(cs, "avm IntStatus %x", sval);
@@ -160,6 +165,12 @@ avm_a1p_interrupt(int intno, void *dev_i
 			if (val)
 				isac_interrupt(cs, val);
--
 	while ((i) && (p->prot.ni1.invoke_used[retval >> 3] == 0xFF)) {
 		p->prot.ni1.last_invoke_id = (retval & 0xF8) + 8;
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (p->prot.ni1.invoke_used[retval >> 3] & (1 << (retval & 7)))
@@ -114,10 +125,21 @@ l3ni1_search_dummy_proc(struct PStack *s
 
   if (!id) return(NULL);
 
-  while (pc)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
+   while (pc)
    { if ((pc->callref == -1) && (pc->prot.ni1.invoke_id == id))
        return(pc);
      pc = pc->next;
+     if (_cur < timeout) {
+       rdstcll(_cur);
--
 	while (qd_len > 0 && !(*p & 0x80)) {	/* extension ? */
 		p++;
 		qd_len--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (ilen > 0) 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+          unsigned long long timeout;
+          timeout = rdstcll(start) + delta;
+          while (ilen > 0) 
           { id = (id << 8) | (*p++ & 0xFF);	/* invoke identifier */
 	    ilen--;
-	  }
+	    if (_cur < timeout) {
+	    rdstcll(_cur);
--
 				while (ilen > 0) {
 					ident = (ident << 8) | (*p++ & 0xFF);
 					ilen--;
+					if (_cur < timeout) {
+	    rdstcll(_cur);
+					}
--
-	                    while (ilen > 0) 
+	                    unsigned long long delta = (cpu / khz / HZ) * 2;
+	                    unsigned long long _start = 0;
+	                    unsigned long long _cur = 0;
+                             unsigned long long timeout;
+                             timeout = rdstcll(start) + delta;
+                             while (ilen > 0) 
                              { err_ret = (err_ret << 8) | (*p++ & 0xFF);	/* error value */
 	                       ilen--;
+	                       if (_cur < timeout) {
+	                        rdstcll(_cur);
+	                       }
--
 	while (max_ie_len[i].ie != -1) {
 		if (max_ie_len[i].ie == ie)
 			return(max_ie_len[i].len);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (*checklist != -1) {
 		if ((*checklist & 0xff) == ie) {
 			if (ie & 0x80)
@@ -655,6 +737,12 @@ ie_in_set(struct l3_process *pc, u_char
 		}
 		ret++;
--
 	while ((p - skb->data) < skb->len) {
 		if ((*p & 0xf0) == 0x90) { /* shift codeset */
 			old_codeset = codeset;
@@ -724,6 +817,12 @@ check_infoelements(struct l3_process *pc
 			codeset = old_codeset;
 			codelock = 1;
--
 		while (l && (i<6)) {
 			pc->para.diag[i++] = *p++;
 			l--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (*sp) {
 		if ('.' == *sp) {
 			sub = sp;
 			*sp = 0;
 		} else
 			sp++;
--
 	while (up) {
 		if ((ri & 7) == 7)
 			up->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);
@@ -2564,6 +2690,12 @@ l3ni1_global_restart(struct l3_process *
 			up->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);
 		
--
 	while (cnt--) {
 		byteout(cs->hw.ix1.cfg_reg + SPECIAL_PORT_OFFSET, 1);
 		HZDELAY(1);	/* wait >=10 ms */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while(ipid->card_vendor) {
 			if ((pnp_c = pnp_find_card(ipid->card_vendor,
 				ipid->card_device, pnp_c))) {
@@ -270,6 +286,12 @@ setup_ix1micro(struct IsdnCard *card)
 			}
 			ipid++;
--
-	while ((ista = cs->readisac(cs, IPACX_ISTA))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while ((ista = cs->readisac(cs, IPACX_ISTA))) {
 //#################################################  
 //		printk(KERN_WARNING "interrupt_ipacx(ista=%02x)\n", ista);
 //#################################################  
@@ -856,6 +861,12 @@ interrupt_ipacx(struct IsdnCardState *cs
     
--
-	while (l2->va != nr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l2->va != nr) {
 		(l2->va)++;
 		if(test_bit(FLG_MOD128, &l2->flag))
 			l2->va %= 128;
@@ -416,6 +421,12 @@ setva(struct PStack *st, unsigned int nr
 		if (test_bit(FLG_LLI_L2WAKEUP, &st->lli.flag) && (len >=0))
--
 	while ((skb = skb_dequeue(&st->l2.ui_queue))) {
 		memcpy(skb_push(skb, i), header, i);
 		enqueue_ui(st, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (l2->vs != nr) {
 			(l2->vs)--;
 			if(test_bit(FLG_MOD128, &l2->flag)) {
@@ -953,6 +980,12 @@ invoke_retransmission(struct PStack *st,
 				st->l1.bcs->tx_cnt += l2->windowar[p1]->len + l2headersize(l2, 0);
 			skb_queue_head(&l2->i_queue, l2->windowar[p1]);
--
-		while (cnt < count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (cnt < count) {
 #ifdef __powerpc__
 			*ptr++ = in_be32((unsigned *)(cs->hw.avm.isac +_IO_BASE));
 #else
 			*ptr++ = inl(cs->hw.avm.isac);
 #endif /* __powerpc__ */
--
 		while (cnt < count) {
 			*p++ = inb(cs->hw.avm.isac);
 			cnt++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-		while (cnt<count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (cnt<count) {
 #ifdef __powerpc__
 			out_be32((unsigned *)(cs->hw.avm.isac +_IO_BASE), *ptr++);
 #else
 			outl(*ptr++, cs->hw.avm.isac);
 #endif /* __powerpc__ */
--
 		while (cnt<count) {
 			outb(*p++, cs->hw.avm.isac);
 			cnt++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-		while (pd->log_head->next) {
-			if ((pd->log_head->usage_cnt <= 0) &&
-			    (pd->log_head->next->usage_cnt <= 0)) {
-				ib = pd->log_head;
-				pd->log_head = pd->log_head->next;
-				kfree(ib);
--
+			while (pd->log_head->next) {
+				if ((pd->log_head->usage_cnt <= 0) &&
+				(pd->log_head->next->usage_cnt <= 0)) {
+					ib = pd->log_head;
+					pd->log_head = pd->log_head->next;
+					kfree(ib);
--
 		while (inf) {
 			inf->usage_cnt--;	/* decrement usage count for buffers */
 			inf = inf->next;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
--
-				while (pd->log_head) {
-					inf = pd->log_head;
-					pd->log_head = pd->log_head->next;
-					kfree(inf);
+			if (pd->if_used <= 0)	/* delete buffers if last file closed */ {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
--
+					while (pd->log_head) {
+						inf = pd->log_head;
+						pd->log_head = pd->log_head->next;
+						kfree(inf);
+						if (_cur < timeout) {
+							rdstcll(_cur);
--
 		while (tmp) {
 			if (tmp->next == card)
 				tmp->next = card->next;
 			card_last = tmp;
 			tmp = tmp->next;
+			if (_cur < timeout) {
--
 	while (cnt--) {
 		*dst++ = *(buf + 1);	/* high byte */
 		*dst++ = *buf;	/* low byte */
 		dst += 2;	/* point to next longword */
 		buf += 2;	/* buffer only filled with words */
+		if (_cur < timeout) {
--
 	while (len) {
 
 		/* first determine the number of bytes that may be buffered */
@@ -302,13 +318,30 @@ ergo_writebootseq(struct HYSDN_CARD *car
 
 		/* now we know how much bytes we may put in the puffer */
--
 		while (nr_write--) {
 			*(dst + wr_mirror) = *buf++;	/* output one byte */
 			if (++wr_mirror >= buflen)
 				wr_mirror = 0;
 			sp->WrPtr = wr_mirror;	/* announce the next byte to E1 */
+			if (_cur < timeout) {
--
 		}		/* while (nr_write) */
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	}			/* while (len) */
 	return (0);
 }				/* ergo_writebootseq */
diff -u -p a/isdn/hysdn/hysdn_boot.c b/isdn/hysdn/hysdn_boot.c
--- a/isdn/hysdn/hysdn_boot.c
+++ b/isdn/hysdn/hysdn_boot.c
--
 	while (cnt--) {
 		boot->Cryptor = (boot->Cryptor >> 1) ^ ((boot->Cryptor & 1U) ? CRYPT_FEEDTERM : 0);
 		*bufp++ ^= (unsigned char)boot->Cryptor;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (len > 0) {
 
 		if (*cp == SYSR_TOK_END)
@@ -391,6 +407,12 @@ EvalSysrTokData(hysdn_card *card, unsign
 		}
 		len -= (*(cp + 1) + 2);		/* adjust len */
--
 				while ((i) && (*cp < ' ') && (*cp != 9)) {
 					i--;	/* discard next char */
 					count++;	/* mark as read */
 					cp++;	/* next char */
+					if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (card) {
 
 		sprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);
@@ -401,6 +417,12 @@ hysdn_procconf_init(void)
 			hysdn_proclog_init(card);	/* init the log file entry */
 		}
--
 	while (card) {
 
 		sprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);
@@ -427,6 +454,12 @@ hysdn_procconf_release(void)
 		hysdn_proclog_release(card);	/* init the log file entry */
 
--
 	while (card->async_busy) {
 
 		if (card->debug_flags & LOG_SCHED_ASYN)
@@ -163,6 +168,12 @@ hysdn_tx_cfgline(hysdn_card *card, unsig
 		msleep_interruptible(20);		/* Timeout 20ms */
 		if (!--cnt)
--
 	while (card->async_busy) {
 
 		if (card->debug_flags & LOG_SCHED_ASYN)
@@ -188,6 +204,12 @@ hysdn_tx_cfgline(hysdn_card *card, unsig
 		msleep_interruptible(20);		/* Timeout 20ms */
 		if (!--cnt)
--
 	while (nl->sk_count) {
 		dev_kfree_skb(nl->skbs[nl->out_idx++]);		/* free skb */
 		if (nl->out_idx >= MAX_SKB_BUFFERS)
 			nl->out_idx = 0;	/* wrap around */
 		nl->sk_count--;
+		if (_cur < timeout) {
--
-	while ((skb = skb_dequeue(&ap->recv_queue))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&ap->recv_queue))) {
 		if (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_IND)
 			ap->nrecvdatapkt++;
 		else
 			ap->nrecvctlpkt++;
 
--
 	while (divert_info_head->next) {
 		if ((divert_info_head->usage_cnt <= 0) &&
 		    (divert_info_head->next->usage_cnt <= 0)) {
@@ -70,6 +75,12 @@ put_info_buffer(char *cp)
 			kfree(ib);
 		} else
--
 	while (inf) {
 		inf->usage_cnt--;
 		inf = inf->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while (divert_info_head) {
-			inf = divert_info_head;
-			divert_info_head = divert_info_head->next;
-			kfree(inf);
+	if (if_used <= 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
+			while (divert_info_head) {
+				inf = divert_info_head;
+				divert_info_head = divert_info_head->next;
+				kfree(inf);
+					if (_cur < timeout) {
+							rdstcll(_cur);
--
 	while (tries < timeout) {
 		schedule_timeout_interruptible(1);
 		
@@ -222,6 +227,12 @@ int send_and_receive(int card,
 		}
 
--
         while (timeout) {
                 if (inb(ISA_PORT_SOS) & ISA_SOS_READY) {
                         outb(data, ISA_PORT_SDO);
@@ -206,6 +211,12 @@ act2000_isa_writeb(act2000_card * card,
                         timeout--;
                         udelay(10);
--
         while (timeout) {
                 if (inb(ISA_PORT_SIS) & ISA_SIS_READY) {
                         *data = inb(ISA_PORT_SDI);
@@ -223,6 +239,12 @@ act2000_isa_readb(act2000_card * card, u
                         timeout--;
                         udelay(10);
--
 	while (!act2000_isa_readb(card, &c)) {
 		if (card->idat.isa.rcvidx < 8) {
                         card->idat.isa.rcvhdr[card->idat.isa.rcvidx++] = c;
@@ -279,6 +306,12 @@ act2000_isa_receive(act2000_card *card)
 				card->idat.isa.rcvptr = card->idat.isa.rcvhdr;
 			}
--
 	while (1) {
 		spin_lock_irqsave(&card->lock, flags);
 		if (!(card->sbuf)) {
@@ -322,6 +360,11 @@ act2000_isa_send(act2000_card * card)
 		}
 		skb = card->sbuf;
--
 		while (skb->len) {
 			if (act2000_isa_writeb(card, *(skb->data))) {
 				/* Fifo is full, but more data to send */
@@ -332,6 +375,12 @@ act2000_isa_send(act2000_card * card)
 			}
 			skb_pull(skb, 1);
--
         while (length) {
                 l = (length > 1024) ? 1024 : length;
                 c = 0;
@@ -424,7 +484,12 @@ act2000_isa_download(act2000_card * card
                         kfree(buf);
                         return -EFAULT;
--
-                while (c < l) {
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                timeout = rdstcll(start) + delta;
+                        while (c < l) {
                         if (act2000_isa_writeb(card, *b++)) {
                                 printk(KERN_WARNING
                                        "act2000: loader timed out"
@@ -433,9 +498,21 @@ act2000_isa_download(act2000_card * card
                                 return -ETIME;
--
 	while (p) {
 		q  = p->next;
 		kfree(p);
 		p = q;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (p) {
 		if (p->eaz == eaz)
 			return(p->msn);
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (p) {
 			if (p->eaz == eazmsn[0]) {
 				spin_lock_irqsave(&card->lock, flags);
@@ -156,10 +183,21 @@ act2000_set_msn(act2000_card *card, char
 			}
 			q = p;
--
 	while (p) {
 		/* Found in list, replace MSN */
 		if (p->eaz == eazmsn[0]) {
@@ -173,6 +211,12 @@ act2000_set_msn(act2000_card *card, char
 			return 0;
 		}
--
         while (p) {
                 if (p->myid == driverid)
                         return p;
                 p = p->next;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
--
         while (p) {
 		initialized = 0;
 		if (!p->interface.statcallb) {
@@ -774,7 +834,13 @@ act2000_addcard(int bus, int port, int i
                         }
 			failed++;
--
         while (card) {
                 unregister_card(card);
 		del_timer(&card->ptimer);
                 card = card->next;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
--
         while (card) {
                 last = card;
                 card = card->next;
 		act2000_clear_msn(last);
                 kfree(last);
+                if (_cur < timeout) {
--
 	while (p) {
 		int i;
 
@@ -294,7 +299,13 @@ actcapi_manufacturer_req_msn(act2000_car
 			ACTCAPI_QUEUE_TX;
 		}
--
         while (1) {
                 m = (actcapi_msg *)tmp->data;
                 if ((((m->msg.data_b3_req.fakencci >> 8) & 0xff) == chan->ncci) &&
@@ -622,6 +638,12 @@ handle_ack(act2000_card *card, act2000_c
 			printk(KERN_WARNING "act2000: handle_ack nothing found!\n");
                         return 0;
--
 	while ((skb = skb_dequeue(&card->rcvq))) {
 		actcapi_debug_msg(skb, 0);
 		msg = (actcapi_msg *)skb->data;
@@ -934,6 +961,12 @@ actcapi_dispatch(struct work_struct *wor
 				break;
 		}
--
 	while (card->sndcount[ch]) {
 		if ((skb = skb_dequeue(&card->bqueue[ch]))) {
 			len = skb->len;
@@ -77,6 +82,12 @@ isdnloop_bchan_send(isdnloop_card * card
 			card->interface.statcallb(&cmd);
 		} else
--
 	while (cc) {
 		for (ch = 0; ch < 2; ch++) {
 			/* Exclude ourself */
@@ -692,12 +708,23 @@ isdnloop_try_call(isdnloop_card * card,
 					break;
 				case ISDN_PTYPE_1TR6:
--
 					while (*e) {
 						sprintf(nbuf, "%s%c", cc->s0num[0], *e);
 						if (!(strcmp(nbuf, cmd->parm.setup.phone)))
 							num_match = 1;
 						e++;
-					}
--
 			while (strchr("0157", *p)) {
 				if (i)
 					card->sil[ch - 1] |= si2bit[*p - '0'];
 				i = (*p++ == '0');
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (len) {
 		int count = len;
 		u_char *p;
@@ -1005,6 +1054,12 @@ isdnloop_writecmd(const u_char * buf, in
 			}
 			ocount++;
--
 	while (p) {
 		isdnloop_stopcard(p);
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (p) {
 		if (p->myid == driverid)
 			return p;
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (card) {
 		cmd.command = ISDN_STAT_UNLOAD;
 		cmd.driver = card->myid;
@@ -1524,13 +1606,30 @@ isdnloop_exit(void)
 		for (i = 0; i < ISDNLOOP_BCH; i++)
 			isdnloop_free_queue(card, i);
--
 	while (card) {
 		last = card;
 		skb_queue_purge(&card->dqueue);
 		card = card->next;
 		kfree(last);
+		if (_cur < timeout) {
--
-	while (line < len) {    /* Are we done with all lines of the matrix? */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (line < len) {    /* Are we done with all lines of the matrix? */
 		if ((line % 10) == 0) {	/* the 0. line of the matrix is always 0 ! */
 			if (m[line] != 0x00) {	/* not 0 ? -> error! */
 #ifdef ISDN_V110_DEBUG
@@ -239,6 +244,12 @@ DecodeMatrix(isdn_v110_stream * v, unsig
 			}
--
 	while ((i < len) && (line < mlen)) {	/* while we still have input data */
 		switch (line % 10) {	/* in which line of the matrix are we? */
 			case 0:
@@ -380,6 +396,12 @@ EncodeMatrix(unsigned char *buf, int len
 		mbit >>= 1;     /* go to next bit of matrix */
 		goto next_bit;
--
 	while (indx-- != 0) {
 		db->dict[indx].codem1 = BADCODEM1;
 		db->dict[indx].cptr   = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (--ilen > 0) {
 		c     = *rptr++;
 		fcode = BSD_KEY  (ent, c);
@@ -577,6 +593,12 @@ nomatch:
 			}
 		}
--
-		while (finchar > LAST) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (finchar > LAST) {
 			struct bsd_dict *dictp2 = dict_ptr (db, finchar);
 	    
 			dictp = dict_ptr (db, dictp2->cptr);
@@ -808,6 +835,12 @@ static int bsd_decompress (void *state,
 				*--p    = (fcode >> 16) & 0xff;
--
 	while (s->nleft < s->nbits) {
 		int d = *((*in)++);
 		(*len)--;
 		s->word = (s->word << 8) | d;
 		s->nleft += 8;
+		if (_cur < timeout) {
--
 	while (s->nleft >= 8) {
 		int d = (s->word >> (s->nleft - 8));
 		*(out[0]++) = d & 255;
 		(*len)++;
 		s->nleft -= 8;
+		if (_cur < timeout) {
--
 	while (len) {
 		int e = isdn_audio_get_bits(s, &in, &len);
 		int sign;
@@ -386,6 +413,12 @@ isdn_audio_adpcm2xlaw(adpcm_state * s, i
 		d = (d * Mx[nbits - 2][e] + 0x2000) >> 14;
 		if (d < 5)
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len--) {
 		int e = 0,
 		 nmax = 1 << (nbits - 1);
 		int sign,
@@ -415,9 +453,20 @@ isdn_audio_xlaw2adpcm(adpcm_state * s, i
 			e = nmax;
--
 		while (--nmax && delta > d) {
 			delta -= d;
 			e++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while ((skb = skb_dequeue(&info->dtmf_queue))) {
 		result = (int *) skb->data;
 		s = info->dtmf_state;
@@ -577,6 +637,12 @@ isdn_audio_eval_dtmf(modem_info * info)
 		} else
 			kfree_skb(skb);
--
-	while (isdn_wildmat(s, p)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (isdn_wildmat(s, p)) {
 		if (*++s == '\0')
 			return (2);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 			while (dev->drv[di]->locks > 0) {
 				isdn_unlock_driver(dev->drv[di]);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 			while ((count_pull < skb->len) && (len > 0)) {
 				len--;
 				if (dev->drv[di]->DLEflag & DLEmask) {
@@ -814,6 +841,12 @@ isdn_readbchan(int di, int channel, u_ch
 					count_pull++;
 				}
--
 			while ((count_pull < skb->len) && (len > 0)) {
 				/* push every character but the last to the tty buffer directly */
 				if ( count_put )
@@ -928,6 +966,12 @@ isdn_readbchan_tty(int di, int channel,
 					count_pull++;
 				}
--
 	while (p) {
 		*(p->private) = 1;
 		p = (infostruct *) p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (p) {
 			if (p->private == (char *) &(filep->private_data)) {
 				if (q)
@@ -1815,6 +1875,12 @@ isdn_close(struct inode *ino, struct fil
 			}
 			q = p;
--
 		printk(KERN_WARNING "isdn: No private data while closing isdnctrl\n");
 		goto out;
diff -u -p a/isdn/i4l/isdn_ppp.c b/isdn/i4l/isdn_ppp.c
--- a/isdn/i4l/isdn_ppp.c
+++ b/isdn/i4l/isdn_ppp.c
@@ -164,11 +164,22 @@ isdn_ppp_bind(isdn_net_local * lp)
--
 		while (net_dev) {	/* step through net devices to find exclusive minors */
 			isdn_net_local *lp = net_dev->local;
 			if (lp->pppbind >= 0)
 				exclusive[lp->pppbind] = 1;
 			net_dev = net_dev->next;
+			if (_cur < timeout) {
--
 				while(ipc) {
 					j = ipc->num / (sizeof(long)*8);
 					i = ipc->num % (sizeof(long)*8);
 					if(j < 8)
 						protos[j] |= (0x1<<i);
 					ipc = ipc->next;
--
   	while (start != NULL || newfrag != NULL) {
 
     		thisseq = MP_SEQ(frag);
@@ -1785,6 +1812,12 @@ static void isdn_ppp_mp_receive(isdn_net
     		}
 	  			
--
   	}	/* while -- main loop */
 	
   	if (mp->frags == NULL)
@@ -1794,10 +1827,21 @@ static void isdn_ppp_mp_receive(isdn_net
 	 * queue overflow */
 	if (mp->frames > MP_MAX_QUEUE_LEN) {
--
 		while (mp->frames > MP_MAX_QUEUE_LEN) {
 			frag = mp->frags->next;
 			isdn_ppp_mp_free_skb(mp, mp->frags);
 			mp->frags = frag;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-    	while( frag ) {
+    	unsigned long long delta = (cpu / khz / HZ) * 2;
+    	unsigned long long _start = 0;
+    	unsigned long long _cur = 0;
+    	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while( frag ) {
 		nextfrag = frag->next;
 		isdn_ppp_mp_free_skb(lp->netdev->pb, frag);
 		frag = nextfrag;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while (from != to) {
-	  		struct sk_buff * next = from->next;
-			isdn_ppp_mp_free_skb(mp, from);
+	if( from ) {
+	  		unsigned long long delta = (cpu / khz / HZ) * 2;
+	  		unsigned long long _start = 0;
--
+	  		while (from != to) {
+	  			struct sk_buff * next = from->next;
+	  		isdn_ppp_mp_free_skb(mp, from);
 	  		from = next;
+	  		if (_cur < timeout) {
+	  			  		rdstcll(_cur);
--
-		while( from != to ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while( from != to ) {
 			unsigned int len = from->len - MP_HEADER_LEN;
 
 			skb_copy_from_linear_data_offset(from, MP_HEADER_LEN,
@@ -1908,6 +1980,12 @@ void isdn_ppp_mp_reassembly( isdn_net_de
 			frag = from->next;
--
 						while (--l) {
 							if (*dp == DLE)
 								tty_insert_flip_char(tty, DLE, 0);
 							tty_insert_flip_char(tty, *dp++, 0);
+							if (_cur < timeout) {
+								rdstcll(_cur);
--
 	while (len > 0) {
 		if (m->lastDLE) {
 			m->lastDLE = 0;
@@ -379,6 +395,12 @@ isdn_tty_handleDLEdown(modem_info * info
 		}
 		p++;
--
 	while (c--) {
 		ch = *buf;
 		if ((ch != 0x11) && (ch != 0x13))
 			return 1;
 		buf++;
+		if (_cur < timeout) {
--
 	while (count > 0) {
 		if (*(p++) == plus) {
 			if ((*pluscount)++) {
@@ -2463,6 +2501,12 @@ isdn_tty_check_esc(const u_char * p, u_c
 			*pluscount = 0;
 		*lastplus = jiffies;
--
 	while (slen > 0) {
 		if (hdlc->bit_shift == 0) {
 			/* the code is for bitreverse streams */
@@ -327,6 +332,12 @@ int isdnhdlc_decode(struct isdnhdlc_vars
 		default:
 			break;
--
 	while (dsize > 0) {
 		if (hdlc->bit_shift == 0) {
 			if (slen && !hdlc->do_closing) {
@@ -622,6 +638,12 @@ int isdnhdlc_encode(struct isdnhdlc_vars
 			len++;
 			dsize--;
--
 	while ((frame = dev->read_queue)) {
 		dev->read_queue = frame->next;
 		spin_unlock_irqrestore(&dev->lock, flags);
@@ -312,6 +317,12 @@ pcbit_deliver(struct work_struct *work)
 		kfree(frame);
 
--
 		while (read_seq != dev->rcv_seq) {
 			pcbit_receive(dev);
 			dev->rcv_seq = (dev->rcv_seq + 1) % 8;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 	while (argc && (i<MAX_PCBIT_CARDS)) {
 
 		if (argc) {
@@ -115,6 +120,12 @@ static int __init pcbit_setup(char *line
 		}
 
--
 						while (*p) {
 							if (*p >= '0' && *p <= '9')
 								*q++ = *p;
 							p++;
+							if (_cur < timeout) {
+								rdstcll(_cur);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (1) {
 #ifdef BOOT_DEBUG
 		printk(KERN_DEBUG "Loader %d ?\n", cardnumber);
 #endif
@@ -772,6 +788,12 @@ icn_check_loader(int cardnumber)
 			icn_release_channel();
--
-  while (slsec) { \
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (slsec) { \
     msleep_interruptible(1000); \
     slsec--; \
-  } \
+  if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (left) {
 		if (sbfree) {   /* If there is a free buffer...  */
 			cnt = left;
@@ -951,10 +989,21 @@ icn_loadproto(u_char __user * buffer, ic
 			}
 			schedule_timeout_interruptible(10);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (1) {
 		if (readb(&cmd_o) || readb(&cmd_i)) {
 #ifdef BOOT_DEBUG
 			printk(KERN_DEBUG "Proto?\n");
@@ -999,6 +1048,12 @@ icn_loadproto(u_char __user * buffer, ic
 			icn_maprelease_channel(card, 0);
--
 	while (p) {
 		icn_stopcard(p);
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (card) {
 		if (!request_region(card->port, ICN_PORTLEN, "icn-isdn")) {
 			printk(KERN_WARNING
@@ -1146,6 +1217,12 @@ icn_disable_cards(void)
 			release_region(card->port, ICN_PORTLEN);
 		}
--
 							while (card->ptype == ISDN_PTYPE_UNKNOWN) {
 								msleep_interruptible(ICN_BOOT_TIMEOUT1);
+								if (_cur < timeout) {
+						rdstcll(_cur);
+								}
+								else {
--
 	while (p) {
 		if (p->myid == driverid)
 			return p;
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (card) {
 		cmd.command = ISDN_STAT_UNLOAD;
 		cmd.driver = card->myid;
@@ -1676,13 +1780,30 @@ static void __exit icn_exit(void)
 		tmpcard = card->next;
 		spin_unlock_irqrestore(&card->lock, flags);
--
 	while (card) {
 		last = card;
 		card = card->next;
 		kfree(last);
+		if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while ((skb = skb_dequeue(&dch->rqueue))) {
 			if (likely(dch->dev.D.peer)) {
 				err = dch->dev.D.recv(dch->dev.D.peer, skb);
@@ -34,6 +39,12 @@ dchannel_bh(struct work_struct *ws)
 					dev_kfree_skb(skb);
 			} else
--
 		while ((skb = skb_dequeue(&bch->rqueue))) {
 			bch->rcount--;
 			if (likely(bch->ch.peer)) {
@@ -58,6 +74,12 @@ bchannel_bh(struct work_struct *ws)
 					dev_kfree_skb(skb);
 			} else
--
-	while (l2->va != nr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l2->va != nr) {
 		l2->va++;
 		if (test_bit(FLG_MOD128, &l2->flag))
 			l2->va %= 128;
@@ -582,11 +587,28 @@ setva(struct layer2 *l2, unsigned int nr
 			l2->windowar[l2->sow] = NULL;
--
 	while (skb) {
 		dev_kfree_skb(skb);
 		skb = skb_dequeue(&l2->tmp_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = skb_dequeue(&l2->ui_queue))) {
 		memcpy(skb_push(skb, i), header, i);
 		enqueue_ui(l2, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (l2->vs != nr) {
 			(l2->vs)--;
 			if (test_bit(FLG_MOD128, &l2->flag)) {
@@ -1152,6 +1190,12 @@ invoke_retransmission(struct layer2 *l2,
 				    "%s: windowar[%d] is NULL\n",
 				    __func__, p1);
--
 	while (i < 256) {
 		j = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (j < 256) {
 			sample = dsp_audio_law_to_s32[i];
 			sample += dsp_audio_law_to_s32[j];
@@ -266,8 +276,20 @@ dsp_audio_generate_mix_table(void)
 			dsp_audio_mix_law[(i<<8)|j] =
 				dsp_audio_s16_to_law[sample & 0xffff];
--
-	while (i < 256) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < 256) {
 		dsp_audio_reduce8[i] = dsp_audio_s16_to_law[
 			(dsp_audio_law_to_s32[i] * denum[7] / num[7]) & 0xffff];
 		dsp_audio_reduce7[i] = dsp_audio_s16_to_law[
@@ -388,6 +415,12 @@ dsp_audio_generate_volume_changes(void)
 		dsp_audio_increase8[i] = dsp_audio_s16_to_law[sample & 0xffff];
--
 	while (i < ii) {
 		*p = volume_change[*p];
 		p++;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((tok = strsep(&dup, "|"))) {
 		if (!strlen(tok))
 			continue;
@@ -320,7 +325,13 @@ int dsp_pipeline_build(struct dsp_pipeli
 				"%s\n", __func__, name);
 			incomplete = 1;
--
 			while (*digits) {
 				int k;
 				struct sk_buff *nskb;
@@ -755,6 +760,12 @@ dsp_function(struct mISDNchannel *ch,  s
 						dev_kfree_skb(nskb);
 				}
--
 			while (*digits) {
 				int k;
 				struct sk_buff *nskb;
@@ -801,6 +817,12 @@ dsp_function(struct mISDNchannel *ch,  s
 						dev_kfree_skb(nskb);
 				}
--
 	while ((skb = skb_dequeue(&dsp->sendq))) {
 		/* in locked date, we must have still data in queue */
 		if (dsp->data_pending) {
@@ -1040,6 +1067,12 @@ dsp_send_bh(struct work_struct *work)
 			} else
 				dev_kfree_skb(skb);
--
 		while ((tok = strsep(&dup, ","))) {
 			if (!strlen(tok))
 				continue;
@@ -88,6 +93,12 @@ void dsp_hwec_enable(struct dsp *dsp, co
 				if (sscanf(val, "%d", &tmp) == 1)
 					deftaps = tmp;
--
 	while (samples[i].len) {
 		j = 0;
-		while (j < (*samples[i].len)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (j < (*samples[i].len)) {
 			samples[i].data[j] =
 				dsp_audio_alaw_to_ulaw[samples[i].data[j]];
 			j++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (len) {
 		/* find sample to start with */
 		while (42) {
@@ -421,6 +448,12 @@ void dsp_tone_copy(struct dsp *dsp, u8 *
 		data += num;
 		count += num;
 		len -= num;
+		if (_cur < timeout) {
--
 	while (i < ii) {
 		d[w++ & CMX_BUFF_MASK] = *p++;
 		i++;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 				while (r != rr) {
 					*c++ += dsp_audio_law_to_s32[q[r]];
 					r = (r+1) & CMX_BUFF_MASK;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 			while (r != rr) {
 				p[r] = dsp_silence;
 				r = (r+1) & CMX_BUFF_MASK;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while (i < MAX_SECONDS_JITTER_CHECK) {
 				if (delay > dsp->rx_delay[i])
 					delay = dsp->rx_delay[i];
 				i++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 				while (r != rr) {
 					p[r] = dsp_silence;
 					r = (r+1) & CMX_BUFF_MASK;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 			while (i < MAX_SECONDS_JITTER_CHECK) {
 				if (delay > dsp->tx_delay[i])
 					delay = dsp->tx_delay[i];
 				i++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 				while (r != rr) {
 					q[r] = dsp_silence;
 					r = (r+1) & CMX_BUFF_MASK;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
 			while (i) {
 				dsp->rx_delay[i] = dsp->rx_delay[i-1];
 				dsp->tx_delay[i] = dsp->tx_delay[i-1];
 				i--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
-	while (w != ww) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (w != ww) {
 #ifdef CMX_TX_DEBUG
 		if (strlen(debugbuf) < 48)
 			sprintf(debugbuf+strlen(debugbuf), " %02x", *d);
 #endif
 		p[w] = *d++;
--
 		while (size < DSP_DTMF_NPOINTS && len) {
 			buf[size++] = dsp_audio_law_to_s32[*data++];
 			len--;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
--
-	while (!signal_pending(current)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!signal_pending(current)) {
 		struct kvec iov = {
 			.iov_base = recvbuf,
 			.iov_len = recvbuf_size,
@@ -743,15 +748,32 @@ l1oip_socket_thread(void *data)
 				printk(KERN_WARNING
--
 	while (!hc->socket) {
 		spin_unlock(&hc->socket_lock);
 		schedule_timeout(HZ/10);
 		spin_lock(&hc->socket_lock);
+		if (_cur < timeout) {
+				rdstcll(_cur);
--
-		while (l) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (l) {
 			ll = (l < L1OIP_MAX_PERFRAME) ? l : L1OIP_MAX_PERFRAME;
 			l1oip_socket_send(hc, 0, dch->slot, 0,
 				hc->chan[dch->slot].tx_counter++, p, ll);
 			p += ll;
 			l -= ll;
--
-		while (l) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (l) {
 			ll = (l < L1OIP_MAX_PERFRAME) ? l : L1OIP_MAX_PERFRAME;
 			l1oip_socket_send(hc, hc->codec, bch->slot, 0,
 				hc->chan[bch->slot].tx_counter, p, ll);
 			hc->chan[bch->slot].tx_counter += ll;
 			p += ll;
--
 	while (l1oip_cnt < MAX_CARDS && type[l1oip_cnt]) {
 		switch (type[l1oip_cnt] & 0xff) {
 		case 1:
@@ -1533,6 +1582,12 @@ l1oip_init(void)
 		}
 
--
 	while (i < ii) {
 		*result++ = table_com[(data[0]<<8) | (data[1])];
 		data += 2;
 		i++;
 		o++;
+		if (_cur < timeout) {
--
 	while (i < len) {
 		r = table_dec[*data++];
 		*result++ = r>>8;
 		*result++ = r;
 		i++;
+		if (_cur < timeout) {
--
 	while (i < len) {
 		*result++ = alaw_to_ulaw[*data++];
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (i < len) {
 		*result++ = ulaw_to_alaw[*data++];
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (i1 < 256) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i1 < 256) {
 		if (ulaw)
 			c = ulaw_to_4bit[i1];
 		else
 			c = alaw_to_4bit[i1];
 		i2 = 0;
--
 		while (i2 < 256) {
 			table_com[(i1<<8) | i2] |= (c<<4);
 			table_com[(i2<<8) | i1] |= c;
 			i2++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (i1 < 16) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i1 < 16) {
 		if (ulaw)
 			sample = _4bit_to_ulaw[i1];
 		else
 			sample = _4bit_to_alaw[i1];
 		i2 = 0;
--
 		while (i2 < 16) {
 			table_dec[(i1<<4) | i2] |= (sample<<8);
 			table_dec[(i2<<4) | i1] |= sample;
 			i2++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (i < len) {
 		/* collect a block of 9 samples */
 		if (j < 9) {
@@ -442,6 +447,12 @@ dsp_bf_encrypt(struct dsp *dsp, u8 *data
 		bf_crypt_out[6] = ((yr>>15) & 0x7f) | ((cs<<6) & 0x80);
 		bf_crypt_out[7] = ((yr>>8) & 0x7f) | (cs<<7);
--
 	while (i < len) {
 		/*
 		 * shift upper bit and rotate data to buffer ring
@@ -549,6 +565,12 @@ dsp_bf_decrypt(struct dsp *dsp, u8 *data
 		bf_data_out[7] = dsp_audio_seven2law[(yr>>8) & 0x7f];
 		bf_data_out[8] = dsp_audio_seven2law[(yr>>1) & 0x7f];
--
 	while (i < 9) {
 		dsp->bf_crypt_out[i] = 0xff;
 		dsp->bf_data_out[i] = dsp_silence;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-    while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                         (word)(len+1+sizeof(*pmsg))))) {
       if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
         queueFreeMsg (dbg_queue);
       } else {
         break;
--
-      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                         (word)(len+1+sizeof(*pmsg))))) {
         if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
           queueFreeMsg (dbg_queue);
         } else {
           break;
--
-    while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                 (word)length+sizeof(*pmsg)))) {
       if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
         queueFreeMsg (dbg_queue);
       } else {
         break;
--
-    while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                   (word)length+sizeof(*pmsg)+2))) {
       if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
         queueFreeMsg (dbg_queue);
       } else {
         break;
--
-      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                                           (word)length))) {
         if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
           queueFreeMsg (dbg_queue);
         } else {
           break;
--
-  while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                       (word)(len+1+sizeof(*pmsg))))) {
     if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
       queueFreeMsg (dbg_queue);
     } else {
       break;
--
-      while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                                         (word)(len+1+sizeof(*pmsg))))) {
         if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
           queueFreeMsg (dbg_queue);
         } else {
           break;
--
-  while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (!(pmsg = (diva_dbg_entry_head_t*)queueAllocMsg (dbg_queue,
                               (word)length+sizeof(*pmsg)))) {
     if ((pmsg = (diva_dbg_entry_head_t*)queuePeekMsg (dbg_queue, &size))) {
       queueFreeMsg (dbg_queue);
     } else {
       break;
--
   while (ref_len--) {
     if (*nmbr-- != *ref--) {
       return (-1);
     }
+    if (_cur < timeout) {
+      rdstcll(_cur);
--
  while (dwords--) {
   *data++ = READ_DWORD((Base + (unsigned long)addr));
   addr+=4;
+  if (_cur < timeout) {
+   rdstcll(_cur);
+  }
--
- while (dwords--) {
+ unsigned long long delta = (cpu / khz / HZ) * 2;
+ unsigned long long _start = 0;
+ unsigned long long _cur = 0;
+ unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (dwords--) {
 	WRITE_DWORD((Base + (unsigned long)addr), *data);
   	addr+=4;
 	data++;
+	if (_cur < timeout) {
+  	rdstcll(_cur);
--
 		while ( (fpgaDate[i] != '\0')
 		     && ((fpgaDate[i] < '0') || (fpgaDate[i] > '9')) )
 		{
 			i++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while ( (fpgaDate[i] >= '0') && (fpgaDate[i] <= '9') )
@@ -330,6 +341,11 @@ int qBri_FPGA_download (PISDN_ADAPTER Io
 /*
  *	put data onto the FPGA
  */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
--
 	while ( code < FileLength )
 	{
 		val = ((word)File[code++]) << 3 ;
@@ -343,6 +359,12 @@ int qBri_FPGA_download (PISDN_ADAPTER Io
 			WRITE_WORD(addr, baseval | FPGA_CCLK) ;     /* set CCLK hi */
 			WRITE_WORD(addr, baseval) ;                 /* set CCLK lo */
--
 	while (length--) {
 		outpp(addrHi, (word) (address >> 16));
 		outppw(addrLo, (word) (address & 0x0000ffff));
 		outpp(ioaddr, *data++);
 		address++;
+		if (_cur < timeout) {
--
  while ( (i < 100) && (IoAdapter->a.ram_in (&IoAdapter->a, &RAM->SWReg) != 0) )
  {
   diva_os_wait (1) ;
   i++ ;
+  if (_cur < timeout) {
+   rdstcll(_cur);
--
 	while (length--) {
 		WRITE_BYTE(mem++, *data++);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
 						while (len--) {
 							*dst++ = READ_BYTE(src++);
+							if (_cur < timeout) {
+		rdstcll(_cur);
+							}
+							else {
--
 						while (len--) {
 							*dst++ = READ_BYTE(src++);
+							if (_cur < timeout) {
+			rdstcll(_cur);
+							}
+							else {
--
 	while (length--) {
 		WRITE_BYTE(mem++, *data++);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
 		while ((*buffer_length >= (64 * 1024))
 		       &&
 		       (!(*buffer = diva_os_malloc (0, *buffer_length)))) {
 			*buffer_length -= 1024;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (diva_mnt_shutdown_xdi_adapters() && i--) {
 		diva_os_sleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 			while (length--) {
 				pci_write_config_dword(dev, offset,
 						       *(unsigned int *)
 						       p++);
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 			while (length--) {
 				pci_write_config_byte(dev, offset,
 						      *(unsigned char *)
 						      p++);
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 			while (length--) {
 				pci_read_config_dword(dev, offset,
 						      (unsigned int *)
 						      p++);
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 			while (length--) {
 				pci_read_config_byte(dev, offset,
 						     (unsigned char *)
 						     p++);
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
             while (total_length > 3 && *p) {
               Ind = *p++;
               this_ind_length = (word)p[0] | ((word)p[1] << 8);
@@ -389,6 +394,12 @@ static int SuperTraceMessageInput (void*
               }
               p += (this_ind_length+1);
--
 	while ((a = get_and_remove_from_queue())) {
 		if (a->interface.cleanup_adapter_proc) {
 			(*(a->interface.cleanup_adapter_proc)) (a);
@@ -379,6 +384,12 @@ void divasa_xdi_driver_unload(void)
 			remove_adapter_proc(a);
 		}
--
-  while(e_no && ReadyCount) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(e_no && ReadyCount) {
     next_req(a);
     this = entity_ptr(a, e_no);
 #ifdef USE_EXTENDED_DEBUGS
@@ -132,6 +137,11 @@ void pr_out(ADAPTER * a)
     length = 0;
--
     while(i<this->XNum && length<270) {
       clength = min((word)(270-length),(word)(X[i].PLength-this->XOffset));
       a->ram_out_buffer(a,
@@ -144,12 +154,23 @@ void pr_out(ADAPTER * a)
         this->XCurrent = (byte)++i;
         this->XOffset = 0;
--
-      while (i < this->XNum) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+        while (i < this->XNum) {
         diva_istream_write (a,
                             this->Id,
                             PTR_P(a,this,&X[i].P[0]),
@@ -157,6 +178,12 @@ void pr_out(ADAPTER * a)
                             ((i+1) == this->XNum),
--
     while(Count--) {
       if((Rc=a->ram_in(a, &RcIn->Rc)) != 0) {
         dword tmp[2];
@@ -291,6 +329,12 @@ byte pr_dpc(ADAPTER * a)
       }
         /* get buffer address of next return code                   */
--
     while(Count--) {
         /* if the application marks an indication as RNR, all       */
         /* indications from the same Id delivered in this interrupt */
@@ -337,6 +386,12 @@ byte pr_dpc(ADAPTER * a)
       }
         /* get buffer address of next indication                    */
--
     while (sample_number < length)
     {
       if (cycle_counter < CAPIDTMF_RECV_ACCUMULATE_CYCLES)
@@ -669,6 +674,12 @@ void capidtmf_recv_block (t_capidtmf_sta
         cycle_counter = 0;
         sample_number++;
--
         while (k != plci->msg_in_write_pos)
         {
           if (k == plci->msg_in_wrap_pos)
@@ -488,6 +493,12 @@ word api_put(APPL   * appl, CAPI_MSG   *
           k += (((CAPI_MSG   *)(&((byte   *)(plci->msg_in_queue))[k]))->header.length +
             MSG_IN_OVERHEAD + 3) & 0xfffc;
--
   while (plci->internal_command_queue[1] != NULL)
   {
     for (i = 0; i < MAX_INTERNAL_COMMAND_LEVELS - 1; i++)
@@ -765,6 +781,12 @@ static void next_internal_command (dword
     if (plci->internal_command != 0)
       return;
--
       while (ncci_ptr->data_pending != 0)
       {
         if (!plci->data_sent || (ncci_ptr->DBuffer[ncci_ptr->data_out].P != plci->data_sent_ptr))
@@ -931,6 +958,12 @@ static void cleanup_ncci_data (PLCI   *p
         if (ncci_ptr->data_out == MAX_DATA_B3)
           ncci_ptr->data_out = 0;
--
     while (i != plci->msg_in_write_pos)
     {
       if (i == plci->msg_in_wrap_pos)
@@ -1036,6 +1074,12 @@ static void plci_free_msg_in_queue (PLCI
       i += (((CAPI_MSG   *)(&((byte   *)(plci->msg_in_queue))[i]))->header.length +
         MSG_IN_OVERHEAD + 3) & 0xfffc;
--
   while(ploc<plci->Sig.RBuffer->length-1) {
 
         /* read information element id and length                   */
@@ -9003,6 +9052,12 @@ static void IndParse(PLCI *plci, word *p
     }
 
--
     while ((w < DTMF_DIGIT_MAP_ENTRIES)
       && (digit_buffer[i] != dtmf_digit_map[w].character))
     {
       w++;
+      if (_cur < timeout) {
+        rdstcll(_cur);
--
         while ((i < dtmf_parms[3].length) && (j < DTMF_DIGIT_MAP_ENTRIES))
         {
           j = 0;
+          unsigned long long delta = (cpu / khz / HZ) * 2;
+          unsigned long long _start = 0;
+          unsigned long long _cur = 0;
--
           while ((j < DTMF_DIGIT_MAP_ENTRIES)
             && ((dtmf_parms[3].info[i+1] != dtmf_digit_map[j].character)
              || ((dtmf_digit_map[j].send_mask & mask) == 0)))
           {
             j++;
+            if (_cur < timeout) {
--
     while ((j < DTMF_DIGIT_MAP_ENTRIES)
       && ((msg[i] != dtmf_digit_map[j].code)
        || ((dtmf_digit_map[j].listen_mask & plci->dtmf_rec_active) == 0)))
     {
       j++;
+      if (_cur < timeout) {
--
       while ((j < li_total_channels)
         && ((r == 0)
          || (!(li_config_table[j].channel & LI_CHANNEL_ADDRESSES_SET))
@@ -10980,6 +11084,12 @@ static byte xconnect_write_coefs_process
         j++;
         if (j < li_total_channels)
--
   while (i + sizeof(word) <= a->adv_voice_coef_length)
   {
     PUT_WORD (p, GET_WORD (a->adv_voice_coef_buffer + i));
     p += 2;
     i += 2;
+    if (_cur < timeout) {
--
   while (i < ADV_VOICE_OLD_COEF_COUNT * sizeof(word))
   {
     PUT_WORD (p, 0x8000);
     p += 2;
     i += 2;
+    if (_cur < timeout) {
--
         while (ncci_ptr->data_pending)
         {
           plci->data_sent_ptr = ncci_ptr->DBuffer[ncci_ptr->data_out].P;
           data_rc (plci, plci->adapter->ncci_ch[plci->adjust_b_ncci]);
+          if (_cur < timeout) {
+        rdstcll(_cur);
--
         while (ncci_ptr->data_ack_pending)
           data_ack (plci, plci->adapter->ncci_ch[plci->adjust_b_ncci]);
diff -u -p a/isdn/hardware/avm/c4.c b/isdn/hardware/avm/c4.c
--- a/isdn/hardware/avm/c4.c
+++ b/isdn/hardware/avm/c4.c
@@ -148,10 +148,21 @@ static inline int wait_for_doorbell(avmc
--
 	while (c4inmeml(card->mbase+DOORBELL) != 0xffffffff) {
 		if (!time_before(jiffies, stop))
 			return -1;
 		mb();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (left >= sizeof(u32)) {
 	        if (t4file->user) {
 			if (copy_from_user(&val, dp, sizeof(val)))
@@ -216,6 +232,12 @@ static int c4_load_t4file(avmcard *card,
 		left -= sizeof(u32);
 		dp += sizeof(u32);
--
 	while (c4inmeml(card->mbase+DOORBELL) != 0xffffffff) {
 		if (!time_before(jiffies, stop))
 			return;
 		c4outmeml(card->mbase+DOORBELL, DBELL_ADDR);
 		mb();
+		if (_cur < timeout) {
--
 	while (c4inmeml(card->mbase+DOORBELL) != 0xffffffff) {
 		if (!time_before(jiffies, stop))
 			return 2;
 		c4outmeml(card->mbase+DOORBELL, DBELL_ADDR);
 		mb();
+		if (_cur < timeout) {
--
-		while (    MsgLen > 0
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (    MsgLen > 0
 		       && (   card->msgbuf[MsgLen-1] == '\n'
 			   || card->msgbuf[MsgLen-1] == '\r')) {
 			card->msgbuf[MsgLen-1] = 0;
 			MsgLen--;
+			if (_cur < timeout) {
--
-		while (    MsgLen > 0
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (    MsgLen > 0
 		       && (   card->msgbuf[MsgLen-1] == '\n'
 			   || card->msgbuf[MsgLen-1] == '\r')) {
 			card->msgbuf[MsgLen-1] = 0;
 			MsgLen--;
+			if (_cur < timeout) {
--
 	while (left >= sizeof(u32)) {
 	        if (config->user) {
 			if (copy_from_user(val, dp, sizeof(val)))
@@ -836,6 +907,12 @@ static int c4_send_config(avmcard *card,
 			return retval;
 		left -= sizeof(val);
--
 	while (left > FWBUF_SIZE) {
 		if (t4file->user) {
 			if (copy_from_user(buf, dp, FWBUF_SIZE))
@@ -173,6 +178,12 @@ int b1_load_t4file(avmcard *card, capilo
 			}
 		left -= FWBUF_SIZE;
--
 	while (left > FWBUF_SIZE) {
 		if (config->user) {
 			if (copy_from_user(buf, dp, FWBUF_SIZE))
@@ -221,6 +237,12 @@ int b1_load_config(avmcard *card, capilo
 		}
 		left -= FWBUF_SIZE;
--
-		while (    MsgLen > 0
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (    MsgLen > 0
 		       && (   card->msgbuf[MsgLen-1] == '\n'
 			   || card->msgbuf[MsgLen-1] == '\r')) {
 			card->msgbuf[MsgLen-1] = 0;
 			MsgLen--;
+			if (_cur < timeout) {
--
-		while (    MsgLen > 0
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (    MsgLen > 0
 		       && (   card->msgbuf[MsgLen-1] == '\n'
 			   || card->msgbuf[MsgLen-1] == '\r')) {
 			card->msgbuf[MsgLen-1] = 0;
 			MsgLen--;
+			if (_cur < timeout) {
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len--) {
 		while (   !b1dma_tx_empty(card->port)
 		       && time_before(jiffies, stop));
 		if (!b1dma_tx_empty(card->port)) 
 			return -1;
 	        t1outp(card->port, 0x01, *s++);
+	        if (_cur < timeout) {
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len--) {
 		while (   !b1dma_rx_full(card->port)
 		       && time_before(jiffies, stop));
 		if (!b1dma_rx_full(card->port)) 
 			return -1;
 	        *s++ = t1inp(card->port, 0x00);
+	        if (_cur < timeout) {
--
-		while (    MsgLen > 0
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (    MsgLen > 0
 		       && (   card->msgbuf[MsgLen-1] == '\n'
 			   || card->msgbuf[MsgLen-1] == '\r')) {
 			card->msgbuf[MsgLen-1] = 0;
 			MsgLen--;
+			if (_cur < timeout) {
--
-		while (    MsgLen > 0
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (    MsgLen > 0
 		       && (   card->msgbuf[MsgLen-1] == '\n'
 			   || card->msgbuf[MsgLen-1] == '\r')) {
 			card->msgbuf[MsgLen-1] = 0;
 			MsgLen--;
+			if (_cur < timeout) {
--
 	while (b1_rx_full(card->port)) {
 
 		b1cmd = b1_get_byte(card->port);
@@ -242,11 +247,22 @@ static irqreturn_t t1isa_interrupt(int i
 			MsgLen = t1_get_slice(card->port, card->msgbuf);
 			spin_unlock_irqrestore(&card->lock, flags);
--
-			while (    MsgLen > 0
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (    MsgLen > 0
 			       && (   card->msgbuf[MsgLen-1] == '\n'
 				   || card->msgbuf[MsgLen-1] == '\r')) {
 				card->msgbuf[MsgLen-1] = 0;
 				MsgLen--;
+				if (_cur < timeout) {
--
-			while (    MsgLen > 0
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (    MsgLen > 0
 			       && (   card->msgbuf[MsgLen-1] == '\n'
 				   || card->msgbuf[MsgLen-1] == '\r')) {
 				card->msgbuf[MsgLen-1] = 0;
 				MsgLen--;
+				if (_cur < timeout) {
--
 	while (cnt < count) {
 		val = le32_to_cpu(inl(addr));
 		put_unaligned(val, ptr);
 		ptr++;
 		cnt += 4;
+		if (_cur < timeout) {
--
 	while (cnt < count) {
 		val = get_unaligned(ptr);
 		outl(cpu_to_le32(val), addr);
 		ptr++;
 		cnt += 4;
+		if (_cur < timeout) {
--
 	while (cnt--) {
 		spin_lock_irqsave(&card->lock, flags);
 		initW6692(card);
@@ -931,6 +936,12 @@ init_card(struct w6692_hw *card)
 			reset_w6692(card);
 		} else
--
 	while (ci->typ != INF_NONE) {
 		if (ci->typ == typ)
 			return ci;
 		ci++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (alt_idx < intf->num_altsetting) {
 		iface = intf->altsetting + alt_idx;
 		probe_alt_setting = iface->desc.bAlternateSetting;
 		cfg_used = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (validconf[cfg_used][0]) {
 			cfg_found = 1;
 			vcf = validconf[cfg_used];
@@ -2026,8 +2036,20 @@ hfcsusb_probe(struct usb_interface *intf
 				}
 			}
--
 	while (cnt--) {
 		val = card->send.start[idx];
 		val &= mask;
@@ -204,6 +209,12 @@ fill_mem(struct tiger_ch *bc, u32 idx, u
 		card->send.start[idx++] = val;
 		if (idx >= card->send.size)
--
 	while (hfc_register_names[++i].name) {
 		if (hfc_register_names[i].reg == reg)
 			strcat(regname, hfc_register_names[i].name);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (hfc_register_names[i++].name)
 		;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while (hfc_register_names[++i].name) {
 		if (hfc_register_names[i].reg == reg)
 			strcat(regname, hfc_register_names[i].name);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (hfc_register_names[i++].name)
 		;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while (hfc_register_names[++i].name) {
 		if (hfc_register_names[i].reg == reg)
 			strcat(regname, hfc_register_names[i].name);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (len>>2) {
 		outl(cpu_to_le32(*(u32 *)data), hc->pci_iobase);
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len>>1) {
 		outw(cpu_to_le16(*(u16 *)data), hc->pci_iobase);
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len) {
 		outb(*data, hc->pci_iobase);
 		data++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (len>>2) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>2) {
 		writel(cpu_to_le32(*(u32 *)data),
 			hc->pci_membase + A_FIFO_DATA0);
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
--
-	while (len>>1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>1) {
 		writew(cpu_to_le16(*(u16 *)data),
 			hc->pci_membase + A_FIFO_DATA0);
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
--
 	while (len) {
 		writeb(*data, hc->pci_membase + A_FIFO_DATA0);
 		data++;
 		len--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (len>>2) {
 		*(u32 *)data = le32_to_cpu(inl(hc->pci_iobase));
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len>>1) {
 		*(u16 *)data = le16_to_cpu(inw(hc->pci_iobase));
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len) {
 		*data = inb(hc->pci_iobase);
 		data++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (len>>2) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>2) {
 		*(u32 *)data =
 			le32_to_cpu(readl(hc->pci_membase + A_FIFO_DATA0));
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
--
-	while (len>>1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>1) {
 		*(u16 *)data =
 			le16_to_cpu(readw(hc->pci_membase + A_FIFO_DATA0));
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
--
 	while (len) {
 		*data = readb(hc->pci_membase + A_FIFO_DATA0);
 		data++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (f2 != (temp = HFC_inb_nodebug(hc, A_F2))) {
 			if (debug & DEBUG_HFCMULTI_FIFO)
 				printk(KERN_DEBUG
 				    "%s(card %d): reread f2 because %d!=%d\n",
 				    __func__, hc->id + 1, temp, f2);
 			f2 = temp; /* repeat until F2 is equal */
--
 	while (z2 != (temp = (HFC_inw_nodebug(hc, A_Z2) - hc->Zmin))) {
 		if (debug & DEBUG_HFCMULTI_FIFO)
 			printk(KERN_DEBUG "%s(card %d): reread z2 because "
 				"%d!=%d\n", __func__, hc->id + 1, temp, z2);
 		z2 = temp; /* repeat unti Z2 is equal */
+		if (_cur < timeout) {
--
 		while (f1 != (temp = HFC_inb_nodebug(hc, A_F1))) {
 			if (debug & DEBUG_HFCMULTI_FIFO)
 				printk(KERN_DEBUG
 				    "%s(card %d): reread f1 because %d!=%d\n",
 				    __func__, hc->id + 1, temp, f1);
 			f1 = temp; /* repeat until F1 is equal */
--
 	while (z1 != (temp = (HFC_inw_nodebug(hc, A_Z1) - hc->Zmin))) {
 		if (debug & DEBUG_HFCMULTI_FIFO)
 			printk(KERN_DEBUG "%s(card %d): reread z2 because "
 				"%d!=%d\n", __func__, hc->id + 1, temp, z2);
 		z1 = temp; /* repeat until Z1 is equal */
+		if (_cur < timeout) {
--
 				while (st_status != (temp =
 					HFC_inb_nodebug(hc, A_ST_RD_STATE))) {
 					if (debug & DEBUG_HFCMULTI_STATE)
@@ -2572,6 +2786,12 @@ ph_state_irq(struct hfc_multi *hc, u_cha
 						    __func__, temp,
 						    st_status);
--
 	while (j < 8) {
 		ch = (block << 2) + (j >> 1);
 		dch = hc->chan[ch].dch;
@@ -2654,6 +2879,12 @@ fifo_irq(struct hfc_multi *hc, int block
 			hfcmulti_rx(hc, ch);
 		}
--
 				while (dch->state != (temp =
 					HFC_inb_nodebug(hc, R_E1_RD_STA))) {
 					if (debug & DEBUG_HFCMULTI_STATE)
@@ -2767,6 +3003,12 @@ hfcmulti_interrupt(int intno, void *dev_
 						    __func__, temp,
 						    dch->state);
--
 			while (pt) { /* release already registered ports */
 				pt--;
 				release_port(hc, hc->chan[(pt << 2) + 2].dch);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
 	while ((val & 1) && t) {
 		udelay(1);
 		t--;
 		val = isar->read_reg(isar->hw, ISAR_HIA);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-			while (l < (int)len) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (l < (int)len) {
 				hex_dump_to_buffer(msg + l, len - l, 32, 1,
 					isar->log, 256, 1);
 				pr_debug("%s: %s %02x: %s\n", isar->name,
 					__func__, l, isar->log);
 				l += 32;
--
-			while (l < (int)isar->clsb) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (l < (int)isar->clsb) {
 				hex_dump_to_buffer(msg + l, isar->clsb - l, 32,
 					1, isar->log, 256, 1);
 				pr_debug("%s: %s %02x: %s\n", isar->name,
 					__func__, l, isar->log);
 				l += 32;
--
 	while (t && !(irq & ISAR_IRQSTA)) {
 		udelay(1);
 		t--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cnt < size) {
 		blk_head.sadr = le16_to_cpu(*sp++);
 		blk_head.len = le16_to_cpu(*sp++);
@@ -246,7 +295,12 @@ load_firmware(struct isar_hw *isar, cons
 			ret = 1;
 			goto reterrflg;
--
-		while (left > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (left > 0) {
 			if (left > 126)
 				noc = 126;
 			else
@@ -262,11 +316,22 @@ load_firmware(struct isar_hw *isar, cons
 			pr_debug("%s: load %3d words at %04x\n", isar->name,
--
 			while (noc) {
 				val = le16_to_cpu(*sp++);
 				*mp++ = val >> 8;
 				*mp++ = val & 0xFF;
 				noc--;
+				if (_cur < timeout) {
--
 	while ((!isar->bstat) && cnt) {
 		mdelay(1);
 		cnt--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((isar->iis != ISAR_IIS_DIAG) && cnt) {
 		udelay(10);
 		cnt--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((isar->iis != ISAR_IIS_DIAG) && cnt) {
 		udelay(10);
 		cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (ista && cnt--) {
 			pr_debug("%s: ISTA %02x\n", ipac->name, ista);
 			if (ista & IPACX__ICA)
@@ -1165,9 +1170,20 @@ mISDNipac_irq(struct ipac_hw *ipac, int
 			if (ista & (ISACX__ICD | ISACX__CIC))
 				mISDNisac_irq(&ipac->isac, ista);
--
 		while (ista && cnt--) {
 			pr_debug("%s: ISTA %02x\n", ipac->name, ista);
 			if (ista & (IPAC__ICD | IPAC__EXD)) {
@@ -1184,6 +1200,12 @@ mISDNipac_irq(struct ipac_hw *ipac, int
 			if (ista & (IPAC__ICB | IPAC__EXB))
 				ipac_irq(&ipac->hscx[1], ista);
--
 		while (cnt) {
diff -u -p a/isdn/hardware/mISDN/hfcpci.c b/isdn/hardware/mISDN/hfcpci.c
--- a/isdn/hardware/mISDN/hfcpci.c
+++ b/isdn/hardware/mISDN/hfcpci.c
@@ -1768,7 +1768,12 @@ init_card(struct hfc_pci *hc)
 	}
--
-	while (cnt) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt) {
 		inithfcpci(hc);
 		/*
 		 * Finally enable IRQ output
@@ -1803,6 +1808,12 @@ init_card(struct hfc_pci *hc)
 			hc->initdone = 1;
--
 		while (fs->state != available) {
 			spin_unlock_irqrestore(&swim3_lock, flags);
 			if (interruptible && signal_pending(current)) {
@@ -848,6 +853,12 @@ static int grab_drive(struct floppy_stat
 			}
 			interruptible_sleep_on(&fs->wait);
--
 	while (time_before(jiffies, expire)) {
 		if (gpio_get_value(rstout) == 1)
 			return MG_ERR_NONE;
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len > 0) {
 		c = id[ofs] >> 8;
 		*s = c;
@@ -323,6 +339,12 @@ static void mg_id_string(const u16 *id,
 
 		ofs++;
--
 	while (!list_empty(&sc->luns)) {
 		p = sc->luns.next;
 		lun = list_entry(p, struct ub_lun, link);
@@ -532,6 +537,12 @@ static void ub_cleanup(struct ub_dev *sc
 
 		ub_id_put(lun->id);
--
 		while ((cmd = ub_cmdq_peek(sc)) != NULL) {
 			cmd->error = -ENOTCONN;
 			cmd->state = UB_CMDST_DONE;
 			ub_cmdq_pop(sc);
 			(*cmd->done)(sc, cmd);
 			cnt++;
--
 	while (req) {
 		unsigned block = blk_rq_pos(req);
 		unsigned count = blk_rq_cur_sectors(req);
@@ -335,6 +340,12 @@ static void do_xd_request (struct reques
 		/* wrap up, 0 = success, -errno = fail */
 		if (!__blk_end_request_cur(req, res))
--
 	while (count) {
 		temp = count < xd_maxsectors ? count : xd_maxsectors;
 
@@ -464,6 +480,12 @@ static int xd_readwrite (u_char operatio
 				buffer[i] = xd_dma_buffer[i];
 
--
 	while (!complete) {
 		if (xd_waitport(XD_STATUS,STAT_READY,STAT_READY,timeout))
 			return (1);
@@ -623,6 +650,12 @@ static u_int xd_command (u_char *command
 				complete = 1;
 				break;
--
 			while (min[i] != max[i] - 1) {
 				test[i] = (min[i] + max[i]) / 2;
 				xd_build(cmdblk,CMD_SEEK,drive,(u_char) test[0],(u_short) test[1],(u_char) test[2],0,0);
@@ -1011,6 +1049,12 @@ static void __init xd_override_init_driv
 					min[i] = test[i];
 				else
--
 	while (chain) {
 		tmp = chain;
 		chain = chain->bi_next;
 
 		bio_put(tmp);
+		if (_cur < timeout) {
--
 	while (old_chain) {
 		tmp = bio_kmalloc(gfpmask, old_chain->bi_max_vecs);
 		if (!tmp)
@@ -283,6 +299,12 @@ static struct bio *bio_chain_clone(struc
 		}
 
--
 	while (i < ccissscsi[h->ctlr].ndevices) {
 		csd = &ccissscsi[h->ctlr].dev[i];
 		found=0;
@@ -598,6 +603,12 @@ adjust_cciss_scsi_table(ctlr_info_t *h,
 				sizeof(csd->revision));
 		} else 		/* device is same as it ever was, */
--
 	while (1) {
 		enum action res;
 		unsigned long saved_flags;
@@ -429,6 +434,12 @@ static void run_fsm(void)
 				pi_disconnect(pi_current);
 				pd_claimed = 0;
--
 			while(count)
 			{
 				u8 d;
@@ -407,6 +412,12 @@ static void ppc6_rd_data_blk(Interface *
 
 				*data++ = d;
--
 			while(count)
 			{
 				ppc->cur_ctrl ^= data_stb;
@@ -429,6 +445,12 @@ static void ppc6_rd_data_blk(Interface *
 
 				*data++ = inb(ppc->lpt_addr);
--
 			while(count)
 			{
 				*data++ = inb(ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(count > 1)
 			{
 				*((u16 *)data) = inw(ppc->lpt_addr + 4);
 				data  += 2;
 				count -= 2;
+				if (_cur < timeout) {
--
 			while(count)
 			{
 				*data++ = inb(ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(count > 3)
 			{
 				*((u32 *)data) = inl(ppc->lpt_addr + 4);
 				data  += 4;
 				count -= 4;
+				if (_cur < timeout) {
--
 			while(count)
 			{
 				*data++ = inb(ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(count--)
 			{
 				outb(*data++, ppc->lpt_addr);
@@ -539,6 +621,12 @@ static void ppc6_wr_data_blk(Interface *
 				ppc->cur_ctrl ^= data_stb;
 
--
 			while(count)
 			{
 				this = *data++;
@@ -576,6 +669,12 @@ static void ppc6_wr_data_blk(Interface *
 
 					last = this;
--
 			while(count)
 			{
 				outb(*data++,ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(count > 1)
 			{
 				outw(*((u16 *)data),ppc->lpt_addr + 4);
 				data  += 2;
 				count -= 2;
+				if (_cur < timeout) {
--
 			while(count)
 			{
 				outb(*data++,ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(count > 3)
 			{
 				outl(*((u32 *)data),ppc->lpt_addr + 4);
 				data  += 4;
 				count -= 4;
+				if (_cur < timeout) {
--
 			while(count)
 			{
 				outb(*data++,ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while ((((r = status_reg(dev)) & go) || (stop && (!(r & stop))))
 	       && time_before(jiffies, tmo)) {
 		if (j++ < PG_SPIN)
 			udelay(PG_SPIN_DEL);
 		else
 			pg_sleep(1);
--
 	while (read_reg(dev, 7) & STAT_DRQ) {
 		d = (read_reg(dev, 4) + 256 * read_reg(dev, 5));
 		n = ((d + 3) & 0xfffc);
@@ -376,6 +392,12 @@ static int pg_completion(struct pg *dev,
 		buf += d;
 		r = pg_wait(dev, STAT_BUSY, STAT_DRQ | STAT_READY | STAT_ERR,
--
 	while (k < tmo) {
 		cd->last_sense = 0;
 		pcd_atapi(cd, tr_cmd, 0, NULL, DBMSG("test unit ready"));
@@ -589,6 +594,12 @@ static int pcd_ready_wait(struct pcd_uni
 			return p;
 		k++;
--
 	while ((k >= 0) && (id[k] <= 0x20)) {
 		id[k] = 0;
 		k--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (1) {
 		if (!pcd_req) {
 			pcd_req = blk_fetch_request(q);
@@ -756,6 +783,12 @@ static void do_pcd_request(struct reques
 			__blk_end_request_all(pcd_req, -EIO);
 			pcd_req = NULL;
--
 	while (pcd_count && (pcd_sector / 4 == pcd_bufblk)) {
 		int o = (pcd_sector % 4) * 512;
 		memcpy(pcd_buf, pcd_buffer + o, 512);
 		pcd_count--;
 		pcd_buf += 512;
 		pcd_sector++;
--
-	while (n >= PAGE_SIZE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (n >= PAGE_SIZE) {
 		/*
 		 * Don't want to actually discard pages here because
 		 * re-allocating the pages can result in writeback
@@ -224,6 +229,12 @@ static void discard_from_brd(struct brd_
 			brd_zero_page(brd, sector);
--
-	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
 
 		wait_event_interruptible(lo->lo_event,
 				!bio_list_empty(&lo->lo_bio_list) ||
@@ -549,6 +554,12 @@ static int loop_thread(void *data)
 
--
 	while (is_loop_device(f)) {
 		struct loop_device *l;
 
@@ -840,6 +856,12 @@ static int loop_set_fd(struct loop_devic
 			goto out_putf;
 		}
--
 	while (left) {
 		sz = (left > ioc->malloc_size) ? ioc->malloc_size : left;
 		buff_size[sg_used] = sz;
@@ -1631,6 +1636,12 @@ static int cciss_bigpassthru(ctlr_info_t
 		left -= sz;
 		data_ptr += sz;
--
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
 		while (raw_tag != FIFO_EMPTY)
 			raw_tag = next_command(h);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (raw_tag != FIFO_EMPTY) {
 			if (cciss_tag_contains_index(raw_tag))
 				raw_tag = process_indexed_cmd(h, raw_tag);
 			else
 				raw_tag = process_nonindexed_cmd(h, raw_tag);
+				if (_cur < timeout) {
--
 	while (raw_tag != FIFO_EMPTY) {
 		if (cciss_tag_contains_index(raw_tag))
 			raw_tag = process_indexed_cmd(h, raw_tag);
 		else
 			raw_tag = process_nonindexed_cmd(h, raw_tag);
+			if (_cur < timeout) {
--
 	while (req) {
 		int err = -EIO;
 
@@ -556,6 +561,12 @@ static void redo_fd_request(struct reque
 	done:
 		if (!__blk_end_request_cur(req, err))
--
-	while ((vbr = virtqueue_get_buf(vblk->vq, &len)) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((vbr = virtqueue_get_buf(vblk->vq, &len)) != NULL) {
 		int error;
 
 		switch (vbr->status) {
@@ -94,6 +99,12 @@ static void blk_done(struct virtqueue *v
 
--
 	while (nr_packets > 0) {
 		pkt = pkt_alloc_packet_data(pd->settings.size >> 2);
 		if (!pkt) {
@@ -653,6 +658,12 @@ static int pkt_grow_pktlist(struct pktcd
 		pkt->pd = pd;
 		list_add(&pkt->list, &pd->cdrw.pkt_free_list);
--
 	while (*p) {
 		parent = *p;
 		tmp = rb_entry(parent, struct pkt_rb_node, rb_node);
@@ -724,6 +740,12 @@ static void pkt_rbtree_insert(struct pkt
 			p = &(*p)->rb_left;
 		else
--
-	while (copy_size > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (copy_size > 0) {
 		struct bio_vec *src_bvl = bio_iovec_idx(src_bio, seg);
 		void *vfrom = kmap_atomic(src_bvl->bv_page, KM_USER0) +
 			src_bvl->bv_offset + offs;
@@ -1000,6 +1027,12 @@ static void pkt_copy_bio_data(struct bio
 		offs = 0;
--
 	while (node) {
 		bio = node->bio;
 		zone = ZONE(bio->bi_sector, pd);
@@ -1301,6 +1339,12 @@ try_next_bio:
 		}
 		if (node == first_node)
--
 			while (src_offs >= src_bvl->bv_len) {
 				src_offs -= src_bvl->bv_len;
 				segment++;
 				BUG_ON(segment >= bio->bi_vcnt);
 				src_bvl = bio_iovec_idx(bio, segment);
+				if (_cur < timeout) {
--
 	while (!list_empty(head)) {
 		prepare_to_wait(&mdev->ee_wait, &wait, TASK_UNINTERRUPTIBLE);
 		spin_unlock_irq(&mdev->req_lock);
 		io_schedule();
 		finish_wait(&mdev->ee_wait, &wait);
 		spin_lock_irq(&mdev->req_lock);
--
 	while (bios) {
 		bio = bios;
 		bios = bios->bi_next;
 		bio_put(bio);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (get_t_state(&mdev->receiver) == Running) {
 		drbd_thread_current_set_cpu(mdev);
 		if (!drbd_recv_header(mdev, &cmd, &packet_size))
@@ -3714,6 +3741,12 @@ static void drbdd(struct drbd_conf *mdev
 			    cmdname(cmd), packet_size);
 			goto err_out;
--
 	while (drbd_pp_pool) {
 		page = drbd_pp_pool;
 		drbd_pp_pool = (struct page *)page_private(page);
 		__free_page(page);
 		drbd_pp_vacant--;
+		if (_cur < timeout) {
--
 	while (try++ < max_tries) {
 		rv = _drbd_request_state(mdev, mask, val, CS_WAIT_COMPLETE);
 
@@ -391,6 +396,12 @@ drbd_set_role(struct drbd_conf *mdev, en
 				goto fail;
 		}
--
 	while (size >= 10000 && base < sizeof(units)-1) {
 		/* shift + round */
 		size = (size >> 10) + !!(size & (1<<9));
 		base++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (offset < end) {
 		do_now = min_t(size_t, ALIGN(offset + 1, LWPP), end) - offset;
 		idx = bm_word_to_page_idx(b, offset);
@@ -590,6 +595,12 @@ static void bm_memset(struct drbd_bitmap
 		bm_unmap(p_addr);
 		bm_set_page_need_writeout(b->bm_pages[idx]);
--
 	while ((tmp = page_chain_next(page))) {
 		/* all but the last page will be fully used */
 		sg_set_page(&sg, page, PAGE_SIZE, 0);
 		crypto_hash_update(&desc, &sg, sg.length);
 		page = tmp;
+		if (_cur < timeout) {
--
 	while (1) {
 		if (odev == mdev)
 			return ERR_SYNC_AFTER_CYCLE;
@@ -1432,6 +1448,12 @@ static int sync_after_error(struct drbd_
 
 		/* follow the dependency chain */
--
 	while (req) {
 		unsigned long start = blk_rq_pos(req) << 9;
 		unsigned long len  = blk_rq_cur_bytes(req);
@@ -87,6 +92,11 @@ static void do_z2_request(struct request
 			err = -EIO;
 			goto done;
--
 		while (len) {
 			unsigned long addr = start & Z2RAM_CHUNKMASK;
 			unsigned long size = Z2RAM_CHUNKSIZE - addr;
@@ -99,10 +109,22 @@ static void do_z2_request(struct request
 				memcpy((char *)addr, req->buffer, size);
 			start += size;
--
 		while (size) {
 			z2ram_map[ z2ram_size++ ] = vaddr;
 			size -= Z2RAM_CHUNKSIZE;
 			vaddr += Z2RAM_CHUNKSIZE;
 			list_count++;
+			if (_cur < timeout) {
--
-	  while (DAC960_GEM_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_GEM_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_GEM_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2808,7 +2813,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_BA_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_BA_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_BA_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2838,7 +2854,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_LP_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_LP_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_LP_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2868,7 +2895,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_LA_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_LA_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_LA_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2898,7 +2936,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_PG_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_PG_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_PG_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2930,7 +2979,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_PD_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_PD_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_PD_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2968,7 +3028,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
-	  while (DAC960_PD_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_PD_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_PD_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -3004,7 +3075,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
--
    while(1) {
 	Request = blk_peek_request(req_q);
 	if (!Request)
@@ -3357,6 +3439,12 @@ static int DAC960_process_queue(DAC960_C
 		 Command->SegmentCount, Command->DmaDirection);
 
--
 	  while (PhysicalDeviceInfo != NULL &&
 		 (NewPhysicalDeviceInfo->Channel >
 		  PhysicalDeviceInfo->Channel ||
@@ -4776,6 +4869,12 @@ static void DAC960_V2_ProcessCompletedCo
 		Controller->V2.PhysicalDeviceInformation[PhysicalDeviceIndex];
 	      InquiryUnitSerialNumber =
--
-  while (NextStatusMailbox->Fields.CommandIdentifier > 0)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (NextStatusMailbox->Fields.CommandIdentifier > 0)
     {
        DAC960_V2_CommandIdentifier_T CommandIdentifier =
            NextStatusMailbox->Fields.CommandIdentifier;
@@ -5283,6 +5387,12 @@ static irqreturn_t DAC960_GEM_InterruptH
        if (++NextStatusMailbox > Controller->V2.LastStatusMailbox)
--
-  while (NextStatusMailbox->Fields.CommandIdentifier > 0)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (NextStatusMailbox->Fields.CommandIdentifier > 0)
     {
       DAC960_V2_CommandIdentifier_T CommandIdentifier =
 	NextStatusMailbox->Fields.CommandIdentifier;
@@ -5324,6 +5439,12 @@ static irqreturn_t DAC960_BA_InterruptHa
       if (++NextStatusMailbox > Controller->V2.LastStatusMailbox)
--
-  while (NextStatusMailbox->Fields.CommandIdentifier > 0)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (NextStatusMailbox->Fields.CommandIdentifier > 0)
     {
       DAC960_V2_CommandIdentifier_T CommandIdentifier =
 	NextStatusMailbox->Fields.CommandIdentifier;
@@ -5366,6 +5492,12 @@ static irqreturn_t DAC960_LP_InterruptHa
       if (++NextStatusMailbox > Controller->V2.LastStatusMailbox)
--
-  while (NextStatusMailbox->Fields.Valid)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (NextStatusMailbox->Fields.Valid)
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	NextStatusMailbox->Fields.CommandIdentifier;
@@ -5404,6 +5541,12 @@ static irqreturn_t DAC960_LA_InterruptHa
       if (++NextStatusMailbox > Controller->V1.LastStatusMailbox)
--
-  while (NextStatusMailbox->Fields.Valid)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (NextStatusMailbox->Fields.Valid)
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	NextStatusMailbox->Fields.CommandIdentifier;
@@ -5442,6 +5590,12 @@ static irqreturn_t DAC960_PG_InterruptHa
       if (++NextStatusMailbox > Controller->V1.LastStatusMailbox)
--
-  while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	DAC960_PD_ReadStatusCommandIdentifier(ControllerBaseAddress);
@@ -5477,6 +5636,12 @@ static irqreturn_t DAC960_PD_InterruptHa
       DAC960_PD_AcknowledgeInterrupt(ControllerBaseAddress);
--
-  while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	DAC960_PD_ReadStatusCommandIdentifier(ControllerBaseAddress);
@@ -5550,6 +5720,12 @@ static irqreturn_t DAC960_P_InterruptHan
 	  break;
--
-	  while (Controller->V2.NewControllerInformation->PhysicalScanActive)
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (Controller->V2.NewControllerInformation->PhysicalScanActive)
 	    {
 	      DAC960_ExecuteCommand(Command);
 	      sleep_on_timeout(&Controller->CommandWaitQueue, HZ);
+	      if (_cur < timeout) {
+					rdstcll(_cur);
--
 	    while ((Command = DAC960_AllocateCommand(Controller)) == NULL)
 	      DAC960_WaitForCommand(Controller);
-	    while (Controller->V1.DirectCommandActive[DCDB.Channel]
+	    unsigned long long delta = (cpu / khz / HZ) * 2;
+	    unsigned long long _start = 0;
+	    unsigned long long _cur = 0;
+	      unsigned long long timeout;
+	      timeout = rdstcll(start) + delta;
+	      while (Controller->V1.DirectCommandActive[DCDB.Channel]
 						     [DCDB.TargetID])
 	      {
 		spin_unlock_irq(&Controller->queue_lock);
@@ -6774,6 +6966,12 @@ static long DAC960_gam_ioctl(struct file
 			     !Controller->V1.DirectCommandActive
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		if (try_to_freeze())
 			continue;
 		if (unlikely(vbd->size != vbd_sz(vbd)))
@@ -307,6 +312,12 @@ int xen_blkif_schedule(void *arg)
 
--
-		while ((bio == NULL) ||
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((bio == NULL) ||
 		       (bio_add_page(bio,
 				     blkbk->pending_page(pending_req, i),
 				     seg[i].nsec << 9,
@@ -743,6 +759,12 @@ static int dispatch_rw_block_io(struct x
 			bio->bi_private = pending_req;
--
 	while (size > 0) {
 		const int sz = min(size, LOOP_IV_SECTOR_SIZE);
 		u32 iv[4] = { 0, };
@@ -161,6 +166,12 @@ cryptoloop_transfer(struct loop_device *
 		size -= sz;
 		in_offs += sz;
--
 	while (slen && (port->name[slen - 1] == ' ')) {
 		port->name[slen - 1] = 0;
 		slen--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (1) {
 		u32 status = le32_to_cpu(resp[idx].status);
 
@@ -1191,6 +1207,12 @@ static inline void carm_handle_responses
 
 		idx = NEXT_RESP(idx);
--
 	while (!list_empty(&d->bufq)) {
 		buf = container_of(d->bufq.next, struct buf, bufs);
 		list_del(d->bufq.next);
 		bio = buf->bio;
 		mempool_free(buf, d->bufpool);
 		bio_endio(bio, -EIO);
--
 	while ((d = *dd)) {
 		spin_lock(&d->lock);
 		if ((!all && (d->flags & DEVFL_UP))
@@ -153,12 +169,29 @@ aoedev_flush(const char __user *str, siz
 		spin_unlock(&d->lock);
 		d->next = rmd;
--
 	while ((d = rmd)) {
 		rmd = d->next;
 		del_timer_sync(&d->timer);
 		aoedev_freedev(d);	/* must be able to sleep */
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((d = devlist)) {
 		devlist = d->next;
 
@@ -267,6 +305,12 @@ aoedev_exit(void)
 
 		del_timer_sync(&d->timer);
--
 	while (errcnt < MAX_ERRORS) {
 		if (!fd_seek(drive, track))
 			return -1;
@@ -1329,6 +1334,12 @@ static int get_track(int drive, int trac
 		/* Read Error Handling: recalibrate and try again */
 		unit[drive].track = -1;
--
 	while (i--) {
 		struct request_queue *q = unit[i].disk->queue;
 
 		put_disk(unit[i].disk);
 		if (q)
 			blk_cleanup_queue(q);
--
 	while (chain) {
 		tmp = chain;
 		chain = chain->bi_next;
 		bio_put(tmp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (chain) {
 		bio_for_each_segment(bv, chain, i) {
 			if (pos + bv->bv_len > start_ofs) {
@@ -676,6 +692,12 @@ static void zero_bio_chain(struct bio *c
 		}
 
--
 	while (old_chain && (total < len)) {
 		tmp = bio_kmalloc(gfpmask, old_chain->bi_max_vecs);
 		if (!tmp)
@@ -739,6 +766,12 @@ static struct bio *bio_chain_clone(struc
 		old_chain = old_chain->bi_next;
 
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		int len = sizeof(*dh) +
 			  snap_count * sizeof(struct rbd_image_snap_ondisk) +
 			  snap_names_len;
@@ -1600,6 +1638,12 @@ static int rbd_read_header(struct rbd_de
 			continue;
--
 	while (!list_empty(&rbd_dev->snaps)) {
 		snap = list_first_entry(&rbd_dev->snaps, struct rbd_snap, node);
 		__rbd_remove_snap_dev(rbd_dev, snap);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (*name) {
 		if (name == start)
 			return start;
 		name--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (ace->id_req_count) {
 			complete(&ace->id_completion);
 			ace->id_req_count--;
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (ace->id_req_count) {
 			complete(&ace->id_completion);
 			ace->id_req_count--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (num_req_outstanding < VIOMAXREQ) {
 		req = blk_fetch_request(q);
 		if (req == NULL)
@@ -386,6 +391,12 @@ static void do_viodasd_request(struct re
 		/* Try sending the request */
 		if (send_request(req) != 0)
--
 	while (1) {
 		if (probed_format >= 8 || !DP->autodetect[probed_format]) {
 			DRS->probed_format = 0;
@@ -2026,6 +2031,12 @@ static int next_valid_format(void)
 			return 0;
 		}
--
 		while (tracksize <= fsector_t % _floppy->sect) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (tracksize + ssize > _floppy->sect) {
 				SIZECODE--;
 				ssize >>= 1;
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
--
 	while (ptr) {
 		struct floppy_raw_cmd cmd = *ptr;
 		cmd.next = NULL;
@@ -3078,6 +3116,12 @@ static int raw_cmd_copyout(int cmd, void
 			}
 		}
--
-	while (this) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (this) {
 		if (this->buffer_length) {
 			fd_dma_mem_free((unsigned long)this->kernel_data,
 					this->buffer_length);
@@ -3099,6 +3148,12 @@ static void raw_cmd_free(struct floppy_r
 		next = this->next;
--
 	while (drive--) {
 		if ((allowed_drive_mask & (1 << drive)) &&
 		    fdc_state[FDC(drive)].version != FDC_NONE) {
@@ -4334,7 +4394,13 @@ out_remove_drives:
 			device_remove_file(&floppy_device[drive].dev, &dev_attr_cmos);
 			platform_device_unregister(&floppy_device[drive]);
--
 	while (dr--) {
 		del_timer_sync(&motor_off_timer[dr]);
 		if (disks[dr]->queue) {
@@ -4356,6 +4427,12 @@ out_put_disk:
 			disks[dr]->queue = NULL;
 		}
--
 	while (p != io_regions) {
 		p--;
 		release_region(FDCS->address + p->offset, p->size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (*cfg) {
 		ptr = cfg;
 		while (*cfg && *cfg != ' ' && *cfg != '\t')
@@ -4534,6 +4627,12 @@ static void __init parse_floppy_cfg_stri
 		}
 		if (*ptr)
 			floppy_setup(ptr);
+			if (_cur < timeout) {
--
 	while (count) {
 		unsigned int offset, avail;
 		unsigned int entry;
@@ -466,6 +471,12 @@ static int ps3vram_read(struct ps3_syste
 		buf += avail;
 		count -= avail;
--
 	while (count) {
 		unsigned int offset, avail;
 		unsigned int entry;
@@ -509,6 +525,12 @@ static int ps3vram_write(struct ps3_syst
 		buf += avail;
 		count -= avail;
--
 	while(c && c != h->reqQ) {
 		seq_printf(m, "->%p", c);
 		c=c->next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while(c && c != h->cmpQ) {
 		seq_printf(m, "->%p", c);
 		c=c->next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (j--) {
 		put_disk(ida_gendisk[i][j]);
 		ida_gendisk[i][j] = NULL;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while((c = h->reqQ) != NULL) {
 		/* Can't do anything if we're busy */
 		if (h->access.fifo_full(h) == 0)
@@ -992,6 +1030,12 @@ static void start_io(ctlr_info_t *h)
 
 		/* Get onto the completion Q */
--
 		while((a = h->access.command_completed(h))) {
 			a1 = a; a &= ~3;
 			if ((c = h->cmpQ) == NULL)
@@ -1096,6 +1145,12 @@ static irqreturn_t do_ida_intr(int irq,
 				}
 				continue;
--
 	while (return_bio) {
 		struct bio *bio = return_bio;
 
 		return_bio = bio->bi_next;
 		bio->bi_next = NULL;
 		bio_endio(bio, 0);
--
 	while (len > 0) {
 		c = id[ofs] >> 8;
 		*s = c;
@@ -344,6 +349,12 @@ static void ata_id_string(const u16 *id,
 
 		ofs++;
--
-	while (!list_empty(&lo->queue_head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&lo->queue_head)) {
 		req = list_entry(lo->queue_head.next, struct request,
 				 queuelist);
 		list_del_init(&req->queuelist);
 		req->errors++;
 		nbd_end_request(req);
--
-	while (!list_empty(&lo->waiting_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&lo->waiting_queue)) {
 		req = list_entry(lo->waiting_queue.next, struct request,
 				 queuelist);
 		list_del_init(&req->queuelist);
 		req->errors++;
 		nbd_end_request(req);
--
-	while (!kthread_should_stop() || !list_empty(&lo->waiting_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop() || !list_empty(&lo->waiting_queue)) {
 		/* wait for something to do */
 		wait_event_interruptible(lo->waiting_wq,
 					 kthread_should_stop() ||
@@ -528,6 +555,12 @@ static int nbd_thread(void *data)
 
--
-	while ((req = blk_fetch_request(q)) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((req = blk_fetch_request(q)) != NULL) {
 		struct nbd_device *lo;
 
 		spin_unlock_irq(q->queue_lock);
@@ -571,6 +609,12 @@ static void do_nbd_request(struct reques
 		wake_up(&lo->waiting_wq);
--
 	while (i--) {
 		blk_cleanup_queue(nbd_dev[i].disk->queue);
 		put_disk(nbd_dev[i].disk);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((offset < len - 1) && (i < LP5521_PROGRAM_LENGTH)) {
 		/* separate sscanfs because length is working only for %s */
 		ret = sscanf(buf + offset, "%2s%n ", c, &nrchars);
@@ -374,6 +379,12 @@ static int lp5521_do_store_load(struct l
 
 		offset += nrchars;
--
 	while (--i >= 0) {
 		switch (data->leds[i].type) {
 		case PCA9532_TYPE_NONE:
@@ -317,7 +322,13 @@ static int pca9532_destroy_devices(struc
 			}
 			break;
--
 	while (pulses--) {
 		gpio_set_value_cansleep(led_dat->gpio, 0);
 		udelay(1);
 		gpio_set_value_cansleep(led_dat->gpio, 1);
 		udelay(1);
+		if (_cur < timeout) {
--
 	while (i--) {
 		led_classdev_unregister(&pca955x[i].led_cdev);
 		cancel_work_sync(&pca955x[i].work);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((offset < len - 1) && (i < LP5523_PROGRAM_LENGTH)) {
 		/* separate sscanfs because length is working only for %s */
 		ret = sscanf(buf + offset, "%2s%n ", c, &nrchars);
@@ -556,6 +561,12 @@ static int lp5523_do_store_load(struct l
 
 		offset += nrchars;
--
 		while (1) {
 			buf = skip_spaces(buf);
 			if (!strnicmp(buf, "io", 2)) {
@@ -393,6 +398,12 @@ static ssize_t pnp_set_current_resources
 				continue;
 			}
--
 	while (pos) {
 		str += sprintf(str, "%s\n", pos->id);
 		pos = pos->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (pos) {
 		if (memcmp(pos->id, id, 3) == 0)
 			if (compare_func(pos->id, id) == 1)
 				return 1;
 		pos = pos->next;
+		if (_cur < timeout) {
--
 	while (*drv_id->id) {
 		if (compare_pnp_id(dev->id, drv_id->id))
 			return drv_id;
 		drv_id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (new_option && pnp_option_set(new_option) == set) {
 			if (new_option->type == IORESOURCE_IRQ) {
 				irq = &new_option->u.irq;
@@ -197,6 +202,12 @@ static void quirk_add_irq_optional_depen
 			dbg_pnp_show_option(dev, new_option);
 			new_option = list_entry(new_option->list.next,
--
 	while (!pnp_check_port(dev, res)) {
 		res->start += rule->align;
 		res->end = res->start + rule->size - 1;
@@ -54,6 +59,12 @@ static int pnp_assign_port(struct pnp_de
 				(unsigned long long) rule->max);
 			return -EBUSY;
--
 	while (!pnp_check_mem(dev, res)) {
 		res->start += rule->align;
 		res->end = res->start + rule->size - 1;
@@ -106,6 +122,12 @@ static int pnp_assign_mem(struct pnp_dev
 				(unsigned long long) rule->max);
 			return -EBUSY;
--
 	while (1) {
 		int status;
 
@@ -196,6 +201,12 @@ static int pnp_dock_thread(void *unused)
 #endif
 			}
--
 	while ((char *)p < (char *)end) {
 		if (p[0] & 0x80) {	/* large tag */
 			len = (p[2] << 8) | p[1];
@@ -272,6 +288,12 @@ static void pnpbios_zero_data_stream(str
 		for (i = 0; i < len; i++)
 			p[i] = 0;
--
 	while ((str != NULL) && (*str != '\0')) {
 		if (strncmp(str, "off", 3) == 0)
 			pnpbios_disabled = 1;
@@ -422,6 +449,12 @@ static int __init pnpbios_setup(char *st
 		str = strchr(str, ',');
 		if (str != NULL)
--
 	while (*drv_id->id) {
 		if (compare_pnp_id(card->id, drv_id->id)) {
 			int i = 0;
@@ -44,6 +49,12 @@ static const struct pnp_card_device_id *
 			}
 		}
--
 	while (id) {
 		next = id->next;
 		kfree(id);
 		id = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (pos) {
 		str += sprintf(str, "%s\n", pos->id);
 		pos = pos->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (pos != &card->devices) {
 		dev = card_to_pnp_dev(pos);
 		if ((!dev->card_link) && compare_pnp_id(dev->id, id))
 			goto found;
 		pos = pos->next;
+		if (_cur < timeout) {
--
-	while (i < res_cnt) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < res_cnt) {
 		switch (resource->type) {
 		case ACPI_RESOURCE_TYPE_IRQ:
 			pnpacpi_encode_irq(dev, resource,
@@ -1156,6 +1161,12 @@ int pnpacpi_encode_resources(struct pnp_
 		}
--
 	while (id) {
 		next = id->next;
 		kfree(id);
 		id = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (list != &pnp_cards) {
 		struct pnp_card *card = global_to_pnp_card(list);
 
 		if (compare_pnp_id(card->id, id) || (memcmp(id, any, 7) == 0))
 			return card;
 		list = list->next;
--
 		while (list != &pnp_global) {
 			struct pnp_dev *dev = global_to_pnp_dev(list);
 
@@ -64,6 +80,12 @@ struct pnp_dev *pnp_find_dev(struct pnp_
 			    (memcmp(id, any, 7) == 0))
 				return dev;
--
 		while (list != &card->devices) {
 			struct pnp_dev *dev = card_to_pnp_dev(list);
 
 			if (compare_pnp_id(dev->id, id))
 				return dev;
 			list = list->next;
--
 		while (len) {
 			sys = set_cis_map(s, card_offset, flags);
 			if (!sys) {
@@ -196,6 +201,12 @@ int pcmcia_read_cis_mem(struct pcmcia_so
 			}
 			card_offset += s->map_size;
--
 		while (len) {
 			sys = set_cis_map(s, card_offset, flags);
 			if (!sys) {
@@ -270,6 +286,12 @@ int pcmcia_write_cis_mem(struct pcmcia_s
 			}
 			card_offset += s->map_size;
--
 			while (*p & 0x80) {
 				if (++p == q)
 					return NULL;
@@ -933,6 +960,12 @@ static u_char *parse_power(u_char *p, u_
 					pwr->flags |= CISTPL_POWER_HIGHZ_REQ;
 				else
--
 		while (e->regbit) {
 			if (pscr & e->regbit)
 				events |= e->eventbit;
 
 			e++;
+			if (_cur < timeout) {
--
 			while (nmemb--) {
 				writeb(*bp++, addr);
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
--
 			while (nmemb--) {
 	    		*bp++ = readb(addr);
+	    		if (_cur < timeout) {
+		rdstcll(_cur);
+	    		}
+	    		else {
--
-			while (nmemb--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (nmemb--) {
 #ifdef PCC_DEBUG_DBEX
 				if (_dbex) {
 					unsigned char *cp = (unsigned char *)bp;
@@ -191,10 +218,21 @@ void pcc_iorw(int sock, unsigned long po
 				} else
--
-	    	while (nmemb--) {
+	    	unsigned long long delta = (cpu / khz / HZ) * 2;
+	    	unsigned long long _start = 0;
+	    	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (nmemb--) {
 #ifdef  PCC_DEBUG_DBEX
 				if (_dbex) {
 					unsigned char *cp = (unsigned char *)bp;
@@ -206,6 +244,12 @@ void pcc_iorw(int sock, unsigned long po
 				} else
--
 	while (did && did->match_flags) {
 		for (i = 0; i < 4; i++) {
 			if (!did->prod_id[i])
@@ -71,6 +76,12 @@ static void pcmcia_check_driver(struct p
 				"details\n");
 		}
--
 	while (did && did->match_flags) {
 		dev_dbg(dev, "trying to match to %s\n", drv->name);
 		if (pcmcia_devmatch(p_dev, did)) {
@@ -912,6 +928,12 @@ static int pcmcia_bus_match(struct devic
 			return 1;
 		}
--
 	while (i-- > 0) {
 		skt = PCMCIA_SOCKET(i);
 
@@ -459,6 +464,12 @@ out_err:
 #endif
 		ops->hw_shutdown(skt);
--
 	while (!gpio_get_value(GPIO_NR_PALMTC_PCMCIA_PWRREADY) &&
 		timeout) {
 		mdelay(1);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (__raw_readl(&rtcreg->ctl) & TX4939_RTCCTL_BUSY) {
 		/* timeout on approx. 100us (@ GBUS200MHz) */
 		if (i++ > 200 * 100)
 			return -EBUSY;
 		cpu_relax();
+		if (_cur < timeout) {
--
 	while (secs != secs2 && --timeout) {
 		secs = secs2;
 		secs2 = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
@@ -89,10 +89,21 @@ static int tegra_rtc_wait_while_busy(str
 
 	/* first wait for the RTC to become busy. this is when it
 	 * posts its updated seconds+msec registers to AHB side. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
--
 	while (tegra_rtc_check_busy(info)) {
 		if (!retries--)
 			goto retry_failed;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((msm6242_read(priv, MSM6242_CD) & MSM6242_CD_BUSY) && cnt) {
 		msm6242_clear(priv, MSM6242_CD_HOLD, MSM6242_CD);
 		udelay(70);
 		msm6242_set(priv, MSM6242_CD_HOLD, MSM6242_CD);
 		cnt--;
+		if (_cur < timeout) {
--
 	while (*p) {
 		struct daisydev *dev = *p;
 		if (dev->port != port) {
@@ -186,6 +191,12 @@ void parport_daisy_fini(struct parport *
 		}
 		*p = dev->next;
--
 	while (p) {
 		char *sep;
 		q = strchr(p, ';');
@@ -74,9 +79,20 @@ static void parse_data(struct parport *p
 			while (u >= p && *u == ' ')
 				*u-- = '\0';
 			u = p;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
--
 			while (*u) {
 				*u = toupper(*u);
 				u++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-		while(len2 < idlen && retval > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while(len2 < idlen && retval > 0) {
 			char tmp[4];
 			retval = parport_read (port, tmp,
 					       min(sizeof tmp, idlen-len2));
 			if (retval < 0)
 				return retval;
--
 	while (time_before (jiffies, deadline)) {
 		if (signal_pending (current))
 			return -EINTR;
@@ -217,6 +222,12 @@ int parport_wait_peripheral(struct parpo
 			 * Wait for another 10ms. */
 			schedule_timeout_interruptible(msecs_to_jiffies(10));
--
 	while (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {
 		uiomem->size = 0;
 		++uiomem;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {
 		uiomem->size = 0;
 		++uiomem;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (atomic_read(&dev->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&dev->refcnt)) {
 		printk(KERN_INFO "Waiting for %s to become free: refcnt=%d.\n",
 		       dev->name, atomic_read(&dev->refcnt));
 		msleep(1000);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (head != tail) {
 		iommu_print_event(iommu, iommu->evt_buf + head);
 		head = (head + EVENT_ENTRY_SIZE) % iommu->evt_buf_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (*sem == 0 && i < LOOP_TIMEOUT) {
 		udelay(1);
 		i += 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (level > end_lvl) {
 		if (!IOMMU_PTE_PRESENT(*pte)) {
 			page = (u64 *)get_zeroed_page(gfp);
@@ -944,6 +971,12 @@ static u64 *alloc_pte(struct protection_
 			*pte_page = pte;
 
--
 	while (level > 0) {
 
 		/* Not Present */
@@ -994,6 +1032,12 @@ static u64 *fetch_pte(struct protection_
 		/* Walk to the next level */
 		pte = IOMMU_PTE_PAGE(*pte);
--
-		while (*entry) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (*entry) {
 			struct iova *this = container_of(*entry,
 							struct iova, node);
 			parent = *entry;
@@ -161,6 +166,12 @@ move_left:
 				entry = &((*entry)->rb_right);
--
 	while (*new) {
 		struct iova *this = container_of(*new, struct iova, node);
 		parent = *new;
@@ -190,6 +206,12 @@ iova_insert_rbtree(struct rb_root *root,
 			new = &((*new)->rb_right);
 		else
--
 	while (node) {
 		struct iova *iova = container_of(node, struct iova, node);
 
@@ -270,6 +297,12 @@ struct iova *find_iova(struct iova_domai
 			node = node->rb_left;
 		else if (pfn > iova->pfn_lo)
--
 	while (node) {
 		struct iova *iova = container_of(node, struct iova, node);
 		rb_erase(node, &iovad->rbroot);
 		free_iova_mem(iova);
 		node = rb_first(&iovad->rbroot);
+		if (_cur < timeout) {
--
 	while (*str) {
 		if (!strncmp(str, "on", 2)) {
 			dmar_disabled = 0;
@@ -454,6 +459,12 @@ static int __init intel_iommu_setup(char
 		str += strcspn(str, ",");
 		while (*str == ',')
 			str++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
--
-	while (parent != tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (parent != tmp) {
 		ret = domain_context_mapping_one(domain,
 						 pci_domain_nr(parent->bus),
 						 parent->bus->number,
@@ -1671,6 +1687,12 @@ domain_context_mapping(struct dmar_domai
 		if (ret)
--
-	while (parent != tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (parent != tmp) {
 		ret = device_context_mapped(iommu, parent->bus->number,
 					    parent->devfn);
 		if (!ret)
 			return ret;
 		parent = parent->bus->self;
--
 	while (nr_pages > 0) {
 		uint64_t tmp;
 
@@ -1859,6 +1897,12 @@ static int __domain_mapping(struct dmar_
 
 		if (!sg_res && nr_pages)
--
-	while (!list_empty(&domain->devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&domain->devices)) {
 		info = list_entry(domain->devices.next,
 			struct device_domain_info, link);
 		list_del(&info->link);
@@ -1910,6 +1959,12 @@ static void domain_remove_dev_info(struc
 		free_devinfo_mem(info);
--
-		while (parent != tmp) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (parent != tmp) {
 			iommu_detach_dev(iommu, parent->bus->number,
 					 parent->devfn);
 			parent = parent->bus->self;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&domain->devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&domain->devices)) {
 		info = list_entry(domain->devices.next,
 			struct device_domain_info, link);
 		list_del(&info->link);
@@ -3828,6 +3899,12 @@ static void vm_domain_remove_all_dev_inf
 
--
 	while (iommu->agaw < dmar_domain->agaw) {
 		struct dma_pte *pte;
 
@@ -4011,6 +4093,12 @@ static int intel_iommu_attach_device(str
 			free_pgtable_page(pte);
 		}
--
 	while (start < end) {
 		scope = start;
 		if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_ENDPOINT ||
@@ -137,6 +142,12 @@ int __init dmar_parse_dev_scope(void *st
 			       "Unsupported device scope\n");
 		}
--
 	while (start < end) {
 		scope = start;
 		if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_ENDPOINT ||
@@ -160,6 +176,12 @@ int __init dmar_parse_dev_scope(void *st
 			index ++;
 		}
--
 	while (dev) {
 		for (index = 0; index < cnt; index++)
 			if (dev == devices[index])
@@ -394,6 +421,12 @@ static int dmar_pci_device_match(struct
 
 		/* Check our parent */
--
-	while (((unsigned long)entry_header) <
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (((unsigned long)entry_header) <
 			(((unsigned long)dmar) + dmar_tbl->length)) {
 		/* Avoid looping forever on bad ACPI tables */
 		if (entry_header->length == 0) {
@@ -536,6 +574,12 @@ int __init check_zero_address(void)
 		}
--
 	while (qi->desc_status[qi->free_tail] == QI_DONE ||
 	       qi->desc_status[qi->free_tail] == QI_ABORT) {
 		qi->desc_status[qi->free_tail] = QI_FREE;
 		qi->free_tail = (qi->free_tail + 1) % QI_LENGTH;
 		qi->free_cnt++;
+		if (_cur < timeout) {
--
 	while (qi->free_cnt < 3) {
 		raw_spin_unlock_irqrestore(&qi->q_lock, flags);
 		cpu_relax();
 		raw_spin_lock_irqsave(&qi->q_lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while (p < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (p < end) {
 		dev = (struct ivhd_entry *)p;
 		switch (dev->type) {
 		case IVHD_DEV_SELECT:
@@ -428,6 +433,12 @@ static int __init find_last_devid_from_i
 			break;
--
-	while (p < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (p < end) {
 		h = (struct ivhd_header *)p;
 		switch (h->type) {
 		case ACPI_IVHD_TYPE:
@@ -471,6 +487,12 @@ static int __init find_last_devid_acpi(s
 			break;
--
 	while (p < end) {
 		e = (struct ivhd_entry *)p;
 		switch (e->type) {
@@ -883,6 +910,12 @@ static void __init init_iommu_from_acpi(
 		}
 
--
 	while (p < end) {
 		h = (struct ivhd_header *)p;
 		switch (*p) {
@@ -1051,6 +1089,12 @@ static int __init init_iommu_all(struct
 		}
 		p += h->length;
--
 	while (p < end) {
 		m = (struct ivmd_header *)p;
 		if (m->flags & IVMD_FLAG_EXCL_RANGE)
@@ -1215,6 +1264,12 @@ static int __init init_memory_definition
 			init_unity_map_range(m);
 
--
 	while (bytes) {
 		ent_sz = max_alignment(da | pa);
 		ent_sz = min_t(unsigned, ent_sz, iopgsz_max(bytes));
@@ -99,6 +104,12 @@ static unsigned sgtable_nents(size_t byt
 		da += ent_sz;
 		pa += ent_sz;
--
 	while (*str) {
 		if (!strncmp(str, "on", 2))
 			disable_intremap = 0;
@@ -48,6 +53,12 @@ static __init int setup_intremap(char *s
 		str += strcspn(str, ",");
 		while (*str == ',')
 			str++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
-	while (--count > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (--count > 0) {
 		/*
 		 * Access PCI directly due to the PCI
 		 * subsystem isn't initialized yet.
@@ -664,6 +680,12 @@ static void ir_parse_one_hpet_scope(stru
 		bus = read_pci_config_byte(bus, path->dev, path->fn,
--
-	while (--count > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (--count > 0) {
 		/*
 		 * Access PCI directly due to the PCI
 		 * subsystem isn't initialized yet.
@@ -692,6 +719,12 @@ static void ir_parse_one_ioapic_scope(st
 		bus = read_pci_config_byte(bus, path->dev, path->fn,
--
 	while (start < end) {
 		scope = start;
 		if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_IOAPIC) {
@@ -739,6 +777,12 @@ static int ir_parse_ioapic_hpet_scope(st
 			ir_parse_one_hpet_scope(scope, iommu);
 		}
--
 	while (!IsStatusReady(j)) {
 		ixj_perfmon(j->statuswait);
 		if (time_after(jiffies, jif)) {
 			ixj_perfmon(j->statuswaitfail);
 			return -1;
 		}
--
 	while (!IsPCControlReady(j)) {
 		ixj_perfmon(j->pcontrolwait);
 		if (time_after(jiffies, jif)) {
 			ixj_perfmon(j->pcontrolwaitfail);
 			return -1;
 		}
--
 	while (!IsControlReady(j)) {
 		ixj_perfmon(j->iscontrolready);
 		if (time_after(jiffies, jif)) {
@@ -1458,12 +1485,29 @@ static int ixj_WriteDSPCommand(unsigned
 			atomic_dec(&j->DSPWrite);
 			if(atomic_read(&j->DSPWrite) > 0) {
--
 				while(atomic_read(&j->DSPWrite) > 0) {
 					atomic_dec(&j->DSPWrite);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
--
 			while(atomic_read(&j->DSPWrite) > 0) {
 				atomic_dec(&j->DSPWrite);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 		while(atomic_read(&j->DSPWrite) > 0) {
 			atomic_dec(&j->DSPWrite);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (len--)
 	{
 		*buff = table_ulaw2alaw[*(unsigned char *)buff];
 		buff++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
         while (len--)
         {
                 *buff = table_alaw2ulaw[*(unsigned char *)buff];
                 buff++;
+                if (_cur < timeout) {
+                	rdstcll(_cur);
--
 	while (!j->read_buffer_ready || (j->dtmf_state && j->flags.dtmf_oob)) {
 		++j->read_wait;
 		if (file_p->f_flags & O_NONBLOCK) {
@@ -2779,6 +2872,12 @@ static ssize_t ixj_read(struct file * fi
 			j->flags.inread = 0;
 			return -EINTR;
--
 	while (!j->write_buffers_empty) {
 		++j->write_wait;
 		if (file_p->f_flags & O_NONBLOCK) {
@@ -2860,6 +2964,12 @@ static ssize_t ixj_write(struct file *fi
 			j->flags.inwrite = 0;
 			return -EINTR;
--
 	while (j->fskcnt < 20) {
 		if(j->fskdcnt < (j->fsksize - 1))
 			j->fskdata[j->fskdcnt++] = fsk[bit][j->fskz][j->fskcnt];
 
 		j->fskcnt += 3;
+		if (_cur < timeout) {
--
 	while (mContinue) {
 		if ((pIn[1] & 0x03) == 0x01) {
 			pOut[0] = pIn[0];
@@ -5034,6 +5160,12 @@ static int ixj_daa_cid_read(IXJ *j)
 			mContinue = false;
 		}
--
 	while (ids->id) {
 		if (ids->id == dev->id.id)
 			return ids;
 
 		ids++;
+		if (_cur < timeout) {
--
 	while (mr && enum_id && *reg_idx < desc->hw.nr_mask_regs) {
 		mr = desc->hw.mask_regs + *reg_idx;
 
@@ -80,6 +85,12 @@ static unsigned int __init _intc_mask_da
 
 		*fld_idx = 0;
--
 	while (pr && enum_id && *reg_idx < desc->hw.nr_prio_regs) {
 		pr = desc->hw.prio_regs + *reg_idx;
 
@@ -149,6 +165,12 @@ static unsigned int __init _intc_prio_da
 
 		*fld_idx = 0;
--
 	while (!found) {
 		found = 1;
 
@@ -103,6 +108,12 @@ nv04_calc_arb(struct nv_fifo_info *fifo,
 
 		fifo->lwm = clwm;
--
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -1071,6 +1076,12 @@ nv04_graph_isr(struct drm_device *dev)
 				     "mthd 0x%04x data 0x%08x\n",
 				chid, subc, class, mthd, data);
--
 	while (!list_empty(&mem->regions)) {
 		this = list_first_entry(&mem->regions, struct nouveau_mm_node, rl_entry);
 
 		list_del(&this->rl_entry);
 		nouveau_mm_put(mm, this);
+		if (_cur < timeout) {
--
 		while (num) {
 			struct nouveau_gpuobj *pgt = vm->pgt[pde].obj[big];
 
@@ -64,6 +69,12 @@ nouveau_vm_map_at(struct nouveau_vma *vm
 			}
 
--
 	while (num) {
 		struct nouveau_gpuobj *pgt = vm->pgt[pde].obj[big];
 
@@ -107,6 +123,12 @@ nouveau_vm_map_sg(struct nouveau_vma *vm
 			pde++;
 			pte = 0;
--
 	while (num) {
 		struct nouveau_gpuobj *pgt = vm->pgt[pde].obj[big];
 
@@ -141,6 +168,12 @@ nouveau_vm_unmap_at(struct nouveau_vma *
 			pde++;
 			pte = 0;
--
 	while (chan->dma.ib_free < count) {
 		uint32_t get = nvchan_rd32(chan, 0x88);
 		if (get != prev_get) {
@@ -210,6 +215,12 @@ nv50_dma_push_wait(struct nouveau_channe
 		chan->dma.ib_free = get - chan->dma.ib_put;
 		if (chan->dma.ib_free <= 0)
--
 	while (parts) {
 		u32 psize = nv_rd32(dev, 0x11020c + (part++ * 0x1000));
 		if (psize == 0)
@@ -131,6 +136,12 @@ nvc0_vram_init(struct drm_device *dev)
 
 		NV_DEBUG(dev, "%d: mem_amount 0x%08x\n", part, psize);
--
 	while (mode->hdisplay) {
 		if (mode->hdisplay <= native->hdisplay &&
 		    mode->vdisplay <= native->vdisplay) {
@@ -597,6 +602,12 @@ nouveau_connector_scaler_modes_add(struc
 		}
 
--
 	while (dwords) {
 		int push = dwords > 2047 ? 2047 : dwords;
 
@@ -146,6 +151,12 @@ nvc0_fbcon_imageblit(struct fb_info *inf
 		BEGIN_NVC0(chan, 6, NvSub2D, 0x0860, push);
 		OUT_RINGp(chan, data, push);
--
 	while ((status = nv_rd32(dev, NV03_PFIFO_INTR_0)) && (cnt++ < 100)) {
 		uint32_t chid, get;
 
@@ -531,6 +536,12 @@ nv04_fifo_isr(struct drm_device *dev)
 		}
 
--
 			while (lvsw != conf[0] || lpre != conf[1]) {
 				conf += dp->table[5];
 				if (conf >= last)
 					return -EINVAL;
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (mcnt--) {
 		u8 remaining = msg->len;
 		u8 *ptr = msg->buf;
 
-		while (remaining) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (remaining) {
 			u8 cnt = (remaining > 16) ? 16 : remaining;
 			u8 cmd;
 
@@ -716,9 +737,21 @@ nouveau_dp_i2c_xfer(struct i2c_adapter *
 
--
 	while (dwords) {
 		int push = dwords > 2047 ? 2047 : dwords;
 
@@ -146,6 +151,12 @@ nv50_fbcon_imageblit(struct fb_info *inf
 		BEGIN_RING(chan, NvSub2D, 0x40000860, push);
 		OUT_RINGp(chan, data, push);
--
-	while (nv_rd32(dev, 0x400700) & 2) {}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (nv_rd32(dev, 0x400700) & 2) {if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
--
 		while (!(ntpcv & (1 << 4))) {
 			ntpcv <<= 1;
 			shift++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((stat = nv_rd32(dev, 0x400100))) {
 		u64 inst = (u64)(nv_rd32(dev, 0x40032c) & 0x0fffffff) << 12;
 		u32 chid = nv50_graph_isr_chid(dev, inst);
@@ -974,6 +979,12 @@ nv50_graph_isr(struct drm_device *dev)
 				chid, inst, subc, class, mthd, data);
 			nv50_fb_vm_trap(dev, 1);
--
-	while (put != get) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (put != get) {
 		nv_wo32(cache, ptr + 0,
 			nv_rd32(dev, NV40_PFIFO_CACHE1_METHOD(get)));
 		nv_wo32(cache, ptr + 4,
 			nv_rd32(dev, NV40_PFIFO_CACHE1_DATA(get)));
 		get = (get + 1) & 0x1ff;
--
 	while (dsize) {
 		int iter_len = dsize > 128 ? 128 : dsize;
 
@@ -131,6 +136,12 @@ nv04_fbcon_imageblit(struct fb_info *inf
 		OUT_RINGp(chan, data, iter_len);
 		data += iter_len;
--
 	while (--testscore > 0) {
 		for (i = 0; i < NUM_SHADOW_METHODS; i++) {
 			if (scores[i] == testscore) {
@@ -253,6 +258,12 @@ static bool NVShadowVBIOS(struct drm_dev
 				return true;
 			}
--
-	while ((table = ROM16(bios->data[bios->init_script_tbls_ptr + i]))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((table = ROM16(bios->data[bios->init_script_tbls_ptr + i]))) {
 		NV_INFO(bios->dev,
 			"Parsing VBIOS init table %d at offset 0x%04X\n",
 			i / 2, table);
@@ -3855,6 +3871,12 @@ parse_init_tables(struct nvbios *bios)
 
--
 	while (map->reg) {
 		if (map->type == type)
 			return map->reg;
 		map++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (entries--) {
 		if (entry[0] == id) {
 			bit->id = entry[0];
@@ -5498,6 +5536,12 @@ bit_table(struct drm_device *dev, u8 id,
 		}
 
--
 	while (page_count) {
 		int line_count = (page_count > 2047) ? 2047 : page_count;
 
@@ -508,6 +513,12 @@ nvc0_bo_move_m2mf(struct nouveau_channel
 		page_count -= line_count;
 		src_offset += (PAGE_SIZE * line_count);
--
 	while (length) {
 		u32 amount, stride, height;
 
@@ -598,6 +614,12 @@ nv50_bo_move_m2mf(struct nouveau_channel
 		length -= amount;
 		src_offset += amount;
--
-	while (page_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (page_count) {
 		int line_count = (page_count > 2047) ? 2047 : page_count;
 
 		ret = RING_SPACE(chan, 11);
@@ -653,6 +680,12 @@ nv04_bo_move_m2mf(struct nouveau_channel
 		page_count -= line_count;
--
 		while ((entry = nouveau_ramht_remove_entry(chan, 0))) {
 			nouveau_ramht_remove_hash(chan, entry->handle);
 			nouveau_gpuobj_ref(NULL, &entry->gpuobj);
 			kfree(entry);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -426,6 +431,12 @@ nv40_graph_isr(struct drm_device *dev)
 				     "class 0x%04x mthd 0x%04x data 0x%08x\n",
 				chid, inst, subc, class, mthd, data);
--
 	while (bf->name) {
 		if (value & bf->mask) {
 			printk(" %s", bf->name);
@@ -41,6 +46,12 @@ nouveau_bitfield_print(const struct nouv
 		}
 
--
 	while (en->name) {
 		if (en->value == value)
 			return en;
 		en++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {
 		vga_count++;
 
@@ -266,6 +271,12 @@ static bool nouveau_dsm_detect(void)
 			has_dsm |= 1;
 		if (retval & NOUVEAU_DSM_HAS_OPT)
--
 		while (n < (d * 2)) {
 			n += (n / m);
 			m++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (((n % 5) == 0) && ((d % 5) == 0)) {
 		n /= 5;
 		d /= 5;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((n % 2) == 0) && ((d % 2) == 0)) {
 		n /= 2;
 		d /= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (n > 0xffff || d > 0xffff) {
 		n >>= 1;
 		d >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cnt--) {
 		nv_wo32(pgt, pte + 0, lower_32_bits(phys));
 		nv_wo32(pgt, pte + 4, upper_32_bits(phys));
 		phys += next;
 		pte  += 8;
+		if (_cur < timeout) {
--
 	while (cnt--) {
 		u64 phys = nvc0_vm_addr(vma, *list++, mem->memtype, 5);
 		nv_wo32(pgt, pte + 0, lower_32_bits(phys));
 		nv_wo32(pgt, pte + 4, upper_32_bits(phys));
 		pte += 8;
+		if (_cur < timeout) {
--
 	while (cnt--) {
 		nv_wo32(pgt, pte + 0, 0x00000000);
 		nv_wo32(pgt, pte + 4, 0x00000000);
 		pte += 8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (vidmask) {
 		if (i > nr_vidtag) {
 			NV_DEBUG(dev, "vid bit %d unknown\n", i);
@@ -201,6 +206,12 @@ nouveau_volt_init(struct drm_device *dev
 
 		vidmask >>= 1;
--
 	while (units) {
 		u32 subp, unit = ffs(units) - 1;
 		for (subp = 0; subp < 2; subp++)
 			nvc0_mfb_subp_isr(dev, unit, subp);
 		units &= ~(1 << unit);
+		if (_cur < timeout) {
--
 	while (cnt) {
 		u32 offset_h = upper_32_bits(phys);
 		u32 offset_l = lower_32_bits(phys);
@@ -112,11 +117,28 @@ nv50_vm_map(struct nouveau_vma *vma, str
 			delta    += block << (vma->node->type - 3);
 		}
--
 		while (block) {
 			nv_wo32(pgt, pte + 0, offset_l);
 			nv_wo32(pgt, pte + 4, offset_h);
 			pte += 8;
 			block -= 8;
+			if (_cur < timeout) {
--
 	while (cnt--) {
 		u64 phys = nv50_vm_addr(vma, (u64)*list++, mem->memtype, 2);
 		nv_wo32(pgt, pte + 0, lower_32_bits(phys));
 		nv_wo32(pgt, pte + 4, upper_32_bits(phys));
 		pte += 8;
+		if (_cur < timeout) {
--
 	while (cnt--) {
 		nv_wo32(pgt, pte + 0, 0x00000000);
 		nv_wo32(pgt, pte + 4, 0x00000000);
 		pte += 8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -704,6 +709,12 @@ nv20_graph_isr(struct drm_device *dev)
 				     "mthd 0x%04x data 0x%08x\n",
 				chid, subc, class, mthd, data);
--
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -1120,6 +1125,12 @@ nv10_graph_isr(struct drm_device *dev)
 				     "mthd 0x%04x data 0x%08x\n",
 				chid, subc, class, mthd, data);
--
 		while (u) {
 			int i = ffs(u) - 1;
 			nvc0_fifo_isr_vm_fault(dev, i);
 			u &= ~(1 << i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (u) {
 			int i = ffs(u) - 1;
 			nvc0_fifo_isr_subfifo_intr(dev, i);
 			u &= ~(1 << i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (nvbe->nr_pages--) {
 			pci_unmap_page(dev->pdev, nvbe->pages[nvbe->nr_pages],
 				       PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (cnt--) {
 		nv_wo32(pgt, pte, (*list++ >> 7) | 1);
 		pte += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cnt--) {
 		nv_wo32(pgt, pte, 0x00000000);
 		pte += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cnt--) {
 		u32 addr = list ? (*list++ >> 12) : (dummy >> 12);
 		switch (pte++ & 0x3) {
@@ -262,6 +300,12 @@ nv44_sgdma_fill(struct nouveau_gpuobj *p
 			tmp[3] |= addr >> 15;
 			break;
--
 	while (cnt >= 4) {
 		for (i = 0; i < 4; i++)
 			tmp[i] = *list++ >> 12;
@@ -303,6 +352,12 @@ nv44_sgdma_bind(struct ttm_backend *be,
 		nv_wo32(pgt, pte + 0xc, tmp[3] >> 15 | 0x40000000);
 		pte  += 0x10;
--
 	while (cnt >= 4) {
 		nv_wo32(pgt, pte + 0x0, 0x00000000);
 		nv_wo32(pgt, pte + 0x4, 0x00000000);
@@ -337,6 +397,12 @@ nv44_sgdma_unbind(struct ttm_backend *be
 		nv_wo32(pgt, pte + 0xc, 0x00000000);
 		pte  += 0x10;
--
 	while (entry->buf_count < count) {
 		buf = &entry->buflist[entry->buf_count];
 		buf->idx = dma->buf_count + entry->buf_count;
@@ -723,6 +728,12 @@ int drm_addbufs_agp(struct drm_device *
 		offset += alignment;
 		entry->buf_count++;
--
 	while (entry->buf_count < count) {
 
 		dmah = drm_pci_alloc(dev, PAGE_SIZE << page_order, 0x1000);
@@ -925,6 +941,12 @@ int drm_addbufs_pci(struct drm_device *
 				  entry->buf_count, buf->address);
 		}
--
 	while (entry->buf_count < count) {
 		buf = &entry->buflist[entry->buf_count];
 		buf->idx = dma->buf_count + entry->buf_count;
@@ -1090,6 +1117,12 @@ static int drm_addbufs_sg(struct drm_dev
 		offset += alignment;
 		entry->buf_count++;
--
 	while (entry->buf_count < count) {
 		buf = &entry->buflist[entry->buf_count];
 		buf->idx = dma->buf_count + entry->buf_count;
@@ -1247,6 +1285,12 @@ static int drm_addbufs_fb(struct drm_dev
 		offset += alignment;
 		entry->buf_count++;
--
 	while (num_desc--) {
 		if (descriptor_this_page-- == 0) {
 			cur_descriptor_page--;
@@ -81,6 +86,12 @@ via_unmap_blit_from_device(struct pci_de
 		dma_unmap_page(&pdev->dev, desc_ptr->mem_addr, desc_ptr->size, vsg->direction);
 		next = (dma_addr_t) desc_ptr->next;
--
 		while (line_len > 0) {
 
 			remaining_len = min(PAGE_SIZE-VIA_PGOFF(cur_mem), line_len);
@@ -148,6 +164,12 @@ via_map_blit_for_device(struct pci_dev *
 			num_desc++;
 			cur_mem += remaining_len;
--
 	while (blitq->serviced != blitq->cur) {
 
 		cur_released = blitq->serviced++;
@@ -527,6 +554,12 @@ via_dmablit_workqueue(struct work_struct
 		kfree(cur_sg);
 
--
 	while (blitq->num_free == 0) {
 		spin_unlock_irqrestore(&blitq->blit_lock, irqsave);
 
@@ -693,6 +731,12 @@ via_dmablit_grab_slot(drm_via_blitq_t *b
 			return (-EINTR == ret) ? -EAGAIN : ret;
 
--
 	while (rptr != wptr) {
 		/* wptr/rptr are in bytes! */
 		ring_index = rptr / 4;
@@ -3033,6 +3038,12 @@ restart_ih:
 		/* wptr/rptr are in bytes! */
 		rptr += 16;
--
 	/* make sure wptr hasn't changed while processing */
 	wptr = evergreen_get_ih_wptr(rdev);
diff -u -p a/gpu/drm/radeon/rs600.c b/gpu/drm/radeon/rs600.c
--- a/gpu/drm/radeon/rs600.c
+++ b/gpu/drm/radeon/rs600.c
@@ -639,6 +639,11 @@ int rs600_irq_process(struct radeon_devi
--
 	while (status || rdev->irq.stat_regs.r500.disp_int) {
 		/* SW interrupt */
 		if (G_000044_SW_INT(status)) {
@@ -678,6 +683,12 @@ int rs600_irq_process(struct radeon_devi
 			DRM_DEBUG("HPD2\n");
 		}
--
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
 		mode_option = this_opt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (status) {
 		/* SW interrupt */
 		if (status & RADEON_SW_INT_TEST) {
@@ -775,6 +780,12 @@ int r100_irq_process(struct radeon_devic
 			DRM_DEBUG("HPD2\n");
 		}
--
 	while (num_gpu_pages > 0) {
 		cur_pages = num_gpu_pages;
 		if (cur_pages > 8191) {
@@ -888,6 +904,12 @@ int r100_copy_blit(struct radeon_device
 		radeon_ring_write(rdev, num_gpu_pages);
 		radeon_ring_write(rdev, num_gpu_pages);
--
 				while (blocks > 0) {
 					id = RBIOS16(index);
 					index += 2;
@@ -2941,6 +2946,12 @@ bool radeon_combios_external_tmds_setup(
 						break;
 					}
--
 			while (id != 0xffff) {
 				index += 2;
 				switch (id >> 13) {
@@ -2996,6 +3012,12 @@ bool radeon_combios_external_tmds_setup(
 					break;
 				}
--
 		while (RBIOS16(offset)) {
 			uint16_t cmd = ((RBIOS16(offset) & 0xe000) >> 13);
 			uint32_t addr = (RBIOS16(offset) & 0x1fff);
@@ -3078,6 +3105,12 @@ static void combios_parse_mmio_table(str
 			default:
 				break;
--
 		while (RBIOS8(offset)) {
 			uint8_t cmd = ((RBIOS8(offset) & 0xc0) >> 6);
 			uint8_t addr = (RBIOS8(offset) & 0x3f);
@@ -3168,6 +3206,12 @@ static void combios_parse_pll_table(stru
 			default:
 				break;
--
 		while (val != 0xff) {
 			offset++;
 
@@ -3215,6 +3264,12 @@ static void combios_parse_ram_reset_tabl
 				WREG32(RADEON_MEM_SDRAM_MODE_REG, tmp);
 			}
--
 	while (ram--) {
 		addr = ram * 1024 * 1024;
 		/* write to each page */
@@ -3248,6 +3308,12 @@ static uint32_t combios_detect_ram(struc
 		WREG32(RADEON_MM_INDEX, (addr) | RADEON_MM_APER);
 		if (RREG32(RADEON_MM_DATA) != 0xdeadbeef)
--
 		while (p->file_priv == NULL && p->next->file_priv == NULL) {
 			struct mem_block *q = p->next;
 			p->size += q->size;
 			p->next = q->next;
 			p->next->prev = p;
 			kfree(q);
--
 		while (dwords & 0xf) {
 			u32 *data = (u32 *)
 			    ((char *)dev->agp_buffer_map->handle
 			     + buf->offset + start);
 			data[dwords++] = RADEON_CP_PACKET2;
+			if (_cur < timeout) {
--
 	while (dwords & 0xf) {
 		packet2s[num_packet2s++] = cpu_to_le32(PACKET2(0));
 		dwords++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-			while (remaining) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (remaining) {
 				if (remaining > 15)
 					current_count = 15;
 				else
@@ -735,9 +740,20 @@ static int r500_hw_i2c_xfer(struct i2c_a
 					p->buf[buffer_offset + j] = RREG32(AVIVO_DC_I2C_DATA) & 0xff;
--
-			while (remaining) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (remaining) {
 				if (remaining > 15)
 					current_count = 15;
 				else
@@ -776,6 +792,12 @@ static int r500_hw_i2c_xfer(struct i2c_a
 				}
--
-				while ((ret = r600_do_cp_idle(dev_priv)) != 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((ret = r600_do_cp_idle(dev_priv)) != 0) {
 					DRM_DEBUG("radeon_do_cp_idle %d\n", ret);
 #ifdef __linux__
 					schedule();
 #else
 					tsleep(&ret, PZERO, "rdnrel", 1);
--
-				while ((ret = radeon_do_cp_idle(dev_priv)) != 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((ret = radeon_do_cp_idle(dev_priv)) != 0) {
 					DRM_DEBUG("radeon_do_cp_idle %d\n", ret);
 #ifdef __linux__
 					schedule();
 #else
 					tsleep(&ret, PZERO, "rdnrel", 1);
--
 	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {
 		vga_count++;
 
 		has_atpx |= (radeon_atpx_pci_probe_handle(pdev) == true);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (drm_buffer_unprocessed(cmdbuf->buffer)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (drm_buffer_unprocessed(cmdbuf->buffer)
 			>= sizeof(drm_r300_cmd_header_t)) {
 		int idx;
 		drm_r300_cmd_header_t *header, stack_header;
@@ -1157,6 +1162,12 @@ int r300_do_cp_cmdbuf(struct drm_device
 			ret = -EINVAL;
--
-		while (ref_div <= pll->max_ref_div) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (ref_div <= pll->max_ref_div) {
 			avivo_get_fb_div(pll, target_clock, post_div, ref_div,
 					 &fb_div, &frac_fb_div);
 			if (frac_fb_div >= (pll->reference_freq / 2))
@@ -850,6 +855,12 @@ void radeon_compute_pll_avivo(struct rad
 				break;
--
 		while (min_ref_div < max_ref_div-1) {
 			uint32_t mid = (min_ref_div + max_ref_div) / 2;
 			uint32_t pll_in = pll->reference_freq / mid;
@@ -925,6 +941,12 @@ void radeon_compute_pll_legacy(struct ra
 				min_ref_div = mid;
 			else
--
 			while (min_feed_div < max_feed_div) {
 				uint32_t vco;
 				uint32_t min_frac_feed_div = min_fractional_feed_div;
@@ -984,6 +1011,11 @@ void radeon_compute_pll_legacy(struct ra
 					continue;
 				}
--
 				while (min_frac_feed_div < max_frac_feed_div) {
 					frac_feedback_div = (min_frac_feed_div + max_frac_feed_div) / 2;
 					tmp = (uint64_t)pll->reference_freq * 10000 * feedback_div;
@@ -1038,11 +1070,23 @@ void radeon_compute_pll_legacy(struct ra
 						min_frac_feed_div = frac_feedback_div + 1;
 					else
--
 	while (CU8(base) == ATOM_IIO_START) {
 		ctx->iio[CU8(base + 1)] = base + 2;
 		base += 2;
 		while (CU8(base) != ATOM_IIO_END)
 			base += atom_iio_len[CU8(base)];
 		base += 3;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (rptr != wptr) {
 		/* wptr/rptr are in bytes! */
 		ring_index = rptr / 4;
@@ -3484,6 +3489,12 @@ restart_ih:
 		/* wptr/rptr are in bytes! */
 		rptr += 16;
--
 	/* make sure wptr hasn't changed while processing */
 	wptr = r600_get_ih_wptr(rdev);
diff -u -p a/gpu/drm/radeon/r600_blit_kms.c b/gpu/drm/radeon/r600_blit_kms.c
--- a/gpu/drm/radeon/r600_blit_kms.c
+++ b/gpu/drm/radeon/r600_blit_kms.c
@@ -527,9 +527,20 @@ int r600_blit_init(struct radeon_device
--
 	while (dwords & 0xf) {
 		packet2s[num_packet2s++] = cpu_to_le32(PACKET2(0));
 		dwords++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (num_gpu_pages) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_gpu_pages) {
 		num_gpu_pages -=
 			r600_blit_create_rect(num_gpu_pages, NULL, NULL,
 					      rdev->r600_blit.max_dim);
 		num_loops++;
+		if (_cur < timeout) {
--
-	while (num_gpu_pages) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (num_gpu_pages) {
 		int w, h;
 		unsigned size_in_bytes;
 		unsigned pages_per_loop =
@@ -779,5 +806,11 @@ void r600_kms_blit_copy(struct radeon_de
 		src_gpu_addr += size_in_bytes;
--
 		while (size_bytes) {
 			int cur_size = size_bytes;
 			int src_x = src_gpu_addr & 255;
@@ -682,10 +687,21 @@ r600_blit_copy(struct drm_device *dev,
 			src_gpu_addr += cur_size * h;
 			dst_gpu_addr += cur_size * h;
--
 		while (size_bytes) {
 			int cur_size = size_bytes;
 			int src_x = (src_gpu_addr & 255);
@@ -772,6 +788,12 @@ r600_blit_copy(struct drm_device *dev,
 			src_gpu_addr += cur_size * h;
 			dst_gpu_addr += cur_size * h;
--
 	while (p && p->chip_device != 0) {
 		if (info.id_vendor == p->hostbridge_vendor &&
 		    info.id_device == p->hostbridge_device &&
@@ -191,6 +196,12 @@ int radeon_agp_init(struct radeon_device
 			default_mode = p->default_mode;
 		}
--
 	while (mm->num_unused < MM_UNUSED_TARGET) {
 		spin_unlock(&mm->unused_lock);
 		node = kzalloc(sizeof(*node), GFP_KERNEL);
@@ -96,6 +101,12 @@ int drm_mm_pre_get(struct drm_mm *mm)
 		}
 		++mm->num_unused;
--
-		while ((pdev =
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((pdev =
 			pci_get_subsys(pid->vendor, pid->device, pid->subvendor,
 				       pid->subdevice, pdev)) != NULL) {
 			if ((pdev->class & pid->class_mask) != pid->class)
@@ -436,6 +441,12 @@ int drm_pci_init(struct drm_driver *driv
 			/* stealth mode requires a manual probe */
--
 	while (ring->space < n) {
 		ring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
 		ring->space = ring->head - (ring->tail + 8);
@@ -266,6 +271,12 @@ static int i810_wait_ring(struct drm_dev
 			goto out_wait_ring;
 		}
--
 		while (pad != 0) {
 			*dma_ptr++ = BCI_CMD_WAIT;
 			pad--;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 	while (*num > 0xffffff || *den > 0xffffff) {
 		*num >>= 1;
 		*den >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (p->file_priv == NULL && p->next->file_priv == NULL) {
 			struct mem_block *q = p->next;
 			p->size += q->size;
 			p->next = q->next;
 			p->next->prev = p;
 			kfree(q);
--
 	while (length > 0) {
 		int cacheline_end = ALIGN(gpu_offset + 1, 64);
 		int this_length = min(cacheline_end - gpu_offset, length);
@@ -319,6 +324,12 @@ slow_shmem_bit17_copy(struct page *gpu_p
 		cpu_offset += this_length;
 		gpu_offset += this_length;
--
 	while (remain > 0) {
 		struct page *page;
 		char *vaddr;
@@ -380,6 +396,12 @@ i915_gem_shmem_pread_fast(struct drm_dev
 		remain -= page_length;
 		user_data += page_length;
--
 	while (remain > 0) {
 		struct page *page;
 
@@ -492,7 +519,13 @@ i915_gem_shmem_pread_slow(struct drm_dev
 		remain -= page_length;
 		data_ptr += page_length;
--
 	while (remain > 0) {
 		/* Operation in this page
 		 *
@@ -658,6 +696,12 @@ i915_gem_gtt_pwrite_fast(struct drm_devi
 		remain -= page_length;
 		user_data += page_length;
--
 	while (remain > 0) {
 		/* Operation in this page
 		 *
@@ -751,7 +800,13 @@ i915_gem_gtt_pwrite_slow(struct drm_devi
 		remain -= page_length;
 		offset += page_length;
--
 	while (remain > 0) {
 		struct page *page;
 		char *vaddr;
@@ -822,6 +882,12 @@ i915_gem_shmem_pwrite_fast(struct drm_de
 		remain -= page_length;
 		user_data += page_length;
--
 	while (remain > 0) {
 		struct page *page;
 
@@ -935,7 +1006,13 @@ i915_gem_shmem_pwrite_slow(struct drm_de
 		remain -= page_length;
 		data_ptr += page_length;
--
-	while (!list_empty(&ring->request_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ring->request_list)) {
 		struct drm_i915_gem_request *request;
 
 		request = list_first_entry(&ring->request_list,
@@ -1759,9 +1841,20 @@ static void i915_gem_reset_ring_lists(st
 		list_del(&request->list);
--
-	while (!list_empty(&ring->active_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ring->active_list)) {
 		struct drm_i915_gem_object *obj;
 
 		obj = list_first_entry(&ring->active_list,
@@ -1771,6 +1864,12 @@ static void i915_gem_reset_ring_lists(st
 		obj->base.write_domain = 0;
--
-	while (!list_empty(&dev_priv->mm.flushing_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev_priv->mm.flushing_list)) {
 		obj = list_first_entry(&dev_priv->mm.flushing_list,
 				      struct drm_i915_gem_object,
 				      mm_list);
@@ -1818,6 +1922,12 @@ void i915_gem_reset(struct drm_device *d
 		obj->base.write_domain = 0;
--
-	while (!list_empty(&file_priv->mm.request_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&file_priv->mm.request_list)) {
 		struct drm_i915_gem_request *request;
 
 		request = list_first_entry(&file_priv->mm.request_list,
@@ -4181,6 +4296,12 @@ void i915_gem_release(struct drm_device
 					   client_list);
--
 		while (fifo <= GT_FIFO_NUM_RESERVED_ENTRIES && loop--) {
 			udelay(10);
 			fifo = I915_READ_NOTRACE(GT_FIFO_FREE_ENTRIES);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (count--) {
 		seq_printf(m, "  %08x %8u %04x %04x %08x%s%s%s%s%s%s",
 			   err->gtt_offset,
@@ -734,6 +739,12 @@ static void print_error_buffers(struct s
 
 		seq_printf(m, "\n");
--
 	while (index < total) {
 		current_id = *(base + index);
 		index++;
@@ -58,6 +63,12 @@ find_section(struct bdb_header *bdb, int
 		if (current_id == section_id)
 			return base + index;
--
 			while (len) {
 				if (wait_for(I915_READ(GMBUS2 + reg_offset) & (GMBUS_SATOER | GMBUS_HW_RDY), 50))
 					goto timeout;
@@ -297,6 +302,12 @@ gmbus_xfer(struct i2c_adapter *adapter,
 
 				I915_WRITE(GMBUS3 + reg_offset, val);
--
 	while (--i) {
 		struct intel_gmbus *bus = &dev_priv->gmbus[i];
 		i2c_del_adapter(&bus->adapter);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (!list_empty(&unwind_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&unwind_list)) {
 		obj = list_first_entry(&unwind_list,
 				       struct drm_i915_gem_object,
 				       exec_list);
@@ -140,6 +145,12 @@ i915_gem_evict_something(struct drm_devi
 
--
-	while (!list_empty(&unwind_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&unwind_list)) {
 		obj = list_first_entry(&unwind_list,
 				       struct drm_i915_gem_object,
 				       exec_list);
@@ -162,10 +178,21 @@ found:
 		}
--
-	while (!list_empty(&eviction_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&eviction_list)) {
 		obj = list_first_entry(&eviction_list,
 				       struct drm_i915_gem_object,
 				       exec_list);
@@ -174,6 +201,12 @@ found:
 
--
 	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {
 		vga_count++;
 		has_dsm |= intel_dsm_pci_probe(pdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (*num > 0xffffff || *den > 0xffffff) {
 		*num >>= 1;
 		*den >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (rem--) {
 		*virt++ = MI_NOOP;
 		*virt++ = MI_NOOP;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(objects)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(objects)) {
 		struct drm_i915_gem_exec_object2 *entry;
 		bool need_fence, need_mappable;
 
@@ -495,6 +500,12 @@ i915_gem_execbuffer_reserve(struct intel
 
--
 	while (objects != &obj->exec_list) {
 		if (obj->gtt_space)
 			i915_gem_object_unpin(obj);
@@ -611,6 +627,12 @@ err:
 		obj = list_entry(obj->exec_list.prev,
 				 struct drm_i915_gem_object,
--
-	while (!list_empty(objects)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(objects)) {
 		obj = list_first_entry(objects,
 				       struct drm_i915_gem_object,
 				       exec_list);
 		list_del_init(&obj->exec_list);
 		drm_gem_object_unreference(&obj->base);
--
-	while (!list_empty(&objects)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&objects)) {
 		struct drm_i915_gem_object *obj;
 
 		obj = list_first_entry(&objects,
@@ -1251,6 +1289,12 @@ err:
 				       exec_list);
--
-	while (status == SDVO_CMD_STATUS_PENDING && retry--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (status == SDVO_CMD_STATUS_PENDING && retry--) {
 		udelay(15);
 		if (!intel_sdvo_read_byte(intel_sdvo,
 					  SDVO_I2C_CMD_STATUS,
 					  &status))
 			goto log_fail;
--
 	while (ttm_zones_above_swap_target(glob, from_wq, extra)) {
 		shrink = glob->shrink;
 		spin_unlock(&glob->lock);
@@ -226,6 +231,12 @@ static void ttm_shrink(struct ttm_mem_gl
 		spin_lock(&glob->lock);
 		if (unlikely(ret != 0))
--
-	while (unlikely(ttm_mem_global_reserve(glob,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (unlikely(ttm_mem_global_reserve(glob,
 					       single_zone,
 					       memory, true)
 			!= 0)) {
@@ -525,6 +541,12 @@ static int ttm_mem_global_alloc_zone(str
 		if (unlikely(count-- == 0))
--
 	while (!list_empty(&tfile->ref_list)) {
 		list = tfile->ref_list.next;
 		ref = list_entry(list, struct ttm_ref_object, head);
 		ttm_ref_object_release(&ref->kref);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (unlikely(atomic_cmpxchg(&bo->reserved, 0, 1) != 0)) {
 		/**
 		 * Deadlock avoidance for multi-bo reserving.
@@ -246,6 +251,12 @@ int ttm_bo_reserve_locked(struct ttm_buf
 
 		if (unlikely(ret))
--
 	while (!list_empty(&man->lru)) {
 		spin_unlock(&glob->lru_lock);
 		ret = ttm_mem_evict_first(bdev, mem_type, false, false, false);
@@ -1333,6 +1349,12 @@ static int ttm_bo_force_list_clean(struc
 			}
 		}
--
 	while (i--) {
 		man = &bdev->man[i];
 		if (man->has_type) {
@@ -1515,6 +1542,12 @@ int ttm_bo_device_release(struct ttm_bo_
 			}
 			man->has_type = false;
--
 	while (*cur) {
 		parent = *cur;
 		cur_bo = rb_entry(parent, struct ttm_buffer_object, vm_rb);
@@ -1654,6 +1692,12 @@ static void ttm_bo_vm_insert_rb(struct t
 			cur = &parent->rb_right;
 		else
--
 	while (bo->sync_obj) {
 
 		if (driver->sync_obj_signaled(bo->sync_obj, bo->sync_obj_arg)) {
@@ -1761,6 +1810,12 @@ int ttm_bo_wait(struct ttm_buffer_object
 			driver->sync_obj_unref(&sync_obj);
 			spin_lock(&bdev->fence_lock);
--
-	while (ret == -EBUSY) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ret == -EBUSY) {
 		if (unlikely(list_empty(&glob->swap_lru))) {
 			spin_unlock(&glob->lru_lock);
 			return -EBUSY;
@@ -1841,6 +1901,12 @@ static int ttm_bo_swapout(struct ttm_mem
 			kref_put(&bo->list_kref, ttm_bo_release_list);
--
-	while (NULL == (p = ttm->pages[index])) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (NULL == (p = ttm->pages[index])) {
 
 		INIT_LIST_HEAD(&h);
 
@@ -127,6 +132,12 @@ static struct page *__ttm_tt_get_page(st
 			ttm->pages[--ttm->first_himem_page] = p;
--
 	while (entry) {
 		next = entry->next;
 		kfree(entry);
 		entry = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!vmw_lag_lt(queue, us)) {
 		spin_lock(&queue->lock);
 		if (list_empty(&queue->head))
@@ -166,6 +171,12 @@ int vmw_wait_lag(struct vmw_private *dev
 			return ret;
 
--
 	while (cur_size > 0) {
 		size = cur_size;
 		ret = vmw_cmd_check(dev_priv, sw_context, buf, &size);
@@ -844,6 +849,12 @@ static int vmw_cmd_check_all(struct vmw_
 			return ret;
 		buf = (void *)((unsigned long) buf + size);
--
 	while (sw_context->cmd_bounce_size < size) {
 		sw_context->cmd_bounce_size =
 			PAGE_ALIGN(sw_context->cmd_bounce_size +
 				   (sw_context->cmd_bounce_size >> 1));
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!list_empty(&fman->fence_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&fman->fence_list)) {
 		struct vmw_fence_obj *fence =
 			list_entry(fman->fence_list.prev, struct vmw_fence_obj,
 				   head);
@@ -664,6 +669,12 @@ void vmw_fence_fifo_down(struct vmw_fenc
 
--
 	while (num_pages > 0) {
 		unsigned long nr = min(num_pages, (unsigned long)VMW_PPN_PER_REMAP);
 
@@ -90,6 +95,12 @@ static int vmw_gmr2_bind(struct vmw_priv
 
 		num_pages -= nr;
--
 	while (likely(num_pages != 0)) {
 		page = alloc_page(__GFP_HIGHMEM);
 		if (unlikely(page == NULL)) {
@@ -186,6 +202,12 @@ static int vmw_gmr_build_descriptors(str
 
 		(++desc_virtual)->ppn = cpu_to_le32(0);
--
 	while (num_pages--) {
 		pfn = page_to_pfn(*pages++);
 		if (prev_pfn + 1 != pfn)
 			++descriptors;
 		prev_pfn = pfn;
+		if (_cur < timeout) {
--
 	while (1) {
 		uint32_t stop = ioread32(fifo_mem + SVGA_FIFO_STOP);
 		bool need_bounce = false;
@@ -370,6 +375,12 @@ void *vmw_fifo_reserve(struct vmw_privat
 				return fifo_state->dynamic_buffer;
 			}
--
 	while (bytes > 0) {
 		iowrite32(*buffer++, fifo_mem + (next_cmd >> 2));
 		next_cmd += sizeof(uint32_t);
@@ -416,6 +432,12 @@ static void vmw_fifo_slow_copy(struct vm
 		iowrite32(next_cmd, fifo_mem + SVGA_FIFO_NEXT_CMD);
 		mb();
--
 	while (new_bus) {
 		new_bridge = new_bus->self;
 
@@ -481,6 +486,11 @@ static void vga_arbiter_check_bridge_sha
 			/* now iterate the previous devices bridge hierarchy */
 			/* if the new devices parent bridge is in the other devices
--
 			while (bus) {
 				bridge = bus->self;
 				if (bridge) {
@@ -488,9 +498,21 @@ static void vga_arbiter_check_bridge_sha
 						vgadev->bridge_has_one_vga = false;
 				}
--
 	while (ids->id) {
 		if (ids->id == DIO_WILDCARD)
 			return ids;
@@ -40,6 +45,12 @@ dio_match_device(const struct dio_device
 				return ids;
 		}
--
 	while (dev->read_packet_length == 0) {
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EAGAIN;
@@ -645,6 +650,12 @@ static ssize_t tower_read (struct file *
 			goto unlock_exit;
 		}
--
 	while (dev->interrupt_out_busy) {
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EAGAIN;
@@ -717,6 +733,12 @@ static ssize_t tower_write (struct file
 		if (retval) {
 			goto unlock_exit;
--
-	while (rec) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rec) {
 		err = emi26_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
 					ANCHOR_LOAD_INTERNAL);
@@ -131,6 +136,12 @@ static int emi26_load_firmware (struct u
 			goto wraperr;
--
 		while (rec && (i + be16_to_cpu(rec->len) < FW_LOAD_SIZE)) {
 			memcpy(buf + i, rec->data, be16_to_cpu(rec->len));
 			i += be16_to_cpu(rec->len);
 			rec = ihex_next_binrec(rec);
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while (bytes_to_read) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bytes_to_read) {
 		int data_in_secondary = dev->secondary_tail - dev->secondary_head;
 		dbg(2," %s : while, data_in_secondary=%d, status=%d",
 		    __func__, data_in_secondary,
@@ -524,6 +529,12 @@ static ssize_t adu_read(struct file *fil
 				}
 			}
 		}
--
 	while (count > 0) {
 		add_wait_queue(&dev->write_wait, &waita);
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -657,6 +673,12 @@ static ssize_t adu_write(struct file *fi
 
 			bytes_written += bytes_to_write;
--
 	while (ptr+4 <= firmware->data+firmware->size) {
 		memcpy(data, ptr, 4);
 		len = (data[0] << 8 | data[1]);
@@ -99,6 +104,12 @@ static int isight_firmware_load(struct u
 			}
 
--
-	while (rec) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rec) {
 		err = emi62_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
 					ANCHOR_LOAD_INTERNAL);
@@ -138,6 +143,12 @@ static int emi62_load_firmware (struct u
 			goto wraperr;
--
 		while (rec && (i + be16_to_cpu(rec->len) < FW_LOAD_SIZE)) {
 			memcpy(buf + i, rec->data, be16_to_cpu(rec->len));
 			i += be16_to_cpu(rec->len);
 			rec = ihex_next_binrec(rec);
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
-		while (!completion_done(&completion)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!completion_done(&completion)) {
 			retval = usb_unlink_urb(urb);
 
 			switch (retval) {
@@ -1174,6 +1179,12 @@ static int unlink1(struct usbtest_dev *d
 			}
--
-		while (retries) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (retries) {
 			result = usb_control_msg(rio->rio_dev,
 						 usb_rcvctrlpipe(rio-> rio_dev, 0),
 						 rio_cmd.request,
@@ -192,6 +197,12 @@ static long ioctl_rio(struct file *file,
 			   will be little_endian and will potentially need to
--
-		while (retries) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (retries) {
 			result = usb_control_msg(rio->rio_dev,
 						 usb_sndctrlpipe(rio-> rio_dev, 0),
 						 rio_cmd.request,
@@ -246,6 +262,12 @@ static long ioctl_rio(struct file *file,
 
--
 		while (thistime) {
 			if (!rio->rio_dev) {
 				errn = -ENODEV;
@@ -330,6 +357,12 @@ write_rio(struct file *file, const char
 				thistime -= partial;
 			} else
--
 	while (count > 0) {
 		if (signal_pending(current)) {
 			mutex_unlock(&(rio->lock));
@@ -427,6 +465,12 @@ read_rio(struct file *file, char __user
 			read_count += this_read;
 			buffer += this_read;
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		u16 a = sisusbcon_readw(p);
 
 		a = ((a) & 0x88ff)        |
@@ -349,6 +354,12 @@ sisusbcon_invert_region(struct vc_data *
 		    (((a) & 0x0700) << 4);
--
 	while (timeout--) {
 		if (base == (mask & usbhs_read(priv, fifo->sel))) {
 			usbhs_pipe_select_fifo(pipe, fifo);
 			return 0;
 		}
 		udelay(10);
--
 	while (count++ < 3) {
 		command[5] = 0xa0;
 
@@ -378,6 +383,12 @@ static int datafab_determine_lun(struct
 		}
 
--
 	while (fst->Status & FCM_STATUS_BUSY) {
 		US_DEBUGP("20 second USB/ATAPI bridge TIMEOUT occurred!\n");
 		US_DEBUGP("fst->Status is %x\n", fst->Status);
@@ -306,6 +311,12 @@ static int freecom_transport(struct scsi
 			return USB_STOR_TRANSPORT_ERROR;
 
--
-	while (*++p && *p != ',') {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*++p && *p != ',') {
 		switch (TOLOWER(*p)) {
 		case 'a':
 			f |= US_FL_SANE_SENSE;
@@ -520,6 +525,12 @@ static void adjust_quirks(struct us_data
 			break;
--
 	while (ready == 0) {
 		msleep(20);
 
@@ -400,6 +405,12 @@ static int alauda_init_media(struct us_d
 
 		if (data[0] & 0x10)
--
 			while (EntrySize > 0) {
 
 				PageNumber = (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1);
@@ -1003,6 +1008,12 @@ static int ms_lib_process_bootblock(stru
 
 				EntryOffset += 2;
--
-	while (cnt < buflen && sg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt < buflen && sg) {
 		struct page *page = sg_page(sg) +
 				((sg->offset + *offset) >> PAGE_SHIFT);
 		unsigned int poff = (sg->offset + *offset) & (PAGE_SIZE-1);
@@ -177,7 +182,12 @@ unsigned int usb_stor_access_xfer_buf(un
 		/* Transfer the data for all the pages in this
--
-		while (sglen > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (sglen > 0) {
 			unsigned int plen = min(sglen, (unsigned int)
 					PAGE_SIZE - poff);
 			unsigned char *ptr = kmap(page);
@@ -193,6 +203,18 @@ unsigned int usb_stor_access_xfer_buf(un
 			++page;
--
 	while (atomic_read(&total_threads) > 0) {
 		wait_for_completion(&usu_end_notify);
 		atomic_dec(&total_threads);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (int_status != 0 && (count-- >= 0)) {
 		c67x00_ll_irq(c67x00, int_status);
 		for (i = 0; i < C67X00_SIES; i++) {
@@ -105,6 +110,12 @@ static irqreturn_t c67x00_irq(int irq, v
 				sie->irq(sie, int_status, msg);
 		}
--
 	while (c67x00_ep_data_free(ep)) {
 		/* Drop the lock so we can sleep waiting for the hardware */
 		spin_unlock_irqrestore(&c67x00->lock, flags);
@@ -349,6 +354,12 @@ void c67x00_endpoint_disable(struct usb_
 		wait_for_completion_timeout(&c67x00->endpoint_disable, 1 * HZ);
 
--
 	while (td->td_list.next != &c67x00->td_list) {
 		td = list_entry(td->td_list.next, struct c67x00_td, td_list);
 		if (td->pipe == last_td->pipe) {
@@ -921,6 +937,12 @@ static inline void c67x00_clear_pipe(str
 			td = tmp;
 		}
--
 		while (*prev && (temp = *prev) != ed) {
 			prev_p = &temp->hwNextED;
 			prev = &temp->ed_next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (data_len > 4096) {
 			td_fill (ohci, info, data, 4096, urb, cnt);
 			data += 4096;
 			data_len -= 4096;
 			cnt++;
+			if (_cur < timeout) {
--
 	while (td) {
 		struct td	*td_next = td->next_dl_td;
 		struct ed	*ed = td->ed;
@@ -1151,5 +1178,11 @@ dl_done_list (struct ohci_hcd *ohci)
 
 		takeback_td(ohci, td);
--
-		while (I-- > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (I-- > 0) {
 			retval = u132_read_pcimem(u132, roothub.portstatus[i],
 				&u132->hc_roothub_portstatus[i]);
 			if (retval) {
@@ -471,6 +476,12 @@ static int read_roothub_info(struct u132
 				return retval;
--
 			while (--I > 0) {
 				struct u132_udev *udev = &u132->udev[++i];
 				if (udev->usb_device) {
@@ -2194,6 +2210,12 @@ static int queue_control_on_old_endpoint
 					u132_udev_get_kref(u132, udev);
 					break;
--
 			while (urb_size-- > 0) {
 				if (i > m) {
 				} else if (i++ < m) {
@@ -2361,6 +2388,12 @@ static int u132_urb_enqueue(struct usb_h
 					l += w;
 				} else
--
-		while (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {
 			if (urb == endp->urb_list[ENDP_QUEUE_MASK &
 				++queue_scan]) {
 				urb_slot = &endp->urb_list[ENDP_QUEUE_MASK &
@@ -2468,12 +2506,29 @@ static int u132_endp_urb_dequeue(struct
 				break;
--
-		while (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {
 			*urb_slot = endp->urb_list[ENDP_QUEUE_MASK &
 				++queue_scan];
 			urb_slot = &endp->urb_list[ENDP_QUEUE_MASK &
 				queue_scan];
+				if (_cur < timeout) {
--
 			while (rings-- > 0) {
 				struct u132_ring *ring = &u132->ring[rings];
 				u132_ring_cancel_work(u132, ring);
-			} while (endps-- > 0) {
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
--
+			while (endps-- > 0) {
 				struct u132_endp *endp = u132->endp[endps];
 				if (endp)
 					u132_endp_cancel_work(u132, endp);
+					if (_cur < timeout) {
+								rdstcll(_cur);
--
 	while (rings-- > 0) {
 		struct u132_ring *ring = &u132->ring[rings];
 		ring->u132 = u132;
@@ -3049,9 +3131,20 @@ static void u132_initialise(struct u132
 		ring->curr_endp = NULL;
 		INIT_DELAYED_WORK(&ring->scheduler,
--
 	while (ports-- > 0) {
 		struct u132_port *port = &u132->port[ports];
 		port->u132 = u132;
@@ -3059,11 +3152,33 @@ static void u132_initialise(struct u132
 		port->enable = 0;
 		port->power = 0;
--
 	while (addrs-- > 0) {
 		struct u132_addr *addr = &u132->addr[addrs];
 		addr->address = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (udevs-- > 0) {
 		struct u132_udev *udev = &u132->udev[udevs];
 		int i = ARRAY_SIZE(udev->endp_number_in);
@@ -3078,6 +3193,12 @@ static void u132_initialise(struct u132
 		while (o-- > 0)
 			udev->endp_number_out[o] = 0;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (endps-- > 0)
 		u132->endp[endps] = NULL;
@@ -3167,8 +3288,19 @@ static int u132_suspend(struct platform_
 		case PM_EVENT_SUSPEND:
 		case PM_EVENT_HIBERNATE:
 			ports = MAX_U132_PORTS;
--
 			while (ports-- > 0) {
 				port_power(u132, ports, 0);
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
--
 			while (ports-- > 0) {
 				port_power(u132, ports, 1);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 	while ((reg_data != 0xFACE) && retry_count) {
 		/*by default host is in 16bit mode, so
 		 * io operations at this stage must be 16 bit
@@ -257,6 +262,12 @@ static int __devinit isp1761_pci_probe(s
 		udelay(100);
 		reg_data = readl(chip_addr + HC_SCRATCH_REG) & 0x0000ffff;
--
 	while (readl(imx21->regs + USBOTG_RST_CTRL) != 0) {
 		if (time_after(jiffies, timeout)) {
 			spin_unlock_irqrestore(&imx21->lock, flags);
@@ -1675,6 +1680,12 @@ static int imx21_hc_reset(struct usb_hcd
 		spin_unlock_irq(&imx21->lock);
 		schedule_timeout_uninterruptible(1);
--
-		while (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {
 			msleep (10);
 			if (--temp == 0) {
 				ohci_err (ohci, "USB HC takeover failed!"
 					"  (BIOS/SMM bug)\n");
 				return -EBUSY;
--
 	while ((ohci_readl (ohci, &ohci->regs->cmdstatus) & OHCI_HCR) != 0) {
 		if (--val == 0) {
 			spin_unlock_irq (&ohci->lock);
@@ -636,6 +652,12 @@ retry:
 			return -1;
 		}
--
 		while (ed->td_head != NULL) {
 			struct td *td = fhci_remove_td_from_ed(ed);
 			fhci_urb_complete_free(fhci, td->urb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (--j >= 0)
 		qe_pin_free(fhci->pins[j]);
 err_gpios:
-	while (--i >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (--i >= 0) {
 		if (gpio_is_valid(fhci->gpios[i]))
 			gpio_free(fhci->gpios[i]);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
--
 	while (!(readl(usb_phy_reg_base + USB_PHY_PLL_REG) & PLL_READY)) {
 		if (!(pll_retry_cont--)) {
 			dev_dbg(&pdev->dev, "USB PHY PLL not ready\n");
 			err = -EIO;
 			goto err2;
 		}
--
 	while (!(readl(usb_phy_reg_base + USB_PHY_PLL_REG) & PLL_READY)) {
 		if (!(pll_retry_cont--)) {
 			dev_dbg(&pdev->dev, "USB PHY PLL not ready\n");
 			err = -EIO;
 			goto err2;
 		}
--
-	while (qh->state != QH_STATE_IDLE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (qh->state != QH_STATE_IDLE) {
 		++uhci->num_waiting;
 		spin_unlock_irq(&uhci->lock);
 		wait_event_interruptible(uhci->waitqh,
 				qh->state == QH_STATE_IDLE);
 		spin_lock_irq(&uhci->lock);
--
-	while (itr_size >= sizeof(*hdr)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (itr_size >= sizeof(*hdr)) {
 		hdr = (struct usb_descriptor_header *) itr;
 		dev_dbg(dev, "Extra device descriptor: "
 			"type %02x/%u bytes @ %zu (%zu left)\n",
@@ -542,6 +547,12 @@ static int wa_fill_descr(struct wahc *wa
 			goto found;
--
 		while (bytes >= 4) {
 			*dst = le32_to_cpu(__raw_readl(src));
 			bytes -= 4;
 			src++;
 			dst++;
+			if (_cur < timeout) {
--
 		while (bytes >= 4) {
 			*dst = __raw_readl(src);
 			bytes -= 4;
 			src++;
 			dst++;
+			if (_cur < timeout) {
--
 	while (bytes > 0) {
 		*dst_byteptr = *src_byteptr;
 		dst_byteptr++;
 		src_byteptr++;
 		bytes--;
+		if (_cur < timeout) {
--
 		while (bytes >= 4) {
 			__raw_writel(cpu_to_le32(*src), dst);
 			bytes -= 4;
 			src++;
 			dst++;
+			if (_cur < timeout) {
--
 		while (bytes >= 4) {
 			__raw_writel(*src, dst);
 			bytes -= 4;
 			src++;
 			dst++;
+			if (_cur < timeout) {
--
 	while (ep_queue) {
 		list_for_each_entry_safe(qh, qh_next, ep_queue, qh_list) {
 			ep = list_entry(qh->qtd_list.next, struct isp1760_qtd,
@@ -966,6 +1026,12 @@ void schedule_ptds(struct usb_hcd *hcd)
 			ep_queue = &priv->bulkqhs;
 		else
--
 	while (ep_queue) {
 		list_for_each_entry_safe(qh, qh_next, ep_queue, qh_list)
 			enqueue_qtds(hcd, qh);
@@ -1009,6 +1080,12 @@ void schedule_ptds(struct usb_hcd *hcd)
 			ep_queue = &priv->bulkqhs;
 		else
--
 	while (priv->int_done_map || priv->atl_done_map) {
 		if (priv->int_done_map) {
 			/* INT ptd */
@@ -1237,6 +1319,12 @@ static void handle_done_ptds(struct usb_
 			start_bus_transfer(hcd, ptd_offset, slot, slots, qtd,
 				qh, &ptd);
--
 	while (last_trb(xhci, ring, enq_seg, enq)) {
 		enq_seg = enq_seg->next;
 		enq = enq_seg->trbs;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (last_trb(xhci, ring, enq_seg, enq)) {
 			enq_seg = enq_seg->next;
 			enq = enq_seg->trbs;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-	while (cur_seg->trbs > trb ||
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cur_seg->trbs > trb ||
 			&cur_seg->trbs[TRBS_PER_SEGMENT - 1] < trb) {
 		generic_trb = &cur_seg->trbs[TRBS_PER_SEGMENT - 1].generic;
 		if (generic_trb->field[3] & cpu_to_le32(LINK_TOGGLE))
@@ -498,6 +525,12 @@ static struct xhci_segment *find_trb_seg
 		if (cur_seg == start_seg)
--
-	while (xhci_trb_virt_to_dma(state->new_deq_seg, state->new_deq_ptr)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (xhci_trb_virt_to_dma(state->new_deq_seg, state->new_deq_ptr)
 			!= (dma_addr_t)(hw_dequeue & ~0xf)) {
 		next_trb(xhci, ep_ring, &state->new_deq_seg,
 					&state->new_deq_ptr);
@@ -609,6 +647,12 @@ void xhci_find_new_dequeue_state(struct
 			WARN_ON(1);
--
-			while (!list_empty(&ring->td_list)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&ring->td_list)) {
 				cur_td = list_first_entry(&ring->td_list,
 						struct xhci_td,
 						td_list);
@@ -1017,8 +1066,19 @@ void xhci_stop_endpoint_command_watchdog
 					list_del_init(&cur_td->cancelled_td_list);
--
-			while (!list_empty(&temp_ep->cancelled_td_list)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&temp_ep->cancelled_td_list)) {
 				cur_td = list_first_entry(
 						&temp_ep->cancelled_td_list,
 						struct xhci_td,
@@ -1026,6 +1086,12 @@ void xhci_stop_endpoint_command_watchdog
 				list_del_init(&cur_td->cancelled_td_list);
--
-	while (xhci_handle_event(xhci) > 0) {}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (xhci_handle_event(xhci) > 0) {if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
--
-		while (last_trb(xhci, ring, ring->enq_seg, next)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while (last_trb(xhci, ring, ring->enq_seg, next)) {
 			/* If we're not dealing with 0.95 hardware or isoc rings
 			 * on AMD 0.96 host, clear the chain bit.
 			 */
@@ -2828,6 +2910,12 @@ static int prepare_ring(struct xhci_hcd
 			ring->enq_seg = ring->enq_seg->next;
--
 		while (running_total < sg_dma_len(sg) && running_total < temp) {
 			num_trbs++;
 			running_total += TRB_MAX_BUFF_SIZE;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
--
 	while (running_total < urb->transfer_buffer_length) {
 		num_trbs++;
 		running_total += TRB_MAX_BUFF_SIZE;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 		while (offset && count--) {
 			pci_read_config_dword (pdev, offset, &cap);
 			switch (cap & 0xff) {
@@ -786,6 +791,12 @@ static ssize_t fill_registers_buffer(str
 				break;
 			}
--
 	while ((td = fhci_peek_td_from_frame(usb->actual_frame)) != NULL) {
 		struct packet *pkt = td->pkt;
 
 		pkt->status = USB_TD_TX_ER_TIMEOUT;
 		fhci_transaction_confirm(usb, pkt);
+		if (_cur < timeout) {
--
 	while (td != NULL) {
 		urb = td->urb;
 		urb_priv = urb->hcpriv;
@@ -675,6 +691,12 @@ static void process_done_list(unsigned l
 		}
 
--
-		while (data_len > 4096) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (data_len > 4096) {
 			td = fhci_td_fill(fhci, urb, urb_priv, ed, cnt,
 				usb_pipeout(urb->pipe) ? FHCI_TA_OUT :
 							 FHCI_TA_IN,
@@ -782,6 +809,12 @@ void fhci_queue_urb(struct fhci_hcd *fhc
 			data += 4096;
--
-	while (here.ptr && here.ptr != ptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (here.ptr && here.ptr != ptr) {
 		prev_p = periodic_next_shadow(ehci, prev_p,
 				Q_NEXT_TYPE(ehci, *hw_p));
 		hw_p = shadow_next_periodic(ehci, &here,
 				Q_NEXT_TYPE(ehci, *hw_p));
 		here = *prev_p;
--
 	while (q->ptr) {
 		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
 		case Q_TYPE_QH:
@@ -191,7 +207,13 @@ periodic_usecs (struct ehci_hcd *ehci, u
 			q = &q->sitd->sitd_next;
 			break;
--
 	while (q->ptr) {
 		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
 		case Q_TYPE_ITD:
@@ -303,6 +330,12 @@ periodic_tt_usecs (
 			hw_p = &q->fstn->hw_next;
 			q = &q->fstn->fstn_next;
--
 		while (here.ptr) {
 			switch (hc32_to_cpu(ehci, type)) {
 			case Q_TYPE_ITD:
@@ -468,6 +506,12 @@ static int tt_no_collision (
 
 			/* collision or error */
--
 		while (!list_empty (&stream->free_list)) {
 			struct list_head	*entry;
 
@@ -1093,6 +1142,12 @@ iso_stream_put(struct ehci_hcd *ehci, st
 				dma_pool_free (ehci->sitd_pool, sitd,
 						sitd->sitd_dma);
--
 		while (q.ptr != NULL) {
 			unsigned		uf;
 			union ehci_shadow	temp;
@@ -2455,6 +2515,12 @@ restart:
 				now_uframe = clock;
 				break;
--
-		while (wait_time > 0 &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (wait_time > 0 &&
 				readl(base + OHCI_CONTROL) & OHCI_CTRL_IR) {
 			wait_time -= 10;
 			msleep(10);
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while ((cap & EHCI_USBLEGSUP_BIOS) && (msec > 0)) {
 			tried_handoff = 1;
 			msleep(10);
 			msec -= 10;
 			pci_read_config_dword(pdev, offset, &cap);
+			if (_cur < timeout) {
--
-	while (offset && --count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset && --count) {
 		pci_read_config_dword(pdev, offset, &cap);
 
 		switch (cap & 0xff) {
@@ -663,6 +690,12 @@ static void __devinit quirk_usb_disable_
 				 "%02x\n", cap & 0xff);
--
-	while (ehci->qh_scan_next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+ timeout = rdstcll(start) + delta;
+ while (ehci->qh_scan_next) {
 		qh = ehci->qh_scan_next;
 		ehci->qh_scan_next = qh->qh_next.qh;
  rescan:
@@ -1303,6 +1308,12 @@ static void scan_async (struct ehci_hcd
 			else
--
 	while (ed) {
 		u32		info = hc32_to_cpu (ohci, ed->hwINFO);
 		u32		headp = hc32_to_cpu (ohci, ed->hwHeadP);
@@ -502,6 +507,12 @@ show_list (struct ohci_hcd *ohci, char *
 		buf += temp;
 
--
 	while (port--) {
 		if (test_bit(port, &ehci->owned_ports)) {
 			reg = &ehci->regs->port_status[port];
@@ -75,6 +80,12 @@ static void ehci_handover_companion_port
 						USB_PORT_FEAT_RESET, port + 1,
 						NULL, 0);
--
 	while (port--) {
 		if (test_bit(port, &ehci->owned_ports)) {
 			ehci_hub_control(hcd, GetPortStatus,
@@ -102,6 +118,12 @@ static void ehci_handover_companion_port
 				ehci_writel(ehci, status & ~PORT_PE, reg);
 			}
--
-		while (port--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (port--) {
 			u32 __iomem	*hostpc_reg;
 
 			hostpc_reg = (u32 __iomem *)((u8 *) ehci->regs
 					+ HOSTPC0 + 4 * port);
 			temp = ehci_readl(ehci, hostpc_reg);
--
 	while (port--) {
 		u32 __iomem	*reg = &ehci->regs->port_status[port];
 		u32		t1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;
@@ -179,18 +217,35 @@ static __maybe_unused void ehci_adjust_p
 		ehci_vdbg(ehci, "port %d, %08x -> %08x\n",
 				port + 1, t1, t2);
--
-		while (port--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (port--) {
 			u32 __iomem	*hostpc_reg;
 
 			hostpc_reg = (u32 __iomem *)((u8 *) ehci->regs
 					+ HOSTPC0 + 4 * port);
 			temp = ehci_readl(ehci, hostpc_reg);
--
-		while (port--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (port--) {
 			if (ehci->reset_done[port] != 0) {
 				spin_unlock_irq(&ehci->lock);
 				ehci_dbg(ehci, "suspend failed because "
@@ -233,6 +293,12 @@ static int ehci_bus_suspend (struct usb_
 						port + 1);
--
 	while (port--) {
 		u32 __iomem	*reg = &ehci->regs->port_status [port];
 		u32		t1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;
@@ -294,6 +365,12 @@ static int ehci_bus_suspend (struct usb_
 			ehci_writel(ehci, t2, reg);
 			changed = 1;
--
-		while (port--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (port--) {
 			u32 __iomem	*hostpc_reg;
 			u32		t3;
 
@@ -322,6 +404,12 @@ static int ehci_bus_suspend (struct usb_
 			ehci_dbg(ehci, "Port %d phy low-power mode %s\n",
--
 		while (i--) {
 			if (test_bit(i, &ehci->bus_suspended)) {
 				u32 __iomem	*hostpc_reg;
@@ -421,6 +514,12 @@ static int ehci_bus_resume (struct usb_h
 				ehci_writel(ehci, temp & ~HOSTPC_PHCD,
 						hostpc_reg);
--
 	while (i--) {
 		temp = ehci_readl(ehci, &ehci->regs->port_status [i]);
 		temp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
@@ -438,6 +542,12 @@ static int ehci_bus_resume (struct usb_h
 			set_bit(i, &resume_needed);
 		}
--
 	while (i--) {
 		temp = ehci_readl(ehci, &ehci->regs->port_status [i]);
 		if (test_bit(i, &resume_needed)) {
@@ -455,6 +570,12 @@ static int ehci_bus_resume (struct usb_h
 			ehci_writel(ehci, temp, &ehci->regs->port_status [i]);
 			ehci_vdbg (ehci, "resumed port %d\n", i + 1);
--
-			while (ports--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (ports--) {
 				u32 __iomem *sreg =
 						&ehci->regs->port_status[ports];
 
@@ -1073,6 +1199,12 @@ static int ehci_hub_control (
 				if (temp & PORT_PE)
--
 	while (remaining) {
 		size_t len;
 
@@ -287,6 +292,12 @@ static void qset_copy_bounce_to_sg(struc
 			sg = sg_next(sg);
 			offset = 0;
--
 		while (dma_remaining) {
 			size_t dma_len;
 
@@ -521,6 +537,12 @@ static int qset_add_urb_sg(struct whc *w
 			prev_end = dma_addr = ep;
 			dma_remaining -= dma_len;
--
 		while (sg_remaining) {
 			if (!std || std->len == max_std_len) {
 				std = qset_new_std(whc, qset, urb, mem_flags);
@@ -599,6 +626,12 @@ static int qset_add_urb_sg_linearize(str
 			orig += len;
 			sg_remaining -= len;
--
 	while (ntds_remaining) {
 		struct whc_std *std;
 		size_t std_len;
@@ -683,6 +721,12 @@ int qset_add_urb(struct whc *whc, struct
 		ntds_remaining--;
 		remaining -= std_len;
--
-		while (i--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i--) {
 			int pstatus;
 
 			/* leverage per-port change bits feature */
@@ -915,6 +920,12 @@ static irqreturn_t ehci_irq (struct usb_
 			ehci->reset_done[i] = jiffies + msecs_to_jiffies(25);
--
 	while (len > 0) {
 		int pktsze = maxsze;
 
@@ -857,6 +862,12 @@ static int uhci_submit_control(struct uh
 
 		data += pktsze;
--
 	while (tmp != &urbp->td_list) {
 		td = list_entry(tmp, struct uhci_td, list);
 		tmp = tmp->prev;
 
 		uhci_remove_td_from_urbp(td);
 		uhci_free_td(uhci, td);
--
-		while ((qh = uhci->next_qh) != uhci->skelqh[i]) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((qh = uhci->next_qh) != uhci->skelqh[i]) {
 			uhci->next_qh = list_entry(qh->node.next,
 					struct uhci_qh, node);
 
@@ -1770,6 +1797,12 @@ rescan:
 	list_entry(qh->queue.next, struct urb_priv, node));
--
 	while (here.ptr && here.ptr != ptr) {
 		prev_p = periodic_next_shadow(prev_p, Q_NEXT_TYPE(*hw_p));
 		hw_p = here.hw_next;
 		here = *prev_p;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (q->ptr) {
 		switch (Q_NEXT_TYPE(*hw_p)) {
 		case Q_TYPE_QH:
@@ -1864,7 +1880,13 @@ static unsigned short periodic_usecs(str
 			q = &q->qh->qh_next;
 			break;
--
 		while (q.ptr != NULL) {
 			union ehci_shadow temp;
 			int live;
@@ -2316,6 +2343,12 @@ restart:
 			/* assume completion callbacks modify the queue */
 			if (unlikely(modified))
--
-		while (i--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while (i--) {
 			int pstatus = readl(&oxu->regs->port_status[i]);
 
 			if (pstatus & PORT_OWNER)
@@ -2505,6 +2543,12 @@ static irqreturn_t oxu210_hcd_irq(struct
 			oxu->reset_done[i] = jiffies + msecs_to_jiffies(20);
--
 	while (port--) {
 		u32 __iomem *reg = &oxu->regs->port_status[port];
 		u32 t1 = readl(reg) & ~PORT_RWC_BITS;
@@ -3499,6 +3548,12 @@ static int oxu_bus_suspend(struct usb_hc
 				port + 1, t1, t2);
 			writel(t2, reg);
--
-	while (i--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i--) {
 		temp = readl(&oxu->regs->port_status[i]);
 		temp &= ~(PORT_RWC_BITS
 			| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);
@@ -3566,9 +3626,20 @@ static int oxu_bus_resume(struct usb_hcd
 			temp |= PORT_RESUME;
--
 	while (i--) {
 		temp = readl(&oxu->regs->port_status[i]);
 		if (test_bit(i, &oxu->bus_suspended) && (temp & PORT_SUSPEND)) {
@@ -3576,6 +3647,12 @@ static int oxu_bus_resume(struct usb_hcd
 			writel(temp, &oxu->regs->port_status[i]);
 			oxu_vdbg(oxu, "resumed port %d\n", i + 1);
--
 		while (seg != first_seg) {
 			struct xhci_segment *next = seg->next;
 			xhci_segment_free(xhci, seg);
 			seg = next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (num_segs > 0) {
 		struct xhci_segment	*next;
 
 		next = xhci_segment_alloc(xhci, flags);
 		if (!next) {
 			prev = ring->first_seg;
--
 			while (prev) {
 				next = prev->next;
 				xhci_segment_free(xhci, prev);
 				prev = next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
-		while (port_index--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (port_index--) {
 			if (bus_state->resume_done[port_index] != 0) {
 				spin_unlock_irqrestore(&xhci->lock, flags);
 				xhci_dbg(xhci, "suspend failed because "
@@ -967,11 +972,22 @@ int xhci_bus_suspend(struct usb_hcd *hcd
 						port_index + 1);
--
 	while (port_index--) {
 		/* suspend the port if the port is not suspended */
 		u32 t1, t2;
@@ -1007,6 +1023,12 @@ int xhci_bus_suspend(struct usb_hcd *hcd
 		t1 = xhci_port_state_to_neutral(t1);
 		if (t1 != t2)
--
 	while (port_index--) {
 		/* Check whether need resume ports. If needed
 		   resume port and disable remote wakeup */
@@ -1085,6 +1112,12 @@ int xhci_bus_resume(struct usb_hcd *hcd)
 				xhci_ring_device(xhci, slot_id);
 		} else
--
 	while (port--) {
 		u32 stat = isp1362_read_reg32(isp1362_hcd, HCRHPORT1 + port);
 
@@ -1885,6 +1890,12 @@ static int isp1362_bus_resume(struct usb
 		}
 		DBG(0, "%s: Resuming RH port %d\n", __func__, port);
--
 	while (!clkrdy && time_before_eq(jiffies, t)) {
 		spin_lock_irqsave(&isp1362_hcd->lock, flags);
 		clkrdy = isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_CLKRDY;
 		spin_unlock_irqrestore(&isp1362_hcd->lock, flags);
 		if (!clkrdy)
 			msleep(4);
--
 	while (buf) {
 		p = strchr(buf, '\n');
 		if (p)
@@ -34,6 +39,12 @@ static void lprintk(char *buf)
 		buf = p;
 		if (buf)
--
 		while (tmp != head) {
 			qh = list_entry(tmp, struct uhci_qh, node);
 			tmp = tmp->next;
@@ -465,6 +481,12 @@ check_link:
 						len - (out - buf), 4);
 			if (!fsbr_link && qh->skel >= SKEL_FSBR)
--
 	while (array[i] != 0) {
 		if (r8a66597->pipe_cnt[min] > r8a66597->pipe_cnt[array[i]])
 			min = array[i];
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (val--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (val--) {
 		u32 stat =
 		    isp116x_read_reg32(isp116x, val ? HCRHPORT2 : HCRHPORT1);
 		/* force global, not selective, resume */
@@ -1485,6 +1490,12 @@ static int isp116x_bus_resume(struct usb
 		DBG("%s: Resuming port %d\n", __func__, val);
--
 		while (queue) {
 			struct cppi_descriptor	*tmp = queue->next;
 
 			cppi_bd_free(cppi_ch, queue);
 			queue = tmp;
+			if (_cur < timeout) {
--
 	while (!list_empty(&ep->req_list)) {
 		req = list_first_entry(&ep->req_list, struct musb_request, list);
 		musb_g_giveback(ep, &req->request, status);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (csr & MUSB_TXCSR_FIFONOTEMPTY) {
 		if (csr != lastcsr)
 			dev_dbg(musb->controller, "Host TX FIFONOTEMPTY csr: %02x\n", csr);
@@ -125,6 +130,12 @@ static void musb_h_tx_flush_fifo(struct
 				ep->epnum, csr))
 			return;
--
 		while (!list_empty(&hep->urb_list)) {
 			urb = next_urb(qh);
 			urb->status = -ESHUTDOWN;
 			musb_advance_schedule(musb, urb, qh->hw_ep, is_in);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
 				& MUSB_ULPI_REG_CMPLT)) {
 		i++;
 		if (i == 10000)
 			return -ETIMEDOUT;
 
--
-	while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
 				& MUSB_ULPI_REG_CMPLT)) {
 		i++;
 		if (i == 10000)
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
--
 	while (reg) {
 		if (reg & 1) {
 			/* musb_ep_select(musb->mregs, ep_num); */
@@ -1560,11 +1587,22 @@ irqreturn_t musb_interrupt(struct musb *
 
 		reg >>= 1;
--
 	while (reg) {
 		if (reg & 1) {
 			/* musb_ep_select(musb->mregs, ep_num); */
@@ -1580,6 +1618,12 @@ irqreturn_t musb_interrupt(struct musb *
 		}
 		reg >>= 1;
--
-	while (ms--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (ms--) {
 		for (i = 0; i < 1000; i++)
 			outb(0x1, 0x80);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((cap & EHCI_USBLEGSUP_BIOS) && (msec > 0)) {
 		mdelay(10);
 		msec -= 10;
 		cap = read_pci_config(ehci_dev.bus, ehci_dev.slot,
 				      ehci_dev.func, offset);
+		if (_cur < timeout) {
--
 	while (n > 0) {
 		for (chunk = 0; chunk < DBGP_MAX_PACKET && n > 0;
 		     str++, chunk++, n--) {
@@ -959,6 +986,12 @@ static void early_dbgp_write(struct cons
 			ret = dbgp_bulk_write(USB_DEBUG_DEVNUM,
 				      dbgp_endpoint_out, buf, chunk);
--
 	while (readl(&ehci_debug->control) & DBGP_ENABLED) {
 		kgdbdbgp_loop_cnt = 1;
 		ret = kgdbdbgp_read_char();
@@ -1074,6 +1112,12 @@ static int kgdbdbgp_reader_thread(void *
 			continue;
 		}
--
 		while (1) {
 			if (signal_pending(current))
 				return -ERESTARTSYS;
@@ -2055,6 +2060,12 @@ static int mos7720_ioctl(struct tty_stru
 				return 0;
 			}
--
 	while (!list_empty(&garmin_data_p->pktlist)) {
 		result = (struct garmin_packet *)garmin_data_p->pktlist.next;
 		list_del(&result->list);
 		kfree(result);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (n < size) {
 		cksum += *recpkt++;
 		n++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (offs < count) {
 
 		data = *(buf+offs);
@@ -573,6 +600,12 @@ static int gsp_receive(struct garmin_dat
 			size = GSP_INITIAL_OFFSET;
 			dleSeen = 0;
--
 	while ((pkt = pkt_pop(garmin_data_p)) != NULL) {
 		dbg("%s - next pkt: %d", __func__, pkt->seq);
 		result = gsp_send(garmin_data_p, pkt->data, pkt->size);
@@ -740,6 +778,12 @@ static int gsp_next_packet(struct garmin
 			return result;
 		}
--
-	while (offs < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offs < count) {
 		/* if buffer contains header, copy rest of data */
 		if (garmin_data_p->insize >= GARMIN_PKTHDR_LENGTH)
 			len = GARMIN_PKTHDR_LENGTH
@@ -818,6 +867,12 @@ static int nat_receive(struct garmin_dat
 				}
--
 	while (count) {
 		unsigned int i;
 		unsigned int lf;
@@ -250,6 +255,12 @@ static void usb_console_write(struct con
 		}
 		buf += i;
--
-		while (todo > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (todo > 0) {
 			/* max 8 byte in one urb (endpoint size) */
 			length = (todo < 8) ? todo : 8;
 			/* copy data to transfer buffer */
@@ -470,6 +475,12 @@ static int kobil_write(struct tty_struct
 
--
-		while (i < urb->actual_length) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i < urb->actual_length) {
 
 			/* Check port number from message*/
 			if (data[i] >= serial->num_ports) {
@@ -915,6 +920,12 @@ static void usa49wg_indat_callback(struc
 			}
--
 	while (1) {
 		/* wake up in bulk read */
 		interruptible_sleep_on(&port->delta_msr_wait);
@@ -568,6 +573,12 @@ static int spcp8x5_wait_modem_info(struc
 			return 0;
 
--
 		while (1) {
 			interruptible_sleep_on(&port->delta_msr_wait);
 			if (signal_pending(current))
@@ -864,6 +869,12 @@ static int ti_ioctl(struct tty_struct *t
 			    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)))
 				return 0;
--
 	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
 		err = usb_submit_urb(urb, GFP_ATOMIC);
 		if (!err) {
@@ -700,6 +705,12 @@ static void play_delayed(struct usb_seri
 			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((factor > 0xfff0) && divisor) {
 		factor >>= 3;
 		divisor--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!multi_change) {
 		interruptible_sleep_on(&port->delta_msr_wait);
 		/* see if a signal did it */
@@ -549,6 +565,12 @@ static int wait_modem_info(struct usb_se
 			return 0;
 		}
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		count = mos7840_chars_in_buffer(tty);
 
 		/* Check for Buffer status */
@@ -1335,6 +1340,12 @@ static void mos7840_block_until_chase_re
 			/* Reset timeout value back to seconds */
--
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (1) {
 			/* interruptible_sleep_on(&mos7840_port->delta_msr_wait); */
 			mos7840_port->delta_msr_cond = 0;
 			wait_event_interruptible(port->delta_msr_wait,
@@ -2333,6 +2349,12 @@ static int mos7840_ioctl(struct tty_stru
 				return 0;
--
-		while ((position < length) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((position < length) &&
 				(portNumber < edge_serial->serial->num_ports)) {
 			txCredits = data[position] | (data[position+1] << 8);
 			if (txCredits) {
@@ -652,6 +657,12 @@ static void edge_interrupt_callback(stru
 			}
--
 	while (1) {
 		/* Save Last credits */
 		lastCredits = edge_port->txCredits;
@@ -1002,6 +1018,12 @@ static void block_until_chase_response(s
 					lastCredits, edge_port->txCredits);
 			loop = 10;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		/* Save Last count */
 		lastCount = fifo->count;
 
@@ -1053,6 +1080,12 @@ static void block_until_tx_empty(struct
 			/* Reset timeout value back to seconds */
--
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (1) {
 			prepare_to_wait(&port->delta_msr_wait,
 						&wait, TASK_INTERRUPTIBLE);
 			schedule();
@@ -1723,6 +1761,12 @@ static int edge_ioctl(struct tty_struct
 				return 0;
--
 			while (tmp >= 256) {
 				tmp >>= 2;
 				buf[1] <<= 1;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
--
 	while (1) {
 		interruptible_sleep_on(&port->delta_msr_wait);
 		/* see if a signal did it */
@@ -635,6 +651,12 @@ static int wait_modem_info(struct usb_se
 			return 0;
 		}
--
 	while (1) {
 		wait_event_interruptible(port->delta_msr_wait,
 					 (port->serial->disconnected ||
@@ -414,6 +419,12 @@ static int wait_modem_info(struct usb_se
 		    (arg & TIOCM_CD  && (prev.dcd != cur.dcd)) ||
 		    (arg & TIOCM_CTS && (prev.cts != cur.cts)))
--
 	while (count > 0) {
-		while (oob_priv->dp_write_urb_in_use) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (oob_priv->dp_write_urb_in_use) {
 			cond_wait_interruptible_timeout_irqrestore(
 				&oob_port->write_wait, DIGI_RETRY_TIMEOUT,
 				&oob_priv->dp_port_lock, flags);
 			if (interruptible && signal_pending(current))
 				return -EINTR;
--
 	while (count > 0 && ret == 0) {
-		while (priv->dp_write_urb_in_use &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (priv->dp_write_urb_in_use &&
 		       time_before(jiffies, timeout)) {
 			cond_wait_interruptible_timeout_irqrestore(
 				&port->write_wait, DIGI_RETRY_TIMEOUT,
@@ -710,6 +742,12 @@ static int digi_write_inb_command(struct
 			if (signal_pending(current))
--
-	while (oob_priv->dp_write_urb_in_use) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (oob_priv->dp_write_urb_in_use) {
 		spin_unlock(&port_priv->dp_port_lock);
 		cond_wait_interruptible_timeout_irqrestore(
 			&oob_port->write_wait, DIGI_RETRY_TIMEOUT,
@@ -790,6 +839,12 @@ static int digi_set_modem_signals(struct
 			return -EINTR;
--
-	while (time_before(jiffies, timeout) && !priv->dp_transmit_idle) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, timeout) && !priv->dp_transmit_idle) {
 		cond_wait_interruptible_timeout_irqrestore(
 			&priv->dp_transmit_idle_wait, DIGI_RETRY_TIMEOUT,
 			&priv->dp_port_lock, flags);
 		if (signal_pending(current))
 			return -EINTR;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		wait_event_interruptible(port->delta_msr_wait,
 					port->serial->disconnected ||
 					priv->status.pin_state != prev);
@@ -724,6 +729,12 @@ static int wait_modem_info(struct usb_se
 		    ((arg & TIOCM_CTS) && (changed & PIN_CTS)))
--
-	while (length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (length) {
 		if (length > 64)
 			read_length = 64;
 		else
@@ -347,6 +352,12 @@ static int read_download_mem(struct usb_
 		start_address += read_length;
--
-	while (length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (length) {
 		if (length > EPROM_PAGE_SIZE)
 			write_length = EPROM_PAGE_SIZE;
 		else
@@ -500,6 +516,12 @@ static int write_i2c_mem(struct edgeport
 		length		-= write_length;
--
 		while (1) {
 			interruptible_sleep_on(&port->delta_msr_wait);
 			/* see if a signal did it */
@@ -2605,6 +2632,12 @@ static int edge_ioctl(struct tty_struct
 				return 0;
 			}
--
-	while (seq[0] >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (seq[0] >= 0) {
 		dev_vdbg(motg->otg.dev, "ulpi: write 0x%02x to 0x%02x\n",
 				seq[0], seq[1]);
 		ulpi_write(&motg->otg, seq[0], seq[1]);
 		seq += 2;
+		if (_cur < timeout) {
--
 	while (usec--) {
 		if (!(readl(view) & mask))
 			return 0;
 
 		udelay(1);
+		if (_cur < timeout) {
--
 	while (length) {
 		/*
 		 * Determine step_len.
@@ -247,6 +252,12 @@ static unsigned int mon_copy_to_buff(con
 		if ((off += step_len) >= this->b_size) off = 0;
 		from += step_len;
--
 	while (length) {
 		/*
 		 * Determine step_len.
@@ -280,6 +296,12 @@ static int copy_from_buf(const struct mo
 		if ((off += step_len) >= this->b_size) off = 0;
 		to += step_len;
--
 	while (ndesc-- != 0) {
 		if (fp->actual_length != 0) {
 			if (fp->offset + fp->actual_length > length)
 				length = fp->offset + fp->actual_length;
 		}
 		fp++;
--
 	while (ndesc-- != 0) {
 		dp = (struct mon_bin_isodesc *)
 		    (rp->b_vec[offset / CHUNK_SIZE].ptr + offset % CHUNK_SIZE);
@@ -476,6 +514,12 @@ static void mon_bin_get_isodesc(const st
 		if ((offset += sizeof(struct mon_bin_isodesc)) >= rp->b_size)
 			offset = 0;
--
 	while (bytes < avail) {
 		ep = MON_OFF2HDR(rp, cur_out);
 
@@ -969,6 +1018,12 @@ static int mon_bin_queued(struct mon_rea
 		if ((cur_out += size) >= rp->b_size)
 			cur_out -= rp->b_size;
--
 	while (MON_RING_EMPTY(rp)) {
 		spin_unlock_irqrestore(&rp->b_lock, flags);
 
@@ -1293,6 +1353,12 @@ static int mon_bin_wait_event(struct fil
 		set_current_state(TASK_INTERRUPTIBLE);
 
--
 	while ((ep = mon_text_fetch(rp, mbus)) == NULL) {
 		if (file->f_flags & O_NONBLOCK) {
 			set_current_state(TASK_RUNNING);
@@ -467,6 +472,12 @@ static struct mon_event_text *mon_text_r
 			return ERR_PTR(-EINTR);
 		}
--
 	while (!list_empty(&rp->e_list)) {
 		p = rp->e_list.next;
 		ep = list_entry(p, struct mon_event_text, e_link);
 		list_del(p);
 		--rp->nevents;
 		kmem_cache_free(rp->e_slab, ep);
--
 	while (!list_empty(&mon_buses)) {
 		p = mon_buses.next;
 		mbus = list_entry(p, struct mon_bus, bus_link);
@@ -411,6 +416,12 @@ static void __exit mon_exit(void)
 
 		mon_dissolve(mbus, mbus->u_bus);
--
 	while (buflen > 2) {
 		if (buffer [1] != USB_DT_CS_INTERFACE) {
 			dev_err(&intf->dev, "skipping garbage\n");
@@ -721,6 +726,12 @@ static int wdm_probe(struct usb_interfac
 next_desc:
 		buflen -= buffer[0];
--
 	while (writecount < count) {
 		/*
 		 * Step 1: Submit next block.
@@ -777,6 +782,12 @@ static ssize_t usblp_write(struct file *
 		 * The wmut exists mainly to cover us here.
 		 */
--
-	while (remaining > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (remaining > 0) {
 		if (remaining > USBTMC_SIZE_IOBUFFER - 12 - 3)
 			this_part = USBTMC_SIZE_IOBUFFER - 12 - 3;
 		else
@@ -487,6 +492,12 @@ static ssize_t usbtmc_read(struct file *
 			remaining = 0;
--
 	while (remaining > 0) {
 		if (remaining > USBTMC_SIZE_IOBUFFER - 12) {
 			this_part = USBTMC_SIZE_IOBUFFER - 12;
@@ -584,6 +600,12 @@ static ssize_t usbtmc_write(struct file
 
 		remaining -= this_part;
--
 			while (i != 0) {
 				--i;
 				--wb;
 				usb_free_coherent(acm->dev, acm->writesize,
 				    wb->buf, wb->dmah);
+				if (_cur < timeout) {
--
 	while (buflen > 0) {
 		if (buffer[1] != USB_DT_CS_INTERFACE) {
 			dev_err(&intf->dev, "skipping garbage\n");
@@ -960,6 +976,12 @@ static int acm_probe(struct usb_interfac
 next_desc:
 		buflen -= buffer[0];
--
 		while (skb2) {
 			if (status < 0
 					|| ETH_HLEN > skb2->len
@@ -318,6 +323,12 @@ static void rx_complete(struct usb_ep *e
 			status = netif_rx(skb2);
 next_frame:
--
 	while (i--) {
 		req = usb_ep_alloc_request(ep, GFP_ATOMIC);
 		if (!req)
 			return list_empty(list) ? -ENOMEM : 0;
 		list_add(&req->list, list);
+		if (_cur < timeout) {
--
-	while (!list_empty(&dev->rx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_reqs)) {
 		req = container_of(dev->rx_reqs.next,
 				struct usb_request, list);
 		list_del_init(&req->list);
@@ -436,6 +463,12 @@ static void rx_fill(struct eth_dev *dev,
 		}
--
-	while (!list_empty(&dev->tx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->tx_reqs)) {
 		req = container_of(dev->tx_reqs.next,
 					struct usb_request, list);
 		list_del(&req->list);
@@ -965,6 +1003,12 @@ void gether_disconnect(struct gether *li
 		spin_unlock(&dev->req_lock);
--
-	while (!list_empty(&dev->rx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_reqs)) {
 		req = container_of(dev->rx_reqs.next,
 					struct usb_request, list);
 		list_del(&req->list);
@@ -980,6 +1029,12 @@ void gether_disconnect(struct gether *li
 		spin_unlock(&dev->req_lock);
--
 			while (i) {
 				sprintf(name, NAME_TEMPLATE, --i);
 				remove_proc_entry(name, NULL);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (len != 0 && (c = (u8) *s++) != 0) {
 		if (unlikely(c & 0x80)) {
 			// 2-byte sequence:
@@ -77,6 +82,12 @@ static int utf8_to_utf16le(const char *s
 		put_unaligned_le16(uchar, cp++);
 		count++;
--
-	while (!list_empty (&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty (&ep->queue)) {
 		struct s3c2410_request *req;
 		req = list_entry (ep->queue.next, struct s3c2410_request,
 				queue);
 		s3c2410_udc_done(ep, req, status);
+		if (_cur < timeout) {
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct pxa27x_request, queue);
 		req_done(ep, req, status, &flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!ep_is_empty(ep)) {
 		i = udc_ep_readl(ep, UDCDR);
 		ep_err(ep, "wrong to have extra bytes for setup : 0x%08x\n", i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (likely(count >= 2)) {
 		/* no byte-swap required; chip endian set during init */
 		writew(*bufp++, ep_data);
 		count -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!(net2272_ep_read(ep, EP_STAT0) & (1 << BUFFER_FULL))) {
 		buf = req->req.buf + req->req.actual;
 		prefetch(buf);
@@ -499,6 +515,12 @@ net2272_write_fifo(struct net2272_ep *ep
 			return 1;
 		}
--
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next,
 				struct net2272_request,
 				queue);
 		net2272_done(ep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
--
-		while (!list_empty(&ep->queue)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&ep->queue)) {
 			req = list_entry(ep->queue.next,
 				struct net2272_request, queue);
 			net2272_done(ep, req,
 				(req->req.actual == req->req.length) ? 0 : -EPROTO);
+			if (_cur < timeout) {
--
 	while (--i >= 0) {
 		iounmap(mem_mapped_addr[i]);
 		release_mem_region(pci_resource_start(pdev, i),
 			pci_resource_len(pdev, i));
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (--i >= 0) {
 		iounmap(mem_mapped_addr[i]);
 		release_mem_region(pci_resource_start(pdev, i),
 			pci_resource_len(pdev, i));
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while ((pch_udc_read_ep_control(ep) & UDC_EPCTL_NAK) && --loopcnt) {
 		pch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_CNAK);
 		udelay(5);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct pch_udc_request, queue);
 		complete_req(ep, req, -ESHUTDOWN);	/* Remove from list */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&ep->queue)) {
 		struct fsl_req *req = NULL;
 
 		req = list_entry(ep->queue.next, struct fsl_req, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
--
 	while (fsl_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {
 		if (time_after(jiffies, timeout)) {
 			ERR("udc reset timeout!\n");
 			return -ETIMEDOUT;
 		}
 		cpu_relax();
--
 		while (fsl_readl(&dr_regs->endptflush)) {
 			if (time_after(jiffies, timeout)) {
 				ERR("ep flush timeout\n");
 				return;
 			}
 			cpu_relax();
--
 	} while (fsl_readl(&dr_regs->endptstatus) & bits);
diff -u -p a/usb/gadget/langwell_udc.c b/usb/gadget/langwell_udc.c
--- a/usb/gadget/langwell_udc.c
+++ b/usb/gadget/langwell_udc.c
@@ -450,11 +450,22 @@ static void nuke(struct langwell_ep *ep,
 	if (&ep->ep && ep->desc)
--
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		struct langwell_request	*req = NULL;
 		req = list_entry(ep->queue.next, struct langwell_request,
 				queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
--
 		while (readl(&dev->op_regs->endptflush)) {
 			if (time_after(jiffies, timeout)) {
 				dev_err(&dev->pdev->dev, "ep flush timeout\n");
 				goto done;
 			}
 			cpu_relax();
--
 	} while (readl(&dev->op_regs->endptstat) & flush_bit);
 done:
@@ -1368,12 +1390,23 @@ static int langwell_udc_reset(struct lan
 
 	/* wait for reset to complete */
 	timeout = jiffies + RESET_TIMEOUT;
--
 	while (readl(&dev->op_regs->usbcmd) & CMD_RST) {
 		if (time_after(jiffies, timeout)) {
 			dev_err(&dev->pdev->dev, "device reset timeout\n");
 			return -ETIMEDOUT;
 		}
 		cpu_relax();
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct m66592_request, queue);
 		spin_lock_irqsave(&ep->m66592->lock, flags);
 		transfer_complete(ep, req, -ECONNRESET);
 		spin_unlock_irqrestore(&ep->m66592->lock, flags);
+		if (_cur < timeout) {
--
 	while (!list_empty(&imx_ep->queue)) {
 		req = list_entry(imx_ep->queue.next, struct imx_request, queue);
 		done(imx_ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		if (count == 0) {	/* last byte */
 			temp = __raw_readl(imx_ep->imx_usb->base
 				+ USB_EP_FCTRL(EP_NO(imx_ep)));
@@ -456,6 +472,12 @@ static int write_packet(struct imx_ep_st
 		}
--
 	while (!imx_ep_empty(imx_ep)) {
 		i = __raw_readl(imx_usb->base +	USB_EP_FDAT(EP_NO(imx_ep)));
 		D_ERR(imx_usb->dev,
 			"<%s> wrong to have extra bytes for setup : 0x%08x\n",
 			__func__, i);
+		if (_cur < timeout) {
--
-	while (!(r8a66597_read(r8a66597, ep->fifoctr) & FRDY)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(r8a66597_read(r8a66597, ep->fifoctr) & FRDY)) {
 		udelay(1);
 		if (unlikely(i++ >= 10000)) {	/* timeout = 10 msec */
 			dev_err(r8a66597_to_dev(r8a66597),
@@ -1424,6 +1429,12 @@ static void sudmac_finish(struct r8a6659
 				__func__, pipenum);
--
 	while (!list_empty(&ep->queue)) {
 		req = get_request_from_ep(ep);
 		spin_lock_irqsave(&ep->r8a66597->lock, flags);
 		transfer_complete(ep, req, -ECONNRESET);
 		spin_unlock_irqrestore(&ep->r8a66597->lock, flags);
+		if (_cur < timeout) {
--
-	while (!list_empty(&hsep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&hsep->queue)) {
 		hsreq = list_entry(hsep->queue.next,
 				struct s3c_hsudc_req, queue);
 		s3c_hsudc_complete_request(hsep, hsreq, status);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (rcnt-- != 0) {
 		word = (u16)readl(fifo);
 		if (buflen) {
@@ -408,6 +424,12 @@ static int s3c_hsudc_read_fifo(struct s3
 		} else {
 			hsreq->req.status = -EOVERFLOW;
--
 	while (ep_intr) {
 		if (ep_intr & 1)  {
 			hsep = &hsudc->ep[ep_idx];
@@ -1129,6 +1156,12 @@ static irqreturn_t s3c_hsudc_irq(int irq
 		}
 		ep_intr >>= 1;
--
 		while (likely(size-- != 0)) {
 			u8	byte = (u8) readl(ep->reg_fifo);
 
@@ -472,6 +477,12 @@ top:
 				*buf++ = byte;
 				bufferspace--;
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct goku_request, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct at91_request, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&mEp->qh.queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mEp->qh.queue)) {
 
 		/* pop oldest request */
 		struct ci13xxx_req *mReq = \
@@ -1604,6 +1609,12 @@ __acquires(mEp->lock)
 			mReq->req.complete(&mEp->ep, &mReq->req);
--
 		while (max >= 2) {
 			omap_writew(*wp++, UDC_DATA);
 			max -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (avail >= 2) {
 			*wp++ = omap_readw(UDC_DATA);
 			avail -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct omap_req, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (likely (count-- != 0)) {
 			u8	byte = (u8) *ep->reg_uddr;
 
@@ -558,6 +563,12 @@ read_fifo (struct pxa25x_ep *ep, struct
 				*buf++ = byte;
 				bufferspace--;
--
 	while (UDCCS0 & UDCCS0_RNE) {
 		byte = (u8) UDDR0;
 
@@ -614,6 +630,12 @@ read_ep0_fifo (struct pxa25x_ep *ep, str
 			req->req.actual++;
 			bufferspace--;
--
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next,
 				struct pxa25x_request,
 				queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
--
 	while (*src) {
 		memcpy(mem, *src, (*src)->bLength);
 		*tmp = mem;
 		tmp++;
 		mem += (*src)->bLength;
 		src++;
--
 	while (!READ_COND) {
 		spin_unlock_irqrestore(&hidg->spinlock, flags);
 		if (file->f_flags & O_NONBLOCK)
@@ -153,6 +158,12 @@ static ssize_t f_hidg_read(struct file *
 			return -ERESTARTSYS;
 
--
-	while (!WRITE_COND) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (!WRITE_COND) {
 		mutex_unlock(&hidg->lock);
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
@@ -209,6 +225,12 @@ static ssize_t f_hidg_write(struct file
 			return -ERESTARTSYS;
--
 	while (size > 0) {
 		page = vmalloc_to_page((void *)addr);
 		if ((ret = vm_insert_page(vma, start, page)) < 0)
@@ -450,6 +455,12 @@ uvc_queue_mmap(struct uvc_video_queue *q
 		start += PAGE_SIZE;
 		addr += PAGE_SIZE;
--
-	while (!list_empty(&queue->irqqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&queue->irqqueue)) {
 		buf = list_first_entry(&queue->irqqueue, struct uvc_buffer,
 				       queue);
 		list_del(&buf->queue);
 		buf->state = UVC_BUF_STATE_ERROR;
 		wake_up(&buf->wait);
--
 	while (!list_empty(head)) {
 		req = list_entry(head->next, struct usb_request, list);
 		list_del(&req->list);
 		gs_free_req(ep, req);
 		if (allocated)
 			(*allocated)--;
--
-	while (likely(!list_empty(&dev->rx_reqs))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!list_empty(&dev->rx_reqs))) {
 		int error;
 
 		req = container_of(dev->rx_reqs.next,
@@ -535,6 +540,12 @@ setup_rx_reqs(struct printer_dev *dev)
 		} else {
--
-	while ((current_rx_bytes || likely(!list_empty(&dev->rx_buffers)))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((current_rx_bytes || likely(!list_empty(&dev->rx_buffers)))
 			&& len) {
 		if (current_rx_bytes == 0) {
 			req = container_of(dev->rx_buffers.next,
@@ -657,6 +673,12 @@ printer_read(struct file *fd, char __use
 			current_rx_buf = NULL;
--
-	while (likely(!list_empty(&dev->tx_reqs)) && len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (likely(!list_empty(&dev->tx_reqs)) && len) {
 
 		if (len > USB_BUFSIZE)
 			size = USB_BUFSIZE;
@@ -770,6 +797,12 @@ printer_write(struct file *fd, const cha
 
--
-	while (likely(!(list_empty(&dev->rx_buffers)))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!(list_empty(&dev->rx_buffers)))) {
 		req = container_of(dev->rx_buffers.next, struct usb_request,
 				list);
 		list_del_init(&req->list);
 		list_add(&req->list, &dev->rx_reqs);
+		if (_cur < timeout) {
--
-	while (likely(!(list_empty(&dev->rx_reqs_active)))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!(list_empty(&dev->rx_reqs_active)))) {
 		req = container_of(dev->rx_buffers.next, struct usb_request,
 				list);
 		list_del_init(&req->list);
 		list_add(&req->list, &dev->rx_reqs);
+		if (_cur < timeout) {
--
-	while (likely(!(list_empty(&dev->tx_reqs_active)))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!(list_empty(&dev->tx_reqs_active)))) {
 		req = container_of(dev->tx_reqs_active.next,
 				struct usb_request, list);
 		list_del_init(&req->list);
 		list_add(&req->list, &dev->tx_reqs);
+		if (_cur < timeout) {
--
-	while (!list_empty(&dev->tx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->tx_reqs)) {
 		req = container_of(dev->tx_reqs.next, struct usb_request,
 				list);
 		list_del(&req->list);
 		printer_req_free(dev->in_ep, req);
+		if (_cur < timeout) {
--
-	while (!list_empty(&dev->rx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_reqs)) {
 		req = container_of(dev->rx_reqs.next,
 				struct usb_request, list);
 		list_del(&req->list);
 		printer_req_free(dev->out_ep, req);
+		if (_cur < timeout) {
--
-	while (!list_empty(&dev->rx_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_buffers)) {
 		req = container_of(dev->rx_buffers.next,
 				struct usb_request, list);
 		list_del(&req->list);
 		printer_req_free(dev->out_ep, req);
+		if (_cur < timeout) {
--
-			while (!list_empty(&dev->tx_reqs)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&dev->tx_reqs)) {
 				req = container_of(dev->tx_reqs.next,
 						struct usb_request, list);
 				list_del(&req->list);
 				printer_req_free(dev->in_ep, req);
+				if (_cur < timeout) {
--
-			while (!list_empty(&dev->rx_reqs)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&dev->rx_reqs)) {
 				req = container_of(dev->rx_reqs.next,
 						struct usb_request, list);
 				list_del(&req->list);
 				printer_req_free(dev->out_ep, req);
+				if (_cur < timeout) {
--
 	while (count >= 4) {
 		/* NOTE be careful if you try to align these. fifo lines
 		 * should normally be full (4 bytes) and successive partial
@@ -488,6 +493,12 @@ write_fifo (struct net2280_ep *ep, struc
 		writel (tmp, &regs->ep_data);
 		buf += 4;
--
 	while (count >= 4) {
 		tmp = readl (&regs->ep_data);
 		cpu_to_le32s (&tmp);
 		put_unaligned (tmp, (u32 *)buf);
 		buf += 4;
 		count -= 4;
--
-	while (!list_empty (&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty (&ep->queue)) {
 		req = list_entry (ep->queue.next,
 				struct net2280_request,
 				queue);
 		done (ep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
--
-		while (!list_empty (&ep->queue)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty (&ep->queue)) {
 			req = list_entry (ep->queue.next,
 					struct net2280_request, queue);
 			done (ep, req, (req->req.actual == req->req.length)
 						? 0 : -EPROTO);
+			if (_cur < timeout) {
--
 			while (readl(&udc->op_regs->epprime) & bit_pos) {
 				if (loops == 0) {
 					retval = -ETIME;
@@ -302,12 +307,23 @@ static int queue_dtd(struct mv_ep *ep, s
 				}
 				udelay(LOOPS_USEC);
--
 		while (readsafe == 0) {
 			if (loops == 0) {
 				retval = -ETIME;
@@ -334,6 +350,12 @@ static int queue_dtd(struct mv_ep *ep, s
 			}
 			loops--;
--
 				while (curr_dtd->size_ioc_sts
 					& DTD_STATUS_ACTIVE) {
 					if (loops == 0) {
@@ -356,6 +383,12 @@ static int queue_dtd(struct mv_ep *ep, s
 					}
 					loops--;
--
-			while ((curr_dtd_ptr != req->head->td_dma)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((curr_dtd_ptr != req->head->td_dma)) {
 				curr_dtd_ptr = dqh->curr_dtd_ptr;
 				if (loops == 0) {
 					dev_err(&udc->dev->dev,
@@ -414,6 +452,12 @@ static int queue_dtd(struct mv_ep *ep, s
 						&udc->op_regs->epprime);
--
-		while (readl(&udc->op_regs->epflush)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (readl(&udc->op_regs->epflush)) {
 			/*
 			 * ENDPTFLUSH bit should be cleared to indicate this
 			 * operation is complete
@@ -758,6 +807,12 @@ static void mv_ep_fifo_flush(struct usb_
 			}
--
 	} while (readl(&udc->op_regs->epstatus) & bit_pos);
@@ -1091,7 +1146,12 @@ static int udc_reset(struct mv_udc *udc)
 
 	/* wait for reset to complete */
 	loops = LOOPS(RESET_TIMEOUT);
-	while (readl(&udc->op_regs->usbcmd) & USBCMD_CTRL_RESET) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (readl(&udc->op_regs->usbcmd) & USBCMD_CTRL_RESET) {
 		if (loops == 0) {
 			dev_err(&udc->dev->dev,
 				"Wait for RESET completed TIMEOUT\n");
@@ -1099,6 +1159,12 @@ static int udc_reset(struct mv_udc *udc)
 		}
--
 	while (!list_empty(&ep->queue)) {
 		struct mv_req *req = NULL;
 		req = list_entry(ep->queue.next, struct mv_req, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (*sp) {
 		s = *sp;
 		language = cpu_to_le16(s->language);
@@ -800,6 +805,12 @@ static void collect_langs(struct usb_gad
 		*tmp++ = language;
 repeat:
--
 	while (*sp) {
 		s = *sp++;
 		if (s->language != language)
@@ -820,6 +836,12 @@ static int lookup_string(
 		value = usb_gadget_get_string(s, id, buf);
 		if (value > 0)
--
-	while (!list_empty(&cdev->configs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cdev->configs)) {
 		struct usb_configuration	*c;
 
 		c = list_first_entry(&cdev->configs,
 				struct usb_configuration, list);
-		while (!list_empty(&c->functions)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&c->functions)) {
 			struct usb_function		*f;
 
 			f = list_first_entry(&c->functions,
@@ -1345,6 +1377,12 @@ composite_unbind(struct usb_gadget *gadg
 				f->unbind(c, f);
--
 	while (td && !(td->status & AMD_BIT(UDC_DMA_IN_STS_L))) {
 		td = phys_to_virt(td->next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (td && !(td->status & AMD_BIT(UDC_DMA_IN_STS_L))) {
 		td = phys_to_virt(td->next);
 		/* received number bytes */
@@ -922,6 +938,12 @@ static u32 udc_get_ppbdu_rxbytes(struct
 			count += AMD_GETBITS(td->status,
 				UDC_DMA_OUT_STS_RXBYTES);
--
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next,
 			struct udc_request,
 			queue);
 		complete_req(ep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
--
 	while (!list_empty(&ep->queue)) {
 		struct qe_req *req = NULL;
 		req = list_entry(ep->queue.next, struct qe_req, queue);
 
 		done(ep, req, status);
+		if (_cur < timeout) {
--
 	while (!(bdstatus & R_E) && !(bdstatus & BD_LENGTH_MASK) && !stop) {
 		bdstatus = R_E | R_I | (bdstatus & R_W);
 		out_be32((u32 __iomem *)bd, bdstatus);
@@ -752,6 +768,12 @@ static void recycle_rxbds(struct qe_ep *
 		bdstatus = in_be32((u32 __iomem *)bd);
 		if (stopatnext && (bd == nextbd))
--
 	while (!(bdstatus & R_E) && length) {
 		if ((bdstatus & R_F) && (bdstatus & R_L)
 			&& !(bdstatus & R_ERROR)) {
@@ -887,6 +914,12 @@ static int qe_ep0_rx(struct qe_udc *udc)
 		bdstatus = in_be32((u32 __iomem *)bd);
 		length = bdstatus & BD_LENGTH_MASK;
--
 	while (!(bdstatus & T_R) && (bdstatus & ~T_W)) {
 		pframe = ep->txframe;
 
@@ -1399,6 +1437,12 @@ static int qe_ep0_txconf(struct qe_ep *e
 
 		bd = ep->c_txbd;
--
 	while (!(bdstatus & T_R) && (bdstatus & ~T_W)) {
 		pframe = ep->txframe;
 		if (bdstatus & DEVICE_T_ERROR) {
@@ -1454,6 +1503,12 @@ static int qe_ep_txconf(struct qe_ep *ep
 		ep_txframe_handle(ep);
 		bd = ep->c_txbd;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		u32 grstctl = readl(hsotg->regs + S3C_GRSTCTL);
 
 		if (timeout-- < 0) {
@@ -2564,6 +2569,12 @@ static int s3c_hsotg_corereset(struct s3
 			continue;
--
 	while ((epctrl & USBA_TX_PK_RDY) && !(epstatus & USBA_TX_PK_RDY)) {
 		DBG(DBG_BUS, "%s: TX PK ready\n", ep->ep.name);
 
@@ -1593,6 +1598,12 @@ static void usba_ep_irq(struct usba_udc
 
 		epstatus = usba_ep_readl(ep, STA);
--
 	while (!list_empty (&ep->queue)) {
 		struct dummy_request	*req;
 
@@ -254,6 +259,12 @@ static void nuke (struct dummy *dum, str
 		spin_unlock (&dum->lock);
 		req->req.complete (&ep->ep, &req->req);
--
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct fusb300_request, queue);
 		spin_lock_irqsave(&ep->fusb300->lock, flags);
 		done(ep, req, -ECONNRESET);
 		spin_unlock_irqrestore(&ep->fusb300->lock, flags);
+		if (_cur < timeout) {
--
 	while (!usb_trylock_device(udev)) {
 
 		/* If we can't acquire the lock after waiting one second,
@@ -593,6 +598,12 @@ int usb_lock_device_for_reset(struct usb
 		if (iface && (iface->condition == USB_INTERFACE_UNBINDING ||
 				iface->condition == USB_INTERFACE_UNBOUND))
--
-	while (size >= sizeof(struct usb_descriptor_header)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size >= sizeof(struct usb_descriptor_header)) {
 		header = (struct usb_descriptor_header *)buffer;
 
 		if (header->bLength < 2) {
@@ -647,6 +663,12 @@ int __usb_get_extra_descriptor(char *buf
 
--
 		while (++i < n) {
 			intf = udev->actconfig->interface[i];
 			usb_resume_interface(udev, intf, msg, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (leng && start <= end) {
 		start += sprintf(start, " %02x", *ptr);
 		ptr++; leng--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (size > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size > 0) {
 		retval = usb_parse_interface(ddev, cfgno, config,
 		    buffer, size, inums, nalts);
 		if (retval < 0)
@@ -593,6 +598,12 @@ static int usb_parse_configuration(struc
 
--
-	while (!list_empty(&anchor->urb_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
 		/* we must make sure the URB isn't freed before we kill it*/
@@ -695,6 +700,12 @@ void usb_kill_anchored_urbs(struct usb_a
 		usb_kill_urb(victim);
--
-	while (!list_empty(&anchor->urb_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
 		/* we must make sure the URB isn't freed before we kill it*/
@@ -728,6 +744,12 @@ void usb_poison_anchored_urbs(struct usb
 		usb_poison_urb(victim);
--
 	while ((victim = usb_get_from_anchor(anchor)) != NULL) {
 		usb_unlink_urb(victim);
 		usb_put_urb(victim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&anchor->urb_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
 		__usb_unanchor_urb(victim, anchor);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (!list_empty (&ep->urb_list)) {
 		spin_lock_irq(&hcd_urb_list_lock);
 
@@ -1687,6 +1692,12 @@ rescan:
 			usb_kill_urb (urb);
 			usb_put_urb (urb);
--
 	while (i < entries && !io->status) {
 		int retval;
 
@@ -549,6 +554,12 @@ void usb_sg_wait(struct usb_sg_request *
 		spin_lock_irq(&io->lock);
 		if (retval && (io->status == 0 || io->status == -ECONNRESET))
--
 	while (!list_empty(list)) {
 		as = list_entry(list->next, struct async, asynclist);
 		list_del_init(&as->asynclist);
@@ -451,6 +456,12 @@ static void destroy_async(struct dev_sta
 		usb_kill_urb(urb);
 		usb_put_urb(urb);
--
 	while (as) {
 		free_async(as);
 		as = async_getcompleted(ps);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&udev->filelist)) {
 		ps = list_entry(udev->filelist.next, struct dev_state, list);
 		destroy_all_async(ps);
@@ -2038,6 +2065,12 @@ static void usbdev_remove(struct usb_dev
 			kill_pid_info_as_cred(ps->discsignr, &sinfo,
 					ps->disc_pid, ps->cred, ps->secid);
--
 	while (pos < len) {
 		int tmp;
 		u32 index;
@@ -507,6 +512,12 @@ static ssize_t cxacru_sysfs_store_adsl_c
 			atm_info(instance->usbatm, "config%s\n", log);
 			num = 0;
--
 		while (l--) {
 			offd = le32_to_cpu(buf[offb++]);
 			if (offd >= size) {
@@ -720,6 +736,12 @@ static int cxacru_cm_get_array(struct cx
 				goto cleanup;
 			}
--
 	while ((urb = usbatm_pop_urb(&instance->rx_channel))) {
 		vdbg("%s: processing urb 0x%p", __func__, urb);
 
@@ -574,6 +579,12 @@ static void usbatm_rx_process(unsigned l
 
 		if (usbatm_submit_urb(urb))
--
 	while (size > 3) {
 		u8 len = FW_GET_BYTE(pfw);
 		u16 add = get_unaligned_le16(pfw + 1);
@@ -664,6 +669,12 @@ static void uea_upload_pre_firmware(cons
 			goto err;
 		}
--
 	while (!kthread_should_stop()) {
 		if (ret < 0 || sc->reset)
 			ret = uea_start_reset(sc);
@@ -1917,6 +1933,12 @@ static int uea_kthread(void *data)
 		if (ret != -EAGAIN)
 			uea_wait(sc, 0, msecs_to_jiffies(1000));
--
-	while (atomic_read(&rpipe->segs_available) > 0
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (atomic_read(&rpipe->segs_available) > 0
 	      && !list_empty(&rpipe->seg_list)) {
 		seg = list_entry(rpipe->seg_list.next, struct wa_seg,
 				 list_node);
@@ -829,6 +834,12 @@ static void wa_xfer_delayed_run(struct w
 			spin_unlock_irqrestore(&xfer->lock, flags);
--
 	while (size) {
 		if (size < sizeof(*notif_hdr)) {
 			missing = sizeof(*notif_hdr) - size;
@@ -146,6 +151,12 @@ static void wa_notif_dispatch(struct wor
 				(size_t)notif_hdr->bLength);
 			break;
--
 	while (!list_empty(&dep->request_list)) {
 		req = next_request(&dep->request_list);
 
 		dwc3_gadget_giveback(dep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (left > 0) {
 		union dwc3_event event;
 
@@ -1914,6 +1930,12 @@ static irqreturn_t dwc3_process_event_bu
 		left -= 4;
 
--
 	while (left > 3) {
 		/* only write multiples of 4 bytes, so there might */
 		/* be as many as 3 bytes left (at the end). */
@@ -480,6 +485,12 @@ hwicap_write(struct file *file, const ch
 		}
 		written += len;
--
-	while (buffer_icap_busy(base_address)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (buffer_icap_busy(base_address)) {
 		retries++;
 		if (retries > XHI_MAX_RETRIES)
 			return -EBUSY;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (buffer_icap_busy(base_address)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (buffer_icap_busy(base_address)) {
 		retries++;
 		if (retries > XHI_MAX_RETRIES)
 			return -EBUSY;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (remaining_words > 0) {
 		/*
 		 * Wait until we have some data in the fifo.
 		 */
-		while (write_fifo_vacancy == 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (write_fifo_vacancy == 0) {
 			write_fifo_vacancy =
 				fifo_icap_write_fifo_vacancy(drvdata);
 			retries++;
 			if (retries > XHI_MAX_RETRIES)
 				return -EIO;
--
-		while ((write_fifo_vacancy != 0) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((write_fifo_vacancy != 0) &&
 				(remaining_words > 0)) {
 			fifo_icap_fifo_write(drvdata, *frame_buffer);
 
 			remaining_words--;
 			write_fifo_vacancy--;
--
 	while (remaining_words > 0) {
 		words_to_read = remaining_words;
 		/* The hardware has a limit on the number of words
@@ -318,14 +356,30 @@ int fifo_icap_get_configuration(struct h
 		fifo_icap_set_read_size(drvdata, words_to_read);
 		fifo_icap_start_readback(drvdata);
--
 		while (words_to_read > 0) {
 			/* Wait until we have some data in the fifo. */
-			while (read_fifo_occupancy == 0) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (read_fifo_occupancy == 0) {
 				read_fifo_occupancy =
 					fifo_icap_read_fifo_occupancy(drvdata);
 				retries++;
 				if (retries > XHI_MAX_RETRIES)
 					return -EIO;
--
 			while (read_fifo_occupancy != 0) {
 				*data++ = fifo_icap_fifo_read(drvdata);
 				read_fifo_occupancy--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (!(c1 & 0x80) && time_before(jiffies, timeout)) {
 		msleep(10);
 		/*
@@ -393,6 +398,12 @@ static int erase_block(int nBlock)
 		 */
 		c1 = *(volatile unsigned char *) (pWritePtr);
--
-	while (kfifo_out_locked(&sonypi_device.input_fifo, (unsigned char *)&kp,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (kfifo_out_locked(&sonypi_device.input_fifo, (unsigned char *)&kp,
 			 sizeof(kp), &sonypi_device.input_fifo_lock)
 			== sizeof(kp)) {
 		msleep(10);
 		input_report_key(kp.dev, kp.key, 0);
 		input_sync(kp.dev);
--
-	while (ret < count &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ret < count &&
 	       (kfifo_out_locked(&sonypi_device.fifo, &c, sizeof(c),
 				 &sonypi_device.fifo_lock) == sizeof(c))) {
 		if (put_user(c, buf++))
 			return -EFAULT;
 		ret++;
--
-	while (check_ioport && check->port1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (check_ioport && check->port1) {
 		if (!request_region(check->port1,
 				   sonypi_device.region_size,
 				   "Sony Programmable I/O Device Check")) {
@@ -1249,9 +1276,20 @@ static int __devinit sonypi_setup_ioport
 		}
--
-	while (ioport_list->port1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioport_list->port1) {
 
 		if (request_region(ioport_list->port1,
 				   sonypi_device.region_size,
@@ -1261,6 +1299,12 @@ static int __devinit sonypi_setup_ioport
 			return 0;
--
-	while (irq_list->irq) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (irq_list->irq) {
 
 		if (!request_irq(irq_list->irq, sonypi_irq,
 				 IRQF_SHARED, "sonypi", sonypi_irq)) {
@@ -1278,6 +1327,12 @@ static int __devinit sonypi_setup_irq(st
 			return 0;
--
 	while ( (dev = pci_get_class(PCI_CLASS_OTHERS << 16, dev))) {
 
 		if (!pci_match_id(applicom_pci_tbl, dev))
@@ -239,6 +244,12 @@ static int __init applicom_init(void)
 		writeb(0x40, apbs[boardno - 1].RamIO + RAM_IT_FROM_PC);
 
--
 	while (readb(apbs[IndexCard].RamIO + DATA_FROM_PC_READY) != 0) {
 		Dummy = readb(apbs[IndexCard].RamIO + VERS);
 		/* It's busy. Sleep. */
@@ -446,6 +462,12 @@ static ssize_t ac_write(struct file *fil
 		}
 		spin_lock_irqsave(&apbs[IndexCard].mutex, flags);
--
 	while(1) {
 		/* Stick ourself on the wait queue */
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -612,6 +639,12 @@ static ssize_t ac_read (struct file *fil
 			printk(KERN_DEBUG "Looping in ac_read. loopcount %d\n", loopcount);
 		}
--
 	while (status < 0) {
 		DECLARE_WAITQUEUE(wait, current);
 
@@ -210,6 +215,12 @@ scdrv_read(struct file *file, char __use
 
 		spin_lock_irqsave(&sd->sd_rlock, flags);
--
 	while (status <= 0) {
 		DECLARE_WAITQUEUE(wait, current);
 
@@ -306,6 +322,12 @@ scdrv_write(struct file *file, const cha
 
 		spin_lock_irqsave(&sd->sd_wlock, flags);
--
 		while (i < count && dtlk_readable()) {
 			ch = dtlk_read_lpc();
 			/*        printk("dtlk_read() reads 0x%02x\n", ch); */
 			if (put_user(ch, buf++))
 				return -EFAULT;
 			i++;
--
 	while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (i < count && !get_user(ch, buf) &&
 		       (ch == DTLK_CLEAR || dtlk_writeable())) {
 			dtlk_write_tts(ch);
@@ -207,6 +223,12 @@ static ssize_t dtlk_write(struct file *f
 						break;
 			}
--
 	while (*t != '\r') {
 		status.rom_version[i] = *t;
 		if (i < sizeof(status.rom_version) - 1)
 			i++;
 		t++;
+		if (_cur < timeout) {
--
 	while (count > 0) { \
 		m = min_t(unsigned long, count, maxio); \
 		for (i = 0; i < m; i++) { \
@@ -71,6 +76,12 @@
 		} \
 		count -= m; \
--
 	while (1) {
 		hv_err = sun4v_rng_data_read(data_ra, &ticks);
 		if (hv_err == HV_EOK)
@@ -195,6 +200,12 @@ static int n2rng_generic_read_data(unsig
 			udelay(10000);
 		} else
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		hv_err = n2rng_read_diag_data_one(np, unit,
 						  data_ra, data_len,
 						  &ticks);
@@ -242,6 +258,12 @@ static int n2rng_generic_read_diag_data(
 			return -EIO;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		hv_err = n2rng_write_ctl_one(np, unit, state, control_ra,
 					     np->wd_timeo, &ticks);
 		if (hv_err == HV_EOK)
@@ -270,6 +297,12 @@ static int n2rng_generic_write_control(s
 			udelay(1);
--
 	while (size) {
 		if (mutex_lock_interruptible(&rng_mutex)) {
 			err = -ERESTARTSYS;
@@ -161,6 +166,12 @@ static ssize_t rng_dev_read(struct file
 			err = -ERESTARTSYS;
 			goto out;
--
 	while (*link) {
 		parent = *link;
 		x = rb_entry(parent, struct mmtimer, list);
@@ -276,6 +281,12 @@ static void mmtimer_add_list(struct mmti
 			link = &(*link)->rb_left;
 		else
--
-	while (!mmtimer_setup(x->cpu, COMPARATOR, expires,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!mmtimer_setup(x->cpu, COMPARATOR, expires,
 				&set_completion_time)) {
 		int to;
 
@@ -344,6 +360,12 @@ restart:
 			kfree(x);
--
 	while (nbytes--) {
 		w = rol32(*bytes++, input_rotate & 31);
 		i = (i - 1) & wordmask;
@@ -522,6 +527,12 @@ static void __mix_pool_bytes(struct entr
 		 * input bits across the pool evenly.
 		 */
--
-	while (nbytes--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nbytes--) {
 		w = rol32(*bytes++, input_rotate & 31) ^ f->pool[i & 3] ^
 			f->pool[(i + 1) & 3];
 		f->pool[i & 3] = (w >> 3) ^ twist_table[w & 7];
 		input_rotate += (i++ & 3) ? 7 : 14;
+		if (_cur < timeout) {
--
 	while (nbytes) {
 		extract_buf(r, tmp);
 
@@ -1007,6 +1034,12 @@ static ssize_t extract_entropy(struct en
 		nbytes -= i;
 		buf += i;
--
 	while (count > 0) {
 		bytes = min(count, sizeof(buf));
 		if (copy_from_user(&buf, p, bytes))
@@ -1268,6 +1306,12 @@ write_pool(struct entropy_store *r, cons
 
 		mix_pool_bytes(r, buf, bytes, NULL);
--
 	while (op_struct_list) {
 		struct op_struct *toFree = op_struct_list;
 		op_struct_list = op_struct_list->next;
 		kfree(toFree);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (link->open) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+ 		unsigned long long timeout;
+ 		timeout = rdstcll(start) + delta;
+ 		while (link->open) {
 		DEBUGP(3, dev, KERN_INFO MODULE_NAME ": delaying release "
 		       "until process has terminated\n");
  		wait_event(dev->devq, (link->open == 0));
+ 		if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while (link->open) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (link->open) {
 		printk(KERN_INFO MODULE_NAME ": delaying release until "
 		       "process has terminated\n");
 		/* note: don't interrupt us:
@@ -1733,6 +1738,12 @@ static void cmm_cm4000_release(struct pc
 		 * the devices _first_ !
--
 	while (read_reg(info, (unsigned char)(channel+STAR)) & BIT2) {
 		udelay(1);
 		if (i++ == 1000)
 			return false;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while((action = bh_action(info)) != 0) {
 
 		/* Process work item */
@@ -797,6 +813,12 @@ static void bh_handler(struct work_struc
 			printk("Unknown work item ID=%08X!\n", action);
 			break;
--
 	while (fifo_count) {
 		data   = read_reg(info, CHA + RXFIFO);
 		status = read_reg(info, CHA + RXFIFO);
@@ -936,6 +963,12 @@ static void rx_ready_async(MGSLPC_INFO *
 				flag = TTY_FRAME;
 		}
--
 	while (info->tx_count && fifo_count) {
 		c = min(2, min_t(int, fifo_count, min(info->tx_count, TXBUFSIZE - info->tx_get)));
 
@@ -1024,6 +1062,12 @@ static void tx_ready(MGSLPC_INFO *info,
 		info->tx_count -= c;
 		info->tx_get = (info->tx_get + c) & (TXBUFSIZE - 1);
--
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while(info) {
 		if (info == remove_info) {
 			if (last)
@@ -2755,6 +2815,12 @@ static void mgslpc_remove_device(MGSLPC_
 		}
 		last = info;
--
 	while(end_time-- && !info->irq_occurred) {
 		msleep_interruptible(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-	while(count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(count) {
 		if (count > 16)
 			linecount = 16;
 		else
@@ -3836,6 +3918,12 @@ static void trace_block(MGSLPC_INFO *inf
 
--
 	while (lp >= 0) {
 		if ((button_callback_list [lp].callback) == callback) {
 			button_callback_list [lp].callback = NULL;
@@ -95,6 +100,12 @@ int button_del_callback (void (*callback
 			return 0;
 		};
--
 	while ((str != NULL) && (*str != '\0')) {
 		if (strncmp(str, "off", 3) == 0)
 			apm_disabled = 1;
@@ -707,6 +712,12 @@ static int __init apm_setup(char *str)
 		str = strchr(str, ',');
 		if (str != NULL)
--
 	while (!(status < 0)) {
 		spin_unlock_irqrestore(&sd->sd_rlock, flags);
 		scdrv_dispatch_event(sd->sd_rb, len);
@@ -252,6 +257,12 @@ scdrv_event(unsigned long dummy)
 		spin_lock_irqsave(&sd->sd_rlock, flags);
 		status = ia64_sn_irtr_recv(sd->sd_nasid, sd->sd_subch,
--
 	while (uCount-- != 0) {
 		spin_lock_irqsave(&dsp_lock, flags);
 		val = InWordDsp(DSP_MsaDataDSISHigh);
@@ -506,6 +511,12 @@ int dsp3780I_ReadDStore(unsigned short u
 			uCount, val);
 
--
 	while (uCount-- != 0) {
 		spin_lock_irqsave(&dsp_lock, flags);
 		val = InWordDsp(DSP_ReadAndClear);
@@ -548,6 +564,12 @@ int dsp3780I_ReadAndClearDStore(unsigned
 			uCount, val);
 
--
 	while (uCount-- != 0) {
 		unsigned short val;
 		if(get_user(val, pusBuffer++))
@@ -590,6 +617,12 @@ int dsp3780I_WriteDStore(unsigned short
 			uCount, val);
 
--
 	while (uCount-- != 0) {
 		unsigned short val_lo, val_hi;
 		spin_lock_irqsave(&dsp_lock, flags);
@@ -639,6 +677,12 @@ int dsp3780I_ReadIStore(unsigned short u
 
 		PaceMsaAccess(usDspBaseIO);
--
 	while (uCount-- != 0) {
 		unsigned short val_lo, val_hi;
 		if(get_user(val_lo, pusBuffer++))
@@ -688,6 +737,12 @@ int dsp3780I_WriteIStore(unsigned short
 
 		PaceMsaAccess(usDspBaseIO);
--
 		while (!data_to_read) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			spin_unlock(&ipmi_read_lock);
 			schedule();
 			spin_lock(&ipmi_read_lock);
+			if (_cur < timeout) {
--
 	while (atomic_read(&dummy_count) > 0) {
 		ipmi_poll_interface(user);
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (rcvrs) {
 		rcvr = rcvrs;
 		rcvrs = rcvr->next;
 		kfree(rcvr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (user->gets_events && !list_empty(&intf->waiting_events)) {
 		list_for_each_entry_safe(msg, msg2, &intf->waiting_events, link)
 			list_move_tail(&msg->link, &msgs);
@@ -1218,6 +1234,12 @@ int ipmi_set_gets_events(ipmi_user_t use
 
 		spin_lock_irqsave(&intf->events_lock, flags);
--
 	while (rcvrs) {
 		rcvr = rcvrs;
 		rcvrs = rcvr->next;
 		kfree(rcvr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (smi->proc_entries) {
 		entry = smi->proc_entries;
 		smi->proc_entries = entry->next;
@@ -2097,6 +2135,12 @@ static void remove_proc_entries(ipmi_smi
 		remove_proc_entry(entry->name, smi->proc_dir);
 		kfree(entry->name);
--
 		while (*p) {
 			int size = strlen(p);
 
@@ -4417,6 +4466,12 @@ static void send_panic_events(char *str)
 				       intf->channels[0].address,
 				       intf->channels[0].lun,
--
 	while (bn) {
 		ret = bsr_add_node(bn);
 		if (ret) {
@@ -288,6 +293,12 @@ static int bsr_create_devs(struct device
 			return ret;
 		}
--
 		while (--i >= 0) {
 			mutex_destroy(&smd_pkt_devp[i]->ch_lock);
 			mutex_destroy(&smd_pkt_devp[i]->rx_lock);
@@ -432,6 +437,12 @@ clean_cdevs:
 			kfree(smd_pkt_devp[i]);
 			device_destroy(smd_pkt_classp,
--
 	while (size < count &&
 	       wait_for_stat(chip,
 			     TPM_STS_DATA_AVAIL | TPM_STS_VALID,
@@ -247,6 +252,12 @@ static int recv_data(struct tpm_chip *ch
 			buf[size++] = ioread8(chip->vendor.iobase +
 					      TPM_DATA_FIFO(chip->vendor.
--
 	while (count < len - 1) {
 		burstcnt = get_burstcount(chip);
 		for (; burstcnt > 0 && count < len - 1; burstcnt--) {
@@ -340,6 +356,12 @@ static int tpm_tis_send_data(struct tpm_
 			rc = -EIO;
 			goto out_err;
--
-	while (cursor < to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cursor < to) {
 		if (!devmem_is_allowed(pfn)) {
 			printk(KERN_INFO
 		"Program %s tried to access /dev/mem between %Lx->%Lx.\n",
@@ -73,6 +78,12 @@ static inline int range_is_allowed(unsig
 		}
--
 	while (count > 0) {
 		unsigned long remaining;
 
@@ -142,6 +158,12 @@ static ssize_t read_mem(struct file *fil
 		p += sz;
 		count -= sz;
--
 	while (count) {
 		pfn = *ppos / PAGE_SIZE;
 		if (pfn > saved_max_pfn)
@@ -383,6 +410,12 @@ static ssize_t read_oldmem(struct file *
 		*ppos += csize;
 		read += csize;
--
 		while (low_count > 0) {
 			sz = size_inside_page(p, low_count);
 
@@ -436,6 +474,12 @@ static ssize_t read_kmem(struct file *fi
 			read += sz;
 			low_count -= sz;
--
 	while (count-- > 0 && i < 65536) {
 		if (__put_user(inb(i), tmp) < 0)
 			return -EFAULT;
 		i++;
 		tmp++;
+		if (_cur < timeout) {
--
 	while (j < (pg_start + mem->page_count)) {
 		if (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (j < (io_pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (j < (io_pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count)) {
 		if (!PGE_EMPTY(agp_bridge, RD_GATT(j))) {
 			pr_debug("i460_insert_memory_small_io_page: GATT[%d]=0x%x is busy\n",
 				 j, RD_GATT(j));
 			return -EBUSY;
 		}
--
 	while (j < (pg_start + mem->page_count)) {
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = SVRWRKS_GET_GATT(addr);
 		if (!PGE_EMPTY(agp_bridge, readl(cur_gatt+GET_GATT_OFF(addr))))
 			return -EBUSY;
 		j++;
--
 	while (j < (io_pg_start + io_pg_count)) {
 		if (hp->gatt[j]) {
 			return -EBUSY;
 		}
 		j++;
+		if (_cur < timeout) {
--
 	while (j < (pg_start + mem->page_count)) {
 		if (!PGE_EMPTY(agp_bridge, readl(agp_bridge->gatt_table+j)))
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (j < (pg_start + mem->page_count)) {
 		if (table[j])
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (j < (io_pg_start + io_pg_count)) {
 		if (info->gatt[j])
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (j < (pg_start + mem->page_count)) {
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
 		if (!PGE_EMPTY(agp_bridge, readl(cur_gatt+GET_GATT_OFF(addr))))
 			return -EBUSY;
 		j++;
--
 		while (!cap_ptr) {
 			gfxcard = pci_get_class(PCI_CLASS_DISPLAY_VGA<<8, gfxcard);
 			if (!gfxcard) {
@@ -444,6 +460,12 @@ static int __devinit agp_amdk7_probe(str
 				return -ENODEV;
 			}
--
 	while (j < (pg_start + mem->page_count)) {
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
 		if (!PGE_EMPTY(agp_bridge,readl(cur_gatt+GET_GATT_OFF(addr))))
 			return -EBUSY;
 		j++;
--
 	while (curr != NULL) {
 		if (curr->my_pid == pid)
 			return curr;
 		curr = curr->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (controller != NULL) {
 		if (controller->pid == id)
 			return controller;
 		controller = controller->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (client) {
 		struct agp_file_private *priv;
 
@@ -353,6 +380,12 @@ static void agp_remove_all_clients(struc
 		}
 		client = client->next;
--
 	while (memory) {
 		temp = memory;
 		memory = memory->next;
 		agp_free_memory_wrap(temp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (clients != NULL) {
 		struct agp_file_private *priv;
 
@@ -418,6 +467,12 @@ static void agp_controller_make_current(
 			set_bit(AGP_FF_IS_CLIENT, &priv->access_flags);
 		}
--
 	while (clients != NULL) {
 		struct agp_file_private *priv;
 
@@ -440,6 +500,12 @@ static void agp_controller_release_curre
 			clear_bit(AGP_FF_IS_VALID, &priv->access_flags);
 
--
 	while (client != NULL) {
 		if (client->pid == id)
 			return client;
 		client = client->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (controller != NULL) {
 		if ((agp_find_client_in_controller(controller, id)) != NULL)
 			return controller;
 		controller = controller->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (buf) {
 		port->stats.bytes_discarded += buf->len - buf->offset;
 		if (add_inbuf(port->in_vq, buf) < 0) {
@@ -422,6 +427,12 @@ static void discard_port_data(struct por
 		}
 		port->inbuf = NULL;
--
 	while ((buf = virtqueue_get_buf(port->out_vq, &len))) {
 		kfree(buf);
 		port->outvq_full = false;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((buf = virtqueue_get_buf(vq, &len))) {
 		spin_unlock(&portdev->c_ivq_lock);
 
@@ -1494,6 +1521,12 @@ static void control_work_handler(struct
 				 "Error adding buffer to queue\n");
 			free_buf(buf);
--
 		while (s > 0 && name[0]) {
 			name += strlen(name) + 1;
 			s--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (msg->len && len) {
 			*data++ = IN32(id, I2CRXTX);
 			msg->len--;
 			len--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 			while (msg->len && (IN32(id, I2CTFDR) < FIFO_SIZE)) {
 				OUT32(id, I2CRXTX, *data++);
 				msg->len--;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
--
 	while (id->msg->len && IN32(id, I2CTFDR) < FIFO_SIZE) {
 		OUT32(id, I2CRXTX, *(id->msg->buf));
 		(id->msg->len)--;
 		(id->msg->buf)++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (davinci_i2c_read_reg(dev, DAVINCI_I2C_STR_REG)
 	       & DAVINCI_I2C_STR_BB) {
 		if (to_cnt <= DAVINCI_I2C_MAX_TRIES) {
@@ -295,6 +300,12 @@ static int i2c_davinci_wait_bus_not_busy
 		}
 		if (allow_sleep)
--
 	while (!(status & SMSTA_XEN) && timeout--) {
 		msleep(1);
 		status = reg_read(smbus, REG_SMSTA);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (num--) {
 		const char *str = val & bits->mask ? bits->set : bits->unset;
 		if (str)
 			printk("%s ", str);
 		bits++;
+		if (_cur < timeout) {
--
 	while ((i > 0) && (readl(_IBMR(i2c)) & 0x1) == 0) {
 		unsigned long icr = readl(_ICR(i2c));
 
@@ -304,6 +320,12 @@ static void i2c_pxa_abort(struct pxa_i2c
 
 		mdelay(1);
--
 	while (timeout-- && readl(_ISR(i2c)) & (ISR_IBB | ISR_UB)) {
 		if ((readl(_ISR(i2c)) & ISR_SAD) != 0)
 			timeout += 4;
 
 		msleep(2);
 		show_state(i2c);
--
 	while (time_before(jiffies, timeout)) {
 		if (i2c_debug > 1)
 			dev_dbg(&i2c->adap.dev, "%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\n",
@@ -354,6 +392,12 @@ static int i2c_pxa_wait_master(struct px
 		}
 
--
 	while (time_before(jiffies, timeout)) {
 		if (i2c_debug > 1)
 			dev_dbg(&i2c->adap.dev, "%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\n",
@@ -402,6 +451,12 @@ static int i2c_pxa_wait_slave(struct pxa
 		}
 
--
 	while (timeout-- && readl(_ISR(i2c)) & (ISR_IBB | ISR_UB)) {
 		udelay(1000);
 		show_state(i2c);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (i2c->msg_num > 0 && --timeout) {
 		i2c_pxa_handler(0, i2c);
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((iface = scx200_acb_list) != NULL) {
 		scx200_acb_list = iface->next;
 		mutex_unlock(&scx200_acb_list_mutex);
@@ -610,6 +615,12 @@ static void __exit scx200_acb_cleanup(vo
 		scx200_cleanup_iface(iface);
 
--
 	while (readl(i2c->regs + MXS_I2C_QUEUESTAT)
 			& MXS_I2C_QUEUESTAT_RD_QUEUE_EMPTY) {
 			if (time_after(jiffies, timeout))
 				return -ETIMEDOUT;
 			cond_resched();
+			if (_cur < timeout) {
--
 	while (!iface->result) {
 		if (!wait_for_completion_timeout(&iface->complete,
 			adap->timeout)) {
 			iface->result = -1;
 			dev_err(&adap->dev, "master transfer timeout\n");
 		}
--
 	while (!iface->result) {
 		if (!wait_for_completion_timeout(&iface->complete,
 			adap->timeout)) {
 			iface->result = -1;
 			dev_err(&adap->dev, "smbus transfer timeout\n");
 		}
--
-	while (timeout > 0 &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (timeout > 0 &&
 			(ioread32(I2C_REG_STS(data)) & mstatus_active)) {
 		mdelay(1);
 		timeout--;
+		if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (timeout > 0 &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (timeout > 0 &&
 			(ioread32(I2C_REG_CTL(data)) & mcntrl_reset)) {
 		mdelay(1);
 		timeout--;
+		if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (timeout > 0 &&
 	       (ioread32(I2C_REG_STS(alg_data)) & mstatus_active)) {
 		/* may be called from interrupt context */
 		udelay(1);
 		timeout--;
+		if (_cur < timeout) {
--
-	while (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &
 						MV64XXX_I2C_REG_CONTROL_IFLG) {
 		status = readl(drv_data->reg_base + MV64XXX_I2C_REG_STATUS);
 		mv64xxx_i2c_fsm(drv_data, status);
 		mv64xxx_i2c_do_action(drv_data);
 		rc = IRQ_HANDLED;
--
 	while (i < (len - 1)) {
 		WR(adap, PSC_SMBTXRX, 0);
 		if (wait_for_rx_byte(adap, &buf[i]))
 			return -EIO;
 
 		i++;
--
 	while (i < (len-1)) {
 		data = buf[i];
 		WR(adap, PSC_SMBTXRX, data);
 		if (wait_ack(adap))
 			return -EIO;
 		i++;
--
 	while (cdiv > 255) {
 		ckdiv++;
 		cdiv = cdiv >> 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (length--) {
 		if (!length)	/* need to send Stop before reading last byte */
 			at91_twi_write(AT91_TWI_CR, AT91_TWI_STOP);
@@ -98,6 +114,12 @@ static int xfer_read(struct i2c_adapter
 			return -ETIMEDOUT;
 		}
--
@@ -448,12 +448,23 @@ static int stu300_wait_while_busy(struct
 	for (i = 0; i < BUSY_RELEASE_ATTEMPTS; i++) {
 		timeout = jiffies + STU300_TIMEOUT;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
--
 		while (!time_after(jiffies, timeout)) {
 			/* Is not busy? */
 			if ((stu300_r8(dev->virtbase + I2C_SR1) &
 			     I2C_SR1_BUSY_IND) == 0)
 				return 0;
 			msleep(1);
--
 	while ((iface->msgs_push < iface->msgs_num)
 	    && (i2c_rd16(iface, S6_I2C_STATUS) & (1 << S6_I2C_STATUS_TFNF))) {
 		struct i2c_msg *m = &iface->msgs[iface->msgs_push];
@@ -110,6 +115,12 @@ static void s6i2c_handle_interrupt(struc
 			iface->push = 0;
 			iface->msgs_push += 1;
--
 	while ((res = platform_get_resource(dev, IORESOURCE_IRQ, k))) {
 		for (n = res->start; hook && n <= res->end; n++) {
 			if (request_irq(n, sh_mobile_i2c_isr, 0,
@@ -552,6 +557,12 @@ static int sh_mobile_i2c_hook_irqs(struc
 			}
 		}
--
 	while (k >= 0) {
 		res = platform_get_resource(dev, IORESOURCE_IRQ, k);
 		for (n = res->start; n <= res->end; n++)
 			free_irq(n, dev);
 
 		k--;
--
 	while ((in_8(&iic->directcntl) & mask) != mask){
 		if (unlikely(time_after(jiffies, x)))
 			return -1;
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){
 		if (time_after(jiffies, x)){
 			DBG("%d: abort timeout, resetting...\n", dev->idx);
@@ -396,6 +412,12 @@ static void iic_abort_xfer(struct ibm_ii
 			return;
 		}
--
 	while (readb(i2c->base + MPC_I2C_SR) & CSR_MBB) {
 		if (signal_pending(current)) {
 			dev_dbg(i2c->dev, "Interrupted\n");
@@ -524,6 +529,12 @@ static int mpc_xfer(struct i2c_adapter *
 			return -EIO;
 		}
--
 		while ((adap_info->pch_data[i].pch_i2c_xfer_in_progress)) {
 			/* Wait until all channel transfers are completed */
 			msleep(20);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (timeout-- > 0) {
 		iicstat = readl(i2c->regs + S3C2410_IICSTAT);
 
@@ -477,6 +482,12 @@ static int s3c24xx_i2c_set_master(struct
 			return 0;
 
--
-	while (timeout-- > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (timeout-- > 0) {
 		if (((readl(i2c->regs + SWR) & I2CSTART) == I2CSTART) &&
 				((readl(i2c->regs + CSR) & I2CBUSY) == 0)) {
 			return 0;
 		}
 
--
 		while (!time_after(jiffies, timeout)) {
 			if ((readl(dev->virtbase + I2C_CR) &
 				(I2C_CR_FTX | I2C_CR_FRX)) == 0)
 					return 0;
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (len--) {
 		u16 data = i2c->tx_msg->buf[i2c->tx_pos++];
 		if ((xiic_tx_space(i2c) == 0) && (i2c->nmsgs == 1)) {
@@ -313,6 +318,12 @@ static void xiic_fill_tx_fifo(struct xii
 			dev_dbg(i2c->adap.dev.parent, "%s TX STOP\n", __func__);
 		}
--
 	while (err && tries--) {
 		mdelay(1);
 		err = xiic_bus_busy(i2c);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (tptr < num) {
 		pmsg = &msgs[tptr];
 		dev_dbg(&adap->dev, "R: %d T: %d\n", rptr, tptr);
@@ -346,6 +351,12 @@ static int cpm_i2c_xfer(struct i2c_adapt
 		if (pmsg->flags & I2C_M_RD)
 			rptr++;
--
 	while (tptr < num) {
 		/* Check for outstanding messages */
 		dev_dbg(&adap->dev, "test ready.\n");
@@ -386,6 +402,12 @@ static int cpm_i2c_xfer(struct i2c_adapt
 			if (ret)
 				goto out_err;
--
 	while (ioread16(dev->base + SMCR) & SMCR_BBSY) {
 		if (time_after(jiffies, timeout)) {
 			dev_warn(dev->dev, "timeout waiting for bus ready\n");
@@ -138,6 +143,12 @@ static int highlander_i2c_wait_for_bbsy(
 		}
 
--
-		while (!(omap_i2c_read_reg(dev, OMAP_I2C_SYSS_REG) &
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!(omap_i2c_read_reg(dev, OMAP_I2C_SYSS_REG) &
 			 SYSS_RESETDONE_MASK)) {
 			if (time_after(jiffies, timeout)) {
 				dev_warn(dev->dev, "timeout waiting "
@@ -343,6 +348,12 @@ static int omap_i2c_init(struct omap_i2c
 				return -ETIMEDOUT;
--
 	while (omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG) & OMAP_I2C_STAT_BB) {
 		if (time_after(jiffies, timeout)) {
 			dev_warn(dev->dev, "timeout waiting for bus ready\n");
 			return -ETIMEDOUT;
 		}
 		msleep(1);
--
 		while (con & OMAP_I2C_CON_STT) {
 			con = omap_i2c_read_reg(dev, OMAP_I2C_CON_REG);
 
@@ -576,6 +603,12 @@ static int omap_i2c_xfer_msg(struct i2c_
 				return -ETIMEDOUT;
 			}
--
-	while (--timeout && !(*stat & OMAP_I2C_STAT_XUDF)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (--timeout && !(*stat & OMAP_I2C_STAT_XUDF)) {
 		if (*stat & (OMAP_I2C_STAT_NACK | OMAP_I2C_STAT_AL)) {
 			omap_i2c_ack_stat(dev, *stat & (OMAP_I2C_STAT_XRDY |
 							OMAP_I2C_STAT_XDR));
@@ -787,6 +825,12 @@ static int errata_omap3_1p153(struct oma
 
--
 			while (num_bytes) {
 				num_bytes--;
 				w = omap_i2c_read_reg(dev, OMAP_I2C_DATA_REG);
@@ -893,6 +942,12 @@ complete:
 								" requested\n");
 					break;
--
 			while (num_bytes) {
 				num_bytes--;
 				w = 0;
@@ -942,6 +1002,12 @@ complete:
 					goto complete;
 
--
 	while (i2c_readl(i2c_dev, I2C_FIFO_CONTROL) &
 		(I2C_FIFO_CONTROL_TX_FLUSH | I2C_FIFO_CONTROL_RX_FLUSH)) {
 		if (time_after(jiffies, timeout)) {
@@ -212,6 +217,12 @@ static int tegra_i2c_flush_fifos(struct
 			return -ETIMEDOUT;
 		}
--
 	while (length--) {
 		if (!poll_status(I2C_STATUS_TFNF)) {
 			dev_dbg(&adap->dev, "Tx FIFO Not Full timeout\n");
@@ -77,6 +82,12 @@ static int xfer_read(struct i2c_adapter
 		/* read the data to buf */
 		*buf = (readl(I2C_DATACMD) & I2C_DATACMD_DAT_MASK);
--
 	while (length--) {
 		/* send addr */
 		writel(i2c_reg | I2C_DATACMD_WRITE, I2C_DATACMD);
@@ -110,6 +126,12 @@ static int xfer_write(struct i2c_adapter
 		/* read the data to buf */
 		i2c_reg++;
--
 	while (dw_readl(dev, DW_IC_STATUS) & DW_IC_STATUS_ACTIVITY) {
 		if (timeout <= 0) {
 			dev_warn(dev->dev, "timeout waiting for bus ready\n");
@@ -322,6 +327,12 @@ static int i2c_dw_wait_bus_not_busy(stru
 		}
 		timeout--;
--
 		while (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {
 			if (msgs[dev->msg_write_idx].flags & I2C_M_RD) {
 				dw_writel(dev, 0x100, DW_IC_DATA_CMD);
@@ -408,6 +424,12 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 			} else
 				dw_writel(dev, *buf++, DW_IC_DATA_CMD);
--
 	while (count > 0) {
 		retval = i2c_outb(i2c_adap, *temp);
 
@@ -401,6 +406,12 @@ static int sendbytes(struct i2c_adapter
 					retval);
 			return retval;
--
 	while (count > 0) {
 		inval = i2c_inb(i2c_adap);
 		if (inval >= 0) {
@@ -469,6 +485,12 @@ static int readbytes(struct i2c_adapter
 			if (inval < 0)
 				return inval;
--
 	while (!(status & I2C_PCF_BB) && --timeout) {
 		udelay(100); /* wait for 100 us */
 		status = get_pcf(adap, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((*status & I2C_PCF_PIN) && --timeout) {
 		adap->waitforpin(adap->data);
 		*status = get_pcf(adap, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while ((state = pca_status(adap)) != 0xf8) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((state = pca_status(adap)) != 0xf8) {
 		if (time_before(jiffies, timeout)) {
 			msleep(10);
 		} else {
@@ -198,6 +203,12 @@ static int pca_xfer(struct i2c_adapter *
 				"%#04x\n", state);
--
 	while (curmsg < num) {
 		state = pca_status(adap);
 
@@ -341,6 +357,12 @@ static int pca_xfer(struct i2c_adapter *
 
 		if (!completed)
--
-	while (i-- > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i-- > 0) {
 		if (res >= 0 && (rdwr_pa[i].flags & I2C_M_RD)) {
 			if (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,
 					 rdwr_pa[i].len))
 				res = -EFAULT;
 		}
--
 	while (id->name[0]) {
 		if (strcmp(client->name, id->name) == 0)
 			return id;
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (strlen(eids->sig)) {
 		if (!strcmp(eids->sig, edev->id.sig) &&
 		    edev->state & EISA_CONFIG_ENABLED) {
@@ -123,6 +128,12 @@ static int eisa_bus_match(struct device
 		}
 
--
-	while (pctlops->list_groups(pctldev, group_selector) >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pctlops->list_groups(pctldev, group_selector) >= 0) {
 		const char *gname = pctlops->get_group_name(pctldev,
 							    group_selector);
 		if (!strcmp(gname, pin_group)) {
@@ -416,6 +421,12 @@ static int pinmux_get_group_selector(str
 		}
--
-	while (ops->list_functions(pctldev, selector) >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ops->list_functions(pctldev, selector) >= 0) {
 		const char *fname = ops->get_function_name(pctldev,
 							   selector);
 		int ret;
@@ -540,6 +556,12 @@ static int pinmux_search_function(struct
 
--
-	while (pmxops->list_functions(pctldev, func_selector) >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pmxops->list_functions(pctldev, func_selector) >= 0) {
 		const char *func = pmxops->get_function_name(pctldev,
 							  func_selector);
 		const char * const *groups;
@@ -997,6 +1024,12 @@ static int pinmux_functions_show(struct
 
--
 	while (ops->list_groups(pctldev, selector) >= 0) {
 		const unsigned *pins;
 		unsigned num_pins;
@@ -347,6 +352,12 @@ static int pinctrl_groups_show(struct se
 			seq_puts(s, "]\n");
 		}
--
 	while ((z = zorro_find_device(ZORRO_WILDCARD, z))) {
 		unsigned long board;
 		struct ide_hw hw[MAX_NUM_HWIFS], *hws[MAX_NUM_HWIFS];
@@ -228,6 +233,12 @@ fail_base2:
 		}
 
--
 	while (cle->id_model) {
 		if (strcmp(cle->id_model, (char *)&id[ATA_ID_PROD]) == 0 &&
 		    (cle->id_firmware == NULL ||
 		     strstr((char *)&id[ATA_ID_FW_REV], cle->id_firmware)))
 			return cle->cd_flags;
 		cle++;
--
 	while (len) {
 		unsigned nr_bytes = min(len, cursg->length - cmd->cursg_ofs);
 		int page_is_high;
@@ -275,6 +280,12 @@ void ide_pio_bytes(ide_drive_t *drive, s
 			local_irq_restore(flags);
 
--
 	while (time_before(jiffies, timeout)) {
 		if (ide_do_test_unit_ready(drive, disk) == 0)
 			return 0;
@@ -702,6 +707,12 @@ static int idetape_wait_ready(ide_drive_
 			     (tape->ascq == 1 || tape->ascq == 8)))
 			return -EIO;
--
 	while (bcount) {
 		unsigned int count = min(tape->buffer_size, bcount);
 
 		idetape_queue_rw_tail(drive, REQ_IDETAPE_WRITE, count);
 		bcount -= count;
+		if (_cur < timeout) {
--
-	while (done < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (done < count) {
 		size_t todo;
 
 		/* flush if staging buffer is full */
@@ -1217,6 +1244,12 @@ static ssize_t idetape_chrdev_write(stru
 		tape->cur += todo;
--
 	while (tape->buffer_size > 0xffff) {
 		printk(KERN_NOTICE "ide-tape: decreasing stage size\n");
 		*ctl /= 2;
 		tape->buffer_size = *ctl * tape->blk_size;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (count--) {
 		__raw_writew(le16_to_cpu(*ptr), (void __iomem *)port);
 		ptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (len > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (len > 0) {
 		if (write)
 			hwif->tp_ops->output_data(drive, NULL, buf, min(4, len));
 		else
 			hwif->tp_ops->input_data(drive, NULL, buf, min(4, len));
 		len -= 4;
--
 	while (lap->device) {
 		if (lap->device == pdev->device &&
 		    lap->subvendor == pdev->subsystem_vendor &&
@@ -282,6 +287,12 @@ static u8 piix_cable_detect(ide_hwif_t *
 			return ATA_CBL_PATA40_SHORT;
 		}
--
 	while((pdev=pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82454NX, pdev))!=NULL)
 	{
 		/* Look for 450NX PXB. Check for problem configurations
@@ -409,6 +425,12 @@ static void __devinit piix_check_450nx(v
 		/* On all revisions below 5 PXB bus lock must be disabled for IDE */
 		else if (cfg & (1<<14) && pdev->revision < 5)
--
 		while ((stat & ATA_BUSY) && (count++ < 100)) {
 			udelay(1);
 			stat = sgiioc4_read_status(hwif);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((ioc4_dma & IOC4_S_DMA_STOP) && (count++ < 200)) {
 		udelay(1);
 		ioc4_dma = readl((void __iomem *)ioc4_dma_addr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((cnt++ < 200) && (!valid)) {
 		for (num = 0; num < 16; num++) {
 			if (ending_dma[num]) {
@@ -233,6 +260,12 @@ static int sgiioc4_dma_end(ide_drive_t *
 			}
 		}
--
 	while (i && sg_dma_len(sg)) {
 		dma_addr_t cur_addr;
 		int cur_len;
 		cur_addr = sg_dma_address(sg);
 		cur_len = sg_dma_len(sg);
 
-		while (cur_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (cur_len) {
 			if (count++ >= IOC4_PRD_ENTRIES) {
 				printk(KERN_WARNING
 				       "%s: DMA table too small\n",
@@ -455,10 +498,22 @@ static int sgiioc4_build_dmatable(ide_dr
 				cur_addr += bcount;
--
-	while (retries-- && ((ireason & ATAPI_COD) == 0 ||
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (retries-- && ((ireason & ATAPI_COD) == 0 ||
 		(ireason & ATAPI_IO))) {
 		printk(KERN_ERR PFX "%s: (IO,CoD != (0,1) while issuing "
 				"a packet command, retrying\n", drive->name);
@@ -565,6 +570,12 @@ static u8 ide_wait_ireason(ide_drive_t *
 			ireason |= ATAPI_COD;
 			ireason &= ~ATAPI_IO;
 		}
--
 		while (hi > lo) {
 			mid = (lo + hi) / 2;
 			if (sense_data_texts[mid].asc_ascq == key ||
@@ -293,6 +298,12 @@ void ide_cd_log_error(const char *name,
 				hi = mid;
 			else
--
 		while (stat & 0x03) {
 			udelay(1);
 			(void) pci_read_config_byte(dev, 0x43, &stat);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (cur_len) {
 			if (count++ >= PRD_ENTRIES)
 				goto use_pio_instead;
@@ -267,6 +272,12 @@ static int tx4939ide_build_dmatable(ide_
 			*table++ = cur_addr;
 			cur_addr += bcount;
--
 	while (count--) {
 		__raw_writew(le16_to_cpu(*ptr), (void __iomem *)port);
 		ptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (g->name || (d && d->name)) {
 		/* read settings in the alphabetical order */
 		if (g->name && d && d->name) {
@@ -318,6 +323,12 @@ static int ide_settings_proc_show(struct
 		if (ds->set)
 			seq_printf(m, "w");
--
 	while (count && isspace(*s)) {
 		--count;
 		++s;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (n > 0) {
 			unsigned val;
 			char *q = p;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
--
 			while (n > 0 && *p != ':') {
 				--n;
 				p++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while (n > 0 && isspace(*p)) {
 				--n;
 				++p;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	} while (!for_real++);
 	free_page((unsigned long)buf);
@@ -627,10 +682,21 @@ static void ide_add_proc_entries(struct
 
 	if (!dir || !p)
 		return;
--
 	while (p->name != NULL) {
 		ent = proc_create_data(p->name, p->mode, dir, p->proc_fops, data);
 		if (!ent) return;
 		p++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (p->name != NULL) {
 		remove_proc_entry(p->name, dir);
 		p++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (s != end && *s == ' ')
 		++s;
 	/* compress internal blanks and strip trailing blanks */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (s != end && *s) {
 		if (*s++ != ' ' || (s != end && *s && *s != ' '))
 			*p++ = *(s-1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (p != end)
@@ -508,6 +519,11 @@ int ide_wait_not_busy(ide_hwif_t *hwif,
 {
 	u8 stat = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
--
 	while (timeout--) {
 		/*
 		 * Turn this into a schedule() sleep once I'm sure
@@ -526,6 +542,12 @@ int ide_wait_not_busy(ide_hwif_t *hwif,
 			return -ENODEV;
 		touch_softlockup_watchdog();
--
 	while (lap->device) {
 		if (lap->device == pdev->device &&
 		    lap->subvendor == pdev->subsystem_vendor &&
 		    lap->subdevice == pdev->subsystem_device)
 			return ATA_CBL_PATA40_SHORT;
 		lap++;
--
 	while (i && sg_dma_len(sg)) {
 		u32 cur_addr;
 		u32 cur_len;
@@ -232,7 +237,12 @@ static int auide_build_dmatable(ide_driv
 		cur_addr = sg_dma_address(sg);
 		cur_len = sg_dma_len(sg);
--
-		while (cur_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (cur_len) {
 			u32 flags = DDMA_FLAGS_NOIE;
 			unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
 
@@ -264,9 +274,21 @@ static int auide_build_dmatable(ide_driv
 
--
 	while (i && sg_dma_len(sg)) {
 		u32 cur_addr;
 		u32 cur_len;
@@ -1502,7 +1507,12 @@ static int pmac_ide_build_dmatable(ide_d
 			}
 			return 0;
--
-		while (cur_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (cur_len) {
 			unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
 
 			if (count++ >= MAX_DCMDS) {
@@ -1519,9 +1529,21 @@ static int pmac_ide_build_dmatable(ide_d
 			cur_addr += tc;
--
 		while (cur_len) {
 			if (count++ >= PRD_ENTRIES)
 				goto use_pio_instead;
@@ -153,6 +158,12 @@ int ide_build_dmatable(ide_drive_t *driv
 			*table++ = cpu_to_le32(xcount);
 			cur_addr += bcount;
--
-	while ((dev = pci_get_device(PCI_VENDOR_ID_CYRIX, PCI_ANY_ID, dev)) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((dev = pci_get_device(PCI_VENDOR_ID_CYRIX, PCI_ANY_ID, dev)) != NULL) {
 		switch (dev->device) {
 			case PCI_DEVICE_ID_CYRIX_PCI_MASTER:
 				master_0 = pci_dev_get(dev);
@@ -152,6 +157,12 @@ static int init_chipset_cs5530(struct pc
 				cs5530_0 = pci_dev_get(dev);
--
 	while (port->rport_task) {
 		if (port->rport_task == RPORT_ADD) {
 			port->rport_task = RPORT_NONE;
@@ -648,6 +653,12 @@ void zfcp_scsi_rport_work(struct work_st
 			port->rport_task = RPORT_NONE;
 			zfcp_scsi_rport_block(port);
--
-	while (offset < length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < length) {
 		rec_length = min((u16) ZFCP_DBF_PAY_MAX_REC,
 				 (u16) (length - offset));
 		memcpy(pl->data, data + offset, rec_length);
@@ -48,6 +53,12 @@ void zfcp_dbf_pl_write(struct zfcp_dbf *
 
--
 	while (payload->counter < scount && (char *)pl[payload->counter]) {
 		memcpy(payload->data, (char *)pl[payload->counter], length);
 		debug_event(dbf->pay, 1, payload, zfcp_dbf_plen(length));
 		payload->counter++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (size) {
 		length = min((unsigned int)size, sg->length);
 		if (copy_from_user(sg_virt(sg++), user_buffer, length))
 			return -EFAULT;
 		user_buffer += length;
 		size -= length;
--
 	while (size) {
 		length = min((unsigned int) size, sg->length);
 		if (copy_to_user(user_buffer, sg_virt(sg++), length))
 			return -EFAULT;
 		user_buffer += length;
 		size -= length;
--
 	while ((dev = bus_find_device(&ap_bus_type, NULL, NULL,
 		    __ap_match_all)))
 	{
 		device_unregister(dev);
 		put_device(dev);
+		if (_cur < timeout) {
--
 		while ((dcssblk_segments[j] != ',') &&
 		       (dcssblk_segments[j] != '\0'))
 		{
 			j++;
+			if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (cqr->refers != NULL) {
 		cqr = cqr->refers;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (cqr->refers != NULL) {
 		cqr = cqr->refers;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (erp_done != erp) {
 
 		if (erp_done == NULL)	/* end of chain reached */
@@ -2639,6 +2666,12 @@ dasd_3990_erp_handle_match_erp(struct da
 		/* free the finished erp request */
 		dasd_free_erp_request(erp_free, erp_free->memdev);
--
 	}			/* end while */
 
 	if (erp->retries > 0) {
diff -u -p a/s390/block/dasd_alias.c b/s390/block/dasd_alias.c
--- a/s390/block/dasd_alias.c
+++ b/s390/block/dasd_alias.c
--
-	while (!list_empty(&active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&active)) {
 		device = list_first_entry(&active, struct dasd_device,
 					  alias_list);
 		spin_unlock_irqrestore(&lcu->lock, flags);
@@ -852,6 +857,12 @@ static void flush_all_alias_devices_on_l
 		if (device == list_first_entry(&active,
--
 		while (seg_len) {
 			if (new_track) {
 				trkid = recid;
@@ -2452,6 +2457,12 @@ static struct dasd_ccw_req *dasd_eckd_bu
 				idaw_len = 0;
 				end_idaw = 0;
--
 			while (seg_len) {
 				if (new_track) {
 					trkid = recid;
@@ -2727,6 +2743,12 @@ static struct dasd_ccw_req *dasd_eckd_bu
 				if (IS_ERR(last_tidaw))
 					return ERR_PTR(-EINVAL);
--
-	while (from <= to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (from <= to) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       from, ((int *) from)[0], ((int *) from)[1]);
@@ -3618,6 +3645,12 @@ dasd_eckd_dump_ccw_range(struct ccw1 *fr
 		}
--
-	while (rest > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rest > 0) {
  		headindex = eerb->head / PAGE_SIZE;
  		localhead = eerb->head % PAGE_SIZE;
 		len = min(rest, PAGE_SIZE - localhead);
@@ -146,6 +151,12 @@ static void dasd_eer_write_buffer(struct
 		if (eerb->head == eerb->buffersize)
--
-	while (rest > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rest > 0) {
  		tailindex = eerb->tail / PAGE_SIZE;
  		localtail = eerb->tail % PAGE_SIZE;
 		len = min(rest, PAGE_SIZE - localtail);
@@ -173,6 +189,12 @@ static int dasd_eer_read_buffer(struct e
 		if (eerb->tail == eerb->buffersize)
--
 	while (dasd_eer_get_free_bytes(eerb) < count + sizeof(count)) {
 		if (eerb->residual > 0) {
 			eerb->tail += eerb->residual;
@@ -202,6 +229,12 @@ static int dasd_eer_start_record(struct
 		eerb->tail += tailcount;
 		if (eerb->tail >= eerb->buffersize)
--
-		while (!tc) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!tc) {
 			tc = dasd_eer_read_buffer(eerb, (char *) &tailcount,
 						  sizeof(tailcount));
 			if (!tc) {
@@ -627,6 +665,12 @@ static ssize_t dasd_eer_read(struct file
 					return -ERESTARTSYS;
--
 	while (fdata->start_unit <= fdata->stop_unit) {
 		cqr = base->discipline->format_device(base, fdata);
 		if (IS_ERR(cqr))
@@ -192,6 +197,12 @@ static int dasd_format(struct dasd_block
 			return rc;
 		}
--
 	while ((retries < 5) && (cqr->status == DASD_CQR_IN_IO)) {
 		rc = ccw_device_clear(device->cdev, (long) cqr);
 		switch (rc) {
@@ -1367,6 +1372,12 @@ int dasd_term_IO(struct dasd_ccw_req *cq
 			break;
 		}
--
-	while (act <= end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (act <= end) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       act, ((int *) act)[0], ((int *) act)[1]);
@@ -526,6 +531,12 @@ dasd_fba_dump_sense(struct dasd_device *
 				       [(count>>2)]);
--
-	while (act <= end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (act <= end) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       act, ((int *) act)[0], ((int *) act)[1]);
@@ -548,6 +564,12 @@ dasd_fba_dump_sense(struct dasd_device *
 				       [(count>>2)]);
--
-	while (act <= last) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (act <= last) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       act, ((int *) act)[0], ((int *) act)[1]);
@@ -566,6 +593,12 @@ dasd_fba_dump_sense(struct dasd_device *
 				       [(count>>2)]);
--
 	while (add_bit > 0) {
 		if (xpram_page_in(mem_page, page_index | add_bit) == 0)
 			page_index |= add_bit;
 		add_bit >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (bytes > 0) {
 			if (bio_data_dir(bio) == READ) {
 				if (xpram_page_in(page_addr, index) != 0)
@@ -217,6 +233,12 @@ static void xpram_make_request(struct re
 			page_addr += 4096;
 			bytes -= 4096;
--
 	while (i--) {
 		blk_cleanup_queue(xpram_queues[i]);
 		put_disk(xpram_disks[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (from <= to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (from <= to) {
 		sprintf(bus_id, "%01x.%01x.%04x",
 			from_id0, from_id1, from++);
 		devmap = dasd_add_busid(bus_id, features);
 		if (IS_ERR(devmap))
 			return (char *)devmap;
--
 	while (cqr->refers != NULL) {
 		struct dasd_ccw_req *refers;
 
@@ -140,6 +145,12 @@ struct dasd_ccw_req *dasd_default_erp_po
 		/* free the finished erp request */
 		dasd_free_erp_request(cqr, cqr->memdev);
--
 	while (priv->buffer_free) {
 		rc = vmlogrdr_receive_data(priv);
 		if (rc) {
@@ -490,6 +495,12 @@ static ssize_t vmlogrdr_read(struct file
 			if (rc)
 				return rc;
--
 	while (sclp_con_queue_running) {
 		spin_unlock_irqrestore(&sclp_con_lock, flags);
 		sclp_sync_wait();
 		spin_lock_irqsave(&sclp_con_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (list_empty(&sclp_con_pages)) {
 				if (sclp_con_suspended)
 					goto out;
 				spin_unlock_irqrestore(&sclp_con_lock, flags);
 				sclp_sync_wait();
 				spin_lock_irqsave(&sclp_con_lock, flags);
--
 	while (lines < RAW3215_MAX_NEWLINE && ix != raw->head) {
 		if (raw->buffer[ix] == 0x15)
 			lines++;
 		ix = (ix + 1) & (RAW3215_BUFFER_SIZE - 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len > 0) {
 		if (ccw > req->ccws)
 			ccw[-1].flags |= 0x40; /* use command chaining */
@@ -228,6 +244,12 @@ static void raw3215_mk_write_req(struct
 		len -= count;
 		ix = (ix + count) & (RAW3215_BUFFER_SIZE - 1);
--
-	while (length > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (length > 0) {
 		spin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);
 		count = (length > RAW3215_BUFFER_SIZE) ?
 					     RAW3215_BUFFER_SIZE : length;
@@ -542,6 +569,12 @@ static void raw3215_write(struct raw3215
 			raw3215_try_io(raw);
--
 	while (count > 0) {
 		for (i = 0; i < count; i++)
 			if (str[i] == '\t' || str[i] == '\n')
@@ -802,6 +840,12 @@ static void con3215_write(struct console
 			count--;
 			str++;
--
-			while (list_empty(&sclp_tty_pages)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (list_empty(&sclp_tty_pages)) {
 				spin_unlock_irqrestore(&sclp_tty_lock, flags);
 				if (may_fail)
 					goto out;
 				else
 					sclp_sync_wait();
--
-	while (count-- > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count-- > 0) {
 		/* compare with special character */
 		if (*ip == CASE_DELIMITER) {
 			/* followed by another special character? */
@@ -403,6 +419,12 @@ static int sclp_switch_cases(unsigned ch
 			else
--
 	while (request->status != SCLP_REQ_DONE &&
 		request->status != SCLP_REQ_FAILED) {
 		 sclp_sync_wait();
+		 if (_cur < timeout) {
+		 	rdstcll(_cur);
+		 }
--
 	while (count-- > 0) {
 		c = *str++;
 		if (cp->cline->len == 0)
@@ -489,6 +494,12 @@ con3270_write(struct console *co, const
 			con3270_cline_insert(cp, c);
 		if (c == '\n' || cp->cline->len >= cp->view.cols)
--
 	while (!cp->write) {
 		raw3270_wait_cons_dev(cp->view.dev);
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cp->update_flags != 0) {
 		spin_unlock_irqrestore(&cp->view.lock, flags);
 		con3270_update(cp);
 		spin_lock_irqsave(&cp->view.lock, flags);
 		con3270_wait_write(cp);
+		if (_cur < timeout) {
--
-			while (!raw3270_request_final(rq)) {
-				wait_cons_dev();
-				barrier();
+		if (rc == 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
--
+				while (!raw3270_request_final(rq)) {
+					wait_cons_dev();
+					barrier();
+						if (_cur < timeout) {
+								rdstcll(_cur);
+						}
--
 	while (!list_empty(&rp->view_list)) {
 		v = list_entry(rp->view_list.next, struct raw3270_view, list);
 		if (v->fn->release)
@@ -1285,6 +1302,12 @@ raw3270_remove (struct ccw_device *cdev)
 		spin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);
 		raw3270_del_view(v);
--
-			while (list_empty(&sclp_vt220_empty)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (list_empty(&sclp_vt220_empty)) {
 				spin_unlock_irqrestore(&sclp_vt220_lock, flags);
 				if (may_fail || sclp_vt220_suspended)
 					goto out;
 				else
 					sclp_sync_wait();
--
 	while (sclp_vt220_queue_running) {
 		spin_unlock_irqrestore(&sclp_vt220_lock, flags);
 		sclp_sync_wait();
 		spin_lock_irqsave(&sclp_vt220_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (sclp_running_state != sclp_running_state_idle) {
 		/* Check for expired request timer */
 		if (timer_pending(&sclp_request_timer) &&
@@ -476,6 +481,12 @@ sclp_sync_wait(void)
 		    del_timer(&sclp_request_timer))
 			sclp_request_timer.function(sclp_request_timer.data);
--
 	while (remaining > 0) {
 		remaining -= evbuf->length;
 		if (evbuf->flags & 0x80) {
@@ -648,6 +664,12 @@ sclp_remove_processed(struct sccb_header
 			evbuf = (struct evbuf_header *)
 					((addr_t) evbuf + evbuf->length);
--
 	while (ptr->cda) {
 		kfree((void *)(addr_t) ptr->cda);
 		ptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (urd->open_flag) {
 		spin_unlock(&urd->open_lock);
 		if (file->f_flags & O_NONBLOCK) {
@@ -723,6 +739,12 @@ static int ur_open(struct inode *inode,
 			goto fail_put;
 		}
--
 	while (zfcpdump_save_areas[i]) {
 		unsigned long cp_start, cp_end; /* copy range */
 		unsigned long sa_start, sa_end; /* save area range */
@@ -274,6 +279,12 @@ static int zcore_add_lc(char __user *buf
 			return -EFAULT;
 next:
--
 		while (line->len < tp->cx) {
 			cell = line->cells + line->len;
 			cell->character = tp->view.ascebc[' '];
 			cell->highlight = tp->highlight;
 			cell->f_color = tp->f_color;
 			line->len++;
--
 	while (line->len < tp->cx) {
 		line->cells[line->len].character = tp->view.ascebc[' '];
 		line->cells[line->len].highlight = TAX_RESET;
 		line->cells[line->len].f_color = TAC_RESET;
 		line->len++;
+		if (_cur < timeout) {
--
 	while (n-- > 0) {
 		line->cells[tp->cx + n].character = tp->view.ascebc[' '];
 		line->cells[tp->cx + n].highlight = tp->highlight;
 		line->cells[tp->cx + n].f_color = tp->f_color;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (line->len > tp->cx && n-- > 0) {
 		cell = line->cells + tp->cx++;
 		cell->character = ' ';
 		cell->highlight = TAX_RESET;
 		cell->f_color = TAC_RESET;
+		if (_cur < timeout) {
--
 		while (c) {
 			if (forced_cleanup ||
 			    atomic_read(&c->state) ==
@@ -388,6 +393,12 @@ static inline void qeth_cleanup_handled_
 				c = c->next_pending;
 			}
--
 	while (iob[index].state == BUF_STATE_PROCESSED) {
 		if (iob[index].callback != NULL)
 			iob[index].callback(channel, iob + index);
 
 		index = (index + 1) % QETH_CMD_BUFFER_NO;
+		if (_cur < timeout) {
--
 	while (skb) {
 		QETH_CARD_TEXT_(q->card, 5, "skbn%d", notification);
 		QETH_CARD_TEXT_(q->card, 5, "%lx", (long) skb);
@@ -1105,6 +1132,12 @@ static void qeth_notify_skbs(struct qeth
 			skb = NULL;
 		else
--
 	while (skb) {
 		QETH_CARD_TEXT(buf->q->card, 5, "skbr");
 		QETH_CARD_TEXT_(buf->q->card, 5, "%lx", (long) skb);
 		atomic_dec(&skb->users);
 		dev_kfree_skb_any(skb);
 		skb = skb_dequeue(&buf->skb_list);
--
 	while (known_devices[i][QETH_DEV_MODEL_IND]) {
 		if ((CARD_RDEV(card)->id.dev_type ==
 				known_devices[i][QETH_DEV_TYPE_IND]) &&
@@ -1447,6 +1496,12 @@ static int qeth_determine_card_type(stru
 			return 0;
 		}
--
 		while (!atomic_read(&reply->received)) {
 			if (time_after(jiffies, timeout))
 				goto time_err;
 			cpu_relax();
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (j > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (j > 0) {
 		--j;
 		kmem_cache_free(qeth_qdio_outbuf_cache,
 				card->qdio.out_qs[i]->bufs[j]);
 		card->qdio.out_qs[i]->bufs[j] = NULL;
+		if (_cur < timeout) {
--
 	while (i > 0) {
 		kfree(card->qdio.out_qs[--i]);
 		qeth_clear_outq_buffers(card->qdio.out_qs[i], 1);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 		while (buffer->element[e].addr) {
 			unsigned long phys_aob_addr;
 
@@ -3443,6 +3536,12 @@ static void qeth_qdio_cq_handler(struct
 			buffer->element[e].length = 0;
 
--
 	while (length > 0) {
 		/* length_here is the remaining amount of data in this page */
 		length_here = PAGE_SIZE - ((unsigned long) data % PAGE_SIZE);
@@ -3689,6 +3793,12 @@ static inline void __qeth_fill_buffer(st
 		data += length_here;
 		element++;
--
 	while (atomic_dec_return(&queue->state)) {
 		flush_count = 0;
 		start_index = queue->next_buf_to_fill;
@@ -3877,6 +3992,12 @@ int qeth_do_send_packet(struct qeth_card
 			flush_count += qeth_flush_buffers_on_no_pci(queue);
 		if (flush_count)
--
 	while (skb_len) {
 		data_len = min(skb_len, (int)(element->length - offset));
 		if (data_len) {
@@ -4839,6 +4965,12 @@ struct sk_buff *qeth_core_get_next_skb(s
 		} else {
 			offset += data_len;
--
-	while ((skb = skb_dequeue(&conn->collect_queue))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&conn->collect_queue))) {
 		header.next = conn->tx_buff->len + skb->len + NETIUCV_HDRLEN;
 		memcpy(skb_put(conn->tx_buff, NETIUCV_HDRLEN), &header,
 		       NETIUCV_HDRLEN);
@@ -764,6 +769,12 @@ static void conn_action_txdone(fsm_insta
 		stat_maxcq++;
--
 	while ((skb = skb_dequeue(q))) {
 		atomic_dec(&skb->users);
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&iucv_connection_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&iucv_connection_list)) {
 		cp = list_entry(iucv_connection_list.next,
 				struct iucv_connection, list);
 		ndev = cp->netdev;
@@ -2184,6 +2211,12 @@ static void __exit netiucv_exit(void)
 
--
 	while ((skb = skb_dequeue(q))) {
 		atomic_dec(&skb->users);
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = skb_dequeue(&ch->io_queue))) {
 		priv->stats.tx_packets++;
 		priv->stats.tx_bytes += skb->len - LL_HEADER_LENGTH;
@@ -277,6 +293,12 @@ static void chx_txdone(fsm_instance *fi,
 		}
 		atomic_dec(&skb->users);
--
-		while ((skb = skb_dequeue(&ch->collect_queue))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((skb = skb_dequeue(&ch->collect_queue))) {
 			skb_copy_from_linear_data(skb,
 				skb_put(ch->trans_skb, skb->len), skb->len);
 			priv->stats.tx_packets++;
@@ -304,6 +331,12 @@ static void chx_txdone(fsm_instance *fi,
 			atomic_dec(&skb->users);
--
 	while ((skb = skb_dequeue(&ch->io_queue))) {
 		priv->stats.tx_packets++;
 		priv->stats.tx_bytes += skb->len - TH_HEADER_LENGTH;
@@ -1256,6 +1294,12 @@ static void ctcmpc_chx_txdone(fsm_instan
 		}
 		atomic_dec(&skb->users);
--
 		while ((pskb->len > 0) && !pdu_last_seen) {
 			curr_pdu = (struct pdu *)pskb->data;
 
@@ -1188,6 +1193,12 @@ static void ctcmpc_unpack_skb(struct cha
 			priv->stats.rx_packets++;
 			priv->stats.rx_bytes += skblen;
--
 		while (card->rx.b_count) {
 			buffer = &card->qdio.in_q->bufs[card->rx.b_index];
 			if (!(card->rx.qdio_err &&
@@ -512,6 +517,12 @@ static int qeth_l2_poll(struct napi_stru
 				goto out;
 			else
--
-	while (!list_empty(&card->ipm_list)){
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&card->ipm_list)){
 		ipm = list_entry(card->ipm_list.next,
 				 struct lcs_ipm_list, list);
 		list_del(&ipm->list);
@@ -468,6 +473,12 @@ lcs_clear_multicast_list(struct lcs_card
 			spin_lock_irqsave(&card->ipm_lock, flags);
--
-		while (channel->io_idx != index) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (channel->io_idx != index) {
 			__lcs_processed_buffer(channel,
 					       channel->iob + channel->io_idx);
 			channel->io_idx =
 				(channel->io_idx + 1) & (LCS_NUM_BUFFS - 1);
+				if (_cur < timeout) {
--
 	while (iob[buf_idx].state == LCS_BUF_STATE_PROCESSED) {
 		/* Do the callback thing. */
 		if (iob[buf_idx].callback != NULL)
 			iob[buf_idx].callback(channel, iob + buf_idx);
 		buf_idx = (buf_idx + 1) & (LCS_NUM_BUFFS - 1);
+		if (_cur < timeout) {
--
 	while (lcs_hdr->offset != 0) {
 		if (lcs_hdr->offset <= 0 ||
 		    lcs_hdr->offset > LCS_IOBUFFERSIZE ||
@@ -1862,6 +1900,12 @@ lcs_get_frames_cb(struct lcs_channel *ch
 		offset = lcs_hdr->offset;
 		lcs_hdr->offset = LCS_ILLEGAL_OFFSET;
--
 	while (len > 0) {
 		struct sk_buff *skb;
 		int skblen;
@@ -178,6 +183,12 @@ void ctcm_unpack_skb(struct channel *ch,
 			}
 			skb_put(pskb, LL_HEADER_LENGTH);
--
-	while (*buf) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (*buf) {
 		if (!isxdigit(*buf++))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!list_empty(tbd_list)) {
 		todo = list_entry(tbd_list->next, struct qeth_ipaddr, entry);
 		list_del(&todo->entry);
@@ -481,6 +497,12 @@ void qeth_l3_set_ip_addr_list(struct qet
 				list_add_tail(&addr->entry, &card->ip_list);
 			kfree(todo);
--
-	while (!list_empty(&card->ip_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&card->ip_list)) {
 		addr = list_entry(card->ip_list.next,
 				  struct qeth_ipaddr, entry);
 		list_del_init(&addr->entry);
@@ -510,6 +537,12 @@ static void qeth_l3_clear_ip_list(struct
 			continue;
--
 		while (card->rx.b_count) {
 			buffer = &card->qdio.in_q->bufs[card->rx.b_index];
 			if (!(card->rx.qdio_err &&
@@ -2112,6 +2150,12 @@ static int qeth_l3_poll(struct napi_stru
 				goto out;
 			else
--
 	while (length > 0) {
 		debug_event(chsc_debug_log_id, level, data, length);
 		length -= chsc_debug_log_id->buf_size;
 		data += chsc_debug_log_id->buf_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (-1ul < (data.elapsed_time | utilization)) {
 		utilization >>= 8;
 		data.elapsed_time >>= 8;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (stcrw(&crw) == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (stcrw(&crw) == 0) {
 		/* Check for responses to RCHP. */
 		if (crw.slct && crw.rsc == CRW_RSC_CPATH)
 			atomic_dec(&chpid_reset_count);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while ((dev = driver_find_device(&cdriver->driver, NULL, NULL,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((dev = driver_find_device(&cdriver->driver, NULL, NULL,
 					 __ccwgroup_match_all))) {
 		struct ccwgroup_device *gdev = to_ccwgroupdev(dev);
 
@@ -591,6 +596,12 @@ void ccwgroup_driver_unregister(struct c
 		__ccwgroup_remove_cdev_refs(gdev);
--
 		while (word) {
 			if (word & INDICATOR_MASK) {
 				airq = airqs[isc][i];
@@ -146,6 +151,12 @@ void do_adapter_IO(u8 isc)
 			}
 			word <<= 8;
--
-	while (!dev_fsm_final_state(cdev) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!dev_fsm_final_state(cdev) &&
 	       cdev->private->state != DEV_STATE_DISCONNECTED) {
 		spin_unlock_irq(cdev->ccwlock);
 		wait_event(cdev->private->wait_q, (dev_fsm_final_state(cdev) ||
 			   cdev->private->state == DEV_STATE_DISCONNECTED));
 		spin_lock_irq(cdev->ccwlock);
--
-	while (!dev_fsm_final_state(cdev) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!dev_fsm_final_state(cdev) &&
 	       cdev->private->state != DEV_STATE_DISCONNECTED) {
 		spin_unlock_irq(cdev->ccwlock);
 		wait_event(cdev->private->wait_q, (dev_fsm_final_state(cdev) ||
 			   cdev->private->state == DEV_STATE_DISCONNECTED));
 		spin_lock_irq(cdev->ccwlock);
--
 	while (ret == -EBUSY) {
 		cdev->private->state = DEV_STATE_QUIESCE;
 		cdev->private->iretry = 255;
@@ -1235,6 +1262,12 @@ static void io_subchannel_quiesce(struct
 			spin_lock_irq(sch->lock);
 		}
--
 	while (i > 0) {
 		struct channel_subsystem *css;
 
@@ -958,6 +963,12 @@ out_unregister:
 			device_remove_file(&css->device,
 					   &dev_attr_cm_enable);
--
 			while (++retries < QDIO_BUSY_BIT_RETRIES) {
 				mdelay(QDIO_BUSY_BIT_RETRY_DELAY);
 				goto retry;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-	while ((from_ssid < to_ssid) || ((from_ssid == to_ssid) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((from_ssid < to_ssid) || ((from_ssid == to_ssid) &&
 	       (from <= to))) {
 		if (action == add)
 			set_bit(from, bl_dev[from_ssid]);
@@ -70,6 +75,12 @@ static int blacklist_range(range_action
 			from_ssid++;
--
 	while ((parm = strsep(&str, ","))) {
 		rc = 0;
 		ra = action;
@@ -196,6 +212,12 @@ static int blacklist_parse_parameters(ch
 				totalrc = -EINVAL;
 		} else
--
 	while ((i >= 0) && (isspace(buf[i]) || (buf[i] == 0))) {
 		buf[i] = '\0';
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (table->twd) {
 		if (value <= table->twd) {
 			if (nodelay && table->tdelay == 0)
@@ -112,6 +117,12 @@ max63xx_select_timeout(struct max63xx_ti
 		}
 
--
 	while ((!found) && (count < 3)) {
 		i = send_isa_command(CMD_ISA_IDLE);
 
@@ -266,6 +271,12 @@ static int set_command_mode(void)
 			udelay(ISA_COMMAND_TIMEOUT);
 		}
--
 			while(!ready){
 				udelay(20);
 				if ((readl(&regs->WinData) & 0xff000000) ==
@@ -502,6 +507,12 @@ static unsigned int write_eeprom(struct
 					ready = 1;
 					error = 1;
--
 	while (prodidx != eidx){
 		switch (rrpriv->evt_ring[eidx].code){
 		case E_NIC_UP:
@@ -930,6 +946,12 @@ static u32 rr_handle_event(struct net_de
 			       dev->name, rrpriv->evt_ring[eidx].code);
 		}
--
 		while ((target_config = strsep(&input, ";"))) {
 			nt = alloc_param_target(target_config);
 			if (IS_ERR(nt)) {
@@ -744,6 +749,12 @@ static int __init init_netconsole(void)
 			spin_lock_irqsave(&target_list_lock, flags);
 			list_add(&nt->list, &target_list);
--
 	while (ret) {
 		if (cmp_addr(&ret->pppoe_pa, sid, addr) &&
 		    ret->pppoe_ifindex == ifindex)
 			return ret;
 
 		ret = ret->next;
--
 	while (ret) {
 		if (cmp_2_addr(&ret->pppoe_pa, &po->pppoe_pa) &&
 		    ret->pppoe_ifindex == po->pppoe_ifindex)
 			return -EALREADY;
 
 		ret = ret->next;
--
 		while (po) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (po && po->pppoe_dev != dev) {
 				po = po->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 		while (po) {
 			if (!pos--)
 				goto out;
 			po = po->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (state->ccount != ccount) {
 			mppe_rekey(state, 0);
 			state->ccount = (state->ccount + 1) % MPPE_CCOUNT_SPACE;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 				while ((ccount & ~0xff) !=
 				       (state->ccount & ~0xff)) {
 					mppe_rekey(state, 0);
 					state->ccount =
 					    (state->ccount +
 					     256) % MPPE_CCOUNT_SPACE;
--
 	while ((skb = skb_dequeue(&ap->rqueue)) != NULL) {
 		if (skb->cb[0])
 			ppp_input_error(&ap->chan, 0);
 		ppp_input(&ap->chan, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (i < count && buf < buflim) {
 		c = data[i++];
 		if (i == 1 && c == 0 && (ap->flags & SC_COMP_PROT))
 			continue;	/* compress protocol field */
 		fcs = PPP_FCS(fcs, c);
 		PUT_BYTE(ap, buf, c, islcp);
--
 	while (dlen >= 2 && dlen >= data[1] && data[1] >= 2) {
 		switch (data[0]) {
 		case LCP_MRU:
@@ -1015,6 +1042,12 @@ static void async_lcp_peek(struct asyncp
 		}
 		dlen -= data[1];
--
 	while (count-- > 0) {
 		next_ch = *in++;
 		*out++ = hex[(next_ch >> 4) & 0x0F];
 		*out++ = hex[next_ch & 0x0F];
 		++out;
+		if (_cur < timeout) {
--
 	while (count-- > 0) {
 		next_ch = *in++;
 
@@ -136,6 +152,12 @@ ppp_print_char (register __u8 * out, con
 			if (next_ch == '%')   /* printk/syslogd has a bug !! */
 				*out++ = '%';
--
 	while (count > 8) {
 		memset (line, 32, 44);
 		ppp_print_hex (line, buf, 8);
@@ -155,6 +182,12 @@ ppp_print_buffer (const char *name, cons
 		printk(KERN_DEBUG "%s\n", line);
 		count -= 8;
--
 	while ((skb = skb_dequeue(&ap->rqueue)) != NULL) {
 		if (skb->len == 0) {
 			/* zero length buffers indicate error */
@@ -546,6 +584,12 @@ static void ppp_sync_process(unsigned lo
 		}
 		else
--
 	while ((skb = ppp_mp_reconstruct(ppp))) {
 		if (pskb_may_pull(skb, 2))
 			ppp_receive_nonmp_frame(ppp, skb);
@@ -1963,6 +1968,12 @@ ppp_receive_mp_frame(struct ppp *ppp, st
 			kfree_skb(skb);
 			ppp_receive_error(ppp);
--
-    while (indx-- != 0)
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (indx-- != 0)
       {
 	db->dict[indx].codem1 = BADCODEM1;
 	db->dict[indx].cptr   = 0;
+	if (_cur < timeout) {
+	rdstcll(_cur);
--
-    while (--ilen > 0)
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (--ilen > 0)
       {
 	c     = *rptr++;
 	fcode = BSD_KEY  (ent, c);
@@ -734,6 +750,12 @@ nomatch:
 	      }
--
-	while (finchar > LAST)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	  unsigned long long timeout;
+	  timeout = rdstcll(start) + delta;
+	  while (finchar > LAST)
 	  {
 	    struct bsd_dict *dictp2 = dict_ptr (db, finchar);
 
@@ -1024,6 +1051,12 @@ static int bsd_decompress (void *state,
 #endif
--
 	while (skb_peek(&cfspi->chead)) {
 		skb = skb_dequeue_tail(&cfspi->chead);
 		skb_queue_head(&cfspi->qhead, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (nfrms < CFHSI_MAX_PKTS) {
 		desc->cffrm_len[nfrms] = 0x0000;
 		nfrms++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (nfrms < CFHSI_MAX_PKTS && *plen) {
 		xfer_sz += *plen;
 		plen++;
 		nfrms++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (nfrms < cfhsi->rx_state.nfrms) {
 		pfrm += *plen;
 		rx_sz += *plen;
 		plen++;
 		nfrms++;
+		if (_cur < timeout) {
--
 	while (nfrms < CFHSI_MAX_PKTS && *plen) {
 		struct sk_buff *skb;
 		u8 *dst = NULL;
@@ -520,6 +558,12 @@ static int cfhsi_rx_pld(struct cfhsi_des
 		rx_sz += *plen;
 		plen++;
--
-	while (!(list_empty(&pshm_drv->tx_pend_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->tx_pend_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_pend_list.next,
 					struct buf_list, list);
 
 		list_del(&pbuf->list);
--
-	while (!(list_empty(&pshm_drv->tx_full_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->tx_full_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_full_list.next,
 					struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
--
-	while (!(list_empty(&pshm_drv->tx_empty_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->tx_empty_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_empty_list.next,
 					struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
--
-	while (!(list_empty(&pshm_drv->rx_full_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->rx_full_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_full_list.next,
 				struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
--
-	while (!(list_empty(&pshm_drv->rx_pend_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->rx_pend_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_pend_list.next,
 				struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
--
-	while (!(list_empty(&pshm_drv->rx_empty_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->rx_empty_list))) {
 		pbuf =
 			list_entry(pshm_drv->rx_empty_list.next,
 				struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
--
 	while (len > PAGE_SIZE - offset) {
 		tx->size = PAGE_SIZE - offset;
 		tx->flags |= XEN_NETTXF_more_data;
@@ -446,6 +451,12 @@ static void xennet_make_frags(struct sk_
 		tx->offset = offset;
 		tx->size = len;
--
-	while ((nskb = __skb_dequeue(list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((nskb = __skb_dequeue(list))) {
 		struct xen_netif_rx_response *rx =
 			RING_GET_RESPONSE(&np->rx, ++cons);
 		skb_frag_t *nfrag = &skb_shinfo(nskb)->frags[0];
@@ -789,6 +805,12 @@ static RING_IDX xennet_fill_frags(struct
 		kfree_skb(nskb);
--
 	while ((skb = __skb_dequeue(rxq)) != NULL) {
 		struct page *page = NETFRONT_SKB_CB(skb)->page;
 		void *vaddr = page_address(page);
@@ -902,6 +929,12 @@ static int handle_incoming_queue(struct
 
 		/* Pass it up. */
--
 	while ((i != rp) && (work_done < budget)) {
 		memcpy(rx, RING_GET_RESPONSE(&np->rx, i), sizeof(*rx));
 		memset(extras, 0, sizeof(rinfo.extras));
@@ -1019,6 +1057,12 @@ err:
 
 		np->rx.rsp_cons = ++i;
--
 		while ((token = strsep(&options, ",")) != NULL) {
 			if (*token == '\0')	/* eat joint commas */
 				continue;
@@ -351,6 +356,12 @@ int i2400m_barker_db_init(const char *_o
 			result = i2400m_barker_db_add(barker);
 			if (result < 0)
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		spin_lock_irqsave(&i2400m->rx_lock, flags);
 		list_splice_init(&i2400m->rx_reports, &list);
 		spin_unlock_irqrestore(&i2400m->rx_lock, flags);
@@ -203,6 +208,12 @@ void i2400m_report_hook_work(struct work
 			list_del(&args->list_node);
--
-	while (offset < ack_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < ack_size) {
 		init_completion(&notif_completion);
 		result = i2400mu_notif_submit(i2400mu, &notif_urb,
 					      &notif_completion);
@@ -344,6 +349,12 @@ ssize_t i2400mu_bus_bm_wait_for_ack(stru
 		len = min(ack_size - offset, (size_t) notif_urb.actual_length);
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (count--) {
 		if (fp && *fp++) {
 			if (!test_and_set_bit(SLF_ERROR, &sl->flags))
 				sl->dev->stats.rx_errors++;
@@ -690,6 +695,12 @@ static void slip_receive_buf(struct tty_
 		else
--
 	while (len-- > 0) {
 		switch (c = *s++) {
 		case END:
@@ -924,6 +940,12 @@ static int slip_esc(unsigned char *s, un
 			*ptr++ = c;
 			break;
--
 		while (bits >= 6) {
 			bits -= 6;
 			c = 0x30 + ((v >> bits) & 0x3F);
 			*ptr++ = c;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!(elp_reg & ELPCTRL_WLAN_READY)) {
 		if (time_after(jiffies, timeout)) {
 			wl1251_error("elp wakeup timeout");
@@ -94,6 +99,12 @@ int wl1251_ps_elp_wakeup(struct wl1251 *
 		}
 		msleep(1);
--
-	while (chunk_num < fw_data_len / CHUNK_SIZE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (chunk_num < fw_data_len / CHUNK_SIZE) {
 		/* 10.2 update partition, if needed */
 		addr = WL1251_PART_DOWN_MEM_START +
 			(chunk_num + 2) * CHUNK_SIZE;
@@ -379,6 +384,12 @@ static int wl1251_boot_upload_firmware(s
 		wl1251_mem_write(wl, addr, buf, len);
--
 	while (nvs_ptr[0]) {
 		burst_len = nvs_ptr[0];
 		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));
@@ -442,6 +458,12 @@ static int wl1251_boot_upload_nvs(struct
 			nvs_ptr += 4;
 			dest_addr += 4;
--
-	while (nvs_bytes_written < nvs_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nvs_bytes_written < nvs_len) {
 		val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
 		       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));
 
@@ -474,6 +501,12 @@ static int wl1251_boot_upload_nvs(struct
 		nvs_ptr += 4;
--
 	while (!(intr & WL1251_ACX_INTR_CMD_COMPLETE)) {
 		if (time_after(jiffies, timeout)) {
 			wl1251_error("command complete timeout");
@@ -48,6 +53,12 @@ int wl1251_cmd_send(struct wl1251 *wl, u
 		msleep(1);
 
--
 	while ((skb = skb_dequeue(&wl->tx_queue))) {
 		if (!woken_up) {
 			ret = wl1251_ps_elp_wakeup(wl);
@@ -340,7 +345,13 @@ void wl1251_tx_work(struct work_struct *
 			dev_kfree_skb(skb);
 			goto out;
--
 	while ((skb = skb_dequeue(&wl->tx_queue))) {
 		info = IEEE80211_SKB_CB(skb);
 
@@ -544,6 +560,12 @@ void wl1251_tx_flush(struct wl1251 *wl)
 				continue;
 
--
 		while (((s1 = R_REG(&wlc->regs->frmtxstatus)) & TXS_V) == 0) {
 			udelay(1);
 			status_delay++;
 			if (status_delay > 10)
 				return; /* error condition */
+				if (_cur < timeout) {
--
 		while (bufsize--) {
 			pci_read_config_byte(dev, cap_data, buf);
 			cap_data++;
 			buf++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (i < pcie_serdes_spinwait) {
 		if (R_REG(&pcieregs->mdiocontrol) & MDIOCTL_ACCESS_DONE) {
 			if (!write) {
@@ -450,6 +466,12 @@ pcie_mdioop(struct pcicore_info *pi, uin
 		}
 		udelay(1000);
--
 		while ((resid > 0) && (p = _dma_getnextrxp(di, false))) {
 			tail->next = p;
 			pkt_len = min_t(uint, resid, di->rxbufsize);
@@ -941,7 +946,13 @@ struct sk_buff *dma_rx(struct dma_pub *p
 
 			tail = p;
--
-	while ((p = dma_getnexttxp(pub, range))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while ((p = dma_getnexttxp(pub, range))) {
 		/* For unframed data, we don't have any packets to free */
 		if (!(di->dma.dmactrlflags & DMA_CTRL_UNFRAMED))
 			brcmu_pkt_buf_free_skb(p);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (i != end) {
 		skb = (struct sk_buff *)di->txp[i];
 		if (skb != NULL) {
@@ -1422,5 +1449,11 @@ void dma_walk_packets(struct dma_pub *dm
 			(callback_fnc)(tx_info, arg_a);
 		}
--
-	while (tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (tmp) {
 		if (tmp->next == t) {
 			tmp->next = t->next;
 #ifdef BCMDBG
@@ -1542,6 +1547,12 @@ void brcms_free_timer(struct brcms_timer
 			return;
--
 	while (len > 0) {
 		memcpy(&word, buf, sizeof(u32));
 
@@ -1588,6 +1593,12 @@ brcms_b_write_template_ram(struct brcms_
 
 		buf = (u8 *) buf + sizeof(u32);
--
 	while ((p = head) != NULL) {
 		struct d11rxhdr_le *rxh_le;
 		struct d11rxhdr *rxh;
@@ -8391,6 +8407,12 @@ brcms_b_recv(struct brcms_hardware *wlc_
 		rxh->RxChan = le16_to_cpu(rxh_le->RxChan);
 
--
-	while (rccal_stepsize >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rccal_stepsize >= 0) {
 		write_radio_reg(pi,
 				(RADIO_2056_RX_RXLPF_RCCAL_LPC |
 				 radio_addr_offset_rx), rccal_val);
@@ -27549,6 +27554,12 @@ wlc_phy_rc_sweep_nphy(struct brcms_phy *
 					(RADIO_2056_RX_RXLPF_RCCAL_LPC |
--
 	while (precision--) {
 		quotient <<= 1;
 		if (remainder >= roundup) {
@@ -1031,6 +1036,12 @@ wlc_lcnphy_qdiv_roundup(u32 dividend, u3
 		} else {
 			remainder <<= 1;
--
 	while (read_phy_reg(pi, 0x481) & (0x1 << 9)) {
 
 		if (wait_count > (10 * 500)) {
@@ -1222,6 +1238,12 @@ wlc_lcnphy_rx_iq_est(struct brcms_phy *p
 		}
 		udelay(100);
--
 	while (div_frac >= fref3) {
 		div_int++;
 		div_frac -= fref3;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (strptr < 0x8000) {
 		val = R_REG(&pi->regs->tplatewrdata);
 		imag = ((val >> 16) & 0x3ff);
@@ -3594,6 +3632,12 @@ wlc_lcnphy_samp_cap(struct brcms_phy *pi
 		}
 
--
-		while ((*gain_index <= (s32) max_index)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((*gain_index <= (s32) max_index)
 		       && (received_power < 700)) {
 			wlc_lcnphy_set_rx_gain(pi,
 					       lcnphy_23bitgaincode_table
@@ -5069,6 +5118,12 @@ static u32 wlc_lcnphy_get_receive_power(
 					pi_lcn->
--
 		while ((op >> 31) == (op >> 30)) {
 			u16extraSignBits++;
 			op = op << 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (srv->flags & SRFL_MORE) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				    while (srv->flags & SRFL_MORE) {
 				srv++;
 				if (srv->off == 0)
 					continue;
@@ -986,6 +991,12 @@ _initvars_srom_pci(u8 sromrev, u16 *srom
 								   mask)) <<
--
-	while (skb) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (skb) {
 		nskb = skb->next;
 		skb->next = NULL;
 
@@ -61,6 +66,12 @@ void brcmu_pkt_buf_free_skb(struct sk_bu
 
--
 	while (p) {
 		if (fn == NULL || (*fn) (p, arg)) {
 			bool head = (p == q->head);
@@ -243,6 +259,12 @@ brcmu_pktq_pflush(struct pktq *pq, int p
 			prev = p;
 			p = p->prev;
--
 	while (i < BRCMF_MAX_IFS) {
 		if (drvr_priv->iflist[i] && drvr_priv->iflist[i]->ndev == ndev)
 			return i;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (ntimes && pend) {
 		if (pend) {
 			set_current_state(TASK_INTERRUPTIBLE);
@@ -1315,6 +1331,12 @@ int brcmf_netdev_wait_pend8021x(struct n
 			ntimes--;
 		}
--
 		while ((s = strstr(p, "\n")) != NULL) {
 			*s = '\0';
 			printk(KERN_DEBUG"%s\n", p);
 			p = s + 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (idx < 0) {
 		idx += 40;
 		factor *= 10;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (mw_uint < QDBM_TABLE_LOW_BOUND) {
 		mw_uint *= 10;
 		offset -= 40;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (totlen >= 2) {
 		int len = elt->len;
 
@@ -2183,6 +2210,12 @@ static struct brcmf_tlv *brcmf_parse_tlv
 
 		elt = (struct brcmf_tlv *) ((u8 *) elt + (len + 2));
--
-	while (!list_empty(&cfg_priv->evt_q_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cfg_priv->evt_q_list)) {
 		e = list_first_entry(&cfg_priv->evt_q_list,
 				     struct brcmf_cfg80211_event_q, evt_q_list);
 		list_del(&e->evt_q_list);
 		kfree(e);
+		if (_cur < timeout) {
--
-		while (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
 			clkctl = brcmf_sdcard_cfg_read(bus->sdiodev,
 						       SDIO_FUNC_1,
 						       SBSDIO_FUNC1_CHIPCLKCSR,
@@ -880,6 +885,12 @@ static int brcmf_sdbrcm_htclk(struct brc
 				break;
--
 	while (c->last != idx) {
 		for (n = 0; n < CONSOLE_LINE_MAX - 2; n++) {
 			if (c->last == idx) {
@@ -2888,6 +2904,12 @@ static int brcmf_sdbrcm_readconsole(stru
 			line[n] = 0;
 			printk(KERN_DEBUG "CONSOLE: %s\n", line);
--
 	while ((len =
 		brcmf_sdbrcm_get_image((char *)memptr, MEMBLOCK, bus))) {
 		ret = brcmf_sdbrcm_membytes(bus, true, offset, memptr, len);
@@ -3439,6 +3466,12 @@ static int brcmf_sdbrcm_download_code_fi
 		}
 
--
-	while (enable != ready) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (enable != ready) {
 		ready = brcmf_sdcard_cfg_read(bus->sdiodev, SDIO_FUNC_0,
 					      SDIO_CCCR_IORx, NULL);
 		if (time_after(jiffies, timeout))
@@ -3741,6 +3779,12 @@ int brcmf_sdbrcm_bus_init(struct brcmf_p
 		else if (time_after(jiffies, timeout - BRCMF_WAIT_F2RDY + 50))
--
 		while (baseband_attenuation < 0 && radio_attenuation > 0) {
 			baseband_attenuation += 4;
 			radio_attenuation--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (baseband_attenuation > 11 && radio_attenuation < 9) {
 			baseband_attenuation -= 4;
 			radio_attenuation++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-	while (i < octets - 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i < octets - 1) {
 		data = tx_get_next_word(txhdr, packet,
 					sizeof(struct b43legacy_txhdr_fw3), &i);
 		b43legacy_pio_write(queue, B43legacy_PIO_TXDATA, data);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-		while (j <= t->range) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (j <= t->range) {
 			int r = islpci_mgt_transaction(priv->ndev, PIMFOR_OP_SET,
 						      oid, data, t->size,
 						      &response);
@@ -617,6 +622,12 @@ mgt_commit_list(islpci_private *priv, en
 			j++;
--
-	while (priv->free_data_tx !=
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (priv->free_data_tx !=
 	       le32_to_cpu(control_block->
 			   device_curr_frag[ISL38XX_CB_TX_DATA_LQ])) {
 		/* read the index of the first fragment to be freed */
@@ -70,6 +75,12 @@ islpci_eth_cleanup_transmit(islpci_priva
 		}
--
 	while (length > 0) {
 		printk("[%02x]", *buffer & 255);
 		length--;
 		buffer++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((void *) h < data + len) {
 		if (h->flags & PIMFOR_FLAG_LITTLE_ENDIAN) {
 			le32_to_cpus(&h->oid);
@@ -98,6 +114,12 @@ pimfor_decode_header(void *data, int len
 		if (h->oid != OID_INL_TUNNEL)
 			return h;
--
 	while (curr - priv->index_mgmt_rx < ISL38XX_CB_MGMT_QSIZE) {
 		u32 index = curr % ISL38XX_CB_MGMT_QSIZE;
 		struct islpci_membuf *buf = &priv->mgmt_rx[index];
@@ -153,6 +180,12 @@ islpci_mgmt_rx_fill(struct net_device *n
 		 * device */
 		wmb();
--
 	while (timeout_left > 0) {
 		int timeleft;
 		struct islpci_mgmtframe *frame;
@@ -499,6 +537,12 @@ islpci_mgt_transaction(struct net_device
 			islpci_trigger(priv);
 		}
--
-			while (reg = readl(device_base + ISL38XX_CTRL_STAT_REG),
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (reg = readl(device_base + ISL38XX_CTRL_STAT_REG),
 			       (reg & ISL38XX_CTRL_STAT_SLEEPMODE) == 0) {
 				udelay(ISL38XX_WRITEIO_DELAY);
 #if VERBOSE > SHOW_ERROR_MESSAGES
 				counter++;
 #endif
--
 	while ((i < IW_MAX_BITRATES) && (*data != 0)) {
 		/*       the result must be in bps. The card gives us 500Kbps */
 		range->bitrate[i] = *data * 500000;
 		i++;
 		data++;
+		if (_cur < timeout) {
--
-	while (pos < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (pos < end) {
 		if (pos + 2 + pos[1] > end) {
 			printk(KERN_DEBUG "Parsing Beacon/ProbeResp failed "
 			       "for %pM\n", addr);
@@ -2236,6 +2252,12 @@ prism54_process_bss_data(islpci_private
 			return;
--
-		while (fw_len > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			    unsigned long long timeout;
+			    timeout = rdstcll(start) + delta;
+			    while (fw_len > 0) {
 			long _fw_len =
 			    (fw_len >
 			     ISL38XX_MEMORY_WINDOW_SIZE) ?
@@ -131,11 +136,22 @@ isl_upload_firmware(islpci_private *priv
 
--
 			while (_fw_len > 0) {
 				/* use non-swapping writel() */
 				__raw_writel(*fw_ptr, dev_fw_ptr);
 				fw_ptr++, dev_fw_ptr++;
 				_fw_len -= 4;
+				if (_cur < timeout) {
--
-			while (isl38xx_in_queue(priv->control_block,
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (isl38xx_in_queue(priv->control_block,
 						ISL38XX_CB_RX_DATA_LQ) != 0) {
 #if VERBOSE > SHOW_ERROR_MESSAGES
 				DEBUG(SHOW_TRACING,
 				      "Received frame in Data Low Queue\n");
 #endif
--
-	while (full_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (full_len) {
 		if (full_len < 254)
 			full_len = 0;
 		else
@@ -319,6 +324,12 @@ static u16 wl3501_get_tx_buffer(struct w
 			ret = 0;
--
 	while (ptr) {
 		u16 next;
 
@@ -343,6 +359,12 @@ static void wl3501_free_tx_buffer(struct
 		wl3501_get_from_wla(this, ptr, &next, sizeof(next));
 		this->tx_buffer_tail = ptr;
--
 		while (pktlen > 0) {
 			if (pktlen > 254) {
 				tmplen = 254;
@@ -530,6 +557,12 @@ static int wl3501_send_pkt(struct wl3501
 			pdata += tmplen;
 			wl3501_get_from_wla(this, bf, &next, sizeof(next));
--
 	while (size > 0) {
 		if (size > WL3501_BLKSZ - 5) {
 			wl3501_get_from_wla(this, next_addr + 5, data,
@@ -788,6 +826,12 @@ static u16 wl3501_receive(struct wl3501_
 			wl3501_get_from_wla(this, next_addr + 5, data, size);
 			size = 0;
--
 	while ((next - this->tx_buffer_head) < this->tx_buffer_size) {
 		this->tx_buffer_cnt++;
 		wl3501_set_to_wla(this, ptr, &next, sizeof(next));
 		ptr = next;
 		next = ptr + WL3501_BLKSZ;
+		if (_cur < timeout) {
--
 		while (*ptr) {
 			if ((*ptr & 0x7f) == priv->data_rate) {
 				ret = 0;
 				goto done;
 			}
 			ptr++;
--
 	while (((wrptr & MWIFIEX_RXBD_MASK) !=
 		(card->rxbd_rdptr & MWIFIEX_RXBD_MASK)) ||
 	       ((wrptr & MWIFIEX_BD_FLAG_ROLLOVER_IND) ==
@@ -903,7 +908,13 @@ static int mwifiex_pcie_process_recv_dat
 		dev_dbg(adapter->dev, "info: RECV DATA: Received packet from "
 				      "firmware successfully\n");
--
 	while (adapter->int_status & HOST_INTR_MASK) {
 		if (adapter->int_status & HOST_INTR_DNLD_DONE) {
 			adapter->int_status &= ~HOST_INTR_DNLD_DONE;
@@ -1650,6 +1666,12 @@ static int mwifiex_process_int_status(st
 			}
 
--
 	while (count) {
 		if (!memcmp(iebody->ptk_body, oui, sizeof(iebody->ptk_body)))
 			return MWIFIEX_OUI_PRESENT;
@@ -101,6 +106,12 @@ mwifiex_search_oui_in_ie(struct ie_body
 		if (count)
 			iebody = (struct ie_body *) ((u8 *) iebody +
--
 		while (tlv_idx < max_chan_per_scan
 		       && tmp_chan_list->chan_number && !done_early) {
 
@@ -674,6 +690,12 @@ mwifiex_scan_channel_list(struct mwifiex
 				|| tmp_chan_list->chan_number == 6
 				|| tmp_chan_list->chan_number == 11))
--
 	while (bytes_left >= 2) {
 		element_id = *current_ptr;
 		element_len = *(current_ptr + 1);
@@ -1267,6 +1294,12 @@ mwifiex_update_bss_desc_with_ie(struct m
 		/* Need to account for IE ID and IE Len */
 		bytes_left -= (element_len + 2);
--
 	}	/* while (bytes_left > 2) */
 	return ret;
 }
diff -u -p a/net/wireless/mwifiex/wmm.c b/net/wireless/mwifiex/wmm.c
--- a/net/wireless/mwifiex/wmm.c
+++ b/net/wireless/mwifiex/wmm.c
--
 	while ((resp_len >= sizeof(tlv_hdr->header)) && valid) {
 		tlv_hdr = (struct mwifiex_ie_types_data *) curr;
 		tlv_len = le16_to_cpu(tlv_hdr->header.len);
@@ -742,6 +747,12 @@ int mwifiex_ret_wmm_get_status(struct mw
 
 		curr += (tlv_len + sizeof(tlv_hdr->header));
--
 	while (tlv_buf && tlv_buf_len > 0) {
 		tlv = (*tlv_buf);
 		tlv = tlv | (*(tlv_buf + 1) << 8);
@@ -313,6 +318,12 @@ static int mwifiex_ret_tx_rate_cfg(struc
 		head = (struct mwifiex_ie_types_header *) tlv_buf;
 		tlv_buf += le16_to_cpu(head->len) + sizeof(*head);
--
 		while (length) {
 			pg++;
 			if (max_power < pg->power_max)
@@ -387,6 +403,12 @@ static int mwifiex_get_power_level(struc
 				min_power = pg->power_min;
 
--
 		while (!skb_queue_empty(&list)) {
 			rx_skb = __skb_dequeue(&list);
 			ret = mwifiex_recv_packet(adapter, rx_skb);
 			if (ret == -1)
 				dev_err(adapter->dev, "Rx of A-MSDU failed");
+				if (_cur < timeout) {
--
 	while ((iwl_legacy_rx_queue_space(rxq) > 0) && (rxq->free_count)) {
 		/* The overwritten rxb must be a used one */
 		rxb = rxq->queue[rxq->write];
@@ -250,6 +255,12 @@ void iwl4965_rx_queue_restock(struct iwl
 		rxq->queue[rxq->write] = rxb;
 		rxq->write = (rxq->write + 1) & RX_QUEUE_MASK;
--
 	while (1) {
 		spin_lock_irqsave(&rxq->lock, flags);
 		if (list_empty(&rxq->rx_used)) {
@@ -352,6 +368,12 @@ static void iwl4965_rx_allocate(struct i
 		priv->alloc_rxb_page++;
 
--
 	while (!list_empty(&priv->free_frames)) {
 		element = priv->free_frames.next;
 		list_del(element);
 		kfree(list_entry(element, struct iwl3945_frame, list));
 		priv->frames_count--;
+		if (_cur < timeout) {
--
 	while ((iwl_legacy_rx_queue_space(rxq) > 0) && (rxq->free_count)) {
 		/* Get next free Rx buffer, remove from free list */
 		element = rxq->rx_free.next;
@@ -985,6 +1001,12 @@ static void iwl3945_rx_queue_restock(str
 		rxq->queue[rxq->write] = rxb;
 		rxq->write = (rxq->write + 1) & RX_QUEUE_MASK;
--
 	while (i != r) {
 		int len;
 
@@ -1317,6 +1344,12 @@ static void iwl3945_rx_handle(struct iwl
 				count = 0;
 			}
--
 		while (iwl3945_hw_get_temperature(priv) == 0) {
 			thermal_spin++;
 			udelay(10);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-	while (size && (PAGE_SIZE - len)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size && (PAGE_SIZE - len)) {
 		hex_dump_to_buffer(data + ofs, size, 16, 1, buf + len,
 				   PAGE_SIZE - len, 1);
 		len = strlen(buf);
@@ -3305,6 +3354,12 @@ static ssize_t iwl3945_show_measurement(
 
--
-	while (sent_bitmap) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sent_bitmap) {
 		ack = sent_bitmap & 1ULL;
 		successes += ack;
 		IWL_DEBUG_TX_REPLY(priv, "%s ON i=%d idx=%d raw=%d\n",
@@ -1207,6 +1212,12 @@ static int iwl4965_tx_status_reply_compr
 			agg->start_idx + i);
--
 	while (tl->queue_count &&
 	       (tl->time_stamp < oldest_time)) {
 		tl->total -= tl->packet_count[tl->head];
@@ -260,6 +265,12 @@ iwl4965_rs_tl_rm_old_stats(struct iwl_tr
 		tl->head++;
 		if (tl->head >= TID_QUEUE_MAX_SIZE)
--
 	while (attempts > 0) {
 		if (window->counter >= IWL_RATE_MAX_WINDOW) {
 
@@ -465,6 +481,12 @@ static int iwl4965_rs_collect_tx_data(st
 		}
 
--
 	while (index < LINK_QUAL_MAX_RETRY_NUM) {
 		/* Repeat initial/next rate.
 		 * For legacy IWL_NUMBER_TRY == 1, this loop will not execute.
 		 * For HT IWL_HT_NUMBER_TRY == 3, this executes twice. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
--
 		while (repeat_rate > 0 && (index < LINK_QUAL_MAX_RETRY_NUM)) {
 			if (is_legacy(tbl_type.lq_type)) {
 				if (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)
@@ -2493,6 +2525,12 @@ static void iwl4965_rs_fill_link_cmd(str
 					cpu_to_le32(new_rate);
 			repeat_rate--;
--
 	while (q->write_ptr != q->read_ptr) {
 		priv->cfg->ops->lib->txq_free_tfd(priv, txq);
 		q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (q->read_ptr != q->write_ptr) {
 		i = iwl_legacy_get_cmd_index(q, q->read_ptr, 0);
 
@@ -164,6 +180,12 @@ void iwl_legacy_cmd_queue_unmap(struct i
 		}
 
--
 	while (retries > 0) {
 		if (window->counter >= IWL_RATE_MAX_WINDOW) {
 
@@ -303,6 +308,12 @@ static void iwl3945_collect_tx_data(stru
 		}
 
--
 	while (retries > 1) {
 		if ((retries - 1) < priv->retry_rate) {
 			current_count = (retries - 1);
@@ -514,6 +530,12 @@ static void iwl3945_rs_tx_status(void *p
 		retries -= current_count;
 
--
 	while (!list_empty(&priv->free_frames)) {
 		element = priv->free_frames.next;
 		list_del(element);
 		kfree(list_entry(element, struct iwl_frame, list));
 		priv->frames_count--;
+		if (_cur < timeout) {
--
 	while (i != r) {
 		int len;
 
@@ -755,6 +771,12 @@ void iwl4965_rx_handle(struct iwl_priv *
 				count = 0;
 			}
--
 	while (pos < size) {
 		tlv_h = (struct mrvl_ie_header *) tlv;
 		if (!tlv_h->len)
@@ -222,6 +227,12 @@ static void *lbs_tlv_find(uint16_t tlv_t
 		length = le16_to_cpu(tlv_h->len) + sizeof(*tlv_h);
 		pos += length;
--
 	while (size) {
 		ret = if_sdio_wait_status(card, FW_DL_READY_STATUS);
 		if (ret)
@@ -518,6 +523,12 @@ static int if_sdio_prog_helper(struct if
 
 		firmware += chunk_size;
--
 	while (size) {
 		ret = if_sdio_wait_status(card, FW_DL_READY_STATUS);
 		if (ret)
@@ -623,7 +639,12 @@ static int if_sdio_prog_real(struct if_s
 		if (req_size > size)
 			req_size = size;
--
-		while (req_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (req_size) {
 			chunk_size = min(req_size, (size_t)512);
 
 			memcpy(chunk_buffer, firmware, chunk_size);
@@ -639,6 +660,18 @@ static int if_sdio_prog_real(struct if_s
 			firmware += chunk_size;
--
 	while (card->packets) {
 		packet = card->packets;
 		card->packets = card->packets->next;
 		kfree(packet);
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (card->packets) {
 		packet = card->packets;
 		card->packets = card->packets->next;
 		kfree(packet);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (1) {
 		u16 val;
 		err = spu_read_u16(card, reg, &val);
@@ -313,6 +318,12 @@ static int spu_wait_for_u16(struct if_sp
 			       __func__, val, target_mask, target);
 			return -ETIMEDOUT;
--
-	while (bytes_remaining > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bytes_remaining > 0) {
 		/*
 		 * Scratch pad 1 should contain the number of bytes we
 		 * want to download to the firmware
@@ -516,6 +532,12 @@ static int if_spi_prog_helper_firmware(s
 			goto out;
--
-	while (priv->scan_channel < last_channel) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (priv->scan_channel < last_channel) {
 		struct chanscanparamset *param = (void *) tlv;
 
 		param->radiotype = CMD_SCAN_RADIO_TYPE_BG;
@@ -229,6 +234,12 @@ static int lbs_add_channel_list_tlv(stru
 		}
--
 		while (left >= 2) {
 			u8 id, elen;
 			id = *pos++;
@@ -615,6 +631,12 @@ static int lbs_ret_scan(struct lbs_priva
 			}
 			left -= elen;
--
 	while (list_len) {
 		if (!memcmp(list, mac, ETH_ALEN))
 			return 1;
 		list += ETH_ALEN;
 		list_len--;
+		if (_cur < timeout) {
--
 	while (iter && iter->helper) {
 		if (iter->model != card_model)
 			goto next;
@@ -1265,7 +1281,13 @@ int lbs_get_firmware(struct device *dev,
 
   next:
--
-	while (priv->cur_cmd != NULL || priv->dnld_sent != DNLD_RES_RECEIVED) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (priv->cur_cmd != NULL || priv->dnld_sent != DNLD_RES_RECEIVED) {
 		spin_unlock_irqrestore(&priv->driver_lock, flags);
 		if (wait_event_interruptible(priv->waitq,
 				(priv->cur_cmd == NULL &&
@@ -946,6 +951,12 @@ static int if_usb_prog_firmware(struct i
 			return -ERESTARTSYS;
--
 	while (!skb_queue_empty(&rx_queue)) {
 		_skb = skb_dequeue(&rx_queue);
 		_rtl_usb_rx_process_agg(hw, _skb);
 		ieee80211_rx_irqsafe(hw, _skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((_skb = skb_dequeue(&rtlusb->tx_skb_queue[i]))) {
 			rtlusb->usb_tx_cleanup(hw, _skb);
 			txinfo = IEEE80211_SKB_CB(_skb);
 			ieee80211_tx_info_clear_status(txinfo);
 			txinfo->flags |= IEEE80211_TX_STAT_ACK;
 			ieee80211_tx_status_irqsafe(hw, _skb);
--
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -1252,6 +1257,12 @@ u8 *rtl_find_ie(u8 *data, unsigned int l
 			return pos;
 
--
 	while (pos < end) {
 		if (pos[0] == 221) {
 			vendor_ie.length = pos[1];
@@ -1404,6 +1420,12 @@ static bool rtl_find_221_ie(struct ieee8
 			return false;
 
--
 	while ((regu1 & BIT(5)) && (delay > 0)) {
 		regu1 = rtl_read_byte(rtlpriv, 0x554);
 		delay--;
 		/* We delay only 50us to prevent
 		 * being scheduled out. */
 		udelay(50);
--
 			while (rate_cfg > 0x1) {
 				rate_cfg = (rate_cfg >> 1);
 				rate_index++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
--
 	while (wait-- >= 10 && rtlpriv->psc.pwrdomain_protect) {
 		if (rtlpriv->psc.pwrdomain_protect)
 			mdelay(20);
 		else
 			break;
+			if (_cur < timeout) {
--
 	while (remain > 0) {
 		pfwbuf[fwlen] = 0;
 		fwlen++;
 		remain--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (true) {
 		spin_lock_irqsave(&rtlpriv->locks.h2c_lock, flag);
 		if (rtlhal->h2c_setinprogress) {
@@ -301,7 +317,12 @@ static void _rtl92c_fill_h2c_command(str
 				 ("H2C set in progress! Wait to set.."
 				  "element_id(%d).\n", element_id));
--
-			while (rtlhal->h2c_setinprogress) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (rtlhal->h2c_setinprogress) {
 				spin_unlock_irqrestore(&rtlpriv->locks.h2c_lock,
 						       flag);
 				h2c_waitcounter++;
@@ -314,6 +335,12 @@ static void _rtl92c_fill_h2c_command(str
 					return;
--
 	while (!bwrite_sucess) {
diff -u -p a/net/wireless/rtlwifi/rtl8192c/phy_common.c b/net/wireless/rtlwifi/rtl8192c/phy_common.c
--- a/net/wireless/rtlwifi/rtl8192c/phy_common.c
+++ b/net/wireless/rtlwifi/rtl8192c/phy_common.c
@@ -2005,12 +2005,23 @@ void _rtl92c_phy_set_rf_sleep(struct iee
 	rtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);
--
 	while (u4b_tmp != 0 && delay > 0) {
 		rtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x0);
 		rtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);
 		rtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x40);
 		u4b_tmp = rtl_get_rfreg(hw, RF90_PATH_A, 0, RFREG_OFFSET_MASK);
 		delay--;
--
 		while ((!(u4tmp & BIT(11))) && timecount <= timeout) {
 			mdelay(50);
 			timecount += 50;
 			u4tmp = rtl_get_rfreg(hw, (enum radio_path)index,
 					      RF_SYN_G6, BRFREGOFFSETMASK);
+			if (_cur < timeout) {
--
 	while (rtlpriv->mac80211.act_scanning && timecount < timeout) {
 		udelay(50);
 		timecount += 50;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (rtlphy->lck_inprogress && timecount < timeout) {
 		mdelay(50);
 		timecount += 50;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (u4btmp != 0 && delay > 0) {
 		rtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x0);
 		rtl_set_rfreg(hw, RF90_PATH_A, 0x00, BRFREGOFFSETMASK, 0x00);
 		rtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x40);
 		u4btmp = rtl_get_rfreg(hw, RF90_PATH_A, 0, BRFREGOFFSETMASK);
 		delay--;
--
 	while (remain > 0) {
 		pfwbuf[fwlen] = 0;
 		fwlen++;
 		remain--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (true) {
 		spin_lock_irqsave(&rtlpriv->locks.h2c_lock, flag);
 		if (rtlhal->h2c_setinprogress) {
@@ -392,7 +408,12 @@ static void _rtl92d_fill_h2c_command(str
 				 ("H2C set in progress! Wait to set.."
 				 "element_id(%d).\n", element_id));
--
-			while (rtlhal->h2c_setinprogress) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (rtlhal->h2c_setinprogress) {
 				spin_unlock_irqrestore(&rtlpriv->locks.h2c_lock,
 						       flag);
 				h2c_waitcounter++;
@@ -406,6 +427,12 @@ static void _rtl92d_fill_h2c_command(str
 
--
 	while (!bwrite_sucess) {
 		wait_writeh2c_limmit--;
diff -u -p a/net/wireless/rtlwifi/rtl8192de/hw.c b/net/wireless/rtlwifi/rtl8192de/hw.c
--- a/net/wireless/rtlwifi/rtl8192de/hw.c
+++ b/net/wireless/rtlwifi/rtl8192de/hw.c
@@ -199,9 +199,20 @@ void rtl92de_set_hw_reg(struct ieee80211
--
 		while (rate_cfg > 0x1) {
 			rate_cfg = (rate_cfg >> 1);
 			rate_index++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while ((bytetmp & BIT(0)) && retry < 1000) {
 		retry++;
 		bytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO + 1);
 		udelay(50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 				while ((retry_cnts++ < 100) &&
 				       (FEN_CPUEN & rtl_read_word(rtlpriv,
 				       REG_SYS_FUNC_EN))) {
 					udelay(50);
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 			while (rate_cfg > 0x1) {
 				rate_cfg >>= 1;
 				rate_index++;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
 	while (u4b_tmp != 0 && delay > 0) {
 		rtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x0);
 		rtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);
 		rtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x40);
 		u4b_tmp = rtl_get_rfreg(hw, RF90_PATH_A, 0, RFREG_OFFSET_MASK);
 		delay--;
--
 			while (rate_cfg > 0x1) {
 				rate_cfg = (rate_cfg >> 1);
 				rate_index++;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
 	while ((bytetmp & BIT(0)) && retry < 1000) {
 		retry++;
 		udelay(50);
@@ -682,6 +698,12 @@ static bool _rtl92ce_init_mac(struct iee
 								       0xEC),
 							bytetmp));
--
-	while (!(((value32 >> 24) & 0xff) & 0x80) && (retry < 10000)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(((value32 >> 24) & 0xff) & 0x80) && (retry < 10000)) {
 		value32 = rtl_read_dword(rtlpriv,
 					 rtlpriv->cfg->maps[EFUSE_CTRL]);
 		retry++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while ((*rtemp8 != 0xFF) && (efuse_addr < efuse_len)) {
 		offset = ((*rtemp8 >> 4) & 0x0f);
 
@@ -332,6 +348,12 @@ void read_efuse(struct ieee80211_hw *hw,
 			efuse_utilized++;
 			efuse_addr++;
--
 	while (!(0x80 & rtl_read_byte(rtlpriv,
 				      rtlpriv->cfg->maps[EFUSE_CTRL] + 3))
 	       && (tmpidx < 100)) {
 		tmpidx++;
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while ((0x80 & rtl_read_byte(rtlpriv,
 				     rtlpriv->cfg->maps[EFUSE_CTRL] + 3))
 	       && (tmpidx < 100)) {
 		tmpidx++;
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (continual && (efuse_addr < EFUSE_MAX_SIZE)) {
 		if (readstate & PG_STATE_HEADER) {
 			if (efuse_one_byte_read(hw, efuse_addr, &efuse_data)
@@ -736,6 +785,12 @@ static int efuse_pg_packet_read(struct i
 			readstate = PG_STATE_HEADER;
 		}
--
 	while (continual && (efuse_addr <
 	       (EFUSE_MAX_SIZE - EFUSE_OOB_PROTECT_BYTES))) {
 
@@ -1002,6 +1062,12 @@ static int efuse_pg_packet_write(struct
 					("efuse PG_STATE_HEADER-3\n"));
 			}
--
 	while (continual && efuse_one_byte_read(hw, efuse_addr, &efuse_data)
 	       && (efuse_addr < EFUSE_MAX_SIZE)) {
 		if (efuse_data != 0xFF) {
@@ -1188,6 +1259,12 @@ static u16 efuse_get_current_size(struct
 		} else {
 			continual = false;
--
 		while (!mac->act_scanning &&
 		       rtlpriv->psc.rfpwr_state == ERFON) {
 			struct rtl_tcb_desc tcb_desc;
@@ -508,6 +513,12 @@ static void _rtl_pci_tx_chk_waitq(struct
 							   &tcb_desc, tid);
 
--
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb;
@@ -605,6 +621,12 @@ static void _rtl_pci_tx_isr(struct ieee8
 		}
 tx_status_ok:
--
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb = __skb_dequeue(&ring->queue);
@@ -1160,6 +1187,12 @@ static void _rtl_pci_free_tx_ring(struct
 				 skb->len, PCI_DMA_TODEVICE);
 		kfree_skb(skb);
--
-			while (skb_queue_len(&ring->queue)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (skb_queue_len(&ring->queue)) {
 				struct rtl_tx_desc *entry =
 				    &ring->desc[ring->idx];
 				struct sk_buff *skb =
@@ -1300,6 +1338,12 @@ int rtl_pci_reset_trx_ring(struct ieee80
 						 skb->len, PCI_DMA_TODEVICE);
--
 	while (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {
 		mdelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {
 		mdelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((void *) pdr <= end) &&
 	       (pdr_id(pdr) != PDI_END)) {
 		/*
@@ -167,6 +172,12 @@ hermes_find_pdr(const struct pdr *first_
 			return pdr;
 
--
 	while (((void *) pdi <= end) &&
 	       (pdi_id(pdi) != PDI_END)) {
 
@@ -187,6 +203,12 @@ hermes_find_pdi(const struct pdi *first_
 			return pdi;
 
--
 	while (((void *) pdi <= pda_end) &&
 	       (pdi_id(pdi) != PDI_END)) {
 		ret = hermes_plug_pdi(hw, pdr, pdi, pdr_end);
@@ -243,6 +270,12 @@ int hermes_apply_pda(struct hermes *hw,
 
 		/* Increment to the next PDI */
--
 	while (((void *) blk <= end) &&
 	       (dblock_addr(blk) != BLOCK_END)) {
 		len = dblock_len(blk);
 		total_len += sizeof(*blk) + len;
 		blk = (struct dblock *) &blk->data[len];
+		if (_cur < timeout) {
--
 	while (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {
 		mdelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((reg & HERMES_CMD_BUSY) && k) {
 		k--;
 		udelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((!(reg & HERMES_EV_CMD)) && k) {
 		k--;
 		udelay(10);
 		reg = hermes_read_regn(hw, EVSTAT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (k && (reg & HERMES_CMD_BUSY)) {
 		if (reg == 0xffff) /* Special case - the card has probably been
 				      removed, so don't wait for the timeout */
@@ -223,6 +250,12 @@ static int hermes_init(struct hermes *hw
 		k--;
 		udelay(1);
--
 	while ((!(reg & HERMES_EV_CMD)) && k) {
 		k--;
 		udelay(10);
 		reg = hermes_read_regn(hw, EVSTAT);
+		if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((!(reg & HERMES_EV_ALLOC)) && k) {
 		k--;
 		udelay(10);
 		reg = hermes_read_regn(hw, EVSTAT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((reg & HERMES_OFFSET_BUSY) && k) {
 		k--;
 		udelay(1);
 		reg = hermes_read_reg(hw, oreg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((reg & (HERMES_OFFSET_BUSY | HERMES_OFFSET_ERR)) && k) {
 		k--;
 		udelay(1);
 		reg = hermes_read_reg(hw, oreg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len--) {
 		obuf = hex_byte_pack(obuf, *ibuf++);
 		*obuf++ = '-';
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (time_before_eq(jiffies, timeout)) {
 		if (!test_bit(STATUS_SCAN_HW, &priv->shrd->status))
 			goto finished;
 		msleep(20);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((iwl_rx_queue_space(rxq) > 0) && (rxq->free_count)) {
 		/* The overwritten rxb must be a used one */
 		rxb = rxq->queue[rxq->write];
@@ -218,6 +223,12 @@ static void iwlagn_rx_queue_restock(stru
 		rxq->queue[rxq->write] = rxb;
 		rxq->write = (rxq->write + 1) & RX_QUEUE_MASK;
--
 	while (1) {
 		spin_lock_irqsave(&rxq->lock, flags);
 		if (list_empty(&rxq->rx_used)) {
@@ -330,6 +346,12 @@ static void iwlagn_rx_allocate(struct iw
 		rxq->free_count++;
 
--
 	while (i != r) {
 		int len, err;
 		u16 sequence;
@@ -526,6 +553,12 @@ static void iwl_rx_handle(struct iwl_tra
 				count = 0;
 			}
--
-	while (trans_pcie->ict_tbl[trans_pcie->ict_index]) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (trans_pcie->ict_tbl[trans_pcie->ict_index]) {
 
 		val |= le32_to_cpu(trans_pcie->ict_tbl[trans_pcie->ict_index]);
 		IWL_DEBUG_ISR(trans, "ICT index %d value 0x%08X\n",
@@ -1400,6 +1438,12 @@ irqreturn_t iwl_isr_ict(int irq, void *d
 		trans_pcie->ict_index =
--
 	while (tl->queue_count &&
 	       (tl->time_stamp < oldest_time)) {
 		tl->total -= tl->packet_count[tl->head];
@@ -276,6 +281,12 @@ static void rs_tl_rm_old_stats(struct iw
 		tl->head++;
 		if (tl->head >= TID_QUEUE_MAX_SIZE)
--
 	while (attempts > 0) {
 		if (window->counter >= IWL_RATE_MAX_WINDOW) {
 
@@ -526,6 +542,12 @@ static int rs_collect_tx_data(struct iwl
 		}
 
--
 	while (index < LINK_QUAL_MAX_RETRY_NUM) {
 		/* Repeat initial/next rate.
 		 * For legacy IWL_NUMBER_TRY == 1, this loop will not execute.
 		 * For HT IWL_HT_NUMBER_TRY == 3, this executes twice. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
--
 		while (repeat_rate > 0 && (index < LINK_QUAL_MAX_RETRY_NUM)) {
 			if (is_legacy(tbl_type.lq_type)) {
 				if (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)
@@ -3004,6 +3036,12 @@ static void rs_fill_link_cmd(struct iwl_
 					cpu_to_le32(new_rate);
 			repeat_rate--;
--
 		while (!skb_queue_empty(&skbs)) {
 			skb = __skb_dequeue(&skbs);
 			hdr = (struct ieee80211_hdr *)skb->data;
@@ -830,6 +835,12 @@ int iwlagn_rx_reply_tx(struct iwl_priv *
 			ieee80211_tx_status_irqsafe(priv->hw, skb);
 
--
 	while (!skb_queue_empty(&reclaimed_skbs)) {
 		struct ieee80211_hdr *hdr;
 		struct ieee80211_tx_info *info;
@@ -973,6 +989,12 @@ int iwlagn_rx_reply_compressed_ba(struct
 		}
 
--
-	while (q->write_ptr != q->read_ptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (q->write_ptr != q->read_ptr) {
 		/* The read_ptr needs to bound by q->n_window */
 		iwlagn_txq_free_tfd(trans, txq, get_cmd_index(q, q->read_ptr),
 				    dma_dir);
 		q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd);
+		if (_cur < timeout) {
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		snprint_line(line, sizeof(line), &data[ofs],
 			     min(len, 16U), ofs);
 		printk(KERN_DEBUG "%s\n", line);
 		ofs += 16;
 		len -= min(len, 16U);
--
-	while (size && len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size && len) {
 		out = snprint_line(output, size, &data[ofs],
 				   min_t(size_t, len, 16U), ofs);
 
@@ -289,6 +305,12 @@ static int snprintk_buf(u8 * output, siz
 		size -= out;
--
 	while (current_index < priv->sram_desc.last_cb_index) {
 		udelay(50);
 		previous_index = current_index;
@@ -2974,6 +3001,12 @@ static int ipw_fw_dma_wait(struct ipw_pr
 			ipw_fw_dma_abort(priv);
 			return -1;
--
 	while ((ipw_rx_queue_space(rxq) > 0) && (rxq->free_count)) {
 		element = rxq->rx_free.next;
 		rxb = list_entry(element, struct ipw_rx_mem_buffer, list);
@@ -5178,6 +5216,12 @@ static void ipw_rx_queue_restock(struct
 		rxq->queue[rxq->write] = rxb;
 		rxq->write = (rxq->write + 1) % RX_QUEUE_SIZE;
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		printk(KERN_DEBUG "%s\n",
 		       snprint_line(line, sizeof(line), &data[ofs],
 				    min(len, 16U), ofs));
 		ofs += 16;
 		len -= min(len, 16U);
--
-	while (i != r) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i != r) {
 		/* IPW_DEBUG_RX("r = %d : w = %d : processing = %d\n",
 		   r, rxq->next, i); */
 
@@ -2793,6 +2809,12 @@ static void __ipw2100_rx_process(struct
 		rxq->drv[i].status.info.field = 0;
--
 	while (len < PAGE_SIZE - 128 && loop < 0x30000) {
 
 		if (priv->snapshot[0])
@@ -3942,6 +3969,12 @@ static ssize_t show_memory(struct device
 				       snprint_line(line, sizeof(line),
 						    (u8 *) buffer, 16, loop));
--
-	while (len < PAGE_SIZE - 128 && loop < ARRAY_SIZE(ord_data)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (len < PAGE_SIZE - 128 && loop < ARRAY_SIZE(ord_data)) {
 		val_len = sizeof(u32);
 
 		if (ipw2100_get_ordinal(priv, ord_data[loop].index, &val,
@@ -4013,6 +4051,12 @@ static ssize_t show_ordinals(struct devi
 				       ord_data[loop].index, val,
--
 	while (!list_empty(&priv->tx_pend_list)) {
 		element = priv->tx_pend_list.next;
 		packet = list_entry(element, struct ipw2100_tx_packet, list);
@@ -5898,6 +5947,12 @@ static int ipw2100_close(struct net_devi
 
 		list_add_tail(element, &priv->tx_free_list);
--
 	while (firmware_data_left > 0) {
 		addr = *(u32 *) (firmware_data);
 		firmware_data += 4;
@@ -8616,6 +8676,12 @@ static int ipw2100_fw_download(struct ip
 		write_nic_memory(priv->net_dev, addr, len, firmware_data);
 		firmware_data += len;
--
 	while (microcode_data_left > 0) {
 		write_nic_byte(dev, 0x210010, *microcode_data++);
 		write_nic_byte(dev, 0x210010, *microcode_data++);
 		microcode_data_left -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (skb) {
 		rt2x00mac_tx(rt2x00dev->hw, skb);
 		skb = ieee80211_get_buffered_bc(rt2x00dev->hw, vif);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -464,6 +480,12 @@ static u8 *rt2x00lib_find_ie(u8 *data, u
 			return pos;
 
--
-	while (kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
 
 		/* TX_STA_FIFO_PID_QUEUE is a 2-bit field, thus
 		 * qid is guaranteed to be one of the TX QIDs
@@ -544,6 +549,12 @@ static void rt2800usb_txdone(struct rt2x
 		if (entry)
--
-		while (entry != entry_done) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (entry != entry_done) {
 			/* Catch up.
 			 * Just report any entries we missed as failed.
 			 */
@@ -2212,6 +2217,12 @@ static void rt61pci_txdone(struct rt2x00
 
--
-	while (len && !status) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (len && !status) {
 		bsize = min_t(u16, CSR_CACHE_SIZE, len);
 		status = rt2x00usb_vendor_req_buff_lock(rt2x00dev, request,
 							requesttype, off, tb,
@@ -132,6 +137,12 @@ int rt2x00usb_vendor_request_buff(struct
 		tb  += bsize;
--
 	while (offset < len) {
 		if (!rt2800_check_firmware_crc(data + offset, fw_len))
 			return FW_BAD_CRC;
 
 		offset += fw_len;
+		if (_cur < timeout) {
--
 		while ((skb = ieee80211_get_buffered_bc(priv->hw, priv->vif))) {
 			skb_queue_tail(&priv->bc_ps_buf, skb);
 			tx_buff_bc = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (len > 0) {
 		int translen = (len > 1024) ? 1024 : len;
 		memcpy(buf, data, translen);
@@ -90,6 +95,12 @@ static int zd1201_fw_upload(struct usb_d
 
 		len -= translen;
--
-	while (fw_len > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (fw_len > 0) {
 		_fw_len = min_t(long, fw_len, SPI_MAX_PACKET_SIZE);
 
 		err = p54spi_spi_write_dma(priv, cpu_to_le32(
@@ -250,6 +255,12 @@ static int p54spi_upload_firmware(struct
 
--
-	while (!list_empty(&priv->tx_pending)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&priv->tx_pending)) {
 		entry = list_entry(priv->tx_pending.next,
 				   struct p54s_tx_info, tx_list);
 
@@ -467,6 +483,12 @@ static int p54spi_wq_tx(struct p54s_priv
 		}
--
 	while (remains) {
 		u32 i = 0;
 		left = min((u32)0x1000, remains);
@@ -100,13 +105,30 @@ static int p54p_upload_firmware(struct i
 		P54P_READ(int_enable);
 
--
 		while (i < left) {
 			P54P_WRITE(direct_mem_win[i], *data++);
 			i += sizeof(u32);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (i != idx) {
 		u16 len;
 		struct sk_buff *skb;
@@ -237,6 +264,12 @@ static void p54p_check_rx_ring(struct ie
 
 		i++;
--
-	while (i != idx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i != idx) {
 		desc = &ring[i];
 
 		skb = tx_buf[i];
@@ -275,6 +313,12 @@ static void p54p_check_tx_ring(struct ie
 
--
 	while (skb_queue_len(&priv->rx_queue) < 32) {
 		skb = __dev_alloc_skb(priv->common.rx_mtu + 32, GFP_KERNEL);
 		if (!skb) {
@@ -251,6 +256,12 @@ static int p54u_init_urbs(struct ieee802
 		}
 		usb_free_urb(entry);
--
 	while (length--) {
 		chk ^= le32_to_cpu(*data++);
 		chk = (chk >> 5) ^ (chk << 3);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (remains) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (left--) {
 			if (carry) {
 				*tmp++ = carry;
@@ -540,6 +572,12 @@ static int p54u_upload_firmware_3887(str
 				break;
 			}
--
 	while (remains) {
 		unsigned int block_len = min(remains, (unsigned int)512);
 		memcpy(buf, data, block_len);
@@ -781,6 +830,12 @@ static int p54u_upload_firmware_net2280(
 		remains -= block_len;
 		data += block_len;
--
 	while (i--) {
 		switch (intf->altsetting->endpoint[i].desc.bEndpointAddress) {
 		case P54U_PIPE_DATA:
@@ -952,6 +1012,12 @@ static int __devinit p54u_probe(struct u
 		case P54U_PIPE_INT | USB_DIR_IN:
 			recognized_pipes++;
--
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -93,6 +98,12 @@ u8 *p54_find_ie(struct sk_buff *skb, u8
 			return pos;
 
--
 	while ((total = p54_flush_count(priv) && i--)) {
 		/* waste time */
 		msleep(20);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (bootrec->data <= end_data && (bootrec->data +
 	       (len = le32_to_cpu(bootrec->len))) <= end_data) {
 		u32 code = le32_to_cpu(bootrec->code);
@@ -122,6 +127,12 @@ int p54_parse_firmware(struct ieee80211_
 			break;
 		}
--
 			while ((u8 *)tmp < entry->data + data_len) {
 				struct exp_if *exp_if = tmp;
 				if (exp_if->if_id == cpu_to_le16(IF_ID_ISL39000))
 					synth = le16_to_cpu(exp_if->variant);
 				tmp += sizeof(*exp_if);
+				if (_cur < timeout) {
--
-	while (eeprom_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (eeprom_size) {
 		blocksize = min(eeprom_size, maxblocksize);
 		ret = p54_download_eeprom(priv, (void *) (eeprom + offset),
 					  offset, blocksize);
@@ -912,6 +928,12 @@ int p54_read_eeprom(struct ieee80211_hw
 
--
 	while (i--) {
 		u8 octet = atmel_read8(priv->dev, DR);
 		crc = crc32_le(crc, &octet, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (1) {
 		if (!atmel_lock_mac(priv)) {
 			/* failed to contact card */
@@ -1260,6 +1276,12 @@ static irqreturn_t service_interrupt(int
 			printk(KERN_INFO "%s: Generic_irq received.\n", dev->name);
 			break;
--
 	while (time_diff--) {
 		priv->last_qual += HZ;
 		priv->wstats.qual.qual = priv->wstats.qual.qual / 2;
 		priv->wstats.qual.qual +=
 			priv->beacons_this_sec * priv->beacon_period * (priv->wstats.qual.level + 100) / 4000;
 		priv->beacons_this_sec = 0;
--
-			while (skb_queue_len(&priv->b_tx_status.queue) > 5) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (skb_queue_len(&priv->b_tx_status.queue) > 5) {
 				struct sk_buff *old_skb;
 
 				dev_dbg(&priv->udev->dev,
@@ -211,6 +216,12 @@ static void rtl8187_tx_cb(struct urb *ur
 
--
 	while (skb_queue_len(&priv->rx_queue) < 16) {
 		skb = __dev_alloc_skb(RTL8187_MAX_RX, GFP_KERNEL);
 		if (!skb) {
@@ -435,6 +451,12 @@ static int rtl8187_init_urbs(struct ieee
 			goto err;
 		}
--
 	while (skb_queue_len(&priv->b_tx_status.queue) > 0) {
 		struct sk_buff *old_skb;
 
@@ -900,6 +927,12 @@ static void rtl8187_work(struct work_str
 		if (info->status.rates[0].count > RETRY_COUNT)
 			info->flags &= ~IEEE80211_TX_STAT_ACK;
--
 	while (i--) {
 		rtl818x_iowrite32(priv, (__le32 __iomem *)&priv->map->PHY[0], buf);
 		if (rtl818x_ioread8(priv, &priv->map->PHY[2]) == (data & 0xFF))
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (count--) {
 		struct rtl8180_rx_desc *entry = &priv->rx_ring[priv->rx_idx];
 		struct sk_buff *skb = priv->rx_buf[priv->rx_idx];
@@ -169,6 +185,12 @@ static void rtl8180_handle_rx(struct iee
 		if (priv->rx_idx == 31)
 			entry->flags |= cpu_to_le32(RTL818X_RX_DESC_FLAG_EOR);
--
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl8180_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb;
@@ -204,6 +231,12 @@ static void rtl8180_handle_tx(struct iee
 		ieee80211_tx_status_irqsafe(dev, skb);
 		if (ring->entries - skb_queue_len(&ring->queue) == 2)
--
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl8180_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb = __skb_dequeue(&ring->queue);
@@ -534,6 +572,12 @@ static void rtl8180_free_tx_ring(struct
 				 skb->len, PCI_DMA_TODEVICE);
 		kfree_skb(skb);
--
 	while (check_bssid_list_item(bssid, bssid_len, buf, len)) {
 		if (rndis_bss_info_update(usbdev, bssid) && match_bssid &&
 		    matched) {
@@ -2107,6 +2112,12 @@ resize_buf:
 
 		real_count++;
--
 	while (buflen >= sizeof(*auth_req)) {
 		auth_req = (void *)buf;
 		type = "unknown";
@@ -2955,6 +2971,12 @@ static void rndis_wlan_auth_indication(s
 
 		buflen -= le32_to_cpu(auth_req->length);
--
 	while (precision > 0) {
 		quotient <<= 1;
 		if (remainder << 1 >= divisor) {
@@ -1092,6 +1097,12 @@ static u32 lpphy_qdiv_roundup(u32 divide
 			remainder = (remainder << 1) - divisor;
 		}
--
 	while (tmp2 >= freqref) {
 		tmp1++;
 		tmp2 -= freqref;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 	while (tuple) {
 		switch (tuple->code) {
 		case 0x80:
@@ -123,6 +128,12 @@ static int __devinit b43_sdio_probe(stru
 			break;
 		}
--
-	while (skb_queue_len(&wl->tx_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (skb_queue_len(&wl->tx_queue)) {
 		skb = skb_dequeue(&wl->tx_queue);
 
 		if (b43_using_pio_transfers(dev))
@@ -3389,6 +3394,12 @@ static void b43_tx_work(struct work_stru
 			err = b43_dma_tx(dev, skb);
--
-		while (skb_queue_len(q) > ZD_MAC_MAX_ACK_WAITERS) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (skb_queue_len(q) > ZD_MAC_MAX_ACK_WAITERS) {
 			zd_mac_tx_status(hw, skb_dequeue(q),
 					 mac->ack_pending ? mac->ack_signal : 0,
 					 NULL);
 			mac->ack_pending = 0;
+			if (_cur < timeout) {
--
 	while (tmp & 0x2) {
 		r = zd_ioread32_locked(&mac->chip, &tmp, CR_BCN_FIFO_SEMAPHORE);
 		if (r < 0)
@@ -760,6 +776,12 @@ static int zd_mac_config_beacon(struct i
 			}
 		}
--
-	while (size > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size > 0) {
 		size_t transfer_size = size <= MAX_TRANSFER_SIZE ?
 			size : MAX_TRANSFER_SIZE;
 
@@ -183,6 +188,12 @@ static int upload_code(struct usb_device
 		size -= transfer_size;
--
 	while (len >= 4) {
 		MIC_ACCUM(ntohl(*(__be32 *)pOctets));
 		context->position += 4;
 		pOctets += 4;
 		len -= 4;
+		if (_cur < timeout) {
--
 	while (len > 0) {
 		context->part.d8[byte_position++] = *pOctets++;
 		context->position++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((IN4500(ai, COMMAND) & COMMAND_BUSY) && (delay < 10000)) {
 		udelay (10);
 		if ((++delay % 20) == 0)
 			OUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while((!rc) && (bss.index != cpu_to_le16(0xffff))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while((!rc) && (bss.index != cpu_to_le16(0xffff))) {
 		/* Grab a network off the free list */
 		if (!list_empty(&ai->network_free_list)) {
 			tmp_net = list_entry(ai->network_free_list.next,
@@ -3036,6 +3074,12 @@ static void airo_process_scan_results (s
 		/* Read next entry */
--
 	while (max_tries-- && (IN4500(ai, EVSTAT) & EV_CMD) == 0) {
 		if ((IN4500(ai, COMMAND)) == pCmd->cmd)
 			// PC4500 didn't notice command, try again
 			OUT4500(ai, COMMAND, pCmd->cmd);
 		if (!in_atomic() && (max_tries & 255) == 0)
 			schedule();
--
 	while (1) {
 		int status = IN4500(ai, OFFSET0+whichbap);
 		if (status & BAP_BUSY) {
@@ -4011,6 +4071,12 @@ static int bap_setup(struct airo_info *a
 		OUT4500(ai, SELECT0+whichbap, rid);
 		OUT4500(ai, OFFSET0+whichbap, offset);
--
 	while( line[0] ) {
 /*** Mode processing */
 		if ( !strncmp( line, "Mode: ", 6 ) ) {
@@ -4887,10 +4958,21 @@ static void proc_config_on_close(struct
 						k is index to rates */
 
--
 			while((v = get_dec_u16(line, &i, 3))!=-1) {
 				ai->config.rates[k++] = (u8)v;
 				line += i + 1;
 				i = 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 		while( line[0] && line[0] != '\n' ) line++;
 		if ( line[0] ) line++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-	while(rc == 0 && BSSList_rid.index != cpu_to_le16(0xffff)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while(rc == 0 && BSSList_rid.index != cpu_to_le16(0xffff)) {
 		ptr += sprintf(ptr, "%pM %*s rssi = %d",
 			       BSSList_rid.bssid,
 				(int)BSSList_rid.ssidLen,
@@ -5523,6 +5616,12 @@ static int proc_BSSList_open( struct ino
 				BSSList_rid.cap & CAP_PRIVACY ? "wep" : "",
--
 	while(!list_empty(&airo_devices)) {
 		ai = list_entry(airo_devices.next, struct airo_info, dev_list);
 		airo_print_info(ai->dev->name, "Unregistering...");
 		stop_airo_card(ai->dev, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((IN4500 (ai, SWS0) & 0x8000) && waittime > 0) {
 		udelay (50);
 		waittime -= 50;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while ((skb = skb_dequeue(&wl->links[hlid].tx_queue[i]))) {
 			filtered[i]++;
 
@@ -212,6 +217,12 @@ static void wl1271_ps_filter_frames(stru
 			info->flags |= IEEE80211_TX_STAT_TX_FILTERED;
 			info->status.rates[0].idx = -1;
--
-		while (pkt_offset < buf_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (pkt_offset < buf_size) {
 			pkt_length = wl12xx_rx_get_buf_size(status,
 					drv_rx_counter);
 
@@ -260,6 +265,12 @@ void wl12xx_rx(struct wl1271 *wl, struct
 			drv_rx_counter++;
--
 	while (num_busy_bytes) {
 		num_busy_bytes--;
 		spi_message_init(&m);
@@ -198,6 +203,12 @@ static int wl1271_spi_read_busy(struct w
 
 		if (*busy_buf & 0x1)
--
 	while (len > 0) {
 		chunk_len = min((size_t)WSPI_MAX_CHUNK_SIZE, len);
 
@@ -268,6 +284,12 @@ static void wl1271_spi_raw_read(struct w
 			addr += chunk_len;
 		buf += chunk_len;
--
-	while (len > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (len > 0) {
 		chunk_len = min((size_t)WSPI_MAX_CHUNK_SIZE, len);
 
 		*cmd = 0;
@@ -316,6 +343,12 @@ static void wl1271_spi_raw_write(struct
 		buf += chunk_len;
--
 	while (chunk_num < fw_data_len / CHUNK_SIZE) {
 		/* 10.2 update partition, if needed */
 		addr = dest + (chunk_num + 2) * CHUNK_SIZE;
@@ -208,6 +213,12 @@ static int wl1271_boot_upload_firmware_c
 		wl1271_write(wl, addr, chunk, CHUNK_SIZE, false);
 
--
 	while (nvs_ptr[0]) {
 		burst_len = nvs_ptr[0];
 		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));
@@ -364,6 +380,12 @@ static int wl1271_boot_upload_nvs(struct
 
 		if (nvs_ptr >= (u8 *) wl->nvs + nvs_len)
--
 	while (!(intr & WL1271_ACX_INTR_CMD_COMPLETE)) {
 		if (time_after(jiffies, timeout)) {
 			wl1271_error("command complete timeout");
@@ -85,6 +90,12 @@ int wl1271_cmd_send(struct wl1271 *wl, u
 			msleep(1);
 
--
 	while (!kthread_should_stop()) {
 		if (rx && !rx_started) {
 			dev_info(pdev, "starting rx test\n");
@@ -393,6 +398,12 @@ static int tester(void *data)
 
 		if (!rx_started && !tx_started)
--
 	while (!done && loopcount--) {
 		/*
 		 * In order to avoid a race with the hardirq, clear the flag
@@ -1037,6 +1042,12 @@ irqreturn_t wl1271_irq(int irq, void *co
 
 		if (intr & WL1271_ACX_INTR_HW_AVAILABLE)
--
 	while (retries) {
 		retries--;
 		ret = wl1271_chip_wakeup(wl);
@@ -1431,6 +1447,12 @@ irq_disable:
 		mutex_lock(&wl->mutex);
 power_off:
--
 	while (retries) {
 		retries--;
 		ret = wl1271_chip_wakeup(wl);
@@ -1956,6 +1983,12 @@ irq_disable:
 		mutex_lock(&wl->mutex);
 power_off:
--
 	while ((skb = wl1271_skb_dequeue(wl))) {
 		if (wl1271_tx_is_data_present(skb))
 			had_data = true;
@@ -682,7 +687,13 @@ void wl1271_tx_work_locked(struct wl1271
 		}
 		buf_offset += ret;
--
 		while ((skb = skb_dequeue(&wl->links[hlid].tx_queue[i]))) {
 			wl1271_debug(DEBUG_TX, "link freeing skb 0x%p", skb);
 
@@ -874,6 +890,12 @@ void wl1271_tx_reset_link_queues(struct
 			}
 
--
-			while ((skb = skb_dequeue(&wl->tx_queue[i]))) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while ((skb = skb_dequeue(&wl->tx_queue[i]))) {
 				wl1271_debug(DEBUG_TX, "freeing skb 0x%p",
 					     skb);
 
@@ -914,6 +941,12 @@ void wl1271_tx_reset(struct wl1271 *wl,
 					info->status.rates[0].count = 0;
--
-	while (!time_after(jiffies, timeout)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!time_after(jiffies, timeout)) {
 		mutex_lock(&wl->mutex);
 		wl1271_debug(DEBUG_TX, "flushing tx buffer: %d %d",
 			     wl->tx_frames_cnt,
@@ -985,6 +1023,12 @@ void wl1271_tx_flush(struct wl1271 *wl)
 		}
--
-	while (iwm->calib_done_map != expected_bitmap) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (iwm->calib_done_map != expected_bitmap) {
 		if (iwm_notif_handle(iwm, CALIBRATION_RES_NOTIFICATION,
 				     IWM_SRC_LMAC, WAIT_NOTIF_TIMEOUT)) {
 			IWM_DBG_FW(iwm, DBG, "Initial calibration timeout\n");
@@ -290,6 +295,12 @@ static int iwm_init_calib(struct iwm_pri
 		IWM_DBG_FW(iwm, DBG, "Got calibration result. calib_done_map: "
--
 	while ((frame = __skb_dequeue(&list))) {
 		ndev->stats.rx_packets++;
 		ndev->stats.rx_bytes += frame->len;
@@ -1591,6 +1596,12 @@ static void iwm_rx_process_amsdu(struct
 			IWM_ERR(iwm, "Packet dropped\n");
 			ndev->stats.rx_dropped++;
--
 	while (!skb_queue_empty(&iwm->rx_list)) {
 		skb = skb_dequeue(&iwm->rx_list);
 		rx_info = skb_to_rx_info(skb);
@@ -99,6 +104,12 @@ static void iwm_sdio_isr_worker(struct w
 			IWM_WARN(iwm, "RX error\n");
 
--
-	while (entry_size > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (entry_size > 0) {
 		chunk_size = min_t(u32, entry_size, IWM_MAX_EEPROM_DATA_LEN);
 
 		eeprom_cmd.hdr.type =
@@ -138,6 +143,12 @@ static int iwm_eeprom_read(struct iwm_pr
 		data_offset += chunk_size;
--
 			while (i >= 0) {
 				pcdac_out[i] = pcdac_out[i + 1];
 				i--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 		while ((pdadc_0 < 0) && (pdadc_i < 128)) {
 			s16 tmp = pdadc_tmp[0] + pdadc_0 * pwr_step;
 			pdadc_out[pdadc_i++] = (tmp < 0) ? 0 : (u8) tmp;
 			pdadc_0++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while ((pdadc_0 < (s16) pdadc_n) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((pdadc_0 < (s16) pdadc_n) &&
 		(pdadc_i < AR5K_EEPROM_POWER_TABLE_SIZE * 2)) {
 			s16 tmp = pdadc_tmp[table_size - 1] +
 					(pdadc_0 - max_idx) * pwr_step;
 			pdadc_out[pdadc_i++] = (tmp > 127) ? 127 : (u8) tmp;
 			pdadc_0++;
--
 	while (pdg < AR5K_EEPROM_N_PD_GAINS) {
 		gain_boundaries[pdg] = gain_boundaries[pdg - 1];
 		pdg++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (pdadc_i < AR5K_EEPROM_POWER_TABLE_SIZE * 2) {
 		pdadc_out[pdadc_i] = pdadc_out[pdadc_i - 1];
 		pdadc_i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(rx_pktq)) {
 		fetched_pkts = 0;
 
@@ -1736,6 +1741,12 @@ static int ath6kl_htc_rx_fetch(struct ht
 
 			list_add_tail(&packet->list, comp_pktq);
--
 	while ((packet = htc_get_control_buf(target, false)) != NULL) {
 		status = htc_add_rxbuf(target, packet);
 		if (status)
 			return status;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (len < buf_len && !ath6kl_debug_fwlog_empty(ar)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len < buf_len && !ath6kl_debug_fwlog_empty(ar)) {
 		ccnt = CIRC_CNT_TO_END(fwlog->head, fwlog->tail,
 				       ATH6KL_FWLOG_SIZE);
 
@@ -332,6 +337,12 @@ static ssize_t ath6kl_fwlog_read(struct
 
--
-	while (!list_empty(packet_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(packet_queue)) {
 
 		packet = list_first_entry(packet_queue, struct htc_packet,
 					  list);
@@ -599,6 +604,12 @@ void ath6kl_tx_complete(void *context, s
 
--
 	while (num) {
 		skb = ath6kl_buf_alloc(ATH6KL_BUFFER_SIZE);
 		if (!skb) {
@@ -663,6 +679,12 @@ static void ath6kl_alloc_netbufs(struct
 		}
 		skb_queue_tail(q, skb);
--
 	while (count) {
 		skb = ath6kl_buf_alloc(ATH6KL_AMSDU_BUFFER_SIZE);
 		if (!skb)
@@ -735,6 +762,12 @@ void ath6kl_refill_amsdu_rxbufs(struct a
 		list_add_tail(&packet->list, &ar->amsdu_rx_buffer_queue);
 		spin_unlock_bh(&ar->lock);
--
 				while ((skbuff = skb_dequeue(&conn->psq))
 				       != NULL) {
 					spin_unlock_bh(&conn->psq_lock);
 					ath6kl_data_tx(skbuff, ar->net_dev);
 					spin_lock_bh(&conn->psq_lock);
+					if (_cur < timeout) {
--
-	while (time_before(jiffies, timeout) && !ar->bmi.cmd_credits) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, timeout) && !ar->bmi.cmd_credits) {
 
 		/*
 		 * Hit the credit counter with a 4-byte access, the first byte
@@ -52,6 +57,12 @@ static int ath6kl_get_bmi_cmd_credits(st
 		 * Ignore anything in the upper 3 bytes
--
-	while (time_before(jiffies, timeout) && !rx_word) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, timeout) && !rx_word) {
 		ret = hif_read_write_sync(ar, RX_LOOKAHEAD_VALID_ADDRESS,
 					  (u8 *)&rx_word, sizeof(rx_word),
 					  HIF_RD_SYNC_BYTE_INC);
@@ -80,6 +96,12 @@ static int ath6kl_bmi_get_rx_lkahd(struc
 
--
-	while (len_remain) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len_remain) {
 		rx_len = (len_remain < BMI_DATASZ_MAX) ?
 					len_remain : BMI_DATASZ_MAX;
 		offset = 0;
@@ -316,6 +343,12 @@ int ath6kl_bmi_read(struct ath6kl *ar, u
 		}
--
 	while (len_remain) {
 		src = &buf[len - len_remain];
 
@@ -380,6 +418,12 @@ int ath6kl_bmi_write(struct ath6kl *ar,
 			return ret;
 		}
--
-	while (len_remain) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len_remain) {
 		tx_len = (len_remain < (BMI_DATASZ_MAX - header)) ?
 			  len_remain : (BMI_DATASZ_MAX - header);
 
@@ -597,6 +646,12 @@ int ath6kl_bmi_lz_data(struct ath6kl *ar
 		}
--
 	while (len > sizeof(struct ath6kl_fw_ie)) {
 		/* hdr is unaligned! */
 		hdr = (struct ath6kl_fw_ie *) data;
@@ -1041,6 +1046,12 @@ static int ath6kl_fetch_fw_api2(struct a
 
 		len -= ie_len;
--
 	while (atomic_read(&ar_sdio->irq_handling)) {
 		sdio_release_host(ar_sdio->func);
 		schedule_timeout(HZ / 10);
 		sdio_claim_host(ar_sdio->func);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((skb = skb_dequeue(&ar->mcastpsq)) != NULL) {
 		spin_unlock_bh(&ar->mcastpsq_lock);
 
 		ath6kl_data_tx(skb, ar->net_dev);
 
 		spin_lock_bh(&ar->mcastpsq_lock);
--
 	while(skb) {
 		hdr = (struct ieee80211_hdr *) skb->data;
 
@@ -342,6 +347,12 @@ static void ath9k_htc_send_buffered(stru
 		}
 	next:
--
 	while (skb) {
 		ath_tx_cabq(hw, skb);
 		skb = ieee80211_get_buffered_bc(hw, vif);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = skb_dequeue(queue)) != NULL) {
 		ath9k_htc_tx_process(priv, skb, NULL);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-	while (bitsLeft > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bitsLeft > 0) {
 		lastBit = (bitPosition + bitsLeft > 8) ?
 		    8 : bitPosition + bitsLeft;
 		mask = (((1 << lastBit) - 1) ^ ((1 << bitPosition) - 1)) <<
@@ -106,6 +111,12 @@ static void ar5008_hw_phy_modify_rx_buff
 		tmp32 = tmp32 >> (8 - bitPosition);
--
 	while ((skb = skb_dequeue(&rx_edma->rx_fifo)) != NULL) {
 		bf = SKB_CB_ATHBUF(skb);
 		BUG_ON(!bf);
 		list_add_tail(&bf->list, &sc->rx.rxbuf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((skb = __skb_dequeue(&tid->buf_q))) {
 		fi = get_frame_info(skb);
 		bf = fi->bf;
@@ -178,6 +183,12 @@ static void ath_tx_flush_tid(struct ath_
 			ath_tx_send_normal(sc, txq, NULL, skb);
 		}
--
 	while (tid->baw_head != tid->baw_tail && !test_bit(tid->baw_head, tid->tx_buf)) {
 		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
 		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((skb = __skb_dequeue(&tid->buf_q))) {
 		fi = get_frame_info(skb);
 		bf = fi->bf;
@@ -253,6 +280,12 @@ static void ath_tid_drain(struct ath_sof
 		spin_unlock(&txq->axq_lock);
 		ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0, 0);
--
 	while (bf) {
 		fi = get_frame_info(bf->bf_mpdu);
 		ba_index = ATH_BA_INDEX(seq_st, bf->bf_state.seqno);
@@ -349,6 +387,12 @@ static void ath_tx_count_frames(struct a
 			(*nbad)++;
 
--
-		while (bf) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bf) {
 			bf_next = bf->bf_next;
 
 			if (!bf->bf_stale || bf_next != NULL)
@@ -401,6 +450,12 @@ static void ath_tx_complete_aggr(struct
 				0, 0);
--
 	while (bf) {
 		struct sk_buff *skb = bf->bf_mpdu;
 		struct ath_frame_info *fi = get_frame_info(skb);
@@ -1058,6 +1118,12 @@ static void ath_tx_fill_desc(struct ath_
 
 		ath9k_hw_set_txdesc(ah, bf->bf_desc, &info);
--
 	while (!list_empty(list)) {
 		bf = list_first_entry(list, struct ath_buf, list);
 
@@ -1440,6 +1511,12 @@ static void ath_drain_txq_list(struct at
 		else
 			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0, 0);
--
-		while (!list_empty(&txq->txq_fifo[idx])) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&txq->txq_fifo[idx])) {
 			ath_drain_txq_list(sc, txq, &txq->txq_fifo[idx],
 					   retry_tx);
 
 			INCR(idx, ATH_TXFIFO_DEPTH);
+			if (_cur < timeout) {
--
 		while (ndesc_skipped) {
 			dma_len = ndesc_skipped * desc_len;
 			dd->dd_desc_len += dma_len;
 
 			ndesc_skipped = ATH_DESC_4KB_BOUND_NUM_SKIPPED(dma_len);
+			if (_cur < timeout) {
--
-			while (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {
 				BUG_ON((caddr_t) bf->bf_desc >=
 				       ((caddr_t) dd->dd_desc +
 					dd->dd_desc_len));
@@ -396,6 +412,12 @@ int ath_descdma_setup(struct ath_softc *
 				ds += (desc_len * ndesc);
--
 	while (pmu_set != REG_READ(ah, pmu_reg)) {
 		if (timeout-- == 0)
 			return false;
 		REG_WRITE(ah, pmu_reg, pmu_set);
 		udelay(10);
+		if (_cur < timeout) {
--
 	while (tx_chainmask || rx_chainmask) {
 		if (tx_chainmask & BIT(0))
 			pCap->max_txchains++;
@@ -2345,6 +2350,12 @@ int ath9k_hw_fill_cap_info(struct ath_hw
 
 		tx_chainmask >>= 1;
--
-	while (thresh_mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (thresh_mask) {
 		index = rightmost_index(timer_table, &thresh_mask);
 		timer = timer_table->timers[index];
 		BUG_ON(!timer);
 		ath_dbg(common, ATH_DBG_HWTIMER,
 			"TSF overflow for Gen timer %d\n", index);
--
-	while (trigger_mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (trigger_mask) {
 		index = rightmost_index(timer_table, &trigger_mask);
 		timer = timer_table->timers[index];
 		BUG_ON(!timer);
 		ath_dbg(common, ATH_DBG_HWTIMER,
 			"Gen timer[%d] trigger\n", index);
--
 	while (i < ARRAY_SIZE(mcs_rix_off) && rate->idx > mcs_rix_off[i]) {
 		rix++; i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 		while ((ss < 0) && (k < (AR5416_NUM_PDADC_VALUES - 1))) {
 			tmpVal = (int16_t)(vpdTableI[i][0] + ss * vpdStep);
 			pPDADCValues[k++] = (u8)((tmpVal < 0) ? 0 : tmpVal);
 			ss++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while ((ss < maxIndex) && (k < (AR5416_NUM_PDADC_VALUES - 1))) {
 			pPDADCValues[k++] = vpdTableI[i][ss++];
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
--
-			while ((ss <= tgtIndex) &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((ss <= tgtIndex) &&
 			       (k < (AR5416_NUM_PDADC_VALUES - 1))) {
 				tmpVal = (int16_t)((vpdTableI[i][sizeCurrVpdTable - 1] +
 						    (ss - maxIndex + 1) * vpdStep));
 				pPDADCValues[k++] = (u8)((tmpVal > 255) ?
 							 255 : tmpVal);
--
 	while (i < AR5416_PD_GAINS_IN_MASK) {
 		pPdGainBoundaries[i] = pdgain_boundary_default;
 		i++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (k < AR5416_NUM_PDADC_VALUES) {
 		pPDADCValues[k] = pPDADCValues[k - 1];
 		k++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((skb = __skb_dequeue(list)) != NULL) {
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
-	while ((skb = __skb_dequeue(queue)) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((skb = __skb_dequeue(queue)) != NULL) {
 		ath9k_htc_txcompletion_cb(hif_dev->htc_handle,
 					  skb, txok);
 		if (txok)
 			TX_STAT_INC(skb_success);
 		else
--
 	while (index < len) {
 		u16 pkt_len;
 		u16 pkt_tag;
@@ -613,7 +640,13 @@ static void ath9k_hif_usb_rx_stream(stru
 			skb_put(nskb, pkt_len);
 			skb_pool[pool_index++] = nskb;
--
 	while (len) {
 		transfer = min_t(int, len, 4096);
 		memcpy(buf, data, transfer);
@@ -997,6 +1035,12 @@ static int ath9k_hif_usb_download_fw(str
 		len -= transfer;
 		data += transfer;
--
 	while ((atomic_read(&ar->rx_anch_urbs) < AR9170_NUM_RX_URBS) &&
 		(runs++ < AR9170_NUM_RX_URBS)) {
 		err = -ENOSPC;
@@ -325,6 +330,12 @@ static int carl9170_usb_submit_rx_urb(st
 			}
 			usb_free_urb(urb);
--
 	while ((urb = usb_get_from_anchor(&ar->tx_err))) {
 		struct sk_buff *skb = (void *)urb->context;
 
 		carl9170_tx_drop(ar, skb);
 		carl9170_tx_callback(ar, skb);
 		usb_free_urb(urb);
--
 	while ((urb = usb_get_from_anchor(&ar->tx_wait))) {
 		struct sk_buff *skb = (void *)urb->context;
 		carl9170_tx_drop(ar, skb);
 		carl9170_tx_callback(ar, skb);
 		usb_free_urb(urb);
+		if (_cur < timeout) {
--
 	while (len) {
 		transfer = min_t(unsigned int, len, 4096u);
 		memcpy(buf, data, transfer);
@@ -822,6 +860,12 @@ static int carl9170_usb_load_firmware(st
 		len -= transfer;
 		data += transfer;
--
 	while (idx >= 0) {
 		if (f >= freqs[idx])
 			return idx;
 		idx--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (pos_addr < end_addr) {
 		if (pos_addr + sizeof(*head) > end_addr)
 			return -E2BIG;
@@ -93,6 +98,12 @@ static int carl9170_fw_verify_descs(stru
 		pos_addr += pos_length;
 		pos = (void *)pos_addr;
--
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -505,6 +510,12 @@ static u8 *carl9170_find_ie(u8 *data, un
 			return pos;
 
--
 	while (len > 2 && i < 12 && buf[0] == 0xff && buf[1] == 0xff) {
 		i += 2;
 		len -= 2;
 		buf += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (tlen >= 4) {
 		rx_stream = (void *) tbuf;
 		clen = le16_to_cpu(rx_stream->length);
@@ -892,6 +919,12 @@ static void carl9170_rx_stream(struct ar
 
 		tbuf += wlen + 4;
--
-	while (!list_empty(&tid_gc)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&tid_gc)) {
 		struct sk_buff *skb;
 		tid_info = list_first_entry(&tid_gc, struct carl9170_sta_tid,
 					    tmp_list);
@@ -214,6 +219,12 @@ static void carl9170_ampdu_gc(struct ar9
 
--
 			while ((skb = skb_dequeue(&ar->tx_pending[i]))) {
 				struct ieee80211_tx_info *info;
 
@@ -238,6 +254,12 @@ static void carl9170_flush(struct ar9170
 					atomic_dec(&ar->tx_ampdu_upload);
 
--
 		while (!skb_queue_empty(&ar->tx_status[i])) {
 			struct sk_buff *skb;
 
@@ -295,6 +322,12 @@ static void carl9170_zap_queues(struct a
 			carl9170_tx_drop(ar, skb);
 			spin_lock_bh(&ar->tx_status[i].lock);
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		err = carl9170_exec_cmd(ar, CARL9170_CMD_RREG,
 					RB, (u8 *) rng_load,
 					RB, (u8 *) buf);
@@ -1506,6 +1544,12 @@ static int carl9170_rng_get(struct ar917
 
--
 	while (HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY && tries > 0) {
 		tries--;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (len > 0) {
 			*pos++ = HFA384X_INW_DATA(HFA384X_AUXDATA_OFF);
 			len -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (len > 0) {
 			HFA384X_OUTW_DATA(*pos++, HFA384X_AUXDATA_OFF);
 			len -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (pos + 1 < PRISM2_PDA_SIZE / 2) {
 		len = le16_to_cpu(pda[pos]);
 		pdr = le16_to_cpu(pda[pos + 1]);
@@ -168,6 +206,12 @@ static int prism2_pda_ok(u8 *buf)
 		}
 
--
-		while (rest_len > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (rest_len > 0) {
 			int block_len;
 
 			block_len = prism2_download_block(
@@ -614,6 +663,12 @@ static int prism2_download_nonvolatile(l
 
--
 	while (cb != NULL && cb->idx != idx) {
 		prev = cb;
 		cb = cb->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (pos < CIS_MAX_LEN - 1 && cis[pos] != CISTPL_END) {
 		if (pos + 2 + cis[pos + 1] > CIS_MAX_LEN)
 			goto cis_error;
@@ -400,6 +405,12 @@ static int prism2_plx_check_cis(void __i
 		}
 
--
 	while (HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY && tries > 0) {
 		tries--;
 		udelay(1);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY && tries > 0) {
 		tries--;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
         while (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_CMD) &&
                tries > 0) {
                 tries--;
                 udelay(10);
+                if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (res && tries > 0) {
 		tries--;
 		udelay(1);
 		res = HFA384X_INW(o_off) & HFA384X_OFFSET_BUSY;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while ((skb = skb_dequeue(&local->sta_tx_exc_list)) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&local->sta_tx_exc_list)) != NULL) {
 		struct hfa384x_tx_frame *txdesc =
 			(struct hfa384x_tx_frame *) skb->data;
 
@@ -2317,6 +2366,12 @@ static void hostap_sta_tx_exc_tasklet(un
 			hostap_handle_sta_tx_exc(local, skb);
--
 	while ((skb = skb_dequeue(&local->info_list)) != NULL) {
 		hostap_info_process(local, skb);
 		dev_kfree_skb(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (tx_cb != NULL) {
 		tx_cb_prev = tx_cb;
 		tx_cb = tx_cb->next;
 		kfree(tx_cb_prev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (entry) {
 		spin_lock_bh(&ap->sta_table_lock);
 		sta = ap_get_sta(ap, entry->addr);
@@ -1086,6 +1091,12 @@ static void handle_add_proc_queue(struct
 		prev = entry;
 		entry = entry->next;
--
 			while (left > 0) {
 				PDEBUG2(DEBUG_AP, "<%02x>", *u);
 				u++; left--;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
-	while (entry) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (entry) {
 		PDEBUG(DEBUG_AP, "%s: %s automatic WDS connection "
 		       "to AP %pM\n",
 		       local->dev->name,
@@ -1973,6 +2000,12 @@ static void handle_wds_oper_queue(struct
 		prev = entry;
--
 	while (left >= 2) {
 		if (2 + pos[1] > left)
 			return; /* parse failed */
@@ -434,6 +439,12 @@ static void hostap_rx_sta_beacon(local_i
 		}
 		left -= 2 + pos[1];
--
 	while (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE &&
 	       work_done < quota) {
 		work_done += flexcan_read_frame(dev);
 		reg_iflag1 = flexcan_read(&regs->iflag1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count--) {
 		if (fp && *fp++) {
 			if (!test_and_set_bit(SLF_ERROR, &sl->flags))
@@ -420,6 +425,12 @@ static void slcan_receive_buf(struct tty
 			continue;
 		}
--
 	while (!hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE) && cnt != 0) {
 		--cnt;
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE) && cnt != 0) {
 		--cnt;
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 			while (status & SR_RBS) {
 				sja1000_rx(dev);
 				status = priv->read_reg(priv, SJA1000_REG_SR);
 				/* check for absent controller */
 				if (status == 0xFF && sja1000_is_absent(priv))
 					goto out;
--
-	while (count && priv->read_reg(priv,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count && priv->read_reg(priv,
 				&priv->regs->ifregs[iface].com_req) &
 				IF_COMR_BUSY) {
 		count--;
 		udelay(1);
+		if (_cur < timeout) {
--
-	while (!(bfin_read(&reg->control) & CCA)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(bfin_read(&reg->control) & CCA)) {
 		udelay(10);
 		if (--timeout == 0) {
 			dev_err(dev->dev.parent,
 					"fail to enter configuration mode\n");
 			BUG();
--
-	while (bfin_read(&reg->status) & CCA) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (bfin_read(&reg->status) & CCA) {
 		udelay(10);
 		if (--timeout == 0) {
 			dev_err(dev->dev.parent,
 					"fail to leave configuration mode\n");
 			BUG();
--
-		while (!(bfin_read(&reg->intr) & SMACK)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!(bfin_read(&reg->intr) & SMACK)) {
 			udelay(10);
 			if (--timeout == 0) {
 				dev_err(dev->dev.parent,
 						"fail to enter sleep mode\n");
 				BUG();
--
-		while (mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK) {
 			schedule();
 			if (time_after(jiffies, timeout)) {
 				dev_err(&spi->dev, "MCP251x didn't"
 					" enter in normal mode\n");
 				return -EBUSY;
--
-	while ((mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK)
 	       != CANCTRL_REQOP_CONF) {
 		schedule();
 		if (time_after(jiffies, timeout)) {
@@ -638,6 +654,12 @@ static int mcp251x_hw_reset(struct spi_d
 				" enter in conf mode after reset\n");
--
 	while (softing_handle_1(card) > 0) {
 		++card->irq.svc_count;
 		++work_done;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (mem < end) {
 		ret = fw_parse(&mem, &type, &addr, &len, &dat);
 		if (ret < 0)
@@ -213,6 +218,12 @@ int softing_load_fw(const char *file, st
 			ret = -EIO;
 			goto failed;
--
 	while (mem < end) {
 		ret = fw_parse(&mem, &type, &addr, &len, &dat);
 		if (ret)
@@ -307,6 +323,12 @@ int softing_load_app_fw(const char *file
 			ret = -EIO;
 			goto failed;
--
 	while (unlikely(ktime_to_ns(tmp) > ktime_to_ns(now))) {
 		card->ts_ref = ktime_add(card->ts_ref, card->ts_overflow);
 		target = tmp;
 		tmp = ktime_add(target, card->ts_overflow);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (count && (offset >= from->iov_len)) {
 		offset -= from->iov_len;
 		++from;
 		--count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (count && (copy > 0)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (count && (copy > 0)) {
 		size = min_t(unsigned int, copy, from->iov_len - offset);
 		if (copy_from_user(skb->data + offset1, from->iov_base + offset,
 				   size))
@@ -509,11 +525,22 @@ static int zerocopy_sg_from_iovec(struct
 			offset += size;
--
 	while (count--) {
 		struct page *page[MAX_SKB_FRAGS];
 		int num_pages;
@@ -543,6 +570,11 @@ static int zerocopy_sg_from_iovec(struct
 		skb->len += len;
 		skb->truesize += truesize;
--
 		while (len) {
 			int off = base & ~PAGE_MASK;
 			int size = min_t(int, len, PAGE_SIZE - off);
@@ -552,9 +584,21 @@ static int zerocopy_sg_from_iovec(struct
 			base += size;
 			len -= size;
--
 	while (nr_segs && (offset >= iv->iov_len)) {
 		offset -= iv->iov_len;
 		++iv;
 		--nr_segs;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len) {
 		set_skb_frag(skb, page, offset, &len);
 		page = (struct page *)page->private;
 		offset = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--num_buf) {
 		i = skb_shinfo(skb)->nr_frags;
 		if (i >= MAX_SKB_FRAGS) {
@@ -246,6 +262,12 @@ static int receive_mergeable(struct virt
 		set_skb_frag(skb, page, 0, &len);
 
--
 	while (received < budget &&
 	       (buf = virtqueue_get_buf(vi->rvq, &len)) != NULL) {
 		receive_buf(vi->dev, buf, len);
 		--vi->num;
 		received++;
+		if (_cur < timeout) {
--
-	while (a & 0x80 || a & 0x40) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (a & 0x80 || a & 0x40) {
 		/* a little sleep */
 		yield();
 
@@ -276,6 +281,12 @@ card_wait_for_busy_clear(const int ioadd
 				name);
--
-	while (a & 0x80 || !(a & 0x40)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (a & 0x80 || !(a & 0x40)) {
 		/* a little sleep */
 		yield();
 
@@ -300,6 +316,12 @@ card_wait_for_ready(const int ioaddr[],
 				name);
--
-	while (inb(ioaddr[1] + 6) & 0x80) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb(ioaddr[1] + 6) & 0x80) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready timeout\n",
 				name);
 			return -ETIME;
 		}
--
-	while (!(inb(ioaddr[1] + 6) & 0x40)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(inb(ioaddr[1] + 6) & 0x40)) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready timeout\n",
 				name);
 			return -ETIME;
 		}
--
-	while (inb(ioaddr[1] + 6) & 0x80) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb(ioaddr[1] + 6) & 0x80) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready_clear timeout\n",
 				name);
 			return -ETIME;
 		}
--
-	while (inb(ioaddr[1] + 6) & 0x40) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb(ioaddr[1] + 6) & 0x40) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready_clear timeout\n",
 				name);
 			return -ETIME;
 		}
--
-	while (bp->rcv_xmt_reg.index.rcv_comp != p_type_2_cons->index.rcv_cons)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bp->rcv_xmt_reg.index.rcv_comp != p_type_2_cons->index.rcv_cons)
 		{
 		/* Process any errors */
 
@@ -3120,6 +3125,12 @@ static void dfx_rcv_queue_process(
 
--
-	while (bp->rcv_xmt_reg.index.xmt_comp != p_type_2_cons->index.xmt_cons)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bp->rcv_xmt_reg.index.xmt_comp != p_type_2_cons->index.xmt_cons)
 		{
 		/* Get pointer to the transmit driver descriptor block information */
 
@@ -3417,6 +3433,12 @@ static int dfx_xmt_done(DFX_board_t *bp)
 
--
-	while (bp->rcv_xmt_reg.index.xmt_comp != bp->rcv_xmt_reg.index.xmt_prod)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bp->rcv_xmt_reg.index.xmt_comp != bp->rcv_xmt_reg.index.xmt_prod)
 		{
 		/* Get pointer to the transmit driver descriptor block information */
 
@@ -3544,6 +3571,12 @@ static void dfx_xmt_flush( DFX_board_t *
 		 */
--
-	while (smc->e.trace_prop) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (smc->e.trace_prop) {
 		DB_ECM("ECM : prop_actions - trace_prop %d\n",
 			smc->e.trace_prop,0) ;
 
@@ -511,6 +516,12 @@ static void prop_actions(struct s_smc *s
 			DB_ECM("ECM : propagate TRACE on PHY %d\n",upstream,0) ;
--
 	while (HWM_GET_RX_FREE(smc) > 0) {
 		pr_debug(".\n");
 
@@ -1813,6 +1818,12 @@ void mac_drv_fill_rxd(struct s_smc *smc)
 		// Pass receive buffer to HWM.
 		hwm_rx_frag(smc, v_addr, b_addr, MaxFrameSize,
--
 	while (oem_ids[i].oi_status) {
 		switch (oem_ids[i].oi_status) {
 		case OI_STAT_ACTIVE:
@@ -524,6 +529,12 @@ int set_oi_id_def(struct s_smc *smc)
 		default:
 			return 1;		/* invalid oi_status */
--
 	while (*p) {
 		if (!sm_to_para(smc,sm,(int) *p)) {
 			DB_SMT("SMT: smt_check_para - missing para %x\n",*p,0);
 			return -1;
 		}
 		p++ ;
--
 	while (len > 0 ) {
 		if (((struct smt_para *)p)->p_type == para)
 			found = (void *) p ;
@@ -1688,6 +1704,12 @@ void *sm_to_para(struct s_smc *smc, stru
 		}
 		if (found)
--
-	while (len > 0  && *format) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (len > 0  && *format) {
 		switch (*format) {
 		case '[' :
 			open_paren = format ;
@@ -1930,6 +1957,12 @@ static void smt_string_swap(char *data,
 			break ;
--
 	while (tm && !done) {
 		if (delta >= tm->tm_delta) {
 			tm->tm_active = FALSE ;
@@ -140,6 +145,12 @@ static void timer_done(struct s_smc *smc
 			delta = 0 ;
 			done = 1 ;
--
 	while (tx_used) {
 		DRV_BUF_FLUSH(t,DDI_DMA_SYNC_FORCPU) ;
 		tbctrl = le32_to_cpu(t->txd_tbctrl) ;
@@ -620,6 +625,12 @@ static u_long repair_txd_ring(struct s_s
 		DRV_BUF_FLUSH(t,DDI_DMA_SYNC_FORDEV) ;
 		t = t->txd_next ;
--
 	while (rx_used) {
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
 		rbctrl = le32_to_cpu(r->rxd_rbctrl) ;
@@ -672,6 +688,12 @@ static u_long repair_rxd_ring(struct s_s
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORDEV) ;
 		r = r->rxd_next ;
--
 		while ((mb = get_llc_rx(smc))) {
 			smt_to_llc(smc,mb) ;
-		}
+			if (_cur < timeout) {
+rdstcll(_cur);
+			}
--
 		while (!offDepth && (mb = get_llc_rx(smc))) {
 			smt_to_llc(smc,mb) ;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
--
 		while (rx_used && !(r->rxd_rbctrl & cpu_to_le32(BMU_ST_BUF))) {
 			DB_RX("Check STF bit in %x",(void *)r,0,5) ;
 			r = r->rxd_next ;
 			DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
 			frag_count++ ;
 			rx_used-- ;
--
 	while (queue->rx_used) {
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
 		DB_RX("switch OWN bit of RxD 0x%x ",r,0,5) ;
@@ -1489,6 +1549,11 @@ void mac_drv_clear_rx_queue(struct s_smc
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORDEV) ;
 		r = r->rxd_next ;
--
 		while (r != queue->rx_curr_put &&
 			!(r->rxd_rbctrl & cpu_to_le32(BMU_ST_BUF))) {
 			DB_RX("Check STF bit in %x",(void *)r,0,5) ;
@@ -1497,6 +1562,12 @@ void mac_drv_clear_rx_queue(struct s_smc
 			r = r->rxd_next ;
 			DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
--
 	while (len) {
 		n = SMT_PAGESIZE - ((long)data & (SMT_PAGESIZE-1)) ;
 		if (n >= len) {
@@ -1844,6 +1926,12 @@ void smt_send_mbuf(struct s_smc *smc, SM
 		frag_count++ ;
 		len -= n ;
--
 		while (tx_used) {
 			DRV_BUF_FLUSH(t,DDI_DMA_SYNC_FORCPU) ;
 			DB_TX("switch OWN bit of TxD 0x%x ",t,0,5) ;
@@ -2057,6 +2150,12 @@ void mac_drv_clear_tx_queue(struct s_smc
 			DRV_BUF_FLUSH(t,DDI_DMA_SYNC_FORDEV) ;
 			t = t->txd_next ;
--
-				while (pt->p_access == AC_G ||
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (pt->p_access == AC_G ||
 					pt->p_access == AC_GR) {
 					smt_add_para(smc,&pcon,pt->p_num,
 						index,local);
 					pt++ ;
+					if (_cur < timeout) {
--
 	while (swap && (c = *swap++)) {
 		switch(c) {
 		case 'b' :
@@ -1292,6 +1308,12 @@ static int smt_set_para(struct s_smc *sm
 			SMT_PANIC(smc,SMT_E0120, SMT_E0120_MSG) ;
 			return SMT_RDF_ILLEGAL;
--
 			while (n > 0) {
 				nn = (n > 16) ? 16 : n ;
 				if (n > 64) {
@@ -1632,6 +1659,12 @@ void dump_smt(struct s_smc *smc, struct
 				}
 				n -= nn ;
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (len--) {
 		n++ ;
 #ifdef UNIX
 		printf("%x%s",*p++ & 0xff,len ? ( (n & 7) ? " " : "-") : "") ;
 #else
 		printf("%02x%s",*p++ & 0xff,len ? ( (n & 7) ? " " : "-") : "") ;
--
 		while (index != TLB_NULL_INDEX) {
 			u32 next_index = tx_hash_table[index].next;
 			tlb_init_table_entry(&tx_hash_table[index], save_load);
 			index = next_index;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (curr_index != RLB_NULL_INDEX) {
 		struct rlb_client_info *curr = &(bond_info->rx_hashtbl[curr_index]);
 		u32 next_index = bond_info->rx_hashtbl[curr_index].next;
@@ -810,6 +826,12 @@ static void rlb_clear_vlan(struct bondin
 		}
 
--
 	while ((slave = bond->first_slave) != NULL) {
 		/* Inform AD package of unbinding of slave
 		 * before slave is detached from the list.
@@ -2195,6 +2200,12 @@ static int bond_release_all(struct net_d
 
 		/* re-acquire the lock before getting the next slave */
--
 	while (proto) {
 		if ((result = proto->ioctl(dev, ifr)) != -EINVAL)
 			return result;
 		proto = proto->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (*p != proto) {
 		BUG_ON(!*p);
 		p = &((*p)->next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (1) {
                 desc_t *desc = &get_status(port)->tx_descs[port->tx_in];
 		struct sk_buff *skb = port->tx_skbs[port->tx_in];
@@ -187,6 +192,12 @@ static inline void wanxl_tx_intr(port_t
 				 PCI_DMA_TODEVICE);
 		dev_kfree_skb_irq(skb);
--
 	while (desc = &card->status->rx_descs[card->rx_in],
 	       desc->stat != PACKET_EMPTY) {
 		if ((desc->stat & PACKET_PORT_MASK) > card->n_ports)
@@ -238,6 +254,12 @@ static inline void wanxl_rx_intr(card_t
 		}
 		desc->stat = PACKET_EMPTY; /* Free descriptor */
--
         while((stat = readl(card->plx + PLX_DOORBELL_FROM_CARD)) != 0) {
                 handled = 1;
 		writel(stat, card->plx + PLX_DOORBELL_FROM_CARD);
@@ -263,6 +290,12 @@ static irqreturn_t wanxl_intr(int irq, v
 		}
 		if (stat & (1 << DOORBELL_FROM_CARD_RX))
--
-	while ((stat = readl(card->plx + PLX_MAILBOX_0)) != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((stat = readl(card->plx + PLX_MAILBOX_0)) != 0) {
 		if (time_before(timeout, jiffies)) {
 			pr_warn("%s: timeout waiting for PUTS to complete\n",
 				pci_name(pdev));
@@ -673,6 +711,12 @@ static int __devinit wanxl_pci_init_one(
 		}
--
 	while(len)
 	{	
 		offset = addr & SDLA_ADDR_MASK;
@@ -99,6 +104,12 @@ static void __sdla_read(struct net_devic
 		addr += bytes;
 		temp += bytes;
--
 	while(len)
 	{
 		offset = addr & SDLA_ADDR_MASK;
@@ -130,6 +146,12 @@ static void __sdla_write(struct net_devi
 		addr += bytes;
 		temp += bytes;
--
 	while(len)
 	{
 		SDLA_WINDOW(dev, addr);
@@ -163,6 +190,12 @@ static void sdla_clear(struct net_device
 
 		addr += bytes;
--
 	while (time_before(jiffies, done) && (resp != resp1) && (!resp2 || (resp != resp2)))
 	{
 		if (jiffies != now)
@@ -268,6 +306,12 @@ static int sdla_z80_poll(struct net_devi
 			now = jiffies;
 			resp = *temp;
--
 	while (waiting && time_before_eq(jiffies, jiffs))
 	{
 		if (waiting++ % 3) 
@@ -470,6 +519,12 @@ static int sdla_cmd(struct net_device *d
 			waiting = ((volatile int)(cmd_buf->opp_flag));
 			spin_unlock_irqrestore(&sdla_lock, pflags);
--
 	while ((status = cpc_readb(&ptdescr->status)) & DST_OSB) {
 		rcvd += cpc_readw(&ptdescr->len);
 		first_bd = (first_bd + 1) & (N_DMA_RX_BUF - 1);
@@ -456,6 +461,12 @@ static int dma_get_rx_frame_size(pc300_t
 			return rcvd;
 		}
--
 	while (1) {
 		if ((rxb = dma_get_rx_frame_size(card, ch)) == -1)
 			return;
@@ -1954,6 +1970,12 @@ static void cpc_net_rx(struct net_device
 		dev->stats.rx_packets++;
 		skb->protocol = hdlc_type_trans(skb, dev);
--
 	while ((cpc_readl(card->hw.scabase + DTX_REG(CDAL,ch)) !=
 		TX_BD_ADDR(ch,chan->tx_first_bd)) &&
 	       (cpc_readb(&ptdescr->status) & DST_OSB)) {
@@ -1980,7 +2007,13 @@ static void sca_tx_intr(pc300dev_t *dev)
 		chan->nfree_tx_bd++;
 		chan->tx_first_bd = (chan->tx_first_bd + 1) & (N_DMA_TX_BUF - 1);
--
 	while ((gis = cpc_readb(falcbase + F_REG(GIS, ch))) != 0) {
 		if (gis & GIS_ISR0) {
 			isr0 = cpc_readb(falcbase + F_REG(FISR0, ch));
@@ -2266,6 +2304,12 @@ static void falc_t1_intr(pc300_t * card,
 						       cpc_readb(falcbase + F_REG(FRS1, ch)));
 			}
--
 	while ((gis = cpc_readb(falcbase + F_REG(GIS, ch))) != 0) {
 		rsp = cpc_readb(falcbase + F_REG(RSP, ch));
 
@@ -2335,6 +2384,12 @@ static void falc_e1_intr(pc300_t * card,
 				pfalc->es++;
 			}
--
-			while ( (plx_status = (cpc_readb(card->hw.plxbase + card->hw.intctl_reg) &
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while ( (plx_status = (cpc_readb(card->hw.plxbase + card->hw.intctl_reg) &
 				 (PLX_9050_LINT1_STATUS | PLX_9050_LINT2_STATUS))) != 0) {
 				if (plx_status & PLX_9050_LINT1_STATUS) {	/* SCA Interrupt */
 					sca_intr(card);
@@ -2388,6 +2448,12 @@ static irqreturn_t cpc_intr(int irq, voi
 				if (plx_status & PLX_9050_LINT2_STATUS) {	/* FALC Interrupt */
--
 	while (card) {
 		card_t *ptr = card;
 		card = card->next_card;
 		unregister_hdlc_device(port_to_dev(ptr));
 		c101_destroy_card(ptr);
+		if (_cur < timeout) {
--
 	while (i-- > 0) {
 		unregister_hdlc_device(cosa->chan[i].netdev);
 		free_netdev(cosa->chan[i].netdev);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 	while (!chan->rx_status) {
 		current->state = TASK_INTERRUPTIBLE;
 		spin_unlock_irqrestore(&cosa->lock, flags);
@@ -818,6 +834,12 @@ static ssize_t cosa_read(struct file *fi
 			mutex_unlock(&chan->rlock);
 			return -ERESTARTSYS;
--
 	while (!chan->tx_status) {
 		current->state = TASK_INTERRUPTIBLE;
 		spin_unlock_irqrestore(&cosa->lock, flags);
@@ -904,6 +931,12 @@ static ssize_t cosa_write(struct file *f
 			up(&chan->wsem);
 			return -ERESTARTSYS;
--
-	while (length--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (length--) {
 		char c;
 #ifndef SRP_DOWNLOAD_AT_BOOT
 		if (get_user(c, microcode))
@@ -1423,6 +1461,12 @@ static int download(struct cosa_data *co
 		if (put_wait_data(cosa, c) == -1)
--
-	while (length--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (length--) {
 		char c;
 		int i;
 		if ((i=get_wait_data(cosa)) == -1) {
@@ -1499,6 +1548,12 @@ static int readmem(struct cosa_data *cos
 		*microcode = c;
--
-	while (--retries) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (--retries) {
 		/* read data and return them */
 		if (cosa_getstatus(cosa) & SR_RX_RDY) {
 			short r;
@@ -1578,6 +1638,12 @@ static int get_wait_data(struct cosa_dat
 		}
--
-	while (--retries) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (--retries) {
 		/* read data and return them */
 		if (cosa_getstatus(cosa) & SR_TX_RDY) {
 			cosa_putdata8(cosa, data);
@@ -1605,6 +1676,12 @@ static int put_wait_data(struct cosa_dat
 		/* sleep if not ready to read */
--
 	while((stat = sca_intr_status(card)) != 0) {
 		handled = 1;
 		for (i = 0; i < 2; i++) {
@@ -399,6 +404,12 @@ static irqreturn_t sca_intr(int irq, voi
 					sca_tx_intr(port);
 			}
--
 	while( (pdev = pci_get_class( PCI_CLASS_NETWORK_OTHER << 8, pdev ))
 	       != NULL ) {
 		int  pci_irq_line;
@@ -341,6 +346,12 @@ sbni_pci_probe( struct net_device  *dev
 			pci_dev_put( pdev );
 			return  0;
--
 			while (cpc_tty_area[port].buf_rx.first) {
 				aux = (unsigned char *)cpc_tty_area[port].buf_rx.first;
 				cpc_tty_area[port].buf_rx.first = cpc_tty_area[port].buf_rx.first->next;
 				kfree(aux);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 		while (cpc_tty->buf_rx.first) {
 			aux = (unsigned char *)cpc_tty->buf_rx.first;
 			cpc_tty->buf_rx.first = cpc_tty->buf_rx.first->next;
 			kfree(aux);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (1) { 
 		rx_len = 0;
 		ptdescr = (pcsca_bd_t  __iomem *)(card->hw.rambase + RX_BD_ADDR(ch, first_bd));
@@ -878,6 +905,12 @@ void cpc_tty_receive(pc300dev_t *pc300de
 			schedule_work(&(cpc_tty->tty_rx_work));
 			stats->rx_packets++;
--
 	while(c->txcount) {
 		/* FIFO full ? */
 		if(!(read_zsreg(c, R0)&4))
@@ -424,6 +429,12 @@ static void z8530_tx(struct z8530_channe
 			write_zsctrl(c, RES_EOM_L);
 			write_zsreg(c, R10, c->regs[10]&~ABUNDER);
--
 	while(*rtable!=255)
 	{
 		int reg=*rtable++;
@@ -1395,6 +1411,12 @@ int z8530_channel_load(struct z8530_chan
 		if(reg>0x0F)
 			write_zsreg(c, R15, c->regs[15]&~1);
--
 			while(c->txcount && (read_zsreg(c,R0)&Tx_BUF_EMP))
 			{		
 				write_zsreg(c, R8, *c->tx_ptr++);
 				c->txcount--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 		while (!(FST_RDB(card, txDescrRing[pi][port->txpos].bits) &
 			 DMA_OWN) &&
 		       !(card->dmatx_in_progress)) {
@@ -1431,6 +1436,12 @@ do_bottom_half_tx(struct fst_card_info *
 				 */
 				break;
--
 	while (rdidx != wridx) {
 		event = FST_RDB(card, interruptEvent.evntbuff[rdidx]);
 		port = &card->ports[event & 0x03];
@@ -1622,6 +1638,12 @@ fst_intr(int dummy, void *dev_id)
 		/* Bump and wrap the index */
 		if (++rdidx >= MAX_CIRBUFF)
--
-  while(iLen > 0) 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while(iLen > 0) 
     {
       sprintf(pstr, "%02x ", *ucData);
       pstr+=3;
@@ -39,6 +44,12 @@ void lmcConsoleLog(char *type, unsigned
 	}
--
 	while (*s) {
 		d[i] = (*s - '0') << 4;
 		if (*(s + 1))
@@ -1151,6 +1156,12 @@ static int byte_to_nibble(u8 *s, u8 *d,
 		}
 		++i;
--
 	while (len) {
 		*d++ = '0' + (*s >> 4);
 
@@ -1172,6 +1188,12 @@ static void nibble_to_byte(u8 *s, u8 *d,
 		} else break;
 
--
 	while (n > 1) {
 		n >>= 1;
 		++log;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while(dev) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while(dev) {
 		struct cycx_x25_channel *chan = netdev_priv(dev);
 
 		pr_info("%-5.5s %-15.15s   %d     ETH_P_%s\n",
 			chan->name, chan->addr, netif_queue_stopped(dev),
 			chan->protocol == ETH_P_IP ? "IP" : "X25");
--
-		while(1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while(1) {
 			if (*hw == '0' && !valid[0])
 				valid[0] = 1; /* Port 0 enabled */
 			else if (*hw == '1' && !valid[1])
@@ -529,6 +534,12 @@ static int __init n2_init(void)
 			else
--
 	while (card) {
 		card_t *ptr = card;
 		card = card->next_card;
 		n2_destroy_card(ptr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--i >= 0) {
 		dpriv = priv->root + i;
 		pci_free_consistent(pdev, IRQ_RING_SIZE*sizeof(u32),
 				    dpriv->iqrx, dpriv->iqrx_dma);
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (--i >= 0) {
 		dpriv = priv->root + i;
 		pci_free_consistent(pdev, IRQ_RING_SIZE*sizeof(u32),
 				    dpriv->iqtx, dpriv->iqtx_dma);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (i-- > 0) {
 		dscc4_release_ring(root + i);
 		unregister_hdlc_device(dscc4_to_dev(root + i));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 			while (0xffffffc0 & divider) {
 				m++;
 				divider >>= 1;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
--
 			//while (dpriv->rx_needs_refill) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (!(rx_fd->state1 & Hold)) {
 					rx_fd++;
 					cur++;
 					if (!(cur = cur%RX_RING_SIZE))
 						rx_fd = dpriv->rx_fd;
+						if (_cur < timeout) {
--
 	while (pvc) {
 		if (pvc->dlci == dlci)
 			return pvc;
 		if (pvc->dlci > dlci)
 			return NULL; /* the list is sorted */
 		pvc = pvc->next;
--
-	while (*pvc_p) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (*pvc_p) {
 		if (!pvc_is_used(*pvc_p)) {
 			pvc_device *pvc = *pvc_p;
 #ifdef DEBUG_PVC
@@ -259,6 +275,12 @@ static inline void delete_unused_pvcs(hd
 			continue;
--
-		while (pvc) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (pvc) {
 			data[i++] = lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :
 				LMI_ANSI_CISCO_PVCSTAT;
 			data[i++] = stat_len;
@@ -550,6 +577,12 @@ static void fr_lmi_send(struct net_devic
 
--
 			while (pvc) {	/* Activate all PVCs */
 				pvc_carrier(1, pvc);
 				pvc->state.exist = pvc->state.active = 1;
 				pvc->state.new = 0;
 				pvc = pvc->next;
+				if (_cur < timeout) {
--
 		while (pvc) {		/* Deactivate all PVCs */
 			pvc_carrier(0, pvc);
 			pvc->state.exist = pvc->state.active = 0;
@@ -591,6 +640,12 @@ static void fr_set_link_state(int reliab
 			if (!state(hdlc)->settings.dce)
 				pvc->state.bandwidth = 0;
--
 			while (pvc) {
 				if (pvc->state.new) {
 					pvc->state.new = 0;
@@ -756,6 +816,12 @@ static int fr_lmi_recv(struct net_device
 					state(hdlc)->dce_changed = 1;
 				}
--
 	while (pvc) {
 		pvc->state.deleted = 1;
 		pvc = pvc->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (skb->len >= i + 2 + stat_len) {
 		u16 dlci;
 		u32 bw;
@@ -843,10 +925,21 @@ static int fr_lmi_recv(struct net_device
 		}
 
--
 	while (pvc) {
 		if (pvc->state.deleted && pvc->state.exist) {
 			pvc_carrier(0, pvc);
@@ -856,6 +949,12 @@ static int fr_lmi_recv(struct net_device
 			fr_log_dlci_active(pvc);
 		}
--
 	while (pvc) {		/* Shutdown all PVCs for this FRAD */
 		if (pvc->main)
 			dev_close(pvc->main);
 		if (pvc->ether)
 			dev_close(pvc->ether);
 		pvc = pvc->next;
--
 	while (pvc) {
 		pvc_device *next = pvc->next;
 		/* destructors will free_netdev() main and ether */
@@ -1160,6 +1275,12 @@ static void fr_destroy(struct net_device
 
 		kfree(pvc);
--
-	while (received < budget) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (received < budget) {
 		struct sk_buff *skb;
 		struct desc *desc;
 		int n;
@@ -779,6 +784,12 @@ static int hss_hdlc_poll(struct napi_str
 		desc->pkt_len = 0;
--
-	while ((n_desc = queue_get_desc(queue_ids[port->id].txdone,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((n_desc = queue_get_desc(queue_ids[port->id].txdone,
 					port, 1)) >= 0) {
 		struct desc *desc;
 		int start;
@@ -824,6 +840,12 @@ static void hss_hdlc_txdone_irq(void *pd
 #endif
--
-	while (readw(addr)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (readw(addr)) {
 		udelay(1000);
 
 		if (++i > 50)
 			return -1;
+			if (_cur < timeout) {
--
 	while (count--) {
 		if (fp && *fp++) {
 			if (!test_and_set_bit(SLF_ERROR, &sl->flags))
@@ -534,6 +539,12 @@ static void x25_asy_receive_buf(struct t
 			continue;
 		}
--
 	while (len-- > 0) {
 		switch (c = *s++) {
 		case X25_END:
@@ -646,6 +662,12 @@ static int x25_asy_esc(unsigned char *s,
 			*ptr++ = c;
 			break;
--
-	while (!(rd->rdma.cntinfo & HPCDMA_OWN)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(rd->rdma.cntinfo & HPCDMA_OWN)) {
 		len = PKT_BUF_SZ - (rd->rdma.cntinfo & HPCDMA_BCNT) - 3;
 		dma_unmap_single(dev->dev.parent, rd->rdma.pbuf,
 				 PKT_BUF_SZ, DMA_FROM_DEVICE);
@@ -404,6 +409,12 @@ memory_squeeze:
 		dma_sync_desc_dev(dev, rd);
--
 	while ((td->tdma.cntinfo & (HPCDMA_XIU | HPCDMA_ETXD)) ==
 	      (HPCDMA_XIU | HPCDMA_ETXD)) {
 		i = NEXT_TX(i);
 		td = &sp->tx_desc[i];
 		dma_sync_desc_cpu(dev, td);
+		if (_cur < timeout) {
--
 	while (i < (nbufs - 1)) {
 		buf[i].tdma.pnext = VIRT_TO_DMA(sp, buf + i + 1);
 		buf[i].tdma.pbuf = 0;
 		dma_sync_desc_dev(dev, &buf[i]);
 		i++;
+		if (_cur < timeout) {
--
 	while (i < (nbufs - 1)) {
 		buf[i].rdma.pnext = VIRT_TO_DMA(sp, buf + i + 1);
 		buf[i].rdma.pbuf = 0;
 		dma_sync_desc_dev(dev, &buf[i]);
 		i++;
+		if (_cur < timeout) {
--
 	while ((ether3_inw(REG_STATUS) & STAT_FIFOEMPTY) == 0) {
 		if (!timeout--) {
 			printk("%s: setbuffer broken\n", dev->name);
@@ -129,6 +134,12 @@ ether3_setbuffer(struct net_device *dev,
 			return 1;
 		}
--
 	while(waittime < 2000) {
 		if(inl(ee_addr) & EEGNT) {
 
@@ -393,6 +398,12 @@ static int __devinit sis96x_get_mac_addr
 			udelay(1);
 			waittime ++;
--
 			while (mii_phy) {
 				struct mii_phy *phy;
 				phy = mii_phy;
 				mii_phy = mii_phy->next;
 				kfree(phy);
+				if (_cur < timeout) {
--
-		while (poll_bit) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (poll_bit) {
 			yield();
 
 			poll_bit ^= (mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS) & poll_bit);
@@ -689,6 +716,12 @@ static int __devinit sis900_mii_probe(st
 				       dev_name);
--
 	while (status && (i++ < 1000)) {
 		status ^= (inl(isr + ioaddr) & status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (sis_priv->first_mii) {
 		phy = sis_priv->first_mii;
 		sis_priv->first_mii = phy->next;
 		kfree(phy);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((tx_status = le32_to_cpu(np->tx_done_q[np->tx_done].status)) != 0) {
 			if (debug > 3)
 				printk(KERN_DEBUG "%s: Tx completion #%d entry %d is %#8.8x.\n",
@@ -1389,6 +1394,12 @@ static irqreturn_t intr_handler(int irq,
 			}
 			np->tx_done_q[np->tx_done].status = 0;
--
 	while ((desc_status = le32_to_cpu(np->rx_done_q[np->rx_done].status)) != 0) {
 		struct sk_buff *skb;
 		u16 pkt_len;
@@ -1536,6 +1552,12 @@ static int __netdev_rx(struct net_device
 		np->cur_rx++;
 		desc->status = 0;
--
 		while (vlan_count < 32) {
 			writew(0, filter_addr);
 			filter_addr += 16;
 			vlan_count++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (i++ < 16) {
 			writew(be16_to_cpu(eaddrs[0]), filter_addr); filter_addr += 4;
 			writew(be16_to_cpu(eaddrs[1]), filter_addr); filter_addr += 4;
 			writew(be16_to_cpu(eaddrs[2]), filter_addr); filter_addr += 8;
+			if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while(base == 0xFF)
 	{
 		i++;
@@ -469,6 +474,12 @@ static int __init mc32_probe1(struct net
 		udelay(1000);
 		if(inb(dev->base_addr+2)&(1<<5))
--
 		while(!(inb(dev->base_addr+2)&(1<<5)))
 		{
 			n++;
@@ -497,6 +513,12 @@ static int __init mc32_probe1(struct net
 				err = -ENODEV;
 				goto err_exit_irq;
--
 	while((inb(ioaddr+HOST_STATUS)&HOST_STATUS_CWR) && boguscount++<2000)
 	{
 		status=inb(ioaddr+HOST_CMD);
@@ -1401,6 +1428,12 @@ static irqreturn_t mc32_interrupt(int ir
 
 			mc32_update_stats(dev);
--
 	while (ether1_readw(dev, ISCP_ADDR, iscp_t, iscp_busy, DISABLEIRQS) == 1) {
 		if (time_after(jiffies, timeout)) {
 			printk (KERN_WARNING "%s: can't initialise 82586: iscp is busy\n", dev->name);
 			return 1;
 		}
+		if (_cur < timeout) {
--
 		while ((inb_status(dev->base_addr) & ACRF) != 0 && time_before(jiffies, timeout)) {
 			if (receive_pcb(dev, &adapter->irx_pcb)) {
 				switch (adapter->irx_pcb.command)
@@ -823,6 +828,12 @@ static irqreturn_t elp_interrupt(int irq
 				pr_warning("%s: failed to read PCB on interrupt\n", dev->name);
 				adapter_reset(dev);
--
 	} while (icount++ < 5 && (inb_status(dev->base_addr) & (ACRF | DONE)));
@@ -1342,10 +1353,22 @@ static int __init elp_autodetect(struct
 	if (dev->base_addr != 0) {	/* dev->base_addr == 0 ==> plain autodetect */
 		if (elp_sense(dev) == 0)
 			return dev->base_addr;
-	} else
-		while ((dev->base_addr = addr_list[idx++])) {
-			if (elp_sense(dev) == 0)
-				return dev->base_addr;
+	} else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
--
+			while ((dev->base_addr = addr_list[idx++])) {
+				if (elp_sense(dev) == 0)
+					return dev->base_addr;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
--
 	while (((status = inb(ioaddr + STATUS_REG)) & (RX_INT|TX_INT)) && (boguscount--))
 	{
 		handled = 1;
@@ -1231,6 +1236,12 @@ eepro_interrupt(int irq, void *dev_id)
 
 			eepro_en_int(ioaddr);
--
 	while (slot != -1) {
 		status = mca_read_stored_pos(slot, 2);
 
@@ -459,6 +464,12 @@ static int __init do_elmc_probe(struct n
 
 		/* found what we're looking for... */
--
-	while (cmd != I596_NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cmd != I596_NULL) {
 		printk(KERN_ERR "cmd at %p, .status = %04x, .command = %04x, .b_next = %p\n",
 		  cmd, cmd->status, cmd->command, cmd->b_next);
 		cmd = cmd->v_next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while ((rfd->stat) & STAT_C) {	/* Loop while complete frames */
 		if (rfd->rbd == I596_NULL)
 			rbd = I596_NULL;
@@ -894,6 +910,12 @@ memory_squeeze:
 		lp->scb.rfd = rfd->b_next;
 		lp->rfd_head = rfd->v_next;
--
 	while (lp->cmd_head != I596_NULL) {
 		ptr = lp->cmd_head;
 		lp->cmd_head = ptr->v_next;
@@ -929,6 +956,12 @@ static void i596_cleanup_cmd(struct net_
 		default:
 			ptr->v_next = ptr->b_next = I596_NULL;
--
-		while ((lp->cmd_head != I596_NULL) && (lp->cmd_head->status & STAT_C)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((lp->cmd_head != I596_NULL) && (lp->cmd_head->status & STAT_C)) {
 			ptr = lp->cmd_head;
 
 			DEB(DEB_STATUS,printk(KERN_DEBUG "cmd_head->status = %04x, ->command = %04x\n",
@@ -1410,12 +1448,29 @@ static irqreturn_t i596_interrupt(int ir
 			}
--
 		while ((ptr != I596_NULL) && (ptr != lp->cmd_tail)) {
 			ptr->command &= 0x1fff;
 			ptr = ptr->v_next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (--delcnt && dma->iscp.stat) {
 		udelay(10);
 		DMA_INV(dev, &(dma->iscp), sizeof(struct i596_iscp));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (--delcnt && dma->scb.command) {
 		udelay(10);
 		DMA_INV(dev, &(dma->scb), sizeof(struct i596_scb));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (cmd != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cmd != NULL) {
 		printk(KERN_DEBUG
 		       "cmd at %p, .status = %04x, .command = %04x,"
 		       " .b_next = %08x\n",
 		       cmd, SWAP16(cmd->status), SWAP16(cmd->command),
 		       SWAP32(cmd->b_next));
--
 	while (rfd->stat & SWAP16(STAT_C)) {	/* Loop while complete frames */
 		if (rfd->rbd == I596_NULL)
 			rbd = NULL;
@@ -789,6 +827,12 @@ memory_squeeze:
 		DMA_WBACK_INV(dev, rfd->v_prev, sizeof(struct i596_rfd));
 		rfd = lp->rfd_head;
--
 	while (lp->cmd_head != NULL) {
 		ptr = lp->cmd_head;
 		lp->cmd_head = ptr->v_next;
@@ -830,6 +879,12 @@ static inline void i596_cleanup_cmd(stru
 			ptr->b_next = I596_NULL;
 		}
--
 		while ((ptr != NULL) && (ptr != lp->cmd_tail)) {
 			struct i596_cmd *prev = ptr;
 
 			ptr->command &= SWAP16(0x1fff);
 			ptr = ptr->v_next;
 			DMA_WBACK_INV(dev, prev, sizeof(struct i596_cmd));
--
 				while (!SCB_complete(rsst=scb_status(dev)))
 				{
 					if (!--boguscount)
@@ -566,6 +571,12 @@ static void unstick_cu(struct net_device
 						scb_command(dev, SCB_CUstart);
 						outb(0,ioaddr+SIGNAL_CA);
--
 		while (!scb_status(dev))
 		{
 			if (!--boguscount)
@@ -1336,6 +1352,12 @@ static void eexp_hw_txrestart(struct net
 					return;
 				}
--
 		while (inw(ioaddr+0x4000))
 		{
 			if (!--rboguscount)
@@ -1532,6 +1559,12 @@ static void eexp_hw_init586(struct net_d
 					return;
 				}
--
 		while (!scb_status(dev))
 		{
 			if (!--iboguscount)
@@ -1560,6 +1598,12 @@ static void eexp_hw_init586(struct net_d
 					return;
 				}
--
 	while (znet->rx_start + cur_frame_end_offset != znet->rx_cur &&
 	       ++boguscount < 5) {
 		unsigned short hi_cnt, lo_cnt, hi_status, lo_status;
@@ -731,6 +736,12 @@ static void znet_rx(struct net_device *d
 		cur_frame_end_offset -= ((count + 1)>>1) + 3;
 		if (cur_frame_end_offset < 0)
--
-	while (lp->scb.command) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (lp->scb.command) {
 		if (--boguscnt == 0) {
 			printk("%s: %s timed out - stat %4.4x, cmd %4.4x\n",
 			       dev->name, msg,
@@ -400,6 +405,12 @@ i596_timeout(struct net_device *dev, cha
 		}
--
-	while (lp->iscp.busy) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (lp->iscp.busy) {
 		if (--boguscnt == 0) {
 			/* No i82596 present? */
 			printk("%s: i82596 initialization timed out\n",
@@ -609,6 +625,12 @@ i596_scp_setup(struct net_device *dev) {
 		}
--
 	while (lp->cmd_head) {
 		cmd = (struct i596_cmd *)lp->cmd_head;
 
@@ -773,6 +800,12 @@ i596_cleanup_cmd(struct net_device *dev)
 			}
 		}
--
-	while (lp->cmd_head && (lp->cmd_head->status & CMD_STAT_C)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (lp->cmd_head && (lp->cmd_head->status & CMD_STAT_C)) {
 		cmd = lp->cmd_head;
 
 		lp->cmd_head = pa_to_va(lp->cmd_head->pa_next);
@@ -1132,13 +1170,30 @@ i596_handle_CU_completion(struct net_dev
 
--
 	while (cmd && (cmd != lp->cmd_tail)) {
 		cmd->command &= 0x1fff;
 		cmd = pa_to_va(cmd->pa_next);
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (work--) {
 		if (!(cpr8(Cmd) & CmdReset))
 			return;
 
 		schedule_timeout_uninterruptible(10);
+		if (_cur < timeout) {
--
 	while (i < len - 1) {
 		val = read_eeprom(cp->regs, offset, addr_len);
 		data[i++] = (u8)val;
 		data[i++] = (u8)(val >> 8);
 		offset++;
+		if (_cur < timeout) {
--
 	while (i < len - 1) {
 		val = (u16)data[i++];
 		val |= (u16)data[i++] << 8;
 		write_eeprom(cp->regs, offset, val, addr_len);
 		offset++;
+		if (_cur < timeout) {
--
 	while (netif_running(dev) && received < budget &&
 	       (RTL_R8 (ChipCmd) & RxBufEmpty) == 0) {
 		u32 ring_offset = cur_rx % RX_BUF_LEN;
@@ -2013,6 +2018,12 @@ no_early_rx:
 		RTL_W16 (RxBufPtr, (u16) (cur_rx - 16));
 
--
 	while (len-- > 0) {
 		rtl_eri_write(ioaddr, r->addr, r->mask, r->val, ERIAR_EXGMAC);
 		r++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (len-- > 0) {
 		rtl_writephy(tp, regs->reg, regs->val);
 		regs++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (len-- > 0) {
 		w = (rtl_ephy_read(ioaddr, e->offset) & ~e->mask) | e->bits;
 		rtl_ephy_write(ioaddr, e->offset, w);
 		e++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--num_bits >= 0) {
 		char outval = (cmd & (1<<num_bits)) ? EE_DATA_WRITE : 0;
 		write_reg_high(ioaddr, PROM_CMD, outval | EE_CLK_LOW);
@@ -412,6 +417,12 @@ static unsigned short __init eeprom_op(l
 		eedata_out <<= 1;
 		if (read_nibble(ioaddr, PROM_DATA) & EE_DATA_READ)
--
 	while (root_atp_dev) {
 		struct net_local *atp_local = netdev_priv(root_atp_dev);
 		next_dev = atp_local->next_module;
@@ -933,6 +949,12 @@ static void __exit atp_cleanup_module(vo
 		/* No need to release_region(), since we never snarf it. */
 		free_netdev(root_atp_dev);
--
-	while (evtcsm != evtprd) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (evtcsm != evtprd) {
 		switch (ap->evt_ring[evtcsm].evt) {
 		case E_FW_RUNNING:
 			printk(KERN_INFO "%s: Firmware up and running\n",
@@ -1927,6 +1932,12 @@ static u32 ace_handle_event(struct net_d
 			       ap->name, ap->evt_ring[evtcsm].evt);
--
 	while (idx != rxretprd) {
 		struct ring_info *rip;
 		struct sk_buff *skb;
@@ -2030,6 +2046,12 @@ static void ace_rx_int(struct net_device
 		dev->stats.rx_bytes += retdesc->size;
 
--
-	while (size > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size > 0) {
 		tsize = min_t(u32, ((~dest & (ACE_WINDOW_SIZE - 1)) + 1),
 			    min_t(u32, size, ACE_WINDOW_SIZE));
 		tdest = (void __iomem *) &regs->Window +
@@ -2851,6 +2878,12 @@ static void __devinit ace_copy(struct ac
 			dest += 4;
--
-	while (size > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size > 0) {
 		tsize = min_t(u32, ((~dest & (ACE_WINDOW_SIZE - 1)) + 1),
 				min_t(u32, size, ACE_WINDOW_SIZE));
 		tdest = (void __iomem *) &regs->Window +
@@ -2876,6 +2914,12 @@ static void __devinit ace_clear(struct a
 
--
 	while ((nolock_regb_read(priv, reg) & mask) != val) {
 		if (time_after(jiffies, timeout)) {
 			if (netif_msg_drv(priv))
@@ -430,6 +435,12 @@ static int poll_ready(struct enc28j60_ne
 			return -ETIMEDOUT;
 		}
--
-#define eeprom_slow_io() do { int _i = 40; while(--_i > 0) { inb(0x80); }}while(0)
+#define eeprom_slow_io() do { int _i = 40; unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while(--_i > 0) { inb(0x80); if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}}while(0)
 
 /* Jumperless Configuration Register (BMPR19) */
 #define JUMPERLESS_CONFIG      19
@@ -765,10 +776,21 @@ static int eth16i_send_probe_packet(int
 	starttime = jiffies;
--
 	while( (inb(ioaddr + TX_STATUS_REG) & 0x80) == 0) {
 		if( time_after(jiffies, starttime + TX_TIMEOUT)) {
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while((inb(ioaddr + TX_STATUS_REG) & 0x20) == 0) {
 		if( time_after(jiffies, starttime + TX_TIMEOUT)) {
 
 			if(eth16i_debug > 1)
 				printk(KERN_DEBUG "Timeout occurred waiting transmit packet received\n");
 			starttime = jiffies;
--
 			while((inb(ioaddr + RX_STATUS_REG) & 0x80) == 0) {
 				if( time_after(jiffies, starttime + TX_TIMEOUT)) {
 					if(eth16i_debug > 1)
 						printk(KERN_DEBUG "Timeout occurred waiting receive packet\n");
 					return -1;
 				}
--
 		while( (cbyte & 0x01) == 0) {
 			cbyte = cbyte >> 1;
 			index++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (hw_reg_addr <= REG_MAC_RX_STATUS_END) {
 		AT_READ_REG(&adapter->hw, hw_reg_addr, &data);
 		*stats_item += data;
 		stats_item++;
 		hw_reg_addr += 4;
+		if (_cur < timeout) {
--
 	while (hw_reg_addr <= REG_MAC_TX_STATUS_END) {
 		AT_READ_REG(&adapter->hw, hw_reg_addr, &data);
 		*stats_item += data;
 		stats_item++;
 		hw_reg_addr += 4;
+		if (_cur < timeout) {
--
 	while (next_to_clean != hw_next_to_clean) {
 		buffer_info = &tpd_ring->buffer_info[next_to_clean];
 		atl1c_clean_buffer(pdev, buffer_info, 1);
 		if (++next_to_clean == tpd_ring->count)
 			next_to_clean = 0;
 		atomic_set(&tpd_ring->next_to_clean, next_to_clean);
--
 		while (1) {
 			if (atl1_read_eeprom(hw, i + 0x100, &control)) {
 				if (key_valid) {
@@ -468,6 +473,12 @@ static int atl1_get_permanent_address(st
 				/* read error */
 				break;
--
 	while (1) {
 		if (atl1_spi_read(hw, i + 0x1f000, &control)) {
 			if (key_valid) {
@@ -501,6 +517,12 @@ static int atl1_get_permanent_address(st
 			/* read error */
 			break;
--
 	while (rfd_ring->next_to_clean != (rrd->buf_indx + offset)) {
 		rfd_ring->buffer_info[rfd_ring->next_to_clean].alloced = 0;
 		if (++rfd_ring->next_to_clean == rfd_ring->count) {
 			rfd_ring->next_to_clean = 0;
 		}
+		if (_cur < timeout) {
--
 	while (1) {
 		rrd = ATL1_RRD_DESC(rrd_ring, rrd_next_to_clean);
 		i = 1;
@@ -2035,6 +2073,12 @@ rrd_ok:
 		buffer_info->skb = NULL;
 		buffer_info->alloced = 0;
--
-	while (cmb_tpd_next_to_clean != sw_tpd_next_to_clean) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cmb_tpd_next_to_clean != sw_tpd_next_to_clean) {
 		buffer_info = &tpd_ring->buffer_info[sw_tpd_next_to_clean];
 		if (buffer_info->dma) {
 			pci_unmap_page(adapter->pdev, buffer_info->dma,
@@ -2089,6 +2138,12 @@ static void atl1_intr_tx(struct atl1_ada
 
--
 		while (1) {
 			if (atl2_read_eeprom(hw, i + 0x100, &Control)) {
 				if (KeyValid) {
@@ -2288,6 +2293,12 @@ static int get_permanent_address(struct
 				break; /* read error */
 			}
--
 	while (1) {
 		if (atl2_spi_read(hw, i + 0x1f000, &Control)) {
 			if (KeyValid) {
@@ -2324,6 +2340,12 @@ static int get_permanent_address(struct
 			break; /* read error */
 		}
--
 	while (hw_reg_addr <= REG_MAC_RX_STATUS_END) {
 		*stats_item += AT_READ_REG(&adapter->hw, hw_reg_addr);
 		stats_item++;
 		hw_reg_addr += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (hw_reg_addr <= REG_MAC_TX_STATUS_END) {
 		*stats_item += AT_READ_REG(&adapter->hw, hw_reg_addr);
 		stats_item++;
 		hw_reg_addr += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (next_to_clean != hw_next_to_clean) {
 		tx_buffer = &tx_ring->tx_buffer[next_to_clean];
 		if (tx_buffer->dma) {
@@ -1246,6 +1273,12 @@ static bool atl1e_clean_tx_irq(struct at
 
 		if (++next_to_clean == tx_ring->count)
--
 	while (mapped_len < buf_len) {
 		/* mapped_len == 0, means we should use the first tpd,
 		   which is given by caller  */
@@ -1745,11 +1783,22 @@ static int atl1e_tx_map(struct atl1e_ada
 			/* We need to unwind the mappings we've done */
 			ring_end = adapter->tx_ring.next_to_use;
--
 			while (adapter->tx_ring.next_to_use != ring_end) {
 				tpd = atl1e_get_tpd(adapter);
 				tx_buffer = atl1e_get_tx_buffer(adapter, tpd);
 				pci_unmap_single(adapter->pdev, tx_buffer->dma,
 						 tx_buffer->length, PCI_DMA_TODEVICE);
+				if (_cur < timeout) {
--
 				while (adapter->tx_ring.next_to_use != ring_end) {
 					tpd = atl1e_get_tpd(adapter);
 					tx_buffer = atl1e_get_tx_buffer(adapter, tpd);
 					dma_unmap_page(&adapter->pdev->dev, tx_buffer->dma,
 						       tx_buffer->length, DMA_TO_DEVICE);
+					if (_cur < timeout) {
--
 	while (*ptr != '\0' && ptr < limit) {
 		if (memcmp(ptr, "MAC=", 4) == 0) {
 			ptr += 4;
@@ -505,6 +510,12 @@ static int myri10ge_read_mac_addr(struct
 			mgp->serial_number = simple_strtoul(ptr, &ptr, 10);
 		}
 		while (ptr < limit && *ptr++) ;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (mgp->cmd->data != MYRI10GE_NO_CONFIRM_DATA && i < 9) {
 		msleep(1 << i);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (len > 0) {
 		memcpy(skb_frags, rx_frags, sizeof(*skb_frags));
 		len -= skb_frag_size(rx_frags);
 		skb_frags++;
 		rx_frags++;
 		skb_shinfo(skb)->nr_frags++;
--
 	while (rx->fill_cnt != (rx->cnt + rx->mask + 1)) {
 		idx = rx->fill_cnt & rx->mask;
 		if (rx->page_offset + bytes <= MYRI10GE_ALLOC_SIZE) {
@@ -1294,6 +1332,12 @@ myri10ge_alloc_rx_pages(struct myri10ge_
 			myri10ge_submit_8rx(&rx->lanai[idx - 7],
 					    &rx->shadow[idx - 7]);
--
 	while (tx->pkt_done != mcp_index) {
 		idx = tx->done & tx->mask;
 		skb = tx->info[idx].skb;
@@ -1440,6 +1489,12 @@ myri10ge_tx_done(struct myri10ge_slice_s
 							      bus), len,
 					       PCI_DMA_TODEVICE);
--
 	while (rx_done->entry[idx].length != 0 && work_done < budget) {
 		length = ntohs(rx_done->entry[idx].length);
 		rx_done->entry[idx].length = 0;
@@ -1503,6 +1563,12 @@ myri10ge_clean_rx_done(struct myri10ge_s
 		cnt++;
 		idx = cnt & (mgp->max_intr_slots - 1);
--
 	while (tx->done != tx->req) {
 		idx = tx->done & tx->mask;
 		skb = tx->info[idx].skb;
@@ -2176,6 +2247,12 @@ static void myri10ge_free_rings(struct m
 							      bus), len,
 					       PCI_DMA_TODEVICE);
--
-				while (i >= 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (i >= 0) {
 					free_irq(mgp->msix_vectors[i].vector,
 						 &mgp->ss[i]);
 					i--;
+					if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (slice) {
 		slice--;
 		napi_disable(&mgp->ss[slice].napi);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (cnt > 1) {
 		cnt--;
 		idx = (starting_slot + cnt) & tx->mask;
 		myri10ge_pio_copy(&tx->lanai[idx], &src[cnt], sizeof(*src));
 		mb();
+		if (_cur < timeout) {
--
-		while (len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (len) {
 			u8 flags_next;
 			int cum_len_next;
 
@@ -2919,6 +3034,12 @@ again:
 				else
--
 	while (segs) {
 		curr = segs;
 		segs = segs->next;
@@ -3030,6 +3156,12 @@ static netdev_tx_t myri10ge_sw_tso(struc
 			}
 			goto drop;
--
-	while (mgp->num_slices > 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (mgp->num_slices > 1) {
 		/* make sure it is a power of two */
 		while (!is_power_of_2(mgp->num_slices))
 			mgp->num_slices--;
@@ -3871,7 +4008,13 @@ static void myri10ge_probe_slices(struct
 			mgp->num_slices = status;
 		else
 			goto disable_msix;
--
 	while (info->num_needed_small_buffers != 0) {
 		if (!tile_net_provide_needed_buffer(info, true))
 			goto oops;
 		info->num_needed_small_buffers--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (info->num_needed_large_buffers != 0) {
 		if (!tile_net_provide_needed_buffer(info, false))
 			goto oops;
 		info->num_needed_large_buffers--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (comp_head != comp_busy && n < comps_size) {
 		comps[n++] = eq->comps[comp_head];
 		LEPP_QINC(comp_head);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (qup->__packet_receive_read !=
 	       qsp->__packet_receive_queue.__packet_write) {
 		int index = qup->__packet_receive_read;
 		tile_net_discard_aux(info, index);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (countdown && mbx->ops.check_for_msg(hw)) {
 		countdown--;
 		udelay(mbx->udelay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (countdown && mbx->ops.check_for_ack(hw)) {
 		countdown--;
 		udelay(mbx->udelay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	/* we cannot reset while the RSTI / RSTD bits are asserted */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!mbx->ops.check_for_rst(hw) && timeout) {
 		timeout--;
 		udelay(5);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 			while (i) {
 				i--;
 				ixgbevf_free_tx_resources(adapter,
 							  &tx_ring[i]);
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 			while (i) {
 				i--;
 				ixgbevf_free_rx_resources(adapter,
 							  &rx_ring[i]);
-			}
+				if (_cur < timeout) {
--
 	while (test->reg) {
 		for (i = 0; i < test->array_len; i++) {
 			switch (test->test_type) {
@@ -605,6 +632,12 @@ static int ixgbevf_reg_test(struct ixgbe
 			}
 		}
--
 	while ((eop_desc->wb.status & cpu_to_le32(IXGBE_TXD_STAT_DD)) &&
 	       (count < tx_ring->work_limit)) {
 		bool cleaned = false;
@@ -238,6 +243,12 @@ static bool ixgbevf_clean_tx_irq(struct
 cont_loop:
 		eop = tx_ring->tx_buffer_info[i].next_to_watch;
--
 	while (cleaned_count--) {
 		rx_desc = IXGBE_RX_DESC_ADV(*rx_ring, i);
 
@@ -417,7 +433,13 @@ static void ixgbevf_alloc_rx_buffers(str
 		if (i == rx_ring->count)
 			i = 0;
--
 	 * set them up later while requesting irq's.
 	 */
-	while (vectors >= vector_threshold) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (vectors >= vector_threshold) {
 		err = pci_enable_msix(adapter->pdev, adapter->msix_entries,
 				      vectors);
 		if (!err) /* Success in acquiring all requested vectors. */
@@ -1903,6 +1930,12 @@ static void ixgbevf_acquire_msix_vectors
 			vectors = 0; /* Nasty failure, quit now */
--
 	while (q_idx) {
 		q_idx--;
 		q_vector = adapter->q_vector[q_idx];
 		netif_napi_del(&q_vector->napi);
 		kfree(q_vector);
 		adapter->q_vector[q_idx] = NULL;
--
 	while (len) {
 		tx_buffer_info = &tx_ring->tx_buffer_info[i];
 		size = min(len, (unsigned int)IXGBE_MAX_DATA_PER_TXD);
@@ -2909,6 +2958,12 @@ static int ixgbevf_tx_map(struct ixgbevf
 		i++;
 		if (i == tx_ring->count)
--
 		while (len) {
 			tx_buffer_info = &tx_ring->tx_buffer_info[i];
 			size = min(len, (unsigned int)IXGBE_MAX_DATA_PER_TXD);
@@ -2939,6 +2999,12 @@ static int ixgbevf_tx_map(struct ixgbevf
 			i++;
 			if (i == tx_ring->count)
--
 	while (count >= 0) {
 		count--;
 		i--;
@@ -2970,6 +3041,12 @@ dma_error:
 			i += tx_ring->count;
 		tx_buffer_info = &tx_ring->tx_buffer_info[i];
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		tx_buffer_info = &tx_ring->tx_buffer_info[i];
 		tx_desc = IXGBE_TX_DESC_ADV(*tx_ring, i);
 		tx_desc->read.buffer_addr = cpu_to_le64(tx_buffer_info->dma);
@@ -3022,6 +3104,12 @@ static void ixgbevf_tx_queue(struct ixgb
 		i++;
--
-	while (mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (mask) {
 		/* A "1" is shifted out to the PHY by setting the MDIO bit to "1" and
 		 * then raising and lowering the Management Data Clock. A "0" is
 		 * shifted out to the PHY by setting the MDIO bit to "0" and then
@@ -2764,6 +2769,12 @@ static void e1000_shift_out_mdi_bits(str
 		e1000_lower_mdi_clk(hw, &ctrl);
--
 		while ((!(eecd & E1000_EECD_GNT)) &&
 		       (i < E1000_EEPROM_GRANT_ATTEMPTS)) {
 			i++;
 			udelay(5);
 			eecd = er32(EECD);
+			if (_cur < timeout) {
--
-	while (widx < words) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (widx < words) {
 		u8 write_opcode = EEPROM_WRITE_OPCODE_SPI;
 
 		if (e1000_spi_eeprom_ready(hw))
@@ -4189,6 +4216,12 @@ static s32 e1000_write_eeprom_spi(struct
 				break;
--
-	while (words_written < words) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (words_written < words) {
 		/* Send the Write command (3-bit opcode + addr) */
 		e1000_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE_MICROWIRE,
 					eeprom->opcode_bits);
@@ -4260,6 +4298,12 @@ static s32 e1000_write_eeprom_microwire(
 		e1000_standby_eeprom(hw);
--
 	while (pvfdev) {
 		if (pvfdev->devfn == vf_devfn &&
 		    (pvfdev->bus->number >= pdev->bus->number))
@@ -73,6 +78,12 @@ static int ixgbe_find_enabled_vfs(struct
 		vf_devfn += 2;
 		pvfdev = pci_get_device(IXGBE_INTEL_VENDOR_ID,
--
 				while (i) {
 					i--;
 					ixgbe_free_tx_resources(&temp_tx_ring[i]);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
--
 				while (i) {
 					i--;
 					ixgbe_free_rx_resources(&temp_rx_ring[i]);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
--
 	while (test->reg) {
 		for (i = 0; i < test->array_len; i++) {
 			switch (test->test_type) {
@@ -1391,6 +1418,12 @@ static int ixgbe_reg_test(struct ixgbe_a
 			}
 		}
--
-	while (staterr & IXGBE_RXD_STAT_DD) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (staterr & IXGBE_RXD_STAT_DD) {
 		/* check Rx buffer */
 		rx_buffer_info = &rx_ring->rx_buffer_info[rx_ntc];
 
@@ -1762,6 +1800,12 @@ static u16 ixgbe_clean_test_rings(struct
 		/* fetch next descriptor */
--
-	while (!end_data) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!end_data) {
 		/*
 		 * Read control word from PHY init contents offset
 		 */
@@ -820,6 +825,12 @@ s32 ixgbe_reset_phy_nl(struct ixgbe_hw *
 			ret_val = IXGBE_ERR_PHY;
--
 	while (sfp_id != IXGBE_PHY_INIT_END_NL) {
 		if (sfp_id == sfp_type) {
 			(*list_offset)++;
@@ -1156,6 +1172,12 @@ s32 ixgbe_get_sfp_init_sequence_offsets(
 			if (hw->eeprom.ops.read(hw, *list_offset, &sfp_id))
 				return IXGBE_ERR_PHY;
--
 		while (len) {
 			/* max number of buffers allowed in one DDP context */
 			if (j >= IXGBE_BUFFCNT_MAX) {
@@ -230,6 +235,12 @@ static int ixgbe_fcoe_ddp_setup(struct n
 			len -= thislen;
 			addr += thislen;
--
 		while (data_value != 0xffff) {
 			IXGBE_WRITE_REG(hw, IXGBE_CORECTL, data_value);
 			IXGBE_WRITE_FLUSH(hw);
 			hw->eeprom.ops.read(hw, ++data_offset, &data_value);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len) {
 		buffer_info = &tx_ring->buffer_info[i];
 		size = min(len, IXGB_MAX_DATA_PER_TXD);
@@ -1380,6 +1385,12 @@ ixgb_tx_map(struct ixgb_adapter *adapter
 			if (i == tx_ring->count)
 				i = 0;
--
 		while (len) {
 			i++;
 			if (i == tx_ring->count)
@@ -1416,6 +1432,12 @@ ixgb_tx_map(struct ixgb_adapter *adapter
 			len -= size;
 			offset += size;
--
 	while (count--) {
 		if (i==0)
 			i += tx_ring->count;
 		i--;
 		buffer_info = &tx_ring->buffer_info[i];
 		ixgb_unmap_and_free_tx_resource(adapter, buffer_info);
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		buffer_info = &tx_ring->buffer_info[i];
 		tx_desc = IXGB_TX_DESC(*tx_ring, i);
 		tx_desc->buff_addr = cpu_to_le64(buffer_info->dma);
@@ -1475,6 +1513,12 @@ ixgb_tx_queue(struct ixgb_adapter *adapt
 		tx_desc->vlan = cpu_to_le16(vlan_id);
--
 	while (eop_desc->status & IXGB_TX_DESC_STATUS_DD) {
 
 		rmb(); /* read buffer_info after eop_desc */
@@ -1893,6 +1942,12 @@ ixgb_clean_tx_irq(struct ixgb_adapter *a
 
 		eop = tx_ring->buffer_info[i].next_to_watch;
--
 				while (i) {
 					i--;
 					igb_free_tx_resources(&temp_ring[i]);
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
--
 				while (i) {
 					i--;
 					igb_free_rx_resources(&temp_ring[i]);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
--
 	while (test->reg) {
 		for (i = 0; i < test->array_len; i++) {
 			switch (test->test_type) {
@@ -1146,6 +1173,12 @@ static int igb_reg_test(struct igb_adapt
 			}
 		}
--
-	while (igb_test_staterr(rx_desc, E1000_RXD_STAT_DD)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (igb_test_staterr(rx_desc, E1000_RXD_STAT_DD)) {
 		/* check rx buffer */
 		rx_buffer_info = &rx_ring->rx_buffer_info[rx_ntc];
 
@@ -1613,6 +1651,12 @@ static int igb_clean_test_rings(struct i
 
--
-		while (unlikely(size > IGB_MAX_DATA_PER_TXD)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (unlikely(size > IGB_MAX_DATA_PER_TXD)) {
 			tx_desc->read.cmd_type_len =
 				cmd_type | cpu_to_le32(IGB_MAX_DATA_PER_TXD);
 
@@ -4219,6 +4224,12 @@ static void igb_tx_map(struct igb_ring *
 
--
 	while (pvfdev) {
 		if (pvfdev->devfn == vf_devfn &&
 		    (pvfdev->bus->number >= pdev->bus->number))
@@ -4983,6 +4999,12 @@ static int igb_find_enabled_vfs(struct i
 		vf_devfn += vf_stride;
 		pvfdev = pci_get_device(hw->vendor_id,
--
 		while (tx_desc != eop_desc) {
 			tx_buffer->dma = 0;
 
@@ -5777,6 +5804,12 @@ static bool igb_clean_tx_irq(struct igb_
 					       tx_buffer->length,
 					       DMA_TO_DEVICE);
--
-	while (widx < words) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (widx < words) {
 		u8 write_opcode = NVM_WRITE_OPCODE_SPI;
 
 		ret_val = igb_ready_nvm_eeprom(hw);
@@ -497,6 +502,12 @@ s32 igb_write_nvm_spi(struct e1000_hw *h
 				break;
--
 	while (nic->cb_to_send != nic->cb_to_use) {
 		if (unlikely(e100_exec_cmd(nic, nic->cuc_cmd,
 			nic->cb_to_send->dma_addr))) {
@@ -910,6 +915,12 @@ static int e100_exec_cb(struct nic *nic,
 			nic->cuc_cmd = cuc_resume;
 			nic->cb_to_send = nic->cb_to_send->next;
--
 		while (nic->cbs_avail != nic->params.cbs.count) {
 			struct cb *cb = nic->cb_to_clean;
 			if (cb->skb) {
@@ -1826,6 +1842,12 @@ static void e100_clean_cbs(struct nic *n
 			}
 			nic->cb_to_clean = nic->cb_to_clean->next;
--
 	while (len) {
 		buffer_info = &tx_ring->buffer_info[i];
 		size = min(len, max_per_txd);
@@ -4692,6 +4697,12 @@ static int e1000_tx_map(struct e1000_ada
 			if (i == tx_ring->count)
 				i = 0;
--
 		while (len) {
 			i++;
 			if (i == tx_ring->count)
@@ -4721,6 +4737,12 @@ static int e1000_tx_map(struct e1000_ada
 			len -= size;
 			offset += size;
--
 	while (count--) {
 		if (i == 0)
 			i += tx_ring->count;
 		i--;
 		buffer_info = &tx_ring->buffer_info[i];
 		e1000_put_txbuf(adapter, buffer_info);
--
 	while ((e1000_phy_unknown == e1000e_get_phy_type_from_id(phy->id)) &&
 	       (i++ < 100)) {
 		usleep_range(1000, 2000);
 		ret_val = e1000e_get_phy_id(hw);
 		if (ret_val)
 			return ret_val;
--
 	while (retry_count < 2) {
 		ret_val = e1e_rphy(hw, PHY_ID1, &phy_id);
 		if (ret_val)
@@ -153,6 +158,12 @@ s32 e1000e_get_phy_id(struct e1000_hw *h
 			goto out;
 
--
 	while (widx < words) {
 		u8 write_opcode = NVM_WRITE_OPCODE_SPI;
 
@@ -2130,6 +2135,12 @@ s32 e1000e_write_nvm_spi(struct e1000_hw
 				break;
 			}
--
 	while (cleaned_count--) {
 		rx_desc = IGBVF_RX_DESC_ADV(*rx_ring, i);
 
@@ -207,7 +212,13 @@ static void igbvf_alloc_rx_buffers(struc
 		if (i == rx_ring->count)
 			i = 0;
--
 	while ((eop_desc->wb.status & cpu_to_le32(E1000_TXD_STAT_DD)) &&
 	       (count < tx_ring->count)) {
 		rmb();	/* read buffer_info after eop_desc status */
@@ -785,6 +801,12 @@ static bool igbvf_clean_tx_irq(struct ig
 		}
 		eop = tx_ring->buffer_info[i].next_to_watch;
--
 	while (count--) {
 		if (i==0)
 			i += tx_ring->count;
 		i--;
 		buffer_info = &tx_ring->buffer_info[i];
 		igbvf_put_txbuf(adapter, buffer_info);
--
-	while (count--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count--) {
 		buffer_info = &tx_ring->buffer_info[i];
 		tx_desc = IGBVF_TX_DESC_ADV(*tx_ring, i);
 		tx_desc->read.buffer_addr = cpu_to_le64(buffer_info->dma);
@@ -2139,6 +2177,12 @@ static inline void igbvf_tx_queue_adv(st
 		i++;
--
 	while (countdown && mbx->ops.check_for_msg(hw)) {
 		countdown--;
 		udelay(mbx->usec_delay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (countdown && mbx->ops.check_for_ack(hw)) {
 		countdown--;
 		udelay(mbx->usec_delay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	/* we cannot initialize while the RSTI / RSTD bits are asserted */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!mbx->ops.check_for_rst(hw) && timeout) {
 		timeout--;
 		udelay(5);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (--tries) {
 		u32 tmp = sbus_readl(gregs + GLOB_CTRL);
 		if (tmp & GLOB_CTRL_RESET) {
@@ -72,6 +77,12 @@ static inline int qec_global_reset(void
 			continue;
 		}
--
 	while (--tries) {
 		u8 tmp = sbus_readb(mregs + MREGS_BCONFIG);
 		if (tmp & MREGS_BCONFIG_RESET) {
@@ -98,6 +114,12 @@ static inline int qe_stop(struct sunqe *
 			continue;
 		}
--
 	while (--tries) {
 		u32 tmp = sbus_readl(cregs + CREG_CTRL);
 		if (tmp & CREG_CTRL_RESET) {
@@ -113,6 +140,12 @@ static inline int qe_stop(struct sunqe *
 			continue;
 		}
--
-	while (!((flags = this->rx_flags) & RXD_OWN)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!((flags = this->rx_flags) & RXD_OWN)) {
 		struct sk_buff *skb;
 		unsigned char *this_qbuf =
 			&qbufs->rx_buf[elem & (RX_RING_SIZE - 1)][0];
@@ -455,6 +493,12 @@ static void qe_rx(struct sunqe *qep)
 
--
 	while (channel < 4) {
 		if (qec_status & 0xf) {
 			struct sunqe *qep = qecp->qes[channel];
@@ -505,6 +554,12 @@ static irqreturn_t qec_interrupt(int irq
 		}
 		qec_status >>= 4;
--
 	while (root_qec_dev) {
 		struct sunqec *next = root_qec_dev->next_module;
 		struct platform_device *op = root_qec_dev->op;
@@ -1000,6 +1060,12 @@ static void __exit qec_exit(void)
 		kfree(root_qec_dev);
 
--
 	while (!((flags = hme_read_desc32(hp, &this->rx_flags)) & RXFLAG_OWN)) {
 		struct sk_buff *skb;
 		int len = flags >> 16;
@@ -2076,6 +2081,12 @@ static void happy_meal_rx(struct happy_m
 	next:
 		elem = NEXT_RX(elem);
--
 	while (tmp != &pdev->bus->devices) {
 		struct pci_dev *this_pdev = pci_dev_b(tmp);
 
@@ -2867,6 +2883,12 @@ static int is_quattro_p(struct pci_dev *
 			n_hmes++;
 
--
 	while (qfe_pci_list) {
 		struct quattro *qfe = qfe_pci_list;
 		struct quattro *next = qfe->next;
@@ -3219,6 +3246,12 @@ static void happy_meal_pci_exit(void)
 		kfree(qfe);
 
--
 	while (qfe_sbus_list) {
 		struct quattro *qfe = qfe_sbus_list;
 		struct quattro *next = qfe->next;
@@ -3320,6 +3358,12 @@ static void happy_meal_sbus_exit(void)
 		kfree(qfe);
 
--
 	while (--tries) {
 		if (sbus_readl(gregs + GLOB_CTRL) & GLOB_CTRL_RESET) {
 			udelay(20);
 			continue;
 		}
 		break;
--
 	while (i--) {
 		sbus_writel(MGMT_CLKOFF, tregs + TCVR_MPAL);
 		sbus_readl(tregs + TCVR_MPAL);
 		sbus_writel(MGMT_CLKON, tregs + TCVR_MPAL);
 		sbus_readl(tregs + TCVR_MPAL);
+		if (_cur < timeout) {
--
 	while (!((flags = this->rx_flags) & RXD_OWN)) {
 		struct sk_buff *skb;
 		int len = (flags & RXD_LENGTH); /* FCS not included */
@@ -884,6 +911,12 @@ static void bigmac_rx(struct bigmac *bp)
 	next:
 		elem = NEXT_RX(elem);
--
 	while (curr != limit) {
 		curr = NEXT_RX(curr);
 		if (++count == 4) {
@@ -736,6 +741,12 @@ static __inline__ void gem_post_rxds(str
 			kick = curr;
 			count = 0;
--
 	while (re2.s.code == RING_ENTRY_CODE_MORE) {
 		re2.d64 = octeon_mgmt_dequeue_rx_buffer(p, &skb2);
 		dev_kfree_skb_any(skb2);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (work_done < budget && mix_ircnt.s.ircnt) {
 
 		rc = octeon_mgmt_receive_one(p);
@@ -401,6 +417,12 @@ static int octeon_mgmt_receive_packets(s
 
 		/* Check for more packets. */
--
 	while (len > 0) {
 		if (len & 1 || offset & 1) {
 			int which = offset & 1;
@@ -669,6 +674,12 @@ static int dm9000_set_eeprom(struct net_
 		data += done;
 		offset += done;
--
 	while (mmio_verify_registers[i]) {
 		int reg = mmio_verify_registers[i++];
 		unsigned char a = inb(pioaddr+reg);
@@ -826,6 +831,12 @@ static int __devinit rhine_init_one(stru
 				reg, a, b);
 			goto err_out_unmap;
--
 	while ((status = readword(dev->base_addr, ISQ_PORT))) {
 		if (net_debug > 4)printk("%s: event=%04x\n", dev->name, status);
 		handled = 1;
@@ -1559,6 +1564,11 @@ static irqreturn_t net_interrupt(int irq
 #if ALLOW_DMA
 			if (lp->use_dma && (status & RX_DMA)) {
--
 				while(count) {
 					if (net_debug > 5)
 						printk("%s: receiving %d DMA frames\n", dev->name, count);
@@ -1569,6 +1579,12 @@ static irqreturn_t net_interrupt(int irq
 						count = readreg(dev, PP_DmaFrameCnt);
 					if (net_debug > 2 && count > 0)
--
 	while ((status = swab16(nubus_readw(dev->base_addr + ISQ_PORT)))) {
 		if (net_debug > 4)printk("%s: event=%04x\n", dev->name, status);
 		switch(status & ISQ_EVENT_MASK) {
@@ -479,6 +484,12 @@ static irqreturn_t net_interrupt(int irq
 			dev->stats.collisions += (status >> 6);
 			break;
--
 	while (priv->tx_head - priv->tx_tail > 0) {
 		priv->tx_tail++;
 		dev->stats.tx_dropped++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (greth->tx_free < GRETH_TXBD_NUM) {
 
 			struct sk_buff *skb = greth->tx_skbuff[greth->tx_last];
@@ -205,6 +210,12 @@ static void greth_clean_rings(struct gre
 			}
 			greth->tx_free += nr_frags+1;
--
-	while (GRETH_REGLOAD(greth->regs->mdio) & GRETH_MII_BUSY) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (GRETH_REGLOAD(greth->regs->mdio) & GRETH_MII_BUSY) {
 		if (time_after(jiffies, timeout))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (!phy_aneg_done(greth->phy) && time_before(jiffies, timeout)) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
--
 	while (GRETH_REGLOAD(regs->control) & GRETH_RESET) {
 		if (time_after(jiffies, timeout)) {
 			err = -EIO;
@@ -1436,6 +1474,12 @@ static int __devinit greth_of_probe(stru
 				dev_err(greth->dev, "timeout when waiting for reset.\n");
 			goto error2;
--
 	while (chan->head) {
 		struct cpdma_desc __iomem *desc = chan->head;
 		dma_addr_t next_dma;
@@ -858,6 +863,12 @@ int cpdma_chan_stop(struct cpdma_chan *c
 		spin_unlock_irqrestore(&chan->lock, flags);
 		__cpdma_chan_free(chan, desc, 0, -ENOSYS);
--
 	while (tlan_have_eisa) {
 		dev = tlan_eisa_devices;
 		priv = netdev_priv(dev);
@@ -640,6 +645,12 @@ static void tlan_eisa_cleanup(void)
 		tlan_eisa_devices = priv->next_device;
 		free_netdev(dev);
--
 	while (((tmp_c_stat = head_list->c_stat) & TLAN_CSTAT_FRM_CMP)
 	       && (ack < 255)) {
 		struct sk_buff *skb = tlan_get_skb(head_list);
@@ -1364,6 +1380,12 @@ static u32 tlan_handle_tx_eof(struct net
 		netif_start_queue(dev);
 		CIRC_INC(priv->tx_head, TLAN_NUM_TX_LISTS);
--
 	while (((tmp_c_stat = head_list->c_stat) & TLAN_CSTAT_FRM_CMP)
 	       && (ack < 255)) {
 		dma_addr_t frame_dma = head_list->buffer[0].address;
@@ -1519,6 +1546,12 @@ drop_and_reuse:
 		head_list = priv->rx_list + priv->rx_head;
 		head_list_phys = priv->rx_list_dma
--
 	while (i < TLAN_NUM_RX_LISTS) {
 		tlan_store_skb(priv->rx_list + i, NULL);
 		++i;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (time_after(timeout, jiffies)) {
 		reg = __raw_readl(&regs->user[0].access);
 		if ((reg & USERACCESS_GO) == 0)
@@ -180,6 +185,12 @@ static inline int wait_for_user_access(s
 		dev_warn(data->dev, "resetting idled controller\n");
 		__davinci_mdio_reset(data);
--
 	while (time_after(timeout, jiffies)) {
 		if (__raw_readl(&regs->control) & CONTROL_IDLE)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (((desc->dataflags & CPMAC_OWN) == 0) && (received < budget)) {
 		processed++;
 
@@ -467,6 +472,12 @@ static int cpmac_poll(struct napi_struct
 			received++;
 		}
--
 	while ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, k))) {
 		for (i = res->start; i <= res->end; i++) {
 			if (request_irq(i, emac_irq, IRQF_DISABLED,
@@ -1559,6 +1564,12 @@ static int emac_dev_open(struct net_devi
 				goto rollback;
 		}
--
 	while ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, i))) {
 		for (irq_num = res->start; irq_num <= res->end; irq_num++)
 			free_irq(irq_num, priv->ndev);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((rdl(pep, SDMA_CMD) & (SDMA_CMD_AR | SDMA_CMD_AT))
 		       && delay-- > 0) {
 			udelay(10);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	} while (max_retries-- > 0 && delay <= 0);
 
@@ -724,6 +735,11 @@ static int txq_reclaim(struct net_device
 	netif_tx_lock(dev);
 
 	pep->work_todo &= ~WORK_TX_DONE;
--
 	while (pep->tx_desc_count > 0) {
 		tx_index = pep->tx_used_desc_q;
 		desc = &pep->p_tx_desc_area[tx_index];
@@ -753,6 +769,12 @@ static int txq_reclaim(struct net_device
 		if (skb)
 			dev_kfree_skb_irq(skb);
--
 	while (length > 0) {
 		u32 val = skge_vpd_read(pdev, cap, offset);
 		int n = min_t(int, length, sizeof(val));
@@ -838,6 +843,12 @@ static int skge_get_eeprom(struct net_de
 		length -= n;
 		data += n;
--
 	while (length > 0) {
 		u32 val;
 		int n = min_t(int, length, sizeof(val));
@@ -870,6 +886,12 @@ static int skge_set_eeprom(struct net_de
 		length -= n;
 		data += n;
--
 	while (--i >= 0) {
 		pci_unmap_page(pdev, re->frag_addr[i],
 			       skb_frag_size(&skb_shinfo(skb)->frags[i]),
 			       PCI_DMA_FROMDEVICE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((idx = sky2_read16(hw, STAT_PUT_IDX)) != hw->st_idx) {
 		work_done += sky2_status_intr(hw, work_limit - work_done, idx);
 
 		if (work_done >= work_limit)
 			goto done;
+			if (_cur < timeout) {
--
 	while ( (sky2_pci_read16(hw, cap + PCI_VPD_ADDR) & PCI_VPD_ADDR_F) == busy) {
 		/* Can take up to 10.6 ms for write */
 		if (time_after(jiffies, start + HZ/4)) {
@@ -4253,6 +4280,12 @@ static int sky2_vpd_wait(const struct sk
 			return -ETIMEDOUT;
 		}
--
 	while (refilled < budget && rxq->rx_desc_count < rxq->rx_ring_size) {
 		struct sk_buff *skb;
 		int rx;
@@ -697,6 +702,12 @@ static int rxq_refill(struct rx_queue *r
 		 * IP header ends up 16-byte aligned.
 		 */
--
 	while (!((bdp->status & RXBD_EMPTY) || (--rx_work_limit < 0))) {
 		struct sk_buff *newskb;
 		rmb();
@@ -2815,6 +2820,12 @@ int gfar_clean_rx_ring(struct gfar_priv_
 		rx_queue->skb_currx =
 		    (rx_queue->skb_currx + 1) &
--
 	while (num_queues && left_over_budget) {
 
 		budget_per_queue = left_over_budget/num_queues;
@@ -2865,6 +2881,12 @@ static int gfar_poll(struct napi_struct
 				num_queues--;
 			}
--
 	while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) {
 
 		/* Since we have allocated space to hold a complete frame,
@@ -738,6 +743,12 @@ rx_processing_done:
 		 * able to keep up at the expense of system resources.
 		 */
--
 			while (--i >= 0) {
 				irq = platform_get_irq(pdev, i);
 				free_irq(irq, ndev);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (((sc = CBDR_SC(bdp)) & BD_ENET_RX_EMPTY) == 0) {
 
 		curidx = bdp - fep->rx_bd_base;
@@ -332,6 +337,12 @@ static int fs_enet_rx_non_napi(struct ne
 			bdp = fep->rx_bd_base;
 
--
 	while ((int_events = (*fep->ops->get_int_events)(dev)) != 0) {
 		nr++;
 
@@ -481,6 +497,12 @@ fs_enet_interrupt(int irq, void *dev_id)
 
 		if (int_events & fep->ev_tx)
--
-	while (!bcom_queue_empty(s)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!bcom_queue_empty(s)) {
 		struct bcom_fec_bd *bd;
 		struct sk_buff *skb;
 
@@ -139,6 +144,12 @@ static void mpc52xx_fec_free_rx_buffers(
 		dma_unmap_single(dev->dev.parent, bd->skb_pa, skb->len,
--
 	while (!bcom_queue_full(rxtsk)) {
 		skb = dev_alloc_skb(FEC_RX_BUFFER_SIZE);
 		if (!skb)
@@ -167,6 +183,12 @@ static int mpc52xx_fec_alloc_rx_buffers(
 		/* zero out the initial receive buffers to aid debugging */
 		memset(skb->data, 0, FEC_RX_BUFFER_SIZE);
--
-	while (bcom_buffer_done(priv->tx_dmatsk)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (bcom_buffer_done(priv->tx_dmatsk)) {
 		struct sk_buff *skb;
 		struct bcom_fec_bd *bd;
 		skb = bcom_retrieve_buffer(priv->tx_dmatsk, NULL,
@@ -380,6 +407,12 @@ static irqreturn_t mpc52xx_fec_tx_interr
 				 DMA_TO_DEVICE);
--
-	while (bcom_buffer_done(priv->rx_dmatsk)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bcom_buffer_done(priv->rx_dmatsk)) {
 
 		rskb = bcom_retrieve_buffer(priv->rx_dmatsk, &status,
 					    (struct bcom_bd **)&bd);
@@ -441,6 +479,12 @@ static irqreturn_t mpc52xx_fec_rx_interr
 			netif_rx(rskb);
--
 	while ((compl = be_mcc_compl_get(adapter))) {
 		if (compl->flags & CQE_FLAGS_ASYNC_MASK) {
 			/* Interpret flags as an async trailer */
@@ -253,6 +258,12 @@ int be_process_mcc(struct be_adapter *ad
 		}
 		be_mcc_compl_use(compl);
--
 	while (total_size) {
 		buf_size = min(total_size, (u32)60*1024);
 		total_size -= buf_size;
@@ -1395,6 +1411,12 @@ void be_cmd_get_regs(struct be_adapter *
 		}
 		offset += buf_size;
--
 	while (copied) {
 		wrb = queue_head_node(txq);
 		unmap_tx_frag(dev, wrb, map_single);
 		map_single = false;
 		copied -= wrb->frag_len;
 		queue_head_inc(txq);
--
 	while ((eqe = event_get(eq_obj)) != NULL) {
 		eqe->evt = 0;
 		num++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((eqe = event_get(eq_obj)) != NULL) {
 		eqe->evt = 0;
 		num++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((rxcp = be_rx_compl_get(rxo)) != NULL) {
 		be_rx_compl_discard(adapter, rxo, rxcp);
 		be_cq_notify(adapter, rx_cq->id, false, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while ((txcp = be_tx_compl_get(tx_cq))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((txcp = be_tx_compl_get(tx_cq))) {
 			end_idx = AMAP_GET_BITS(struct amap_eth_tx_compl,
 					wrb_index, txcp);
 			num_wrbs += be_tx_compl_process(adapter, txo, end_idx);
 			cmpl++;
+			if (_cur < timeout) {
--
-	while (atomic_read(&txq->used)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (atomic_read(&txq->used)) {
 		sent_skb = sent_skbs[txq->tail];
 		end_idx = txq->tail;
 		index_adv(&end_idx,
@@ -1563,6 +1623,12 @@ static void be_tx_compl_clean(struct be_
 			txq->len);
--
-		while ((txcp = be_tx_compl_get(&txo->cq))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((txcp = be_tx_compl_get(&txo->cq))) {
 			num_wrbs += be_tx_compl_process(adapter, txo,
 				AMAP_GET_BITS(struct amap_eth_tx_compl,
 					wrb_index, txcp));
 			tx_compl++;
+			if (_cur < timeout) {
--
-		while ((idev = pnp_find_dev(NULL,
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((idev = pnp_find_dev(NULL,
 					    isapnp_clone_list[i].vendor,
 					    isapnp_clone_list[i].function,
 					    idev))) {
@@ -275,6 +280,12 @@ static int __init ne_probe_isapnp(struct
 			}
--
 	while ((pdev_ne[this_dev] && platform_get_drvdata(pdev_ne[this_dev])) ||
 		io[this_dev]) {
 		if (++this_dev == MAX_NE_CARDS)
 			return ERR_PTR(-ENOMEM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-                while ((idev = pnp_find_dev(NULL,
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                        timeout = rdstcll(start) + delta;
+                        while ((idev = pnp_find_dev(NULL,
                                             ultra_device_ids[i].vendor,
                                             ultra_device_ids[i].function,
                                             idev))) {
@@ -367,6 +372,12 @@ static int __init ultra_probe_isapnp(str
                         }
--
         while ((inb(E33G_STATUS) & ESTAT_DPRDY) == 0)
         {
             if(!boguscount--)
@@ -560,6 +565,12 @@ el2_block_output(struct net_device *dev,
                 el2_reset_8390(dev);
                 goto blocked;
--
     while ((inb(E33G_STATUS) & ESTAT_DPRDY) == 0)
     {
         if(!boguscount--)
@@ -612,6 +628,12 @@ el2_get_8390_hdr(struct net_device *dev,
             el2_reset_8390(dev);
             goto blocked;
--
         while ((inb(E33G_STATUS) & ESTAT_DPRDY) == 0)
         {
             if(!boguscount--)
@@ -675,6 +702,12 @@ el2_block_input(struct net_device *dev,
                 el2_reset_8390(dev);
                 goto blocked;
--
 	while (count >= 2) {
 		*(unsigned short *)target = *(unsigned short volatile *)ptr;
 		ptr += 4;			/* skip cruft */
 		target += 2;
 		count -= 2;
+		if (_cur < timeout) {
--
 	while (count >= 2) {
 		*ptr++ = *(unsigned short *)src;	/* Copy and */
 		ptr++;			/* skip cruft */
 		src += 2;
 		count -= 2;
+		if (_cur < timeout) {
--
 	while(offset_len--) {
 		offset = (offset << 8) | tuple[4+offset_len];
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
--
-  while (length > 0)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (length > 0)
     {
       val = *(vhalf *) PA_83902_IF;
 #ifdef __LITTLE_ENDIAN__
@@ -237,6 +242,12 @@ stnic_block_input (struct net_device *de
 #endif
--
-  while (length > 0)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (length > 0)
     {
 #ifdef __LITTLE_ENDIAN__
       *(vhalf *) PA_83902_IF = ((half) buf[1] << 8) | buf[0];
@@ -269,6 +285,12 @@ stnic_block_output (struct net_device *d
       STNIC_DELAY ();
--
-	while (i < network->rate_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < network->rate_len) {
 		if (j < network->rate_ext_len &&
 		    ((scan->ext_rate[j] & 0x7f) < (scan->rate[i] & 0x7f)))
 		    rate = scan->ext_rate[j++] & 0x7f;
@@ -624,11 +629,28 @@ static char *gelic_wl_translate_scan(str
 		iwe.u.bitrate.value = rate * 500000; /* 500kbps unit */
--
 	while (j < network->rate_ext_len) {
 		iwe.u.bitrate.value = (scan->ext_rate[j++] & 0x7f) * 500000;
 		tmp = iwe_stream_add_value(info, ev, tmp, stop, &iwe,
 					   IW_EV_PARAM_LEN);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		status = lv1_net_control(bus_id(port->card), dev_id(port->card),
 					 GELIC_LV1_GET_WLAN_EVENT, 0, 0, 0,
 					 &event, &tmp);
@@ -2179,6 +2206,12 @@ static void gelic_wl_event_worker(struct
 		default:
--
 	} /* while */
 }
 /*
diff -u -p a/net/ethernet/toshiba/spider_net.c b/net/ethernet/toshiba/spider_net.c
--- a/net/ethernet/toshiba/spider_net.c
+++ b/net/ethernet/toshiba/spider_net.c
--
 	while (1) {
 		spin_lock_irqsave(&chain->lock, flags);
 		if (chain->tail == chain->head) {
@@ -861,6 +866,12 @@ spider_net_release_tx_chain(struct spide
 					PCI_DMA_TODEVICE);
 			dev_kfree_skb(skb);
--
 	while (regs[i][0]) {
 		spider_net_write_reg(card, regs[i][0], regs[i][1]);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (tc_readl(&tr->MD_CA) & MD_CA_Busy) {
 		if (time_after(jiffies, timeout))
 			return -EIO;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (tc_readl(&tr->MD_CA) & MD_CA_Busy) {
 		if (time_after(jiffies, timeout))
 			return -EIO;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-				while (--i >= 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (--i >= 0) {
 					free_rxbuf_skb(lp->pci_dev,
 						       lp->rx_skbs[i].skb,
 						       lp->rx_skbs[i].skb_dma);
 					lp->rx_skbs[i].skb = NULL;
+					if (_cur < timeout) {
--
 	while (len != 0) {
 		entry = (++priv->cur_tx) % txsize;
 		desc = priv->dma_tx + entry;
@@ -73,6 +78,12 @@ unsigned int stmmac_jumbo_frm(void *p, s
 			priv->tx_skbuff[entry] = NULL;
 			len = 0;
--
-	while (rx_queue->notified_count != rx_queue->added_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rx_queue->notified_count != rx_queue->added_count) {
 		efx_build_rx_desc(
 			rx_queue,
 			rx_queue->notified_count & rx_queue->ptr_mask);
 		++rx_queue->notified_count;
+		if (_cur < timeout) {
--
 	while (part != &efx_mtd->part[0]) {
 		--part;
 		efx_mtd_remove_partition(part);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (offset < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset < end) {
 		chunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);
 		rc = efx_mcdi_nvram_read(efx, part->mcdi.nvram_type, offset,
 					 buffer, chunk);
@@ -476,6 +492,12 @@ static int siena_mtd_read(struct mtd_inf
 			goto out;
--
-	while (offset < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < end) {
 		rc = efx_mcdi_nvram_erase(efx, part->mcdi.nvram_type, offset,
 					  chunk);
 		if (rc)
 			goto out;
 		offset += chunk;
--
-	while (offset < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset < end) {
 		chunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);
 		rc = efx_mcdi_nvram_write(efx, part->mcdi.nvram_type, offset,
 					  buffer, chunk);
@@ -539,6 +577,12 @@ static int siena_mtd_write(struct mtd_in
 			goto out;
--
 	while (nvram_types != 0) {
 		if (nvram_types & 1) {
 			rc = siena_mtd_probe_partition(efx, efx_mtd,
@@ -678,6 +727,12 @@ static int siena_mtd_probe(struct efx_ni
 		}
 		type++;
--
 	while (nvram_types != 0) {
 		if (nvram_types & 1) {
 			rc = efx_mcdi_nvram_test(efx, type);
@@ -950,6 +955,12 @@ int efx_mcdi_nvram_test_all(struct efx_n
 		}
 		type++;
--
 		while (mask) {
 			if (mask & 1) {
 				stat = efx_mdio_read(efx, mmd, MDIO_CTRL1);
@@ -98,6 +103,12 @@ int efx_mdio_wait_reset_mmds(struct efx_
 			}
 			mask = mask >> 1;
--
 	while (mmd_mask) {
 		if ((mmd_mask & 1) && efx_mdio_check_mmd(efx, mmd))
 			return -EIO;
 		mmd_mask = mmd_mask >> 1;
 		mmd++;
+		if (_cur < timeout) {
--
 	while (mmd_mask) {
 		if (mmd_mask & 1)
 			efx_mdio_set_mmd_lpower(efx, low_power, mmd);
 		mmd_mask = (mmd_mask >> 1);
 		mmd++;
+		if (_cur < timeout) {
--
 	while (*reg_values) {
 		u8 reg = *reg_values++;
 		u8 value = *reg_values++;
 		int rc = i2c_smbus_write_byte_data(client, reg, value);
 		if (rc)
 			return rc;
--
 	while (!mac_up && tries) {
 		netif_dbg(efx, hw, efx->net_dev, "bashing xaui\n");
 		falcon_reset_xaui(efx);
@@ -263,6 +268,12 @@ static bool falcon_xmac_link_ok_retry(st
 
 		mac_up = falcon_xmac_link_ok(efx);
--
 	while (tx_queue->insert_count != tx_queue->write_count) {
 		--tx_queue->insert_count;
 		insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
 		buffer = &tx_queue->buffer[insert_ptr];
 		efx_dequeue_buffer(tx_queue, buffer);
 		buffer->len = 0;
--
 	while (read_ptr != stop_index) {
 		struct efx_tx_buffer *buffer = &tx_queue->buffer[read_ptr];
 		if (unlikely(buffer->len == 0)) {
@@ -336,6 +352,12 @@ static void efx_dequeue_buffers(struct e
 
 		++tx_queue->read_count;
--
 	while (tx_queue->read_count != tx_queue->write_count) {
 		buffer = &tx_queue->buffer[tx_queue->read_count & tx_queue->ptr_mask];
 		efx_dequeue_buffer(tx_queue, buffer);
@@ -540,6 +567,12 @@ void efx_release_tx_buffers(struct efx_t
 		buffer->len = 0;
 
--
 	while (*p != NULL) {
 		if (((unsigned long)*p & PAGE_MASK) == base_kva)
 			*p = (*p)->next;
 		else
 			p = &(*p)->next;
+			if (_cur < timeout) {
--
-	while (tx_queue->insert_count != tx_queue->write_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tx_queue->insert_count != tx_queue->write_count) {
 		--tx_queue->insert_count;
 		buffer = &tx_queue->buffer[tx_queue->insert_count &
 					   tx_queue->ptr_mask];
@@ -911,6 +960,12 @@ static void efx_enqueue_unwind(struct ef
 		}
--
 	while (index != stop) {
 		if (test_bit(index, table->used_bitmap) &&
 		    table->spec[index].priority == EFX_FILTER_PRI_HINT &&
@@ -714,6 +719,12 @@ bool __efx_filter_rfs_expire(struct efx_
 			efx_filter_table_clear_entry(efx, table, index);
 		}
--
 	while ((status != VXGE_HW_OK) && retry++ < max_retry) {
 		if (!vpath->vp_open)
 			msleep(20);
@@ -200,6 +205,12 @@ vxge_hw_vpath_fw_api(struct __vxge_hw_vi
 					&vp_reg->rts_access_steer_ctrl,
 					VXGE_HW_RTS_ACCESS_STEER_CTRL_STROBE,
--
 	while (vxge_hw_channel_dtr_count(channel) > 0) {
 
 		status = vxge_hw_ring_rxd_reserve(ring, &rxd);
@@ -2172,6 +2188,12 @@ vxge_hw_ring_replenish(struct __vxge_hw_
 		}
 
--
-				while (j < max_entries) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (j < max_entries) {
 					if (mtable[itable[j]] != i) {
 						j++;
 						continue;
@@ -3889,9 +3916,20 @@ enum vxge_hw_status vxge_hw_vpath_rts_rt
 						&data0, &data1, 1, itable);
--
-				while (j < max_entries) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (j < max_entries) {
 					if (mtable[itable[j]] != i) {
 						j++;
 						continue;
@@ -3900,9 +3938,20 @@ enum vxge_hw_status vxge_hw_vpath_rts_rt
 						&data0, &data1, 2, itable);
--
-				while (j < max_entries) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (j < max_entries) {
 					if (mtable[itable[j]] != i) {
 						j++;
 						continue;
@@ -3911,9 +3960,20 @@ enum vxge_hw_status vxge_hw_vpath_rts_rt
 						&data0, &data1, 3, itable);
--
-				while (j < max_entries) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (j < max_entries) {
 					if (mtable[itable[j]] != i) {
 						j++;
 						continue;
@@ -3922,6 +3982,12 @@ enum vxge_hw_status vxge_hw_vpath_rts_rt
 						&data0, &data1, 4, itable);
--
 	while (processed < budget) {
 		struct ixpdev_rx_desc *desc;
 		struct sk_buff *skb;
@@ -121,6 +126,12 @@ static int ixpdev_rx(struct net_device *
 err:
 		ixp2000_reg_write(RING_RX_PENDING, _desc);
--
 	while ((cycles < MAX_MDIO_RETRIES) &&
 	       (__raw_readl(&mdio_regs->mdio_command[3]) & 0x80)) {
 		udelay(1);
 		cycles++;
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
-	while (received < budget) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (received < budget) {
 		struct sk_buff *skb;
 		struct desc *desc;
 		int n;
@@ -764,6 +780,12 @@ static int eth_poll(struct napi_struct *
 		desc->pkt_len = 0;
--
 	while ((phys = qmgr_get_entry(TXDONE_QUEUE)) != 0) {
 		u32 npe_id, n_desc;
 		struct port *port;
@@ -818,6 +845,12 @@ static void eth_txdone_irq(void *unused)
 #endif
 			netif_wake_queue(port->netdev);
--
 	while (npackets < budget) {
 		/*
 		 * break out of while loop if there are no more
@@ -438,6 +443,12 @@ static int dnet_poll(struct napi_struct
 			printk(KERN_NOTICE
 			       "%s: No memory to allocate a sk_buff of "
 			       "size %u.\n", dev->name, pkt_len);
+			if (_cur < timeout) {
--
 	while (len >= 2) {
 		*(dest++) = *(src++);
 		len -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while ((csr0 = lance->RDP) & (ERR | RINT | TINT) && --boguscnt >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while ((csr0 = lance->RDP) & (ERR | RINT | TINT) && --boguscnt >= 0) {
 		/* Acknowledge all of the current interrupt sources ASAP */
 		lance->RDP = csr0 & ~(INEA | TDMD | STOP | STRT | INIT);
 
@@ -376,6 +392,12 @@ static irqreturn_t ariadne_interrupt(int
 			/* Restart the chip */
--
 	while ((csr0 = inw(dev->base_addr + LANCE_DATA)) & 0x8600 &&
 	       --boguscnt >= 0) {
 		/* Acknowledge all of the current interrupt sources ASAP. */
@@ -1127,6 +1132,12 @@ static irqreturn_t lance_interrupt(int i
 			outw(0x0004, dev->base_addr + LANCE_DATA);
 			lance_restart(dev, 0x0002, 0);
--
 	while (len >= 4) {
 		*p32++ = sbus_readl(pbuf);
 		pbuf += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (len >= 4) {
 			sbus_writel(*p32, piobuf);
 			p32++;
 			piobuf += 4;
 			len -= 4;
+			if (_cur < timeout) {
--
 		while (len >= 4) {
 			u32 val;
 
@@ -1040,17 +1067,34 @@ static void lance_piocopy_from_skb(void
 			p8 += 4;
 			piobuf += 4;
--
 		while (len >= 4) {
 			u32 val = p16[0]<<16 | p16[1];
 			sbus_writel(val, piobuf);
 			p16 += 2;
 			piobuf += 4;
 			len -= 4;
--
 	while (len >= 4) {
 		sbus_writel(0, piobuf);
 		piobuf += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
   while (mace_read(lp, ioaddr, MACE_BIUCC) & 0x01) {
     /* Wait for reset bit to be cleared automatically after <= 200ns */;
     if(++ct > 500)
@@ -552,6 +557,12 @@ static int mace_init(mace_private *lp, u
     	return -1;
     }
--
   while (mace_read(lp, ioaddr, MACE_IAC) & MACE_IAC_ADDRCHG)
   {
   	if(++ ct > 500)
@@ -598,6 +614,12 @@ static int mace_init(mace_private *lp, u
 		pr_err("ADDRCHG timeout, card removed?\n");
   		return -1;
--
   while (
     ((rx_framecnt = inb(ioaddr + AM2150_RCV_FRAME_COUNT)) > 0) &&
     (rx_framecnt <= 12) && /* rx_framecnt==0xFF if card is extracted. */
@@ -1127,6 +1154,12 @@ static int mace_rx(struct net_device *de
       }
     }
--
   } /* while */
 
   return 0;
diff -u -p a/net/ethernet/amd/sun3lance.c b/net/ethernet/amd/sun3lance.c
--- a/net/ethernet/amd/sun3lance.c
+++ b/net/ethernet/amd/sun3lance.c
--
 	while( (MEM->rx_head[entry].flag & RMD1_OWN) == RMD1_OWN_HOST ) {
 		struct lance_rx_head *head = &(MEM->rx_head[entry]);
 		int status = head->flag;
@@ -861,6 +866,12 @@ static int lance_rx( struct net_device *
 		head->flag = RMD1_OWN_CHIP;
 
--
 	while (readl(mii_control_reg) & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			netdev_err(dev, "read_MII busy timeout!!\n");
 			return -1;
 		}
--
 	while (readl(mii_control_reg) & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			netdev_err(dev, "mdio_read busy timeout!!\n");
 			return -1;
 		}
--
 	while (readl(mii_control_reg) & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			netdev_err(dev, "mdio_write busy timeout!!\n");
 			return;
 		}
--
 	while (buff_stat & RX_T_DONE)  {
 		status = prxd->status;
 		pDB = aup->rx_db_inuse[aup->rx_head];
@@ -768,6 +806,12 @@ static int au1000_rx(struct net_device *
 		/* next descriptor */
 		prxd = aup->rx_dma_ring[aup->rx_head];
--
 	while (ptxd->buff_stat & TX_T_DONE) {
 		au1000_update_tx_stats(dev, ptxd->status);
 		ptxd->buff_stat &= ~TX_T_DONE;
@@ -820,6 +869,12 @@ static void au1000_tx_ack(struct net_dev
 			aup->tx_full = 0;
 			netif_wake_queue(dev);
--
-	while (length > 8) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (length > 8) {
 		register unsigned int tmp asm("r2"), tmp2 asm("r3");
 		asm volatile(
 			"ldm%?ia	%0!, {%1, %2}"
@@ -116,12 +121,29 @@ am_writebuffer(struct net_device *dev, u
 			"mov%?	%2, %2, lsr #16\n\t"
--
-	while (length > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (length > 0) {
 		asm volatile("str%?h	%2, [%0], #4"
 		 : "=&r" (offset) : "0" (offset), "r" (buf[0] | (buf[1] << 8)));
 		buf += 2;
 		length -= 2;
+		if (_cur < timeout) {
--
 	while (length > 8) {
 		register unsigned int tmp asm("r2"), tmp2 asm("r3"), tmp3;
 		asm volatile(
@@ -153,7 +180,18 @@ am_readbuffer(struct net_device *dev, u_
 		: "=&r" (offset), "=&r" (buf), "=r" (tmp), "=r" (tmp2), "=r" (tmp3)
 		: "0" (offset), "1" (buf));
--
 	while (length > 0) {
 		unsigned int tmp;
 		asm volatile(
@@ -163,6 +201,12 @@ am_readbuffer(struct net_device *dev, u_
 			"str%?b	%2, [%1], #1"
 		: "=&r" (offset), "=&r" (buf), "=r" (tmp) : "0" (offset), "1" (buf));
--
 		while ((read_rreg(dev->base_addr, CTRL1) & CTRL1_SPND) == 0) {
 			spin_unlock_irqrestore(&priv->chip_lock, flags);
 			nop();
 			spin_lock_irqsave(&priv->chip_lock, flags);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while(!( (rmdstat = rmdp->u.s.status) & RCV_OWN))
 	{
 		cnt++;
@@ -1133,6 +1138,12 @@ static void ni65_recv_intr(struct net_de
 		rmdp->u.s.status = RCV_OWN; /* change owner */
 		p->rmdnum = (p->rmdnum + 1) & (RMDNUM-1);
--
-	while (--new >= lp->rx_ring_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (--new >= lp->rx_ring_size) {
 		if (new_skb_list[new]) {
 			pci_unmap_single(lp->pci_dev, new_dma_addr_list[new],
 					 PKT_BUF_SIZE, PCI_DMA_FROMDEVICE);
 			dev_kfree_skb(new_skb_list[new]);
 		}
--
 		while ((lp->rx_ring[x].status & teststatus) && (ticks < 200)) {
 			spin_unlock_irqrestore(&lp->lock, flags);
 			msleep(1);
 			spin_lock_irqsave(&lp->lock, flags);
 			rmb();
 			ticks++;
--
 	while (x < numbuffs && !rc) {
 		skb = lp->rx_skbuff[x];
 		packet = lp->tx_skbuff[x]->data;
@@ -998,6 +1025,12 @@ static int pcnet32_loopback_test(struct
 			}
 		}
--
-	while (!(a->read_csr(ioaddr, CSR5) & CSR5_SUSPEND)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(a->read_csr(ioaddr, CSR5) & CSR5_SUSPEND)) {
 		spin_unlock_irqrestore(&lp->lock, *flags);
 		if (can_sleep)
 			msleep(1);
@@ -1094,6 +1132,12 @@ static int pcnet32_suspend(struct net_de
 				     "Error getting into suspend!\n");
--
 	while (npackets < budget && (short)le16_to_cpu(rxp->status) >= 0) {
 		pcnet32_rx_entry(dev, lp, rxp, entry);
 		npackets += 1;
@@ -1218,6 +1267,12 @@ static int pcnet32_rx(struct net_device
 		rxp->status = cpu_to_le16(0x8000);
 		entry = (++lp->cur_rx) & lp->rx_mod_mask;
--
 	while (pcnet32_dev) {
 		struct pcnet32_private *lp = netdev_priv(pcnet32_dev);
 		next_dev = lp->next;
@@ -2920,6 +2980,12 @@ static void __exit pcnet32_cleanup_modul
 				    lp->init_block, lp->init_dma_addr);
 		free_netdev(pcnet32_dev);
--
 	while( len-- ) {
 		*cto++ = *cfrom++;
 		MFPDELAY();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while( lp->cur_tx >= TX_RING_SIZE && lp->dirty_tx >= TX_RING_SIZE ) {
 		lp->cur_tx -= TX_RING_SIZE;
 		lp->dirty_tx -= TX_RING_SIZE;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while( ((csr0 = DREG) & (CSR0_ERR | CSR0_TINT | CSR0_RINT)) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while( ((csr0 = DREG) & (CSR0_ERR | CSR0_TINT | CSR0_RINT)) &&
 		   --boguscnt >= 0) {
 		handled = 1;
 		/* Acknowledge all of the current interrupt sources ASAP. */
@@ -947,6 +974,12 @@ static irqreturn_t lance_interrupt( int
 			/* Restart the chip. */
--
 		while (clen--) {
 			*tp++ = *fp++;
 			tp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (clen--) {
 			*rtp++ = *rfp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (clen--) {
 			*tp++ = *fp++;
 			*tp++ = *fp++;
@@ -367,6 +394,12 @@ static void cp_to_buf(const int type, vo
 			*tp++ = *fp++;
 			*tp++ = *fp++;
--
 		while (clen--) {
 			*rtp++ = *rfp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (clen--) {
 			*tp++ = *fp++;
 			fp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (clen--) {
 			*rtp++ = *rfp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (clen--) {
 			*tp++ = *fp++;
 			*tp++ = *fp++;
@@ -428,6 +499,12 @@ static void cp_from_buf(const int type,
 			*tp++ = *fp++;
 			*tp++ = *fp++;
--
 		while (clen--) {
 			*rtp++ = *rfp++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (dev) {
 			i++;
 			lp = netdev_priv(dev);
 			dev = lp->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (root_lance_dev) {
 		struct net_device *dev = root_lance_dev;
 		struct lance_private *lp = netdev_priv(dev);
@@ -1321,6 +1425,12 @@ static void __exit dec_lance_platform_re
 		unregister_netdev(dev);
 		root_lance_dev = lp->next;
--
 	while (!ftmac100_rxdes_owned_by_dma(rxdes)) {
 		if (ftmac100_rxdes_first_segment(rxdes))
 			return rxdes;
@@ -322,6 +327,12 @@ ftmac100_rx_locate_first_segment(struct
 		ftmac100_rxdes_set_dma_own(rxdes);
 		ftmac100_rx_pointer_advance(priv);
--
 	while (ftgmac100_rxdes_packet_ready(rxdes)) {
 		if (ftgmac100_rxdes_first_segment(rxdes))
 			return rxdes;
@@ -341,6 +346,12 @@ ftgmac100_rx_locate_first_segment(struct
 		ftgmac100_rxdes_set_dma_own(rxdes);
 		ftgmac100_rx_pointer_advance(priv);
--
-	while ((___rval = mace->eth.phy_data) & MDIO_BUSY) {	\
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+unsigned long long _start = 0;
+unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((___rval = mace->eth.phy_data) & MDIO_BUSY) {	\
 		udelay(25);					\
+	if (_cur < timeout) {
+		rdstcll(_cur);
 	}
+	else {
--
-	while (priv->rx_write != fifo_rptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (priv->rx_write != fifo_rptr) {
 		dma_unmap_single(NULL, priv->rx_ring_dmas[priv->rx_write],
 				 METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);
 		status = priv->rx_ring[priv->rx_write]->status.raw;
@@ -448,6 +464,12 @@ static void meth_rx(struct net_device* d
 				       METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);
--
-	while (priv->tx_read != rptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (priv->tx_read != rptr) {
 		skb = priv->tx_skbs[priv->tx_read];
 		status = priv->tx_ring[priv->tx_read].header.raw;
 #if MFE_DEBUG>=1
@@ -516,6 +543,12 @@ static void meth_tx_cleanup(struct net_d
 		priv->tx_ring[priv->tx_read].header.raw = 0;
--
 	while (1) {
 		u64 reg;
 		reg = nic_find(ioc3, &save);
@@ -385,6 +390,12 @@ static int nic_init(struct ioc3 *ioc3)
 		}
 		crc = reg & 0xff;
--
 	while (w0 & ERXBUF_V) {
 		err = be32_to_cpu(rxb->err);		/* It's valid ...  */
 		if (err & ERXBUF_GOODPKT) {
@@ -644,6 +660,12 @@ next:
 		skb = ip->rx_skbs[rx_entry];
 		rxb = (struct ioc3_erxbuf *) (skb->data - RX_OFFSET);
--
 	while (o_entry != tx_entry) {
 		packets++;
 		skb = ip->tx_skbs[o_entry];
@@ -678,6 +705,12 @@ static inline void ioc3_tx(struct net_de
 
 		etcir = ioc3_r_etcir();			/* More pkts sent?  */
--
 		while (n_entry != rx_entry) {
 			skb = ip->rx_skbs[n_entry];
 			if (skb)
 				dev_kfree_skb_any(skb);
 
 			n_entry = (n_entry + 1) & 511;
--
 	while (miicontrol & BMCR_RESET) {
 		usleep_range(10000, 20000);
 		miicontrol = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);
 		/* FIXME: 100 tries seem excessive */
 		if (tries++ > 100)
 			return -1;
--
 	while (np->put_rx.orig != less_rx) {
 		struct sk_buff *skb = dev_alloc_skb(np->rx_buf_sz + NV_RX_ALLOC_PAD);
 		if (skb) {
@@ -1761,6 +1777,12 @@ static int nv_alloc_rx(struct net_device
 				np->put_rx_ctx = np->first_rx_ctx;
 		} else
--
 	while (np->put_rx.ex != less_rx) {
 		struct sk_buff *skb = dev_alloc_skb(np->rx_buf_sz + NV_RX_ALLOC_PAD);
 		if (skb) {
@@ -1793,6 +1820,12 @@ static int nv_alloc_rx_optimized(struct
 				np->put_rx_ctx = np->first_rx_ctx;
 		} else
--
 	while ((np->get_tx.orig != np->put_tx.orig) &&
 	       !((flags = le32_to_cpu(np->get_tx.orig->flaglen)) & NV_TX_VALID) &&
 	       (tx_work < limit)) {
@@ -2413,6 +2451,12 @@ static int nv_tx_done(struct net_device
 			np->get_tx.orig = np->first_tx.orig;
 		if (unlikely(np->get_tx_ctx++ == np->last_tx_ctx))
--
 	while ((np->get_tx.ex != np->put_tx.ex) &&
 	       !((flags = le32_to_cpu(np->get_tx.ex->flaglen)) & NV_TX2_VALID) &&
 	       (tx_work < limit)) {
@@ -2458,6 +2507,12 @@ static int nv_tx_done_optimized(struct n
 			np->get_tx.ex = np->first_tx.ex;
 		if (unlikely(np->get_tx_ctx++ == np->last_tx_ctx))
--
 	while ((np->get_rx.orig != np->put_rx.orig) &&
 	      !((flags = le32_to_cpu(np->get_rx.orig->flaglen)) & NV_RX_AVAIL) &&
 		(rx_work < limit)) {
@@ -2702,6 +2762,12 @@ next_pkt:
 			np->get_rx_ctx = np->first_rx_ctx;
 
--
 	while ((np->get_rx.ex != np->put_rx.ex) &&
 	      !((flags = le32_to_cpu(np->get_rx.ex->flaglen)) & NV_RX2_AVAIL) &&
 	      (rx_work < limit)) {
@@ -2789,6 +2860,12 @@ next_pkt:
 			np->get_rx_ctx = np->first_rx_ctx;
 
--
 			while (!(phylink & PHY_LINK_SPEEDDPU_RESOLVED) &&
 				--cnt) {
 
@@ -464,6 +469,12 @@ jme_check_link(struct net_device *netdev
 					phylink = jme_linkstat_from_phy(jme);
 				else
--
 	while (limit > 0) {
 		rxdesc = rxring->desc;
 		rxdesc += i;
@@ -1127,6 +1143,12 @@ jme_process_receive(struct jme_adapter *
 		}
 
--
 	while (!atomic_dec_and_test(&jme->link_changing)) {
 		atomic_inc(&jme->link_changing);
 		netif_info(jme, intr, jme->dev, "Get link change lock failed\n");
 		while (atomic_read(&jme->link_changing) != 1)
 			netif_info(jme, intr, jme->dev, "Waiting link change lock\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
--
 	while (atomic_read(&jme->rx_empty) > 0) {
 		atomic_dec(&jme->rx_empty);
 		++(NET_STAT(jme).rx_dropped);
 		jme_restart_rx_engine(jme);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!(phylink & PHY_LINK_UP) && (to -= 10) > 0) {
 		mdelay(10);
 		phylink = jme_linkstat_from_phy(jme);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((val & SMBCSR_BUSY) && --to) {
 		msleep(1);
 		val = jread32(jme, JME_SMBCSR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((val & SMBINTF_HWCMD) && --to) {
 		msleep(1);
 		val = jread32(jme, JME_SMBINTF);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((val & SMBCSR_BUSY) && --to) {
 		msleep(1);
 		val = jread32(jme, JME_SMBCSR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((val & SMBINTF_HWCMD) && --to) {
 		msleep(1);
 		val = jread32(jme, JME_SMBINTF);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((*wb_comp & ~DMAE_PCI_ERR_FLAG) != DMAE_COMP_VAL) {
 		DP(BNX2X_MSG_OFF, "wb_comp 0x%08x\n", *wb_comp);
 
@@ -475,6 +480,12 @@ static int bnx2x_issue_dmae_with_comp(st
 		}
 		cnt--;
--
-	while (len > dmae_wr_max) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len > dmae_wr_max) {
 		bnx2x_write_dmae(bp, phys_addr + offset,
 				 addr + offset, dmae_wr_max);
 		offset += dmae_wr_max * 4;
 		len -= dmae_wr_max;
+		if (_cur < timeout) {
--
 	while ((crd != init_crd) && ((u32)SUB_S32(crd_freed, crd_freed_start) <
 	       (init_crd - crd_start))) {
 		if (cur_cnt--) {
@@ -1053,6 +1080,12 @@ static void bnx2x_pbf_pN_buf_flushed(str
 			   regs->pN, crd_freed);
 			break;
--
 	while (occup && ((u32)SUB_S32(freed, freed_start) < to_free)) {
 		if (cur_cnt--) {
 			udelay(FLR_WAIT_INTERAVAL);
@@ -1085,6 +1123,12 @@ static void bnx2x_pbf_pN_cmd_flushed(str
 			   regs->pN, freed);
 			break;
--
 	while (1) {
 		switch (bp->recovery_state) {
 		case BNX2X_RECOVERY_INIT:
@@ -8467,6 +8516,12 @@ static void bnx2x_parity_recover(struct
 		default:
 			return;
--
 			while (tout && REG_RD(bp, IGU_REG_RESET_MEMORIES)) {
 				tout--;
 				usleep_range(1000, 1000);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while ((init_crd != crd) && count) {
 		msleep(5);
 
 		crd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);
 		count--;
+		if (_cur < timeout) {
--
 	while (shift > 0) {
 
 		shift -= 4;
@@ -5858,6 +5874,12 @@ static int bnx2x_format_ver(u32 num, u8
 			(*len)--;
 			remove_leading_zeros = 1;
--
 	while ((buf_size > sizeof(u32)) && (rc == 0)) {
 		rc = bnx2x_nvram_read_dword(bp, offset, &val, cmd_flags);
 		memcpy(ret_buf, &val, 4);
@@ -1044,6 +1049,12 @@ static int bnx2x_nvram_read(struct bnx2x
 		ret_buf += sizeof(u32);
 		buf_size -= sizeof(u32);
--
 	while ((written_so_far < buf_size) && (rc == 0)) {
 		if (written_so_far == (buf_size - sizeof(u32)))
 			cmd_flags |= MCPR_NVM_COMMAND_LAST;
@@ -1220,6 +1236,12 @@ static int bnx2x_nvram_write(struct bnx2
 		data_buf += sizeof(u32);
 		written_so_far += sizeof(u32);
--
-	while (!list_empty(&o->pending_comp)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&o->pending_comp)) {
 		elem = list_first_entry(&o->pending_comp,
 					struct bnx2x_exeq_elem, link);
 
 		list_del(&elem->link);
 		bnx2x_exe_queue_free_elem(bp, elem);
--
-	while (!list_empty(&o->exe_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&o->exe_queue)) {
 		elem = list_first_entry(&o->exe_queue, struct bnx2x_exeq_elem,
 					link);
 		WARN_ON(!elem->cmd_len);
@@ -231,6 +247,12 @@ static inline int bnx2x_exe_queue_step(s
 			list_del(&spacer.link);
--
-	while (cnt--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (cnt--) {
 		if (!test_bit(state, pstate)) {
 #ifdef BNX2X_STOP_ON_ERROR
 			DP(BNX2X_MSG_SP, "exit  (cnt %d)\n", 5000 - cnt);
@@ -327,6 +354,12 @@ static inline int bnx2x_state_wait(struc
 
--
 	while (cnt--) {
 		/* Wait for the current command to complete */
 		rc = raw->wait_comp(bp, raw);
@@ -1333,6 +1371,12 @@ static int bnx2x_wait_vlan_mac(struct bn
 			usleep_range(1000, 1000);
 		else
--
-		while (!bnx2x_exe_queue_empty(&o->exe_queue) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!bnx2x_exe_queue_empty(&o->exe_queue) &&
 		       max_iterations--) {
 
 			/* Wait for the current command to complete */
@@ -1729,6 +1778,12 @@ int bnx2x_config_vlan_mac(
 						  ramrod_flags);
--
 	while ((MAX_PFC_PRIORITIES == pri) && (0 != index)) {
 		pri_mask = 1 << index;
 		if (GET_FLAGS(pri_bitmap, pri_mask))
 			pri = index ;
 		index--;
+		if (_cur < timeout) {
--
-	while (required_num_of_pg < pg_help_data->num_of_pg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (required_num_of_pg < pg_help_data->num_of_pg) {
 		entry_joined = pg_help_data->num_of_pg - 2;
 		entry_removed = entry_joined + 1;
 		/* protect index */
@@ -1459,6 +1475,12 @@ static int bnx2x_dcbx_join_pgs(
 		}
--
 	while (num_spread_of_entries && num_of_app_pri > 0) {
 		app_pri_bit = 1 << (num_of_app_pri - 1);
 		if (app_pri_bit & strict_app_pris) {
@@ -1631,6 +1658,12 @@ static int bnx2x_dcbx_spread_strict_pri(
 		}
 
--
 	while (work_to_do-- > 0) {
 		/*
 		 * figure out where we are (as an index) and where
@@ -1207,6 +1212,12 @@ again:
 
 		d->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);
--
 	while ((atomic_read(&ulp_ops->ref_count) != 0) && (i < 20)) {
 		msleep(100);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (test_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[ulp_type]) &&
 	       i < 20) {
 		msleep(100);
 		i++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (num_cqes) {
 		struct cnic_ulp_ops *ulp_ops;
 		int ulp_type;
@@ -2705,6 +2732,12 @@ end:
 		num_cqes -= j;
 		i += j;
--
 	while ((i != hw_prod) && (kcqe_cnt < MAX_COMPLETED_KCQE)) {
 		kcqe = &info->kcq[KCQ_PG(ri)][KCQ_IDX(ri)];
 		cp->completed_kcq[kcqe_cnt++] = kcqe;
@@ -2731,6 +2769,12 @@ static int cnic_get_kcqes(struct cnic_de
 			last_cnt = kcqe_cnt;
 			last = i;
--
 	while (sw_cons != hw_cons) {
 		u8 cqe_fp_flags;
 
@@ -2767,6 +2816,12 @@ static int cnic_l2_completion(struct cni
 				comp++;
 		}
--
 	while ((kcqe_cnt = cnic_get_kcqes(dev, &cp->kcq1))) {
 
 		service_kcqes(dev, kcqe_cnt);
@@ -2815,6 +2875,12 @@ static u32 cnic_service_bnx2_queues(stru
 		/* status block index must be read first */
 		rmb();
--
 	while ((kcqe_cnt = cnic_get_kcqes(dev, info))) {
 
 		service_kcqes(dev, kcqe_cnt);
@@ -2942,6 +3013,12 @@ static u32 cnic_service_bnx2x_kcq(struct
 		last_status = *info->status_idx_ptr;
 		/* status block index must be read before reading the KCQ */
--
-		while (cp->status_blk.bnx2->status_completion_producer_index &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (cp->status_blk.bnx2->status_completion_producer_index &&
 		       i < 10) {
 			CNIC_WR(dev, BNX2_HC_COALESCE_NOW,
 				1 << (11 + sblk_num));
 			udelay(10);
 			i++;
--
-		while (sblk->status_completion_producer_index && i < 10) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (sblk->status_completion_producer_index && i < 10) {
 			CNIC_WR(dev, BNX2_HC_COMMAND,
 				hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);
 			udelay(10);
 			i++;
 			barrier();
--
 	while (!(*cp->rx_cons_ptr != 0) && i < 10) {
 		CNIC_WR(dev, coal_reg, coal_val);
 		udelay(10);
 		i++;
 		barrier();
+		if (_cur < timeout) {
--
 		while (cp->udev->uio_dev != -1 && i < 15) {
 			msleep(100);
 			i++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((atomic_read(&dev->ref_count) != 0) && i < 10) {
 		msleep(100);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&cnic_dev_list)) {
 		dev = list_entry(cnic_dev_list.next, struct cnic_dev, list);
 		if (test_bit(CNIC_F_CNIC_UP, &dev->flags)) {
@@ -5451,11 +5588,28 @@ static void cnic_release(void)
 		cnic_unregister_netdev(dev);
 		list_del_init(&dev->list);
--
-	while (!list_empty(&cnic_udev_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cnic_udev_list)) {
 		udev = list_entry(cnic_udev_list.next, struct cnic_uio_dev,
 				  list);
 		cnic_free_uio(udev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (cons != prod && budget > 0) {
 		struct ring_info *rp = &bp->rx_buffers[cons];
 		struct sk_buff *skb = rp->skb;
@@ -825,6 +830,12 @@ static int b44_rx(struct b44 *bp, int bu
 		bp->rx_prod = (bp->rx_prod + 1) &
 			(B44_RX_RING_SIZE - 1);
--
-	while (frag_len_left) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (frag_len_left) {
 		len = min(frag_len_left, (unsigned int)WQ_ENET_MAX_DESC_LEN);
 		dma_addr = pci_map_single(enic->pdev, skb->data + offset,
 				len, PCI_DMA_TODEVICE);
@@ -708,6 +713,12 @@ static inline void enic_queue_wq_skb_tso
 			eop && (len == frag_len_left), loopback);
--
-		while (frag_len_left) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (frag_len_left) {
 			len = min(frag_len_left,
 				(unsigned int)WQ_ENET_MAX_DESC_LEN);
 			dma_addr = skb_frag_dma_map(&enic->pdev->dev, frag,
@@ -735,6 +751,12 @@ static inline void enic_queue_wq_skb_tso
 				loopback);
--
 	while ((type = ioread8(&r->type)) != RES_TYPE_EOL) {
 
 		u8 bar_num = ioread8(&r->bar);
@@ -165,6 +170,12 @@ static int vnic_dev_discover_res(struct
 		vdev->res[type].vaddr = (char __iomem *)bar[bar_num].vaddr +
 			bar_offset;
--
 	while (vnic_rq_desc_used(rq) > 0) {
 
 		(*buf_clean)(rq, buf);
 
 		buf = rq->to_clean = buf->next;
 		rq->ring.desc_avail++;
--
 	while (vnic_wq_desc_used(wq) > 0) {
 
 		(*buf_clean)(wq, buf);
 
 		buf = wq->to_clean = buf->next;
 		wq->ring.desc_avail++;
--
 	while(i--) {
 		if(!(TSI_READ(TSI108_MAC_MII_IND) & TSI108_MAC_MII_IND_BUSY))
 			return;
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while(i--){
 		if(!(TSI_READ(TSI108_EC_RXSTAT) & TSI108_EC_RXSTAT_ACTIVE))
 			return;
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!data->txfree || data->txhead != data->txtail) {
 		int tx = data->txtail;
 		struct sk_buff *skb;
@@ -1424,12 +1451,23 @@ static int tsi108_close(struct net_devic
 		data->txtail = (data->txtail + 1) % TSI108_TXRING_LEN;
 		data->txfree++;
--
 	while (data->rxfree) {
 		int rx = data->rxtail;
 		struct sk_buff *skb;
@@ -1438,6 +1476,12 @@ static int tsi108_close(struct net_devic
 		data->rxtail = (data->rxtail + 1) % TSI108_RXRING_LEN;
 		data->rxfree--;
--
 	while ((tx_stat = smsc911x_tx_get_txstatus(pdata)) != 0) {
 		if (unlikely(tx_stat & 0x80000000)) {
 			/* In this driver the packet tag is used as the packet
@@ -1062,6 +1067,12 @@ static void smsc911x_tx_update_txcounter
 				dev->stats.tx_aborted_errors++;
 			}
--
 	while ((smsc911x_reg_read(pdata, E2P_CMD) & E2P_CMD_EPC_BUSY_) &&
 	       --timeout) {
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (resets--) {
 		SMC_SET_HW_CFG(lp, HW_CFG_SRST_);
 		timeout=10;
@@ -211,6 +216,12 @@ static void smc911x_reset(struct net_dev
 				break;
 			}
 		} while (--timeout && (reg & HW_CFG_SRST_));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
-	while (((SMC_GET_TX_FIFO_INF(lp) & TX_FIFO_INF_TSUSED_) >> 16) != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (((SMC_GET_TX_FIFO_INF(lp) & TX_FIFO_INF_TSUSED_) >> 16) != 0) {
 		DBG(SMC_DEBUG_TX, "%s: Tx stat FIFO used 0x%04x\n",
 			dev->name,
 			(SMC_GET_TX_FIFO_INF(lp) & TX_FIFO_INF_TSUSED_) >> 16);
@@ -624,6 +640,12 @@ static void smc911x_tx(struct net_device
 			dev->stats.collisions++;
--
-	while (lp->rxrcommit < MAX_RX_PDL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (lp->rxrcommit < MAX_RX_PDL) {
 		/*
 		   ** Attempt to get a buffer and build a Rx PDL.
 		 */
@@ -1373,6 +1378,12 @@ static void hp100_rxfill(struct net_devi
 
--
-	while (packets-- > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (packets-- > 0) {
 		/* If ADV_NXT_PKT is still set, we have to wait until the card has */
 		/* really advanced to the next packet. */
 		for (pkt_len = 0; pkt_len < 6000 && (hp100_inb(OPTION_MSW) & HP100_ADV_NXT_PKT); pkt_len++) {
@@ -1862,6 +1878,12 @@ static void hp100_rx(struct net_device *
 			dev->stats.multicast++;
--
 	}			/* end of while(there are packets) loop */
 #ifdef HP100_DEBUG_RX
 	printk("hp100_rx: %s: end\n", dev->name);
@@ -1899,6 +1921,11 @@ static void hp100_rx_bm(struct net_devic
 	}
 #endif
--
 	while ((lp->rxrcommit > hp100_inb(RX_PDL))) {
 		/*
 		 * The packet was received into the pdl pointed to by lp->rxrhead (
@@ -1972,6 +1999,12 @@ static void hp100_rx_bm(struct net_devic
 			lp->rxrtail = lp->rxrtail->next;
 		}
--
 	while ( (rd_port(ioaddr) & rd_port(ioaddr) & rd_port(ioaddr) &
 		 rd_port(ioaddr) & rd_port(ioaddr) & rd_port(ioaddr)) != 0xff)
 	{
 		if (boguscount-- == 0)
 			goto out;
+			if (_cur < timeout) {
--
 	while (wis) {
 		skb = unmap_array[unmap_cons].skb;
 
@@ -207,6 +212,12 @@ bnad_free_txbufs(struct bnad *bnad,
 				skb_shinfo(skb)->nr_frags);
 
--
-	while (to_alloc--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (to_alloc--) {
 		if (!wi_range)
 			BNA_RXQ_QPGE_PTR_GET(unmap_prod, rcb->sw_qpt, rxent,
 					     wi_range);
@@ -390,7 +406,13 @@ bnad_alloc_n_post_rxbufs(struct bnad *bn
 		rxent++;
--
-	while (cmpl->valid && packets < budget) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cmpl->valid && packets < budget) {
 		packets++;
 		BNA_UPDATE_PKT_CNT(pkt_rt, ntohs(cmpl->length));
 
@@ -516,6 +543,12 @@ bnad_poll_cq(struct bnad *bnad, struct b
 next:
--
 	while (!list_empty(&rxf->mcast_pending_del_q)) {
 		bfa_q_deq(&rxf->mcast_pending_del_q, &qe);
 		bfa_q_qe_init(qe);
@@ -542,6 +547,12 @@ bna_rxf_mcast_cfg_apply(struct bna_rxf *
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
 		if (ret)
--
 		while (!(vlan_pending_bitmask & 0x1)) {
 			block_idx++;
 			vlan_pending_bitmask >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!list_empty(&rxf->mcast_pending_del_q)) {
 		bfa_q_deq(&rxf->mcast_pending_del_q, &qe);
 		bfa_q_qe_init(qe);
@@ -593,9 +620,20 @@ bna_rxf_mcast_cfg_reset(struct bna_rxf *
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
 		if (ret)
--
 	while (!list_empty(&rxf->mcast_active_q)) {
 		bfa_q_deq(&rxf->mcast_active_q, &qe);
 		bfa_q_qe_init(qe);
@@ -603,6 +641,12 @@ bna_rxf_mcast_cfg_reset(struct bna_rxf *
 		mac = (struct bna_mac *)qe;
 		if (bna_rxf_mcast_del(rxf, mac, cleanup))
--
 	while (!list_empty(&rxf->ucast_pending_add_q)) {
 		bfa_q_deq(&rxf->ucast_pending_add_q, &mac);
 		bfa_q_qe_init(&mac->qe);
 		bna_ucam_mod_mac_put(&rxf->rx->bna->ucam_mod, mac);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&rxf->mcast_pending_add_q)) {
 		bfa_q_deq(&rxf->mcast_pending_add_q, &mac);
 		bfa_q_qe_init(&mac->qe);
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (!list_empty(&rxf->mcast_pending_add_q)) {
 		bfa_q_deq(&rxf->mcast_pending_add_q, &qe);
 		bfa_q_qe_init(qe);
 		mac = (struct bna_mac *)qe;
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
+		if (_cur < timeout) {
--
 	while (!list_empty(&rxf->mcast_active_q)) {
 		bfa_q_deq(&rxf->mcast_active_q, &qe);
 		mac = (struct bna_mac *)qe;
 		bfa_q_qe_init(&mac->qe);
 		list_add_tail(&mac->qe, &rxf->mcast_pending_del_q);
+		if (_cur < timeout) {
--
 	while (!list_empty(&list_head)) {
 		bfa_q_deq(&list_head, &qe);
 		mac = (struct bna_mac *)qe;
 		bfa_q_qe_init(&mac->qe);
 		list_add_tail(&mac->qe, &rxf->mcast_pending_add_q);
+		if (_cur < timeout) {
--
 	while (!list_empty(&list_head)) {
 		bfa_q_deq(&list_head, &qe);
 		mac = (struct bna_mac *)qe;
 		bfa_q_qe_init(&mac->qe);
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
+		if (_cur < timeout) {
--
 	while (!list_empty(&rxf->ucast_pending_del_q)) {
 		bfa_q_deq(&rxf->ucast_pending_del_q, &qe);
 		bfa_q_qe_init(qe);
@@ -1058,9 +1173,20 @@ bna_rxf_ucast_cfg_reset(struct bna_rxf *
 			bna_ucam_mod_mac_put(&rxf->rx->bna->ucam_mod, mac);
 			return 1;
--
 	while (!list_empty(&rxf->ucast_active_q)) {
 		bfa_q_deq(&rxf->ucast_active_q, &qe);
 		bfa_q_qe_init(qe);
@@ -1071,6 +1197,12 @@ bna_rxf_ucast_cfg_reset(struct bna_rxf *
 				BFI_ENET_H2I_MAC_UCAST_DEL_REQ);
 			return 1;
--
 	while (!list_empty(&rx->rxp_q)) {
 		bfa_q_deq(&rx->rxp_q, &rxp);
 		GET_RXQS(rxp, q0, q1);
@@ -2573,6 +2710,12 @@ bna_rx_destroy(struct bna_rx *rx)
 		rxp->cq.ccb = NULL;
 		rxp->rx = NULL;
--
 	while (!list_empty(&tx->txq_q)) {
 		bfa_q_deq(&tx->txq_q, &txq);
 		bfa_q_qe_init(&txq->qe);
 		txq->tcb = NULL;
 		txq->tx = NULL;
 		list_add_tail(&txq->qe, &tx_mod->txq_free_q);
--
 	while ((r32 & 1) && (cnt < BFA_SEM_SPINCNT)) {
 		cnt++;
 		udelay(2);
 		r32 = readl(sem_reg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!list_empty(&cmdq->pending_q)) {
 		bfa_q_deq(&cmdq->pending_q, &cmdq_ent);
 		bfa_q_qe_init(&cmdq_ent->qe);
 		call_cmdq_ent_cbfn(cmdq_ent, BFA_STATUS_FAILED);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		to_copy = (len < BFI_MSGQ_CMD_ENTRY_SIZE) ?
 				len : BFI_MSGQ_CMD_ENTRY_SIZE;
 		memcpy(dst, src, to_copy);
@@ -228,6 +244,12 @@ __cmd_copy(struct bfa_msgq_cmdq *cmdq, s
 		dst = (u8 *)cmdq->addr.kva;
--
 	while (!list_empty(&cmdq->pending_q)) {
 		cmd =
 		(struct bfa_msgq_cmd_entry *)bfa_q_first(&cmdq->pending_q);
@@ -254,6 +281,12 @@ bfa_msgq_cmdq_ci_update(struct bfa_msgq_
 		} else {
 			break;
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		to_copy = (len < BFI_MSGQ_RSP_ENTRY_SIZE) ?
 				len : BFI_MSGQ_RSP_ENTRY_SIZE;
 		memcpy(dst, src, to_copy);
@@ -665,5 +703,11 @@ bfa_msgq_rsp_copy(struct bfa_msgq *msgq,
 		BFA_MSGQ_INDX_ADD(ci, 1, rspq->depth);
--
-	while (frag_idx < nfrags && curflit < WR_FLITS) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (frag_idx < nfrags && curflit < WR_FLITS) {
 		pci_unmap_page(pdev, be64_to_cpu(sgp->addr[j]),
 			       skb_frag_size(&skb_shinfo(skb)->frags[frag_idx]),
 			       PCI_DMA_TODEVICE);
@@ -263,6 +268,12 @@ static inline void unmap_skb(struct sk_b
 		}
--
 	while (n--) {
 		if (d->skb) {	/* an SGL is present */
 			if (need_unmap)
@@ -307,6 +323,12 @@ static void free_tx_desc(struct adapter
 			cidx = 0;
 			d = q->sdesc;
--
 	while (q->credits--) {
 		struct rx_sw_desc *d = &q->sdesc[cidx];
 
@@ -388,6 +415,12 @@ static void free_rx_bufs(struct pci_dev
 		clear_rx_desc(pdev, q, d);
 		if (++cidx == q->size)
--
 	while (q->in_use < q->size &&
 	       (skb = __skb_dequeue(&q->sendq)) != NULL) {
 
@@ -1488,6 +1526,12 @@ static void restart_ctrlq(unsigned long
 			q->gen ^= 1;
 		}
--
 	while ((skb = skb_peek(&q->sendq)) != NULL) {
 		unsigned int gen, pidx;
 		unsigned int ndesc = skb->priority;
@@ -1719,6 +1768,12 @@ again:	reclaim_completed_tx(adap, q, TX_
 
 		write_ofld_wr(adap, skb, q, pidx, gen, ndesc);
--
 	while (work_done < budget) {
 		struct sk_buff *skb, *tmp, *skbs[RX_BUNDLE_SIZE];
 		struct sk_buff_head queue;
@@ -1872,6 +1932,12 @@ static int ofld_poll(struct napi_struct
 			spin_unlock_irq(&q->lock);
 		}
--
 	while (adap->sge.qs[0].rspq.offload_pkts < init_cnt + n) {
 		if (!--attempts)
 			return -ETIMEDOUT;
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-		while (t.len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (t.len) {
 			unsigned int chunk =
 				min_t(unsigned int, t.len, sizeof(buf));
 
@@ -2418,6 +2434,12 @@ static int cxgb_extension_ioctl(struct n
 			useraddr += chunk;
--
 		while (v) {
 			qs->fl[i].empty += (v & 1);
 			if (i)
 				qs++;
 			i ^= 1;
 			v >>= 1;
--
-	while (n--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (n--) {
 		struct sk_buff *skb = *skbs++;
 		unsigned int opcode = get_opcode(skb);
 		int ret = cpl_handlers[opcode] (dev, skb);
@@ -1033,6 +1038,12 @@ static int process_rx(struct t3cdev *dev
 #endif
--
 	while (1) {
 		u32 val = t3_read_reg(adapter, reg);
 
@@ -67,6 +72,12 @@ int t3_wait_op_done_val(struct adapter *
 			return -EAGAIN;
 		if (delay)
--
 	while (n--) {
 		t3_write_reg(adapter, p->reg_addr + offset, p->val);
 		p++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (nregs--) {
 		t3_write_reg(adap, addr_reg, start_idx);
 		*vals++ = t3_read_reg(adap, data_reg);
 		start_idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (n--) {
 		int i;
 		u64 val64 = 0;
@@ -186,6 +224,12 @@ int t3_mc7_bd_read(struct mc7 *mc7, unsi
 			start += 8;
 		}
--
 	while (1) {
 		if ((ret = sf1_write(adapter, 1, 1, SF_RD_STATUS)) != 0 ||
 		    (ret = sf1_read(adapter, 1, 0, &status)) != 0)
@@ -826,6 +875,12 @@ static int flash_wait_op(struct adapter
 			return -EAGAIN;
 		if (delay)
--
 	while (start <= end) {
 		int ret;
 
@@ -1072,6 +1132,12 @@ static int t3_flash_erase_sectors(struct
 		    (ret = flash_wait_op(adapter, 5, 500)) != 0)
 			return ret;
--
 	while (n--) {
 		if (d->skb) {                       /* an SGL is present */
 			if (unmap)
@@ -350,6 +355,12 @@ static void free_tx_desc(struct adapter
 			cidx = 0;
 			d = q->sdesc;
--
 	while (n--) {
 		struct rx_sw_desc *d = &q->sdesc[q->cidx];
 
@@ -424,6 +440,12 @@ static void free_rx_bufs(struct adapter
 		if (++q->cidx == q->size)
 			q->cidx = 0;
--
 	while ((skb = __skb_dequeue(&q->sendq)) != NULL) {
 		struct fw_wr_hdr *wr;
 		unsigned int ndesc = skb->priority;     /* previously saved */
@@ -1146,6 +1173,12 @@ static void restart_ctrlq(unsigned long
 			written = 0;
 		}
--
 	while ((skb = skb_peek(&q->sendq)) != NULL && !q->full) {
 		/*
 		 * We drop the lock but leave skb on sendq, thus retaining
@@ -1305,6 +1343,12 @@ static void service_ofldq(struct sge_ofl
 		__skb_unlink(skb, &q->sendq);
 		if (is_ofld_imm(skb))
--
-	while (frags--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (frags--) {
 		if (q->cidx == 0)
 			q->cidx = q->size - 1;
 		else
@@ -1639,6 +1688,12 @@ static void restore_rx_bufs(const struct
 		d->page = si->frags[frags].page;
--
 	while (count) {
 		size_t len;
 		int ret, ofst;
@@ -2040,6 +2045,12 @@ static ssize_t mem_read(struct file *fil
 		buf += len;
 		pos += len;
--
 	while (adap->tid_release_head) {
 		void **p = adap->tid_release_head;
 		unsigned int chan = (uintptr_t)p & 3;
@@ -2233,6 +2249,12 @@ static void process_tid_release_list(str
 		mk_tid_release(skb, chan, p - adap->tids.tid_tab);
 		t4_ofld_send(adap, skb);
--
 	while (1) {
 		u32 val = t4_read_reg(adapter, reg);
 
@@ -68,6 +73,12 @@ static int t4_wait_op_done_val(struct ad
 			return -EAGAIN;
 		if (delay)
--
 	while (nregs--) {
 		t4_write_reg(adap, addr_reg, start_idx);
 		*vals++ = t4_read_reg(adap, data_reg);
 		start_idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		if ((ret = sf1_write(adapter, 1, 1, 1, SF_RD_STATUS)) != 0 ||
 		    (ret = sf1_read(adapter, 1, 0, 1, &status)) != 0)
@@ -517,6 +544,12 @@ static int flash_wait_op(struct adapter
 			return -EAGAIN;
 		if (delay)
--
 	while (n > 0) {
 		int nq = min(n, 32);
 		__be32 *qp = &cmd.iq0_to_iq2;
@@ -1593,6 +1631,11 @@ int t4_config_rss_range(struct adapter *
 		start += nq;
 		n -= nq;
--
 		while (nq > 0) {
 			unsigned int v;
 
@@ -1608,11 +1651,23 @@ int t4_config_rss_range(struct adapter *
 
 			*qp++ = htonl(v);
--
 	while (nparams--) {
 		*p++ = htonl(*params++);
 		*p++ = htonl(*val++);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (e->arpq_head) {
 		struct sk_buff *skb = e->arpq_head;
 
 		e->arpq_head = skb->next;
 		skb->next = NULL;
 		t4_ofld_send(adap, skb);
--
 		while (e->arpq_head) {
 			struct sk_buff *skb = e->arpq_head;
 
 			e->arpq_head = skb->next;
 			kfree_skb(skb);
+			if (_cur < timeout) {
--
 	while (arpq) {
 		struct sk_buff *skb = arpq;
 		const struct l2t_skb_cb *cb = L2T_SKB_CB(skb);
@@ -428,6 +455,12 @@ static void handle_failed_resolution(str
 			cb->arp_err_handler(cb->handle, skb);
 		else
--
 	while (n--) {
 		/*
 		 * If we kept a reference to the original TX skb, we need to
@@ -410,6 +415,12 @@ static void free_tx_desc(struct adapter
 			cidx = 0;
 			sdesc = tq->sdesc;
--
 	while (n--) {
 		struct rx_sw_desc *sdesc = &fl->sdesc[fl->cidx];
 
@@ -489,6 +505,12 @@ static void free_rx_bufs(struct adapter
 		if (++fl->cidx == fl->size)
 			fl->cidx = 0;
--
-	while (frags--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (frags--) {
 		if (fl->cidx == 0)
 			fl->cidx = fl->size - 1;
 		else
@@ -1603,6 +1630,12 @@ static void restore_rx_bufs(const struct
 		sdesc->page = gl->frags[frags].page;
--
 	while (n > 0) {
 		__be32 *qp = &cmd.iq0_to_iq2;
 		int nq = min(n, 32);
@@ -811,6 +816,11 @@ int t4vf_config_rss_range(struct adapter
 		 * current firmware RSS command, retrieve them from the
 		 * Ingress Queue ID array and insert them into the command.
--
 		while (nq > 0) {
 			/*
 			 * Grab up to the next 3 Ingress Queue IDs (wrapping
@@ -824,15 +834,32 @@ int t4vf_config_rss_range(struct adapter
 
 			nq -= nqbuf;
--
 			while (nqbuf) {
 				nqbuf--;
 				*qbp++ = *rsp++;
 				if (rsp >= rsp_end)
 					rsp = rspq;
+					if (_cur < timeout) {
--
 	while (rem) {
 		unsigned int ix = VI_VF_NUM_STATS - rem;
 		unsigned int nstats = min(6U, rem);
@@ -1223,6 +1261,12 @@ int t4vf_get_port_stats(struct adapter *
 
 		rem -= nstats;
--
-	while (q->credits--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (q->credits--) {
 		struct freelQ_ce *ce = &q->centries[cidx];
 
 		pci_unmap_single(pdev, dma_unmap_addr(ce, dma_addr),
@@ -530,6 +535,12 @@ static void free_freelQ_buffers(struct p
 		ce->skb = NULL;
--
 	while (n--) {
 		if (likely(dma_unmap_len(ce, dma_len))) {
 			pci_unmap_single(pdev, dma_unmap_addr(ce, dma_addr),
@@ -654,6 +670,12 @@ static void free_cmdQ_buffers(struct sge
 			cidx = 0;
 			ce = q->centries;
--
 		while (len > SGE_TX_DESC_MAX_PLEN) {
 			count++;
 			len -= SGE_TX_DESC_MAX_PLEN;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 			while (len > SGE_TX_DESC_MAX_PLEN) {
 				count++;
 				len -= SGE_TX_DESC_MAX_PLEN;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-		while (*desc_len > SGE_TX_DESC_MAX_PLEN) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (*desc_len > SGE_TX_DESC_MAX_PLEN) {
 			*desc_len -= SGE_TX_DESC_MAX_PLEN;
 			write_tx_desc(e1, *desc_mapping, SGE_TX_DESC_MAX_PLEN,
 				      *gen, nfrags == 0 && *desc_len == 0);
@@ -1200,6 +1249,12 @@ static inline unsigned int write_large_p
 					e1 = q->entries;
--
 	while ((skb = sched_skb(sge, NULL, credits)) != NULL) {
 		unsigned int genbit, pidx, count;
 	        count = 1 + skb_shinfo(skb)->nr_frags;
@@ -1344,6 +1404,12 @@ static void restart_sched(unsigned long
 		write_tx_descs(adapter, skb, pidx, genbit, q);
 	        credits = q->size - q->in_use;
--
 	while (done < budget && e->GenerationBit == q->genbit) {
 		flags |= e->Qsleeping;
 
@@ -1544,6 +1615,12 @@ static int process_responses(struct adap
 			writel(q->credits, adapter->regs + A_SG_RSPQUEUECREDIT);
 			q->credits = 0;
--
 	while (i >= 0) {
 		free_percpu(sge->port_stats[i]);
 		--i;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (1) {
 		u32 val = readl(adapter->regs + reg) & mask;
 
@@ -71,6 +76,12 @@ static int t1_wait_op_done(adapter_t *ad
 			return 1;
 		if (delay)
--
 	while (--i >= 0) {
 		if (adapter->port[i].dev)
 			free_netdev(adapter->port[i].dev);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (dlist->descriptors[lp->rxBuffIndex].addr & EMAC_DESC_DONE) {
 		p_recv = dlist->recv_buf[lp->rxBuffIndex];
 		pktlen = dlist->descriptors[lp->rxBuffIndex].size & 0x7ff;	/* Length of frame including FCS */
@@ -907,6 +912,12 @@ static void at91ether_rx(struct net_devi
 			lp->rxBuffIndex = 0;
 		else
--
 	while ((detected != 0) && (phy_address < 32)) {
 		/* Read the PHY ID registers */
 		enable_mdi();
@@ -1157,6 +1173,12 @@ static int __init at91ether_probe(struct
 		}
 
--
 	while ((rx < budget) && !complete) {
 		struct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];
 
@@ -170,6 +175,12 @@ ltq_etop_poll_rx(struct napi_struct *nap
 		} else {
 			complete = 1;
--
-	while ((ch->dma.desc_base[ch->tx_free].ctl &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((ch->dma.desc_base[ch->tx_free].ctl &
 			(LTQ_DMA_OWN | LTQ_DMA_C)) == LTQ_DMA_C) {
 		dev_kfree_skb_any(ch->skb[ch->tx_free]);
 		ch->skb[ch->tx_free] = NULL;
@@ -197,6 +213,12 @@ ltq_etop_poll_tx(struct napi_struct *nap
 			sizeof(struct ltq_dma_desc));
--
 	while (tx_index--) {
 		mlx4_en_deactivate_tx_ring(priv, &priv->tx_ring[tx_index]);
 		mlx4_en_deactivate_cq(priv, &priv->tx_cq[tx_index]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (npages > 0) {
 		if (!chunk) {
 			chunk = kmalloc(sizeof *chunk,
@@ -187,6 +192,12 @@ struct mlx4_icm *mlx4_alloc_icm(struct m
 			chunk = NULL;
 
--
 	while (i > start) {
 		i -= inc;
 		mlx4_table_put(dev, table, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cmd_pending(dev)) {
 		if (time_after_eq(jiffies, end))
 			goto out;
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (ring->cons != ring->prod) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ring->cons != ring->prod) {
 		ring->last_nr_txbb = mlx4_en_free_tx_desc(priv, ring,
 						ring->cons & ring->size_mask,
 						!!(ring->cons & ring->size));
 		ring->cons += ring->last_nr_txbb;
 		cnt++;
--
 		while (t & ((1 << buf->page_shift) - 1)) {
 			--buf->page_shift;
 			buf->npages *= 2;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
--
 	while ((eqe = next_eqe_sw(eq))) {
 		/*
 		 * Make sure we read EQ entry contents after we've
@@ -257,6 +262,12 @@ static int mlx4_eq_int(struct mlx4_dev *
 			eq_set_ci(eq, 0);
 			set_ci = 0;
--
 	while (i >= 0) {
 		mlx4_free_eq(dev, &priv->eq_table.eq[i]);
 		--i;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 	while (i--) {
 		page_alloc = &ring->page_alloc[i];
 		put_page(page_alloc->page);
 		page_alloc->page = NULL;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while (ring->actual_size > new_size) {
 			ring->actual_size--;
 			ring->prod--;
 			mlx4_en_free_rx_desc(priv, ring, ring->actual_size);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (ring->cons != ring->prod) {
 		index = ring->cons & ring->size_mask;
 		en_dbg(DRV, priv, "Processing descriptor:%d\n", index);
 		mlx4_en_free_rx_desc(priv, ring, index);
 		++ring->cons;
+		if (_cur < timeout) {
--
 	while (ring_ind >= 0) {
 		if (priv->rx_ring[ring_ind].stride <= TXBB_SIZE)
 			priv->rx_ring[ring_ind].buf -= TXBB_SIZE;
 		mlx4_en_destroy_allocator(priv, &priv->rx_ring[ring_ind]);
 		ring_ind--;
+		if (_cur < timeout) {
--
 	while (nr > 0) {
 		nr--;
 		__skb_frag_unref(&skb_frags_rx[nr]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (XNOR(cqe->owner_sr_opcode & MLX4_CQE_OWNER_MASK,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (XNOR(cqe->owner_sr_opcode & MLX4_CQE_OWNER_MASK,
 		    cq->mcq.cons_index & cq->size)) {
 
 		skb_frags = ring->rx_info + (index << priv->log_rx_info);
@@ -673,6 +733,12 @@ next:
 			 * flush only pending LRO sessions */
--
-	while (buf_size < eff_mtu) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (buf_size < eff_mtu) {
 		priv->frag_info[i].frag_size =
 			(eff_mtu > buf_size + frag_sizes[i]) ?
 				frag_sizes[i] : eff_mtu - buf_size;
@@ -765,6 +836,12 @@ void mlx4_en_calc_rx_buf(struct net_devi
 						priv->frag_info[i].frag_align);
--
 	while (o > order) {
 		--o;
 		seg <<= 1;
 		set_bit(seg ^ 1, buddy->bits[o]);
 		++buddy->num_free[o];
+		if (_cur < timeout) {
--
 	while (test_bit(seg ^ 1, buddy->bits[order])) {
 		clear_bit(seg ^ 1, buddy->bits[order]);
 		--buddy->num_free[order];
 		seg >>= 1;
 		++order;
+		if (_cur < timeout) {
--
 	while (npages > 0) {
 		chunk = min_t(int, PAGE_SIZE / sizeof(u64), npages);
 		err = mlx4_write_mtt_chunk(dev, mtt, start_index, chunk, page_list);
@@ -430,6 +457,12 @@ int mlx4_write_mtt(struct mlx4_dev *dev,
 		npages      -= chunk;
 		start_index += chunk;
--
 	while ((((u8)(pd->rx_skb_i - pd->rx_skb_o)) < S6_NUM_RX_SKB) &&
 	       (!s6dmac_fifo_full(pd->rx_dma, pd->rx_chan)) &&
 	       (skb = dev_alloc_skb(S6_MAX_FRLEN + 2))) {
 		pd->rx_skb[(pd->rx_skb_i++) % S6_NUM_RX_SKB] = skb;
 		s6dmac_put_fifo_cache(pd->rx_dma, pd->rx_chan,
 			pd->io, (u32)skb->data, S6_MAX_FRLEN);
--
-	while (((u8)(pd->rx_skb_i - pd->rx_skb_o)) >
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (((u8)(pd->rx_skb_i - pd->rx_skb_o)) >
 			s6dmac_pending_count(pd->rx_dma, pd->rx_chan)) {
 		skb = pd->rx_skb[(pd->rx_skb_o++) % S6_NUM_RX_SKB];
 		pfx = readl(pd->reg + S6_GMAC_BURST_POSTRD);
@@ -400,15 +416,32 @@ static void s6gmac_rx_interrupt(struct n
 			skb->ip_summed = CHECKSUM_UNNECESSARY;
--
-	while (((u8)(pd->tx_skb_i - pd->tx_skb_o)) >
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (((u8)(pd->tx_skb_i - pd->tx_skb_o)) >
 			s6dmac_pending_count(pd->tx_dma, pd->tx_chan)) {
 		dev_kfree_skb_irq(pd->tx_skb[(pd->tx_skb_o++) % S6_NUM_TX_SKB]);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
 	while (mask) {
 		b = fls(mask) - 1;
 		mask &= ~(1 << b);
 		pd->carry[inf[b].net_index] += (1 << inf[b].reg_size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (readl(pd->reg + S6_GMAC_MACMIIINDI)) {
 		if (--tmo == 0)
 			return -ETIME;
 		udelay(64);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (i < nr_of_pages) {
 		u8 *kpage = (u8 *)get_zeroed_page(GFP_KERNEL);
 		if (!kpage)
@@ -87,6 +92,12 @@ static int hw_queue_ctor(struct hw_queue
 			kpage += pagesize;
 			i++;
--
 	while (pfn < end_pfn) {
 		if (ehea_is_hugepage(pfn)) {
 			/* Add mem found in front of the hugepage */
@@ -740,6 +756,12 @@ static int ehea_create_busmap_callback(u
 			start_pfn = pfn;
 		} else
--
 	while (rx != budget) {
 		napi_complete(napi);
 		ehea_reset_cq_ep(pr->recv_cq);
@@ -905,6 +910,12 @@ static int ehea_poll(struct napi_struct
 
 		cqe_skb = ehea_proc_cqes(pr, EHEA_POLL_MAX_CQES);
--
-	while (eqe) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (eqe) {
 		qp_token = EHEA_BMASK_GET(EHEA_EQE_QP_TOKEN, eqe->entry);
 		pr_err("QP aff_err: entry=0x%llx, token=0x%x\n",
 		       eqe->entry, qp_token);
@@ -959,6 +975,12 @@ static irqreturn_t ehea_qp_aff_irq_handl
 			reset_port = 1;   /* Reset in case of CQ or EQ error */
--
 	while (eqe) {
 		pr_debug("*eqe=%lx\n", (unsigned long) eqe->entry);
 		ehea_parse_eqe(adapter, eqe->entry);
 		eqe = ehea_poll_eq(adapter->neq);
 		pr_debug("next eqe=%p\n", eqe);
+		if (_cur < timeout) {
--
 	while (--i >= 0) {
 		u32 ist = port->port_res[i].eq->attr.ist1;
 		ibmebus_free_irq(ist, &port->port_res[i]);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
-	while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
 
 		dn_log_port_id = of_get_property(eth_dn, "ibm,hea-port-no",
 						 NULL);
@@ -3110,6 +3159,12 @@ static int ehea_setup_ports(struct ehea_
 			ehea_remove_adapter_mr(adapter);
--
-	while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
 
 		dn_log_port_id = of_get_property(eth_dn, "ibm,hea-port-no",
 						 NULL);
 		if (dn_log_port_id)
 			if (*dn_log_port_id == logical_port_id)
--
 		while (!(in_be32(&p->mr0) & EMAC_MR0_TXI) && n) {
 			udelay(1);
 			--n;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 			while (!(r = in_be32(&p->mr0) & EMAC_MR0_RXI) && n) {
 				udelay(1);
 				--n;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 		while (!(in_be32(&p->mr0) & EMAC_MR0_RXI) && n) {
 			udelay(1);
 			--n;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!emac_phy_done(dev, in_be32(&p->stacr))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait idle\n");
 			goto bail;
 		}
--
 	while (!emac_phy_done(dev, (r = in_be32(&p->stacr)))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait complete\n");
 			goto bail;
 		}
--
 	while (!emac_phy_done(dev, in_be32(&p->stacr))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait idle\n");
 			goto bail;
 		}
--
 	while (!emac_phy_done(dev, in_be32(&p->stacr))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait complete\n");
 			goto bail;
 		}
--
 	while (slot != dev->tx_slot) {
 		dev->tx_desc[slot].ctrl = 0;
 		--dev->tx_cnt;
 		if (--slot < 0)
 			slot = NUM_TX_BUFF - 1;
+			if (_cur < timeout) {
--
 	while (1) {
 		u16 ctrl = dev->rx_desc[slot].ctrl;
 		if (ctrl & MAL_RX_CTRL_EMPTY)
@@ -1805,6 +1898,12 @@ static int emac_peek_rx_sg(void *param)
 		/* I'm just being paranoid here :) */
 		if (unlikely(slot == dev->rx_slot))
--
 	while (done < length) {
 		list[i].addr = iseries_hv_addr(p + done);
 		list[i].size = min(length-done, PAGE_SIZE);
 		done += list[i].size;
 		i++;
+		if (_cur < timeout) {
--
 	while (IS_DMA_FINISHED(td->control)) {
 		if (lp->tx_full == 1) {
 			netif_wake_queue(dev);
@@ -592,6 +597,12 @@ static void korina_tx(struct net_device
 		lp->tx_next_done = (lp->tx_next_done + 1) & KORINA_TDS_MASK;
 		td = &lp->td_ring[lp->tx_next_done];
--
 	while (count) {
 		temp = ql_read_other_func_reg(qdev, reg);
 
@@ -55,6 +60,12 @@ static int ql_wait_other_func_reg_rdy(st
 			return 0;
 		mdelay(10);
--
 				while ((result_index & MAC_ADDR_MR) == 0) {
 					result_index = ql_read32(qdev,
 								MAC_ADDR_IDX);
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count) {
 		temp = ql_read32(qdev, reg);
 
 		/* check for errors */
@@ -181,6 +186,12 @@ int ql_wait_reg_rdy(struct ql_adapter *q
 			return 0;
--
 	while (count) {
 		temp = ql_read32(qdev, CFG);
 		if (temp & CFG_LE)
@@ -203,6 +219,12 @@ static int ql_wait_cfg(struct ql_adapter
 			return 0;
 		udelay(UDELAY_DELAY);
--
 	while (rx_ring->lbq_free_cnt > 32) {
 		for (i = 0; i < 16; i++) {
 			netif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,
@@ -1209,6 +1236,12 @@ static void ql_update_lbq(struct ql_adap
 		if (rx_ring->lbq_prod_idx == rx_ring->lbq_len)
 			rx_ring->lbq_prod_idx = 0;
--
 	while (rx_ring->sbq_free_cnt > 16) {
 		for (i = 0; i < 16; i++) {
 			sbq_desc = &rx_ring->sbq[clean_idx];
@@ -1277,6 +1315,12 @@ static void ql_update_sbq(struct ql_adap
 		if (rx_ring->sbq_prod_idx == rx_ring->sbq_len)
 			rx_ring->sbq_prod_idx = 0;
--
-		while (length > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (length > 0) {
 			lbq_desc = ql_get_curr_lchunk(qdev, rx_ring);
 			size = (length < rx_ring->lbq_buf_size) ? length :
 				rx_ring->lbq_buf_size;
@@ -1914,6 +1963,12 @@ static struct sk_buff *ql_build_rx_skb(s
 			skb->truesize += size;
--
-	while (prod != rx_ring->cnsmr_idx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (prod != rx_ring->cnsmr_idx) {
 
 		netif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,
 			     "cq_id = %d, prod = %d, cnsmr = %d.\n.",
@@ -2199,6 +2259,12 @@ static int ql_clean_outbound_rx_ring(str
 		count++;
--
 	while (curr_idx != clean_idx) {
 		lbq_desc = &rx_ring->lbq[curr_idx];
 
@@ -2768,6 +2839,12 @@ static void ql_free_lbq_buffers(struct q
 		if (++curr_idx == rx_ring->lbq_len)
 			curr_idx = 0;
--
-		while (i-- && !test_bit(QL_ADAPTER_UP, &qdev->flags)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (i-- && !test_bit(QL_ADAPTER_UP, &qdev->flags)) {
 			netif_err(qdev, ifup, qdev->ndev,
 				  "Waiting for adapter UP...\n");
 			ssleep(1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (i < 10) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (i < 10) {
 		if (i)
 			ssleep(1);
 
@@ -159,6 +164,12 @@ static int ql_wait_for_drvr_lock(struct
 				      "driver lock acquired\n");
--
 	while (count) {
 		temp = ql_read_page0_reg(qdev, &port_regs->macMIIStatusReg);
 		if (!(temp & MAC_MII_STATUS_BSY))
 			return 0;
 		udelay(10);
 		count--;
--
 		while (qdev->small_buf_release_cnt >= 16) {
 			qdev->small_buf_q_producer_index++;
 
@@ -1854,6 +1881,12 @@ static void ql_update_small_bufq_prod_in
 			    NUM_SBUFQ_ENTRIES)
 				qdev->small_buf_q_producer_index = 0;
--
-		while ((qdev->lrg_buf_release_cnt >= 16) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while ((qdev->lrg_buf_release_cnt >= 16) &&
 		       (qdev->lrg_buf_free_count >= 8)) {
 
 			for (i = 0; i < 8; i++) {
@@ -1906,6 +1944,12 @@ static void ql_update_lrg_bufq_prod_inde
 			    (qdev->num_lbufq_entries - 1)) {
--
 	while ((le32_to_cpu(*(qdev->prsp_producer_index)) !=
 		qdev->rsp_consumer_index) && (work_done < work_to_do)) {
 
@@ -2178,6 +2227,12 @@ static int ql_tx_rx_clean(struct ql3_ada
 		}
 
--
 	while (npar_state != QLCNIC_DEV_NPAR_OPER && --npar_opt_timeo) {
 		msleep(1000);
 		npar_state = QLCRD32(adapter, QLCNIC_CRB_DEV_NPAR_STATE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while (copied < hdr_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (copied < hdr_len) {
 
 			copy_len = min((int)sizeof(struct cmd_desc_type0) -
 				offset, (hdr_len - copied));
@@ -2079,6 +2095,12 @@ set_flags:
 			offset = 0;
--
 	while (--i >= 0) {
 		nf = &pbuf->frag_array[i+1];
 		pci_unmap_page(pdev, nf->dma, nf->length, PCI_DMA_TODEVICE);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (val-- > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (val-- > 0) {
 		oth_pdev = pci_get_domain_bus_and_slot(pci_domain_nr
 			(pdev->bus), pdev->bus->number,
 			PCI_DEVFN(PCI_SLOT(pdev->devfn), val));
@@ -3203,6 +3241,12 @@ static int qlcnic_is_first_func(struct p
 			return 0;
--
-	while (!list_empty(head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(head)) {
 		cur = list_entry(head->next, struct qlcnic_mac_list_s, list);
 		qlcnic_sre_macaddr_change(adapter,
 				cur->mac_addr, 0, QLCNIC_MAC_DEL);
 		list_del(&cur->list);
 		kfree(cur);
--
 		while (cnt) {
 			QLCNIC_RD_DUMP_REG(addr, base, &data);
 			*buffer++ = cpu_to_le32(data);
 			addr += l1->read_addr_stride;
 			cnt--;
+			if (_cur < timeout) {
--
 		while (cnt) {
 			QLCNIC_RD_DUMP_REG(addr, base, &data);
 			*buffer++ = cpu_to_le32(data);
 			addr += l2->read_addr_stride;
 			cnt--;
+			if (_cur < timeout) {
--
-	while (reg_read != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (reg_read != 0) {
 		QLCNIC_WR_DUMP_REG(MIU_TEST_ADDR_LO, base, addr);
 		QLCNIC_WR_DUMP_REG(MIU_TEST_ADDR_HI, base, 0);
 		QLCNIC_WR_DUMP_REG(MIU_TEST_CTR, base,
@@ -1646,6 +1684,12 @@ qlcnic_read_memory(struct qlcnic_adapter
 		addr += 16;
--
-	while (done == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (done == 0) {
 		done = QLCRD32(adapter, QLCNIC_ROMUSB_GLB_STATUS);
 		done &= 2;
 		if (++timeout >= QLCNIC_MAX_ROM_WAIT_USEC) {
@@ -340,6 +345,12 @@ static int qlcnic_wait_rom_done(struct q
 			return -EIO;
--
 	while (desc_cnt > 0 && i < 8) {
 		desc = &sds_ring->desc_head[index];
 		msg.words[i++] = le64_to_cpu(desc->status_desc_data[0]);
@@ -1389,6 +1405,12 @@ qlcnic_handle_fw_message(int desc_cnt, i
 
 		index = get_next_index(index, sds_ring->num_desc);
--
-	while (done == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (done == 0) {
 		done = NXRD32(adapter, NETXEN_ROMUSB_GLB_STATUS);
 		done &= 2;
 		if (++timeout >= NETXEN_MAX_ROM_WAIT_USEC) {
@@ -365,6 +370,12 @@ static int netxen_wait_rom_done(struct n
 			return -EIO;
--
 	while (desc_cnt > 0 && i < 8) {
 		desc = &sds_ring->desc_head[index];
 		msg.words[i++] = le64_to_cpu(desc->status_desc_data[0]);
@@ -1473,6 +1489,12 @@ netxen_handle_fw_message(int desc_cnt, i
 
 		index = get_next_index(index, sds_ring->num_desc);
--
-	while (copied < hdr_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (copied < hdr_len) {
 
 		copy_len = min((int)sizeof(struct cmd_desc_type0) - offset,
 				(hdr_len - copied));
@@ -1879,6 +1884,12 @@ netxen_tso_check(struct net_device *netd
 		offset = 0;
--
 	while (--i >= 0) {
 		nf = &pbuf->frag_array[i+1];
 		pci_unmap_page(pdev, nf->dma, nf->length, PCI_DMA_TODEVICE);
 		nf->dma = 0ULL;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (!list_empty(head)) {
 		cur = list_entry(head->next, struct nx_vlan_ip_list, list);
 		netxen_config_ipaddr(adapter, cur->ip_addr, NX_IP_DOWN);
 		list_del(&cur->list);
 		kfree(cur);
+		if (_cur < timeout) {
--
-	while (!list_empty(head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(head)) {
 		cur = list_entry(head->next, nx_mac_list_t, list);
 
 		nx_p3_sre_macaddr_change(adapter,
 				cur->mac_addr, NETXEN_MAC_DEL);
 		list_del(&cur->list);
--
-	while (!list_empty(head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(head)) {
 		cur = list_entry(head->next, nx_mac_list_t, list);
 		nx_p3_sre_macaddr_change(adapter,
 				cur->mac_addr, NETXEN_MAC_DEL);
 		list_del(&cur->list);
 		kfree(cur);
--
 	while (bdx_rxdb_available(db) > 0) {
 		i = bdx_rxdb_alloc_elem(db);
 		dm = bdx_rxdb_addr_elem(db, i);
 		dm->dma = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (f->m.wptr != f->m.rptr) {
 		f->m.rptr += BDX_TXF_DESC_SZ;
 		f->m.rptr &= f->m.size_mask;
@@ -1731,6 +1747,12 @@ static void bdx_tx_cleanup(struct bdx_pr
 		/* now should come skb pointer - free it */
 		dev_kfree_skb_irq(db->rptr->addr.skb);
--
-	while (db->rptr != db->wptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (db->rptr != db->wptr) {
 		if (likely(db->rptr->len))
 			pci_unmap_page(priv->pdev, db->rptr->addr.dma,
 				       db->rptr->len, PCI_DMA_TODEVICE);
 		else
 			dev_kfree_skb(db->rptr->addr.skb);
--
 			while(i > 0) { /* free any that were allocated successfully */
 				i--;
 				dev_kfree_skb(lp->rx_skb[i]);
 				lp->rx_skb[i] = NULL;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while(i > 0) { /* free any that were mapped successfully */
 				i--;
 				dma_unmap_single(lp->device, lp->rx_laddr[i], SONIC_RBSIZE, DMA_FROM_DEVICE);
 				lp->rx_laddr[i] = (dma_addr_t)0;
+				if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		/* read descriptor that was next to be filled by SONIC */
 
@@ -641,6 +646,12 @@ static void irqrx_handler(struct net_dev
 		priv->lastrxdescr = priv->nextrxdescr;
 		if ((++priv->nextrxdescr) >= priv->rxbufcnt)
--
 	while (1) {
 		ival = inw(dev->base_addr + SONIC_ISREG);
 
@@ -733,6 +749,12 @@ static irqreturn_t irq_handler(int dummy
 			outw(ISREG_TXER, dev->base_addr + SONIC_ISREG);
 		}
--
 		while (destoffs < tmplen) {
 			memcpy_toio(priv->base + baddr + destoffs, fill, l);
 			destoffs += l;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((CMDSTS_OWN & (cmdsts = le32_to_cpu(desc[DESC_CMDSTS]))) &&
 	       (cmdsts != CMDSTS_OWN)) {
 		struct sk_buff *skb;
@@ -927,6 +932,12 @@ netdev_mangle_me_harder_failed:
 		nr++;
 		next_rx = info->next_rx;
--
 	while ((tx_done_idx != dev->tx_free_idx) &&
 	       !(CMDSTS_OWN & (cmdsts = le32_to_cpu(desc[DESC_CMDSTS]))) ) {
 		struct sk_buff *skb;
@@ -1018,6 +1034,12 @@ static void do_tx_done(struct net_device
 		desc[DESC_CMDSTS] = cpu_to_le32(0);
 		mb();
--
 	while (IPG_AC_RESET_BUSY & ipg_r32(ASIC_CTRL)) {
 		mdelay(IPG_AC_RESETWAIT);
 		if (++timeout_count > IPG_AC_RESET_TIMEOUT)
 			return -ETIME;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while ((le64_to_cpu(rxfd->rfs) & IPG_RFS_RFDDONE) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((le64_to_cpu(rxfd->rfs) & IPG_RFS_RFDDONE) &&
 	       !((le64_to_cpu(rxfd->rfs) & IPG_RFS_FRAMESTART) &&
 		 (le64_to_cpu(rxfd->rfs) & IPG_RFS_FRAMEEND))) {
 		unsigned int entry = curr++ % IPG_RFDLIST_LENGTH;
@@ -1533,6 +1549,12 @@ static int ipg_nic_rx(struct net_device
 
--
 	while (length != 0) {
 		if (rev == revision) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
--
 			while (length > 1) {
 				address = *phy_param;
 				value = *(phy_param + 1);
 				phy_param += 2;
 				mdio_write(dev, phy_address, address, value);
 				length -= 4;
--
-		while (mib->cnt_ptr < PORT_COUNTER_NUM) {
-			port_r_mib_cnt(hw, port, mib->cnt_ptr,
+	if (mib->mib_start < PORT_COUNTER_NUM) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
--
+			while (mib->cnt_ptr < PORT_COUNTER_NUM) {
+				port_r_mib_cnt(hw, port, mib->cnt_ptr,
 				&mib->counter[mib->cnt_ptr]);
 			++mib->cnt_ptr;
+			if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (!(alloc & 1)) {
 		shift++;
 		alloc >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (alloc) {
 			shift++;
 			alloc >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (hw->tx_int_mask) {
 		hw->tx_int_cnt++;
 		hw->tx_int_mask >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (info->avail < info->alloc) {
 		/* Get next descriptor which is not hardware owned. */
 		desc = &info->ring[last];
@@ -4799,6 +4849,12 @@ static void transmit_cleanup(struct dev_
 		last++;
 		last &= info->mask;
--
 	while (range->end > range->start) {
 		regs_len += (range->end - range->start + 3) / 4 * 4;
 		range++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (range->end > range->start) {
 		for (len = range->start; len < range->end; len += 4) {
 			*buf = readl(hw->io + len);
 			buf++;
 		}
 		range++;
--
 	while (j < MAC_ADDR_LEN) {
 		if (macaddr[i]) {
 			int digit;
@@ -6890,6 +6973,12 @@ static void get_mac_addr(struct dev_info
 			num = got_num = 0;
 		}
--
-	while (received < budget
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (received < budget
 			&& ksp->rx_buffers[buff_n].skb
 			&& (!(ksp->rx_ring[buff_n].status &
 					cpu_to_le32(RDES_OWN)))) {
@@ -536,6 +541,12 @@ rx_failure:
 rx_finished:
--
 	while (!last) {
 		txb = skb_dequeue(&ks->txq);
 		last = skb_queue_empty(&ks->txq);
@@ -733,6 +738,12 @@ static void ks8851_tx_work(struct work_s
 
 			ks8851_done_tx(ks, txb);
--
-	while (!skb_queue_empty(&ks->txq)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!skb_queue_empty(&ks->txq)) {
 		struct sk_buff *txb = skb_dequeue(&ks->txq);
 
 		netif_dbg(ks, ifdown, ks->netdev,
 			  "%s: freeing txb %p\n", __func__, txb);
 
--
 	while (state != EEPROM_COMPLETE) {
 		/* falling clock period starts... */
 		/* set EED_IO pin for control and address */
@@ -1144,6 +1171,12 @@ unsigned int ks8851_eeprom_read(struct n
 
 		/* wait period / 2 */
--
 	while (state != EEPROM_COMPLETE) {
 		/* falling clock period starts... */
 		/* set EED_IO pin for control and address */
@@ -1254,6 +1292,12 @@ void ks8851_eeprom_write(struct net_devi
 
 		/* wait period / 2 */
--
 	while (ks->frame_cnt--) {
 		skb = dev_alloc_skb(frame_hdr->len + 16);
 		if (likely(skb && (frame_hdr->sts & RXFSHR_RXFV) &&
@@ -812,6 +817,12 @@ static void ks_rcv(struct ks_net *ks, st
 				dev_kfree_skb_irq(skb);
 		}
--
 	while (--length >= 0) {
 		u8 current_octet = *data++;
 		int bit;
@@ -1073,6 +1089,12 @@ static unsigned long ether_gen_crc(int l
 				((crc < 0) ^ (current_octet & 1) ?
 			ethernet_polynomial : 0);
--
 		while (len > 0) {
 			iowrite16(*ptr16++, adapter->hw_addr + REG_QMU_DATA_LO);
 			iowrite16(*ptr16++, adapter->hw_addr + REG_QMU_DATA_HI);
 			len -= sizeof(u32);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (len > 0) {
 			iowrite32(*ptr, adapter->hw_addr + REG_QMU_DATA_LO);
 			len -= sizeof(u32);
 			ptr++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-				while (len > 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (len > 0) {
 					*data16++ = ioread16(adapter->hw_addr +
 						REG_QMU_DATA_LO);
 					*data16++ = ioread16(adapter->hw_addr +
 						REG_QMU_DATA_HI);
 					len -= sizeof(u32);
--
-				while (len > 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (len > 0) {
 					*data++ = ioread32(adapter->hw_addr +
 						REG_QMU_DATA_LO);
 					len -= sizeof(u32);
+					if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (rx_data) {
 		ks8842_rx_frame(netdev, adapter);
 		rx_data = ks8842_read16(adapter, 16, REG_RXMIR) & 0x1fff;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((bfin_read_EMAC_STAADD()) & STABUSY) {
 		udelay(1);
 		if (timeout_cnt-- < 0) {
 			pr_err("wait MDC/MDIO transaction to complete timeout\n");
 			return -ETIMEDOUT;
 		}
--
 	while (tx_list_head != current_tx_ptr) {
 		tx_list_head->desc_a.config &= ~DMAEN;
 		tx_list_head->status.status_word = 0;
@@ -1277,6 +1293,12 @@ static void bfin_mac_timeout(struct net_
 			tx_list_head->skb = NULL;
 		}
--
 	while (--bits >= 0) {
 		iowrite32(MDIO_WRITE1, mdio_addr);
 		mdio_delay(mdio_addr);
 		iowrite32(MDIO_WRITE1 | MDIO_ShiftClk, mdio_addr);
 		mdio_delay(mdio_addr);
+		if (_cur < timeout) {
--
-	while (skb && !netif_queue_stopped(dev) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (skb && !netif_queue_stopped(dev) &&
 	       (u_long) lp->tx_skb[lp->tx_new] <= 1) {
 	    spin_lock_irqsave(&lp->lock, flags);
 	    netif_stop_queue(dev);
@@ -1513,6 +1518,12 @@ de4x5_queue_pkt(struct sk_buff *skb, str
 	    }
--
 	while (!skb_queue_empty(&lp->cache.queue) && !netif_queue_stopped(dev) && lp->tx_enable) {
 	    de4x5_queue_pkt(de4x5_get_cache(dev), dev);
+	    if (_cur < timeout) {
+	    rdstcll(_cur);
+	    }
+	    else {
--
-    while (count--) {
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+	while (count--) {
 	gep_wr(((lp->chipset==DC21140) && (lp->ibn!=5) ?
 		                                   *p++ : get_unaligned_le16(w++)), dev);
 	mdelay(2);                          /* 2ms per action */
+	if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (db->rx_avail_cnt) {
 		dev_kfree_skb(db->rx_ready_ptr->rx_skb_ptr);
 		db->rx_ready_ptr = db->rx_ready_ptr->next_rx_desc;
 		db->rx_avail_cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--i) {
 		if (!de_is_running(de))
 			return;
 		udelay(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (db->rx_avail_cnt) {
 		dev_kfree_skb(db->rx_ready_ptr->rx_skb_ptr);
 		db->rx_ready_ptr = db->rx_ready_ptr->next_rx_desc;
 		db->rx_avail_cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (inb(EWRK3_RQC) && !status) {	/* Whilst there's incoming data */
 		if ((page = inb(EWRK3_RQ)) < lp->mPage) {	/* Get next entry's buffer page */
 			/*
@@ -1048,6 +1053,12 @@ static int ewrk3_rx(struct net_device *d
 			printk("ewrk3_rx(): Illegal page number, page %d\n", page);
 			printk("ewrk3_rx(): CSR: %02x ICR: %02x FMQC: %02x\n", inb(EWRK3_CSR), inb(EWRK3_ICR), inb(EWRK3_FMQC));
--
 	while ((tx_status = inb(EWRK3_TDQ)) > 0) {	/* Whilst there's old buffers */
 		if (tx_status & T_VSTS) {	/* The status is valid */
 			if (tx_status & T_TXE) {
@@ -1087,6 +1103,12 @@ static int ewrk3_tx(struct net_device *d
 				dev->stats.tx_packets++;
 			}
--
     while (eth_status & FullPktRcvd) {
 	rsr = GetByte(XIRCREG0_RSR);
 	if (bytes_rcvd > maxrx_bytes && (rsr & PktRxOk)) {
@@ -1124,6 +1129,12 @@ xirc2ps_interrupt(int irq, void *dev_id)
 
 	/* get the new ethernet status */
--
 	while (--nb >= 0) {
 		bmwrite(dev, MIFCSR, 0);
 		MIFDELAY;
@@ -251,6 +256,12 @@ bmac_mif_readbits(struct net_device *dev
 			val |= 1 << nb;
 		bmwrite(dev, MIFCSR, 1);
--
 	while (--nb >= 0) {
 		b = (val & (1 << nb))? 6: 4;
 		bmwrite(dev, MIFCSR, b);
 		MIFDELAY;
 		bmwrite(dev, MIFCSR, b|1);
 		MIFDELAY;
--
     while (--i) {
 	out_8(&mb->biucc, SWRST);
 	if (in_8(&mb->biucc) & SWRST) {
@@ -332,6 +337,12 @@ static void mace_reset(struct net_device
 	    continue;
 	}
--
     while (in_8(&mb->pr) & XMTSV) {
 	del_timer(&mp->tx_timeout);
 	mp->timeout_active = 0;
@@ -778,6 +794,12 @@ static irqreturn_t mace_interrupt(int ir
 	mace_last_fs = fs;
 	mace_last_xcount = xcount;
--
 	while (--i) {
 		mb->biucc = SWRST;
 		if (mb->biucc & SWRST) {
@@ -277,6 +282,12 @@ static void mace_reset(struct net_device
 			continue;
 		}
--
-		while (mp->rx_tail < head) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (mp->rx_tail < head) {
 			mace_dma_rx_frame(dev, (struct mace_frame*) (mp->rx_ring
 				+ (mp->rx_tail * MACE_BUFF_SIZE)));
 			mp->rx_tail++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (in_be32(lp->base_addr + XEL_MDIOCTRL_OFFSET) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (in_be32(lp->base_addr + XEL_MDIOCTRL_OFFSET) &
 			XEL_MDIOCTRL_MDIOSTS_MASK) {
 		if (end - jiffies <= 0) {
 			WARN_ON(1);
 			return -ETIMEDOUT;
 		}
--
 	while (!(temac_ior(lp, XTE_RDY0_OFFSET) & XTE_RDY0_HARD_ACS_RDY_MASK)) {
 		if (end - jiffies <= 0) {
 			WARN_ON(1);
 			return -ETIMEDOUT;
 		}
 		msleep(1);
--
 	while (tp->opt) {
 		reg = temac_indirect_in32(lp, tp->reg) & ~tp->m_or;
 		if (options & tp->opt)
 			reg |= tp->m_or;
 		temac_indirect_out32(lp, tp->reg, reg);
 		tp++;
--
-	while (stat & STS_CTRL_APP0_CMPLT) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (stat & STS_CTRL_APP0_CMPLT) {
 		dma_unmap_single(ndev->dev.parent, cur_p->phys, cur_p->len,
 				 DMA_TO_DEVICE);
 		if (cur_p->app4)
@@ -652,6 +679,12 @@ static void temac_start_xmit_done(struct
 
--
-	while ((bdstat & STS_CTRL_APP0_CMPLT)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((bdstat & STS_CTRL_APP0_CMPLT)) {
 
 		skb = lp->rx_skb[lp->rx_bd_ci];
 		length = cur_p->app4 & 0x3FFF;
@@ -813,6 +851,12 @@ static void ll_temac_recv(struct net_dev
 
--
 	while (i-- > 0) {
 		if (!(inw (ioaddr + EepromCtrl) & EEP_BUSY)) {
 			return inw (ioaddr + EepromData);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--bits >= 0) {
 		iowrite8(MDIO_WRITE1, mdio_addr);
 		mdio_delay();
 		iowrite8(MDIO_WRITE1 | MDIO_ShiftClk, mdio_addr);
 		mdio_delay();
+		if (_cur < timeout) {
--
 	while (count-- > 0) {
 		*data++ = de620_read_byte(dev);
 		de620_flip_ds(dev);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 	while (count-- > 0) {
 		value = inb(STATUS_PORT) & 0xf0; /* High nibble */
 		outb(uflip, COMMAND_PORT);
 		*data++ = value | inb(STATUS_PORT) >> 4; /* Low nibble */
 		outb(dflip , COMMAND_PORT);
+		if (_cur < timeout) {
--
-		while((idev = pnp_find_dev(NULL,
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while((idev = pnp_find_dev(NULL,
 					   corkscrew_isapnp_adapters[i].vendor,
 					   corkscrew_isapnp_adapters[i].function,
 					   idev))) {
@@ -541,6 +546,12 @@ static struct net_device *corkscrew_scan
 			if (!err)
--
 		while (--i > 0 && (tx_status = inb(ioaddr + TxStatus)) > 0) {
 			if (tx_status & 0x3C) {	/* A Tx-disabling error occurred.  */
 				if (corkscrew_debug > 2)
@@ -1116,6 +1132,12 @@ static netdev_tx_t corkscrew_start_xmit(
 				outw(TxEnable, ioaddr + EL3_CMD);
 			}
--
 	while ((rx_status = inw(ioaddr + RxStatus)) > 0) {
 		if (rx_status & 0x4000) {	/* Error, update stats. */
 			unsigned char rx_error = inb(ioaddr + RxErrors);
@@ -1324,6 +1351,12 @@ static int corkscrew_rx(struct net_devic
 		for (i = 200; i >= 0; i--)
 			if (!(inw(ioaddr + EL3_STATUS) & CmdInProgress))
--
 	while ((rx_status = vp->rx_ring[entry].status) & RxDComplete) {
 		if (rx_status & RxDError) {	/* Error, update stats. */
 			unsigned char rx_error = rx_status >> 16;
@@ -1397,6 +1435,12 @@ static int boomerang_rx(struct net_devic
 			dev->stats.rx_packets++;
 		}
--
-	while (!list_empty(&root_corkscrew_dev)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&root_corkscrew_dev)) {
 		struct net_device *dev;
 		struct corkscrew_private *vp;
 
@@ -1579,6 +1628,12 @@ void cleanup_module(void)
 		unregister_netdev(dev);
--
 		while (--i > 0	&&	(tx_status = inb(ioaddr + TX_STATUS)) > 0) {
 			if (tx_status & 0x38) dev->stats.tx_aborted_errors++;
 			if (tx_status & 0x30) outw(TxReset, ioaddr + EL3_CMD);
 			if (tx_status & 0x3C) outw(TxEnable, ioaddr + EL3_CMD);
 			outb(0x00, ioaddr + TX_STATUS); /* Pop the status stack. */
+			if (_cur < timeout) {
--
 				while (--i>0 && (tx_status = inb(ioaddr + TX_STATUS)) > 0) {
 					if (tx_status & 0x38) dev->stats.tx_aborted_errors++;
 					if (tx_status & 0x30) outw(TxReset, ioaddr + EL3_CMD);
 					if (tx_status & 0x3C) outw(TxEnable, ioaddr + EL3_CMD);
 					outb(0x00, ioaddr + TX_STATUS); /* Pop the status stack. */
+					if (_cur < timeout) {
--
 	while ((rx_status = inw(ioaddr + RX_STATUS)) > 0) {
 		if (rx_status & 0x4000) { /* Error, update stats. */
 			short error = rx_status & 0x3800;
@@ -1096,6 +1123,12 @@ el3_rx(struct net_device *dev)
 		while (inw(ioaddr + EL3_STATUS) & 0x1000)
 			pr_debug("	Waiting for 3c509 to discard packet, status %x.\n",
 				   inw(ioaddr + EL3_STATUS) );
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (-- bits >= 0) {
 		outw(MDIO_DATA_WRITE1, mdio_addr);
 		outw(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!((rx_status = inw(ioaddr + RxStatus)) & 0x8000) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!((rx_status = inw(ioaddr + RxStatus)) & 0x8000) &&
 			worklimit > 0) {
 		worklimit--;
 		if (rx_status & 0x4000) { /* Error, update stats. */
@@ -1031,6 +1047,12 @@ static int el3_rx(struct net_device *dev
 			}
--
 		while (--i > 0	&&	(tx_status = ioread8(ioaddr + TxStatus)) > 0) {
 			if (tx_status & 0x3C) {		/* A Tx-disabling error occurred.  */
 				if (vortex_debug > 2)
@@ -2117,6 +2122,12 @@ vortex_start_xmit(struct sk_buff *skb, s
 				iowrite16(TxEnable, ioaddr + EL3_CMD);
 			}
--
 	while ((rx_status = ioread16(ioaddr + RxStatus)) > 0) {
 		if (rx_status & 0x4000) { /* Error, update stats. */
 			unsigned char rx_error = ioread8(ioaddr + RxErrors);
@@ -2537,6 +2553,12 @@ static int vortex_rx(struct net_device *
 			dev->stats.rx_dropped++;
 		}
--
-	while (-- bits >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (-- bits >= 0) {
 		window_write16(vp, MDIO_DATA_WRITE1, 4, Wn4_PhysicalMgmt);
 		mdio_delay(vp);
 		window_write16(vp, MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK,
 			       4, Wn4_PhysicalMgmt);
 		mdio_delay(vp);
--
 	while(cleared != ready) {
 		resp = (struct resp_desc *)(base + cleared);
 		count = resp->numDesc + 1;
@@ -530,6 +535,12 @@ typhoon_process_response(struct typhoon
 
 cleanup:
--
 	while (numSections--) {
 		if (remaining < sizeof(struct typhoon_section_header))
 			goto invalid_fw;
@@ -1321,6 +1337,12 @@ typhoon_request_firmware(struct typhoon
 
 		image_data += section_len;
--
 		while(section_len) {
 			len = min_t(u32, section_len, PAGE_SIZE);
 
@@ -1443,6 +1470,12 @@ typhoon_download_firmware(struct typhoon
 			image_data += len;
 			load_addr += len;
--
 	while(lastRead != le32_to_cpu(*index)) {
 		tx = (struct tx_desc *) (txRing->ringBase + lastRead);
 		type = tx->flags & TYPHOON_TYPE_MASK;
@@ -1540,6 +1578,12 @@ typhoon_clean_tx(struct typhoon *tp, str
 
 		tx->flags = 0;
--
 	while(rxaddr != local_ready && budget > 0) {
 		rx = (struct rx_desc *) (rxRing->ringBase + rxaddr);
 		idx = rx->addr;
@@ -1707,6 +1756,12 @@ typhoon_rx(struct typhoon *tp, struct ba
 
 		received++;
--
-    while (!((rx_status = inw(ioaddr + RX_STATUS)) & 0x8000) &&
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (!((rx_status = inw(ioaddr + RX_STATUS)) & 0x8000) &&
 		    worklimit > 0) {
 	worklimit--;
 	if (rx_status & 0x4000) { /* Error, update stats. */
@@ -838,6 +843,12 @@ static int el3_rx(struct net_device *dev
 	}
--
 	while (mask) {
 		/* low MDC, prepare MDO */
 		miir &= ~(MASK_MIIR_MII_MDC + MASK_MIIR_MII_MDO);
@@ -752,6 +757,12 @@ static ulong m80x_send_cmd_to_phy(void _
 		mask >>= 1;
 		if (mask == 0x2 && opcode == OP_READ)
--
 	while (mask) {
 		/* low MDC */
 		miir &= ~MASK_MIIR_MII_MDC;
@@ -786,6 +802,12 @@ static int mdio_read(struct net_device *
 
 		/* next */
--
 	while (mask) {
 		/* low MDC, prepare MDO */
 		miir &= ~(MASK_MIIR_MII_MDC + MASK_MIIR_MII_MDO);
@@ -820,6 +847,12 @@ static void mdio_write(struct net_device
 
 		/* next */
--
 	while (--delay) {
 		ioread32(ioaddr + BCR);
 		rmb();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (status) {
 		int fill_level;
 		writel(status, NETX_PFIFO_XPEC_ISR(priv->id));
@@ -202,6 +207,12 @@ netx_eth_interrupt(int irq, void *dev_id
 			mii_check_media(&priv->mii, netif_msg_link(priv), 1);
 
--
 	while (size-- > 0) {
 		mapping += sizeof(*desc);
 		desc->ndesc = cpu_to_le32(mapping);
 		desc->vndescp = desc + 1;
 		desc++;
+		if (_cur < timeout) {
--
 	while (count < limit && !(descptr->status & DSC_OWNER_MAC)) {
 		/* Read the descriptor status */
 		err = descptr->status;
@@ -586,6 +602,12 @@ next_descr:
 		descptr->status = DSC_OWNER_MAC;
 		descptr = descptr->vndescp;
--
 		while (i < MCAST_MAX) {
 			iowrite16(0, ioaddr + MID_1L + 8 * i);
 			iowrite16(0, ioaddr + MID_1M + 8 * i);
 			iowrite16(0, ioaddr + MID_1H + 8 * i);
 			i++;
+			if (_cur < timeout) {
--
 	while (entry != cur_entry) {
 		txbd = &ether->tdesc->desclist[ether->finish_tx];
 
@@ -692,6 +697,12 @@ static irqreturn_t w90p910_tx_interrupt(
 
 		entry = ether->tdesc_phys +
--
 	while (skb->len > 0) {
 		u32 header, align_count;
 		struct sk_buff *ax_skb;
@@ -1115,6 +1120,12 @@ static int smsc95xx_rx_fixup(struct usbn
 		/* padding bytes before the next frame starts */
 		if (skb->len)
--
 	while ((skb = skb_dequeue(&dev->rxq_pause)) != NULL) {
 		usbnet_skb_return(dev, skb);
 		num++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!skb_queue_empty(q)) {
 		struct skb_data		*entry;
 		struct urb		*urb;
@@ -626,6 +642,12 @@ found:
 			count++;
 		usb_put_urb(urb);
--
 	while (!skb_queue_empty(&dev->rxq)
 		&& !skb_queue_empty(&dev->txq)
 		&& !skb_queue_empty(&dev->done)) {
@@ -667,6 +694,12 @@ static void usbnet_terminate_urbs(struct
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			netif_dbg(dev, ifdown, dev->net,
--
 	while ((skb = skb_dequeue (&dev->done))) {
 		entry = (struct skb_data *) skb->cb;
 		switch (entry->state) {
@@ -1220,6 +1258,12 @@ static void usbnet_bh (unsigned long par
 		default:
 			netdev_dbg(dev->net, "bogus skb state %d\n", entry->state);
--
 		while ((res = usb_get_from_anchor(&dev->deferred))) {
 
 			skb = (struct sk_buff *)res->context;
@@ -1557,6 +1606,12 @@ int usbnet_resume (struct usb_interface
 				dev->net->trans_start = jiffies;
 				__skb_queue_tail(&dev->txq, skb);
--
 	while (likely(skb->len)) {
 		err = parse_hip(skb->data, skb->len, &hh);
 		if (err) {
@@ -887,6 +892,12 @@ static int sierra_net_rx_fixup(struct us
 		if (new_skb)
 			usbnet_skb_return(dev, new_skb);
--
 	} /* while */
 
 	return 0;
diff -u -p a/net/usb/asix.c b/net/usb/asix.c
--- a/net/usb/asix.c
+++ b/net/usb/asix.c
--
 	while (offset + sizeof(u16) <= skb->len) {
 		u16 remaining = 0;
 		unsigned char *data;
@@ -379,6 +384,12 @@ static int asix_rx_fixup_internal(struct
 
 		offset += (rx->size + 1) & 0xfffe;
--
 	while (count > 1) {
 		// get the packet length
 		size = le32_to_cpu(packet->packet_length);
@@ -131,6 +136,12 @@ static int genelink_rx_fixup(struct usbn
 
 		// shift the data pointer to the next gl_packet
--
 	while (len >= 3) {
 		u8 dlen = data[0];
 		if (dlen < 3)
@@ -362,6 +367,12 @@ int usbpn_probe(struct usb_interface *in
 		}
 		data += dlen;
--
 	while (skb->len > 0) {
 		u32 rx_cmd_a, rx_cmd_b, align_count, size;
 		struct sk_buff *ax_skb;
@@ -1155,6 +1160,12 @@ static int smsc75xx_rx_fixup(struct usbn
 		/* padding bytes before the next frame starts */
 		if (skb->len)
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (count) {
 		switch (odev->rx_parse_state) {
 		case WAIT_IP:
 			/* waiting for IP header. */
@@ -985,6 +990,12 @@ static void packetizeRx(struct hso_net *
 			count--;
--
 	while (serial->rx_urb_filled[serial->curr_rx_urb_idx]) {
 		curr_urb = serial->rx_urb[serial->curr_rx_urb_idx];
 		count = put_rxbuf_data(curr_urb, serial);
@@ -1181,6 +1197,12 @@ static void put_rxbuf_data_and_resubmit_
 				serial->curr_rx_urb_idx = 0;
 			hso_resubmit_rx_bulk_urb(serial, curr_urb);
--
-		while (write_length_remaining) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (write_length_remaining) {
 			if (test_bit(TTY_THROTTLED, &tty->flags)) {
 				tty_kref_put(tty);
 				return -1;
@@ -2073,6 +2100,12 @@ static int put_rxbuf_data(struct urb *ur
 			serial->curr_rx_urb_offset += curr_write_len;
--
 	while (count--) {
 		if (buf->len < sizeof(*packet)) {
 			netif_err(dev, ifup, dev->net, "Packet too short\n");
@@ -235,7 +240,13 @@ static int vl600_rx_fixup(struct usbnet
 
 			return 1;
--
 	while (len > 3) {
 		if (buf [1] != USB_DT_CS_INTERFACE)
 			goto next_desc;
@@ -235,6 +240,12 @@ bad_detail:
 next_desc:
 		len -= buf [0];	/* bLength */
--
 	while ((len > 0) && (buf[0] > 2) && (buf[0] <= len)) {
 
 		if (buf[1] != USB_DT_CS_INTERFACE)
@@ -536,6 +541,12 @@ advance:
 		temp = buf[0];
 		buf += temp;
--
 		while (len_cleartext-- > 0) {
 			*buf_xoredtext++ = *buf_cleartext++ ^ xor_mask;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (dev->tx_buff.len > 0) {			/* wait until tx idle */
 		spin_unlock_irqrestore(&dev->tx_lock, flags);
 		msleep(10);
 		spin_lock_irqsave(&dev->tx_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (count--) {
 			/* rx not enabled: save the raw bytes and never
 			 * trigger any netif_rx. The received bytes are flushed
@@ -573,6 +589,12 @@ int sirdev_receive(struct sir_dev *dev,
 			/* What should we do when the buffer is full? */
 			if (unlikely(dev->rx_buff.len == dev->rx_buff.truesize))
--
 	while ((fifo_size-- > 0) && (actual < len)) {
 		/* Transmit next byte */
 		outb(buf[actual++], iobase+TBR);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((status = inb(iobase+FS_FO)) & FS_FO_FSFDR) {
 		st_fifo->entries[st_fifo->tail].status = status;
 		
@@ -812,8 +828,19 @@ static int w83977af_dma_receive_complete
 		
 		st_fifo->tail++;
--
 	while (st_fifo->len) {
 		/* Get first entry */
 		status = st_fifo->entries[st_fifo->head].status;
@@ -890,6 +917,12 @@ static int w83977af_dma_receive_complete
 			skb->protocol = htons(ETH_P_IRDA);
 			netif_rx(skb);
--
 		while (lsr & LSR_FIFOE) {
 			data = STRBR;
 			if (lsr & (LSR_OE | LSR_PE | LSR_FE | LSR_BI)) {
@@ -288,6 +293,12 @@ static irqreturn_t pxa_irda_sir_irq(int
 						  &si->rx_buff, data);
 			}
--
-	    	while ((si->tx_buff.len) && (STLSR & LSR_TDRQ)) {
+	    	unsigned long long delta = (cpu / khz / HZ) * 2;
+	    	unsigned long long _start = 0;
+	    	unsigned long long _cur = 0;
+	    	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((si->tx_buff.len) && (STLSR & LSR_TDRQ)) {
 	    		STTHR = *si->tx_buff.data++;
 			si->tx_buff.len -= 1;
-	    	}
+			if (_cur < timeout) {
+	    		rdstcll(_cur);
--
 	while (!(UART_GET_LSR(port) & THRE)) {
 		cpu_relax();
 		continue;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (st_fifo->len > 0) {	//upload frame
 			// Put this entry back in fifo 
 			if (st_fifo->head > MAX_RX_WINDOW)
@@ -1270,6 +1275,12 @@ static int RxTimerHandler(struct via_irc
 			skb_reset_mac_header(skb);
 			skb->protocol = htons(ETH_P_IRDA);
--
 		}		//while
 		self->RetryCount = 0;
 
diff -u -p a/net/irda/smsc-ircc2.c b/net/irda/smsc-ircc2.c
--- a/net/irda/smsc-ircc2.c
+++ b/net/irda/smsc-ircc2.c
--
 	while (fifo_size-- > 0 && actual < len) {
 		/* Transmit next byte */
 		outb(buf[actual], iobase + UART_TX);
 		actual++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (address->cfg_base) {
 		cfg_base = address->cfg_base;
 
@@ -2176,6 +2192,12 @@ static int __init smsc_ircc_look_for_chi
 					found++;
 		}
--
 	while (chip->devid != devid) {
 
 		chip++;
 
 		if (chip->name == NULL)
 			return NULL;
--
-	while (!(ptxd->flags & AU_OWN) && (aup->tx_tail != aup->tx_head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(ptxd->flags & AU_OWN) && (aup->tx_tail != aup->tx_head)) {
 		update_tx_stats(dev, ptxd->flags, 
 				ptxd->count_1<<8 | ptxd->count_0);
 		ptxd->count_0 = 0;
@@ -451,6 +456,12 @@ static void au1k_tx_ack(struct net_devic
 			aup->tx_full = 0;
--
 	while (!(flags & AU_OWN))  {
 		pDB = aup->rx_db_inuse[aup->rx_head];
 		count = prxd->count_1<<8 | prxd->count_0;
@@ -618,6 +634,12 @@ static int au1k_irda_rx(struct net_devic
 		prxd = aup->rx_ring[aup->rx_head];
 		flags = prxd->flags;
--
 	while ((fifo_size-- > 0) && (actual < len)) {
 		/* Transmit next byte */
 		outb(buf[actual], iobase+UART_TX);
 
 		actual++;
-	}
--
 	while ((fifo_size-- > 0) && (actual < len)) {
 		/* Transmit next byte */
 		outb(buf[actual++], iobase+TXD);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((status = inb(iobase+FRM_ST)) & FRM_ST_VLD) {
 		/* We must empty the status FIFO no matter what */
 		len = inb(iobase+RFLFL) | ((inb(iobase+RFLFH) & 0x1f) << 8);
@@ -1793,8 +1809,19 @@ static int nsc_ircc_dma_receive_complete
 		st_fifo->pending_bytes += len;
 		st_fifo->tail++;
--
 	while (st_fifo->len > 0) {
 		/* Get first entry */
 		status = st_fifo->entries[st_fifo->head].status;
@@ -1911,6 +1938,12 @@ static int nsc_ircc_dma_receive_complete
 			skb->protocol = htons(ETH_P_IRDA);
 			netif_rx(skb);
--
-      while (toshoboe_numvalidrcvs (self) != n)
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (toshoboe_numvalidrcvs (self) != n)
         {
           if (i > 4800)
               return toshoboe_probefail (self, "filter test");
           udelay ((9600*(TT_LEN+16))/self->speed);
           i++;
--
-      while ((toshoboe_numrcvs(self) != self->int_rx) || (self->int_tx != n))
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while ((toshoboe_numrcvs(self) != self->int_rx) || (self->int_tx != n))
         {
           if (i > 4800)
               return toshoboe_probefail (self, "interrupt test");
           udelay ((9600*(TT_LEN+16))/self->speed);
           i++;
--
-  while (toshoboe_numvalidrcvs (self) != 4)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (toshoboe_numvalidrcvs (self) != 4)
     {
       if (i > 100)
           return toshoboe_probefail (self, "Async test");
       udelay (100);
       i++;
--
-  while ((toshoboe_numrcvs (self) != self->int_rx) || (self->int_tx != 1))
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while ((toshoboe_numrcvs (self) != self->int_rx) || (self->int_tx != 1))
     {
       if (i > 100)
           return toshoboe_probefail (self, "Async interrupt test");
       udelay (100);
       i++;
--
-          while (self->ring->tx[txpc].control & OBOE_CTL_TX_HW_OWNS)
+          unsigned long long delta = (cpu / khz / HZ) * 2;
+          unsigned long long _start = 0;
+          unsigned long long _cur = 0;
+            unsigned long long timeout;
+            timeout = rdstcll(start) + delta;
+            while (self->ring->tx[txpc].control & OBOE_CTL_TX_HW_OWNS)
             {
               txp = txpc;
               txpc++;
@@ -1196,6 +1245,12 @@ toshoboe_interrupt (int irq, void *dev_i
               self->netdev->stats.tx_packets++;
--
-      while (!(self->ring->rx[self->rxs].control & OBOE_CTL_RX_HW_OWNS))
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (!(self->ring->rx[self->rxs].control & OBOE_CTL_RX_HW_OWNS))
         {
           int len = self->ring->rx[self->rxs].len;
           skb = NULL;
@@ -1313,6 +1373,12 @@ dumpbufs(self->rx_bufs[self->rxs],len,'<
           if (skb)
--
 	while (status & UTSR0_EIF) {
 		int stat, data;
 
@@ -386,6 +391,12 @@ static void sa1100_irda_hpsir_irq(struct
 			async_unwrap_char(dev, &dev->stats, &si->rx_buff, data);
 
--
         while((tmp = *r) != NULL)
         {
                 if(tmp->ip == rt->ip &&
@@ -241,7 +246,13 @@ static int ipddp_delete(struct ipddp_rou
                         return 0;
                 }
--
         while (ipddp_route_list) {
                 p = ipddp_route_list->next;
                 kfree(ipddp_route_list);
                 ipddp_route_list = p;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
--
         while(length--)
         {
                 outb(ltf->data[i], ioaddr);
                 i++;
-        }
+                if (_cur < timeout) {
--
                 while((inb(ioaddr+DAYNA_CARD_STATUS)&DAYNA_TX_READY)==0)
                 {
 			outb(0, ioaddr+COPS_CLEAR_INT);	/* Clear interrupts. */
         		if((inb(ioaddr+DAYNA_CARD_STATUS)&0x03)==DAYNA_RX_REQUEST)
                 		cops_rx(dev);	/* Kick any packets waiting. */
 			schedule();
--
                 while(inb(ioaddr+TANG_CARD_STATUS)&TANG_RX_READY)
                 {
 			outb(0, ioaddr+COPS_CLEAR_INT);	/* Clear interrupt. */
                 	cops_rx(dev);          	/* Kick out packets waiting. */
 			schedule();
+			if (_cur < timeout) {
--
-        while(lp->node_acquire==0)	/* Get *True* nodeid finally. */
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while(lp->node_acquire==0)	/* Get *True* nodeid finally. */
 	{
 		outb(0, ioaddr+COPS_CLEAR_INT);	/* Clear any interrupt. */
 
@@ -659,6 +697,12 @@ static int cops_nodeid (struct net_devic
                                 cops_rx(dev);   /* Grab the nodeid put in lp->node_acquire. */
--
-	while (tq->tx_ring.next2comp != eop_idx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tq->tx_ring.next2comp != eop_idx) {
 		vmxnet3_unmap_tx_buf(tq->buf_info + tq->tx_ring.next2comp,
 				     pdev);
 
@@ -360,6 +365,12 @@ vmxnet3_unmap_pkt(u32 eop_idx, struct vm
 		 */
--
-	while (VMXNET3_TCD_GET_GEN(&gdesc->tcd) == tq->comp_ring.gen) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (VMXNET3_TCD_GET_GEN(&gdesc->tcd) == tq->comp_ring.gen) {
 		completed += vmxnet3_unmap_pkt(VMXNET3_TCD_GET_TXIDX(
 					       &gdesc->tcd), tq, adapter->pdev,
 					       adapter);
 
 		vmxnet3_comp_ring_adv_next2proc(&tq->comp_ring);
--
 	while (tq->tx_ring.next2comp != tq->tx_ring.next2fill) {
 		struct vmxnet3_tx_buf_info *tbi;
 
@@ -415,6 +442,12 @@ vmxnet3_tq_cleanup(struct vmxnet3_tx_que
 			tbi->skb = NULL;
 		}
--
 	while (len) {
 		u32 buf_size;
 
@@ -743,6 +781,12 @@ vmxnet3_map_pkt(struct sk_buff *skb, str
 
 		len -= buf_size;
--
-		while (num_to_alloc) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (num_to_alloc) {
 			vmxnet3_getRxDesc(rxd, &ring->base[ring->next2fill].rxd,
 					  &rxCmdDesc);
 			BUG_ON(!rxd->addr);
@@ -1304,6 +1353,12 @@ rcd_done:
 			rxd->gen = ring->gen;
--
-	while (vectors >= vector_threshold) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (vectors >= vector_threshold) {
 		err = pci_enable_msix(adapter->pdev, adapter->intr.msix_entries,
 				      vectors);
 		if (!err) {
@@ -2722,6 +2782,12 @@ vmxnet3_acquire_msix_vectors(struct vmxn
 			       " %d instead\n", vectors, adapter->netdev->name,
--
 	while (myFirstTxDesc != myNextTxDesc) {
 		dev_kfree_skb(myFirstTxDesc->skb);
 		myFirstTxDesc->skb = 0;
 		myFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((*R_DMA_CH1_FIRST != virt_to_phys(myNextRxDesc)) &&
 		       (myNextRxDesc != myLastRxDesc)) {
 			/* Take out the buffer and give it to the OS, then
@@ -1166,10 +1182,21 @@ e100rxtx_interrupt(int irq, void *dev_id
 
 			/* now, we might have gotten another packet
--
 	while (virt_to_phys(myFirstTxDesc) != *R_DMA_CH0_FIRST &&
 	       (netif_queue_stopped(dev) || myFirstTxDesc != myNextTxDesc)) {
 		dev->stats.tx_bytes += myFirstTxDesc->skb->len;
@@ -1182,6 +1209,12 @@ e100rxtx_interrupt(int irq, void *dev_id
 		myFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);
                 /* Wake up queue. */
--
 	while (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) { 
 		schedule();		
 		if (time_after(jiffies, t + 40 * HZ)) {
 			printk(KERN_ERR "%s: 3COM 3C359 Velocity XL  card not responding to global reset.\n", dev->name);
 			return -ENODEV;
 		}
--
 	while ( !(readw(xl_mmio + MMIO_INTSTATUS_AUTO) & INTSTAT_SRB) ) { 
 		schedule();		
 		if (time_after(jiffies, t + 15 * HZ)) {
 			printk(KERN_ERR "3COM 3C359 Velocity XL  card not responding.\n");
 			return -ENODEV; 
 		}
--
 	while (xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].framestatus & (RXUPDCOMPLETE | RXUPDFULL) ) { /* Descriptor to process */
 
 		if (xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].framestatus & RXUPDFULL ) { /* UpdFull, Multiple Descriptors used for the frame */
@@ -942,9 +969,20 @@ static void xl_rx(struct net_device *dev
 
 			temp_ring_loc = xl_priv->rx_ring_tail ; 
--
 			while (xl_priv->xl_rx_ring[temp_ring_loc].framestatus & RXUPDFULL ) {
 				temp_ring_loc++ ; 
 				temp_ring_loc &= (XL_RX_RING_SIZE-1) ; 
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while (xl_priv->rx_ring_tail != temp_ring_loc) { 
 				copy_len = le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfraglen) & 0x7FFF;
 				frame_length -= copy_len ;  
@@ -972,6 +1015,12 @@ static void xl_rx(struct net_device *dev
 							  copy_len);
 				pci_dma_sync_single_for_device(xl_priv->pdev,le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfragaddr),xl_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE);
--
 	} /* while packet to do */
 
 	/* Clear the updComplete interrupt */
@@ -1123,10 +1178,21 @@ static irqreturn_t xl_interrupt(int irq,
 
 			if (intstatus & TXUNDERRUN) { /* Issue DnReset command */
--
 				while (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) { /* Wait for command to run */
 					/* !!! FIX-ME !!!! 
 					Must put a timeout check here ! */
 					/* Empty Loop */
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (xl_priv->xl_tx_ring[xl_priv->tx_ring_tail].framestartheader & TXDNCOMPLETE ) { 
 		txd = &(xl_priv->xl_tx_ring[xl_priv->tx_ring_tail]) ;
 		pci_unmap_single(xl_priv->pdev, le32_to_cpu(txd->buffer), xl_priv->tx_ring_skb[xl_priv->tx_ring_tail]->len, PCI_DMA_TODEVICE);
@@ -1277,6 +1348,12 @@ static void xl_dn_comp(struct net_device
 		xl_priv->tx_ring_tail++ ; 
 		xl_priv->tx_ring_tail &= (XL_TX_RING_SIZE - 1) ; 
--
 			while (readb(xl_mmio + MMIO_MACDATA) != 0) {
 				;	/* Empty Loop */
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
--
 	while (!((readw(streamer_mmio + SISR)) & SISR_SRB_REPLY)) {
 		msleep_interruptible(100);
 		if (time_after(jiffies, t + 40 * HZ)) {
@@ -520,6 +525,12 @@ static int streamer_reset(struct net_dev
 				dev_kfree_skb(skb);
 			return -1;
--
 	while (rx_desc->status & 0x01000000) {	/* While processed descriptors are available */
 		if (rx_ring_last_received != streamer_priv->rx_ring_last_received) 
 		{
@@ -1016,6 +1032,12 @@ static void streamer_rx(struct net_devic
 
 		/* try the next one */
--
 	while((sisr & (SISR_MI | SISR_SRB_REPLY | SISR_ADAPTER_CHECK | SISR_ASB_FREE | 
 		       SISR_ARB_CMD | SISR_TRB_REPLY | SISR_PAR_ERR | SISR_SERR_ERR)) &&
 	      (max_intr > 0)) {
@@ -1050,6 +1077,11 @@ static irqreturn_t streamer_interrupt(in
 			misr = readw(streamer_mmio + MISR_RUM);
 
--
 				while(streamer_priv->streamer_tx_ring[(streamer_priv->tx_ring_last_status + 1) & (STREAMER_TX_RING_SIZE - 1)].status) {
 				streamer_priv->tx_ring_last_status = (streamer_priv->tx_ring_last_status + 1) & (STREAMER_TX_RING_SIZE - 1);
 				streamer_priv->free_tx_ring_entries++;
@@ -1063,6 +1095,12 @@ static irqreturn_t streamer_interrupt(in
 				streamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].rsvd1 = 0;
 				streamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].rsvd2 = 0;
--
 	} /* while() */		
 
 	spin_unlock(&streamer_priv->streamer_lock) ; 
@@ -1580,11 +1624,22 @@ static void streamer_arb_cmd(struct net_
 				break;
 
--
 			while (i < buffer_len) {
 				rx_word=ntohs(readw(streamer_mmio+LAPDINC));
 				frame_data[i]=rx_word >> 8;
 				frame_data[i+1]=rx_word & 0xff;
 				i += 2;
+				if (_cur < timeout) {
--
         while(weight)
         {
                 branch = ROOT;
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
--
                 while((tree + branch)->tag != LEAF && weight)
                 {
                         branch = *ucode & bit ? (tree + branch)->llink
@@ -787,6 +797,12 @@ static int smctr_decode_firmware(struct
                                 bit = 0x80;
                                 ucode++;
--
         while((vlen > 0) && (rcode == POSITIVE_ACK))
         {
                 switch(rsv->svi)
@@ -4043,6 +4070,12 @@ static int smctr_rcv_chg_param(struct ne
                         rcode = E_VECTOR_LENGTH_ERROR;
 
--
         while((vlen > 0) && (rcode == POSITIVE_ACK))
         {
                 switch(rsv->svi)
@@ -4118,6 +4156,12 @@ static int smctr_rcv_init(struct net_dev
                         rcode = E_VECTOR_LENGTH_ERROR;
 
--
         while((vlen > 0) && (rcode == POSITIVE_ACK))
         {
                 switch(rsv->svi)
@@ -4178,6 +4227,12 @@ static int smctr_rcv_tx_forward(struct n
                         rcode = E_VECTOR_LENGTH_ERROR;
 
--
         while((vlen > 0) && (rcode == POSITIVE_ACK))
         {
                 switch(rsv->svi)
@@ -4234,6 +4294,12 @@ static int smctr_rcv_rq_addr_state_attch
                         rcode = E_VECTOR_LENGTH_ERROR;
 
--
         while((vlen > 0) && (*correlator == 0))
         {
                 switch(rsv->svi)
@@ -4284,6 +4355,12 @@ static int smctr_rcv_unknown(struct net_
 
                 vlen -= rsv->svl;
--
         while(flen > 0 && bytes > 0)
         {
                 smctr_set_page(dev, pbuff);
@@ -5450,6 +5532,12 @@ static unsigned short smctr_tx_move_fram
                 bytes -= len;
                 frag += len;
--
 	while((readl(olympic_mmio+BCTL)) & BCTL_SOFTRESET) {
 		schedule();		
 		if(time_after(jiffies, t + 40*HZ)) {
 			printk(KERN_ERR "IBM PCI tokenring card not responding.\n");
 			return -ENODEV;
 		}
--
 		while (!(readl(olympic_mmio+CLKCTL) & CLKCTL_PAUSE)) {
 			schedule() ; 
 			if(time_after(jiffies, t + 2*HZ)) {
 				printk(KERN_ERR "IBM Cardbus tokenring adapter not responsing.\n") ; 
 				return -ENODEV;
 			}
--
 	while(!((readl(olympic_mmio+SISR_RR)) & SISR_SRB_REPLY)) {
 		schedule();		
 		if(time_after(jiffies, t + 15*HZ)) {
 			printk(KERN_ERR "IBM PCI tokenring card not responding.\n");
 			return -ENODEV;
 		}
--
-	while (rx_status->status_buffercnt) { 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (rx_status->status_buffercnt) { 
                 u32 l_status_buffercnt;
 
 		olympic_priv->rx_status_last_received++ ;
@@ -879,6 +917,12 @@ static void olympic_rx(struct net_device
 		rx_status = &(olympic_priv->olympic_rx_status_ring[(olympic_priv->rx_status_last_received+1) & (OLYMPIC_RX_RING_SIZE -1) ]);
--
 	} /* while */
 
 }
@@ -969,6 +1013,11 @@ static irqreturn_t olympic_interrupt(int
 		/* We shouldn't ever miss the Tx interrupt, but the you never know, hence the loop to ensure
 		   we get all tx completions. */
--
 			while(olympic_priv->olympic_tx_status_ring[(olympic_priv->tx_ring_last_status + 1) & (OLYMPIC_TX_RING_SIZE-1)].status) { 
 				olympic_priv->tx_ring_last_status++;
 				olympic_priv->tx_ring_last_status &= (OLYMPIC_TX_RING_SIZE-1);
@@ -981,6 +1030,12 @@ static irqreturn_t olympic_interrupt(int
 				dev_kfree_skb_irq(olympic_priv->tx_ring_skb[olympic_priv->tx_ring_last_status]);
 				olympic_priv->olympic_tx_ring[olympic_priv->tx_ring_last_status].buffer=cpu_to_le32(0xdeadbeef);
--
 		while (!readb(ti->mmio + ACA_OFFSET + ACA_RW + RRR_EVEN)){
 			if (!time_after(jiffies, timeout)) continue;
 			DPRINTK( "Hardware timeout during initialization.\n");
 			iounmap(t_mmio);
 			return -ENODEV;
+			if (_cur < timeout) {
--
 	while(1) {
 		if (ti->page_mask) {
 			dhb_page=(dhb >> 8) & ti->page_mask;
@@ -1655,6 +1671,12 @@ static void tr_tx(struct net_device *dev
 		}
 		memcpy_toio(dhbuf, &ti->current_skb->data[src_offset], src_len);
--
 	while (rnet->tx_cnt && (rnet->ack_slot != slot)) {
 		/* dma unmap single */
 		dev_kfree_skb_irq(rnet->tx_skb[rnet->ack_slot]);
@@ -283,6 +288,12 @@ static void rionet_outb_msg_event(struct
 		++rnet->ack_slot;
 		rnet->ack_slot &= (RIONET_TX_RING_SIZE - 1);
--
 	while ((skb = skb_dequeue(&dp83640->rx_queue)) != NULL) {
 		type = SKB_PTP_TYPE(skb);
 		spin_lock_irqsave(&dp83640->rx_lock, flags);
@@ -1160,6 +1165,12 @@ static void rx_timestamp_work(struct wor
 		}
 		spin_unlock_irqrestore(&dp83640->rx_lock, flags);
--
 	while (--i >= 0) {
 		if (bus->phy_map[i])
 			device_unregister(&bus->phy_map[i]->dev);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (timediff >= 500000)
 		timediff -= 1000000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while (timediff >= bdus2) {
 		timediff -= bc->baud_us;
 		bc->modem.ser12.pll_time += bc->baud_us;
@@ -249,6 +254,12 @@ static __inline__ void ser12_rx(struct n
 		}
 		/* add a one bit */
--
 	while (count) {
 		count--;
 		if (fp && *fp++) {
@@ -482,6 +487,12 @@ static void sixpack_receive_buf(struct t
 				sp->dev->stats.rx_errors++;
 			continue;
--
 	while (first) {
 		info = first;
 
@@ -302,6 +307,12 @@ static void __exit dmascc_exit(void)
 		/* Free memory */
 		first = info->next;
--
 		while (jiffies - time < 13) {
 			for (i = 0; i < hw[h].num_devs; i++)
 				if (base[i] && counting[i]) {
@@ -402,6 +418,12 @@ static int __init dmascc_init(void)
 						counting[i] = 0;
 					delay[i] = jiffies - start[i];
--
 	while ((is = read_scc(&info->priv[0], R3)) && i--) {
 		if (is & CHARxIP) {
 			rx_isr(&info->priv[0]);
@@ -1113,6 +1140,12 @@ static inline void z8530_isr(struct scc_
 		}
 		write_scc(&info->priv[0], R0, RES_H_IUS);
--
 		while ((is = ~inb(card_base + TWIN_INT_REG)) &
 		       TWIN_INT_MSK) {
 			if (is & TWIN_SCC_MSK) {
@@ -1153,6 +1191,12 @@ static irqreturn_t scc_isr(int irq, void
 				inb(card_base + TWIN_CLR_TMR2);
 				tm_isr(&info->priv[1]);
--
-		while (read_scc(priv, R0) & Rx_CH_AV) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (read_scc(priv, R0) & Rx_CH_AV) {
 			rc = read_scc(priv, R1);
 			if (priv->rx_ptr < BUF_SIZE)
 				priv->rx_buf[priv->rx_head][priv->
@@ -1182,6 +1231,12 @@ static void rx_isr(struct scc_priv *priv
 				read_scc_data(priv);
--
 	while (priv->rx_count) {
 		spin_unlock_irqrestore(&priv->ring_lock, flags);
 		cb = priv->rx_len[i];
@@ -1285,6 +1345,12 @@ static void rx_bh(struct work_struct *ug
 		/* Move tail */
 		priv->rx_tail = i = (i + 1) % NUM_RX_BUF;
--
 	while ((read_scc(priv, R0) & Tx_BUF_EMP) && p < priv->tx_len[i]) {
 		write_scc_data(priv, priv->tx_buf[i][p++], 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (!list_empty(&bpq_devices)) {
 		bpq = list_entry(bpq_devices.next, struct bpqdev, bpq_list);
 		bpq_free_device(bpq->axdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (s->hdlcrx.rx_state && num >= 8) {
 		if (s->hdlcrx.len >= sizeof(s->hdlcrx.buffer)) {
 			s->hdlcrx.rx_state = 0;
@@ -137,6 +142,12 @@ static int hdlc_rx_add_bytes(struct hdlc
 		s->hdlcrx.len++;
 		num -= 8;
--
-	while (!hdlcdrv_hbuf_empty(&s->hdlcrx.hbuf)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (!hdlcdrv_hbuf_empty(&s->hdlcrx.hbuf)) {
 		word = hdlcdrv_hbuf_get(&s->hdlcrx.hbuf);	
 
 #ifdef HDLCDRV_DEBUG
@@ -215,6 +231,12 @@ void hdlcdrv_receiver(struct net_device
 		}
--
 	while (p) {
 		if (p->bitrate == bitrate) {
 			memcpy(p->bits, bits, YAM_FPGA_SIZE);
 			goto out;
 		}
 		p = p->next;
--
 	while (p) {
 		if (p->bitrate == bitrate)
 			return p->bits;
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((iir = IIR_MASK & inb(IIR(dev->base_addr))) != IIR_NOPEND) {
 			unsigned char msr = inb(MSR(dev->base_addr));
 			unsigned char lsr = inb(LSR(dev->base_addr));
@@ -784,6 +811,12 @@ static irqreturn_t yam_interrupt(int irq
 				else
 					yam_rx_byte(dev, yp, rxb);
--
 	while (--i >= 0) {
 		unregister_netdev(yam_devs[i]);
 		free_netdev(yam_devs[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (yam_data) {
 		p = yam_data;
 		yam_data = yam_data->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len-- > 0) {
 		switch (c = *s++) {
 		case END:
@@ -195,6 +200,12 @@ static int kiss_esc(unsigned char *s, un
 			*ptr++ = c;
 			break;
--
 	while (len > 0) {
 		if (len > 2)
 			c = *s++;
@@ -237,6 +253,12 @@ static int kiss_esc_crc(unsigned char *s
 			*ptr++ = c;
 			break;
--
 	while (count--) {
 		if (fp != NULL && *fp++) {
 			if (!test_and_set_bit(AXF_ERROR, &ax->flags))
@@ -948,6 +975,12 @@ static void mkiss_receive_buf(struct tty
 		}
 
--
 	while (pkt_len > -2) {
 		bitstream >>= 8;
 		bitstream |= ((unsigned int)*bp) << 8;
@@ -407,18 +412,46 @@ static void encode_hdlc(struct baycom_st
 				notbitstream = ~bitstream;
 			}
--
 		while (numbit >= 8) {
 			*wp++ = bitbuf;
 			bitbuf >>= 8;
 			numbit -= 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (numbit >= 8) {
 		*wp++ = bitbuf;
 		bitbuf >>= 8;
 		numbit -= 8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (cnt > 0) {
 		switch (bc->hdlctx.state) {
 		case tx_keyup:
@@ -467,11 +505,22 @@ static int transmit(struct baycom_state
 			if (bc->hdlctx.flags <= 0)
 				bc->hdlctx.state = tx_data;
--
 			while (i > 0) {
 				j = (i > sizeof(tmp)) ? sizeof(tmp) : i;
 				if (j != pp->ops->epp_write_data(pp, tmp, j, 0))
 					return -1;
 				i -= j;
+				if (_cur < timeout) {
--
 				while (i > 0) {
 					j = (i > sizeof(tmp)) ? sizeof(tmp) : i;
 					if (j != pp->ops->epp_write_data(pp, tmp, j, 0))
 						return -1;
 					i -= j;
+					if (_cur < timeout) {
--
 			while (i > 0) {
 				j = (i > sizeof(tmp)) ? sizeof(tmp) : i;
 				if (j != pp->ops->epp_write_data(pp, tmp, j, 0))
 					return -1;
 				i -= j;
+				if (_cur < timeout) {
--
 			while (state && numbits >= 8) {
 				if (bc->hdlcrx.bufcnt >= TXBUFFER_SIZE) {
 					state = 0;
@@ -621,6 +703,12 @@ static int receive(struct net_device *de
 					bc->hdlcrx.bufcnt++;
 					numbits -= 8;
--
-		while ((stat & (EPP_NRAEF|EPP_NRHF)) != EPP_NRHF) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((stat & (EPP_NRAEF|EPP_NRHF)) != EPP_NRHF) {
 			switch (stat & (EPP_NRAEF|EPP_NRHF)) {
 			case EPP_NRAEF:
 				cnt = 1025;
@@ -736,18 +829,35 @@ static void epp_bh(struct work_struct *w
 				goto epptimeout;
--
 		while (cnt > 0 && stat & EPP_NREF) {
 			if (receive(dev, 1))
 				goto epptimeout;
 			cnt--;
 			if (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)
 				goto epptimeout;
--
 	while (time_before(jiffies, tstart + HZ/3)) {
 		if (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)
 			goto epptimeout;
@@ -891,6 +1006,12 @@ static int epp_open(struct net_device *d
 		if (pp->ops->epp_read_data(pp, tmp, 128, 0) != 128)
 			goto epptimeout;
--
 	while (j < 7 && i > 150) {
 		j++;
 		i >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (size > 3) {
 		u32 val;
 		rio_read_config_32(dev, off, &val);
@@ -150,6 +155,12 @@ rio_read_config(struct file *filp, struc
 		data[off - init_off + 3] = val & 0xff;
 		off += 4;
--
 	while (size > 3) {
 		u32 val = data[off - init_off + 3];
 		val |= (u32) data[off - init_off + 2] << 8;
@@ -212,6 +228,12 @@ rio_write_config(struct file *filp, stru
 		rio_write_config_32(dev, off, val);
 		off += 4;
--
-		while (sendcount) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (sendcount) {
 			rio_write_config_32(rdev,
 					  TSI578_SP_CS_TX(portnum), 0x40fc8000);
 			checkcount = 3;
-			while (checkcount--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (checkcount--) {
 				udelay(50);
 				rio_read_config_32(rdev,
 					rdev->phys_efptr +
@@ -263,9 +273,21 @@ tsi57x_em_handler(struct rio_dev *rdev,
 					&regval);
--
-	while (result != port->host_deviceid) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (result != port->host_deviceid) {
 		if (wait_ms != 0 && tcnt == wait_ms) {
 			pr_debug("RIO: timeout when locking device %x:%x\n",
 				destid, hopcount);
@@ -605,6 +610,12 @@ rio_lock_device(struct rio_mport *port,
 		rio_mport_read_config_32(port, destid,
--
 	while ((tmp = rio_get_host_deviceid_lock(port, hopcount))
 	       < port->host_deviceid) {
 		/* Delay a bit */
@@ -797,6 +813,12 @@ static int __devinit rio_enum_peer(struc
 					  hopcount,
 					  RIO_HOST_DID_LOCK_CSR,
--
 		while (!rio_enum_complete(mport)) {
 			mdelay(1);
 			if (enum_timeout_flag) {
 				del_timer_sync(&rio_enum_timer);
 				goto timeout;
 			}
--
 	while (id->vid || id->asm_vid) {
 		if (((id->vid == RIO_ANY_ID) || (id->vid == rdev->vid)) &&
 		    ((id->did == RIO_ANY_ID) || (id->did == rdev->did)) &&
@@ -39,6 +44,12 @@ static const struct rio_device_id *rio_m
 			|| (id->asm_did == rdev->asm_did)))
 			return id;
--
-	while (ext_ftr_ptr)  {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ext_ftr_ptr)  {
 		if (local)
 			rio_local_read_config_32(port, ext_ftr_ptr,
 						 &ftr_header);
@@ -441,6 +446,12 @@ rio_mport_get_physefb(struct rio_mport *
 
--
 	while (n && (n != &rio_devices)) {
 		rdev = rio_dev_g(n);
 		if (rdev->comp_tag == comp_tag)
 			goto exit;
 		n = n->next;
+		if (_cur < timeout) {
--
-	while (rio_mport_read_config_32(mport, destid, hopcount,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rio_mport_read_config_32(mport, destid, hopcount,
 					RIO_DEV_ID_CAR, &tmp)) {
 		i++;
 		if (i == RIO_MAX_CHK_RETRY)
 			return -EIO;
 		mdelay(1);
--
-	while (checkcount--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (checkcount--) {
 		udelay(50);
 		rio_read_config_32(rdev,
 			rdev->phys_efptr + RIO_PORT_N_MNT_RSP_CSR(pnum),
@@ -618,6 +656,12 @@ rio_get_input_status(struct rio_dev *rde
 			*lnkresp = regval;
--
 	while (n && (n != &rio_devices)) {
 		rdev = rio_dev_g(n);
 		if ((vid == RIO_ANY_ID || rdev->vid == vid) &&
@@ -989,6 +1038,12 @@ struct rio_dev *rio_get_asm(u16 vid, u16
 		    (asm_did == RIO_ANY_ID || rdev->asm_did == asm_did))
 			goto exit;
--
 	while ((dev = rio_get_device(RIO_ANY_ID, RIO_ANY_ID, dev)) != NULL) {
 		rio_fixup_device(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while ((ch_stat = ioread32(priv->regs +
 		TSI721_DMAC_STS(TSI721_DMACH_MAINT))) & TSI721_DMAC_STS_RUN) {
 		udelay(1);
@@ -152,6 +157,12 @@ static int tsi721_maint_dma(struct tsi72
 			err = -EIO;
 			goto err_out;
--
-	while (kfifo_out_spinlocked(&priv->pw_fifo, (unsigned char *)msg_buffer,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (kfifo_out_spinlocked(&priv->pw_fifo, (unsigned char *)msg_buffer,
 			 TSI721_RIO_PW_MSG_SIZE, &priv->pw_fifo_lock)) {
 		/* Process one message */
 #ifdef DEBUG_PW
@@ -311,6 +327,12 @@ static void tsi721_pw_dpc(struct work_st
 #endif
--
-	while (wr_ptr != rd_ptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (wr_ptr != rd_ptr) {
 		idb_entry = (u64 *)(priv->idb_base +
 					(TSI721_IDB_ENTRY_SIZE * rd_ptr));
 		rd_ptr++;
@@ -442,6 +469,12 @@ static void tsi721_db_dpc(struct work_st
 
--
 		while (sts_ptr[j]) {
 			for (i = 0; i < 8 && sts_ptr[j]; i++, j++) {
 				prev_ptr = last_ptr;
@@ -1268,6 +1306,12 @@ static void tsi721_omsg_handler(struct t
 			++srd_ptr;
 			srd_ptr %= priv->omsg_ring[ch].sts_size;
--
 	while (priv->imsg_ring[mbox].imq_base[rx_slot] == NULL) {
 		if (++rx_slot == priv->imsg_ring[mbox].size)
 			rx_slot = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (maxspin) {
 		if ((msmsdcc_readl(host, MMCISTATUS) & mask))
 			return 0;
 		udelay(1);
 		--maxspin;
+		if (_cur < timeout) {
--
 		while (!(at91_mci_read(host, AT91_MCI_SR) & AT91_MCI_CMDRDY)) {
 			/* spin */
 			pr_debug("Clearing: SR = %08X\n", at91_mci_read(host, AT91_MCI_SR));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((fifo = fifo_count(host))) {
 		if (!host->pio_bytes) {
 			res = get_data_buffer(host, &host->pio_bytes,
@@ -416,11 +421,28 @@ static void do_pio_read(struct s3cmci_ho
 			u32 data = readl(from_ptr);
 			u8 *p = (u8 *)host->pio_ptr;
--
 			while (n--) {
 				*p++ = data;
 				data >>= 8;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
--
 	while ((fifo = fifo_free(host)) > 3) {
 		if (!host->pio_bytes) {
 			res = get_data_buffer(host, &host->pio_bytes,
@@ -483,6 +510,12 @@ static void do_pio_write(struct s3cmci_h
 		while (fifo--)
 			writel(*ptr++, to_ptr);
 		host->pio_ptr = ptr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (readl(host->base + S3C2410_SDIDSTA) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (readl(host->base + S3C2410_SDIDSTA) &
 	       (S3C2410_SDIDSTA_TXDATAON | S3C2410_SDIDSTA_RXDATAON)) {
 
 		dbg(host, dbg_err,
@@ -1001,6 +1039,12 @@ static int s3cmci_setup_data(struct s3cm
 			dbg_dumpregs(host, "DRF");
--
 	while (host->mmc != NULL) {
 		spin_unlock_irqrestore(&host->slot_lock, flags);
 		wait_event(host->slot_wq, host->mmc == NULL);
 		spin_lock_irqsave(&host->slot_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (restarts < maxloops) {
 		OMAP_MMC_WRITE(host, STAT, 0xFFFF);
 		OMAP_MMC_WRITE(host, CMD, (3 << 12) | (1 << 7));
 
 		passes = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (passes < timeout) {
 			stat = OMAP_MMC_READ(host, STAT);
 			if (stat & OMAP_MMC_STAT_END_OF_CMD)
 				goto out;
 			udelay(1);
 			passes++;
--
-	while ((status = OMAP_MMC_READ(host, STAT)) != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while ((status = OMAP_MMC_READ(host, STAT)) != 0) {
 		int cmd;
 
 		OMAP_MMC_WRITE(host, STAT, status);
@@ -821,6 +859,12 @@ static irqreturn_t mmc_omap_irq(int irq,
 		    (!(status & OMAP_MMC_STAT_A_EMPTY))) {
--
 		while (usecs > 0 && (OMAP_MMC_READ(host, STAT) & 1) == 0) {
 			udelay(1);
 			usecs--;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 			while (--i >= 0) {
 				slot = host->slots[i];
 				mmc_resume_host(slot->mmc);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 		while (len) {
 			data = sdricoh_readl(host, R230_DATA);
 			size = min(len, 4);
 			len -= size;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
--
 			while (size) {
 				*buf = data & 0xFF;
 				buf++;
 				data >>= 8;
 				size--;
+				if (_cur < timeout) {
--
 		while (len) {
 			size = min(len, 4);
 			len -= size;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
--
 			while (size) {
 				data >>= 8;
 				data |= (u32)*buf << 24;
 				buf++;
 				size--;
+				if (_cur < timeout) {
--
-	while ((pci_dev =
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((pci_dev =
 		pci_get_device(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C476,
 			       pci_dev))) {
 		/* try to init the device */
@@ -490,6 +539,12 @@ static int sdricoh_pcmcia_probe(struct p
 			return 0;
--
 		while (s >= 32 && (intr_status & MVSD_NOR_RX_FIFO_8W)) {
 			readsw(iobase + MVSD_FIFO, p, 16);
 			p += 16;
 			s -= 32;
 			intr_status = mvsd_read(MVSD_NOR_INTR_STATUS);
+			if (_cur < timeout) {
--
 			while (s >= 4 && (intr_status & MVSD_NOR_RX_READY)) {
 				put_unaligned(mvsd_read(MVSD_FIFO), p++);
 				put_unaligned(mvsd_read(MVSD_FIFO), p++);
 				s -= 4;
 				intr_status = mvsd_read(MVSD_NOR_INTR_STATUS);
+				if (_cur < timeout) {
--
 		while (s >= 4 && (intr_status & MVSD_NOR_TX_AVAIL)) {
 			mvsd_write(MVSD_FIFO, get_unaligned(p++));
 			mvsd_write(MVSD_FIFO, get_unaligned(p++));
 			s -= 4;
 			intr_status = mvsd_read(MVSD_NOR_INTR_STATUS);
+			if (_cur < timeout) {
--
 	while (i--) {
 		irq = platform_get_irq(pdev, i);
 		free_irq(irq, host);
-	}
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (0 < regs-- && 1 == vub300->sdio_register[i].activate) {
 		if (vub300->sdio_register[i].func_num == func &&
 		    vub300->sdio_register[i].sdio_reg == Register) {
@@ -563,6 +568,12 @@ static void add_offloaded_reg(struct vub
 			i += 1;
 			continue;
--
 		while (register_count--) {
 			add_offloaded_reg(vub300, &vub300->resp.irq.reg[ri]);
 			ri += 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (register_count--) {
 			add_offloaded_reg(vub300, &vub300->resp.irq.reg[ri]);
 			ri += 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (I--) {
 			unsigned int func_num = 0;
 			vub300->sdio_register[i].func_num = *data++;
@@ -1341,6 +1379,12 @@ static void __download_offload_pseudocod
 			vub300->sdio_register[i].activate = 1;
 			vub300->sdio_register[i].prepared = 0;
--
 		while (register_count--) {
 			add_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);
 			ri += 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (register_count--) {
 			add_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);
 			ri += 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (register_count--) {
 			add_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);
 			ri += 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (words-- > 0) {
 		cmd->resp[words] = (r[1 + (words << 2)] << 24)
 			| (r[2 + (words << 2)] << 16)
 			| (r[3 + (words << 2)] << 8)
 			| (r[4 + (words << 2)] << 0);
+			if (_cur < timeout) {
--
-		while (0 < register_count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (0 < register_count) {
 			int point = MAXREGMASK & register_point;
 			struct offload_registers_access *r =
 				&vub300->fn[Function].reg[point];
@@ -1852,6 +1945,12 @@ static int examine_cyclic_buffer(struct
 				delta += 1;
--
 	while (0 < regs--) {
 		if ((vub300->sdio_register[i].func_num == func) &&
 		    (vub300->sdio_register[i].sdio_reg == reg)) {
@@ -1895,6 +1999,12 @@ static int satisfy_request_from_offloade
 			i += 1;
 			continue;
--
 	while (blocks-- > 0) {
 		len = data->blksz;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (len >= 16) {
 			err = cb710_mmc_receive_pio(slot, &miter, 4);
 			if (err)
 				goto out;
 			len -= 16;
+			if (_cur < timeout) {
--
 	while (blocks-- > 0) {
 		len = (data->blksz + 15) >> 4;
 		do {
@@ -336,6 +363,12 @@ static int cb710_mmc_send(struct cb710_s
 			cb710_sg_dwiter_read_to_io(&miter,
 				slot->iobase + CB710_MMC_DATA_PORT, 4);
 		} while (--len);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 			while (--i >= 0) {
 				slot = host->slot[i];
 				if (slot
@@ -2217,6 +2222,12 @@ static int atmci_suspend(struct device *
 					mmc_resume_host(host->slot[i]->mmc);
 					clear_bit(ATMCI_SUSPENDED, &slot->flags);
--
 		while (rotator & 0x8000) {
 			bitshift++;
 			rotator <<= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (status & 0x80) {
 		status <<= 1;
 		bitshift--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (bytes > 3) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bytes > 3) {
 		stat = mxcmci_poll_status(host,
 				STATUS_BUF_READ_RDY | STATUS_READ_OP_DONE);
 		if (stat)
 			return stat;
 		*buf++ = readl(host->base + MMC_REG_BUFFER_ACCESS);
--
 	while (bytes > 3) {
 		stat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);
 		if (stat)
 			return stat;
 		writel(*buf++, host->base + MMC_REG_BUFFER_ACCESS);
 		bytes -= 4;
--
 		while ((timeout & 0x80000000) == 0) {
 			dto += 1;
 			timeout <<= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (time_before(jiffies, timeout)) {
 		cmd_status = mci_readl(host, CMD);
 		if (!(cmd_status & SDMMC_CMD_START))
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (cnt >= 2) {
 			u16 aligned_buf[64];
 			int len = min(cnt & -2, (int)sizeof(aligned_buf));
@@ -1069,6 +1085,12 @@ static void dw_mci_push_data16(struct dw
 			for (i = 0; i < items; ++i)
 				mci_writew(host, DATA(host->data_offset),
--
 		while (cnt >= 2) {
 			/* pull data from fifo into aligned buffer */
 			u16 aligned_buf[64];
@@ -1104,6 +1131,12 @@ static void dw_mci_pull_data16(struct dw
 			memcpy(buf, aligned_buf, len);
 			buf += len;
--
 		while (cnt >= 4) {
 			u32 aligned_buf[32];
 			int len = min(cnt & -4, (int)sizeof(aligned_buf));
@@ -1147,6 +1185,12 @@ static void dw_mci_push_data32(struct dw
 			for (i = 0; i < items; ++i)
 				mci_writel(host, DATA(host->data_offset),
--
 		while (cnt >= 4) {
 			/* pull data from fifo into aligned buffer */
 			u32 aligned_buf[32];
@@ -1182,6 +1231,12 @@ static void dw_mci_pull_data32(struct dw
 			memcpy(buf, aligned_buf, len);
 			buf += len;
--
 		while (cnt >= 8) {
 			u64 aligned_buf[16];
 			int len = min(cnt & -8, (int)sizeof(aligned_buf));
@@ -1225,6 +1285,12 @@ static void dw_mci_push_data64(struct dw
 			for (i = 0; i < items; ++i)
 				mci_writeq(host, DATA(host->data_offset),
--
 		while (cnt >= 8) {
 			/* pull data from fifo into aligned buffer */
 			u64 aligned_buf[16];
@@ -1260,6 +1331,12 @@ static void dw_mci_pull_data64(struct dw
 			memcpy(buf, aligned_buf, len);
 			buf += len;
--
-		while (present != slot->last_detect_state) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (present != slot->last_detect_state) {
 			dev_dbg(&slot->mmc->class_dev, "card %s\n",
 				present ? "inserted" : "removed");
 
@@ -1645,6 +1727,12 @@ static void dw_mci_work_routine_card(str
 				host->pdata->setpower(slot->id, 0);
--
 	while (i > 0) {
 		if (host->slot[i])
 			dw_mci_cleanup_slot(host->slot[i], i);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (--i >= 0) {
 				slot = host->slot[i];
 				if (slot)
 					mmc_resume_host(host->slot[i]->mmc);
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_EMPTY)) {
 		/*
 		 * The size field in the FSR is broken so we have to
@@ -465,6 +470,12 @@ static void wbsd_empty_fifo(struct wbsd_
 				buffer = wbsd_sg_to_buffer(host);
 			}
--
 	while (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_FULL)) {
 		/*
 		 * The size field in the FSR is broken so we have to
@@ -528,6 +544,12 @@ static void wbsd_fill_fifo(struct wbsd_h
 				buffer = wbsd_sg_to_buffer(host);
 			}
--
 	while (host->max_clk / div > clock) {
 		/*
 		 * On CNS3xxx divider grows linearly up to 4, and then
@@ -50,6 +55,12 @@ static void sdhci_cns3xxx_set_clock(stru
 			div *= 2;
 		else
--
-	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
 		if (timeout == 0) {
 			pr_err("%s: Reset 0x%x never completed.\n",
 				mmc_hostname(host->mmc), (int)mask);
@@ -207,6 +212,12 @@ static void sdhci_reset(struct sdhci_hos
 		}
--
 	while (blksize) {
 		if (!sg_miter_next(&host->sg_miter))
 			BUG();
@@ -314,6 +330,11 @@ static void sdhci_read_block_pio(struct
 
 		buf = host->sg_miter.addr;
--
 		while (len) {
 			if (chunk == 0) {
 				scratch = sdhci_readl(host, SDHCI_BUFFER);
@@ -326,6 +347,18 @@ static void sdhci_read_block_pio(struct
 			scratch >>= 8;
 			chunk--;
--
 	while (blksize) {
 		if (!sg_miter_next(&host->sg_miter))
 			BUG();
@@ -360,6 +398,11 @@ static void sdhci_write_block_pio(struct
 
 		buf = host->sg_miter.addr;
--
 		while (len) {
 			scratch |= (u32)*buf << (chunk * 8);
 
@@ -372,6 +415,18 @@ static void sdhci_write_block_pio(struct
 				chunk = 0;
 				scratch = 0;
--
-	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
 		if (timeout == 0) {
 			pr_err("%s: Controller never released "
 				"inhibit bit(s).\n", mmc_hostname(host->mmc));
@@ -981,6 +1041,12 @@ static void sdhci_send_command(struct sd
 		}
--
-	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
 		& SDHCI_CLOCK_INT_STABLE)) {
 		if (timeout == 0) {
 			pr_err("%s: Internal clock never "
@@ -1151,6 +1222,12 @@ static void sdhci_set_clock(struct sdhci
 		}
--
 	while (t_size) {
 		cnt = sg[host->sg_pos].length - host->block_pos;
 		if (!cnt) {
@@ -205,6 +210,12 @@ static void tifm_sd_transfer_data(struct
 
 		t_size -= p_cnt;
--
 	while (t_size) {
 		cnt = sg[host->sg_pos].length - host->block_pos;
 		if (!cnt) {
@@ -257,6 +273,12 @@ static void tifm_sd_bounce_block(struct
 
 		t_size -= p_cnt;
--
 	while (i < 0x1000) {
 		if (!(i & 0x7f)) {
 			reg = readw(host->base + MMC_REG_STR_STP_CLK);
@@ -119,6 +124,12 @@ static void imxmci_stop_clock(struct imx
 		}
 
--
 		while (delay--) {
 			reg = readw(host->base + MMC_REG_STATUS);
 			if (reg & STATUS_CARD_BUS_CLK_RUN) {
@@ -157,6 +173,12 @@ static int imxmci_start_clock(struct imx
 
 			if (test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events))
--
-	while (!(*pstat & stat_mask)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(*pstat & stat_mask)) {
 		loops += 2;
 		if (loops >= timeout) {
 			dev_dbg(mmc_dev(host->mmc), "busy wait timeout in %s, STATUS = 0x%x (0x%x)\n",
@@ -211,6 +238,12 @@ static int imxmci_busy_wait_for_status(s
 		}
--
 		while ((stat & (STATUS_APPL_BUFF_FF | STATUS_DATA_TRANS_DONE)) &&
 		       !(stat & STATUS_TIME_OUT_READ) &&
 		       (host->data_cnt < 512)) {
@@ -583,6 +621,12 @@ static int imxmci_cpu_driven_data(struct
 
 			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data read %d burst %d STATUS = 0x%x\n",
--
 		while ((stat & STATUS_APPL_BUFF_FE) &&
 		       (host->data_cnt < host->dma_size)) {
 			if (burst_len >= host->dma_size - host->data_cnt) {
@@ -619,6 +668,12 @@ static int imxmci_cpu_driven_data(struct
 
 			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data write burst %d STATUS = 0x%x\n",
--
 	while (sg_miter_next(miter)) {
 		buf = miter->addr;
 		i = miter->length / 4;
 		j = i / 8;
 		i = i & 0x7;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (j) {
 			timeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_TXFIFO_WR_REQ);
 			if (unlikely(timeout))
@@ -263,19 +273,42 @@ static bool jz4740_mmc_write_data(struct
 			writel(buf[7], fifo_addr);
 			buf += 8;
--
 			while (i) {
 				writel(*buf, fifo_addr);
 				++buf;
 				--i;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (sg_miter_next(miter)) {
 		buf = miter->addr;
 		i = miter->length;
 		j = i / 32;
 		i = i & 0x1f;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (j) {
 			timeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_RXFIFO_RD_REQ);
 			if (unlikely(timeout))
@@ -321,6 +364,12 @@ static bool jz4740_mmc_read_data(struct
 
 			buf += 8;
--
 			while (i >= 4) {
 				*buf++ = readl(fifo_addr);
 				i -= 4;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (!(status & JZ_MMC_STATUS_DATA_FIFO_EMPTY) && --timeout) {
 		d = readl(fifo_addr);
 		status = readl(host->base + JZ_REG_MMC_STATUS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (real_rate > rate && div < 7) {
 		++div;
 		real_rate >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (remainder > func->cur_blksize) {
 			unsigned blocks;
 
@@ -332,11 +337,22 @@ static int sdio_io_rw_ext_helper(struct
 			buf += size;
 			if (incr_addr)
--
-	while (remainder > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (remainder > 0) {
 		size = min(remainder, sdio_max_byte_size(func));
 
 		ret = mmc_io_rw_extended(func->card, write, func->num, addr,
@@ -348,6 +364,12 @@ static int sdio_io_rw_ext_helper(struct
 		buf += size;
--
 	while (tuple) {
 		victim = tuple;
 		tuple = tuple->next;
 		kfree(victim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (tuple && tuple != func->card->tuples) {
 		victim = tuple;
 		tuple = tuple->next;
 		kfree(victim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (ids->class || ids->vendor || ids->device) {
 			if (sdio_match_one(func, ids))
 				return ids;
 			ids++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (err && --i >= 0) {
 		struct sdio_func *func = host->card->sdio_func[i];
 		if (func && sdio_func_present(func) && func->dev.driver) {
 			const struct dev_pm_ops *pmops = func->dev.driver->pm;
 			pmops->resume(&func->dev);
 		}
--
 		while ((req = blk_fetch_request(q)) != NULL) {
 			req->cmd_flags |= REQ_QUIET;
 			__blk_end_request_all(req, -EIO);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (sz) {
 		base = page_address(mem->arr[--i].page);
 		cnt = 1 << mem->arr[i].order;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (sz && cnt) {
 			addr = base + PAGE_SIZE * --cnt;
 			if (last_addr && last_addr + PAGE_SIZE == addr)
@@ -477,9 +487,21 @@ static int mmc_test_map_sg_max_scatter(s
 			sg_set_page(sg, virt_to_page(addr), len, 0);
 			sz -= len;
--
 	while (ns > UINT_MAX) {
 		bytes >>= 1;
 		ns >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
     while (part->FreeTotal < nblocks) {
 	ret = reclaim_block(part);
 	if (ret)
 	    return ret;
+	    if (_cur < timeout) {
+	    rdstcll(_cur);
--
 	while (nr_sects) {
 		uint32_t old_addr = part->VirtualBlockMap[sector];
 		if (old_addr != 0xffffffff) {
@@ -1024,6 +1040,12 @@ static int ftl_discardsect(struct mtd_bl
 		}
 		nr_sects--;
--
 	while (!kthread_should_stop()) {
 		int res;
 
@@ -179,6 +184,12 @@ static int mtd_blktrans_thread(void *arg
 			req = NULL;
 
--
 	while (*size > min_alloc) {
 		kbuf = kmalloc(*size, flags);
 		if (kbuf)
@@ -750,6 +755,12 @@ void *mtd_kmalloc_up_to(const struct mtd
 
 		*size >>= 1;
--
 	while (thisEUN <= nftl->lastEUN ) {
 		unsigned int status, foldmark;
 
@@ -340,6 +345,12 @@ static u16 NFTL_foldchain (struct NFTLre
 		}
 
--
 	while (thisEUN <= nftl->lastEUN && thisEUN != targetEUN) {
 		unsigned int EUNtmp;
 
@@ -473,6 +489,12 @@ static u16 NFTL_foldchain (struct NFTLre
 			nftl->numfreeEUNs++;
 		}
--
 		while (writeEUN <= nftl->lastEUN) {
 			struct nftl_bci bci;
 			size_t retlen;
@@ -593,6 +620,12 @@ static inline u16 NFTL_findwriteunit(str
 
 			/* Skip to next block in chain */
--
-		while (thisEUN < nftl->nb_blocks) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while (thisEUN < nftl->nb_blocks) {
 			if (nftl_read_oob(mtd, (thisEUN * nftl->EraseSize) +
 					  blockofs, 8, &retlen,
 					  (char *)&bci) < 0)
@@ -761,6 +799,12 @@ static int nftl_readblock(struct mtd_blk
 				return 1;
--
 	while (count) {
 		len = min_t(size_t, count, size);
 
@@ -261,6 +266,12 @@ static ssize_t mtd_read(struct file *fil
 			return ret;
 		}
--
 	while (count) {
 		len = min_t(size_t, count, size);
 
@@ -341,6 +357,12 @@ static ssize_t mtd_write(struct file *fi
 			kfree(kbuf);
 			return ret;
--
 		while (header.length) {
 			offset += sizeof(header) + header.length;
 			master->read(master, offset, sizeof(header),
 				     &len, (uint8_t *)&header);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (header.length) {
 			offset += sizeof(header) + header.length;
 			master->read(master, offset, sizeof(header),
 				     &len, (uint8_t *)&header);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (thisEUN < inftl->nb_blocks) {
 		for (block = 0; block < inftl->EraseSize/SECTORSIZE; block ++) {
 			if ((BlockMap[block] != BLOCK_NIL) ||
@@ -314,6 +319,12 @@ static u16 INFTL_foldchain(struct INFTLr
 		}
 
--
 		while (inftl->PUtable[thisEUN] != BLOCK_NIL) {
 			prevEUN = thisEUN;
 			thisEUN = inftl->PUtable[thisEUN];
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while (thisEUN < inftl->nb_blocks) {
 		for (block = 0; block < inftl->EraseSize/SECTORSIZE; block++) {
 			if (BlockUsed[block] || BlockDeleted[block])
@@ -696,6 +723,12 @@ static void INFTL_trydeletechain(struct
 		}
 
--
 		while (inftl->PUtable[thisEUN] != BLOCK_NIL) {
 			BUG_ON(thisEUN >= inftl->nb_blocks);
 
 			prevEUN = &inftl->PUtable[thisEUN];
 			thisEUN = *prevEUN;
+			if (_cur < timeout) {
--
-	while (thisEUN < inftl->nb_blocks) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (thisEUN < inftl->nb_blocks) {
 		if (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +
 				   blockofs, 8, &retlen, (char *)&bci) < 0)
 			status = SECTOR_IGNORE;
@@ -795,7 +844,13 @@ static int INFTL_deleteblock(struct INFT
 			return 1;
--
-	while (thisEUN < inftl->nb_blocks) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (thisEUN < inftl->nb_blocks) {
 		if (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +
 				  blockofs, 8, &retlen, (char *)&bci) < 0)
 			status = SECTOR_IGNORE;
@@ -905,7 +965,13 @@ static int inftl_readblock(struct mtd_bl
 		}
--
 	while (len_left > 0) {
 		if (len_left > DMA_MAX_LEN) {
 			tmp_len = DMA_MAX_LEN;
@@ -177,6 +182,12 @@ static void nand_dma_read(void *buf, int
 		wait_for_completion(&nand_comp);
 
--
 	while (len_left > 0) {
 		if (len_left > DMA_MAX_LEN) {
 			tmp_len = DMA_MAX_LEN;
@@ -227,6 +243,12 @@ static void nand_dma_write(const void *b
 		wait_for_completion(&nand_comp);
 
--
 		while ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&
 			(data_setup_in_cycles < nfc->max_data_setup_cycles)) {
 
@@ -450,6 +455,12 @@ static int gpmi_nfc_compute_hardware_tim
 			if (ideal_sample_delay_in_ns < 0)
 				ideal_sample_delay_in_ns = 0;
--
-	while ((tEYE <= 0) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((tEYE <= 0) &&
 			(data_setup_in_cycles < nfc->max_data_setup_cycles)) {
 		/* Give a cycle to data setup. */
 		data_setup_in_cycles++;
@@ -520,6 +536,12 @@ static int gpmi_nfc_compute_hardware_tim
 		data_setup_in_ns += clock_period_in_ns;
--
-	while ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&
 			(data_setup_in_cycles < nfc->max_data_setup_cycles)) {
 
 		/* Give a cycle to data setup. */
@@ -602,6 +629,12 @@ static int gpmi_nfc_compute_hardware_tim
 		/* Jam a negative ideal sample delay to zero. */
--
-	while (SAMPLE_IS_NOT_WITHIN_THE_EYE &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (SAMPLE_IS_NOT_WITHIN_THE_EYE &&
 			(data_setup_in_cycles < nfc->max_data_setup_cycles)) {
 		/*
 		 * If control arrives here, the quantized sample delay falls
@@ -696,6 +734,12 @@ static int gpmi_nfc_compute_hardware_tim
 
--
 	while (len) {
 		reg = buf[0] | buf[1] << 8 | buf[2] << 16 | buf[3] << 24;
 		r852_write_reg_dword(dev, R852_DATALINE, reg);
 		buf += 4;
 		len -= 4;
 
--
 	while (len >= 4) {
 
 		reg = r852_read_reg_dword(dev, R852_DATALINE);
@@ -288,6 +304,12 @@ void r852_read_buf(struct mtd_info *mtd,
 		*buf++ = (reg >> 16) & 0xFF;
 		*buf++ = (reg >> 24) & 0xFF;
--
 	while (len) {
 		u8 oob[16];
 		size_t byte = from & al->bytemask;
@@ -411,6 +416,12 @@ static int alauda_bounce_read(struct mtd
 		buf += cplen;
 		from += cplen;
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		u8 oob[16];
 
 		err = alauda_read_page(mtd, from, buf, oob,
@@ -443,6 +459,12 @@ static int alauda_read(struct mtd_info *
 		buf += mtd->writesize;
--
 	while (len) {
 		u32 page = (to >> al->card->pageshift) & al->pagemask;
 		u8 oob[16] = {	'h', 'e', 'l', 'l', 'o', 0xff, 0xff, 0xff,
@@ -484,6 +511,12 @@ static int alauda_write(struct mtd_info
 		buf += mtd->writesize;
 		to += mtd->writesize;
--
 	while (len) {
 		/* don't erase bad blocks */
 		err = alauda_isbad(mtd, ofs);
@@ -512,6 +550,12 @@ static int __alauda_erase(struct mtd_inf
 
 		ofs += mtd->erasesize;
--
 	while (len && (unsigned long)buf & 7) {
 		*buf++ = readb(io_base);
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (i < len/8) {
 		/*
 		 * Since GCC has no proper constraint (PR 43518)
@@ -65,6 +81,12 @@ static void orion_nand_read_buf(struct m
 
 		asm volatile ("ldrd\t%0, [%1]" : "=&r" (x) : "r" (io_base));
--
 	while (i < len)
diff -u -p a/mtd/nand/nand_base.c b/mtd/nand/nand_base.c
--- a/mtd/nand/nand_base.c
+++ b/mtd/nand/nand_base.c
@@ -1721,11 +1721,22 @@ static int nand_write_oob_syndrome(struc
 				uint32_t fill = 0xFFFFFFFF;
--
-				while (len > 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while (len > 0) {
 					int num = min_t(int, len, 4);
 					chip->write_buf(mtd, (uint8_t *)&fill,
 							num);
 					len -= num;
+					if (_cur < timeout) {
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (len) {
 		/* Heck if we have a bad block, we do not erase bad blocks! */
 		if (nand_block_checkbad(mtd, ((loff_t) page) <<
 					chip->page_shift, 0, allowbbt)) {
@@ -2655,6 +2671,12 @@ int nand_erase_nand(struct mtd_info *mtd
 				bbt_masked_page = chip->bbt_td->pages[chipnr] &
--
 	while (len--) {
 		crc ^= *p++ << 8;
 		for (i = 0; i < 8; i++)
 			crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (len > 0x800) {
 		memcpy_fromio(buf, chip->IO_ADDR_R, 0x800);
 		buf += 0x800;
 		len -= 0x800;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len > 0x800) {
 		memcpy_toio(chip->IO_ADDR_R, buf, 0x800);
 		buf += 0x800;
 		len -= 0x800;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while ((ReadDOC(docptr, Mplus_FlashControl) & CDSN_CTRL_FR_B_MASK) != CDSN_CTRL_FR_B_MASK) {
 			if (time_after(jiffies, timeo)) {
 				printk("_DoC_WaitReady timed out.\n");
@@ -256,8 +261,19 @@ static int _DoC_WaitReady(struct doc_pri
 			}
 			udelay(1);
--
 		while (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {
 			if (time_after(jiffies, timeo)) {
 				printk("_DoC_WaitReady timed out.\n");
@@ -265,6 +281,12 @@ static int _DoC_WaitReady(struct doc_pri
 			}
 			udelay(1);
--
 		while (blocks > maxblocks) {
 			blocks >>= 1;
 			maxblocks = min(32768U, (maxblocks << 1) + psize);
 			mh->UnitSizeFactor--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (totlen) {
 		len = min(totlen, (size_t)(1 << this->bbt_erase_shift));
 		if (marker_len) {
@@ -247,6 +252,12 @@ static int read_bbt(struct mtd_info *mtd
 		}
 		totlen -= len;
--
 	while (len > 0) {
 		ops.datbuf = buf;
 		ops.len = min(len, (size_t)mtd->writesize);
@@ -325,6 +341,12 @@ static int scan_read_raw_oob(struct mtd_
 		buf += mtd->oobsize + mtd->writesize;
 		len -= mtd->writesize;
--
 		while (flips--) {
 			int pos = random32() % (num * 8);
 			ns->buf.byte[pos / 8] ^= (1 << (pos % 8));
@@ -1425,6 +1430,12 @@ void do_bit_flips(struct nandsim *ns, in
 				"reading from %d ecc: corrected=%u failed=%u\n",
 				pos, ns->regs.row, ns->regs.column + ns->regs.off,
--
 	while (timeout--) {
 		if (readb(FLTRCR(flctl)) & TREND) {
 			writeb(0x0, FLTRCR(flctl));
 			return;
 		}
 		udelay(1);
--
 	while (timeout--) {
 		uint32_t val;
 		/* check FIFO */
@@ -139,6 +155,12 @@ static void wait_rfifo_ready(struct sh_f
 		if (val & 0xFF)
 			return;
--
 	while (timeout--) {
 		/* check FIFO */
 		len = (readl(FLDTCNTR(flctl)) >> 16) & 0xFF;
 		if (len >= 4)
 			return;
 		udelay(1);
--
 	while (timeout--) {
 		size = readl(FLDTCNTR(flctl)) >> 24;
 		if (size & 0xFF)
@@ -204,6 +242,12 @@ static int wait_recfifo_ready(struct sh_
 		}
 
--
 	while (timeout--) {
 		/* check FLECFIFO */
 		len = (readl(FLDTCNTR(flctl)) >> 24) & 0xFF;
 		if (len >= 4)
 			return;
 		udelay(1);
--
 	while ((ndcr & NDCR_ND_RUN) && (timeout-- > 0)) {
 		ndcr = nand_readl(info, NDCR);
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (dv_window < 8) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (dv_window < 8) {
 		data_invalid_rhoh = en_lo * CLK_X + Trhoh[mode];
 
 		data_invalid_rloh = (en_lo + en_hi) * CLK_X + Trloh[mode];
@@ -257,6 +262,12 @@ static void nand_onfi_timing_set(struct
 
--
 	while (size) {
 		/* Calculate spare buffer number */
 		s = offset / sbsize;
@@ -450,6 +455,12 @@ static void mpc5121_nfc_copy_spare(struc
 		buffer += blksize;
 		offset += blksize;
--
 	while (len) {
 		bsize = min(len, 256);
 		mpc5121_nfc_read_buf(mtd, tmp, bsize);
@@ -522,6 +538,12 @@ static int mpc5121_nfc_verify_buf(struct
 
 		buf += bsize;
--
 	while (nfc_read(mtd, NFC_CONFIG1) & NFC_RESET) {
 		if (resettime++ >= NFC_RESET_TIMEOUT) {
 			dev_err(dev, "Timeout while resetting NFC!\n");
@@ -772,6 +799,12 @@ static int __devinit mpc5121_nfc_probe(s
 		}
 
 		udelay(1);
+		if (_cur < timeout) {
--
 	while (unlikely(len > 0x800)) {
 		memcpy_fromio(buf, this->IO_ADDR_R, 0x800);
 		buf += 0x800;
 		len -= 0x800;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (unlikely(len > 0x800)) {
 		memcpy_toio(this->IO_ADDR_R, buf, 0x800);
 		buf += 0x800;
 		len -= 0x800;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (i && readb(this->IO_ADDR_R + MM_NAND_STS) & CS_NAND_CTLR_BUSY) {
 		udelay(1);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (num_err--) {
 		change_bit(0, (unsigned long *)&err_idx[i]);
 		change_bit(1, (unsigned long *)&err_idx[i]);
@@ -517,6 +522,12 @@ static int fsmc_correct_data(struct mtd_
 			change_bit(err_idx[i], (unsigned long *)dat);
 			i++;
--
 	while (len--) {
 		iowrite8(*p++, info->nand.IO_ADDR_W);
 		/* wait until buffer is available for write */
 		do {
 			status = gpmc_read_status(GPMC_STATUS_BUFFER);
 		} while (!status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (len--) {
 		iowrite16(*p++, info->nand.IO_ADDR_W);
 		/* wait until buffer is available for write */
 		do {
 			status = gpmc_read_status(GPMC_STATUS_BUFFER);
 		} while (!status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 		while (len) {
 			w_count = gpmc_read_status(GPMC_PREFETCH_FIFO_CNT);
 			w_count = w_count >> 1;
 			for (i = 0; (i < w_count) && len; i++, len -= 2)
 				iowrite16(*p++, info->nand.IO_ADDR_W);
+				if (_cur < timeout) {
--
-	while (len--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (len--) {
 		if (*p++ != cpu_to_le16(readw(info->nand.IO_ADDR_R)))
 			return -EFAULT;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 		while (cnt++ < 0x1FF) {
 			if  ((val & 0x100) == 0x100)
 				return 0;
 			val = gpmc_read_status(GPMC_GET_IRQ_STATUS);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while(len && (offset < MAX_TIG_FLASH_SIZE)) {
 		*dest = tsunami_tig_readb(offset);
 		offset++;
 		dest++;
 		len--;
+		if (_cur < timeout) {
--
 	while(len && (offset < MAX_TIG_FLASH_SIZE)) {
 		tsunami_tig_writeb(*src, offset);
 		offset++;
 		src++;
 		len--;
+		if (_cur < timeout) {
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
@@ -75,6 +80,12 @@ static void vmax301_copy_from(struct map
 		to += thislen;
 		from += thislen;
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
@@ -100,6 +116,12 @@ static void vmax301_copy_to(struct map_i
 		to += thislen;
 		from += thislen;
--
 	while((map_top - 1) < 0xffffffffUL) {
 		struct cfi_private *cfi;
 		unsigned long offset;
@@ -275,7 +280,13 @@ static int __devinit amd76xrom_init_one
 		/* File away the map structure */
 		list_add(&map->list, &window->maps);
--
 	while(len--) {
 		unsigned long tmp = address_fix8_write(map->map_priv_1 + to++);
 		*(__u8 *)(tmp) = *(__u8 *)(from++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cplen > 0) {
 		res[count] = cp;
 		l = strlen(cp) + 1;
 		cp += l;
 		cplen -= l;
 		count++;
--
 	while (start < end) {
 		/* invalidate D cache line */
 		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (start));
 		start += CACHELINESIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len > 0) {
 		map_word d;
 		d.x[0] = *((uint32_t*)from);
@@ -111,11 +116,22 @@ static void dc21285_copy_to_32(struct ma
 		from += 4;
 		to += 4;
--
 	while (len > 0) {
 		map_word d;
 		d.x[0] = *((uint16_t*)from);
@@ -123,6 +139,12 @@ static void dc21285_copy_to_16(struct ma
 		from += 2;
 		to += 2;
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
@@ -135,6 +140,12 @@ static void sbc_gxx_copy_from(struct map
 		to += thislen;
 		from += thislen;
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
@@ -160,6 +176,12 @@ static void sbc_gxx_copy_to(struct map_i
 		to += thislen;
 		from += thislen;
--
 	while(*sor)
 	{
 		if(*sor==',')
@@ -91,6 +96,12 @@ static char * __init get_string_option(c
 				return sor;
 			}
--
 	while ((map_top - 1) < 0xffffffffUL) {
 		struct cfi_private *cfi;
 		unsigned long offset;
@@ -364,7 +369,13 @@ static int __devinit esb2rom_init_one(st
 		/* File away the map structure */
 		list_add(&map->list, &window->maps);
--
 	while (len >= 2) {
 		u16 data = flash_read16(src);
 		*dest++ = BYTE0(data);
 		*dest++ = BYTE1(data);
 		src += 2;
 		len -= 2;
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
@@ -84,6 +89,12 @@ static void oct5066_copy_from(struct map
 		to += thislen;
 		from += thislen;
--
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
@@ -109,6 +125,12 @@ static void oct5066_copy_to(struct map_i
 		to += thislen;
 		from += thislen;
--
 	while((map_top - 1) < 0xffffffffUL) {
 		struct cfi_private *cfi;
 		unsigned long offset;
@@ -304,7 +309,13 @@ static int __devinit ck804xrom_init_one
 		/* File away the map structure */
 		list_add(&map->list, &window->maps);
--
 	while(len) {
 		int toread = win_size - (from & (win_size-1));
 		caddr_t addr;
@@ -158,6 +163,12 @@ static void pcmcia_copy_from_remap(struc
 		len -= toread;
 		to += toread;
--
 	while(len) {
 		int towrite = win_size - (to & (win_size-1));
 		caddr_t addr;
@@ -207,6 +223,12 @@ static void pcmcia_copy_to_remap(struct
 		len -= towrite;
 		to += towrite;
--
 	while (len > 0) {
 		n = info->win_mask + 1 - (from & info->win_mask);
 		if (n > len)
@@ -89,6 +94,12 @@ static void lf_copy_from(struct map_info
 		to += n;
 		from += n;
--
 	while((map_top - 1) < 0xffffffffUL) {
 		struct cfi_private *cfi;
 		unsigned long offset;
@@ -300,7 +305,13 @@ static int __devinit ichxrom_init_one (s
 		/* File away the map structure */
 		list_add(&map->list, &window->maps);
--
 	while (i--) {
 		mtd_device_unregister(msp_flash[i]);
 		map_destroy(msp_flash[i]);
 		kfree(msp_maps[i].name);
 		iounmap(msp_maps[i].virt);
 		kfree(msp_parts[i]);
--
   while (x >= NN) {
     x -= NN;
     x = (x >> MM) + (x & NN);
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
--
   while (++r <= NN-KK) {	/* r is the step number */
     /* Compute discrepancy at the r-th step in poly-form */
     discr_r = 0;
@@ -324,6 +340,12 @@ eras_dec_rs(dtype Alpha_to[NN + 1], dtyp
       }
       COPY(lambda,t,NN-KK+1);
--
 		while (len) {
 			if (erase_sector(flash, addr)) {
 				instr->state = MTD_ERASE_FAILED;
@@ -324,6 +329,12 @@ static int m25p80_erase(struct mtd_info
 
 			addr += mtd->erasesize;
--
-		while (soff_hi != eoff_hi) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (soff_hi != eoff_hi) {
 #ifdef CONFIG_MTD_PMC551_DEBUG
 			printk(KERN_DEBUG "pmc551_erase() soff_hi: %ld, "
 				"eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);
@@ -154,6 +159,12 @@ static int pmc551_erase(struct mtd_info
 			pmc551_point(mtd, (priv->base_map0 | soff_hi),
--
-		while (soff_hi != eoff_hi) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (soff_hi != eoff_hi) {
 #ifdef CONFIG_MTD_PMC551_DEBUG
 			printk(KERN_DEBUG "pmc551_read() soff_hi: %ld, "
 				"eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);
@@ -267,6 +283,12 @@ static int pmc551_read(struct mtd_info *
 			soff_hi += priv->asize;
--
-		while (soff_hi != eoff_hi) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (soff_hi != eoff_hi) {
 #ifdef CONFIG_MTD_PMC551_DEBUG
 			printk(KERN_DEBUG "pmc551_write() soff_hi: %ld, "
 				"eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);
@@ -334,6 +361,12 @@ static int pmc551_write(struct mtd_info
 			soff_hi += priv->asize;
--
 		while (counter++ < 100) {
 			pci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (counter++ < 100) {
 			pci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while ((mtd = pmc551list)) {
 		priv = mtd->priv;
 		pmc551list = priv->nextpmc551;
@@ -859,6 +919,12 @@ static void __exit cleanup_pmc551(void)
 		mtd_device_unregister(mtd);
 		kfree(mtd);
--
 	while (!ret && len > 0) {
 		readlen = min_t(size_t, len, (size_t)DOC_LAYOUT_PAGE_SIZE);
 		ret = doc_read_page_prepare(docg3, block0, block1, page, ofs);
@@ -632,6 +637,12 @@ static int doc_read(struct mtd_info *mtd
 				goto err_in_read;
 		}
--
-   while (len)
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
+	 while (len)
 	 {
 		if (!erase_block (addr))
 		  {
@@ -426,6 +431,12 @@ static int flash_erase (struct mtd_info
 		len -= mtd->eraseregions[i].erasesize;
--
-   while (len >= BUSWIDTH)
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
+	 while (len >= BUSWIDTH)
 	 {
 		*((__u32 *) buf) = read32 (from);
 
 		buf += BUSWIDTH;
 		from += BUSWIDTH;
--
-   while (len >= BUSWIDTH)
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
+	 while (len >= BUSWIDTH)
 	 {
 		if (!write_dword (to,*((__u32 *) buf))) return (-EIO);
 
@@ -556,7 +583,13 @@ static int flash_write (struct mtd_info
 		buf += BUSWIDTH;
--
 	while (addr < end) {
 		err = sst25l_erase_sector(flash, addr);
 		if (err) {
@@ -205,6 +210,12 @@ static int sst25l_erase(struct mtd_info
 		}
 
--
-	while (old) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (old) {
 		if (DoCMil_is_alias(this, old)) {
 			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium at "
 			       "0x%lX - already configured\n", this->physadr);
@@ -335,6 +340,12 @@ void DoCMil_init(struct mtd_info *mtd)
 			old = old->nextdoc->priv;
--
 	while ((mtd=docmillist)) {
 		this = mtd->priv;
 		docmillist = this->nextdoc;
@@ -830,6 +846,12 @@ static void __exit cleanup_doc2001(void)
 		iounmap(this->virtadr);
 		kfree(this->chips);
--
 	while (*curmtd) {
 		curmtd = &(*curmtd)->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (slram_mtdlist) {
 		nextitem = slram_mtdlist->next;
 		mtd_device_unregister(slram_mtdlist->mtdinfo);
@@ -237,6 +253,12 @@ static void unregister_devices(void)
 		kfree(slram_mtdlist->mtdinfo);
 		kfree(slram_mtdlist);
--
 	while (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {
 		/* issue 2 read from NOP register after reading from CDSNControl register
 	   	see Software Requirement 11.4 item 2. */
@@ -96,6 +101,12 @@ static int _DoC_WaitReady(struct DiskOnC
 		}
 		udelay(1);
--
-	while (old) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (old) {
 		if (DoC2k_is_alias(old, this)) {
 			printk(KERN_NOTICE
 			       "Ignoring DiskOnChip 2000 at 0x%lX - already configured\n",
@@ -529,6 +545,12 @@ void DoC2k_init(struct mtd_info *mtd)
 			old = old->nextdoc->priv;
--
 	while (left) {
 		len = left;
 
@@ -737,6 +764,12 @@ static int doc_read(struct mtd_info *mtd
 		from += len;
 		left -= len;
--
 	while (left) {
 		len = left;
 
@@ -912,6 +950,12 @@ static int doc_write(struct mtd_info *mt
 		to += len;
 		left -= len;
--
 	while(len) {
 		mychip = &this->chips[ofs >> this->chipshift];
 
@@ -1156,6 +1205,12 @@ static int doc_erase(struct mtd_info *mt
 		}
 		ofs += mtd->erasesize;
--
 	while ((mtd = doc2klist)) {
 		this = mtd->priv;
 		doc2klist = this->nextdoc;
@@ -1187,6 +1247,12 @@ static void __exit cleanup_doc2000(void)
 		iounmap(this->virtadr);
 		kfree(this->chips);
--
 	while (pages) {
 		page = page_read(mapping, index);
 		if (!page)
@@ -71,6 +76,12 @@ static int _block2mtd_erase(struct block
 		page_cache_release(page);
 		pages--;
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		if ((offset + len) > PAGE_SIZE)
 			cpylen = PAGE_SIZE - offset;	// multiple pages
 		else
@@ -134,6 +150,12 @@ static int block2mtd_read(struct mtd_inf
 		buf += cpylen;
--
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		if ((offset+len) > PAGE_SIZE)
 			cpylen = PAGE_SIZE - offset;	// multiple pages
 		else
@@ -178,6 +205,12 @@ static int _block2mtd_write(struct block
 		buf += cpylen;
--
-	while (old) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (old) {
 		if (DoCMilPlus_is_alias(this, old)) {
 			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium "
 				"Plus at 0x%lX - already configured\n",
@@ -459,6 +464,12 @@ void DoCMilPlus_init(struct mtd_info *mt
 			old = old->nextdoc->priv;
--
 	while ((mtd=docmilpluslist)) {
 		this = mtd->priv;
 		docmilpluslist = this->nextdoc;
@@ -1095,6 +1111,12 @@ static void __exit cleanup_doc2001plus(v
 		iounmap(this->virtadr);
 		kfree(this->chips);
--
 	while (instr->len > 0) {
 		unsigned int	pageaddr;
 		int		status;
@@ -222,6 +227,12 @@ static int dataflash_erase(struct mtd_in
 			instr->addr += priv->page_size;
 			instr->len -= priv->page_size;
--
-	while (remaining > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (remaining > 0) {
 		pr_debug("write @ %i:%i len=%i\n",
 			pageaddr, offset, writelen);
 
@@ -453,6 +469,12 @@ static int dataflash_write(struct mtd_in
 			writelen = priv->page_size;
--
         while (len > 0) {
 		/* We must not cross write block boundaries */
 		int size = wbufsize - (ofs & (wbufsize-1));
@@ -653,6 +658,12 @@ static int cfi_staa_write_buffers (struc
 			if (chipnum == cfi->numchips)
 				return 0;
--
-                while (temp_len) {
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (temp_len) {
 			printk("before unlock %x: block status register is %x\n",temp_adr,cfi_read_query(map, temp_adr+(2*ofs_factor)));
 			temp_adr += mtd->erasesize;
 			temp_len -= mtd->erasesize;
+			if (_cur < timeout) {
+	rdstcll(_cur);
--
 			while (chip->state != newstate) {
 				DECLARE_WAITQUEUE(wait, current);
 				set_current_state(TASK_UNINTERRUPTIBLE);
@@ -1159,6 +1164,12 @@ static int __xipram xip_wait_for_operati
 				schedule();
 				remove_wait_queue(&chip->wq, &wait);
--
-	while(len >= map_bankwidth(map)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while(len >= map_bankwidth(map)) {
 		map_word datum = map_word_load(map, buf);
 
 		ret = do_write_oneword(map, &cfi->chips[chipnum],
@@ -1620,6 +1636,12 @@ static int cfi_intelext_write_words (str
 			if (chipnum == cfi->numchips)
--
 	while (size) {
 		unsigned long bus_ofs = offset & ~(map_bankwidth(map)-1);
 		int gap = offset - bus_ofs;
@@ -2205,6 +2232,12 @@ do_otp_write(struct map_info *map, struc
 		offset += n;
 		buf += n;
--
 			while (len > 0 && groups > 0) {
 				if (!action) {
 					/*
@@ -2343,6 +2381,12 @@ static int cfi_intelext_otp_walk(struct
 				}
 				groupno++;
--
 			while (chip->state != FL_XIP_WHILE_ERASING) {
 				DECLARE_WAITQUEUE(wait, current);
 				set_current_state(TASK_UNINTERRUPTIBLE);
@@ -896,6 +901,12 @@ static void __xipram xip_udelay(struct m
 				schedule();
 				remove_wait_queue(&chip->wq, &wait);
--
-	while(len >= map_bankwidth(map)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while(len >= map_bankwidth(map)) {
 		map_word datum;
 
 		datum = map_word_load(map, buf);
@@ -1331,6 +1347,12 @@ static int cfi_amdstd_write_words(struct
 				return 0;
--
 	while(z < words * map_bankwidth(map)) {
 		datum = map_word_load(map, buf);
 		map_write(map, datum, adr + z);
 
 		z += map_bankwidth(map);
 		buf += map_bankwidth(map);
--
 	while (len >= map_bankwidth(map) * 2) {
 		/* We must not cross write block boundaries */
 		int size = wbufsize - (ofs & (wbufsize-1));
@@ -1547,6 +1585,12 @@ static int cfi_amdstd_write_buffers(stru
 			if (chipnum == cfi->numchips)
 				return 0;
--
 	while (*p) {
 		parent = *p;
 		cur = rb_entry(parent, struct swap_eb, rb);
@@ -228,6 +233,12 @@ static void __mtdswap_rb_add(struct rb_r
 			p = &(*p)->rb_right;
 		else
--
 	while (i < idx && p) {
 		p = rb_next(p);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (1) {
 		ret = mtdswap_gc(d, 1);
 		if (ret || mtd_blktrans_cease_background(dev))
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((pp = of_get_next_child(node, pp))) {
 		const __be32 *reg;
 		int len;
@@ -74,6 +79,12 @@ static int parse_ofpart_partitions(struc
 			(*pparts)[i].mask_flags = MTD_WRITEABLE;
 
--
 	while (len > 0) {
 		unsigned long sect_start = (pos/sect_size)*sect_size;
 		unsigned int offset = pos - sect_start;
@@ -204,6 +209,12 @@ static int do_cached_write (struct mtdbl
 		buf += size;
 		pos += size;
--
 	while (len > 0) {
 		unsigned long sect_start = (pos/sect_size)*sect_size;
 		unsigned int offset = pos - sect_start;
@@ -251,6 +267,12 @@ static int do_cached_read (struct mtdblk
 		buf += size;
 		pos += size;
--
-		while (offs < slave->mtd.size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (offs < slave->mtd.size) {
 			if (master->block_isbad(master,
 						offs + slave->offset))
 				slave->mtd.ecc_stats.badblocks++;
 			offs += slave->mtd.erasesize;
+			if (_cur < timeout) {
--
 	while (*p) {
 		parent = *p;
 		sv = rb_entry(parent, struct ubi_scan_volume, rb);
@@ -269,6 +274,12 @@ static struct ubi_scan_volume *add_volum
 			p = &(*p)->rb_left;
 		else
--
 	while (*p) {
 		int cmp_res;
 
@@ -556,6 +572,12 @@ int ubi_scan_add_used(struct ubi_device
 			return add_to_list(si, pnum, ec, cmp_res & 4,
 					   &si->erase);
--
 	while (p) {
 		sv = rb_entry(p, struct ubi_scan_volume, rb);
 
@@ -613,6 +640,12 @@ struct ubi_scan_volume *ubi_scan_find_sv
 			p = p->rb_left;
 		else
--
 	while (p) {
 		seb = rb_entry(p, struct ubi_scan_leb, u.rb);
 
@@ -642,6 +680,12 @@ struct ubi_scan_leb *ubi_scan_find_seb(c
 			p = p->rb_left;
 		else
--
 	while ((rb = rb_first(&sv->root))) {
 		seb = rb_entry(rb, struct ubi_scan_leb, u.rb);
 		rb_erase(&seb->u.rb, &sv->root);
 		list_add_tail(&seb->u.list, &si->erase);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (this) {
 		if (this->rb_left)
 			this = this->rb_left;
@@ -1270,6 +1330,12 @@ static void destroy_sv(struct ubi_scan_i
 
 			kmem_cache_free(si->scan_leb_slab, seb);
--
 	while (rb) {
 		if (rb->rb_left)
 			rb = rb->rb_left;
@@ -1321,6 +1392,12 @@ void ubi_scan_destroy_si(struct ubi_scan
 
 			destroy_sv(si, sv);
--
 	while (*p) {
 		struct ubi_wl_entry *e1;
 
@@ -205,6 +210,12 @@ static void wl_tree_add(struct ubi_wl_en
 			else
 				p = &(*p)->rb_right;
--
 	while (!ubi->free.rb_node) {
 		spin_unlock(&ubi->wl_lock);
 
@@ -281,6 +297,12 @@ static int produce_free_peb(struct ubi_d
 			return err;
 
--
 	while (p) {
 		struct ubi_wl_entry *e1;
 
@@ -321,6 +348,12 @@ static int in_wl_tree(struct ubi_wl_entr
 			else
 				p = p->rb_right;
--
 	while (p) {
 		struct ubi_wl_entry *e1;
 
@@ -374,6 +412,12 @@ static struct ubi_wl_entry *find_wl_entr
 			p = p->rb_right;
 			e = e1;
--
 	while (ubi->works_count) {
 		err = do_work(ubi);
 		if (err)
 			return err;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (ubi->works_count) {
 		dbg_wl("flush more (%d pending works)", ubi->works_count);
 		err = do_work(ubi);
 		if (err)
 			return err;
+			if (_cur < timeout) {
--
 	while (rb) {
 		if (rb->rb_left)
 			rb = rb->rb_left;
@@ -1342,6 +1413,12 @@ static void tree_destroy(struct rb_root
 
 			kmem_cache_free(ubi_wl_entry_slab, e);
--
 	while (!list_empty(&ubi->works)) {
 		struct ubi_work *wrk;
 
@@ -1416,6 +1498,12 @@ static void cancel_pending(struct ubi_de
 		wrk->func(ubi, wrk, 1);
 		ubi->works_count -= 1;
--
 	while (p) {
 		struct ubi_ltree_entry *le;
 
@@ -116,6 +121,12 @@ static struct ubi_ltree_entry *ltree_loo
 			else
 				return le;
--
 		while (*p) {
 			parent = *p;
 			le1 = rb_entry(parent, struct ubi_ltree_entry, rb);
@@ -181,6 +197,12 @@ static struct ubi_ltree_entry *ltree_add
 				else
 					p = &(*p)->rb_right;
--
 	while (i < len) {
 		printk("0x%08x: ", start + i);
 		diff = "   ";
@@ -486,9 +491,20 @@ static void print_bufs(unsigned char *re
 				diff = "***";
 		}
--
 		while (j1 < 8) {
 			printk(" ");
 			j1 += 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (i < offset + len) {
 		if (buf[i] != check_buf[i]) {
 			(*bytesp)++;
 			bit = 1;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
--
 			while (bit < 256) {
 				if ((buf[i] & bit) != (check_buf[i] & bit))
 					(*bitsp)++;
 				bit <<= 1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (offs > mtd->erasesize) {
 		offsets[eb++] = mtd->erasesize;
 		offs -= mtd->erasesize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (chip->state != chip_state) {
 			/* Someone's suspended the operation: sleep */
 			DECLARE_WAITQUEUE(wait, current);
@@ -170,6 +175,12 @@ static int wait_for_ready(struct map_inf
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
--
 			/* Suspend has occurred while sleep: reset timeout */
@@ -698,12 +709,23 @@ static int lpddr_erase(struct mtd_info *
 	if (ofs > mtd->size || (len + ofs) > mtd->size)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
--
 	while (len > 0) {
 		ret = do_erase_oneblock(mtd, ofs);
 		if (ret)
 			return ret;
 		ofs += size;
 		len -= size;
--
-	while (i--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i--) {
 		len = kfifo_out(&zone->free_sectors,
 					(unsigned char *)&block, 2);
 		WARN_ON(len != 2);
 		kfifo_in(&zone->free_sectors, (const unsigned char *)&block, 2);
+		if (_cur < timeout) {
--
 	while ((dev = of_get_next_child(busnode, dev)) != NULL) {
 		u8 addr;
 
@@ -154,6 +159,12 @@ static int wf_max6690_attach(struct i2c_
 			continue;
 		printk("found max6690, loc=%s addr=0x%02x\n", loc, addr);
--
 	while (!req.complete) {
 		adb_iop_poll();
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (state == state_attached) {
 		unsigned long elapsed, start;
 
@@ -1871,6 +1876,12 @@ static int main_control_loop(void *x)
 		elapsed = jiffies - start;
 		if (elapsed < HZ)
--
 	while ((np = of_get_next_child(fcu_node, np)) != NULL) {
 		int type = -1;
 		const char *loc;
@@ -2197,6 +2213,12 @@ static void fcu_lookup_fans(struct devic
 			DBG(" fan id -> %d, type -> %d\n", fan_id, type);
 			fcu_fans[i].id = fan_id;
--
 	while (count--) {
 		result = ams_i2c_read(AMS_COMMAND);
 		if (result == 0 || result & 0x80)
 			return 0;
 
 		schedule_timeout_uninterruptible(HZ / 20);
--
-	while(!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while(!kthread_should_stop()) {
 		try_to_freeze();
 		msleep_interruptible(2000);
 
@@ -364,6 +369,12 @@ static int monitor_task(void *arg)
 		display_stats(th);
--
 	while (!req->complete && count++ < 50) {
 		maciisi_poll();
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
--
 	while (!list_empty(&smu_fans)) {
 		fct = list_entry(smu_fans.next, struct smu_fan_control, link);
 		list_del(&fct->link);
 		wf_unregister_control(&fct->ctrl);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while(adb_handler[index].busy) {
 			write_unlock_irq(&adb_handler_lock);
 			yield();
 			write_lock_irq(&adb_handler_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (!list_empty(&smu_ads)) {
 		ads = list_entry(smu_ads.next, struct smu_ad_sensor, link);
 		list_del(&ads->link);
 		wf_unregister_sensor(&ads->sens);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((in_8(&adb->ctrl.r) & ADB_RST) != 0) {
 		if (--timeout == 0) {
 			out_8(&adb->ctrl.r, in_8(&adb->ctrl.r) & ~ADB_RST);
 			spin_unlock_irqrestore(&macio_lock, flags);
 			return -1;
 		}
--
 	while (cur) {
 		if (cur == req) {
 			local_irq_restore(flags);
 			return 1;
 		}
 		cur = cur->next;
--
 		while (!req->complete) {
 			macii_poll();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (!kthread_should_stop()) {
 		try_to_freeze();
 
@@ -119,6 +124,12 @@ static int wf_thread_func(void *data)
 		delay = next - jiffies;
 		if (delay <= HZ)
--
 	while (len) {
 		unsigned int clen = min(len, chunk);
 
@@ -946,6 +951,12 @@ static int smu_read_datablock(u8 *dest,
 		len -= clen;
 		addr += clen;
--
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_init: no response from PMU\n");
@@ -204,11 +209,22 @@ pmu_init(void)
 		}
 		udelay(10);
--
 	while (interrupt_data[0] || pmu_state != idle) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_init: timed out acking intrs\n");
@@ -220,11 +236,22 @@ pmu_init(void)
 		}
 		pmu_poll();
--
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_init: no response from PMU\n");
@@ -232,6 +259,12 @@ pmu_init(void)
 		}
 		udelay(10);
--
 	while (!req.complete)
 		pmu_poll();
 	timeout = 100000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_adb_reset_bus (reset): no response from PMU\n");
@@ -435,6 +473,12 @@ pmu_reset_bus(void)
 		}
 		udelay(10);
--
 		while (!(via2[B] & TACK)) {
 			if (--timeout < 0) {
 				printk(KERN_ERR "PMU not responding (!ack)\n");
 				goto finish;
 			}
 			udelay(10);
--
 	while (!kthread_should_stop()) {
 		for (i = 0; i < media_bay_count; ++i) {
 			mutex_lock(&media_bays[i].lock);
@@ -552,6 +557,12 @@ static int media_bay_task(void *x)
 		}
 
--
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "init_pmu: no response from PMU\n");
@@ -538,11 +543,22 @@ init_pmu(void)
 		}
 		udelay(10);
--
 	while (interrupt_data[0][0] || pmu_state != idle) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "init_pmu: timed out acking intrs\n");
@@ -552,6 +568,12 @@ init_pmu(void)
 			adb_int_pending = 1;
 		via_pmu_interrupt(0, NULL);
--
 	while(*label == ' ')
 		label++;
 	val = label;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while(*val && (*val != '=')) {
 		if (*val == ' ')
 			*val = 0;
 		val++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((in_8(&via[B]) & TACK) == 0) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "PMU not responding (!ack)\n");
 			return;
 		}
 		udelay(10);
--
 	while (asleep) {
 		mb();
 		mtmsr(msr);
 		isync();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (cplen > 0) {
 		int l;
 		length += sprintf (buf, "%s\n", compat);
@@ -33,6 +38,12 @@ compatible_show (struct device *dev, str
 		l = strlen (compat) + 1;
 		compat += l;
--
 				while (i--) {
 					u16 new_idx = (ioat->tail+i) & (new_size-1);
 
 					ioat2_free_ring_ent(ring[new_idx], c);
+					if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while ((d40d = d40_first_active_get(d40c))) {
 		d40_desc_remove(d40d);
 		d40_desc_free(d40c, d40d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((d40d = d40_first_queued(d40c))) {
 		d40_desc_remove(d40d);
 		d40_desc_free(d40c, d40d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((d40d = d40_first_pending(d40c))) {
 		d40_desc_remove(d40d);
 		d40_desc_free(d40c, d40d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (l->link_addr) {
 		next = l->virt_link_addr;
 		dma_pool_free(pool->dmapool, l, l->phy_this);
 		DEBUGFS_POOL_COUNTER_ADD(pool, -1);
 		l = next;
+		if (_cur < timeout) {
--
 	while (lli->link_addr) {
 		lli->control = ctrl_chained | MAX_DMA_PACKET_SIZE;
 		lli->src_addr = src;
@@ -163,6 +179,12 @@ coh901318_lli_fill_memcpy(struct coh9013
 
 		src += MAX_DMA_PACKET_SIZE;
--
 	while (lli->link_addr) {
 		size_t block_size = MAX_DMA_PACKET_SIZE;
 		lli->control = ctrl_chained | MAX_DMA_PACKET_SIZE;
@@ -219,6 +246,12 @@ coh901318_lli_fill_single(struct coh9013
 			src += block_size;
 		else if (dir == DMA_FROM_DEVICE)
--
 		while (bytes_to_transfer) {
 			u32 val;
 
@@ -302,6 +340,12 @@ coh901318_lli_fill_sg(struct coh901318_p
 
 			bytes_to_transfer -= elem_size;
--
-		while ((rv = ioread32(&dma_reg->csfpl))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((rv = ioread32(&dma_reg->csfpl))) {
 			i = rv & DMA_CDB_ADDR_MSK;
 			cdb = (struct dma_cdb *)&p[i -
 			    (u32)chan->device->dma_desc_pool];
@@ -1217,6 +1222,12 @@ static void ppc440spe_adma_device_clear_
 						BUG();
--
 	while (stride--) {
 		slot->slots_per_op = 0;
 		slot = list_entry(slot->slot_node.next,
 				struct ppc440spe_adma_desc_slot,
 				slot_node);
+		if (_cur < timeout) {
--
-		while (dst_cnt--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (dst_cnt--) {
 			addr = ppc440spe_desc_get_dest_addr(
 				desc, chan, dst_cnt);
 			dma_unmap_page(chan->device->dev,
 					addr, desc->unmap_len,
 					DMA_FROM_DEVICE);
--
-		while (src_cnt--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (src_cnt--) {
 			addr = ppc440spe_desc_get_src_addr(
 				desc, chan, src_cnt);
 			dma_unmap_page(chan->device->dev,
 					addr, desc->unmap_len,
 					DMA_TO_DEVICE);
--
 			while (num_slots) {
 				int i;
 				/* pre-ack all but the last descriptor */
@@ -2053,6 +2102,12 @@ retry:
 						slot_node);
 				}
--
-		while (src_cnt--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (src_cnt--) {
 			ppc440spe_adma_pq_set_src(sw_desc, src[src_cnt],
 						  src_cnt);
 
@@ -2768,6 +2828,12 @@ static struct ppc440spe_adma_desc_slot *
 				mult = scf[src_cnt];
--
-		while (src_cnt--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (src_cnt--) {
 			/* handle descriptors (if dst_cnt == 2) inside
 			 * the ppc440spe_adma_pq_set_srcxxx() functions
 			 */
@@ -2863,6 +2934,12 @@ static struct ppc440spe_adma_desc_slot *
 				mult = scf[src_cnt];
--
-	while (op <= index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (op <= index) {
 		lop = op;
 		if (k == XOR_MAX_OPS) {
 			k = 0;
@@ -3746,6 +3828,12 @@ static void ppc440spe_adma_dma2rxor_set_
 			op += 2;
--
-	while (op <= index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (op <= index) {
 		lop = op;
 		if (k == XOR_MAX_OPS) {
 			k = 0;
@@ -3788,6 +3881,12 @@ static void ppc440spe_adma_dma2rxor_set_
 			op += 2;
--
 	while (iovec_idx < pinned_list->nr_iovecs) {
 		struct dma_page_list *page_list;
 
@@ -175,6 +180,11 @@ dma_cookie_t dma_memcpy_to_iovec(struct
 			 - ((unsigned long)page_list->base_address & PAGE_MASK)) >> PAGE_SHIFT;
 
--
 		while (iov[iovec_idx].iov_len) {
 			copy = min_t(int, PAGE_SIZE - iov_byte_offset, len);
 			copy = min_t(int, copy, iov[iovec_idx].iov_len);
@@ -200,8 +210,20 @@ dma_cookie_t dma_memcpy_to_iovec(struct
 			kdata += copy;
 			iov_byte_offset = 0;
--
 	while (iovec_idx < pinned_list->nr_iovecs) {
 		struct dma_page_list *page_list;
 
@@ -244,6 +271,11 @@ dma_cookie_t dma_memcpy_pg_to_iovec(stru
 			 - ((unsigned long)page_list->base_address & PAGE_MASK)) >> PAGE_SHIFT;
 
--
 		while (iov[iovec_idx].iov_len) {
 			copy = min_t(int, PAGE_SIZE - iov_byte_offset, len);
 			copy = min_t(int, copy, iov[iovec_idx].iov_len);
@@ -270,8 +302,20 @@ dma_cookie_t dma_memcpy_pg_to_iovec(stru
 			offset += copy;
 			iov_byte_offset = 0;
--
 			while (bd.remainder > (mbus->buswidth - 1)) {
 				size_t lli_len, tsize, width;
 
@@ -741,6 +746,12 @@ static int pl08x_fill_llis_for_desc(stru
 				pl08x_fill_lli_for_desc(&bd, num_llis++,
 						lli_len, cctl);
--
-	while (!list_empty(&desc->tx_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&desc->tx_list)) {
 		struct ep93xx_dma_desc *d = list_first_entry(&desc->tx_list,
 			struct ep93xx_dma_desc, node);
 
@@ -239,6 +244,12 @@ static void ep93xx_dma_set_active(struct
 		d->txd.callback_param = desc->txd.callback_param;
--
-	while (l) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l) {
 		dev_vdbg(COHC_2_DEV(cohc), "i %d, lli %p, ctrl 0x%x, src 0x%x"
 			 ", dst 0x%x, link 0x%x virt_link_addr 0x%p\n",
 			 i, l, l->control, l->src_addr, l->dst_addr,
 			 l->link_addr, l->virt_link_addr);
 		i++;
--
 	while (lli) {
 		bytes += lli->control & COH901318_CX_CTRL_TC_VALUE_MASK;
 		lli = lli->virt_link_addr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (status1) {
 		/* Find first bit set, return as a number. */
 		i = ffs(status1) - 1;
@@ -863,9 +890,20 @@ static irqreturn_t dma_irq_handler(int i
 			}
 		}
--
 	while (status2) {
 		/* Find first bit set, return as a number. */
 		i = ffs(status2) - 1;
@@ -908,6 +946,12 @@ static irqreturn_t dma_irq_handler(int i
 			}
 		}
--
 	while ((cohd = coh901318_first_active_get(cohc))) {
 		/* release the lli allocation*/
 		coh901318_lli_free(&cohc->base->pool, &cohd->lli);
@@ -1396,8 +1445,19 @@ coh901318_control(struct dma_chan *chan,
 		/* return desc to free-list */
 		coh901318_desc_remove(cohd);
--
 	while ((cohd = coh901318_first_queued(cohc))) {
 		/* release the lli allocation*/
 		coh901318_lli_free(&cohc->base->pool, &cohd->lli);
@@ -1405,6 +1465,12 @@ coh901318_control(struct dma_chan *chan,
 		/* return desc to free-list */
 		coh901318_desc_remove(cohd);
--
 	while (temp_size >= out_size * 2 && temp_downsize < 2) {
 		temp_size >>= 1;
 		temp_downsize++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (n--) {
 		struct dma_async_tx_descriptor *txd = &desc->txd;
 
@@ -964,6 +980,12 @@ static int idmac_desc_alloc(struct idmac
 		list_add(&desc->list, &ichan->free_list);
 
--
 		while ((line = ffs(status))) {
 			struct ipu_irq_map *map;
 
@@ -303,6 +308,12 @@ static void ipu_irq_err(unsigned int irq
 				continue;
 			}
--
 		while ((line = ffs(status))) {
 			struct ipu_irq_map *map;
 
@@ -340,6 +356,12 @@ static void ipu_irq_fn(unsigned int irq,
 				continue;
 			}
--
 	while (!list_empty(&last->node)) {
 		desc = list_entry(last->node.next, struct dma_pl330_desc, node);
 
@@ -410,6 +415,12 @@ static dma_cookie_t pl330_tx_submit(stru
 		desc->txd.cookie = cookie;
 
--
-			while (!list_empty(&first->node)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&first->node)) {
 				desc = list_entry(first->node.next,
 						struct dma_pl330_desc, node);
 				list_move_tail(&desc->node, &pdmac->desc_pool);
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (--i >= 0) {
 		struct imxdma_channel *imxdmac = &imxdma->channel[i];
 		imx_dma_free(imxdmac->imxdma_channel);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((ch = fls(status) - 1) >= 0) {
 		status &= ~(1 << ch);
 		mchan = &mdma->channels[ch + off];
@@ -298,6 +303,12 @@ static void mpc_dma_irq_process(struct m
 			mpc_dma_execute(mchan);
 
--
 	while (midc->descs_allocated < DESCS_PER_CHANNEL) {
 		spin_unlock_bh(&midc->lock);
 		desc = pci_pool_alloc(mid->dma_pool, GFP_KERNEL, &phys);
@@ -900,6 +905,12 @@ static int intel_mid_dma_alloc_chan_reso
 		spin_lock_bh(&midc->lock);
 		i = ++midc->descs_allocated;
--
 	while (status) {
 		/*txn interrupt*/
 		i = get_ch_index(&status, mid->chan_base);
@@ -977,10 +993,21 @@ static void dma_tasklet(unsigned long da
 				mid->dma_base + MASK_BLOCK);
 		}
--
 	while (status) {
 		/*err interrupt*/
 		i = get_ch_index(&status, mid->chan_base);
@@ -1002,6 +1029,12 @@ static void dma_tasklet(unsigned long da
 		iowrite32(UNMASK_INTR_REG(midc->ch_id),
 				mid->dma_base + MASK_ERR);
--
-				while (src_cnt--) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (src_cnt--) {
 					addr = mv_desc_get_src_addr(unmap,
 								    src_cnt);
 					if (addr == dest)
 						continue;
 					dma_unmap_page(dev, addr, len,
--
 			while (num_slots) {
 				int i;
 
@@ -515,6 +531,12 @@ retry:
 						slot_node);
 				}
--
 	while (stat) {
 		int channel = fls(stat) - 1;
 		struct sdma_channel *sdmac = &sdma->channel[channel];
@@ -553,6 +558,12 @@ static irqreturn_t sdma_int_handler(int
 		mxc_sdma_handle_channel(sdmac);
 
--
 	while (buf < buf_len) {
 		struct sdma_buffer_descriptor *bd = &sdmac->bd[i];
 		int param;
@@ -1071,6 +1087,12 @@ static struct dma_async_tx_descriptor *s
 		buf += period_len;
 
--
 	while (stride--) {
 		slot->slots_per_op = 0;
 		slot = list_entry(slot->slot_node.next,
 				struct iop_adma_desc_slot,
 				slot_node);
+		if (_cur < timeout) {
--
 		while (src_cnt--) {
 			addr = iop_desc_get_src_addr(unmap, iop_chan, src_cnt);
 			if (addr == dest)
 				continue;
 			dma_unmap_page(dev, addr, len, DMA_TO_DEVICE);
+			if (_cur < timeout) {
--
-			while (num_slots) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (num_slots) {
 				int i;
 				dev_dbg(iop_chan->device->common.dev,
 					"allocated slot: %d "
@@ -419,6 +446,12 @@ retry:
 						slot_node);
--
-	while (stat1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (stat1) {
 		int channel = fls(stat1) - 1;
 		struct mxs_dma_chan *mxs_chan =
 			&mxs_dma->mxs_chans[channel % MXS_DMA_CHANNELS];
@@ -301,6 +306,12 @@ static irqreturn_t mxs_dma_int_handler(i
 
--
 	while (buf < buf_len) {
 		struct mxs_dma_ccw *ccw = &mxs_chan->ccw[i];
 
@@ -522,6 +538,12 @@ static struct dma_async_tx_descriptor *m
 		buf += period_len;
 
--
 	while (chan->client_count < dmaengine_ref_count) {
 		__module_get(owner);
 		chan->client_count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (tx->cookie == -EBUSY) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tx->cookie == -EBUSY) {
 		if (time_after_eq(jiffies, dma_sync_wait_timeout)) {
 			pr_err("%s timeout waiting for descriptor submission\n",
 				__func__);
 			return DMA_ERROR;
 		}
--
-	while (!list_empty(&priv->list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&priv->list)) {
 		gref = list_entry(priv->list.next,
 			struct gntalloc_gref, next_file);
 		list_del(&gref->next_file);
 		gref->users--;
 		if (gref->users == 0)
--
 	while (pages && !err) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (pages && map->unmap_ops[offset].handle == -1) {
 			offset++;
 			pages--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (range < pages) {
@@ -354,6 +370,12 @@ static int unmap_grant_pages(struct gran
 		err = __unmap_grant_pages(map, offset, range);
 		offset += range;
 		pages -= range;
+		if (_cur < timeout) {
--
 	while (!list_empty(&priv->maps)) {
 		map = list_entry(priv->maps.next, struct grant_map, next);
 		list_del(&map->next);
 		gntdev_put_map(map);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (pgno < nr_pages) {
 		page = balloon_retrieve(highmem);
 		if (page && (highmem || !PageHighMem(page))) {
@@ -522,6 +527,12 @@ int alloc_xenballooned_pages(int nr_page
 			if (st != BP_DONE)
 				goto out_undo;
--
-	while (!list_empty(&seized_devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&seized_devices)) {
 		psdev = container_of(seized_devices.next,
 				     struct pcistub_device, dev_list);
 		list_del(&psdev->dev_list);
@@ -377,6 +382,12 @@ static int __init pcistub_init_devices_l
 
--
 	while ((recorded < bytes) && (i < desc->nr_addrs)) {
 		unsigned long vaddr = (unsigned long)buffer + recorded;
 		unsigned long paddr;
@@ -49,6 +54,12 @@ static int xencomm_init(struct xencomm_d
 
 		desc->address[i++] = paddr;
--
-	while (len != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (len != 0) {
 		void *dst;
 		unsigned int avail;
 
@@ -133,6 +138,12 @@ int xb_write(const void *data, unsigned
 
--
 	while (len != 0) {
 		unsigned int avail;
 		const char *src;
@@ -192,6 +208,12 @@ int xb_read(void *data, unsigned len)
 
 		/* Implies mb(): other side will see the updated consumer. */
--
-	while (list_empty(&xs_state.reply_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (list_empty(&xs_state.reply_list)) {
 		spin_unlock(&xs_state.reply_lock);
 		/* XXX FIXME: Avoid synchronous wait for response here. */
 		wait_event(xs_state.reply_waitq,
 			   !list_empty(&xs_state.reply_list));
 		spin_lock(&xs_state.reply_lock);
--
 	while (callback != NULL) {
 		next = callback->next;
 		if (gnttab_free_count >= callback->count) {
@@ -122,6 +127,12 @@ static void do_free_callbacks(void)
 			gnttab_free_callback_list = callback;
 		}
--
 	while (!((flags = shared[ref].flags) & GTF_transfer_committed)) {
 		if (sync_cmpxchg(&shared[ref].flags, flags, 0) == flags)
 			return 0;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!(flags & GTF_transfer_completed)) {
 		flags = shared[ref].flags;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (gnttab_entry(ref) != GNTTAB_LIST_END) {
 		ref = gnttab_entry(ref);
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cb) {
 		if (cb == callback)
 			goto out;
 		cb = cb->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (list_empty(&u->read_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (list_empty(&u->read_buffers)) {
 		mutex_unlock(&u->reply_mutex);
 		if (filp->f_flags & O_NONBLOCK)
 			return -EAGAIN;
@@ -133,6 +138,12 @@ again:
 		if (ret)
--
 	while (!list_empty(list)) {
 		rb = list_entry(list->next, struct read_buffer, list);
 		list_del(list->next);
 		kfree(rb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (nelem--) {
 		if (pageidx > PAGE_SIZE-size) {
 			struct page *page = alloc_page(GFP_KERNEL);
@@ -101,6 +106,12 @@ static int gather_array(struct list_head
 
 		data += size;
--
 	while (atomic_read(&pd_dvb->users) != 0
 		|| atomic_read(&pd_dvb->active_feed) != 0) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (fm_stat.sig_lock_busy && count-- && !ret) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
 
 		ret = send_get_req(p, TUNER_STATUS, TLG_MODE_FM_RADIO,
 				  &fm_stat, &status, sizeof(fm_stat));
--
 	 } while (0)
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while (count && count >= video->lines_size) {
 		if (video->prev_left) {
 			copy_data(video->prev_left);
@@ -251,6 +256,12 @@ static void copy_video_data(struct video
 			continue;
 		}
--
 	while (atv_stat.sig_lock_busy && count-- && !ret) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
 
 		ret = send_get_req(pd, TUNER_STATUS, TLG_MODE_ANALOG_TV,
 				&atv_stat, &cmd_status, sizeof(atv_stat));
--
-	while (!s->data_available_for_read) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!s->data_available_for_read) {
 		int ret = wait_event_interruptible(s->read_queue,
 					     s->data_available_for_read);
 		if (ret == -ERESTARTSYS) {
 			a->result = -EINTR;
 			return;
--
 	while (size > 0) { /* size is page-aligned */
 		if (vm_insert_page(vma, start, vmalloc_to_page(pos))) {
 			mutex_unlock(&cam->fileop_mutex);
@@ -1563,6 +1568,12 @@ static int et61x251_mmap(struct file* fi
 		start += PAGE_SIZE;
 		pos += PAGE_SIZE;
--
 	while (i--) {
 		int err;
 		if (stype == fsize->type) {
@@ -482,6 +487,12 @@ static int __find_resolution(struct v4l2
 			}
 		}
--
 	while (regs->reg != 0) {
 		saa7127_write(sd, regs->reg, regs->value);
 		regs++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (rv->reg != 0xffff) {
 		ret = stk_camera_write_reg(dev, rv->reg, rv->val);
 		if (ret)
 			return ret;
 		rv++;
+		if (_cur < timeout) {
--
 	while (vdec[i].adr != -1) {
 		data.byte = vdec[i].byte;
 		if (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x6c, 0, I2C_SMBUS_WRITE, vdec[i].adr, I2C_SMBUS_BYTE_DATA, &data)) {
@@ -221,6 +226,12 @@ static int hexium_set_standard(struct he
 			return -1;
 		}
--
 	while (size > 0) {
 		page = vmalloc_to_page((void *)addr);
 		if ((ret = vm_insert_page(vma, start, page)) < 0)
@@ -447,6 +452,12 @@ int uvc_queue_mmap(struct uvc_video_queu
 		start += PAGE_SIZE;
 		addr += PAGE_SIZE;
--
-	while (!list_empty(&queue->irqqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&queue->irqqueue)) {
 		buf = list_first_entry(&queue->irqqueue, struct uvc_buffer,
 				       queue);
 		list_del(&buf->queue);
 		buf->state = UVC_BUF_STATE_ERROR;
 		wake_up(&buf->wait);
--
 	while (numerator > ((uint32_t)-1)/multiplier) {
 		multiplier /= 2;
 		denominator /= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&
 	       buffer[2] == ftype) {
 		frame = &format->frame[format->nframes];
@@ -514,6 +530,12 @@ static int uvc_parse_format(struct uvc_d
 		format->nframes++;
 		buflen -= buffer[0];
--
 	while (buflen > 2 && buffer[1] != USB_DT_CS_INTERFACE) {
 		buflen -= buffer[0];
 		buffer += buffer[0];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (_buflen > 2 && _buffer[1] == USB_DT_CS_INTERFACE) {
 		switch (_buffer[2]) {
 		case UVC_VS_FORMAT_UNCOMPRESSED:
@@ -712,6 +750,12 @@ static int uvc_parse_streaming(struct uv
 
 		_buflen -= _buffer[0];
--
 	while (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE) {
 		switch (buffer[2]) {
 		case UVC_VS_FORMAT_UNCOMPRESSED:
@@ -761,6 +810,12 @@ static int uvc_parse_streaming(struct uv
 
 		buflen -= buffer[0];
--
 	while (buflen > 2) {
 		if (uvc_parse_vendor_control(dev, buffer, buflen) ||
 		    buffer[1] != USB_DT_CS_INTERFACE)
@@ -1184,6 +1244,12 @@ static int uvc_parse_control(struct uvc_
 next_descriptor:
 		buflen -= buffer[0];
--
-	while (entity != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (entity != NULL) {
 		/* Entity must not be part of an existing chain */
 		if (entity->chain.next || entity->chain.prev) {
 			uvc_trace(UVC_TRACE_DESCR, "Found reference to "
@@ -1489,6 +1560,12 @@ static int uvc_scan_chain(struct uvc_vid
 		prev = entity;
--
-   while (pdec->nbits_in_reservoir<(nbits_wanted)) \
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (pdec->nbits_in_reservoir<(nbits_wanted)) \
     { \
       pdec->reservoir |= (*(pdec->stream)++) << (pdec->nbits_in_reservoir); \
       pdec->nbits_in_reservoir += 8; \
-    } \
+    if (_cur < timeout) {
--
 }  while(0);
 
 #define skip_nbits(pdec, nbits_to_skip) do { \
@@ -747,11 +758,22 @@ static void DecompressBand23(struct pwc_
 	ptable8004 = pdec->table_8004_pass1[compression_index];
 
--
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_Y(pdec->temp_colors, planar_y, real_image_width, pdec->scalebits);
 		planar_y += 4;
 		nblocks--;
+		if (_cur < timeout) {
--
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_CrCb(pdec->temp_colors, planar_u, real_image_width/2, pdec->scalebits);
@@ -771,6 +798,12 @@ static void DecompressBand23(struct pwc_
 		planar_v += 8;
 		planar_u += 8;
--
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_RedBlue(pdec->temp_colors, rgbbayer, real_image_width, pdec->scalebits);
 		dest += 8;
 		nblocks--;
+		if (_cur < timeout) {
--
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_Green(pdec->temp_colors, rgbbayer+1, real_image_width, pdec->scalebits);
@@ -835,6 +884,12 @@ static void DecompressBandBayer(struct p
 
 		rgbbayer += 16;
--
-		while (bandlines_left--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (bandlines_left--) {
 
 			DecompressBandBayer(pwc->decompress_data,
 					    src,
@@ -881,6 +941,12 @@ void pwc_dec23_decompress(const struct p
 			src += pwc->vbandlength;
--
-		while (bandlines_left--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (bandlines_left--) {
 
 			DecompressBand23(pwc->decompress_data,
 					 src,
@@ -915,6 +986,12 @@ void pwc_dec23_decompress(const struct p
 			pout_planar_u += pwc->view.x;
--
-	while (!list_empty(&pdev->queued_bufs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&pdev->queued_bufs)) {
 		struct pwc_frame_buf *buf;
 
 		buf = list_entry(pdev->queued_bufs.next, struct pwc_frame_buf,
 				 list);
 		list_del(&buf->list);
--
 					while (*dot != ':' && k < 29) {
 						device_hint[i].serial_number[k++] = *dot;
 						dot++;
+						if (_cur < timeout) {
+						rdstcll(_cur);
+						}
--
 		while (!((status = read_lpstatus(q)) & 8)) {
 			/* 1000 is enough spins on the I/O for all normal
 			   cases, at that point we start to poll slowly
@@ -188,8 +193,19 @@ static int qc_waithand(struct qcam *q, i
 				msleep_interruptible(5);
 			if (runs > (maxpoll + 1000)) /* 5 seconds */
--
 		while (((status = read_lpstatus(q)) & 8)) {
 			/* 1000 is enough spins on the I/O for all normal
 			   cases, at that point we start to poll slowly
@@ -202,6 +218,12 @@ static int qc_waithand(struct qcam *q, i
 				msleep_interruptible(5);
 			if (runs++ > (maxpoll + 1000)) /* 5 seconds */
--
 	while (vals->reg_num != 0xffff || vals->value != 0xff) {
 		int ret = reg_write(client, vals->reg_num, vals->value);
 		if (ret < 0)
 			return ret;
 		vals++;
+		if (_cur < timeout) {
--
 	while (!list_empty(&vidq->active)) {
 		buf = list_entry(vidq->active.next, struct viu_buf, vb.queue);
 		list_del(&buf->vb.queue);
 		buf->vb.state = VIDEOBUF_ERROR;
 		wake_up(&buf->vb.done);
 		dprintk(1, "viu/0: [%p/%d] timeout\n", buf, buf->vb.i);
--
 	while (!list_empty(&dma_q->active)) {
 		struct vivi_buffer *buf;
 		buf = list_entry(dma_q->active.next, struct vivi_buffer, list);
 		list_del(&buf->list);
 		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
 		dprintk(dev, 2, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);
--
-	while (!list_empty(&vivi_devlist)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&vivi_devlist)) {
 		list = vivi_devlist.next;
 		list_del(list);
 		dev = list_entry(list, struct vivi_dev, vivi_devlist);
@@ -1244,6 +1260,12 @@ static int vivi_release(void)
 		v4l2_device_unregister(&dev->v4l2_dev);
--
 	while (size > 0) { /* size is page-aligned */
 		if (vm_insert_page(vma, start, vmalloc_to_page(pos))) {
 			mutex_unlock(&cam->fileop_mutex);
@@ -2140,6 +2145,12 @@ static int sn9c102_mmap(struct file* fil
 		start += PAGE_SIZE;
 		pos += PAGE_SIZE;
--
-		while (prog_cnt != dev->_last_index_irq) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (prog_cnt != dev->_last_index_irq) {
 			/* Update _last_index_irq */
 			if (dev->_last_index_irq < (NUMBER_OF_PROGRAMS - 1))
 				dev->_last_index_irq++;
@@ -526,6 +531,12 @@ int cx25821_audio_upstream_irq(struct cx
 
--
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++) =
 				    cpu_to_le32(RISC_WRITE | sg_dma_len(sg));
 				*(rp++) = cpu_to_le32(sg_dma_address(sg));
 				*(rp++) = cpu_to_le32(0);	/* bits 63-32 */
 				todo -= sg_dma_len(sg);
--
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++) = cpu_to_le32(RISC_WRITE |
 						      sg_dma_len(sg));
 				*(rp++) = cpu_to_le32(sg_dma_address(sg));
 				*(rp++) = cpu_to_le32(0);	/* bits 63-32 */
 				todo -= sg_dma_len(sg);
--
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf =
 		    list_entry(q->active.next, struct cx25821_buffer, vb.queue);
 		list_del(&buf->vb.queue);
 
 		buf->vb.state = VIDEOBUF_ERROR;
--
 	while (line) {
 		*line = 0;
 		svar = strpbrk(sp, tdelim);
@@ -173,6 +178,12 @@ static ssize_t zoran_write(struct file *
 		}
 		sp = line + 1;
--
 	while (i < len) {
 		zr36050_write(ptr, startreg++, data[i++]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 //      while (((por = btread(ZR36057_POR)) & (ZR36057_POR_POPen | ZR36057_POR_POTime)) == ZR36057_POR_POPen) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((por = btread(ZR36057_POR)) & ZR36057_POR_POPen) {
 		/* wait for something to happen */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (zr->jpg_dma_tail < zr->jpg_dma_head) {
 		if (zr->jpg_settings.TmpDcm == 1)
 			i = (zr->jpg_dma_tail -
@@ -1190,6 +1206,12 @@ zoran_reap_stat_com (struct zoran *zr)
 		buffer->state = BUZ_STATE_DONE;
 
--
-		while ((stat = count_reset_interrupt(zr))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((stat = count_reset_interrupt(zr))) {
 			if (count++ > 100) {
 				btand(~ZR36057_ICR_IntPinEn, ZR36057_ICR);
 				dprintk(1,
@@ -1364,6 +1391,12 @@ zoran_irq (int             irq,
 					ZR_DEVNAME(zr), stat);
--
 	while (h) {
 		// attach only if the slave has at least the flags
 		// expected by the master
@@ -153,6 +158,12 @@ videocodec_attach (struct videocodec_mas
 			}
 		}
--
 	while (h) {
 		a = h->list;
 		prev = NULL;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while (a) {
 			if (codec == a->codec) {
 				res = a->codec->unset(a->codec);
@@ -222,8 +243,20 @@ videocodec_detach (struct videocodec *co
 			}
 			prev = a;
--
-	while (h) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (h) {
 		if (codec == h->codec) {
 			if (h->attached) {
 				dprintk(1,
@@ -311,6 +349,12 @@ videocodec_unregister (const struct vide
 		}
--
-	while (h) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (h) {
 		seq_printf(m, "S %32s %04x %08lx %08lx (TEMPLATE)\n",
 			      h->codec->name, h->codec->type,
 			      h->codec->flags, h->codec->magic);
 		a = h->list;
-		while (a) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (a) {
 			seq_printf(m, "M %32s %04x %08lx %08lx (%s)\n",
 				      a->codec->master_data->name,
 				      a->codec->master_data->type,
@@ -342,8 +396,20 @@ static int proc_videocodecs_show(struct
 				      a->codec->master_data->magic,
--
 	while (i < len) {
 		zr36060_write(ptr, startreg++, data[i++]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (num) {
 		num >>= 1;
 		result <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-			while (!test_bit(IVTV_F_I_EOS, &itv->i_flags) &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!test_bit(IVTV_F_I_EOS, &itv->i_flags) &&
 				time_before(jiffies,
 					    then + msecs_to_jiffies(2000))) {
 				schedule_timeout(msecs_to_jiffies(10));
+				if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while (!(oi->video_buffer_size & (1 << size_shift))) {
 			size_shift--;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
--
 				while (--i >= 0) {
 					kfree(itv->vbi.sliced_mpeg_data[i]);
 					itv->vbi.sliced_mpeg_data[i] = NULL;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
--
 		while (1) {
 			if (test_and_clear_bit(IVTV_F_I_EV_DEC_STOPPED, &itv->i_flags))
 				ev->type = VIDEO_EVENT_DECODER_STOPPED;
@@ -1752,6 +1757,12 @@ static int ivtv_decoder_ioctls(struct fi
 				IVTV_DEBUG_INFO("User stopped wait for event\n");
 				return -EINTR;
--
 	while (line < 36) {
 		itv->vbi.sliced_dec_data[line].id = 0;
 		itv->vbi.sliced_dec_data[line].line = 0;
 		itv->vbi.sliced_dec_data[line].field = 0;
 		line++;
+		if (_cur < timeout) {
--
-		while (vi->cc_payload_idx) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (vi->cc_payload_idx) {
 			cc = vi->cc_payload[0];
 
 			memcpy(vi->cc_payload, vi->cc_payload + 1,
@@ -540,6 +556,12 @@ void ivtv_vbi_work_handler(struct ivtv *
 
--
 	while (bytes_available < needed_bytes) {
 		struct ivtv_buffer *buf = list_entry(steal->list.prev, struct ivtv_buffer, list);
 		u16 dma_xfer_cnt = buf->dma_xfer_cnt;
@@ -163,19 +168,47 @@ int ivtv_queue_move(struct ivtv_stream *
 				break;
 			buf = list_entry(steal->list.prev, struct ivtv_buffer, list);
--
 		while (to->length - old_length < needed_bytes) {
 			ivtv_queue_move_buf(s, from, to, 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (to->bytesused - old_bytesused < needed_bytes) {
 			ivtv_queue_move_buf(s, from, to, to_free);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while ((buf = ivtv_dequeue(s, &s->q_free))) {
 		if (ivtv_might_use_dma(s))
 			pci_unmap_single(s->itv->pdev, buf->dma_handle,
 				s->buf_size + 256, s->dma);
 		kfree(buf->buf);
 		kfree(buf);
--
 	while (!(readl(&mbox->flags) & IVTV_MBOX_FIRMWARE_DONE)) {
 		if (time_after(jiffies, then + api_timeout)) {
 			IVTV_DEBUG_WARN("Could not get result (%s)\n", api_info[cmd].name);
@@ -313,6 +318,12 @@ static int ivtv_api_call(struct ivtv *it
 			mdelay(1);
 		else
--
 		while ((buf = ivtv_dequeue(s, &s->q_dma)) != NULL) {
 			ivtv_buf_sync_for_cpu(s, buf);
 			ivtv_enqueue(s, buf, &s->q_free);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx23885_buffer,
 			vb.queue);
 		list_del(&buf->vb.queue);
@@ -174,6 +179,12 @@ void cx23885_vbi_timeout(unsigned long d
 		wake_up(&buf->vb.done);
--
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next,
 			struct cx23885_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -1523,6 +1528,12 @@ static void cx23885_vid_timeout(unsigned
 		printk(KERN_ERR "%s: [%p/%d] timeout - dma=0x%08lx\n",
--
 	while (params.shutdown == false) {
 		params.enable = false;
 		params.interrupt_enable = false;
 		params.shutdown = true;
 		v4l2_subdev_call(dev->sd_ir, ir, rx_s_parameters, &params);
 		v4l2_subdev_call(dev->sd_ir, ir, rx_g_parameters, &params);
--
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++) = cpu_to_le32(RISC_WRITE|
 						    sg_dma_len(sg));
 				*(rp++) = cpu_to_le32(sg_dma_address(sg));
 				*(rp++) = cpu_to_le32(0); /* bits 63-32 */
 				todo -= sg_dma_len(sg);
--
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx23885_buffer,
 				 vb.queue);
 		list_del(&buf->vb.queue);
@@ -1635,6 +1662,12 @@ static void do_cancel_buffers(struct cx2
 		wake_up(&buf->vb.done);
--
 	while ((long)size > 0) {
 		SetPageReserved(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
 		size -= PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((long)size > 0) {
 		ClearPageReserved(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
 		size -= PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (size > 0) {
 		page = kvirt_to_pa(pos);
 		if (remap_pfn_range(vma, start, page >> PAGE_SHIFT, PAGE_SIZE, PAGE_SHARED))
@@ -2486,6 +2513,12 @@ int cpia2_remap_buffer(struct camera_dat
 			size -= PAGE_SIZE;
 		else
--
 	while (1) {
 		if (frame->status == FRAME_READY)
 			return 0;
@@ -386,6 +391,12 @@ static int sync(struct camera_data *cam,
 			return -ERESTARTSYS;
 		if(!cam->present)
--
 			while (--i >= 0) {
 				kfree(cam->sbuf[i].data);
 				cam->sbuf[i].data = NULL;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
--
 	while (!suspend && !list_empty(&cap->pending_buf_q)) {
 		buf = fimc_pending_queue_pop(cap);
 		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!list_empty(&cap->active_buf_q)) {
 		buf = fimc_active_queue_pop(cap);
 		if (suspend)
 			fimc_pending_queue_add(cap, buf);
 		else
 			vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
--
 	while (sh--) {
 		u32 tmp = 1 << sh;
 		if (src >= tar * tmp) {
 			*shift = sh, *ratio = tmp;
 			return 0;
 		}
--
 	while ((me = media_entity_graph_walk_next(&graph))) {
 		if (media_entity_type(me) != MEDIA_ENT_T_V4L2_SUBDEV)
 			continue;
@@ -54,6 +59,12 @@ void fimc_pipeline_prepare(struct fimc_d
 			fimc->pipeline.sensor = sd;
 		else if (sd->grp_id == CSIS_GROUP_ID)
--
 	while (--i >= 0) {
 		if (IS_ERR_OR_NULL(fmd->camclk[i].clock))
 			continue;
 		clk_put(fmd->camclk[i].clock);
 		fmd->camclk[i].clock = NULL;
+		if (_cur < timeout) {
--
 	while (!kthread_should_stop()) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (!list_empty(&ctx->ref_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ctx->ref_queue)) {
 		mb_entry = list_entry((&ctx->ref_queue)->next,
 						struct s5p_mfc_buf, list);
 		mb_y_addr = vb2_dma_contig_plane_dma_addr(mb_entry->b, 0);
@@ -605,6 +610,12 @@ static void cleanup_ref_queue(struct s5p
 		ctx->ref_queue_cnt--;
--
 	while (!test_bit(new_ctx, &dev->ctx_work_bits)) {
 		new_ctx = (new_ctx + 1) % MFC_NUM_CONTEXTS;
 		if (++cnt > MFC_NUM_CONTEXTS) {
@@ -1102,6 +1107,12 @@ static int s5p_mfc_get_new_ctx(struct s5
 			spin_unlock_irqrestore(&dev->condlock, flags);
 			return -EAGAIN;
--
 	while (!list_empty(lh)) {
 		b = list_entry(lh->next, struct s5p_mfc_buf, list);
 		for (i = 0; i < b->b->num_planes; i++)
 			vb2_set_plane_payload(b->b, i, 0);
 		vb2_buffer_done(b->b, VB2_BUF_STATE_ERROR);
 		list_del(&b->list);
--
-	while (!list_empty(&ctx->dst_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ctx->dst_queue)) {
 		dst_buf = list_entry(ctx->dst_queue.next,
 				     struct s5p_mfc_buf, list);
 		mfc_debug(2, "Cleaning up buffer: %d\n",
@@ -188,6 +193,12 @@ static void s5p_mfc_handle_frame_all_ext
 
--
 	while (dev->ctx[ctx->num]) {
 		ctx->num++;
 		if (ctx->num >= MFC_NUM_CONTEXTS) {
@@ -671,6 +687,12 @@ static int s5p_mfc_open(struct file *fil
 			ret = -EBUSY;
 			goto err_no_ctx;
--
-	while (test_and_set_bit(0, &m_dev->hw_lock) != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (test_and_set_bit(0, &m_dev->hw_lock) != 0) {
 		/* Try and lock the HW */
 		/* Wait on the interrupt waitqueue */
 		ret = wait_event_interruptible_timeout(m_dev->queue,
@@ -1189,6 +1216,12 @@ static int s5p_mfc_suspend(struct device
 			mfc_err("Waiting for hardware to finish timed out\n");
--
 	while (!list_empty(&btv->capture)) {
 		item = list_entry(btv->capture.next, struct bttv_buffer, vb.queue);
 		list_del(&item->vb.queue);
 		item->vb.state = VIDEOBUF_ERROR;
 		wake_up(&item->vb.done);
+		if (_cur < timeout) {
--
 	while (!list_empty(&btv->vcapture)) {
 		item = list_entry(btv->vcapture.next, struct bttv_buffer, vb.queue);
 		list_del(&item->vb.queue);
 		item->vb.state = VIDEOBUF_ERROR;
 		wake_up(&item->vb.done);
+		if (_cur < timeout) {
--
 	while (skip_lines-- > 0) {
 		*(rp++) = cpu_to_le32(BT848_RISC_SKIP | BT848_RISC_SOL |
 				      BT848_RISC_EOL | bpl);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++)=cpu_to_le32(BT848_RISC_WRITE|
 						    sg_dma_len(sg));
 				*(rp++)=cpu_to_le32(sg_dma_address(sg));
 				todo -= sg_dma_len(sg);
 				sg++;
--
 			while (yoffset && yoffset >= sg_dma_len(ysg)) {
 				yoffset -= sg_dma_len(ysg);
 				ysg++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
--
 			while (uoffset && uoffset >= sg_dma_len(usg)) {
 				uoffset -= sg_dma_len(usg);
 				usg++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 			while (voffset && voffset >= sg_dma_len(vsg)) {
 				voffset -= sg_dma_len(vsg);
 				vsg++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-	while ((dev = pci_get_device(PCI_VENDOR_ID_INTEL,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((dev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_82441, dev))) {
 		unsigned char b;
 		pci_read_config_byte(dev, 0x53, &b);
 		if (bttv_debug)
 			pr_info("Host bridge: 82441FX Natoma, bufcon=0x%02x\n",
--
 	while (len > 1) {
 		reg = *data++;
 		ret |= vpx3220_fp_write(sd, reg, *data++);
 		len -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (incoming > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (incoming > 0) {
 		vino_queue_transfer(&vcs->fb_queue);
 
 		if (vino_queue_get_incoming(&vcs->fb_queue, &incoming)) {
@@ -2223,6 +2228,12 @@ static void vino_capture_stop(struct vin
 				"vino_queue_get_incoming() failed\n");
--
-	while (outgoing > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (outgoing > 0) {
 		vino_queue_remove(&vcs->fb_queue, &id);
 
 		if (vino_queue_get_outgoing(&vcs->fb_queue, &outgoing)) {
@@ -2238,6 +2254,12 @@ static void vino_capture_stop(struct vin
 				"vino_queue_get_outgoing() failed\n");
--
 	while ((intr = vino->intr_status)) {
 		fc_a = vino->a.field_counter >> 1;
 		fc_b = vino->b.field_counter >> 1;
@@ -2506,6 +2533,12 @@ static irqreturn_t vino_interrupt(int ir
 		loop++;
 #endif
--
 	while (first <= last) {
 		const struct v4l2_int_ioctl_desc *mid;
 
@@ -130,6 +135,12 @@ static v4l2_int_ioctl_func *find_ioctl(s
 			last = mid - 1;
 		else
--
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -133,6 +138,12 @@ void cx8800_vbi_timeout(unsigned long da
 		wake_up(&buf->vb.done);
 		printk("%s/0: [%p/%d] timeout - dma=0x%08lx\n", dev->core->name,
--
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -335,6 +340,12 @@ static void do_cancel_buffers(struct cx8
 		wake_up(&buf->vb.done);
 		dprintk(1,"[%p/%d] %s - dma=0x%08lx\n",
--
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++)=cpu_to_le32(RISC_WRITE|
 						    sg_dma_len(sg));
 				*(rp++)=cpu_to_le32(sg_dma_address(sg));
 				todo -= sg_dma_len(sg);
 				sg++;
--
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -1633,6 +1638,12 @@ static void cx8800_vid_timeout(unsigned
 		wake_up(&buf->vb.done);
 		printk("%s/0: [%p/%d] timeout - dma=0x%08lx\n", core->name,
--
 	while (*regs != 0x00) {
 		reg = *(regs++);
 		data = *(regs++);
@@ -160,6 +165,12 @@ static int saa711x_writeregs(struct v4l2
 		} else {
 			v4l2_dbg(1, debug, sd, "tried to access reserved reg 0x%02x\n", reg);
--
 	while (size > 0) {
 		unsigned long pfn;
 		pfn = virt_to_phys((void *) pos) >> PAGE_SHIFT;
@@ -921,6 +926,12 @@ static int omap_vout_mmap(struct file *f
 		start += PAGE_SIZE;
 		pos += PAGE_SIZE;
--
 		while (size > 0) {
 			SetPageReserved(virt_to_page(addr));
 			addr += PAGE_SIZE;
 			size -= PAGE_SIZE;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (size > 0) {
 		ClearPageReserved(virt_to_page(addr));
 		addr += PAGE_SIZE;
 		size -= PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (bytes < nbytes) {
 			unsigned int lo1, hi1, lo2, hi2;
 			unsigned char r, g, b;
@@ -333,12 +338,23 @@ static unsigned int qcam_read_bytes(stru
 				buf[bytes++] = g;
 				buf[bytes++] = r;
--
 		while (bytes < nbytes) {
 			unsigned int hi, lo;
 
@@ -364,6 +380,12 @@ get_fragment:
 					buf[n++] = rgb[0];
 				}
--
 		while ((mf.width > 2560 || mf.height > 1920) && shift < 4) {
 			/* Try 2560x1920, 1280x960, 640x480, 320x240 */
 			mf.width	= 2560 >> shift;
@@ -1097,6 +1102,12 @@ static int sh_mobile_ceu_get_formats(str
 			if (ret < 0)
 				return ret;
--
 	while (!ret && (is_smaller(cam_rect, rect) ||
 			is_inside(cam_rect, rect)) &&
 	       (cap.bounds.width > width || cap.bounds.height > height)) {
@@ -1355,6 +1371,12 @@ static int client_s_crop(struct soc_came
 		dev_geo(dev, "Camera S_CROP %d for %dx%d@%d:%d\n", ret,
 			cam_rect->width, cam_rect->height,
--
 	while ((width > tmp_w || height > tmp_h) &&
 	       tmp_w < max_width && tmp_h < max_height) {
 		tmp_w = min(2 * tmp_w, max_width);
@@ -1440,6 +1467,12 @@ static int client_s_fmt(struct soc_camer
 			dev_err(dev, "Client failed to set format: %d\n", ret);
 			return ret;
--
 	while (rv->reg != 0xff || rv->val != 0xff) {
 		ret = stk_sensor_outb(dev, rv->reg, rv->val);
 		if (ret != 0)
 			return ret;
 		rv++;
+		if (_cur < timeout) {
--
 	while (count++ < 100) {
 		if (!(readl(pcdev->base_emma + PRP_CNTL) & PRP_CNTL_SWRST))
 			return 0;
 		barrier();
 		udelay(1);
+		if (_cur < timeout) {
--
 	while (bytes_to_write >= free_write_space) {
 
 		if (timeout-- == 0) {
@@ -214,6 +219,12 @@ int saa7164_bus_set(struct saa7164_dev *
 			free_write_space = (curr_srp + bus->m_dwSizeSetRing) -
 				curr_swp;
--
 	while (size > 0) {
 		SetPageReserved(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
 		size -= PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((long) size > 0) {
 		ClearPageReserved(vmalloc_to_page((void *)adr));
 		adr += PAGE_SIZE;
 		size -= PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (size > 0) {
 		if (vm_insert_page(vma, start, vmalloc_to_page(pos))) {
 			PDEBUG(DBG_MMAP, "mmap: vm_insert_page failed");
@@ -1102,6 +1107,12 @@ static int usbvision_v4l2_mmap(struct fi
 		start += PAGE_SIZE;
 		pos += PAGE_SIZE;
--
 	while (len > 0) {
 		count = (len > max_len) ? max_len : len;
 		retval = usbvision_i2c_write_max4(usbvision, addr, buf_ptr, count);
@@ -438,6 +443,12 @@ static int usbvision_i2c_write(struct us
 			wrcount += count;
 		} else
--
 	while (len > 0) {
 		count = (len > 3) ? 4 : len;
 		retval = usbvision_i2c_read_max4(usbvision, addr, temp, count);
@@ -460,6 +476,12 @@ static int usbvision_i2c_read(struct usb
 			rdcount += count;
 		} else
--
 		while (size > 0) {
 			SetPageReserved(vmalloc_to_page((void *)adr));
 			adr += PAGE_SIZE;
 			size -= PAGE_SIZE;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while ((long) size > 0) {
 			ClearPageReserved(vmalloc_to_page((void *)adr));
 			adr += PAGE_SIZE;
 			size -= PAGE_SIZE;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (*len == -1) {
 		mchip_take_picture();
 		*len = mchip_compress_frame(meye.grab_fbuffer, gbufsize);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (size > 0) {
 		page = vmalloc_to_pfn((void *)pos);
 		if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED)) {
@@ -1643,6 +1681,12 @@ static int meye_mmap(struct file *file,
 			size -= PAGE_SIZE;
 		else
--
 	while (--i >= 0) {
 		if (buf->write)
 			set_page_dirty_lock(buf->pages[i]);
 		put_page(buf->pages[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (msg->addr != REG_TERM) {
 		int ret = cam_i2c_write(sd, msg->addr, msg->val);
 		if (ret)
 			return ret;
 		msg++;
+		if (_cur < timeout) {
--
 	while (i--) {
 		int err = abs(fsize->width - mf->width)
 				+ abs(fsize->height - mf->height);
@@ -489,6 +505,12 @@ static int sr030pc30_try_frame_size(stru
 			match = fsize;
 		}
--
-	while (!((next->reg == TCM825X_REG_TERM)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!((next->reg == TCM825X_REG_TERM)
 		 && (next->val == TCM825X_VAL_TERM))) {
 		err = tcm825x_write_reg(client, next->reg, next->val);
 		if (err) {
@@ -358,6 +363,12 @@ static int tcm825x_write_default_regs(st
 			return err;
--
 		while (--n >= 0) {
 			if (copy_in_user(&kclips->c, &uclips->c, sizeof(uclips->c)))
 				return -EFAULT;
@@ -73,6 +78,12 @@ static int get_v4l2_window32(struct v4l2
 				return -EFAULT;
 			uclips += 1;
--
 		while (--num_planes >= 0) {
 			ret = get_v4l2_plane32(uplane, uplane32, kp->memory);
 			if (ret)
 				return ret;
 			++uplane;
 			++uplane32;
--
 		while (--num_planes >= 0) {
 			ret = put_v4l2_plane32(uplane, uplane32, kp->memory);
 			if (ret)
 				return ret;
 			++uplane;
 			++uplane32;
--
 	while (--n >= 0) {
 		if (copy_in_user(kcontrols, ucontrols, sizeof(*ucontrols)))
 			return -EFAULT;
@@ -662,6 +700,12 @@ static int get_v4l2_ext_controls32(struc
 		}
 		ucontrols++;
--
 	while (--n >= 0) {
 		unsigned size = sizeof(*ucontrols);
 
@@ -701,6 +750,12 @@ static int put_v4l2_ext_controls32(struc
 			return -EFAULT;
 		ucontrols++;
--
 	while ((entity = media_entity_graph_walk_next(&graph))) {
 		if (media_entity_type(entity) == MEDIA_ENT_T_DEVNODE)
 			use += entity->use_count;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
-	while (!time_after(jiffies, timeout)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (!time_after(jiffies, timeout)) {
 		if (!busy(isp))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (omap3isp_stat_busy(&isp->isp_af)
 	    || omap3isp_stat_busy(&isp->isp_aewb)
 	    || omap3isp_stat_busy(&isp->isp_hist)
@@ -1029,6 +1056,12 @@ static int isp_suspend_modules(struct is
 			return 1;
 		}
--
-	while (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN,
 			       ISP_SYSSTATUS) & 0x1)) {
 		if (timeout++ > 10000) {
 			dev_alert(isp->dev, "cannot reset ISP\n");
 			return -ETIMEDOUT;
 		}
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		buf = isp_stat_buf_find_oldest(stat);
 		if (!buf) {
 			spin_unlock_irqrestore(&stat->isp->stat_lock, flags);
@@ -321,6 +326,12 @@ static struct ispstat_buffer *isp_stat_b
 			/* Buffer isn't corrupted. */
--
-		while (bytes_parsed < buffer_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bytes_parsed < buffer_size) {
 			u32 bytes_used = 0;
 
 			sav_eav = cx231xx_find_next_SAV_EAV(
@@ -416,6 +421,12 @@ static inline int cx231xx_isoc_copy(stru
 					p_buffer + bytes_parsed,/* p_buffer */
--
-		while (bytes_parsed < buffer_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bytes_parsed < buffer_size) {
 			u32 bytes_used = 0;
 
 			sav_eav = cx231xx_find_next_SAV_EAV(
@@ -502,6 +518,12 @@ static inline int cx231xx_bulk_copy(stru
 					p_buffer + bytes_parsed,/* p_buffer */
--
-		while (bytes_parsed < buffer_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bytes_parsed < buffer_size) {
 			u32 bytes_used = 0;
 
 			sav_eav = cx231xx_find_next_SAV_EAV(
@@ -154,6 +159,12 @@ static inline int cx231xx_isoc_vbi_copy(
 					p_buffer+bytes_parsed, /* p_buffer */
--
 		while (unsend_size - 4 > 0) {
 			pdata = pdata + 4;
 			ret = __usb_control_msg(dev, pipe,
@@ -388,6 +393,12 @@ int cx231xx_send_vendor_cmd(struct cx231
 				ven_req->wValue, ven_req->wIndex, pdata,
 				0x0004, HZ);
--
 	while (gpio->sleep >= 0) {
 		rc = cx231xx_set_gpio_value(dev, gpio->bit, gpio->val);
 		if (rc < 0)
@@ -641,6 +657,12 @@ int cx231xx_gpio_set(struct cx231xx *dev
 			msleep(gpio->sleep);
 
--
 	while (!(gpio&0x020000)) {
 		msleep(10);
 
@@ -336,6 +341,12 @@ static int waitForMciComplete(struct cx2
 			dprintk(3, "ERROR: Timeout - gpio=%x\n", gpio);
 			return -1;
--
 	while (ret >= 0 && time_is_after_jiffies(end)) {
 		ret = s5k6aa_read(client, REG_G_NEW_CFG_SYNC, &reg);
 		if (!reg)
 			return 0;
 		usleep_range(1000, 5000);
+		if (_cur < timeout) {
--
 	while (init != (u8)(end + 1)) {
 		if ((i % max_line) == 0) {
 			if (i > 0)
@@ -95,6 +100,12 @@ static void dump_reg_range(struct v4l2_s
 
 		init++;
--
 	while (regs->reg != 0xff) {
 		tvp5150_write(sd, regs->reg, regs->value);
 		regs++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (regs->reg != (u16)-1) {
 		tvp5150_write(sd, TVP5150_CONF_RAM_ADDR_HIGH, regs->reg >> 8);
 		tvp5150_write(sd, TVP5150_CONF_RAM_ADDR_LOW, regs->reg);
@@ -574,6 +601,12 @@ static int tvp5150_vdp_init(struct v4l2_
 			tvp5150_write(sd, TVP5150_VDP_CONF_RAM_DATA, regs->values[i]);
 
--
 	while (regs->reg != (u16)-1 ) {
 		for (line=regs->type.ini_line;line<=regs->type.end_line;line++) {
 			cap->service_lines[0][line] |= regs->type.vbi_type;
@@ -595,6 +633,12 @@ static int tvp5150_g_sliced_vbi_cap(stru
 		cap->service_set |= regs->type.vbi_type;
 
--
 	while (data[0] || data[1]) {
 		saa717x_write(sd, data[0], data[1]);
 		data += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (state->watch_stereo) {
 			if (msp_sleep(state, count ? 1000 : 5000))
 				goto restart;
 			if (count)
 				count--;
 			watch_stereo(client);
--
 		while (state->watch_stereo) {
 			if (msp_sleep(state, count ? 1000 : 5000))
 				goto restart;
 			if (count)
 				count--;
 			watch_stereo(client);
--
-		while (state->watch_stereo) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while (state->watch_stereo) {
 			watch_stereo(client);
 			if (msp_sleep(state, 5000))
 				goto restart;
+				if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, k))) {
 		for (i = res->start; i <= res->end; i++) {
 			if (request_irq(i, vpif_channel_isr, IRQF_DISABLED,
@@ -1716,6 +1721,12 @@ static __init int vpif_probe(struct plat
 			}
 		}
--
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i))) {
 		for (irq_num = res->start; irq_num <= res->end; irq_num++)
 			free_irq(irq_num,
 				 (void *)(&vpif_obj.dev[i]->channel_id));
 		i++;
+		if (_cur < timeout) {
--
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, k))) {
 		for (i = res->start; i <= res->end; i++) {
 			if (request_irq(i, vpif_channel_isr, IRQF_DISABLED,
@@ -2189,6 +2194,12 @@ static __init int vpif_probe(struct plat
 			}
 		}
--
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i))) {
 		for (irq_num = res->start; irq_num <= res->end; irq_num++)
 			free_irq(irq_num,
 				 (void *)(&vpif_obj.dev[i]->channel_id));
 		i++;
+		if (_cur < timeout) {
--
 	while (i < 3) {
 		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
 		if (!res) {
@@ -1103,6 +1108,12 @@ static int __init isif_probe(struct plat
 			break;
 		}
--
 	while (i >= 0) {
 		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
 		release_mem_region(res->start, resource_size(res));
 		i--;
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (i < 3) {
 		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
 		if (res)
 			release_mem_region(res->start, resource_size(res));
 		i++;
+		if (_cur < timeout) {
--
 	while (i) {
 		i--;
 		alloc_size = sg_dma_len(&dma->sglist[i]);
@@ -247,6 +252,12 @@ static void omap24xxcam_vbq_free_mmap_bu
 		} while (alloc_size -= PAGE_SIZE);
 		__free_pages(sg_page(&dma->sglist[i]),
 			     get_order(sg_dma_len(&dma->sglist[i])));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (size) {
 		order = get_order(size);
 		/*
@@ -311,6 +327,11 @@ static int omap24xxcam_vbq_alloc_mmap_bu
 		/* try to allocate as many contiguous pages as possible */
 		page = alloc_pages(GFP_KERNEL, order);
--
 		while (page == NULL) {
 			order--;
 			page = alloc_pages(GFP_KERNEL, order);
@@ -318,6 +339,12 @@ static int omap24xxcam_vbq_alloc_mmap_bu
 				err = -ENOMEM;
 				goto out;
--
 		} while (alloc_size -= PAGE_SIZE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (i) {
 		i--;
 		omap24xxcam_vbq_free_mmap_buffer(vbq->bufs[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (!(omap24xxcam_reg_in(cam->mmio_base, CAM_SYSSTATUS)
 		 & CAM_SYSSTATUS_RESETDONE)
 	       && --max_loop) {
 		ndelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (TVP7002_EOR != regs->reg) {
 		if (TVP7002_WRITE == regs->type)
 			tvp7002_write_err(sd, regs->reg, regs->value, &error);
 		regs++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (!(omap24xxcam_reg_in(base, CAMDMA_CCR(ch))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(omap24xxcam_reg_in(base, CAMDMA_CCR(ch))
 		 & CAMDMA_CCR_ENABLE)) {
 		if (ch == dmach) {
 			/* The previous transfer has ended and this one
@@ -151,6 +156,12 @@ static void omap24xxcam_dmahw_transfer_c
 			break;
--
 	while ((dma->free_dmach < NUM_CAMDMA_CHANNELS) &&
 	       (free_dmach < NUM_CAMDMA_CHANNELS)) {
 		dmach = (dma->next_dmach + dma->free_dmach)
@@ -276,6 +292,12 @@ static void omap24xxcam_dma_abort(struct
 			(*callback) (dma, csr, arg);
 			spin_lock(&dma->lock);
--
 	while (queued_sgdma > 0) {
 		sg_state = sgdma->sg_state + sgslot;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while ((sg_state->next_sglist < sg_state->sglen) &&
 		       !(sg_state->csr & csr_error)) {
 			const struct scatterlist *sglist;
@@ -486,9 +518,21 @@ void omap24xxcam_sgdma_process(struct om
 				expires = jiffies + HZ;
 				mod_timer(&sgdma->reset_timer, expires);
--
 	while (size > 0) {
 		int len = min(MAX_BUF_SIZE - 2, size);
 
@@ -149,6 +154,12 @@ int cx25840_loadfw(struct i2c_client *cl
 
 		size -= len;
--
 	while (msg->addr != REG_TERM) {
 		int ret = cam_i2c_write(sd, msg->addr, msg->val);
 
 		if (ret)
 			return ret;
 		msg++;
--
 	while (i--) {
 		int err = abs(fsize->width - mf->width)
 				+ abs(fsize->height - mf->height);
@@ -377,6 +393,12 @@ static int noon010_try_frame_size(struct
 			match = fsize;
 		}
--
-	while (*ids != V4L2_CTRL_MENU_IDS_END) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*ids != V4L2_CTRL_MENU_IDS_END) {
 		if (*ids++ == qmenu->index) {
 			strlcpy(qmenu->name, menu_items[qmenu->index],
 					sizeof(qmenu->name));
 			return 0;
 		}
--
-	while ((vals->reg_num != 0xff) || (vals->value != 0xff)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((vals->reg_num != 0xff) || (vals->value != 0xff)) {
 		ret = i2c_smbus_write_byte_data(client,
 						vals->reg_num, vals->value);
 		dev_vdbg(&client->dev, "array: 0x%02x, 0x%02x",
@@ -632,6 +637,12 @@ static int ov2640_write_array(struct i2c
 		if (ret < 0)
--
 	while (gpio->sleep >= 0) {
 		if (gpio->reg >= 0) {
 			rc = em28xx_write_reg_bits(dev,
@@ -887,6 +892,12 @@ int em28xx_gpio_set(struct em28xx *dev,
 			msleep(gpio->sleep);
 
--
 	while (len > 0) {
 		count = (len > maxLen) ? maxLen : len;
 		ret = em2800_i2c_send_max4(dev, addr, bufPtr, count);
@@ -115,6 +120,12 @@ static int em2800_i2c_send_bytes(void *d
 			wrcount += count;
 		} else
--
-	while (size > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size > 0) {
 		if (size > 16)
 			block = 16;
 		else
@@ -385,6 +401,12 @@ static int em28xx_i2c_eeprom(struct em28
 		}
--
 	while (--cnt > 0) {
 		ret = reg_r_12(gspca_dev, reg, index, 1);
 		if (ret == value)
 			return 0;
 		msleep(50);
+		if (_cur < timeout) {
--
 	while (data[i][0] != 0 || data[i][1] != 0 || data[i][2] != 0) {
 		ret = reg_w(gspca_dev, data[i][0], data[i][2], data[i][1]);
 		if (ret < 0)
 			return ret;
 		i++;
+		if (_cur < timeout) {
--
 		while (alrc >= 10 && sd->resetlevel < 63) {
 			sd->resetlevel++;
 			alrc /= 2;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 		while (ahrc >= 20 && sd->resetlevel > 0) {
 			sd->resetlevel--;
 			ahrc /= 2;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
--
 	while (--i >= 0) {
 		*p++ = reg++;
 		*p++ = *buffer++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (*p != 0) {
 		val[1] = *p++;
 		val[3] = *p++;
@@ -672,6 +688,12 @@ static void om6802_sensor_init(struct gs
 			if (!(byte & 0x01))
 				break;
--
-	while (read_indexs[i] != 0x00) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (read_indexs[i] != 0x00) {
 		test_byte = reg_r(gspca_dev, read_indexs[i]);
 		PDEBUG(D_STREAM, "Reg 0x%02x = 0x%02x", read_indexs[i],
 		       test_byte);
 		i++;
+		if (_cur < timeout) {
--
 	while (--n >= 0) {
 		reg_w(sd, regvals->reg, regvals->val);
 		regvals++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (--n >= 0) {
 		i2c_w(sd, regvals->reg, regvals->val);
 		regvals++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (gspca_dev->present && gspca_dev->streaming) {
 		/* request some data and then read it until we have
 		 * a complete frame. */
@@ -242,7 +247,12 @@ static void sq905_dostream(struct work_s
 		   we must finish reading an entire frame, otherwise the
 		   next time we stream we start reading in the middle of a
--
-		while (bytes_left > 0 && gspca_dev->present) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (bytes_left > 0 && gspca_dev->present) {
 			data_len = bytes_left > SQ905_MAX_TRANSFER ?
 				SQ905_MAX_TRANSFER : bytes_left;
 			ret = sq905_read_data(gspca_dev, buffer, data_len, 1);
@@ -273,6 +283,12 @@ static void sq905_dostream(struct work_s
 			    bytes_left == 0)
--
 	while (cx11646_fw1[i][1]) {
 		reg_w(gspca_dev, 0x006b, cx11646_fw1[i], 3);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (cx_sensor_init[i][0]) {
 		reg_w_val(gspca_dev, 0x00e5, cx_sensor_init[i][0]);
 		reg_r(gspca_dev, 0x00e8, 1);		/* -> 0x00 */
@@ -809,6 +825,12 @@ static void cx11646_init1(struct gspca_d
 			reg_r(gspca_dev, 0x00ed, 1);	/* -> 0x01 */
 		}
--
 	while (data[i][0] != 0 || data[i][1] != 0 || data[i][2] != 0) {
 		ret = reg_write(dev, data[i][0], data[i][2], data[i][1]);
 		if (ret < 0) {
@@ -1874,6 +1879,12 @@ static int write_vector(struct gspca_dev
 			return ret;
 		}
--
 	while (retry--) {
 		msleep(10);
 		reg_r(gspca_dev, 0x08);
@@ -596,6 +601,12 @@ static int i2c_w(struct gspca_dev *gspca
 				return -1;
 			return 0;
--
 	while (status != 0x0a && tries < 256) {
 		err_code = cam_get_response16(gspca_dev, 0x21, 0);
 		status = data[0];
 		tries++;
 		if (err_code < 0)
 			return err_code;
--
 	while (tries < 4) {
 		data[0] = 0x19;
 		data[1] = 0x00;
@@ -431,6 +447,12 @@ static int zero_the_pointer(struct gspca
 		tries++;
 		if (err_code < 0)
--
 	while (data[i][0] != 0) {
 		ret = reg_write(dev, data[i][0], data[i][2], data[i][1]);
 		if (ret < 0)
 			return ret;
 		i++;
+		if (_cur < timeout) {
--
 	while (--len >= 0) {
 		reg_w(gspca_dev, seq[0], seq[1]);
 		seq += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while ((*data)[0] != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((*data)[0] != 0) {
 		if ((*data)[0] != DELAY)
 			i2c_w8(gspca_dev, *data);
 		else
 			msleep((*data)[1]);
 		data++;
--
 	while (--len >= 0) {
 		reg_w(gspca_dev, seq[0], seq[1]);
 		seq += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while ((modeU < gspca_dev->cam.nmodes) || modeD >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((modeU < gspca_dev->cam.nmodes) || modeD >= 0) {
 		if (--modeD >= 0) {
 			if (gspca_dev->cam.cam_mode[modeD].pixelformat
 								== pixfmt)
@@ -1023,6 +1028,12 @@ static int gspca_get_mode(struct gspca_d
 								== pixfmt)
--
 	while (size > 0) {
 		page = vmalloc_to_page((void *) addr);
 		ret = vm_insert_page(vma, start, page);
@@ -1895,6 +1911,12 @@ static int dev_mmap(struct file *file, s
 		start += PAGE_SIZE;
 		addr += PAGE_SIZE;
--
 	while (--len >= 0) {
 		ov534_reg_write(gspca_dev, (*data)[0], (*data)[1]);
 		data++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (--len >= 0) {
 		if ((*data)[0] != 0xff) {
 			sccb_reg_write(gspca_dev, (*data)[0], (*data)[1]);
@@ -901,6 +917,12 @@ static void sccb_w_array(struct gspca_de
 			sccb_reg_write(gspca_dev, 0xff, 0x00);
 		}
--
 	while (retry--) {
 		reg_r(gspca_dev, ET_ClCK, 1);
 		if (gspca_dev->usb_buf[0] != 0)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (--ncmds > 0) {
 		cmd++;
 		*buf++ = cmd->reg;
 		*buf++ = cmd->val >> 8;
 		*buf++ = sensor->i2c_dum;
 		*buf++ = cmd->val;
--
 		while (--len > 0) {
 			cmd++;
 			*buf++ = cmd->bw_addr;
 			*buf++ = cmd->bw_addr >> 8;
 			*buf++ = cmd->bw_data;
+			if (_cur < timeout) {
--
 		while (startexp > MAX_EXP && sd->params.exposure.gain <
 		       sd->params.exposure.gainMode - 1) {
 			startexp = startexp >> 1;
 			++sd->params.exposure.gain;
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while (action->req) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (action->req) {
 		switch (action->req) {
 		case 0xa0:	/* write register */
 			reg_w(gspca_dev, action->val, action->idx);
@@ -5786,6 +5791,12 @@ static void usb_exchange(struct gspca_de
 		}
--
 	while (--len >= 0) {
 		reg_w(gspca_dev, (*data)[0], (*data)[1]);
 		data++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (--len >= 0) {
 		if ((*data)[0] != 0xff) {
 			sccb_write(gspca_dev, (*data)[0], (*data)[1]);
@@ -946,6 +962,12 @@ static void sccb_w_array(struct gspca_de
 			sccb_write(gspca_dev, 0xff, 0x00);
 		}
--
 	while (data[i][1] != 0) {
 		reg_w_val(dev, data[i][1], data[i][0]);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((*sensormap)[0]) {
 		gspca_dev->usb_buf[0] = (*sensormap)[1];
 		gspca_dev->usb_buf[1] = (*sensormap)[1] >> 8;
 		reg_w_buf(gspca_dev, (*sensormap)[0], 2);
 		sensormap++;
+		if (_cur < timeout) {
--
 	while ((*sensor)[0]) {
 		i2c_write(gspca_dev, (*sensor)[1], (*sensor)[0]);
 		sensor++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (++n < len) {
 		if (tbl[n].idx != 0xffff)
 			ctrl_out(gspca_dev, 0x40, 1, tbl[n].val, tbl[n].idx,
@@ -612,6 +617,12 @@ int keep_on_fetching_validx(struct gspca
 			break;
 		else
--
 	while (--ncmds >= 0) {
 		reg_w_riv(gspca_dev, data->req, data->idx, data->val);
 		data++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (--cnt > 0) {
 		/* With this we get the status, when return 0 it's all ok */
 		reg_r(gspca_dev, 0x06, 0x00, 1);
 		if (gspca_dev->usb_buf[0] == 0)
 			return;
 		msleep(10);
--
-	while (gspca_dev->present && gspca_dev->streaming) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (gspca_dev->present && gspca_dev->streaming) {
 		/* Request the header, which tells the size to download */
 		ret = usb_bulk_msg(gspca_dev->dev,
 				usb_rcvbulkpipe(gspca_dev->dev, 0x81),
@@ -169,7 +174,12 @@ static void sq905c_dostream(struct work_
 		packet_type = FIRST_PACKET;
--
-		while (bytes_left > 0 && gspca_dev->present) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (bytes_left > 0 && gspca_dev->present) {
 			data_len = bytes_left > SQ905C_MAX_TRANSFER ?
 				SQ905C_MAX_TRANSFER : bytes_left;
 			ret = usb_bulk_msg(gspca_dev->dev,
@@ -188,8 +198,20 @@ static void sq905c_dostream(struct work_
 				packet_type = INTER_PACKET;
--
 	while (len) {
 		int id, chunk_len;
 
@@ -478,6 +483,12 @@ frame_data:
 		}
 		data    += chunk_len;
--
-	while (vals->reg_num != 0xff) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (vals->reg_num != 0xff) {
 		int ret = i2c_smbus_write_byte_data(client,
 						    vals->reg_num,
 						    vals->value);
 		if (ret < 0)
 			return ret;
--
 	while (decinum % 3 == 0 && deciden % 3 == 0) {
 		deciden /= 3;
 		decinum /= 3;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (decinum % 2 == 0 && deciden % 2 == 0) {
 		decinum /= 2;
 		deciden /= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (deciden > 32) {
 		deciden /= 2;
 		decinum = (decinum + 1) / 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (((decinum | deciden) & 1) == 0) {
 		decinum >>= 1;
 		deciden >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (deciden > 32) {
 		deciden >>= 1;
 		decinum = (decinum + 1) >> 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (cnt <= 0) {
 			/*
 			 *	Don't copy too far
@@ -659,6 +719,12 @@ static int pms_capture(struct pms *dev,
 				return len ? len : -EFAULT;
 			buf += dt;
--
-		while (!w9966_i2c_getscl(cam)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while (!w9966_i2c_getscl(cam)) {
 			if (time_after(jiffies, timeout))
 				return -1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (dleft > 0) {
 		unsigned long tsize = (dleft > W9966_RBUFFER) ? W9966_RBUFFER : dleft;
 
@@ -799,6 +815,12 @@ static ssize_t w9966_v4l_read(struct fil
 		}
 		dest += tsize;
--
 	while (vals->reg_num != 0xff || vals->value != 0xff) {
 		int ret = ov7670_write(sd, vals->reg_num, vals->value);
 		if (ret < 0)
 			return ret;
 		vals++;
+		if (_cur < timeout) {
--
-	while (dev->status == STATUS_STREAMING) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (dev->status == STATUS_STREAMING) {
 
 		if (hdpvr_submit_buffers(dev)) {
 			v4l2_err(&dev->v4l2_dev, "couldn't submit buffers\n");
@@ -244,6 +249,12 @@ static void hdpvr_transmit_buffers(struc
 				!list_empty(&dev->free_buff_list) ||
--
-	while (buf && ++c < 500 &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (buf && ++c < 500 &&
 	       !usb_bulk_msg(dev->udev,
 			     usb_rcvbulkpipe(dev->udev,
 					     dev->bulk_in_endpointAddr),
@@ -340,6 +356,12 @@ static int hdpvr_stop_streaming(struct h
 			     BULK_URB_TIMEOUT)) {
--
-	while (1 != i2c_master_send(ir->c, &b, 1)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1 != i2c_master_send(ir->c, &b, 1)) {
 		if ((attempt++) < 10) {
 			/*
 			 * wait a bit for next attempt -
@@ -152,6 +157,12 @@ static int get_key_flydvb_trio(struct IR
 		i2cdprintk("send wake up byte to pic16C505 (IR chip)"
--
 	while (0 == (state & bit)) {
 		if (unlikely(0 == count)) {
 			printk("%s: dsp access wait timeout [bit=%s]\n",
@@ -686,6 +691,12 @@ static inline int saa_dsp_wait_bit(struc
 		saa_wait(DSP_DELAY);
 		state = saa_readb(SAA7135_DSP_RWSTATE);
--
 	while (count > 3) {
 		cx18_writel(cx, val4, dst);
 		count -= 4;
 		dst += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 				while (--i >= 0) {
 					kfree(cx->vbi.sliced_mpeg_data[i]);
 					cx->vbi.sliced_mpeg_data[i] = NULL;
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
--
 	while (!list_empty(&q_src->list)) {
 		mdl = list_first_entry(&q_src->list, struct cx18_mdl, list);
 		list_move_tail(&mdl->list, &q_dst->list);
@@ -227,6 +232,12 @@ static void cx18_queue_flush(struct cx18
 		mdl->skipped = 0;
 		mdl->curr_buf = NULL;
--
-		while (!list_empty(&mdl->buf_list)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&mdl->buf_list)) {
 			buf = list_first_entry(&mdl->buf_list,
 					       struct cx18_buffer, list);
 			list_move_tail(&buf->list, &s->buf_pool);
 			buf->bytesused = 0;
 			buf->readpos = 0;
--
-	while (!list_empty(&s->buf_pool)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&s->buf_pool)) {
 		buf = list_first_entry(&s->buf_pool, struct cx18_buffer, list);
 		list_del_init(&buf->list);
 
@@ -439,5 +466,11 @@ void cx18_stream_free(struct cx18_stream
 				s->buf_size, s->dma);
--
 	while (remaining >= sizeof(struct cx18_enc_idx_entry) &&
 	       idx->entries < V4L2_ENC_IDX_ENTRIES) {
 
@@ -779,6 +784,12 @@ static int _cx18_process_idx_data(struct
 
 		remaining -= sizeof(struct cx18_enc_idx_entry);
--
 	while (dlen) {
 		chunkCnt = 8;
 		if (chunkCnt > dlen) chunkCnt = dlen;
@@ -77,6 +82,12 @@ static int pvr2_encoder_write_words(stru
 		data += chunkCnt;
 		dlen -= chunkCnt;
--
 	while (dlen) {
 		chunkCnt = 16;
 		if (chunkCnt > dlen) chunkCnt = dlen;
@@ -127,6 +143,12 @@ static int pvr2_encoder_read_words(struc
 		data += chunkCnt;
 		dlen -= chunkCnt;
--
-	while ((bp = pvr2_stream_get_idle_buffer(cp->stream)) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((bp = pvr2_stream_get_idle_buffer(cp->stream)) != NULL) {
 		stat = pvr2_buffer_queue(bp);
 		if (stat < 0) {
 			pvr2_trace(PVR2_TRACE_DATA_FLOW,
@@ -176,6 +181,12 @@ static int pvr2_ioread_start(struct pvr2
 			pvr2_ioread_stop(cp);
--
 	} while (0); LOCK_GIVE(hdw->big_lock);
 	if ((ret = pvr2_hdw_wait(hdw,0)) < 0) return ret;
 	if (enable_flag) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
--
 		while ((st = hdw->master_state) != PVR2_STATE_RUN) {
 			if (st != PVR2_STATE_READY) return -EIO;
 			if ((ret = pvr2_hdw_wait(hdw,st)) < 0) return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (src[cnt] && (cnt + 1) < dst_max) {
 		dst[cnt] = src[cnt];
 		cnt++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (hdw->ctl_write_pend_flag || hdw->ctl_read_pend_flag) {
 		wait_for_completion(&hdw->ctl_done);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (ucnt < ccnt) {
 		lcnt = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while ((lcnt + ucnt < ccnt) && (buf[lcnt + ucnt] != '\n')) {
 			lcnt++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (sp->buffer_total_count < cnt) {
 			struct pvr2_buffer *bp;
 			bp = kmalloc(sizeof(*bp),GFP_KERNEL);
@@ -340,8 +345,19 @@ static int pvr2_stream_buffer_count(stru
 			sp->buffers[sp->buffer_total_count] = bp;
 			(sp->buffer_total_count)++;
--
 		while (sp->buffer_total_count > cnt) {
 			struct pvr2_buffer *bp;
 			bp = sp->buffers[sp->buffer_total_count - 1];
@@ -350,6 +366,12 @@ static int pvr2_stream_buffer_count(stru
 			(sp->buffer_total_count)--;
 			pvr2_buffer_done(bp);
--
 	while ((lp = sp->queued_list.next) != &sp->queued_list) {
 		bp1 = list_entry(lp,struct pvr2_buffer,list_overhead);
 		pvr2_buffer_wipe(bp1);
@@ -409,6 +436,12 @@ static void pvr2_stream_internal_flush(s
 		   here first. */
 		if (bp1->state != pvr2_buffer_state_queued) continue;
--
 		while ((bp = pvr2_stream_get_ready_buffer(sp)) != NULL) {
 			pvr2_buffer_set_idle(bp);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 			while (tcnt) {
 				bcnt = tcnt;
 				if (bcnt > sizeof(hdw->cmd_buffer)-1) {
@@ -430,6 +435,12 @@ static int pvr2_i2c_xfer(struct i2c_adap
 				}
 				offs += bcnt;
--
 			while (tcnt || wcnt) {
 				bcnt = tcnt;
 				if (bcnt > sizeof(hdw->cmd_buffer)-1) {
@@ -473,6 +489,12 @@ static int pvr2_i2c_xfer(struct i2c_adap
 				offs += bcnt;
 				tcnt -= bcnt;
--
 	while (!kthread_should_stop()) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((bp = pvr2_stream_get_idle_buffer(stream)) != NULL) {
 		ret = pvr2_buffer_queue(bp);
 		if (ret < 0) return ret;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (bufSize) {
 		if (!mMode) {
 			cnt = 0;
@@ -176,6 +181,12 @@ int pvr2_std_str_to_id(v4l2_std_id *idPt
 		if (cnt < bufSize) cnt++;
 		bufPtr += cnt;
--
 	while (count--) {
 		int val = hex_to_bin(*buf++);
 		if (val < 0 || val >= radix)
 			return -EINVAL;
 		result *= radix;
 		result += val;
--
 	while (count) {
 		for (bcnt = 0; bcnt < count; bcnt++) {
 			if (buf[bcnt] == '\n') break;
@@ -318,6 +334,12 @@ int pvr2_debugifc_docmd(struct pvr2_hdw
 		if (bcnt < count) bcnt++;
 		buf += bcnt;
--
 		while ((mp = pvr2_context_notify_first) != NULL) {
 			pvr2_context_set_notify(mp, 0);
 			pvr2_context_check(mp);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (Spur < BANDWIDTH) {
 			I += J;
 			Spur = mt2060_spurcalc(lo1+I,lo2+I,if2);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	while ((map[i].rfmax * 1000) < *freq) {
 		if (tda18271_debug & DBG_ADV)
 			tda_map("(%d) rfmax = %d < freq = %d, "
@@ -1037,6 +1042,12 @@ int tda18271_lookup_rf_band(struct dvb_f
 		if (map[i].rfmax == 0)
 			return -EINVAL;
--
 	while (reg_pair[i].reg || reg_pair[i].val) {
 		if (reg_pair[i].reg == reg) {
 			reg_pair[i].val &= ~mask;
@@ -184,6 +189,12 @@ static void set_reg_bits(struct reg_pair
 		}
 		i++;
--
 	while (reg_pair1[i].reg || reg_pair1[i].val) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (reg_pair2[j].reg || reg_pair2[j].val) {
 			if (reg_pair1[i].reg != reg_pair2[j].reg) {
 				j++;
@@ -203,8 +224,20 @@ static void copy_reg_bits(struct reg_pai
 			}
 			reg_pair2[j].val = reg_pair1[i].val;
--
-	while ((ret == 0) && (reg_pair[i].reg || reg_pair[i].val)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((ret == 0) && (reg_pair[i].reg || reg_pair[i].val)) {
 		ret = mxl5007t_write_reg(state,
 					 reg_pair[i].reg, reg_pair[i].val);
 		i++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 		while ((WatchDogTimer > 0) && (result == XC_RESULT_SUCCESS)) {
 			result = xc5000_readreg(priv, XREG_BUSY, (u16 *)buf);
 			if (result == XC_RESULT_SUCCESS) {
@@ -311,6 +316,12 @@ static int xc_write_reg(struct xc5000_pr
 					WatchDogTimer--;
 				}
--
 	while ((i2c_sequence[index] != 0xFF) ||
 		(i2c_sequence[index + 1] != 0xFF)) {
 		len = i2c_sequence[index] * 256 + i2c_sequence[index+1];
@@ -349,7 +365,12 @@ static int xc_load_i2c_sequence(struct d
 			buf[0] = i2c_sequence[index];
 			buf[1] = i2c_sequence[index + 1];
--
-			while (pos < len) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (pos < len) {
 				if ((len - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)
 					nbytes_to_send =
 						XC_MAX_I2C_WRITE_LENGTH;
@@ -366,9 +387,21 @@ static int xc_load_i2c_sequence(struct d
 					return result;
--
 	while ((lockState == 0) && (watchDogCount > 0)) {
 		xc_get_lock_status(priv, &lockState);
 		if (lockState != 1) {
 			xc_wait(5);
 			watchDogCount--;
 		}
--
 	while ((i2c_sequence[index] != 0xFF) ||
 		(i2c_sequence[index + 1] != 0xFF)) {
 		len = i2c_sequence[index] * 256 + i2c_sequence[index+1];
@@ -338,7 +343,12 @@ static int xc_load_i2c_sequence(struct d
 			buf[0] = i2c_sequence[index];
 			buf[1] = i2c_sequence[index + 1];
--
-			while (pos < len) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (pos < len) {
 				if ((len - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)
 					nbytes_to_send =
 						XC_MAX_I2C_WRITE_LENGTH;
@@ -355,9 +365,21 @@ static int xc_load_i2c_sequence(struct d
 					return result;
--
 	while ((lock_state == 0) && (watchdog_count > 0)) {
 		xc_get_lock_status(priv, &lock_state);
 		if (lock_state != 1) {
 			msleep(5);
 			watchdog_count--;
 		}
--
-	while (p < endp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (p < endp) {
 		__u32 type, size;
 		v4l2_std_id id;
 		__u16 int_freq = 0;
@@ -827,6 +865,12 @@ static int xc4000_fwupload(struct dvb_fr
 		priv->firm[n].int_freq = int_freq;
--
 	while (!kthread_should_stop()) {
 
 		spin_lock_irq(&raw->lock);
@@ -69,6 +74,12 @@ static int ir_raw_event_thread(void *dat
 			handler->decode(raw->dev, ev);
 		raw->prev_ev = ev;
--
 	while (next_one < size) {
 		next_zero = find_next_zero_bit_le(ldata, size, next_one + 1);
 		ev.pulse = false;
@@ -215,6 +220,12 @@ static void ite_decode_bytes(struct ite_
 			    (dev->rdev, &ev);
 		} else
--
-	while (n > 0 && dev->in_use) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n > 0 && dev->in_use) {
 		/* transmit the next sample */
 		is_pulse = !is_pulse;
 		remaining_us = *(txbuf++);
@@ -433,7 +449,12 @@ static int ite_tx_ir(struct rc_dev *rcde
 				      remaining_us);
--
 		/* repeat while the pulse is non-zero length */
-		while (remaining_us > 0 && dev->in_use) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (remaining_us > 0 && dev->in_use) {
 			if (remaining_us > max_rle_us)
 				next_rle_us = max_rle_us;
 
@@ -489,6 +510,18 @@ static int ite_tx_ir(struct rc_dev *rcde
 			/* now send the byte through the FIFO */
--
 	 * TX ones while the transmission is still being performed! */
 	fifo_remaining = dev->params.get_tx_used_slots(dev);
 	remaining_us = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (fifo_remaining > 0) {
 		fifo_remaining--;
 		last_idx--;
 		last_idx &= (ITE_TX_FIFO_LEN - 1);
 		remaining_us += last_sent[last_idx];
+		if (_cur < timeout) {
--
 	while (fifo > 0 && buf_size > 0) {
 		*(buf++) = inb(dev->cir_addr + IT87_DR);
 		fifo--;
 		read++;
 		buf_size--;
+		if (_cur < timeout) {
--
 	while (fifo > 0 && buf_size > 0) {
 		*(buf++) = inb(dev->cir_addr + IT8708_C0DR);
 		fifo--;
 		read++;
 		buf_size--;
+		if (_cur < timeout) {
--
 	while (fifo > 0 && buf_size > 0) {
 		*(buf++) = it8709_rm(dev, IT8709_FIFO + read);
 		fifo--;
 		read++;
 		buf_size--;
+		if (_cur < timeout) {
--
 	while (start <= end) {
 		mid = (start + end) / 2;
 		if (rc_map->scan[mid].scancode < scancode)
@@ -422,6 +427,12 @@ static unsigned int ir_lookup_by_scancod
 			end = mid - 1;
 		else
--
 	while (inb(data->sbase + WBCIR_REG_SP3_LSR) & WBCIR_RX_AVAIL) {
 		irdata = inb(data->sbase + WBCIR_REG_SP3_RXDATA);
 		if (data->rxstate == WBCIR_RXSTATE_ERROR)
@@ -360,6 +365,12 @@ wbcir_irq_rx(struct wbcir_data *data, st
 		rawir.pulse = irdata & 0x80 ? false : true;
 		rawir.duration = US_TO_NS((irdata & 0x7F) * 10);
--
 	while (data->txstate == WBCIR_TXSTATE_ACTIVE) {
 		spin_unlock_irqrestore(&data->spinlock, flags);
 		wait_event(data->txwaitq, data->txstate != WBCIR_TXSTATE_ACTIVE);
 		spin_lock_irqsave(&data->spinlock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY_IDX)) {
 			val = nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY);
 			nvt_dbg("setting wake up key: 0x%x", val);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (!list_empty(&coredev->clients)) {
 		client = (struct smscore_client_t *) coredev->clients.next;
 		client->onremove_handler(client->context);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (size && rc >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size && rc >= 0) {
 		struct SmsDataDownload_ST *DataMsg =
 			(struct SmsDataDownload_ST *) msg;
 		int payload_size = min((int) size, SMS_MAX_PAYLOAD_SIZE);
@@ -571,6 +587,12 @@ static int smscore_load_firmware_family2
 		payload += payload_size;
--
 	while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!list_empty(&coredev->buffers)) {
 			cb = (struct smscore_buffer_t *) coredev->buffers.next;
 			list_del(&cb->entry);
 			kfree(cb);
 			num_buffers++;
+			if (_cur < timeout) {
--
-	while (!list_empty(&client->idlist)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&client->idlist)) {
 		struct smscore_idlist_t *identry =
 			(struct smscore_idlist_t *) client->idlist.next;
 		list_del(&identry->entry);
 		kfree(identry);
+		if (_cur < timeout) {
--
 	while (!list_empty(&g_smscore_notifyees)) {
 		struct smscore_device_notifyee_t *notifyee =
 			(struct smscore_device_notifyee_t *)
@@ -1619,10 +1668,21 @@ static void __exit smscore_module_exit(v
 
 		list_del(&notifyee->entry);
--
 	while (!list_empty(&g_smscore_registry)) {
 		struct smscore_registry_entry_t *entry =
 			(struct smscore_registry_entry_t *)
@@ -1630,6 +1690,12 @@ static void __exit smscore_module_exit(v
 
 		list_del(&entry->entry);
--
-	while (size >= smsdev->func->cur_blksize) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size >= smsdev->func->cur_blksize) {
 		ret = sdio_memcpy_toio(smsdev->func, SMSSDIO_DATA,
 					buffer, smsdev->func->cur_blksize);
 		if (ret)
@@ -95,6 +100,12 @@ static int smssdio_sendrequest(void *con
 
--
-			while (size) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (size) {
 				ret = sdio_memcpy_fromio(smsdev->func,
 						  buffer, SMSSDIO_DATA,
 						  smsdev->func->cur_blksize);
@@ -214,6 +230,12 @@ static void smssdio_interrupt(struct sdi
 					size -= smsdev->func->cur_blksize;
--
-	while (mantis->last_block != mantis->busy_block) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (mantis->last_block != mantis->busy_block) {
 		dprintk(MANTIS_DEBUG, 1, "last block=[%d] finished block=[%d]",
 			mantis->last_block, mantis->busy_block);
 
 		(config->ts_size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)
 		(&mantis->demux, &mantis->buf_cpu[mantis->last_block * MANTIS_BLOCK_BYTES], MANTIS_BLOCK_BYTES);
--
 	while (i < num) {
 		/* Byte MODE */
 		if ((config->i2c_mode & MANTIS_BYTE_MODE) &&
@@ -196,6 +201,12 @@ static int mantis_i2c_xfer(struct i2c_ad
 				goto bail_out;
 		}
--
-	while (dev->EventQueueReadIndex != dev->EventQueueWriteIndex) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (dev->EventQueueReadIndex != dev->EventQueueWriteIndex) {
 		struct EVENT_BUFFER Event =
 			dev->EventQueue[dev->EventQueueReadIndex];
 		dev->EventQueueReadIndex =
@@ -86,6 +91,12 @@ static void event_tasklet(unsigned long
 		if ((Event.UARTStatus & 0x02) && (dev->RxEventNotify))
--
 	while (i > 0) {
 		i--;
 		spin_lock(&dev->channel[i].state_lock);
@@ -243,6 +259,12 @@ static irqreturn_t irq_handler(int irq,
 			}
 		}
--
-	while (Length > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (Length > 0) {
 		if (Flags & DF_SWAP32)
 			*ptr = 0x471FFF10;
 		else
 			*ptr = 0x10FF1F47;
 		ptr += (188 / 4);
--
-	while (left) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (left) {
 		if (wait_event_interruptible(
 			    dev->tsin_rbuf.queue,
 			    dvb_ringbuffer_avail(&dev->tsin_rbuf) > 0) < 0)
@@ -84,6 +89,12 @@ static ssize_t ts_read(struct file *file
 		dvb_ringbuffer_read_user(&dev->tsin_rbuf, buf, avail);
--
 	while (len) {
 		*p = swab32(*p);
 		p++;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (len >= 188) {
 			if (memcmp(buf, fill_ts, sizeof fill_ts) != 0) {
 				if (dvb_ringbuffer_free(&dev->tsin_rbuf) >= 188) {
@@ -161,6 +188,12 @@ void *tsin_exchange(void *priv, void *bu
 #endif
 			buf += 188;
--
 	while (dst_ca_comm_err < RETRIES) {
 		dprintk(verbose, DST_CA_NOTICE, 1, " Put Command");
 		if (dst_ci_command(state, data, ca_string, len, read)) {	// If error
@@ -141,6 +146,12 @@ static int dst_put_ci(struct dst_state *
 		} else {
 			break;
--
 	while (card->bt->last_block != card->bt->finished_block) {
 		(card->bt->TS_Size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)
 			(&card->demux,
@@ -63,6 +68,12 @@ static void dvb_bt8xx_task(unsigned long
 			 card->bt->block_bytes);
 		card->bt->last_block = (card->bt->last_block + 1) %
--
 	while (bt->line_bytes > 4095) {
 		bt->line_bytes >>= 1;
 		bt->line_count <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 			while (p-- != tab) {
 				vfree(p[0]->data);
 				p[0]->data = NULL;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 	while (c < count && (p->mpeg == 0 ||
 			     (p->mpeg == 1 && p->found < 7) ||
 			     (p->mpeg == 2 && p->found < 9))
@@ -247,6 +252,12 @@ int av7110_ipack_instant_repack (const u
 			}
 			break;
--
 				while (c < count && p->found < 14) {
 					p->pts[p->found - 9] = buf[c];
 					write_ipack(p, buf + c, 1);
 					c++;
 					p->found++;
+					if (_cur < timeout) {
--
 				while (!p->which && c < count &&
 				       p->check == 0xff){
 					p->check = buf[c];
@@ -296,6 +323,12 @@ int av7110_ipack_instant_repack (const u
 					c++;
 					p->found++;
--
 						while (c < count && p->which < 7) {
 							p->pts[p->which - 2] = buf[c];
 							write_ipack(p, buf + c, 1);
@@ -349,10 +387,21 @@ int av7110_ipack_instant_repack (const u
 							p->found++;
 							p->which++;
--
 						while (c < count && p->which < 12) {
 							if (p->which < 7)
 								p->pts[p->which - 2] = buf[c];
@@ -361,6 +410,12 @@ int av7110_ipack_instant_repack (const u
 							p->found++;
 							p->which++;
--
 			while (c < count && p->found < p->plength + 6) {
 				l = count - c;
 				if (l + p->found > p->plength + 6)
@@ -377,6 +437,12 @@ int av7110_ipack_instant_repack (const u
 				write_ipack(p, buf + c, l);
 				p->found += l;
--
 	while (*data != 0xff) {
 		i2c_writereg(&budget->i2c_adap, 0x4a, *data, *(data + 1));
 		data += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (todo > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (todo > 0) {
 		if (dvb_ringbuffer_free(rbuf) < 2048) {
 			if (wait_event_interruptible(rbuf->queue,
 						     (dvb_ringbuffer_free(rbuf) >= 2048)))
@@ -414,6 +419,12 @@ static inline long aux_ring_buffer_write
 		dvb_ringbuffer_write(rbuf, buf, free);
--
 	while (todo >= TS_SIZE) {
 		if (!FREE_COND_TS) {
 			if (nonblock)
@@ -472,6 +488,12 @@ static ssize_t ts_play(struct av7110 *av
 		write_ts_to_decoder(av7110, type, kb, TS_SIZE);
 		todo -= TS_SIZE;
--
-	while (todo > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (todo > 0) {
 		if (!FREE_COND) {
 			if (nonblock)
 				return count - todo;
@@ -510,6 +537,12 @@ static ssize_t dvb_play(struct av7110 *a
 					    &av7110->ipack[type]);
--
-	while (todo > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (todo > 0) {
 		if (!FREE_COND) {
 			if (nonblock)
 				return count - todo;
@@ -540,6 +578,12 @@ static ssize_t dvb_play_kernel(struct av
 		av7110_ipack_instant_repack(buf, n, &av7110->ipack[type]);
--
 	while (todo > 0) {
 		if (dvb_ringbuffer_free(&av7110->aout) < 20 * 1024) {
 			if (nonblock)
@@ -572,6 +621,12 @@ static ssize_t dvb_aplay(struct av7110 *
 					    &av7110->ipack[type]);
 		todo -= n;
--
 	while (c < length - 3 && !found) {
 		if (buf[c] == 0x00 && buf[c + 1] == 0x00 &&
 		    buf[c + 2] == 0x01) {
@@ -626,6 +686,12 @@ static int find_pes_header(u8 const *buf
 			}
 		} else
--
 	while (c < length) {
 		c2 = find_pes_header(buf + c + add, length - c - add, &p->frags);
 		if (c2 >= 0) {
@@ -734,6 +805,12 @@ void av7110_p2t_write(u8 const *buf, lon
 			p->pos = rest;
 			c = length;
--
 	while (c < length) {
 		memset(obuf, 0, TS_SIZE);
 		if (length - c >= (TS_SIZE - 4)){
@@ -817,6 +899,12 @@ static void p_to_t(u8 const *buf, long i
 		}
 		feed->cb.ts(obuf, 188, NULL, 0, &feed->feed.ts, DMX_OK);
--
 	while (!kthread_should_stop()) {
 		try_to_freeze();
 
@@ -328,6 +333,12 @@ static int pt1_thread(void *data)
 			if (++table_index >= pt1_nr_tables)
 				table_index = 0;
--
 	while (i < pt1_nr_tables) {
 		ret = pt1_init_table(pt1, &tables[i], &pfn);
 		if (ret)
 			goto err;
 		tables[i - 1].page->next_pfn = cpu_to_le32(pfn);
 		i++;
--
 			while (len--) {
 				next_msg->buf[len] = word;
 				word >>= 8;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
--
-	while (ret >= 0 && ret != blen && try < 3) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ret >= 0 && ret != blen && try < 3) {
 		ret = usb_control_msg(d->udev,
 			usb_rcvctrlpipe(d->udev,0),
 			req,
@@ -67,6 +72,12 @@ int gp8psk_usb_in_op(struct dvb_usb_devi
 			2000);
--
 	while (ptr[0] != 0xff) {
 		u16 buflen = ptr[0] + 4;
 		if (ptr + buflen >= fw->data + fw->size) {
@@ -149,6 +165,12 @@ static int gp8psk_load_bcm4500fw(struct
 			goto out_free;
 		}
--
 		while (stream->buf_num) {
 			stream->buf_num--;
 			deb_mem("freeing buffer %d\n",stream->buf_num);
 			usb_free_coherent(stream->udev, stream->buf_size,
 					  stream->buf_list[stream->buf_num],
 					  stream->dma_addr[stream->buf_num]);
--
 	while (i < num) {
 		if (msg[i].addr == af9015_af9013_config[0].demod_address ||
 		    msg[i].addr == af9015_af9013_config[1].demod_address) {
@@ -342,6 +347,12 @@ Due to that the only way to select corre
 		if (ret)
 			goto error;
--
-	while ((ret = dvb_usb_get_hexline(fw, &hx, &pos)) > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((ret = dvb_usb_get_hexline(fw, &hx, &pos)) > 0) {
 		deb_fwdata("writing to address 0x%08x (buffer: 0x%02x %02x)\n",
 				hx.addr, hx.len, hx.chk);
 
@@ -500,6 +505,12 @@ int dib0700_download_firmware(struct usb
 			err("firmware download failed at %d with %d",pos,ret);
--
 	while (i < num) {
 		if (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {
 			if (msg[i].addr == ec168_ec100_config.demod_address) {
@@ -173,6 +178,12 @@ static int ec168_i2c_xfer(struct i2c_ada
 		if (ret)
 			goto error;
--
-		while (rc_seq->address) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (rc_seq->address) {
 			if ((ret = m920x_write(d->udev, M9206_CORE,
 					       rc_seq->data,
 					       rc_seq->address)) != 0) {
@@ -80,6 +85,12 @@ static int m920x_init(struct dvb_usb_dev
 			}
--
 	while (left) {
 		if (input->cbuf == idx)
 			return count - left;
@@ -534,6 +539,12 @@ static ssize_t ddb_input_read(struct ddb
 		left -= free;
 		ddbwritel((input->cbuf << 11) | (input->coff >> 7),
--
-		while (input->cbuf != ((input->stat >> 11) & 0x1f)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (input->cbuf != ((input->stat >> 11) & 0x1f)
 		       || (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))) {
 			dvb_dmx_swfilter_packets(&input->demux,
 						 input->vbuf[input->cbuf],
@@ -1016,7 +1032,13 @@ static void input_tasklet(unsigned long
 			ddbwritel((input->cbuf << 11),
--
 	while (wlen > 4) {
 		/* FIXME: check for big-endian */
 		data = swab32(*(u32 *)wbuf);
@@ -1354,6 +1381,12 @@ static int flashio(struct ddb *dev, u8 *
 		ddbwritel(data, SPI_DATA);
 		while (ddbreadl(SPI_CONTROL) & 0x0004)
 			;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
--
 	while (wlen) {
 		data <<= 8;
 		data |= *wbuf;
 		wlen--;
 		wbuf++;
+		if (_cur < timeout) {
--
 	while (rlen > 4) {
 		ddbwritel(0xffffffff, SPI_DATA);
 		while (ddbreadl(SPI_CONTROL) & 0x0004)
@@ -1390,6 +1439,12 @@ static int flashio(struct ddb *dev, u8 *
 		*(u32 *) rbuf = swab32(data);
 		rbuf += 4;
 		rlen -= 4;
+		if (_cur < timeout) {
--
 	while (rlen > 0) {
 		*rbuf = ((data >> 24) & 0xff);
 		data <<= 8;
 		rbuf++;
 		rlen--;
+		if (_cur < timeout) {
--
 	while(dvb_ringbuffer_avail(rbuf) > DVB_RINGBUFFER_PKTHDRSIZE) {
 		if (DVB_RINGBUFFER_PEEK(rbuf, 2) == PKT_DISPOSED) {
 			pktlen = DVB_RINGBUFFER_PEEK(rbuf, 0) << 8;
@@ -249,6 +254,12 @@ void dvb_ringbuffer_pkt_dispose(struct d
 			// first packet is not disposed, so we stop cleaning now
 			break;
--
 	while((dvb_ringbuffer_avail(rbuf) - consumed) > DVB_RINGBUFFER_PKTHDRSIZE) {
 
 		curpktlen = rbuf->data[idx] << 8;
@@ -281,6 +297,12 @@ ssize_t dvb_ringbuffer_pkt_next(struct d
 
 		consumed += curpktlen + DVB_RINGBUFFER_PKTHDRSIZE;
--
 	while (count--) {
 		if (buf[0] == 0x47)
 			dvb_dmx_swfilter_packet(demux, buf);
 		buf += 188;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while ((!end_chain) && (address < 0x1000)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while ((!end_chain) && (address < 0x1000)) {
 		if ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,
 							&tupleLength, tuple)) < 0)
 			return status;
@@ -529,6 +534,12 @@ static int dvb_ca_en50221_parse_attribut
 				tupleLength);
--
 	while (!kthread_should_stop()) {
 		/* sleep for a bit */
 		if (!ca->wakeup) {
@@ -999,6 +1015,11 @@ static int dvb_ca_en50221_thread(void *d
 			mutex_lock(&ca->slot_info[slot].slot_lock);
 
--
 			while (dvb_ca_en50221_check_camstatus(ca, slot)) {
 				/* clear down an old CI slot if necessary */
 				if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE)
@@ -1012,6 +1033,12 @@ static int dvb_ca_en50221_thread(void *d
 				/* we've handled one CAMCHANGE */
 				dvb_ca_en50221_thread_update_delay(ca);
--
 	while (fragpos < count) {
 		fraglen = ca->slot_info[slot].link_buf_size - 2;
 		if ((count - fragpos) < fraglen)
@@ -1344,6 +1382,12 @@ static ssize_t dvb_ca_en50221_io_write(s
 		}
 
--
 	while ((slot_count < ca->slot_count) && (!found)) {
 		if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
 			goto nextslot;
@@ -1392,6 +1441,12 @@ static int dvb_ca_en50221_io_read_condit
 nextslot:
 		slot = (slot + 1) % ca->slot_count;
--
 	while ( !found  && c < count){
 		u8 *b = mbuf+c;
 
@@ -358,6 +363,12 @@ int dvb_filter_get_ac3info(u8 *mbuf, int
 		else {
 			c++;
--
 	while (len>=184) {
 		buf[3]=0x10|((p2ts->cc++)&0x0f);
 		memcpy(buf+4, pes, 184);
@@ -586,6 +602,12 @@ int dvb_filter_pes2ts(struct dvb_filter_
 			return ret;
 		len-=184; pes+=184;
--
 	while(!ready) {
 		/* calculate the lnb_drift */
 		fepriv->lnb_drift = fepriv->auto_step * fepriv->step_size;
@@ -333,6 +338,12 @@ static int dvb_frontend_swzigzag_autotun
 		}
 
--
-			while (mferetry-- && (mfedev->users != -1 ||
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (mferetry-- && (mfedev->users != -1 ||
 					mfepriv->thread != NULL)) {
 				if(msleep_interruptible(500)) {
 					if(signal_pending(current))
 						return -EINTR;
 				}
--
 	while (id < DVB_MAX_IDS) {
 		struct dvb_device *dev;
 		list_for_each_entry(dev, &adap->device_list, list_head)
@@ -183,6 +188,12 @@ static int dvbdev_get_free_id (struct dv
 		return id;
 skip:
--
 	while (num < DVB_MAX_ADAPTERS) {
 		if (dvbdev_check_free_adapter_num(num))
 			return num;
 		num++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (len--) {
 		crc ^= *buf++;
 		crc ^= (u8)crc >> 4;
 		tmp = (u8)crc;
 		crc ^= (tmp ^ (tmp << 1)) << 4;
+		if (_cur < timeout) {
--
-	while (length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (length) {
 		switch (dec->packet_state) {
 
 		case 0:
@@ -729,6 +745,12 @@ static void ttusb_dec_process_urb_frame(
 			       __func__);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		spin_lock_irqsave(&dec->urb_frame_list_lock, flags);
 		if ((item = dec->urb_frame_list.next) != &dec->urb_frame_list) {
 			frame = list_entry(item, struct urb_frame,
@@ -754,6 +781,12 @@ static void ttusb_dec_process_urb_frame_
 
--
 				while (i) {
 					usb_kill_urb(dec->iso_urb[i - 1]);
 					i--;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
--
 	while ((item = dec->urb_frame_list.next) != &dec->urb_frame_list) {
 		frame = list_entry(item, struct urb_frame, urb_frame_list);
 		list_del(&frame->urb_frame_list);
 		kfree(frame);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((item = dec->filter_info_list.next) != &dec->filter_info_list) {
 		finfo = list_entry(item, struct filter_info, filter_info_list);
 		list_del(&finfo->filter_info_list);
 		kfree(finfo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (l >= 190) {
 		if (*b == 0xff) {
 			switch (*(b+1) & 0x03) {
@@ -340,6 +345,12 @@ static void flexcop_usb_process_frame(st
 			deb_ts("wrong header\n");
 			l = 0;
--
 	while (len != 0) {
 		bytes_to_transfer = len > 4 ? 4 : len;
 
@@ -160,6 +165,12 @@ int flexcop_i2c_request(struct flexcop_i
 		buf  += bytes_to_transfer;
 		addr += bytes_to_transfer;
--
 	while (read_pos < length) {
 		c->operand[write_pos++] = msg[read_pos++];
 		c->operand[write_pos++] = msg[read_pos++];
@@ -1185,6 +1190,12 @@ int avc_ca_pmt(struct firedtv *fdtv, cha
 			read_pos += es_info_length;
 			write_pos += es_info_length;
--
 	while ((position == 0) && (i < 8)) {
 		position = ((*mask) >> i) & 0x01;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while ((imax - imin) > 1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while ((imax - imin) > 1) {
 			i = (imax + imin) >> 1;
 
 			if (INRANGE(lookup->table[imin].regval,
@@ -638,6 +654,12 @@ static s32 stv0900_get_rf_level(struct s
 				imax = i;
--
-				while ((imax - imin) > 1) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+						while ((imax - imin) > 1) {
 					i = (imax + imin) >> 1;
 					if (INRANGE(lookup->table[imin].regval,
 						    regval,
@@ -726,6 +753,12 @@ static s32 stv0900_carr_get_quality(stru
 						imax = i;
--
 	while ((timer < time_out) && (lock == 0)) {
 		dmd_state = stv0900_get_bits(intp, HEADER_MODE);
 		dprintk("Demod State = %d\n", dmd_state);
@@ -869,6 +907,12 @@ int stv0900_get_demod_lock(struct stv090
 			msleep(10);
 
--
 	while (i < NbData) {
 		while (stv0900_get_bits(intp, FIFO_FULL))
 			;/* checkpatch complains */
 		stv0900_write_reg(intp, DISTXDATA, data[i]);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((stv0900_get_bits(intp, TX_IDLE) != 1) && (i < 10)) {
 		msleep(10);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((stv0900_get_bits(intp, RX_END) != 1) && (i < 10)) {
 		msleep(10);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (l) {
 		r = *n++;
 
@@ -150,6 +155,12 @@ static void dib7000p_write_tab(struct di
 			r++;
 		} while (--l);
 		l = *n++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (n_overflow == 1 && i) {
 		n_overflow = (dib7000p_read_word(state, 1984) >> 1) & 0x1;
 		i--;
 		if (i == 0)
 			dprintk("Tuner ITF: write busy (overflow)");
+			if (_cur < timeout) {
--
 	while (n_overflow == 1 && i) {
 		n_overflow = (dib7000p_read_word(state, 1984) >> 1) & 0x1;
 		i--;
 		if (i == 0)
 			dprintk("TunerITF: read busy (overflow)");
+			if (_cur < timeout) {
--
 	while (n_empty == 1 && i) {
 		n_empty = dib7000p_read_word(state, 1984) & 0x1;
 		i--;
 		if (i == 0)
 			dprintk("TunerITF: read busy (empty)");
+			if (_cur < timeout) {
--
-		while (pos < fw->size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (pos < fw->size) {
 
 			if ((fw->size - pos) > wlen)
 				cnt = wlen;
@@ -556,6 +561,12 @@ static int tda10048_firmware_upload(stru
 				&fw->data[pos], cnt);
--
 	while ((i < 10) && (ret != 0)) {
 		ret = ((stv6110_read_reg(fe, RSTV6110_STAT1)) & 0x02);
 		mdelay(1);	/* wait for LPF auto calibration */
 		i++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while ((i < 10) && (ret != 0)) {
 		ret = ((stv6110_read_reg(fe, RSTV6110_STAT1)) & 0x04);
 		msleep(1); /* wait for VCO auto calibration */
 		i++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while ((si21_readreg(state, LNB_CTRL_REG_1) & 0x8) == 8) {
 		if (jiffies - start > timeout) {
 			dprintk("%s: timeout!!\n", __func__);
 			return -ETIMEDOUT;
 		}
 		msleep(10);
--
 	while (counter < 20) {
 		nxt200x_readbytes(state, 0x31, &buf, 1);
 		if (buf & stopval)
 			return;
 		msleep(10);
 		counter++;
--
 	while (counter < 20) {
 		nxt200x_readbytes(state, 0x21, buf, 1);
 		if (buf[0] == 0)
 			return;
 		msleep(10);
 		counter++;
--
 			while (count < 20) {
 				i2c_readbytes(state, data[0], &buf, 1);
 				if (buf & 0x40)
 					return 0;
 				msleep(100);
 				count++;
--
 			while (count < 20) {
 				nxt200x_readbytes(state, 0x21, &buf, 1);
 				if ((buf & 0x80)== 0x00)
 					return 0;
 				msleep(100);
 				count++;
--
 	while (1) {
 		r=*tab++;
 		m=*tab++;
@@ -124,6 +129,12 @@ static void tda10023_writetab(struct tda
 		}
 		else
--
 	while (jiffies - start < timeout &&
 	       !(tda8083_readreg(state, 0x02) & 0x80))
 	{
 		msleep(50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (l) {
 			r = *n++;
 			do {
@@ -847,6 +852,12 @@ static int dib8000_reset(struct dvb_fron
 				r++;
 			} while (--l);
 			l = *n++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (BlockSize > 0) {
 		u16 Chunk = BlockSize > CHUNK_SIZE ? CHUNK_SIZE : BlockSize;
 
@@ -328,6 +333,12 @@ static int WriteBlock(struct drxd_state
 		pBlock += Chunk;
 		Address += (Chunk >> 1);
--
-	while (cx24116_readreg(state, CX24116_REG_EXECUTE)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cx24116_readreg(state, CX24116_REG_EXECUTE)) {
 		msleep(10);
 		if (i++ > 64) {
 			/* Avoid looping forever if the firmware does
@@ -557,6 +562,12 @@ static int cx24116_cmd_execute(struct dv
 				__func__);
--
 	while ((position == 0) && (i < 8)) {
 		position = ((*mask) >> i) & 0x01;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((!SYR_var) && (wd > 0)) {
 		usleep_range(2000, 3000);
 		wd -= 2;
 		SYR_var = stv0367_readbits(state, F367TER_SYR_LOCK);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((CPAMPvalue < CPAMPMin) && (wd > 0)) {
 		usleep_range(1000, 2000);
 		wd -= 1;
 		CPAMPvalue = stv0367_readbits(state, F367TER_PPM_CPAMP_DIRECT);
 		/*dprintk("CPAMPvalue= %d at wd=%d\n",CPAMPvalue,wd); */
+		if (_cur < timeout) {
--
 	/*while ( ((!u_var1)||(!u_var2)||(!u_var3)||(!u_var4))  && (wd>=0)) */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (((!u_var1) || (!u_var2) || (!u_var3)) && (wd >= 0)) {
 		usleep_range(1000 * tempo, 1000 * (tempo + 1));
 		wd -= tempo;
@@ -1372,6 +1410,12 @@ stv0367_ter_signal_type stv0367ter_lock_
 		u_var2 = stv0367_readbits(state, F367TER_PRF);
 		u_var3 = stv0367_readbits(state, F367TER_TPS_LOCK);
--
 	while ((!u_var4) && (wd >= 0)) {
 		usleep_range(1000 * tempo, 1000 * (tempo + 1));
 		wd -= tempo;
 		u_var4 = stv0367_readbits(state, F367TER_TSFIFO_LINEOK);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while ((timing_offset == 0) && (tempo > 0)) {
 		usleep_range(10000, 20000);	/*was 20ms  */
 		/* fine tuning of timing offset if required */
@@ -1773,6 +1833,12 @@ static int stv0367ter_algo(struct dvb_fr
 		timing_offset = ((signed)(1000000 / trl_nomrate) *
 							timing_offset) / 2048;
--
 	while (((index) < num_trials) && (ter_state->state != FE_TER_LOCKOK)) {
 		if (!ter_state->first_lock) {
 			if (param->inversion == INVERSION_AUTO)
@@ -1900,6 +1971,12 @@ static int stv0367ter_set_frontend(struc
 		}
 
--
-	while (cpt < 10) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cpt < 10) {
 		usleep_range(2000, 3000);
 		if (cut == 0x50) /*cut 1.0 cut 1.1*/
 			snru32 += stv0367_readbits(state, F367TER_CHCSNR) / 4;
@@ -2037,6 +2119,12 @@ static int stv0367ter_read_snr(struct dv
 			snru32 += 125 * stv0367_readbits(state, F367TER_CHCSNR);
--
 	while (l) {
 		r = *n++;
 
@@ -141,6 +146,12 @@ static void dib7000m_write_tab(struct di
 			r++;
 		} while (--l);
 		l = *n++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (time_before(jiffies, t)) {
 		deb_info("waiting for HAB to complete\n");
 		msleep(10);
@@ -193,6 +198,12 @@ static int bcm3510_hab_send_request(stru
 
 		if (!v.HABSTAT_a8.HABR)
--
 	while (time_before(jiffies, t)) {
 		msleep(10);
 		if ((ret = bcm3510_readB(st,0xa2,&v)) < 0)
@@ -677,6 +693,12 @@ static int bcm3510_reset(struct bcm3510_
 
 		if (v.APSTAT1_a2.RESET)
--
 	while (time_before(jiffies, t)) {
 		msleep(10);
 		if ((ret = bcm3510_readB(st,0xa2,&v)) < 0)
@@ -701,6 +728,12 @@ static int bcm3510_clear_reset(struct bc
 		/* verify that reset is cleared */
 		if (!v.APSTAT1_a2.RESET)
--
 	while (l) {
 		r = pgm_read_word(n++);
 		do {
@@ -683,6 +688,12 @@ static int dib0070_reset(struct dvb_fron
 			r++;
 		} while (--l);
 		l = pgm_read_word(n++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (pos != len) {
 		// work out how much to send this time
 		tx_size = len - pos;
@@ -346,6 +351,12 @@ static int tda1004x_do_upload(struct tda
 		pos += tx_size;
 
--
 	while (!STB0899_GETFIELD(RXEND, reg)) {
 		reg = stb0899_read_reg(state, STB0899_DISRX_ST0);
 		if (jiffies - start > timeout) {
@@ -730,6 +735,12 @@ static int stb0899_wait_diseqc_rxidle(st
 			return -ETIMEDOUT;
 		}
--
 	while (!STB0899_GETFIELD(TXIDLE, reg)) {
 		reg = stb0899_read_reg(state, STB0899_DISSTATUS);
 		if (jiffies - start > timeout) {
@@ -779,6 +795,12 @@ static int stb0899_wait_diseqc_txidle(st
 			return -ETIMEDOUT;
 		}
--
 		while ((max - min) > 1) {
 			med = (max + min) / 2;
 			if (val >= tab[min].read && val < tab[med].read)
 				max = med;
 			else
 				min = med;
--
 	while (fw_pos < SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET){
 		tx_len = (fw_pos <= SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - 252) ? 252 : SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - fw_pos;
 		// write register 0xCF0A
@@ -136,6 +141,12 @@ static int sp8870_firmware_upload (struc
 			return err;
 		}
--
 	while ((sync & 0x03) != 0x03 && (sync & 0x0c) && maxtry--) {
 		msleep(10);
 		sync = ves1x93_readreg (state, 0x0e);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (txlen) {
 		dibx000_read_word(mst, mst->base_reg + 2);
 
@@ -124,6 +129,12 @@ static int dibx000_master_i2c_write(stru
 		if (dibx000_is_i2c_done(mst) != 0)
 			return -EREMOTEIO;
--
 	while (rxlen) {
 		len = rxlen > 8 ? 8 : rxlen;
 		da = (((u8) (msg->addr)) << 9) |
@@ -158,6 +174,11 @@ static int dibx000_master_i2c_read(struc
 
 		rxlen -= len;
--
 		while (len) {
 			da = dibx000_read_word(mst, mst->base_reg);
 			*b++ = (da >> 8) & 0xff;
@@ -166,6 +187,18 @@ static int dibx000_master_i2c_read(struc
 				*b++ =  da   & 0xff;
 				len--;
--
 	while ((cx24123_readreg(state, 0x20) & 0x40) == 0) {
 		if (time_after(jiffies, timeout)) {
 			err("%s:  demodulator is not responding, "\
@@ -625,11 +630,22 @@ static int cx24123_pll_writereg(struct d
 			return -EREMOTEIO;
 		}
--
 	while ((cx24123_readreg(state, 0x20) & 0x40) == 0) {
 		if (time_after(jiffies, timeout)) {
 			err("%s:  demodulator is not responding, "\
@@ -637,12 +653,23 @@ static int cx24123_pll_writereg(struct d
 			return -EREMOTEIO;
 		}
--
 	while ((cx24123_readreg(state, 0x20) & 0x80)) {
 		if (time_after(jiffies, timeout)) {
 			err("%s:  demodulator is not responding," \
@@ -650,6 +677,12 @@ static int cx24123_pll_writereg(struct d
 			return -EREMOTEIO;
 		}
--
 	while ((stb0899_check_tmg(state) != TIMINGOK) && next_loop) {
 		index++;
 		derot_freq += index * internal->direction * derot_step;	/* next derot zig zag position	*/
@@ -231,6 +236,12 @@ static enum stb0899_status stb0899_searc
 			stb0899_write_regs(state, STB0899_CFRM, cfr, 2); /* derotator frequency		*/
 		}
--
 	while ((!lock) && (time < timeout)) {
 		reg = stb0899_read_reg(state, STB0899_CFGPDELSTATUS1);
 		dprintk(state->verbose, FE_DEBUG, 1, "---------> CFGPDELSTATUS=[0x%02x]", reg);
 		lock = STB0899_GETFIELD(CFGPDELSTATUS_LOCK, reg);
 		time++;
+		if (_cur < timeout) {
--
 		while ((internal->status != DVBS2_FEC_LOCK) && (i < 3)) {
 			/*	Read the frequency offset*/
 			offsetfreq = STB0899_READ_S2REG(STB0899_S2DEMOD, CRL_FREQ);
@@ -1401,6 +1428,12 @@ enum stb0899_status stb0899_dvbs2_algo(s
 			stb0899_dvbs2_reacquire(state);
 			internal->status = stb0899_dvbs2_get_fec_status(state, searchTime);
--
 				while ((internal->status != DVBS2_FEC_LOCK) && (i < 3)) {
 					/*	Read the frequency offset*/
 					offsetfreq = STB0899_READ_S2REG(STB0899_S2DEMOD, CRL_FREQ);
@@ -1433,6 +1471,12 @@ enum stb0899_status stb0899_dvbs2_algo(s
 					stb0899_dvbs2_reacquire(state);
 					internal->status = stb0899_dvbs2_get_fec_status(state, searchTime);
--
 			while ((internal->status != DVBS2_FEC_LOCK) && (i < 3)) {
 				csm1 = STB0899_READ_S2REG(STB0899_S2DEMOD, CSM_CNTRL1);
 				STB0899_SETFIELD_VAL(CSM_TWO_PASS, csm1, 1);
@@ -1466,6 +1515,12 @@ enum stb0899_status stb0899_dvbs2_algo(s
 
 				internal->status = stb0899_dvbs2_get_fec_status(state, FecLockTime);
--
 	while (stv0299_readreg(state, 0x0a) & 1) {
 		if (jiffies - start > timeout) {
 			dprintk ("%s: timeout!!\n", __func__);
 			return -ETIMEDOUT;
 		}
 		msleep(10);
--
 	while ((stv0299_readreg(state, 0x0a) & 3) != 2 ) {
 		if (jiffies - start > timeout) {
 			dprintk ("%s: timeout!!\n", __func__);
 			return -ETIMEDOUT;
 		}
 		msleep(10);
--
-	while ((current_step <= nb_steps) && (lock == FALSE)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((current_step <= nb_steps) && (lock == FALSE)) {
 		if (direction > 0)
 			tuner_freq += (current_step * currier_step);
 		else
@@ -629,6 +634,12 @@ static int stv0900_get_demod_cold_lock(s
 		lock = stv0900_get_demod_lock(intp, d, timeout);
--
-			while ((stv0900_get_demod_lock(intp,
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while ((stv0900_get_demod_lock(intp,
 							demod,
 							timed / 2) == FALSE) &&
 						(i <= 2)) {
@@ -1017,6 +1033,12 @@ static void stv0900_track_optimization(s
 				stv0900_write_reg(intp, CFRINIT0, freq0);
--
 	while ((timer < time_out) && (lock == 0)) {
 		switch (dmd_state) {
 		case STV0900_SEARCH:
@@ -1061,6 +1088,12 @@ static int stv0900_get_fec_lock(struct s
 			msleep(10);
 			timer += 10;
--
 		while ((timer < fec_timeout) && (lock == 0)) {
 			lock = stv0900_get_bits(intp, TSFIFO_LINEOK);
 			msleep(1);
 			timer++;
+			if (_cur < timeout) {
+					rdstcll(_cur);
--
 		while ((i <= 50) && (timing != 0) && (timing != 0xff)) {
 			timing = stv0900_read_reg(intp, TMGREG2);
 			msleep(5);
 			i += 5;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((timing_lck == FALSE) && (current_step < nb_steps)) {
 		stv0900_write_reg(intp, DMDISTATE, 0x5f);
 		stv0900_write_bits(intp, DEMOD_MODE, 0);
@@ -1512,6 +1572,12 @@ static u32 stv0900_search_srate_coarse(s
 				stv0900_set_tuner(fe, tuner_freq,
 						intp->bw[demod]);
--
 	while (l) {
 		r = pgm_read_word(n++);
 		do {
@@ -1420,6 +1425,12 @@ static void dib0090_set_default_config(s
 			r++;
 		} while (--l);
 		l = pgm_read_word(n++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (link_top(graph) < stack_top(graph)->num_links) {
 		struct media_entity *entity = stack_top(graph);
 		struct media_link *link = &entity->links[link_top(graph)];
@@ -190,6 +195,12 @@ media_entity_graph_walk_next(struct medi
 		/* Push the new entity to stack and start over. */
 		link_top(graph)++;
--
 	while ((entity = media_entity_graph_walk_next(&graph))) {
 		entity->stream_count++;
 		WARN_ON(entity->pipe && entity->pipe != pipe);
 		entity->pipe = pipe;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((entity = media_entity_graph_walk_next(&graph))) {
 		entity->stream_count--;
 		if (entity->stream_count == 0)
 			entity->pipe = NULL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while ((skb = skb_dequeue(&fmdev->rx_q))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&fmdev->rx_q))) {
 		if (skb->len < sizeof(struct fm_event_msg_hdr)) {
 			fmerr("skb(%p) has only %d bytes, "
 				"at least need %zu bytes to decode\n", skb,
@@ -337,6 +342,12 @@ static void recv_tasklet(unsigned long a
 		if (num_fm_hci_cmds && atomic_read(&fmdev->tx_cnt))
--
 		while (index + 1 < FM_RX_RDS_INFO_FIELD_MAX) {
 			byte1 = rds_buff[index];
 			rds_buff[index] = rds_buff[index + 1];
 			rds_buff[index + 1] = byte1;
 			index += 2;
+			if (_cur < timeout) {
--
 	while (fw_data && fw_len > 0) {
 		action = (struct bts_action *)fw_data;
 
@@ -1289,6 +1316,12 @@ static u32 fm_download_firmware(struct f
 
 		fw_data += (sizeof(struct bts_action) + (action->size));
--
 	while (i--) {
 		if ((bitmask & 0x8000000000000000ull) != 0) {
 			outb(0x80, zol->io);
@@ -154,6 +159,12 @@ static int zol_setfreq(struct zoltrix *z
 			udelay(50);
 		}
--
 	while (rest != 0) {
 		if (rest % temp  == rest)
 			buffer[i] = 0;
@@ -171,6 +176,12 @@ static int tt_setfreq(struct terratec *t
 		i--;
 		p--;
--
 		while ((inb(dev->io) & 0x80) != 0) {
 			dev->rdsbuf[dev->rdsin] = inb(dev->io + 1);
 			if (dev->rdsin == dev->rdsout)
 				printk(KERN_WARNING "cadet: RDS buffer overflow\n");
 			else
 				dev->rdsin++;
--
 	while (radio->wr_index == radio->rd_index) {
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EWOULDBLOCK;
@@ -478,6 +483,12 @@ static ssize_t si470x_fops_read(struct f
 			retval = -EINTR;
 			goto done;
--
 	while (bits--) {
 		if (data & 1) {
 			outb(5, io);
@@ -78,6 +83,12 @@ static void outbits(int bits, unsigned i
 			udelay(6);
 		}
--
-	while (id_table[i].card_vendor != 0 && dev == NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (id_table[i].card_vendor != 0 && dev == NULL) {
 		dev = pnp_find_dev(NULL, id_table[i].vendor,
 				   id_table[i].function, NULL);
 		i++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (radio->wr_index == radio->rd_index) {
 		if (file->f_flags & O_NONBLOCK) {
 			r = -EWOULDBLOCK;
@@ -1222,6 +1227,12 @@ static ssize_t wl1273_fm_fops_read(struc
 			r = -EINTR;
 			goto out;
--
 	while (remaining) {
 		if (!mem_len) {
 			sg = sg_next(sg);
@@ -183,6 +188,12 @@ int ft_queue_data_in(struct se_cmd *se_c
 						__func__, fp, ep->xid,
 						remaining, lport->lso_max);
--
 	while (frame_len) {
 		if (!mem_len) {
 			sg = sg_next(sg);
@@ -310,7 +326,13 @@ void ft_recv_write_data(struct ft_cmd *c
 		mem_off += tlen;
 		mem_len -= tlen;
--
 	while (!list_empty(&drain_task_list)) {
 		task = list_entry(drain_task_list.next, struct se_task, t_state_list);
 		list_del(&task->t_state_list);
@@ -293,6 +298,12 @@ static void core_tmr_drain_task_list(
 		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 
--
 	while (!list_empty(&drain_cmd_list)) {
 		cmd = list_entry(drain_cmd_list.next, struct se_cmd, se_queue_node);
 		list_del_init(&cmd->se_queue_node);
@@ -348,6 +364,12 @@ static void core_tmr_drain_cmd_list(
 
 		core_tmr_handle_tas_abort(tmr_nacl, cmd, tas,
--
 	while ((ptr = strsep(&opts, ",")) != NULL) {
 		if (!*ptr)
 			continue;
@@ -1569,6 +1574,12 @@ static ssize_t target_core_dev_pr_store_
 		default:
 			break;
--
 	while ((ptr = strsep(&opts, ",")) != NULL) {
 		if (!*ptr)
 			continue;
@@ -546,6 +551,12 @@ static ssize_t fd_set_configfs_dev_param
 		default:
 			break;
--
-	while (size >= 16) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size >= 16) {
 		lba = get_unaligned_be64(&ptr[0]);
 		range = get_unaligned_be32(&ptr[8]);
 		pr_debug("UNMAP: Using lba: %llu and range: %u\n",
@@ -1172,7 +1177,13 @@ int target_emulate_unmap(struct se_task
 
--
 	while (len < cmd->data_length) {
 		alua_access_state = (ptr[0] & 0x0f);
 		/*
@@ -348,7 +353,13 @@ int target_emulate_set_target_port_group
 
 		ptr += 4;
--
 	while ((ptr = strsep(&opts, ",")) != NULL) {
 		if (!*ptr)
 			continue;
@@ -421,6 +426,12 @@ static ssize_t iblock_set_configfs_dev_p
 		default:
 			break;
--
-		while (bio_add_page(bio, sg_page(sg), sg->length, sg->offset)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (bio_add_page(bio, sg_page(sg), sg->length, sg->offset)
 				!= sg->length) {
 			bio = iblock_get_bio(task, block_lba, sg_num);
 			if (!bio)
 				goto fail;
 			bio_list_add(&list, bio);
--
-		while (i < (4 + page_83[3])) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i < (4 + page_83[3])) {
 			vpd->device_identifier[j++] =
 				hex_str[(page_83[i] & 0xf0) >> 4];
 			vpd->device_identifier[j++] =
 				hex_str[page_83[i] & 0x0f];
 			i++;
--
 	while (!list_empty(&dispose_list)) {
 		task = list_first_entry(&dispose_list, struct se_task, t_list);
 
@@ -3320,6 +3336,12 @@ static void transport_free_dev_tasks(str
 		list_del(&task->t_list);
 
--
 	while (length) {
 		u32 page_len = min_t(u32, length, PAGE_SIZE);
 		page = alloc_page(GFP_KERNEL | __GFP_ZERO);
@@ -3511,13 +3538,30 @@ transport_generic_get_mem(struct se_cmd
 		sg_set_page(&cmd->t_data_sg[i], page, page_len, 0);
 		length -= page_len;
--
 	while (i > 0) {
 		i--;
 		__free_page(sg_page(&cmd->t_data_sg[i]));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (!list_empty(&lun->lun_cmd_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&lun->lun_cmd_list)) {
 		cmd = list_first_entry(&lun->lun_cmd_list,
 		       struct se_cmd, se_lun_node);
 		list_del(&cmd->se_lun_node);
@@ -4212,6 +4261,12 @@ check_cond:
 
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		ret = wait_event_interruptible(dev->dev_queue_obj.thread_wq,
 				atomic_read(&dev->dev_queue_obj.queue_cnt) ||
 				kthread_should_stop());
@@ -4724,6 +4784,12 @@ get_cmd:
 		}
--
-	while (total_sg_needed) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
 			max_sg_per_table : total_sg_needed;
 
@@ -191,6 +196,12 @@ static int rd_build_device_space(struct
 
--
 	while (req->rd_size) {
 		u32 len;
 		void *rd_addr;
@@ -409,6 +425,12 @@ static int rd_MEMCPY(struct rd_request *
 
 		/* since we increment, the first sg entry is correct */
--
 	while ((ptr = strsep(&opts, ",")) != NULL) {
 		if (!*ptr)
 			continue;
@@ -490,6 +517,12 @@ static ssize_t rd_set_configfs_dev_param
 		default:
 			break;
--
 	while ((ptr = strsep(&opts, ",")) != NULL) {
 		if (!*ptr)
 			continue;
@@ -865,6 +870,12 @@ static ssize_t pscsi_set_configfs_dev_pa
 		default:
 			break;
--
 		while (len > 0 && data_len > 0) {
 			bytes = min_t(unsigned int, len, PAGE_SIZE - off);
 			bytes = min(bytes, data_len);
@@ -1048,16 +1064,33 @@ static int pscsi_map_sg(struct se_task *
 			len -= bytes;
 			data_len -= bytes;
--
 	while (*hbio) {
 		bio = *hbio;
 		*hbio = (*hbio)->bi_next;
 		bio->bi_next = NULL;
 		bio_endio(bio, 0);	/* XXX: should be error */
+		if (_cur < timeout) {
--
 	while (hbio) {
 		struct bio *bio = hbio;
 		hbio = hbio->bi_next;
 		bio->bi_next = NULL;
 		bio_endio(bio, 0);	/* XXX: should be error */
+		if (_cur < timeout) {
--
 	while (start < end) {
 		char *key, *value;
 		struct iscsi_param *param;
@@ -1607,6 +1612,12 @@ int iscsi_decode_text_input(
 			}
 			SET_PSTATE_ACCEPTOR(param);
--
 	while ((ts = iscsi_get_ts_from_inactive_list())) {
 
 		spin_lock_bh(&ts->ts_state_lock);
@@ -169,6 +174,12 @@ extern void iscsi_deallocate_thread_sets
 
 		released_count++;
--
-	while (exp_data_sn > data_sn) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (exp_data_sn > data_sn) {
 		if ((cmd->next_burst_len +
 		     conn->conn_ops->MaxRecvDataSegmentLength) <
 		     conn->sess->sess_ops->MaxBurstLength) {
@@ -59,6 +64,12 @@ void iscsit_create_conn_recovery_datain_
 			cmd->next_burst_len = 0;
--
 	while (cmd->write_data_done > write_data_done) {
 		if ((write_data_done + conn->sess->sess_ops->MaxBurstLength) <=
 		     cmd->write_data_done)
 			write_data_done += conn->sess->sess_ops->MaxBurstLength;
 		else
 			break;
--
-	while (data_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (data_len) {
 		u32 space = (sg->length - offset);
 		u32 sub_len = min_t(u32, data_len, space);
 send_pg:
@@ -1360,7 +1365,13 @@ send_pg:
 		data_len -= sub_len;
--
-	while (total_rx < data) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (total_rx < data) {
 		rx_loop = kernel_recvmsg(conn->sock, &msg, iov_p, iov_len,
 					(data - total_rx), MSG_WAITALL);
 		if (rx_loop <= 0) {
@@ -1474,6 +1490,12 @@ static int iscsit_do_rx_data(
 		total_rx += rx_loop;
--
-	while (total_tx < data) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (total_tx < data) {
 		tx_loop = kernel_sendmsg(conn->sock, &msg, iov_p, iov_len,
 					(data - total_tx));
 		if (tx_loop <= 0) {
@@ -1511,6 +1538,12 @@ static int iscsit_do_tx_data(
 		total_tx += tx_loop;
--
-	while (offset < buf_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < buf_len) {
 		size = ((offset + length) > buf_len) ?
 			(buf_len - offset) : length;
 
@@ -77,6 +82,12 @@ int iscsit_dump_data_payload(
 		}
--
 	while (begrun < last_r2tsn) {
 		r2t = iscsit_get_holder_for_r2tsn(cmd, begrun);
 		if (!r2t)
@@ -184,6 +200,12 @@ static int iscsit_handle_r2t_snack(
 			return -1;
 
--
-	while (begrun > data_sn++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (begrun > data_sn++) {
 		data_sn_count++;
 		if ((dr->next_burst_len +
 		     conn->conn_ops->MaxRecvDataSegmentLength) <
@@ -224,6 +251,12 @@ int iscsit_create_recovery_datain_values
 			data_sn_count = 0;
--
-				while (data_sn < begrun) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (data_sn < begrun) {
 					seq->pdu_send_order++;
 					read_data_done +=
 						conn->conn_ops->MaxRecvDataSegmentLength;
 					seq->next_burst_len +=
 						conn->conn_ops->MaxRecvDataSegmentLength;
--
 				while (data_sn < begrun) {
 					seq->pdu_send_order++;
 
@@ -358,6 +407,12 @@ int iscsit_create_recovery_datain_values
 						}
 					}
--
 	while (begrun < last_statsn) {
 		found_cmd = 0;
 
@@ -558,6 +618,12 @@ int iscsit_handle_status_snack(
 		cmd->i_state = ISTATE_SEND_STATUS_RECOVERY;
 		iscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);
--
 	while (length > 0) {
 		get_random_bytes(&r, sizeof(long));
 		r = r ^ (r >> 8);
@@ -72,6 +77,12 @@ static void chap_set_random(char *data,
 
 		*data++ = n;
--
 	while (buf[i] != '\0') {
 		if (buf[i] == ';')
 			return i;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		if (++pdu_count > MAX_LOGIN_PDUS) {
 			pr_err("MAX_LOGIN_PDUS count reached.\n");
 			iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
@@ -726,6 +742,12 @@ static int iscsi_target_do_login(struct
 			login_rsp->flags &= ~ISCSI_FLAG_LOGIN_TRANSIT;
--
 	while (start < end) {
 		if (iscsi_extract_key_value(start, &key, &value) < 0) {
 			ret = -1;
@@ -812,6 +839,12 @@ static int iscsi_target_locate_portal(
 			t_buf = value;
 
--
 	while (irq_stat != 0) {
 		int irqoffset = fls(irq_stat) - 1;
 
@@ -228,6 +233,12 @@ static void mxc_gpio_irq_handler(struct
 		generic_handle_irq(gpio_irq_no_base + irqoffset);
 
--
 		while (stat) {
 			int bit = __ffs(stat);
 			int line = bank * 8 + bit;
 
 			handle_nested_irq(stmpe_gpio->irq_base + line);
 			stat &= ~(1 << bit);
--
 		while (status) {
 			res = ffs(status);
 			n += res;
 			generic_handle_irq(n - 1);
 			status >>= res;
+			if (_cur < timeout) {
--
 	while (status) {
 		int bit = __ffs(status);
 
 		generic_handle_irq(first_irq + bit);
 		status &= ~BIT(bit);
+		if (_cur < timeout) {
--
 	while (new_irqs) {
 		level = __ffs(new_irqs);
 		pca953x_gpio_direction_input(&chip->gpio_chip, level);
 		new_irqs &= ~(1 << level);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (n--) {
 		int ret = mcp23008_read(mcp, reg++);
 		if (ret < 0)
 			return ret;
 		*vals++ = ret;
+		if (_cur < timeout) {
--
 	while (n--) {
 		int ret = mcp23017_read(mcp, reg++);
 		if (ret < 0)
 			return ret;
 		*vals++ = ret;
+		if (_cur < timeout) {
--
 	while (--j >= 0) {
 		chip--;
 		irq_free_descs(chip->irq_base, num_ports[j]);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 	while (--i >= 0) {
 		chip--;
 		ret = gpiochip_remove(&chip->gpio);
 		if (ret)
 			dev_err(&pdev->dev, "Failed gpiochip_remove(%d)\n", i);
+			if (_cur < timeout) {
--
 		while (pending) {
 			gpio = __ffs(pending);
 			mask = BIT(gpio);
@@ -257,6 +262,12 @@ static void lnw_irq_handler(unsigned irq
 			/* Clear before handling so we can't lose an edge */
 			writel(mask, gedr);
--
-			while (pending) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (pending) {
 				if (pending & (1 << bit)) {
 					handle_nested_irq(dev->irq_base +
 							  (bank << 3) + bit);
@@ -264,6 +269,12 @@ static irqreturn_t adp5588_irq_handler(i
 
--
 			while (n < BITS_PER_LONG) {
 				loop = 1;
 
 				generic_handle_irq(gpio_to_irq(gpio_base + n));
 				n = find_next_bit(&gedr, BITS_PER_LONG, n + 1);
+				if (_cur < timeout) {
--
 	} while (loop);
diff -u -p a/gpio/gpio-msm-v1.c b/gpio/gpio-msm-v1.c
--- a/gpio/gpio-msm-v1.c
+++ b/gpio/gpio-msm-v1.c
@@ -569,6 +569,11 @@ static void msm_gpio_irq_handler(unsigne
 		struct msm_gpio_chip *msm_chip = &msm_gpio_chips[i];
--
 		while (val) {
 			mask = val & -val;
 			j = fls(mask) - 1;
@@ -578,6 +583,12 @@ static void msm_gpio_irq_handler(unsigne
 			val &= ~mask;
 			generic_handle_irq(FIRST_GPIO_IRQ +
--
 	while (irq_stat != 0) {
 		int irqoffset = fls(irq_stat) - 1;
 		generic_handle_irq(gpio_irq_no_base + irqoffset);
 		irq_stat &= ~(1 << irqoffset);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (stat) {
 			int bit = __ffs(stat);
 			int line = i * 8 + bit;
 
 			handle_nested_irq(tc3589x_gpio->irq_base + line);
 			stat &= ~(1 << bit);
--
 	while (fw_csr_iterator_next(&ci, &key, &value)) {
 		if (last_key == search_key &&
 		    key == (CSR_DESCRIPTOR | CSR_LEAF))
 			return ci.p - 1 + value;
 
 		last_key = key;
--
 	while (fw_csr_iterator_next(&ci, &key, &value)) {
 		switch (key) {
 		case CSR_VENDOR:	id[0] = value; break;
@@ -140,6 +156,12 @@ static void get_ids(const u32 *directory
 		case CSR_SPECIFIER_ID:	id[2] = value; break;
 		case CSR_VERSION:	id[3] = value; break;
--
-	while (fw_csr_iterator_next(&ci, &key, &value)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (fw_csr_iterator_next(&ci, &key, &value)) {
 		switch (key) {
 		case CSR_SPECIFIER_ID:
 			specifier_id = value;
@@ -416,6 +443,12 @@ static int units_sprintf(char *buf, cons
 			version = value;
--
 	while (sp > 0) {
 		/*
 		 * Pop the next block reference of the stack.  The
@@ -614,6 +652,12 @@ static int read_config_rom(struct fw_dev
 		}
 		if (length < i)
--
 	while (fw_csr_iterator_next(&ci, &key, &value)) {
 		if (key != (CSR_UNIT | CSR_DIRECTORY))
 			continue;
@@ -696,6 +745,12 @@ static void create_units(struct fw_devic
 
 	skip_unit:
--
-	while (i != last && res_count == 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i != last && res_count == 0) {
 
 		/* Peek at the next descriptor. */
 		next_i = ar_next_buffer_index(i);
@@ -752,6 +757,12 @@ static unsigned int ar_search_last_activ
 next_buffer_is_active:
--
-	while (i != end_buffer_index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i != end_buffer_index) {
 		dma_sync_single_for_cpu(ctx->ohci->card.device,
 					ar_buffer_bus(ctx, i),
 					PAGE_SIZE, DMA_FROM_DEVICE);
 		i = ar_next_buffer_index(i);
+		if (_cur < timeout) {
--
 	while (p < end) {
 		next = handle_ar_packet(ctx, p);
 		if (!next)
 			return p;
 		p = next;
+		if (_cur < timeout) {
--
-	while (i != end_buffer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i != end_buffer) {
 		dma_sync_single_for_device(ctx->ohci->card.device,
 					   ar_buffer_bus(ctx, i),
 					   PAGE_SIZE, DMA_FROM_DEVICE);
 		ar_context_link_page(ctx, i);
 		i = ar_next_buffer_index(i);
--
-		while (iso_event) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (iso_event) {
 			i = ffs(iso_event) - 1;
 			tasklet_schedule(
 				&ohci->ir_context_list[i].context.tasklet);
 			iso_event &= ~(1 << i);
+			if (_cur < timeout) {
--
-		while (iso_event) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (iso_event) {
 			i = ffs(iso_event) - 1;
 			tasklet_schedule(
 				&ohci->it_context_list[i].context.tasklet);
 			iso_event &= ~(1 << i);
+			if (_cur < timeout) {
--
 	while (!(d->control & cpu_to_le16(DESCRIPTOR_BRANCH_ALWAYS))) {
 		d++;
 		buffer_dma = le32_to_cpu(d->data_address);
@@ -2722,6 +2793,12 @@ static int handle_ir_packet_per_buffer(s
 					      buffer_dma & ~PAGE_MASK,
 					      le16_to_cpu(d->req_count),
--
-	while (fw_csr_iterator_next(&ci, &key, &value)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (fw_csr_iterator_next(&ci, &key, &value)) {
 		switch (key) {
 
 		case CSR_DEPENDENT_INFO | CSR_OFFSET:
@@ -1054,6 +1059,12 @@ static int sbp2_scan_unit_dir(struct sbp
 				return -ENOMEM;
--
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		port_type = (q >> shift) & 0x03;
 		switch (port_type) {
 		case SELFID_PORT_CHILD:
@@ -97,6 +102,12 @@ static u32 *count_ports(u32 *sid, int *t
 
--
 	while (sid < end) {
 		next_sid = count_ports(sid, &port_count, &child_port_count);
 
@@ -309,6 +325,12 @@ static struct fw_node *build_tree(struct
 
 		sid = next_sid;
--
 	while (&node0->link != &list0) {
 		WARN_ON(node0->port_count != node1->port_count);
 
@@ -498,6 +525,12 @@ static void update_tree(struct fw_card *
 		next1 = fw_node(node1->link.next);
 		fw_node_put(node1);
--
-		while (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {
 			/* remove the oldest */
 			fwnet_pd_delete(list_first_entry(&peer->pd_list,
 				struct fwnet_partial_datagram, pd_link));
 			peer->pdg_size--;
+			if (_cur < timeout) {
--
 	while (card->tlabel_mask & (1ULL << tlabel)) {
 		tlabel = (tlabel + 1) & 0x3f;
 		if (tlabel == card->current_tlabel)
 			return -EBUSY;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (handler->offset + handler->length <= region->end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (handler->offset + handler->length <= region->end) {
 		if (is_in_fcp_region(handler->offset, handler->length))
 			other = NULL;
 		else
@@ -592,6 +608,12 @@ int fw_core_add_address_handler(struct f
 			ret = 0;
--
-		while (pfnleft) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (pfnleft) {
 			if (pfnleft > pfncount)
 				pfncurr = pfncount;
 			else
@@ -348,6 +353,12 @@ static int create_gpadl_header(void *kbu
 				      &msgheader->submsglist);
--
 	while (1) {
 		if (msg->header.message_type == HVMSG_NONE) {
 			/* no msg */
@@ -476,6 +481,12 @@ static void vmbus_on_msg_dpc(unsigned lo
 			 */
 			wrmsrl(HV_X64_MSR_EOM, 0);
--
 	while (retries < 3) {
 		ret =  hv_post_message(conn_id, 1, buffer, buflen);
 		if (ret != HV_STATUS_INSUFFICIENT_BUFFERS)
 			return ret;
 		retries++;
 		msleep(100);
--
-	while (kfifo_out(&sony_laptop_input.fifo,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (kfifo_out(&sony_laptop_input.fifo,
 			 (unsigned char *)&kp, sizeof(kp)) == sizeof(kp)) {
 		input_report_key(kp.dev, kp.key, 0);
 		input_sync(kp.dev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-	while (ret < count &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ret < count &&
 	       (kfifo_out_locked(&sonypi_compat.fifo, &c, sizeof(c),
 			  &sonypi_compat.fifo_lock) == sizeof(c))) {
 		if (put_user(c, buf++))
 			return -EFAULT;
 		ret++;
--
-		while ((irb =
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((irb =
 			call_fext_func(FUNC_BUTTONS, 0x1, 0x0, 0x0)) != 0
 				&& (i++) < MAX_HOTKEY_RINGBUFFER_SIZE) {
 			switch (irb & 0x4ff) {
@@ -1018,7 +1023,12 @@ static void acpi_fujitsu_hotkey_notify(s
 					input_sync(input);
--
-				while ((status =
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					while ((status =
 					kfifo_out_locked(
 					 &fujitsu_hotkey->fifo,
 					 (unsigned char *) &keycode_r,
@@ -1030,8 +1040,20 @@ static void acpi_fujitsu_hotkey_notify(s
 					vdbg_printk(FUJLAPTOP_DBG_TRACE,
--
 	while (--i >= 0) {
 		kfree(pinfo->tzd[i]->devdata);
 		thermal_zone_device_unregister(pinfo->tzd[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
-	while (value != 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (value != 0) {
 		status = acpi_evaluate_object(NULL, (value > 0) ?
 					      hotk->methods->brightness_up :
 					      hotk->methods->brightness_down,
@@ -953,6 +958,12 @@ static int set_brightness(int value)
 			pr_warn("Error changing brightness\n");
--
 	while (remain) {
 		if (sscanf(buffer, " lcd_out : %i", &value) == 1)
 			lcd_out = value & 1;
@@ -623,6 +628,12 @@ static ssize_t video_proc_write(struct f
 			--remain;
 		}
 		while (remain && *(buffer - 1) != ';');
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
--
 	while (status & 1) {
 		udelay(1); /* scu processing time is in few u secods */
 		status = ipc_read_status();
@@ -149,6 +154,12 @@ static inline int busy_loop(void) /* Wai
 			dev_err(&ipcdev.pdev->dev, "IPC timed out");
 			return -ETIMEDOUT;
--
 	while (readl(&mailbox->scu_flag) != 1) {
 		rmb();
 		mdelay(1);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (readl(&mailbox->status) != IPC_FW_TXLOW) {
 		rmb();
 		mdelay(10);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (readl(&mailbox->scu_flag) == 1) {
 		rmb();
 		mdelay(1);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (readl(&mailbox->status) != IPC_FW_TXHIGH) {
 		rmb();
 		mdelay(10);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (mailbox->scu_flag == 0) {
 		rmb();
 		mdelay(1);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (qlist_size) {
 		if ((qlist->vendor == thinkpad_id.vendor ||
 				qlist->vendor == TPACPI_MATCH_ANY) &&
@@ -491,6 +496,12 @@ static unsigned long __init tpacpi_check
 
 		qlist_size--;
--
 	while (*fmt) {
 		char c = *(fmt++);
 		switch (c) {
@@ -589,6 +605,12 @@ static int acpi_evalf(acpi_handle handle
 			va_end(ap);
 			return 0;
--
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "enable") == 0)
 			status = TPACPI_RFK_RADIO_ON;
@@ -1404,6 +1431,12 @@ static int tpacpi_rfk_procfs_write(const
 			status = TPACPI_RFK_RADIO_OFF;
 		else
--
 	while (!res && i < ARRAY_SIZE(tpacpi_driver_attributes)) {
 		res = driver_create_file(drv, tpacpi_driver_attributes[i]);
 		i++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (1) {
 		if (!acpi_evalf(hkey_handle, &hkey, "MHKP", "d")) {
 			pr_err("failed to retrieve HKEY event\n");
@@ -3758,6 +3807,12 @@ static void hotkey_notify(struct ibm_str
 					dev_name(&ibm->acpi->device->dev),
 					event, hkey);
--
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "enable") == 0) {
 			hotkey_enabledisable_warn(1);
@@ -3859,6 +3919,12 @@ static int hotkey_write(char *buf)
 			res = -EINVAL;
 			goto errexit;
--
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "lcd_enable") == 0) {
 			enable |= TP_ACPI_VIDEO_S_LCD;
@@ -4737,6 +4808,12 @@ static int video_write(char *buf)
 				return res;
 		} else
--
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "on") == 0) {
 			newstatus = 1;
@@ -4918,6 +5000,12 @@ static int light_write(char *buf)
 			newstatus = 0;
 		} else
--
-	while ((cmd = next_cmd(&buf))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((cmd = next_cmd(&buf))) {
 		if (sscanf(cmd, "%u", &cmos_cmd) == 1 &&
 		    cmos_cmd >= 0 && cmos_cmd <= 21) {
 			/* cmos_cmd set */
@@ -5007,6 +5100,12 @@ static int cmos_write(char *buf)
 		res = issue_thinkpad_cmos_command(cmos_cmd);
--
 	while ((cmd = next_cmd(&buf))) {
 		if (sscanf(cmd, "%d", &led) != 1 || led < 0 || led > 15)
 			return -EINVAL;
@@ -5424,6 +5528,12 @@ static int led_write(char *buf)
 		rc = led_set_status(led, s);
 		if (rc < 0)
--
-	while ((cmd = next_cmd(&buf))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((cmd = next_cmd(&buf))) {
 		if (sscanf(cmd, "%u", &beep_cmd) == 1 &&
 		    beep_cmd >= 0 && beep_cmd <= 17) {
 			/* beep_cmd set */
@@ -5503,6 +5618,12 @@ static int beep_write(char *buf)
 					beep_cmd))
--
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "up") == 0) {
 			if (level < bright_maxlvl)
@@ -6392,6 +6518,12 @@ static int brightness_write(char *buf)
 			/* new level set */
 		} else
--
 	while ((cmd = next_cmd(&buf))) {
 		if (!tp_features.mixer_no_level_control) {
 			if (strlencmp(cmd, "up") == 0) {
@@ -7067,6 +7204,12 @@ static int volume_write(char *buf)
 			new_mute = 0;
 		else
--
 	while (!rc && (cmd = next_cmd(&buf))) {
 		if (!((fan_control_commands & TPACPI_FAN_CMD_LEVEL) &&
 		      fan_write_cmd_level(cmd, &rc)) &&
@@ -8370,6 +8518,12 @@ static int fan_write(char *buf)
 			rc = -EINVAL;
 		else if (!rc)
--
 			while (ret & 1 << (i - WM831X_IRQ_GPIO_1)) {
 				handle_nested_irq(wm831x->irq_base + i);
 				ret = wm831x_reg_read(wm831x,
 						      WM831X_GPIO_LEVEL);
+				if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (isr) {
 			int irq = fls(isr) - 1;
 			isr &= ~(1 << irq);
@@ -824,6 +829,12 @@ static void menelaus_work(struct work_st
 				handler(menelaus);
 			menelaus_enable_irq(irq);
--
 	while (acks) {
 		int i = __ffs(acks);
 
@@ -387,6 +392,12 @@ static irqreturn_t tps6586x_irq(int irq,
 			handle_nested_irq(tps6586x->irq_base + i);
 
--
 	while (pins) {
 		int pin = __ffs(pins);
 		int regoffset = numregs - (pin / afperreg) - 1;
@@ -272,6 +277,12 @@ int stmpe_set_altfunc(struct stmpe *stmp
 		regs[regoffset] |= af << pos;
 
--
 		while (status) {
 			int bit = __ffs(status);
 			int line = bank * 8 + bit;
 
 			handle_nested_irq(stmpe->irq_base + line);
 			status &= ~(1 << bit);
--
 	while (curr_voltage < tps_comp.uV_max) {
 		curr_voltage = tps_comp.vsel_table[index];
 		if (curr_voltage >= voltage)
 			break;
 		else if (curr_voltage < voltage)
 			index ++;
--
-	while (timeout) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (timeout) {
 		msleep(1);
 
 		ret = wm831x_reg_read(wm831x,
@@ -211,6 +216,12 @@ static int wm831x_auxadc_read_polled(str
 			ret = -EBUSY;
--
-	while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
 			& OMAP_USBTLL_SYSSTATUS_RESETDONE)) {
 		cpu_relax();
 
@@ -751,6 +756,12 @@ static int usbhs_enable(struct device *d
 			ret = -EINVAL;
--
-	while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
 				& (1 << 0))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
--
-	while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
 				& (1 << 1))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
--
-	while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
 				& (1 << 2))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
--
-	while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
 				& (1 << 0))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
--
 	while (!kthread_should_stop()) {
 		unsigned int x, y, p;
 		signed long timeout;
@@ -270,6 +275,12 @@ static int ucb1x00_thread(void *_ts)
 		try_to_freeze();
 
--
 	while (status) {
 		int bit = __ffs(status);
 
 		handle_nested_irq(tc3589x->irq_base + bit);
 		status &= ~(1 << bit);
+		if (_cur < timeout) {
--
 		while (edge_change) {
 			int		i = fls(edge_change) - 1;
 			struct irq_data	*idata;
@@ -545,6 +550,12 @@ static void twl4030_sih_bus_sync_unlock(
 				bytes[byte] |= BIT(off + 0);
 
--
 	while (isr) {
 		irq = fls(isr);
 		irq--;
@@ -616,6 +632,12 @@ static irqreturn_t handle_twl4030_sih(in
 		else
 			pr_err("twl4030: %s SIH, invalid ISR bit %d\n",
--
-	while (numregs) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (numregs) {
 		/* The hardware limit for get page is 4 */
 		u8 curnum = min_t(u8, numregs, 4u);
 
@@ -1039,6 +1044,12 @@ static int get_register_page_interruptib
 		numregs -= curnum;
--
 	while (stat & ~mask) {
 		int irq = __ffs(stat & ~mask);
 
@@ -443,6 +448,12 @@ static int mc13xxx_irq_handle(struct mc1
 
 			ret = mc13xxx_reg_write(mc13xxx, offmask, mask);
--
 		while (resconfig->resource) {
 			err = twl4030_configure_resource(resconfig);
 			if (err)
 				goto resource;
 			resconfig++;
 
--
 	while (br_exp < CR_MAXPEXP + CR_MIND && (br_man % 2 == 0)) {
 		br_man = br_man >> 1;
 		++br_exp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (div < CR_MAXD) {
 		div++;
 		if (br_man <= (c << (CR_MAXPEXP+div-br_exp))) {
@@ -681,6 +697,12 @@ static int make_rate (const hrz_dev * de
 			PRINTD (DBG_QOS, "B: p=%u, d=%u", pre, div);
 			goto got_it;
--
-  while (pio_instead) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (pio_instead) {
 #endif
     // bytes waiting for RX transfer
     rx_bytes = dev->rx_bytes;
@@ -1071,6 +1098,12 @@ static void rx_schedule (hrz_dev * dev,
 #else
--
-  while (pio_instead) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (pio_instead) {
 #endif
     // bytes in current region waiting for TX transfer
     tx_bytes = dev->tx_bytes;
@@ -1227,6 +1265,12 @@ static void tx_schedule (hrz_dev * const
 #else
--
-  while ((int_source = rd_regl (dev, INT_SOURCE_REG_OFF)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
+    while ((int_source = rd_regl (dev, INT_SOURCE_REG_OFF)
 	  & INTERESTING_INTERRUPTS)) {
     // In the interests of fairness, the handlers below are
     // called in sequence and without immediate return to the head of
@@ -1427,6 +1476,12 @@ static irqreturn_t interrupt_handler(int
       PRINTD (DBG_IRQ|DBG_RX, "rx_data_av asserted");
--
   while (!(idle_channels = rd_regw (dev, TX_STATUS_OFF) & IDLE_CHANNELS_MASK)) {
     PRINTD (DBG_TX|DBG_WARN, "waiting for idle TX channel");
     // delay a bit here
@@ -1476,6 +1536,12 @@ static short setup_idle_tx_channel (hrz_
       PRINTD (DBG_TX|DBG_ERR, "spun out waiting for idle TX channel");
       return -EBUSY;
--
     while (keep_going) {
       if (idle_channels & (1<<chan)) {
 	tx_channel = chan;
@@ -1492,6 +1563,12 @@ static short setup_idle_tx_channel (hrz_
       ++chan;
       if (chan == TX_CHANS)
--
-  while ((free_buffers = rd_regw (dev, TX_FREE_BUFFER_COUNT_OFF)) < buffers_required) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while ((free_buffers = rd_regw (dev, TX_FREE_BUFFER_COUNT_OFF)) < buffers_required) {
     PRINTD (DBG_TX, "waiting for free TX buffers, got %d of %d",
 	    free_buffers, buffers_required);
     // what is the appropriate delay? implement a timeout? (depending on line speed?)
@@ -1682,6 +1764,12 @@ static int hrz_send (struct atm_vcc * at
       hrz_kfree_skb (skb);
--
 	while (x = zin(MWA(mbx)), (pos & 0xffff) != x) {
 		u32 *here;
 		struct sk_buff *skb;
@@ -471,6 +476,12 @@ printk("dummy: 0x%08lx, 0x%08lx\n",dummy
 		ATM_SKB(skb)->vcc = vcc;
 		vcc->push(vcc,skb);
--
-	while (x = zin(MWA(mbx)), (pos & 0xffff) != x) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (x = zin(MWA(mbx)), (pos & 0xffff) != x) {
 		int chan;
 
 #if 1
@@ -775,6 +791,12 @@ NO !
 		}
--
 	while ((reason = zin(GSR))) {
 		handled = 1;
 		EVENT("reason 0x%x\n",reason,0);
@@ -1087,6 +1114,12 @@ static irqreturn_t zatm_int(int irq,void
 			if (reason & 8) poll_tx(dev,3);
 		}
--
 	while (i-- > 0) {
 		pci_free_consistent(pdev, 2*MBX_SIZE(i), 
 				    (void *)zatm_dev->mbx_start[i],
 				    zatm_dev->mbx_dma[i]);
+		if (_cur < timeout) {
+	rdstcll(_cur);
--
 	while (rate > 0x3ff) {
 		++exp;
 		rate >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (rate_atmf < 0x400) {
 		man = (rate_atmf & 0x1f) << 4;
 		exp = rate_atmf >> 5;
@@ -770,6 +786,12 @@ he_init_cs_block_rcm(struct he_dev *he_d
 				CONFIG_RCMABR + RTGTBL_OFFSET + (rate_atmf >> 1));
 
--
 	while (he_dev->rbrq_head != rbrq_tail) {
 		++updated;
 
@@ -1803,6 +1830,12 @@ next_rbrq_entry:
 				((unsigned long) he_dev->rbrq_base |
 					RBRQ_MASK(he_dev->rbrq_head + 1));
--
-	while (he_dev->tbrq_head != tbrq_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (he_dev->tbrq_head != tbrq_tail) {
 		++updated;
 
 		HPRINTK("tbrq%d 0x%x%s%s\n",
@@ -1885,6 +1923,12 @@ next_tbrq_entry:
 		he_dev->tbrq_head = (struct he_tbrq *)
--
 	while (he_dev->irq_head != he_dev->irq_tail) {
 		++updated;
 
@@ -2015,6 +2064,12 @@ he_tasklet(unsigned long data)
 		he_dev->irq_head->isw = ITYPE_INVALID;
 
--
 		while (he_readl(he_dev, RCC_STAT) & RCC_BUSY) {
 			HPRINTK("close cid 0x%x RCC_BUSY\n", cid);
 			udelay(250);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (((tx_inuse = atomic_read(&sk_atm(vcc)->sk_wmem_alloc)) > 1) &&
 		       (retry < MAX_RETRY)) {
 			msleep(sleep);
@@ -2420,6 +2491,12 @@ he_close(struct atm_vcc *vcc)
 				sleep = sleep * 2;
 
--
 		while (!((tsr4 = he_readl_tsr4(he_dev, cid)) & TSR4_SESSION_ENDED)) {
 			HPRINTK("close tx cid 0x%x !TSR4_SESSION_ENDED (tsr4 = 0x%x)\n", cid, tsr4);
 			udelay(250);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (TSR0_CONN_STATE(tsr0 = he_readl_tsr0(he_dev, cid)) != 0) {
 			HPRINTK("close tx cid 0x%x TSR0_CONN_STATE != 0 (tsr0 = 0x%x)\n", cid, tsr0);
 			udelay(250);
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (eni_vcc->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR) >>
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (eni_vcc->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR) >>
 	    MID_VCI_DESCR_SHIFT)) {
 		EVENT("rx_vcc(2: host dsc=0x%lx, nic dsc=0x%lx)\n",
 		    eni_vcc->descr,tmp);
@@ -631,6 +636,12 @@ static inline int rx_vcc(struct atm_vcc
 		    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>
--
-	while (ENI_VCC(vcc)->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ENI_VCC(vcc)->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR)
 	    >> MID_VCI_DESCR_SHIFT)) {
 		EVENT("rx_vcc(4: host dsc=0x%lx, nic dsc=0x%lx)\n",
 		    eni_vcc->descr,tmp);
@@ -648,6 +664,12 @@ static inline int rx_vcc(struct atm_vcc
 		    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>
--
 	while ((curr = eni_dev->fast)) {
 		EVENT("poll_rx.fast\n",0,0);
 		if (rx_vcc(curr)) return;
@@ -666,7 +693,18 @@ static void poll_rx(struct atm_dev *dev)
 		ENI_VCC(curr)->next = ENI_VCC_NOS;
 		barrier();
--
 	while ((curr = eni_dev->slow)) {
 		EVENT("poll_rx.slow\n",0,0);
 		if (rx_vcc(curr)) return;
@@ -674,6 +712,12 @@ static void poll_rx(struct atm_dev *dev)
 		ENI_VCC(curr)->next = ENI_VCC_NOS;
 		barrier();
--
 	while (eni_in(MID_SERV_WRITE) != eni_dev->serv_read) {
 		vci = readl(eni_dev->service+eni_dev->serv_read*4);
 		eni_dev->serv_read = (eni_dev->serv_read+1) & (NR_SERVICE-1);
@@ -718,6 +767,12 @@ static void get_service(struct atm_dev *
 		}
 putting++;
--
-			while ((skb = skb_dequeue(&tx->backlog))) {
-				res = do_tx(skb);
-				if (res == enq_ok) continue;
-				DPRINTK("re-queuing TX PDU\n");
-				skb_queue_head(&tx->backlog,skb);
-requeued++;
--
+				while ((skb = skb_dequeue(&tx->backlog))) {
+					res = do_tx(skb);
+					if (res == enq_ok) continue;
+					DPRINTK("re-queuing TX PDU\n");
+					skb_queue_head(&tx->backlog,skb);
+				requeued++;
--
 	while (space >= 64) {
 		skb = skb_dequeue(&lvcc->tx.backlog);
 		if (skb == NULL)
@@ -1328,6 +1333,12 @@ static void vcc_tx_unqueue_aal5(struct l
 		}
 		lanai_send_one_aal5(lanai, lvcc, skb, n);
--
-	while (lanai->service.ptr != end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (lanai->service.ptr != end) {
 		ntx += handle_service(lanai,
 		    le32_to_cpup(lanai->service.ptr++));
 		if (lanai->service.ptr >= lanai->service.end)
 			lanai->service.ptr = lanai->service.start;
+			if (_cur < timeout) {
--
 	while (pool->skb[index]) {
 		index = (index + 1) & FBQ_MASK;
 		if (index == pool->index)
 			return -ENOBUFS;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while ((skb = skb_dequeue(&scq->transmit))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&scq->transmit))) {
 		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
 				 skb->len, PCI_DMA_TODEVICE);
 
@@ -683,9 +699,20 @@ free_scq(struct idt77252_dev *card, stru
 			vcc->pop(vcc, skb);
--
-	while ((skb = skb_dequeue(&scq->pending))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&scq->pending))) {
 		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
 				 skb->len, PCI_DMA_TODEVICE);
 
@@ -694,6 +721,12 @@ free_scq(struct idt77252_dev *card, stru
 			vcc->pop(vcc, skb);
--
 	while (head != tail) {
 		unsigned int vpi, vci;
 		u32 header;
@@ -1363,6 +1401,12 @@ drop:
 				break;
 			}
--
 	while (r > 0) {
 		if ((cl >= avail) && (card->soft_tst[e].vc == NULL)) {
 			if (vc)
@@ -1650,6 +1699,12 @@ __fill_tst(struct idt77252_dev *card, st
 		if (++e == avail)
 			e = 0;
--
 	while (count--) {
 		skb = dev_alloc_skb(size);
 		if (!skb)
@@ -1873,6 +1933,12 @@ add_rx_skb(struct idt77252_dev *card, in
 			printk("%s: FB QUEUE full\n", __func__);
 			goto outunmap;
--
 	while (idt77252_chain) {
 		card = idt77252_chain;
 		dev = card->atmdev;
@@ -3783,6 +3854,12 @@ static void __exit idt77252_exit(void)
 		deinit_card(card);
 		pci_disable_device(card->pcidev);
--
 	while (len > 0) {
 		printk ("%p ", ptr);
 		for (j=0;j < ((len < 16)?len:16);j++) {
@@ -361,6 +366,12 @@ static void my_hd (void *addr, int len)
 		printk ("\n");
 		ptr += 16;
--
 		while (!(man & (1<<31))) {
 			exp = exp - 1;
 			man = man<<1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-	while ((wp = read_fs (dev, Q_WP (q->offset))) & Q_FULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((wp = read_fs (dev, Q_WP (q->offset))) & Q_FULL) {
 		fs_dprintk (FS_DEBUG_TXQ, "Found queue at %x full. Waiting.\n", 
 			    q->offset);
 		schedule ();
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {
 		fs_dprintk (FS_DEBUG_QUEUE, "reaping return queue entry at %lx\n", rq); 
 		qe = bus_to_virt (rq);
@@ -697,6 +735,12 @@ static void process_return_queue (struct
 		}
     
--
 	while (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {
 		fs_dprintk (FS_DEBUG_QUEUE, "reaping txdone entry at %lx\n", rq); 
 		qe = bus_to_virt (rq);
@@ -767,6 +816,12 @@ static void process_txdone_queue (struct
 		}
     
--
 	while (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {
 		fs_dprintk (FS_DEBUG_QUEUE, "reaping incoming queue entry at %lx\n", rq); 
 		qe = bus_to_virt (rq);
@@ -850,6 +910,12 @@ static void process_incoming (struct fs_
 				STATUS_CODE(qe), res_strings[STATUS_CODE (qe)]);
 		}
--
 	while (reginit->reg != PHY_EOF) {
 		if (reginit->reg == PHY_CLEARALL) {
 			/* "PHY_CLEARALL means clear all registers. Numregisters is in "val". */
@@ -1341,6 +1412,12 @@ static int __devinit init_phy (struct fs
 			write_phy (dev, reginit->reg, reginit->val);
 		}
--
     while (buffer) {
 
 	if (buffer->supplied) {
@@ -979,6 +984,12 @@ int bsq_audit(int where, struct host_bsq
 
 	count++;
--
-	    while (bsq->freebuf_count >= RBD_BLK_SIZE) {
+	    unsigned long long delta = (cpu / khz / HZ) * 2;
+	    unsigned long long _start = 0;
+	    unsigned long long _cur = 0;
+	    unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bsq->freebuf_count >= RBD_BLK_SIZE) {
 
 		DPRINTK(2, "supplying %d rx buffers to queue %d / %d, freebuf_count = %d\n",
 			RBD_BLK_SIZE, scheme, magn, bsq->freebuf_count);
@@ -1042,6 +1058,12 @@ fore200e_supply(struct fore200e* fore200
 
--
     while (time_before(jiffies, timeout)) {
 
 	c = (int) fore200e->bus->read(&monitor->soft_uart.recv);
@@ -2471,6 +2498,12 @@ fore200e_monitor_getc(struct fore200e* f
 #endif
 	    return c & 0xFF;
--
     while (*str) {
 
 	/* the i960 monitor doesn't accept any new character if it has something to say */
 	while (fore200e_monitor_getc(fore200e) >= 0);
 	
 	fore200e_monitor_putc(fore200e, *str++);
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
--
     while (fore200e_monitor_getc(fore200e) >= 0);
diff -u -p a/atm/ambassador.c b/atm/ambassador.c
--- a/atm/ambassador.c
+++ b/atm/ambassador.c
@@ -591,17 +591,39 @@ static int command_do (amb_dev * dev, co
     msleep(cq->pending);
--
     while (ptrs->out != my_slot) {
       PRINTD (DBG_CMD, "wait: command slot (now at %p)", ptrs->out);
       set_current_state(TASK_UNINTERRUPTIBLE);
       schedule();
+      if (_cur < timeout) {
+        rdstcll(_cur);
--
     while (ptrs->out->request != cpu_to_be32 (SRB_COMPLETE)) {
       PRINTD (DBG_CMD, "wait: command slot completion");
       set_current_state(TASK_UNINTERRUPTIBLE);
       schedule();
+      if (_cur < timeout) {
+        rdstcll(_cur);
--
   while (rxq->pending < rxq->maximum && rxq->pending < rxq->buffers_wanted) {
     
     struct sk_buff * skb = alloc_skb (rxq->buffer_size, priority);
@@ -808,6 +835,12 @@ static void fill_rx_pool (amb_dev * dev,
     if (rx_give (dev, &rx, pool))
       dev_kfree_skb_any (skb);
--
     while (!(man & (1<<31))) {
       exp = exp - 1;
       man = man<<1;
+      if (_cur < timeout) {
+	rdstcll(_cur);
+      }
--
   while (command_do (dev, &cmd)) {
     set_current_state(TASK_UNINTERRUPTIBLE);
     schedule();
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
--
   while (command_do (dev, &cmd)) {
     set_current_state(TASK_UNINTERRUPTIBLE);
     schedule();
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
--
 	while ((reason = GET(PICR))) {
 		if (reason & uPD98402_INT_LOS)
 			printk(KERN_NOTICE "%s(itf %d): signal lost\n",
@@ -203,6 +208,12 @@ static void uPD98402_int(struct atm_dev
 			    "FIFO overflow\n",dev->type,dev->number);
 			silence = (jiffies+HZ/2)|1;
--
   while (dev->host_tcq_wr != tcq_wr) {
      desc1 = *(u_short *)(dev->seg_ram + dev->host_tcq_wr);
      if (!desc1) ;
@@ -171,6 +176,12 @@ static void ia_hack_tcq(IADEV *dev) {
      dev->host_tcq_wr += 2;
      if (dev->host_tcq_wr > dev->ffL.tcq_ed) 
--
      while (i < dev->num_tx_desc) {
         if (!dev->desc_tbl[i].timestamp) {
            i++;
@@ -210,6 +226,12 @@ static u16 get_desc (IADEV *dev, struct
            dev->desc_tbl[i].txskb = NULL;
         }
--
      } /* while */
   }
   if (dev->ffL.tcq_rd == dev->host_tcq_wr) 
@@ -218,6 +240,11 @@ static u16 get_desc (IADEV *dev, struct
   /* Get the next available descriptor number from TCQ */
   desc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);
--
   while (!desc_num || (dev->desc_tbl[desc_num -1]).timestamp) {
      dev->ffL.tcq_rd += 2;
      if (dev->ffL.tcq_rd > dev->ffL.tcq_ed) 
@@ -225,6 +252,12 @@ static u16 get_desc (IADEV *dev, struct
      if (dev->ffL.tcq_rd == dev->host_tcq_wr) 
         return 0xFFFF; 
--
   while (tmp != 1) {
      tmp >>= 1;
      i++;
+     if (_cur < timeout) {
+       rdstcll(_cur);
+     }
--
    while (toBeAssigned)
    {
       // If this is the first time, start the table loading for this connection
@@ -562,6 +611,12 @@ static int ia_cbr_setup (IADEV *dev, str
        memcpy((caddr_t)TstSchedTbl, (caddr_t)&vcIndex, sizeof(*TstSchedTbl));
        dev->CbrRemEntries--;
--
    } /* while */ 
 
    /* IaFFrednCbrEnable */
@@ -663,6 +718,11 @@ static void ia_tx_poll (IADEV *iadev) {
        }
 
--
        while (skb1 && (skb1 != skb)) {
           if (!(IA_SKB_STATE(skb1) & IA_TX_DONE)) {
              printk("IA_tx_intr: Vci %d lost pkt!!!\n", vcc->vci);
@@ -677,6 +737,12 @@ static void ia_tx_poll (IADEV *iadev) {
           else 
              dev_kfree_skb_any(skb1);
--
 	while (len--) {
 		ia_phy_write32(iadev, regs->reg, regs->val);
 		regs++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
     while(count < length){
         pBuf += sprintf( pBuf, "%s", prefix );
         for(col = 0;count + col < length && col < 16; col++){
@@ -988,10 +1070,21 @@ static void xdump( u_char*  cp, int  len
                 pBuf += sprintf( pBuf, " " );
             pBuf += sprintf( pBuf, "%02X ", cp[count + col] );
--
         while(col++ < 16){      /* pad end of buffer with blanks */
             if ((col % 4) == 0)
                 sprintf( pBuf, " " );
             pBuf += sprintf( pBuf, "   " );
+            if (_cur < timeout) {
+                rdstcll(_cur);
--
   while (tcq_st_ptr != tcq_ed_ptr) {
       tmp = iadev->seg_ram+tcq_st_ptr;
       printk("TCQ slot %d desc = %d  Addr = %p\n", i++, readw(tmp), tmp);
       tcq_st_ptr += 2;
+      if (_cur < timeout) {
+  rdstcll(_cur);
--
 	while(!(state & PCQ_EMPTY))  
 	{  
              rx_pkt(dev);  
 	     state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  
-	}  
+	     if (_cur < timeout) {
--
   while(dle != cur_dle)  
   {  
       /* free the DMAed skb */  
@@ -1353,6 +1479,12 @@ static void rx_dle_intr(struct atm_dev *
 INCR_DLE:
       if (++dle == iadev->rx_dle_q.end)  
--
        while (i != iadev->num_vc) {
           i /= 2;
           vcsize_sel++;
+          if (_cur < timeout) {
+       	rdstcll(_cur);
+          }
--
         while (i != iadev->num_vc) {
           i /= 2;
           vcsize_sel++;
+          if (_cur < timeout) {
+        rdstcll(_cur);
+          }
--
-	while (--i >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (--i >= 0) {
 		struct cpcs_trailer_desc *desc = iadev->tx_buf + i;
 
 		pci_unmap_single(iadev->pci, desc->dma_addr,
 			sizeof(*desc->cpcs), PCI_DMA_TODEVICE);
 		kfree(desc->cpcs);
--
    while( (status = readl(iadev->reg+IPHASE5575_BUS_STATUS_REG) & 0x7f))  
    { 
 	handled = 1;
@@ -2252,6 +2422,12 @@ static irqreturn_t ia_int(int irq, void
            if (status & STAT_FEINT) 
                ia_frontend_intr(iadev);
--
            while((skb = skb_dequeue(&iadev->tx_backlog))) {
               if (ATM_SKB(skb)->vcc == vcc){ 
                  if (vcc->pop) vcc->pop(vcc, skb);
@@ -2627,6 +2808,12 @@ static void ia_close(struct atm_vcc *vcc
               }
               else 
--
            while((skb = skb_dequeue(&tmp_tx_backlog))) 
              skb_queue_tail(&iadev->tx_backlog, skb);
diff -u -p a/atm/nicstar.c b/atm/nicstar.c
--- a/atm/nicstar.c
+++ b/atm/nicstar.c
@@ -229,17 +229,39 @@ static void __devexit nicstar_remove_one
--
 	while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL) {
 		dev_kfree_skb_any(hb);
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL) {
 		dev_kfree_skb_any(iovb);
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
@@ -1164,6 +1186,11 @@ static irqreturn_t ns_irq_handler(int ir
 		/* NOTE: the following procedure may keep a raw cell pending until the
 		   next interrupt. As this preliminary support is only meant to
 		   avoid buffer leakage, this is not an issue. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (readl(card->membase + RAWCT) != card->rawch) {
 
 			if (ns_rcqe_islast(card->rawcell)) {
@@ -1180,6 +1207,12 @@ static irqreturn_t ns_irq_handler(int ir
 				card->rawch += NS_RCQE_SIZE;
 				card->rawcell++;
--
 	while (r > 0) {
 		if (cl >= NS_TST_NUM_ENTRIES && card->tste2vc[e] == NULL) {
 			card->tste2vc[e] = vc;
@@ -1630,6 +1668,12 @@ static void fill_tst(ns_dev * card, int
 			e = 0;
 		}
--
 	while (scq->tail == scq->next) {
 		if (in_interrupt()) {
 			spin_unlock_irqrestore(&scq->lock, flags);
@@ -1764,6 +1813,12 @@ static int push_scqe(ns_dev * card, vc_m
 			       card->index);
 			return 1;
--
 	while (!ns_tsi_isempty(card->tsq.next) || !ns_tsi_isempty(one_ahead) ||
 	       !ns_tsi_isempty(two_ahead))
 		/* At most two empty, as stated in the 77201 errata */
@@ -1872,11 +1932,22 @@ static void process_tsq(ns_dev * card)
 		serviced_entries = 1;
 
--
 		while (ns_tsi_isempty(card->tsq.next)) {
 			if (card->tsq.next == card->tsq.last)
 				card->tsq.next = card->tsq.base;
 			else
 				card->tsq.next++;
+				if (_cur < timeout) {
--
-	while (i != pos) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i != pos) {
 		skb = scq->skb[i];
 		XPRINTK("nicstar%d: freeing skb at 0x%p (index %d).\n",
 			card->index, skb, i);
@@ -1958,6 +2040,12 @@ static void drain_scq(ns_dev * card, scq
 		}
--
 			while (card->sbfqc < card->sbnr.init) {
 				struct sk_buff *sb;
 
@@ -2681,10 +2774,21 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->sbpool.queue, sb);
 				skb_reserve(sb, NS_AAL0_HEADER);
--
 			while (card->lbfqc < card->lbnr.init) {
 				struct sk_buff *lb;
 
@@ -2695,10 +2799,21 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->lbpool.queue, lb);
 				skb_reserve(lb, NS_SMBUFSIZE);
--
 			while (card->hbpool.count > card->hbnr.init) {
 				struct sk_buff *hb;
 
@@ -2713,7 +2828,18 @@ static int ns_ioctl(struct atm_dev *dev,
 				else
 					dev_kfree_skb_any(hb);
--
 			while (card->hbpool.count < card->hbnr.init) {
 				struct sk_buff *hb;
 
@@ -2725,10 +2851,21 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->hbpool.queue, hb);
 				card->hbpool.count++;
--
 			while (card->iovpool.count > card->iovnr.init) {
 				struct sk_buff *iovb;
 
@@ -2743,7 +2880,18 @@ static int ns_ioctl(struct atm_dev *dev,
 				else
 					dev_kfree_skb_any(iovb);
--
 			while (card->iovpool.count < card->iovnr.init) {
 				struct sk_buff *iovb;
 
@@ -2755,6 +2903,12 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->iovpool.queue, iovb);
 				card->iovpool.count++;
--
 	while (1) {
 		if (dm_bufio_cache_size_latch != 1) {
 			b = alloc_buffer(c, GFP_NOIO | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);
@@ -765,6 +770,12 @@ static struct dm_buffer *__alloc_buffer_
 			return b;
 
--
 	while (c->n_buffers[LIST_CLEAN] + c->n_buffers[LIST_DIRTY] >
 	       limit_buffers) {
 
@@ -862,6 +878,12 @@ static void __check_watermark(struct dm_
 
 		__free_buffer_wake(b);
--
 	while (c->need_reserved_buffers) {
 		struct dm_buffer *b = alloc_buffer(c, GFP_KERNEL);
 
@@ -1480,6 +1507,12 @@ struct dm_bufio_client *dm_bufio_client_
 			goto bad_buffer;
 		}
--
-	while (!list_empty(&c->reserved_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&c->reserved_buffers)) {
 		struct dm_buffer *b = list_entry(c->reserved_buffers.next,
 						 struct dm_buffer, lru_list);
 		list_del(&b->lru_list);
 		free_buffer(b);
+		if (_cur < timeout) {
--
-	while (!list_empty(&c->reserved_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&c->reserved_buffers)) {
 		struct dm_buffer *b = list_entry(c->reserved_buffers.next,
 						 struct dm_buffer, lru_list);
 		list_del(&b->lru_list);
 		free_buffer(b);
+		if (_cur < timeout) {
--
 	while(j--) {
 		bio = r1_bio->bios[j];
 		for (i = 0; i < RESYNC_PAGES; i++) {
@@ -116,6 +121,12 @@ static void * r1buf_pool_alloc(gfp_t gfp
 			bio->bi_io_vec[i].bv_page = page;
 			bio->bi_vcnt = i+1;
--
 		while (bio) { /* submit pending writes */
 			struct bio *next = bio->bi_next;
 			bio->bi_next = NULL;
 			generic_make_request(bio);
 			bio = next;
+			if (_cur < timeout) {
--
 	while(sectors) {
 		int s = sectors;
 		int d = r1_bio->read_disk;
@@ -1566,6 +1593,11 @@ static int fix_sync_read_error(struct r1
 
 		start = d;
--
 		while (d != r1_bio->read_disk) {
 			if (d == 0)
 				d = conf->raid_disks;
@@ -1579,8 +1611,19 @@ static int fix_sync_read_error(struct r1
 				r1_bio->bios[d]->bi_end_io = NULL;
 				rdev_dec_pending(rdev, mddev);
--
 		while (d != r1_bio->read_disk) {
 			if (d == 0)
 				d = conf->raid_disks;
@@ -1592,10 +1635,22 @@ static int fix_sync_read_error(struct r1
 					    bio->bi_io_vec[idx].bv_page,
 					    READ) != 0)
--
 		while (d != read_disk) {
 			if (d==0)
 				d = conf->raid_disks;
@@ -1798,8 +1858,19 @@ static void fix_read_error(struct r1conf
 			    test_bit(In_sync, &rdev->flags))
 				r1_sync_page_io(rdev, sect, s,
--
 		while (d != read_disk) {
 			char b[BDEVNAME_SIZE];
 			if (d==0)
@@ -1820,6 +1891,12 @@ static void fix_read_error(struct r1conf
 					       bdevname(rdev->bdev, b));
 				}
--
 	while (sect_to_write) {
 		struct bio *wbio;
 		if (sectors > sect_to_write)
@@ -1917,6 +1999,12 @@ static int narrow_write_error(struct r1b
 		sect_to_write -= sectors;
 		sector += sectors;
--
 					while (i > 0) {
 						i--;
 						bio = r1_bio->bios[i];
@@ -2380,6 +2473,12 @@ static sector_t sync_request(struct mdde
 						bio->bi_vcnt--;
 						bio->bi_size -= len;
--
 	while ((ds->sweeper != ds->current_entry) &&
 	       !ds->entries[ds->sweeper].count) {
 		list_splice_init(&ds->entries[ds->sweeper].work_items, head);
 		ds->sweeper = ds_next(ds->sweeper);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while ((bio = bio_list_pop(&bios))) {
 		if (dm_get_mapinfo(bio)->ptr == tc)
 			bio_endio(bio, DM_ENDIO_REQUEUE);
 		else
 			bio_list_add(master, bio);
+			if (_cur < timeout) {
--
 	while (argc && !r) {
 		arg_name = dm_shift_arg(as);
 		argc--;
@@ -1691,6 +1718,12 @@ static int parse_pool_features(struct dm
 
 		ti->error = "Unrecognised pool feature requested";
--
 	while (begin < end) {
 		if (!(begin & (ENTRIES_PER_WORD - 1)) &&
 		    bitmap_word_used(addr, begin)) {
@@ -181,6 +186,12 @@ static int sm_find_free(void *addr, unsi
 		}
 
--
 	while (hi - lo > 1) {
 		int mid = lo + ((hi - lo) / 2);
 		uint64_t mid_key = le64_to_cpu(n->keys[mid]);
@@ -53,6 +58,12 @@ static int bsearch(struct btree_node *n,
 			lo = mid;
 		else
--
 	while (unprocessed_frames(s)) {
 		uint32_t flags;
 		struct frame *f;
@@ -285,6 +301,12 @@ int dm_btree_del(struct dm_btree_info *i
 			}
 			f->current_child = f->nr_children;
--
 	while (bio->bi_idx < bio->bi_vcnt &&
 	       bio->bi_io_vec[bio->bi_idx].bv_len <= offset) {
 		/* remove this whole bio_vec */
 		offset -= bio->bi_io_vec[bio->bi_idx].bv_len;
 		bio->bi_idx++;
+		if (_cur < timeout) {
--
 		while (!is_free) {
 			dev = MKDEV(MD_MAJOR, next_minor);
 			next_minor++;
@@ -667,6 +683,12 @@ static struct mddev * mddev_find(dev_t u
 					is_free = 0;
 					break;
--
 	while (*cmd && *str && *cmd == *str) {
 		cmd++;
 		str++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (isdigit(*cp) || (*cp == '.' && decimals < 0)) {
 		if (*cp == '.')
 			decimals = 0;
@@ -3236,6 +3274,12 @@ int strict_strtoul_scaled(const char *cp
 				decimals++;
 		}
--
 	while (decimals < scale) {
 		result *= 10;
 		decimals ++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
--
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 
 		/* We need to wait INTERRUPTIBLE so that
 		 * we don't add to the load-average.
@@ -6436,6 +6496,12 @@ static int md_thread(void * arg)
 		clear_bit(THREAD_WAKEUP, &thread->flags);
--
 		while (j >= mddev->resync_max && !kthread_should_stop()) {
 			/* As this condition is controlled by user-space,
 			 * we can block indefinitely, so use '_interruptible'
@@ -7209,6 +7280,12 @@ void md_do_sync(struct mddev *mddev)
 			wait_event_interruptible(mddev->recovery_wait,
 						 mddev->resync_max > j
--
 	while (hi - lo > 1) {
 		int mid = (lo + hi) / 2;
 		sector_t a = BB_OFFSET(p[mid]);
@@ -7693,12 +7775,23 @@ retry:
 		else
 			/* This and later ranges are definitely out. */
--
 		while (lo >= 0 &&
 		       BB_OFFSET(p[lo]) + BB_LEN(p[lo]) > s) {
 			if (BB_OFFSET(p[lo]) < target) {
@@ -7713,6 +7806,12 @@ retry:
 				*bad_sectors = BB_LEN(p[lo]);
 			}
--
 	while (hi - lo > 1) {
 		int mid = (lo + hi) / 2;
 		sector_t a = BB_OFFSET(p[mid]);
@@ -7763,6 +7867,12 @@ static int md_set_badblocks(struct badbl
 			lo = mid;
 		else
--
 	while (sectors) {
 		/* didn't merge (it all).
 		 * Need to add a range just before 'hi' */
@@ -7861,6 +7976,12 @@ static int md_set_badblocks(struct badbl
 			sectors -= this_sectors;
 			s += this_sectors;
--
 	while (hi - lo > 1) {
 		int mid = (lo + hi) / 2;
 		sector_t a = BB_OFFSET(p[mid]);
@@ -7925,6 +8051,12 @@ static int md_clear_badblocks(struct bad
 			lo = mid;
 		else
--
 	while (len < PAGE_SIZE && i < bb->count) {
 		sector_t s = BB_OFFSET(p[i]);
 		unsigned int length = BB_LEN(p[i]);
@@ -8058,6 +8195,12 @@ retry:
 		len += snprintf(page+len, PAGE_SIZE-len, "%llu %u\n",
 				(unsigned long long)s << bb->shift,
--
-	while (!list_empty(&all_detected_devices) && i_scanned < INT_MAX) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&all_detected_devices) && i_scanned < INT_MAX) {
 		i_scanned++;
 		node_detected_dev = list_entry(all_detected_devices.next,
 					struct detected_devices_node, list);
@@ -8250,6 +8398,12 @@ static void autostart_arrays(int part)
 		set_bit(AutoDetected, &rdev->flags);
--
 	while (bi) {
 
 		return_bi = bi->bi_next;
@@ -178,6 +183,12 @@ static void return_io(struct bio *return
 		bi->bi_size = 0;
 		bio_endio(bi, 0);
--
 			while (rbi && rbi->bi_sector <
 				dev->sector + STRIPE_SECTORS) {
 				rbi2 = r5_next_bio(rbi, dev->sector);
@@ -682,6 +698,12 @@ static void ops_complete_biofill(void *s
 					return_bi = rbi;
 				}
--
-			while (rbi && rbi->bi_sector <
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (rbi && rbi->bi_sector <
 				dev->sector + STRIPE_SECTORS) {
 				tx = async_copy_data(0, rbi, dev->page,
 					dev->sector, tx);
 				rbi = r5_next_bio(rbi, dev->sector);
+				if (_cur < timeout) {
--
-			while (wbi && wbi->bi_sector <
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (wbi && wbi->bi_sector <
 				dev->sector + STRIPE_SECTORS) {
 				if (wbi->bi_rw & REQ_FUA)
 					set_bit(R5_WantFUA, &dev->flags);
 				tx = async_copy_data(1, wbi, dev->page,
 					dev->sector, tx);
--
 		while (!list_empty(&newstripes)) {
 			nsh = list_entry(newstripes.next, struct stripe_head, lru);
 			list_del(&nsh->lru);
 			kmem_cache_free(sc, nsh);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while(!list_empty(&newstripes)) {
 		nsh = list_entry(newstripes.next, struct stripe_head, lru);
 		list_del_init(&nsh->lru);
@@ -1549,6 +1609,12 @@ static int resize_stripes(struct r5conf
 					err = -ENOMEM;
 			}
--
 	while (*bip && (*bip)->bi_sector < bi->bi_sector) {
 		if ((*bip)->bi_sector + ((*bip)->bi_size >> 9) > bi->bi_sector)
 			goto overlap;
 		bip = & (*bip)->bi_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (bi && bi->bi_sector <
 			sh->dev[i].sector + STRIPE_SECTORS) {
 			struct bio *nextbi = r5_next_bio(bi, sh->dev[i].sector);
@@ -2306,11 +2388,22 @@ handle_failed_stripe(struct r5conf *conf
 				*return_bi = bi;
 			}
--
 		while (bi && bi->bi_sector <
 		       sh->dev[i].sector + STRIPE_SECTORS) {
 			struct bio *bi2 = r5_next_bio(bi, sh->dev[i].sector);
@@ -2321,6 +2414,12 @@ handle_failed_stripe(struct r5conf *conf
 				*return_bi = bi;
 			}
--
-			while (bi && bi->bi_sector <
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (bi && bi->bi_sector <
 			       sh->dev[i].sector + STRIPE_SECTORS) {
 				struct bio *nextbi =
 					r5_next_bio(bi, sh->dev[i].sector);
@@ -2344,6 +2448,12 @@ handle_failed_stripe(struct r5conf *conf
 					*return_bi = bi;
--
 				while (wbi && wbi->bi_sector <
 					dev->sector + STRIPE_SECTORS) {
 					wbi2 = r5_next_bio(wbi, dev->sector);
@@ -2538,6 +2653,12 @@ static void handle_stripe_clean_event(st
 						*return_bi = wbi;
 					}
--
 		while (!list_empty(&conf->delayed_list)) {
 			struct list_head *l = conf->delayed_list.next;
 			struct stripe_head *sh;
@@ -3407,6 +3533,12 @@ static void raid5_activate_delayed(struc
 			if (!test_and_set_bit(STRIPE_PREREAD_ACTIVE, &sh->state))
 				atomic_inc(&conf->preread_active_stripes);
--
 	while (!list_empty(&head)) {
 		struct stripe_head *sh = list_entry(head.next, struct stripe_head, lru);
 		list_del_init(&sh->lru);
 		atomic_inc(&sh->count);
 		__release_stripe(conf, sh);
+		if (_cur < timeout) {
--
 	while (first_sector <= last_sector) {
 		sh = get_active_stripe(conf, first_sector, 1, 0, 1);
 		set_bit(STRIPE_EXPAND_SOURCE, &sh->state);
 		set_bit(STRIPE_HANDLE, &sh->state);
 		release_stripe(sh);
 		first_sector += STRIPE_SECTORS;
--
 	while (!list_empty(&stripes)) {
 		sh = list_entry(stripes.next, struct stripe_head, lru);
 		list_del_init(&sh->lru);
 		release_stripe(sh);
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (size < conf->max_nr_stripes) {
 		if (drop_one_stripe(conf))
 			conf->max_nr_stripes--;
 		else
 			break;
+			if (_cur < timeout) {
--
 	while (size > conf->max_nr_stripes) {
 		if (grow_one_stripe(conf))
 			conf->max_nr_stripes++;
 		else break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (pl) {
 		next = pl->next;
 		free_pl(pl);
 		pl = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (origin_write_extent(s, dest.sector, io_size)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (origin_write_extent(s, dest.sector, io_size)) {
 		wait_event(_pending_exceptions_done,
 			   (read_pending_exceptions_done_count() !=
 			    previous_count));
 		/* Retry after the wait, until all exceptions are done. */
 		previous_count = read_pending_exceptions_done_count();
--
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
 		generic_make_request(bio);
 		bio = n;
+		if (_cur < timeout) {
--
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
@@ -1357,6 +1384,12 @@ static void retry_origin_bios(struct dm_
 		if (r == DM_MAPIO_REMAPPED)
 			generic_make_request(bio);
--
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
 		bio_io_error(bio);
 		bio = n;
+		if (_cur < timeout) {
--
 	while(ctx->idx_in < ctx->bio_in->bi_vcnt &&
 	      ctx->idx_out < ctx->bio_out->bi_vcnt) {
 
@@ -803,6 +808,12 @@ static int crypt_convert(struct crypt_co
 			atomic_dec(&ctx->pending);
 			return r;
--
 	while (as.argc) {
 		struct priority_group *pg;
 
@@ -845,6 +850,12 @@ static int multipath_ctr(struct dm_targe
 		pg->pg_num = pg_count;
 		if (!--next_pg_num)
--
 	while (!blk_queue_stopped(q)) {
 		rq = blk_peek_request(q);
 		if (!rq)
@@ -1678,6 +1683,12 @@ static void dm_request_fn(struct request
 
 		BUG_ON(!irqs_disabled());
--
 	while (i < dm_table_get_num_targets(table)) {
 		ti = dm_table_get_target(table, i++);
 
 		if (ti->type->iterate_devices &&
 		    ti->type->iterate_devices(ti, dm_device_merge_is_compulsory, NULL))
 			return 0;
--
 	while ((rdev = next_active_rdev(rdev, mddev)) != NULL) {
 		int size = PAGE_SIZE;
 		loff_t offset = mddev->bitmap_info.offset;
@@ -282,6 +287,12 @@ static int write_sb_page(struct bitmap *
 			       + page->index * (PAGE_SIZE/512),
 			       size,
--
 		while (bh && bh->b_blocknr) {
 			atomic_inc(&bitmap->pending_writes);
 			set_buffer_locked(bh);
 			set_buffer_mapped(bh);
 			submit_bh(WRITE | REQ_SYNC, bh);
 			bh = bh->b_this_page;
--
 	while (bh) {
 		struct buffer_head *next = bh->b_this_page;
 		free_buffer_head(bh);
 		bh = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (bh) {
 		if (count == 0)
 			bh->b_blocknr = 0;
@@ -419,6 +457,12 @@ static struct page *read_page(struct fil
 		}
 		block++;
--
 	while (sectors) {
 		sector_t blocks;
 		bitmap_counter_t *bmc;
@@ -1376,6 +1425,12 @@ int bitmap_startwrite(struct bitmap *bit
 			sectors -= blocks;
 		else
--
 	while (sectors) {
 		sector_t blocks;
 		unsigned long flags;
@@ -1434,6 +1494,12 @@ void bitmap_endwrite(struct bitmap *bitm
 			sectors -= blocks;
 		else
--
-	while (*blocks < (PAGE_SIZE>>9)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*blocks < (PAGE_SIZE>>9)) {
 		rv |= __bitmap_start_sync(bitmap, offset,
 					  &blocks1, degraded);
 		offset += blocks1;
 		*blocks += blocks1;
+		if (_cur < timeout) {
--
 	while (sector < bitmap->mddev->resync_max_sectors) {
 		bitmap_end_sync(bitmap, sector, &blocks, 0);
 		sector += blocks;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (s < sector && s < bitmap->mddev->resync_max_sectors) {
 		bitmap_end_sync(bitmap, s, &blocks, 0);
 		s += blocks;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while (sector < mddev->resync_max_sectors) {
 		sector_t blocks;
 		bitmap_start_sync(bitmap, sector, &blocks, 0);
 		sector += blocks;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
 		generic_make_request(bio);
 		bio = n;
+		if (_cur < timeout) {
--
 	while (hi > lo) {
 
 		mid = (hi + lo) / 2;
@@ -47,6 +52,12 @@ static inline struct dev_info *which_dev
 			hi = mid;
 		else
--
 		while (sector >= conf->stride) {
 			sector -= conf->stride;
 			if (dev < conf->near_copies)
 				dev += conf->raid_disks - conf->near_copies;
 			else
 				dev -= conf->near_copies;
--
 		while (bio) { /* submit pending writes */
 			struct bio *next = bio->bi_next;
 			bio->bi_next = NULL;
 			generic_make_request(bio);
 			bio = next;
+			if (_cur < timeout) {
--
 		while (n--) {
 			if (conf->mirrors[this].rdev &&
 			    this != ignore)
 				cnt++;
 			this = (this+1) % conf->raid_disks;
+			if (_cur < timeout) {
--
 	while (atomic_dec_and_test(&r10_bio->remaining)) {
 		if (r10_bio->master_bio == NULL) {
 			/* the primary of several recovery bios */
@@ -1505,6 +1543,12 @@ static void end_sync_request(struct r10b
 				put_buf(r10_bio);
 			r10_bio = r10_bio2;
--
 		while (sl != r10_bio->read_slot) {
 			char b[BDEVNAME_SIZE];
 
@@ -1949,8 +1998,19 @@ static void fix_read_error(struct r10con
 			}
 			rdev_dec_pending(rdev, mddev);
--
 		while (sl != r10_bio->read_slot) {
 			char b[BDEVNAME_SIZE];
 
@@ -1998,6 +2058,12 @@ static void fix_read_error(struct r10con
 
 			rdev_dec_pending(rdev, mddev);
--
 	while (sect_to_write) {
 		struct bio *wbio;
 		if (sectors > sect_to_write)
@@ -2078,6 +2149,12 @@ static int narrow_write_error(struct r10
 		sect_to_write -= sectors;
 		sector += sectors;
--
 			while (r10_bio) {
 				struct r10bio *rb2 = r10_bio;
 				r10_bio = (struct r10bio*) rb2->master_bio;
 				rb2->master_bio = NULL;
 				put_buf(rb2);
+				if (_cur < timeout) {
--
 	while (biolist) {
 		bio = biolist;
 		biolist = biolist->bi_next;
@@ -2738,6 +2831,12 @@ static sector_t sync_request(struct mdde
 			md_sync_acct(bio->bi_bdev, nr_sectors);
 			generic_make_request(bio);
--
 	while (n > 1) {
 		n = dm_div_up(n, base);
 		result++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (i < dm_table_get_num_targets(table)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < dm_table_get_num_targets(table)) {
 		blk_set_default_limits(&ti_limits);
 
 		ti = dm_table_get_target(table, i++);
@@ -1280,6 +1296,12 @@ combine_limits:
 			       dm_device_name(table->md),
--
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
@@ -1340,6 +1367,12 @@ static bool dm_table_supports_flush(stru
 		if (ti->type->iterate_devices &&
 		    ti->type->iterate_devices(ti, device_flush_capable, &flush))
--
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
 		if (ti->discard_zeroes_data_unsupported)
 			return 0;
+			if (_cur < timeout) {
--
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
 		if (!ti->type->iterate_devices ||
 		    !ti->type->iterate_devices(ti, func, NULL))
 			return 0;
--
 	while (i--) {
 		if (postsuspend) {
 			if (ti->type->postsuspend)
@@ -1479,6 +1539,12 @@ static void suspend_targets(struct dm_ta
 			ti->type->presuspend(ti);
 
--
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
@@ -1607,6 +1678,12 @@ bool dm_table_supports_discards(struct d
 		if (ti->type->iterate_devices &&
 		    ti->type->iterate_devices(ti, device_discard_capable, NULL))
--
 	while (argc) {
 		arg_name = dm_shift_arg(as);
 		argc--;
@@ -126,6 +131,12 @@ static int parse_features(struct dm_arg_
 
 		ti->error = "Unrecognised flakey feature requested";
--
 	while ((reg = dm_rh_recovery_start(ms->rh))) {
 		r = recover(ms, reg);
 		if (r)
 			dm_rh_recovery_end(reg, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while ((bio = bio_list_pop(reads))) {
 		region = dm_rh_bio_to_region(ms->rh, bio);
 		m = get_default_mirror(ms);
@@ -566,6 +582,12 @@ static void do_reads(struct mirror_set *
 			read_async_bio(m, bio);
 		else
--
 	while ((bio = bio_list_pop(writes))) {
 		if ((bio->bi_rw & REQ_FLUSH) ||
 		    (bio->bi_rw & REQ_DISCARD)) {
@@ -705,6 +732,12 @@ static void do_writes(struct mirror_set
 		}
 
--
 	while ((bio = bio_list_pop(&recover)))
 		dm_rh_delay(ms->rh, bio);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while ((bio = bio_list_pop(&nosync))) {
 		if (unlikely(ms->leg_failure) && errors_handled(ms)) {
 			spin_lock_irq(&ms->lock);
@@ -758,6 +796,12 @@ static void do_writes(struct mirror_set
 			map_bio(get_default_mirror(ms), bio);
 			generic_make_request(bio);
--
 	while ((bio = bio_list_pop(failures))) {
 		if (!ms->log_failure) {
 			ms->in_sync = 0;
@@ -805,6 +854,12 @@ static void do_failures(struct mirror_se
 			hold_bio(ms, bio);
 		else
--
-		while (ids->class_id != I2O_CLASS_END) {
-			if (ids->class_id == i2o_dev->lct_data.class_id)
-				return 1;
-			ids++;
+	if (ids) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
--
+			while (ids->class_id != I2O_CLASS_END) {
+				if (ids->class_id == i2o_dev->lct_data.class_id)
+					return 1;
+				ids++;
+				if (_cur < timeout) {
+						rdstcll(_cur);
--
 	while (table_size > 0) {
 		i2o_lct_entry *entry = &lct->lct_entry[max];
 		int found = 0;
@@ -419,6 +424,12 @@ int i2o_device_parse_lct(struct i2o_cont
 
 		table_size -= 9;
--
-	while (sg_count-- > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (sg_count-- > 0) {
 		if (!sg_count)
 			sg_flags |= 0xC0000000;
 		*mptr++ = cpu_to_le32(sg_flags | sg_dma_len(sg));
@@ -162,6 +167,12 @@ int i2o_dma_map_sg(struct i2o_controller
 			*mptr++ = cpu_to_le32(i2o_dma_high(sg_dma_address(sg)));
--
-	while (IS_ERR(msg = i2o_msg_get(c))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (IS_ERR(msg = i2o_msg_get(c))) {
 		if (time_after(jiffies, timeout)) {
 			osm_debug("%s: Timeout waiting for message frame.\n",
 				  c->name);
 			return ERR_PTR(-ETIMEDOUT);
 		}
--
 	while (*status <= I2O_CMD_IN_PROGRESS) {
 		if (time_after(jiffies, timeout)) {
 			osm_warn("%s: Timeout Initializing\n", c->name);
 			return -ETIMEDOUT;
 		}
 		schedule_timeout_uninterruptible(1);
--
 		while (IS_ERR(msg = i2o_msg_get_wait(c, I2O_TIMEOUT_RESET))) {
 			if (time_after(jiffies, timeout)) {
 				osm_err("%s: IOP reset timeout.\n", c->name);
@@ -553,6 +580,12 @@ static int i2o_iop_reset(struct i2o_cont
 				goto exit;
 			}
--
 	while (status_block[87] != 0xFF) {
 		if (time_after(jiffies, timeout)) {
 			osm_err("%s: Get status timeout.\n", c->name);
@@ -954,6 +992,12 @@ int i2o_status_get(struct i2o_controller
 		}
 
--
-	while (i2o_pe->name) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i2o_pe->name) {
 		tmp = proc_create_data(i2o_pe->name, i2o_pe->mode, dir,
 				       i2o_pe->fops, data);
 		if (!tmp)
 			return -1;
 
--
 	while (pe) {
 		tmp = pe->next;
 		i2o_proc_subdir_remove(pe);
 		remove_proc_entry(pe->name, dir);
 		pe = tmp;
+		if (_cur < timeout) {
--
 	while (pe) {
 		tmp = pe->next;
 		if (pe->data == c) {
@@ -2015,6 +2042,12 @@ static void i2o_proc_iop_remove(struct p
 		}
 		osm_debug("removing IOP /proc/i2o/%s\n", c->name);
--
 		while (!mptsas_sas_expander_pg0(ioc, &buffer,
 		    (MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<
 		     MPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle) &&
@@ -3889,6 +3894,12 @@ retry_page:
 				found_expander = 1;
 			}
--
-	while (!mptsas_sas_expander_pg0(ioc, &buffer,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!mptsas_sas_expander_pg0(ioc, &buffer,
 	    (MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<
 	     MPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle)) {
 
@@ -3950,6 +3966,12 @@ mptsas_probe_expanders(MPT_ADAPTER *ioc)
 		    "sas_addr (0x%llx)\n", ioc->name, port_info->num_phys,
--
 	while (!(mptsas_sas_device_pg0(ioc, &sas_device,
 	    MPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE, handle))) {
 
@@ -3987,6 +4014,12 @@ mptsas_probe_devices(MPT_ADAPTER *ioc)
 			continue;
 
--
-	while (chain_idx != MPT_HOST_NO_CHAIN) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (chain_idx != MPT_HOST_NO_CHAIN) {
 
 		/* Save the next chain buffer index */
 		next = ioc->ChainToChain[chain_idx];
@@ -1574,6 +1579,12 @@ mptscsih_freeChainBuffers(MPT_ADAPTER *i
 
--
 	while ((ready = fc_remote_port_chkready(rport) >> 16) == DID_IMM_RETRY
 	 || (loops > 0 && ioc->active == 0)) {
 		spin_unlock_irqrestore(shost->host_lock, flags);
@@ -212,6 +217,12 @@ mptfc_block_error_handler(struct scsi_cm
 		msleep(1000);
 		spin_lock_irqsave(shost->host_lock, flags);
--
 	while (! (nib & 0x4)) { /* eob */
 		/* skip ignore/chain. */
 		if (nib == 0 || nib == 3) {
@@ -1208,6 +1213,12 @@ kfree_sgl(MptSge_t *sgl, dma_addr_t sgl_
 		sg++;
 		bl++;
--
 	while (count > 0) {
 		ctx = GET_LAN_BUFFER_CONTEXT(le32_to_cpu(*pContext));
 
@@ -668,6 +673,12 @@ mpt_lan_send_reply(struct net_device *de
 
 		pContext++;
--
-	while (buckets) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (buckets) {
 		mf = mpt_get_msg_frame(LanCtx, mpt_dev);
 		if (mf == NULL) {
 			printk (KERN_ERR "%s: Unable to alloc request frame\n",
@@ -1282,6 +1298,12 @@ mpt_lan_post_receive_buckets(struct mpt_
 		priv->total_posted += i;
--
 	while ((ioc_state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
 		if (ioc_state == MPI_IOC_STATE_OPERATIONAL) {
 			/*
@@ -3017,6 +3022,12 @@ MakeIocReady(MPT_ADAPTER *ioc, int force
 			mdelay (1);	/* 1 msec delay */
 		}
--
 		while ( sz )
 		{
 			shiftFactor++;
 			sz = sz >> 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (state != MPI_IOC_STATE_OPERATIONAL && --cntdn) {
 		if (sleepFlag == CAN_SLEEP) {
 			msleep(1);
@@ -3428,6 +3455,12 @@ SendIocInit(MPT_ADAPTER *ioc, int sleepF
 
 		state = mpt_GetIocState(ioc, 1);
--
 	while (fwSize--) {
 		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
--
 	while (nextImage) {
 		pExtImage = (MpiExtImageHeader_t *) ((char *)pFwHeader + nextImage);
 
@@ -3763,10 +3812,27 @@ mpt_downloadboot(MPT_ADAPTER *ioc, MpiFw
 						ioc->name, fwSize*4, fwSize*4, ptrFw, load_addr));
 		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, load_addr);
--
 		while (fwSize--) {
 			CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
--
 		while ((diag0val & MPI_DIAG_DRWE) == 0) {
 			/* Write magic sequence to WriteSequence register
 			 * Loop until in diagnostic mode
@@ -4058,6 +4129,12 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 
 			dprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Wrote magic DiagWriteEn sequence (%x)\n",
--
 	while ((state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
 		cntdn--;
 		count++;
@@ -4290,6 +4372,12 @@ SendIocReset(MPT_ADAPTER *ioc, u8 reset_
 		} else {
 			mdelay (1);	/* 1 msec delay */
--
 	while (numSGE - num_sge > 0) {
 		num_chain++;
 		num_sge += (scale - 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((req = blk_fetch_request(rq)) != NULL) {
 		if (req->cmd_type != REQ_TYPE_FS) {
 			printk(KERN_DEBUG "gdrom: Non-fs request ignored\n");
@@ -677,6 +682,12 @@ static void gdrom_request(struct request
 		 */
 		list_add_tail(&req->queuelist, &gdrom_deferred);
--
 	while ((rwreq == 0) && ((req = blk_fetch_request(q)) != NULL)) {
 		if (req->cmd_type != REQ_TYPE_FS)
 			__blk_end_request_all(req, -EIO);
@@ -318,6 +323,12 @@ static void do_viocd_request(struct requ
 			__blk_end_request_all(req, -EIO);
 		} else
--
 	while (size) {
 		err = ec_read(*off, &data[*off - init_off]);
 		if (err)
 			return err;
 		*off += 1;
 		size--;
--
 	while (size) {
 		u8 byte_write = data[*off - init_off];
 		err = ec_write(*off, byte_write);
@@ -89,6 +105,12 @@ static ssize_t acpi_ec_write_io(struct f
 
 		*off += 1;
--
-	while ((level > 0) && parent && (!err)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((level > 0) && parent && (!err)) {
 		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
 					      chandle, &chandle);
 
@@ -1544,6 +1549,12 @@ int acpi_bus_trim(struct acpi_device *st
 			parent = child;
--
 	while (us) {
 		u32 delay = 1000;
 
@@ -603,6 +608,12 @@ void acpi_os_stall(u32 us)
 		udelay(delay);
 		touch_nmi_watchdog();
--
 	while (i < count) {
 
 		/* Print current offset */
@@ -616,6 +621,12 @@ void acpi_ut_dump_buffer2(u8 * buffer, u
 
 		acpi_os_printf("\n");
--
 			while (info->parameters[info->param_count]) {
 				if (info->param_count > ACPI_METHOD_MAX_ARG) {
 					return_ACPI_STATUS(AE_LIMIT);
 				}
 				info->param_count++;
+				if (_cur < timeout) {
--
 	while (next) {
 		prev = next;
 		next = next->method.mutex;
@@ -335,6 +351,12 @@ void acpi_ns_exec_module_code_list(void)
 		/* Delete the (temporary) method object */
 
--
 		while (last_obj_desc->common.next_object) {
 			last_obj_desc = last_obj_desc->common.next_object;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
--
 	while (obj_desc) {
 		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
 		    (obj_desc->data.handler == handler)) {
@@ -345,6 +361,12 @@ acpi_ns_attach_data(struct acpi_namespac
 
 		prev_obj_desc = obj_desc;
--
 	while (obj_desc) {
 		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
 		    (obj_desc->data.handler == handler)) {
@@ -407,6 +434,12 @@ acpi_ns_detach_data(struct acpi_namespac
 
 		prev_obj_desc = obj_desc;
--
 	while (obj_desc) {
 		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
 		    (obj_desc->data.handler == handler)) {
@@ -442,6 +480,12 @@ acpi_ns_get_attached_data(struct acpi_na
 		}
 
--
 	while (next_interface) {
 		acpi_gbl_supported_interfaces = next_interface->next;
 
@@ -156,6 +161,12 @@ void acpi_ut_interface_terminate(void)
 		}
 
--
 	while (next_interface) {
 		if (!ACPI_STRCMP(interface_name, next_interface->name)) {
 
@@ -258,6 +274,12 @@ acpi_status acpi_ut_remove_interface(acp
 
 		previous_interface = next_interface;
--
 	while (next_interface) {
 		if (!ACPI_STRCMP(interface_name, next_interface->name)) {
 			return (next_interface);
 		}
 
 		next_interface = next_interface->next;
--
 	while ((index > ACPI_NAME_SIZE) && (parent_node != acpi_gbl_root_node)) {
 		index -= ACPI_NAME_SIZE;
 
@@ -99,6 +104,12 @@ acpi_ns_build_external_path(struct acpi_
 
 		index--;
--
-	while (next_node && (next_node != acpi_gbl_root_node)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (next_node && (next_node != acpi_gbl_root_node)) {
 		if (ACPI_GET_DESCRIPTOR_TYPE(next_node) != ACPI_DESC_TYPE_NAMED) {
 			ACPI_ERROR((AE_INFO,
 				    "Invalid Namespace Node (%p) while traversing namespace",
@@ -199,6 +215,12 @@ acpi_size acpi_ns_get_pathname_length(st
 		}
 		size += ACPI_PATH_SEGMENT_LENGTH;
 		next_node = next_node->parent;
+		if (_cur < timeout) {
--
 	while (byte_count) {
 		/*
 		 * Final bit positions for the package length bytes:
@@ -103,6 +108,12 @@ acpi_ps_get_next_package_length(struct a
 
 		byte_zero_mask = 0x0F;	/* Use bits [0:3] of byte 0 */
--
 	while (acpi_ps_is_prefix_char(*end)) {
 		end++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+	}
+	else {
--
 		while (aml[length]) {
 			length++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
--
 			while (parser_state->aml < parser_state->pkg_end) {
 				field = acpi_ps_get_next_field(parser_state);
 				if (!field) {
@@ -642,6 +680,12 @@ acpi_ps_get_next_arg(struct acpi_walk_st
 					arg = field;
 				}
--
 		while (next_gpe_block->next) {
 			next_gpe_block = next_gpe_block->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (gpe_xrupt_info) {
 		gpe_block = gpe_xrupt_info->gpe_block_list_head;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (gpe_block) {
 			next_gpe_block = gpe_block->next;
 			ACPI_FREE(gpe_block->event_info);
@@ -86,10 +96,22 @@ static void acpi_ut_terminate(void)
 			ACPI_FREE(gpe_block);
 
--
 	while (gpe_xrupt_info) {
 
 		/* Walk all Gpe Blocks attached to this interrupt level */
 
 		gpe_block = gpe_xrupt_info->gpe_block_list_head;
-		while (gpe_block) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (gpe_block) {
 			walk_info.gpe_block = gpe_block;
 			walk_info.gpe_device = gpe_block->node;
 
@@ -279,9 +289,21 @@ void acpi_ev_update_gpes(acpi_owner_id t
 			}
--
-			while (prev) {
+		else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
--
+				while (prev) {
 
 				/* Traverse all siblings in the parent's argument list */
 
-				next = prev->common.next;
-				if (next == op) {
--
-	while (walk_state) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (walk_state) {
 		if (ACPI_SUCCESS(status)) {
 			/*
 			 * The parse_loop executes AML until the method terminates
@@ -676,6 +693,12 @@ acpi_status acpi_ps_parse_aml(struct acp
 		}
--
 		while ((length < original_object->buffer.length) &&
 		       (original_object->buffer.pointer[length])) {
 			length++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
-		while (length--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (length--) {
 			*elements =
 			    acpi_ut_create_integer_object((u64) *buffer);
 			if (!*elements) {
@@ -499,6 +515,12 @@ acpi_ns_convert_to_package(union acpi_op
 			}
--
 	while ((*string) && (ACPI_IS_SPACE(*string) || *string == '\t')) {
 		string++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (state) {
 
 		/* Get one element of the package */
@@ -973,6 +989,11 @@ acpi_ut_walk_package_tree(union acpi_ope
 			}
 
--
 			while (state->pkg.index >=
 			       state->pkg.source_object->package.count) {
 				/*
@@ -1001,6 +1022,12 @@ acpi_ut_walk_package_tree(union acpi_ope
 				 * completed package object.
 				 */
--
-				while (state_list) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (state_list) {
 					state =
 					    acpi_ut_pop_generic_state
 					    (&state_list);
 					acpi_ut_delete_generic_state(state);
+					if (_cur < timeout) {
--
 		while (handler_obj) {
 			if (handler_obj->address_space.space_id == space_id) {
 				if (handler_obj->address_space.handler_flags &
@@ -184,6 +189,12 @@ acpi_ev_has_default_handler(struct acpi_
 			}
 
--
 	while (obj_desc) {
 
 		/* Is this the correct Region? */
@@ -626,6 +642,12 @@ acpi_ev_detach_region(union acpi_operand
 
 		last_obj_ptr = &obj_desc->region.next;
--
-		while (next_handler_obj) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (next_handler_obj) {
 
 			/* Found a handler, is it for the same address space? */
 
@@ -782,6 +809,12 @@ acpi_ev_install_handler(acpi_handle obj_
 			/* Walk the linked list of handlers attached to this device */
--
 		while (handler_obj) {
 
 			/* Same space_id indicates a handler already installed */
@@ -938,6 +976,12 @@ acpi_ev_install_space_handler(struct acp
 			/* Walk the linked list of handlers */
 
--
 	while (next_node) {
 		if ((next_node->type == ACPI_TYPE_REGION) &&
 		    (next_node->object) &&
@@ -1221,6 +1270,12 @@ static void acpi_ev_orphan_ec_reg_method
 			goto exit;	/* Do not execute _REG */
 		}
--
-	while (level > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (level > 0) {
 
 		/* Attempt to get the next object in this scope */
 
@@ -266,6 +271,12 @@ static acpi_status acpi_ns_delete_subtre
 				return_ACPI_STATUS(status);
--
 	while (arg) {
 		/*
 		 * Three types of field elements are handled:
@@ -329,6 +334,12 @@ acpi_ds_get_field_names(struct acpi_crea
 		}
 
--
 	while (arg) {
 		/*
 		 * Ignore OFFSET and ACCESSAS terms here; we are only interested in the
@@ -500,6 +516,12 @@ acpi_ds_init_field_objects(union acpi_pa
 		/* Get the next field element in the list */
 
--
 	while (1) {
 		status = acpi_get_parent(current_device, &parent_device);
 		if (ACPI_FAILURE(status)) {
@@ -209,6 +214,12 @@ acpi_hw_build_pci_list(acpi_handle root_
 		list_head = list_element;
 
--
-	while (info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (info) {
 		status = acpi_hw_get_pci_device_info(pci_id, info->device,
 						     &bus_number, &is_bridge);
 		if (ACPI_FAILURE(status)) {
@@ -263,6 +279,12 @@ acpi_hw_process_pci_list(struct acpi_pci
 		}
--
 	while (next) {
 		previous = next;
 		next = previous->next;
 		ACPI_FREE(previous);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (acpi_ns_valid_root_prefix(*next_external_char)) {
 			next_external_char++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (*next_external_char == '^') {
 			info->num_carats++;
 			next_external_char++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (next) {
 		obj_desc = next;
 		next = obj_desc->mutex.next;
@@ -494,5 +499,11 @@ void acpi_ex_release_all_mutexes(struct
 
 		thread->current_sync_level =
--
 		while (parent_node) {
 			parent_node->flags |= ANOBJ_SUBTREE_HAS_INI;
 			parent_node = parent_node->parent;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (this_name->repair_function) {
 		if (ACPI_COMPARE_NAME(node->name.ascii, this_name->name)) {
 			return (this_name);
 		}
 		this_name++;
+		if (_cur < timeout) {
--
-	while (current_value) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (current_value) {
 		(void)acpi_ut_short_divide(current_value, base, &current_value,
 					   NULL);
 		num_digits++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (next_node != node) {
 		prev_node = next_node;
 		next_node = next_node->peer;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (child_node->peer) {
 			child_node = child_node->peer;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (next_node) {
 
 		/* Grandchildren should have all been deleted already */
@@ -316,6 +343,12 @@ void acpi_ns_delete_children(struct acpi
 		node_to_delete = next_node;
 		next_node = next_node->peer;
--
 	while (level > 0) {
 
 		/* Get the next node in this scope (NULL if none) */
@@ -403,6 +441,12 @@ void acpi_ns_delete_namespace_subtree(st
 
 			parent_node = parent_node->parent;
--
 	while (level > 0) {
 		/*
 		 * Get the next child of this parent node. When child_node is NULL,
@@ -509,6 +558,12 @@ void acpi_ns_delete_namespace_by_owner(a
 
 			parent_node = parent_node->parent;
--
 	while (node) {
 
 		/* Check for match against the name */
@@ -155,6 +160,12 @@ acpi_ns_search_one_scope(u32 target_name
 		/* Didn't match name, move on to the next peer object */
 
--
-	while (parent_node) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (parent_node) {
 		/*
 		 * Search parent scope. Use TYPE_ANY because we don't care about the
 		 * object type at this point, we only care about the existence of
@@ -251,6 +267,12 @@ acpi_ns_search_parent_tree(u32 target_na
 		/* Not found here, go up another level (until we reach the root) */
--
-	while (GET_CURRENT_ARG_TYPE(walk_state->arg_types) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (GET_CURRENT_ARG_TYPE(walk_state->arg_types) &&
 	       (GET_CURRENT_ARG_TYPE(walk_state->arg_types) != ARGP_NAME)) {
 		status =
 		    acpi_ps_get_next_arg(walk_state,
@@ -207,6 +212,12 @@ acpi_ps_build_named_op(struct acpi_walk_
 
--
-		while (GET_CURRENT_ARG_TYPE(walk_state->arg_types)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (GET_CURRENT_ARG_TYPE(walk_state->arg_types)
 		       && !walk_state->arg_count) {
 			walk_state->aml_offset =
 			    (u32) ACPI_PTR_DIFF(walk_state->parser_state.aml,
@@ -452,6 +468,12 @@ acpi_ps_get_arguments(struct acpi_walk_s
 			}
--
 	while (next) {
 		prev = next;
 		next = next->method.mutex;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (!(*op) || ((*op)->common.aml_opcode != AML_WHILE_OP)) {
 			acpi_ps_pop_scope(&(walk_state->parser_state), op,
 					  &walk_state->arg_types,
 					  &walk_state->arg_count);
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 	/* Iterative parsing loop, while there is more AML to process: */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
--
 	while ((parser_state->aml < parser_state->aml_end) || (op)) {
 		aml_op_start = parser_state->aml;
 		if (!op) {
@@ -1203,6 +1252,12 @@ acpi_status acpi_ps_parse_loop(struct ac
 			return_ACPI_STATUS(status);
 		}
--
 	}			/* while parser_state->Aml */
 
 	status = acpi_ps_complete_final_op(walk_state, op, status);
diff -u -p a/acpi/acpica/evgpeutil.c b/acpi/acpica/evgpeutil.c
--- a/acpi/acpica/evgpeutil.c
+++ b/acpi/acpica/evgpeutil.c
--
 	while (gpe_xrupt_info) {
 
 		/* Walk all Gpe Blocks attached to this interrupt level */
 
 		gpe_block = gpe_xrupt_info->gpe_block_list_head;
-		while (gpe_block) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (gpe_block) {
 
 			/* One callback per GPE block */
 
@@ -95,9 +105,21 @@ acpi_ev_walk_gpe_list(acpi_gpe_callback
 			}
--
 	while (gpe_xrupt_block) {
 		gpe_block = gpe_xrupt_block->gpe_block_list_head;
 
 		/* Walk the GPE blocks on this interrupt level */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
--
 		while (gpe_block) {
 			if ((&gpe_block->event_info[0] <= gpe_event_info) &&
 			    (&gpe_block->event_info[gpe_block->gpe_count] >
@@ -144,9 +176,21 @@ u8 acpi_ev_valid_gpe_event(struct acpi_g
 			}
 
--
 	while (next_gpe_xrupt) {
 		if (next_gpe_xrupt->interrupt_number == interrupt_number) {
 			return_PTR(next_gpe_xrupt);
 		}
 
 		next_gpe_xrupt = next_gpe_xrupt->next;
--
 		while (next_gpe_xrupt->next) {
 			next_gpe_xrupt = next_gpe_xrupt->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (this_name->info.name[0]) {
 		if (ACPI_COMPARE_NAME(node->name.ascii, this_name->info.name)) {
 			return (this_name);
@@ -401,6 +406,12 @@ const union acpi_predefined_info *acpi_n
 		}
 
--
 	while (arg) {
 
 		/* Ignore OFFSET and ACCESSAS terms here */
@@ -749,6 +754,12 @@ acpi_ds_eval_bank_field_operands(struct
 		/* Move to next field in the list */
 
--
 	while (count) {
 		previous_target = target;
 		target = ACPI_ADD_PTR(u8, resource, table->offset);
@@ -506,6 +511,12 @@ acpi_rs_dump_descriptor(void *resource,
 
 		table++;
--
 	while (next_node) {
 
 		/* If type matches, we are done */
@@ -140,6 +145,12 @@ struct acpi_namespace_node *acpi_ns_get_
 		/* Otherwise, move on to the next peer node */
 
--
 	while (level > 0 && child_node) {
 		status = AE_OK;
 
@@ -350,6 +366,12 @@ acpi_ns_walk_namespace(acpi_object_type
 
 			node_previously_visited = TRUE;
--
 		while ((length < operand[0]->buffer.length) &&
 		       (length < operand[1]->integer.value) &&
 		       (operand[0]->buffer.pointer[length])) {
 			length++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (op) {
 
 		/* Check if we are not ascending */
@@ -104,6 +109,12 @@ void acpi_ps_delete_parse_tree(union acp
 		} else {
 			op = parent;
--
 		/* Pop and delete control states until we find a while */
 
-		while (walk_state->control_state &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (walk_state->control_state &&
 		       (walk_state->control_state->control.opcode !=
 			AML_WHILE_OP)) {
 			control_state =
 			    acpi_ut_pop_generic_state(&walk_state->
 						      control_state);
--
 		/* No while found? */
diff -u -p a/acpi/acpica/rslist.c b/acpi/acpica/rslist.c
--- a/acpi/acpica/rslist.c
+++ b/acpi/acpica/rslist.c
@@ -141,7 +141,12 @@ acpi_rs_convert_resources_to_aml(struct
 
--
-	while (aml < end_aml) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (aml < end_aml) {
 
 		/* Validate the (internal) Resource Type */
 
@@ -195,6 +200,12 @@ acpi_rs_convert_resources_to_aml(struct
 		resource =
--
 	while (obj_desc->common.type == ACPI_TYPE_LOCAL_REFERENCE) {
 		switch (obj_desc->reference.class) {
 		case ACPI_REFCLASS_REFOF:
@@ -512,6 +517,12 @@ acpi_ex_resolve_multiple(struct acpi_wal
 				    obj_desc->reference.class));
 			return_ACPI_STATUS(AE_AML_INTERNAL);
--
 	while (arg) {
 		if (index >= ACPI_OBJ_NUM_OPERANDS) {
 			return_ACPI_STATUS(AE_BAD_DATA);
@@ -725,6 +730,12 @@ acpi_ds_create_operands(struct acpi_walk
 		arg = arg->common.next;
 		arg_count++;
--
 	while (num_segments) {
 		for (i = 0; i < 4; i++) {
 			ACPI_IS_PRINT(pathname[i]) ?
@@ -98,6 +103,12 @@ void acpi_ns_print_pathname(u32 num_segm
 		if (num_segments) {
 			acpi_os_printf(".");
--
 	while (obj_desc) {
 		obj_type = ACPI_TYPE_INVALID;
 		acpi_os_printf("Attached Object %p: ", obj_desc);
@@ -590,6 +606,12 @@ acpi_ns_dump_one_object(acpi_handle obj_
 		}
 
--
 		while (extra_op && !extra_op->common.node) {
 			extra_op = extra_op->common.parent;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
--
 	while (walk_state->control_state) {
 		state = walk_state->control_state;
 		walk_state->control_state = state->common.next;
 
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
--
 	while (walk_state->scope_info) {
 		state = walk_state->scope_info;
 		walk_state->scope_info = state->common.next;
 
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
--
 	while (walk_state->results) {
 		state = walk_state->results;
 		walk_state->results = state->common.next;
 
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
--
 	while ((parent->common.aml_opcode == AML_PACKAGE_OP) ||
 	       (parent->common.aml_opcode == AML_VAR_PACKAGE_OP)) {
 		parent = parent->common.parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-		while (arg) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (arg) {
 			/*
 			 * We must delete any package elements that were created earlier
 			 * and are not going to be used because of the package truncation.
@@ -522,6 +538,12 @@ acpi_ds_build_internal_package_obj(struc
 
--
-	while ((index < ACPI_METHOD_NUM_ARGS) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((index < ACPI_METHOD_NUM_ARGS) &&
 	       (index < max_param_count) && params[index]) {
 		/*
 		 * A valid parameter.
@@ -222,6 +227,12 @@ acpi_ds_method_data_init_args(union acpi
 		}
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (count) {
 		target = ACPI_ADD_PTR(u8, obj_desc, info->offset);
 		name = info->name;
 
@@ -433,6 +438,12 @@ acpi_ex_dump_object(union acpi_operand_o
 
--
 	while (num_operands) {
 		acpi_ex_dump_operand(*operands, 0);
 		operands++;
 		num_operands--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (gpe_block) {
 		/*
 		 * Read all of the 8-bit GPE status and enable registers in this GPE
@@ -436,6 +441,12 @@ u32 acpi_ev_gpe_detect(struct acpi_gpe_x
 		}
 
--
-		while (ACPI_SUCCESS(status) && notify_object) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (ACPI_SUCCESS(status) && notify_object) {
 			status = acpi_ev_queue_notify_request(
 					notify_object->node,
 					ACPI_NOTIFY_DEVICE_WAKE);
 			notify_object = notify_object->next;
+			if (_cur < timeout) {
--
 	while (length && *string) {
 		if (!ACPI_IS_PRINT(*string)) {
 			*string = '?';
 		}
 		string++;
 		length--;
--
 	while (buffer < end) {
 		sum = (u8) (sum + *(buffer++));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (handler_obj) {
 
 		/* We have a handler, see if user requested this one */
@@ -241,6 +246,11 @@ acpi_remove_address_space_handler(acpi_h
 
 			/* Walk the handler's region list */
--
 			while (region_obj) {
 				/*
 				 * First disassociate the handler from the region.
@@ -258,6 +268,12 @@ acpi_remove_address_space_handler(acpi_h
 				region_obj =
 				    handler_obj->address_space.region_list;
--
 	while (aml < end_aml) {
 
 		/* Validate the Resource Type and Resource Length */
@@ -329,6 +334,12 @@ acpi_ut_walk_aml_resources(u8 * aml,
 
 		aml += length;
--
-		while (notifier) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (notifier) {
 			notifier->handler(notify_info->notify.node,
 					  notify_info->notify.value,
 					  notifier->context);
 			notifier = notifier->next;
+			if (_cur < timeout) {
--
-	while (walk_state->scope_info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (walk_state->scope_info) {
 
 		/* Pop a scope off the stack */
 
@@ -78,6 +83,12 @@ void acpi_ds_scope_stack_clear(struct ac
 				  acpi_ut_get_type_name(scope_info->common.
--
 	while (arg && argn) {
 		argn--;
 		arg = arg->common.next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (prev_arg->common.next) {
 			prev_arg = prev_arg->common.next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 	while (arg) {
 		arg->common.parent = op;
 		arg = arg->common.next;
 
 		op->common.arg_list_length++;
+		if (_cur < timeout) {
--
 	while (parent) {
 		arg = acpi_ps_get_arg(parent, 0);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (arg && (arg != origin) && (arg != op)) {
 			arg = arg->common.next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
 		while (prefix_count--) {
 			*temp_ptr++ = AML_PARENT_PREFIX;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
--
-			while (num_segments &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (num_segments &&
 			       (status =
 				acpi_ex_name_segment(&aml_address,
 						     name_string)) == AE_OK) {
 				num_segments--;
+				if (_cur < timeout) {
--
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		/*
 		 * Source is the external AML byte stream buffer,
 		 * destination is the internal resource descriptor
@@ -292,7 +297,13 @@ acpi_rs_convert_aml_to_resource(struct a
 
--
 	while (count) {
 		/*
 		 * Source is the internal resource descriptor,
@@ -517,6 +533,12 @@ acpi_rs_convert_resource_to_aml(struct a
 
 		count--;
--
 		while (handler_desc) {
 			next_desc = handler_desc->address_space.next;
 			acpi_ut_remove_reference(handler_desc);
 			handler_desc = next_desc;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (object) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (object) {
 
 		/* Make sure that this isn't a namespace handle */
 
@@ -604,6 +620,12 @@ acpi_ut_update_object_reference(union ac
 			object = state->update.object;
--
 	while (state_list) {
 		state = acpi_ut_pop_generic_state(&state_list);
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
--
 	while (resource) {
 
 		/* Validate the descriptor type */
@@ -326,6 +331,12 @@ acpi_rs_get_aml_length(struct acpi_resou
 		resource =
 		    ACPI_ADD_PTR(struct acpi_resource, resource,
--
-	while (aml_buffer < end_aml) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (aml_buffer < end_aml) {
 
 		/* Validate the Resource Type and Resource Length */
 
@@ -484,6 +500,12 @@ acpi_rs_get_list_length(u8 * aml_buffer,
 		 * contained in the resource descriptor header
--
 	while (parser_state->scope) {
 		scope = acpi_ut_pop_generic_state(&parser_state->scope);
 		acpi_ut_delete_generic_state(scope);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (pci_device_node && (pci_device_node->type != ACPI_TYPE_DEVICE)) {
 		pci_device_node = pci_device_node->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
--
 	while (node) {
 
 		/* Check to see if a handler exists */
@@ -601,7 +617,12 @@ acpi_ev_initialize_region(union acpi_ope
 				break;
 			}
--
-			while (handler_obj) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+					while (handler_obj) {
 
 				/* Is this handler of the correct type? */
 
@@ -655,12 +676,24 @@ acpi_ev_initialize_region(union acpi_ope
 				/* Try next handler in the list */
--
 			while (!acpi_ns_opens_scope(prefix_node->type) &&
 			       prefix_node->type != ACPI_TYPE_ANY) {
 				prefix_node = prefix_node->parent;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
-			while (*path == (u8) AML_PARENT_PREFIX) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (*path == (u8) AML_PARENT_PREFIX) {
 
 				/* Name is fully qualified, no search rules apply */
 
@@ -428,6 +444,12 @@ acpi_ns_lookup(union acpi_generic_state
 						    "- reached beyond root node"));
--
 	while (num_segments && current_node) {
 		num_segments--;
 		if (!num_segments) {
@@ -647,6 +674,12 @@ acpi_ns_lookup(union acpi_generic_state
 
 		path += ACPI_NAME_SIZE;
--
 			while (handler_obj->handler != handler) {
 				if (handler_obj->next) {
 					parent_obj = handler_obj;
@@ -637,6 +642,12 @@ acpi_remove_notify_handler(acpi_handle d
 				} else {
 					break;
--
 	while (((unsigned long)entry) + sizeof(struct acpi_subtable_header) <
 	       table_end) {
 		if (entry->type == entry_id
@@ -247,6 +252,12 @@ acpi_table_parse_entries(char *id,
 
 		entry = (struct acpi_subtable_header *)
--
 	while (!acpi_is_root_bridge(phandle)) {
 		node = kzalloc(sizeof(struct acpi_handle_node), GFP_KERNEL);
 		if (!node)
@@ -331,6 +336,12 @@ struct pci_dev *acpi_get_pci_dev(acpi_ha
 		status = acpi_get_parent(phandle, &phandle);
 		if (ACPI_FAILURE(status))
--
 	while (entry && (entry->length > 0)) {
 		acpi_pci_irq_add_entry(handle, bus, entry);
 		entry = (struct acpi_pci_routing_table *)
 		    ((unsigned long)entry + entry->length);
+		    if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (bridge) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 
@@ -405,6 +421,12 @@ static struct acpi_prt_entry *acpi_pci_i
 
 		dev = bridge;
--
 	while (size > 0) {
 		unsigned int nr_bytes;
 
@@ -62,6 +67,12 @@ int suspend_nvs_register(unsigned long s
 
 		start += entry->size;
--
 	while (!kthread_should_stop()) {
 		int cpu;
 		u64 expire_time;
@@ -221,6 +226,12 @@ static int power_saving_thread(void *dat
 		 */
 		if (do_sleep)
--
-		while (ps_tsk_num < num) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while (ps_tsk_num < num) {
 			if (create_power_saving_task())
 				return;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
--
 		while (ps_tsk_num > num)
diff -u -p a/acpi/apei/ghes.c b/acpi/apei/ghes.c
--- a/acpi/apei/ghes.c
+++ b/acpi/apei/ghes.c
@@ -364,6 +364,11 @@ static void ghes_copy_tofrom_phys(void *
 	u64 offset;
--
 	while (len > 0) {
 		offset = paddr - (paddr & PAGE_MASK);
 		if (in_nmi) {
@@ -389,6 +394,12 @@ static void ghes_copy_tofrom_phys(void *
 			ghes_iounmap_irq(vaddr);
 			spin_unlock_irqrestore(&ghes_ioremap_lock_irq, flags);
--
 	while (llnode) {
 		next = llnode->next;
 		llnode->next = tail;
 		tail = llnode;
 		llnode = next;
+		if (_cur < timeout) {
--
-	while (llnode) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (llnode) {
 		next = llnode->next;
 		estatus_node = llist_entry(llnode, struct ghes_estatus_node,
 					   llnode);
@@ -747,6 +774,12 @@ static void ghes_proc_in_irq(struct irq_
 		gen_pool_free(ghes_estatus_pool, (unsigned long)estatus_node,
--
 	while (&res1->list != res_list1) {
 		list_for_each_entry(res2, res_list2, list) {
 			if (res1->start >= res2->end ||
@@ -377,6 +382,12 @@ static int apei_res_sub(struct list_head
 		}
 		res1 = resn1;
--
 	while (data_len > sizeof(*gdata)) {
 		gedata_len = gdata->error_data_length;
 		apei_estatus_print_section(pfx, gdata, sec_no);
 		data_len -= gedata_len + sizeof(*gdata);
 		sec_no++;
+		if (_cur < timeout) {
--
 	while (data_len > sizeof(*gdata)) {
 		gedata_len = gdata->error_data_length;
 		if (gedata_len > data_len - sizeof(*gdata))
 			return -EINVAL;
 		data_len -= gedata_len + sizeof(*gdata);
+		if (_cur < timeout) {
--
 	while (acpi_blacklist[i].oem_id[0] != '\0') {
 		if (acpi_get_table_header(acpi_blacklist[i].table, 0, &table_header)) {
 			i++;
@@ -164,6 +169,12 @@ int __init acpi_blacklisted(void)
 		} else {
 			i++;
--
-	while (repeat--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (repeat--) {
 		unsigned long delay = jiffies +
 			msecs_to_jiffies(ec_delay);
 		do {
@@ -239,6 +244,12 @@ static int ec_poll(struct acpi_ec *ec)
 		spin_lock_irqsave(&ec->curr_lock, flags);
--
 	while (i--) {
 		if (!pbats[i])
 			continue;
 		power_supply_unregister(&pbats[i]->bat);
 		kfree(pbats[i]);
+		if (_cur < timeout) {
--
 	while (map->key) {
 		if (strncasecmp(map->key, buf, MAX_KEYLENGTH) == 0)
 			return map->value;
 		map++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (map->key) {
 		if (map->value == value)
 			return map->key;
 		map++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (togo >= 4) {
 		togo -= 4;
 		b.n = jsf_inl(p);
 		memcpy(buf, b.s, 4);
 		p += 4;
 		buf += 4;
--
 	while (req) {
 		struct jsfd_part *jdp = req->rq_disk->private_data;
 		unsigned long offset = blk_rq_pos(req) << 9;
@@ -212,6 +228,12 @@ static void jsfd_do_request(struct reque
 	end:
 		if (!__blk_end_request_cur(req, err))
--
 	while (togo >= 4) {
 		togo -= 4;
 		b.n = jsf_inl(p);
@@ -292,6 +319,12 @@ static ssize_t jsf_read(struct file * fi
 			return -EFAULT;
 		tmp += 4;
--
 	while (togo != 0) {
 		togo -= 4;
 		if (copy_from_user(&b.s[0], uptr, 4))
@@ -379,6 +417,12 @@ static int jsf_ioctl_program(void __user
 		jsf_write4(p, b.n);
 		p += 4;
--
 	while ((op = bbc_i2c_getdev(bp, devidx++)) != NULL) {
 		if (!strcmp(op->dev.of_node->name, "temperature"))
 			attach_one_temp(bp, op, temp_index++);
 		if (!strcmp(op->dev.of_node->name, "fan-control"))
 			attach_one_fan(bp, op, fan_index++);
+			if (_cur < timeout) {
--
 	while (len > 0) {
 		int l = strlen(pos) + 1;
 		envctrl_set_mon(pchild, pos, i++);
 		len -= l;
 		pos += l;
+		if (_cur < timeout) {
--
 	while (dp) {
 		if (!strcmp(dp->name, "gpio")) {
 			i2c_childlist[index].i2ctype = I2C_GPIO;
@@ -1052,6 +1068,12 @@ static int __devinit envctrl_probe(struc
 		}
 
--
 	while ((n < 2) && (bufsize < OPROMMAXPARAM)) {
 		if (get_user(c, &info->oprom_array[bufsize])) {
 			kfree(*opp_p);
@@ -123,6 +128,12 @@ static int getstrings(struct openpromio
 		if (c == '\0')
 			n++;
--
 	while (incnt > 0) {
 		byte = (txn->inbuf[bytecnt] << 8);
 		WRITEUCTLDATA(byte);
 		incnt--;
 		bytecnt++;
+		if (_cur < timeout) {
--
 	while (outcnt > 0) {
 		READUCTLDATA(byte);
 		txn->outbuf[bytecnt] = (byte >> 8);
 		dprintk(("set byte to %02x\n", byte));
 		outcnt--;
 		bytecnt++;
--
 	while(redir[page] != 0xFF) {
 		page = redir[page]^0xFF;
 		loops--;
@@ -225,8 +230,19 @@ read_redir_page(struct ioc3_driver_data
 			printk(KERN_ERR "IOC3: NIC circular redirection\n");
 			return;
--
 	while(loops>0) {
 		nic_addr(idd, addr);
 		nic_write_byte(idd, 0xF0);
@@ -237,6 +253,12 @@ read_redir_page(struct ioc3_driver_data
 		if(crc16_area(data, 0x20, 0x0000) == 0x800d)
 			return;
--
 	while(loops>0) {
 		crc_ok = 1;
 		nic_addr(idd, addr);
@@ -268,6 +295,12 @@ read_redir_map(struct ioc3_driver_data *
 		if(crc_ok)
 			return;
--
 	while(loops>0) {
 		nic_addr(idd, addr);
 		nic_write_byte(idd, 0xF0);
@@ -327,6 +365,12 @@ static void read_mac(struct ioc3_driver_
 			return;
 		}
--
         while(loops>0) {
                 idd->nic_part[0] = 0;
                 idd->nic_serial[0] = 0;
                 addr = first = nic_find(idd, &save, 0);
                 if(!first)
                         return;
--
                 while(1) {
                         if(crc8_addr(addr))
                                 break;
@@ -364,8 +418,20 @@ static void probe_nic(struct ioc3_driver
                         addr = nic_find(idd, &save, addr);
                         if(addr == first)
--
 	while (bus->parent) {
 		if (!acpi_pm_device_sleep_wake(&bus->self->dev, enable))
 			return;
 		bus = bus->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (bus->parent) {
 		struct pci_dev *bridge = bus->self;
 
@@ -317,6 +333,12 @@ static void acpi_pci_propagate_run_wake(
 		if (!acpi_dev_run_wake(&bridge->dev, enable))
 			return;
--
 	while (out_of_order) {
 		out_of_order = 0;
 
@@ -336,6 +341,11 @@ static int sort_by_size(struct pci_resou
 
 		current_res = *head;
--
 		while (current_res->next && current_res->next->next) {
 			if (current_res->next->length > current_res->next->next->length) {
 				out_of_order++;
@@ -346,6 +356,18 @@ static int sort_by_size(struct pci_resou
 				current_res->next = next_res;
 			} else
--
 	while (out_of_order) {
 		out_of_order = 0;
 
@@ -384,6 +411,11 @@ static int sort_by_max_size(struct pci_r
 
 		current_res = *head;
--
 		while (current_res->next && current_res->next->next) {
 			if (current_res->next->length < current_res->next->next->length) {
 				out_of_order++;
@@ -394,6 +426,18 @@ static int sort_by_max_size(struct pci_r
 				current_res->next = next_res;
 			} else
--
 	while (node->next) {
 		prevnode = node;
 		node = node->next;
 		kfree(prevnode);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 			while (temp && temp->next != max) {
 				temp = temp->next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
--
 	while (out_of_order) {
 		out_of_order = 0;
 
@@ -857,6 +928,11 @@ int cpqhp_resource_sort_and_combine(stru
 
 		node1 = (*head);
--
 		while (node1->next && node1->next->next) {
 			if (node1->next->base > node1->next->next->base) {
 				out_of_order++;
@@ -867,11 +943,28 @@ int cpqhp_resource_sort_and_combine(stru
 				node1->next = node2;
 			} else
--
 	while (node1 && node1->next) {
 		if ((node1->base + node1->length) == node1->next->base) {
 			/* Combine */
@@ -882,6 +975,12 @@ int cpqhp_resource_sort_and_combine(stru
 			kfree(node2);
 		} else
--
 	while (func->next != NULL) {
 		func = func->next;
 
@@ -1100,6 +1204,12 @@ struct pci_func *cpqhp_slot_find(u8 bus,
 
 		if (found == index)
--
 		while (func) {
 			res_lists.io_head = ctrl->io_head;
 			res_lists.mem_head = ctrl->mem_head;
@@ -1713,6 +1828,12 @@ static u32 remove_board(struct pci_func
 				slot_remove(func);
 
--
 	while (change) {
 		change = 0;
 
@@ -1909,6 +2035,12 @@ static void interrupt_event_handler(stru
 				change = 1;
 			}
--
 	while (func && !rc) {
 		pci_bus->number = func->bus;
 		devfn = PCI_DEVFN(func->device, func->function);
@@ -2132,6 +2269,12 @@ int cpqhp_process_SS(struct controller *
 		}
 
--
 			while (new_slot) {
 				new_slot = cpqhp_slot_find(new_slot->bus, new_slot->device, index++);
 
 				if (new_slot)
 					cpqhp_return_board_resources(new_slot, resources);
+					if (_cur < timeout) {
--
 		while ((function < max_functions) && (!stop_it)) {
 			pci_bus_read_config_dword (ctrl->pci_bus, PCI_DEVFN(func->device, function), 0x00, &ID);
 
@@ -2341,6 +2500,12 @@ static u32 configure_new_device(struct c
 
 				stop_it++;
--
 	} while (function < max_functions);
diff -u -p a/pci/hotplug/cpqphp_core.c b/pci/hotplug/cpqphp_core.c
--- a/pci/hotplug/cpqphp_core.c
+++ b/pci/hotplug/cpqphp_core.c
@@ -144,11 +144,22 @@ static int init_SERR(struct controller *
 
--
 	while (number_of_slots) {
 		physical_slot = tempdword;
 		writeb(0, ctrl->hpc_reg + SLOT_SERR);
 		tempdword++;
 		number_of_slots--;
+		if (_cur < timeout) {
--
 	while ((p_temp < p_max) && !bail) {
 		/* Look for the double NULL terminator
 		 * The first condition is the previous byte
@@ -233,6 +249,12 @@ static void __iomem *get_subsequent_smbi
 
 		previous_byte = readb(p_temp);
--
 	while (old_slot) {
 		/* memory will be freed by the release_slot callback */
 		next_slot = old_slot->next;
 		pci_hp_deregister (old_slot->hotplug_slot);
 		old_slot = next_slot;
+		if (_cur < timeout) {
--
-	while (number_of_slots) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (number_of_slots) {
 		slot = kzalloc(sizeof(*slot), GFP_KERNEL);
 		if (!slot)
 			goto error;
@@ -647,10 +685,21 @@ static int ctrl_slot_setup(struct contro
 		slot_entry = get_SMBIOS_entry(smbios_start, smbios_table, 9,
--
-		while (slot_entry && (readw(slot_entry + SMBIOS_SLOT_NUMBER) !=
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (slot_entry && (readw(slot_entry + SMBIOS_SLOT_NUMBER) !=
 				slot->number)) {
 			slot_entry = get_SMBIOS_entry(smbios_start,
 						smbios_table, 9, slot_entry);
+			if (_cur < timeout) {
+		rdstcll(_cur);
--
 	while (ctrl) {
 		if (ctrl->hpc_reg) {
 			u16 misc;
@@ -1331,31 +1391,75 @@ static void __exit unload_cpqphpd(void)
 		ctrl_slot_cleanup(ctrl);
 
--
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (next != NULL) {
 			res = next->io_head;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
--
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
--
 	while (timeout > 0) {
 		msleep(10);
 		timeout -= 10;
@@ -145,6 +150,12 @@ static int pcie_poll_cmd(struct controll
 			pciehp_writew(ctrl, PCI_EXP_SLTSTA, PCI_EXP_SLTSTA_CC);
 			return 1;
--
 	while (timeout > 0) {
 		msleep(10);
 		timeout -= 10;
 		if (check_link_active(ctrl))
 			return;
+			if (_cur < timeout) {
--
 	while (slot) {
 		next = slot->next;
 		list_for_each_entry_safe(func, tmp, &slot->funcs, sibling) {
@@ -561,6 +566,12 @@ static void cleanup_bridge(struct acpiph
 		list_del(&slot->funcs);
 		kfree(slot);
--
-	while (ind < size && (des->generic.type != 0x82 ||
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ind < size && (des->generic.type != 0x82 ||
 			des->slot.slot_num != id)) {
 		des = (union apci_descriptor *)&table[ind += des->generic.len];
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
--
 	while ((pci_bus = pci_find_next_bus(pci_bus))) {
 		if (!pci_bus->sysdata)
 			continue;
@@ -710,6 +715,12 @@ static int __init sn_pci_hotplug_init(vo
 			registered = 0;
 			break;
--
-		while (!done) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!done) {
 			rc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar,
 							&status);
 			if (!rc) {
@@ -756,6 +761,12 @@ int ibmphp_hpc_writeslot (struct slot *
 				} else
--
 	while (!kthread_should_stop()) {
 		/* try to get the lock to do some kind of hardware access */
 		down (&semOperations);
@@ -907,6 +923,12 @@ static int poll_hpc(void *data)
 		/* sleep for a short time just for good measure */
 out_sleep:
--
 	while (!done) {
 		*pstatus = ctrl_read (ctlr_ptr, wpg_bbar, WPG_CTLR_INDEX);
 		if (*pstatus == HPC_ERROR) {
@@ -1126,6 +1153,12 @@ static int hpc_wait_ctlr_notworking (int
 			} else
 				timeout--;
--
-			while (func_cur) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (func_cur) {
 				if ((func_cur->busno == busno) &&
 						(func_cur->device == device) &&
 						(func_cur->function == function))
 					return func_cur;
 				func_cur = func_cur->next;
--
 	while (i <= slot_cur->bus_on->slot_max) {
 		if (i == slot_cur->number) {
 			i++;
@@ -837,6 +853,12 @@ static int is_bus_empty(struct slot * sl
 					SLOT_PWRGD(tmp_slot->status))
 			return 0;
--
 			while (temp_end < end_address) {
 				if (ibmphp_find_resource (bus, start_address, &io, IO) < 0) {
 					err ("cannot find corresponding IO resource to remove\n");
@@ -1285,6 +1290,12 @@ static int unconfigure_boot_device (u8 b
 				temp_end = io->end;
 				start_address = io->end + 1;
--
 		while (cur_func) {
 			/* TO DO: WILL MOST LIKELY NEED TO GET RID OF THE BUS STRUCTURE FROM RESOURCES AS WELL */
 			if (cur_func->bus) {
@@ -1619,6 +1635,12 @@ int ibmphp_unconfigure_card (struct slot
 			temp_func = cur_func->next;
 			kfree (cur_func);
--
 	while (res && index--) {
 		out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 		res = res->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (res && index--) {
 		out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 		res = res->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (res && index--) {
 		out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 		res = res->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (res && index--) {
 		out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 		res = res->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (res && index--) {
 			out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 			res = res->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (res && index--) {
 			out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 			res = res->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (res && index--) {
 			out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 			res = res->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 		while (res && index--) {
 			out += sprintf(out, "start = %8.8x, length = %8.8x\n", res->base, res->length);
 			res = res->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while ((d = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371SB_0, d))) {
 		pci_read_config_byte(d, 0x82, &dlc);
 		if (!(dlc & 1<<1)) {
@@ -132,6 +137,12 @@ static void quirk_passive_release(struct
 			dlc |= 1<<1;
 			pci_write_config_byte(d, 0x82, dlc);
--
 	while (pos && ttl--) {
 		u8 flags;
 
@@ -2277,6 +2293,12 @@ static int __devinit msi_ht_cap_enabled(
 
 		pos = pci_find_next_ht_capability(dev, pos,
--
-	while (pos && ttl--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (pos && ttl--) {
 		u8 flags;
 
 		if (pci_read_config_byte(dev, pos + HT_MSI_FLAGS,
@@ -2337,6 +2364,12 @@ static void __devinit ht_enable_msi_mapp
 		}
--
 	while (pos && ttl--) {
 		u8 flags;
 
@@ -2542,6 +2580,12 @@ static void __devinit ht_disable_msi_map
 		}
 		pos = pci_find_next_ht_capability(dev, pos,
--
 	while (f < end) {
 		if ((f->vendor == dev->vendor || f->vendor == (u16) PCI_ANY_ID) &&
 		    (f->device == dev->device || f->device == (u16) PCI_ANY_ID)) {
@@ -2955,6 +3004,12 @@ static void pci_do_fixups(struct pci_dev
 			f->hook(dev);
 		}
--
-	while (test_bit(_XEN_PCIF_active,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (test_bit(_XEN_PCIF_active,
 			(unsigned long *)&pdev->sh_info->flags)) {
 		xen_poll_irq_timeout(irq, jiffies + 3*HZ);
 		xen_clear_irq_pending(irq);
@@ -149,6 +154,12 @@ static int do_pci_op(struct pcifront_dev
 			err = XEN_PCI_ERR_dev_not_found;
--
-	while (!list_empty(&bus->devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&bus->devices)) {
 		dev = container_of(bus->devices.next, struct pci_dev,
 				   bus_list);
 		dev_dbg(&dev->dev, "removing device\n");
 		pci_remove_bus_device(dev);
+		if (_cur < timeout) {
--
 	while (link) {
 		/* Check upstream direction L0s latency */
 		if ((link->aspm_capable & ASPM_STATE_L0S_UP) &&
@@ -346,6 +351,12 @@ static void pcie_aspm_check_latency(stru
 		l1_switch_latency += 1000;
 
--
 	while (link) {
 		pcie_config_aspm_link(link, policy_to_aspm_state(link));
 		link = link->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((bus_ops = pci_bus_ops_pop())) {
 		pci_bus_set_ops(bus_ops->bus, bus_ops->ops);
 		kfree(bus_ops);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (kfifo_get(&aer_recover_ring, &entry)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (kfifo_get(&aer_recover_ring, &entry)) {
 		pdev = pci_get_domain_bus_and_slot(entry.domain, entry.bus,
 						   entry.devfn);
 		if (!pdev) {
@@ -638,6 +643,12 @@ static void aer_recover_work_func(struct
 		}
--
 	while ((bus = pci_find_next_bus(bus)) != NULL)  {
 		if (pci_domain_nr(bus) != domain)
 			continue;
 		tmp_bus = pci_do_find_bus(bus, busnr);
 		if (tmp_bus)
 			return tmp_bus;
--
 	while (ids->vendor || ids->subvendor || ids->class_mask) {
 		found = pci_get_dev_by_id(ids, NULL);
 		if (found)
 			goto exit;
 		ids++;
-	}
--
-	while ((dmi = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((dmi = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD,
 				      NULL, dmi)) != NULL) {
 		donboard = dmi->device_data;
 		if (donboard && donboard->bus == bus &&
@@ -85,6 +90,12 @@ find_smbios_instance_string(struct pci_d
 			}
--
 	while (parent->parent && parent->subordinate < max) {
 		parent->subordinate = max;
 		pci_write_config_byte(parent->self, PCI_SUBORDINATE_BUS, max);
 		parent = parent->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 				while (parent->parent) {
 					if ((!pcibios_assign_all_busses()) &&
 					    (parent->subordinate > max) &&
@@ -786,6 +802,12 @@ int __devinit pci_scan_bridge(struct pci
 						j = 1;
 					}
--
 	while (bus->parent) {
 		if ((child->subordinate > bus->subordinate) ||
 		    (child->number > bus->subordinate) ||
@@ -828,6 +855,12 @@ int __devinit pci_scan_bridge(struct pci
 				bus->number, bus->subordinate);
 		}
--
 	while (l == 0xffff0001) {
 		msleep(delay);
 		delay *= 2;
@@ -1152,6 +1190,12 @@ static struct pci_dev *pci_scan_device(s
 					PCI_FUNC(devfn));
 			return NULL;
--
 		while (ids->vendor || ids->subvendor || ids->class_mask) {
 			if (pci_match_one_device(ids, dev))
 				return ids;
 			ids++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while ((id = strsep(&p, ","))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((id = strsep(&p, ","))) {
 		unsigned int vendor, device, subvendor = PCI_ANY_ID,
 			subdevice = PCI_ANY_ID, class=0, class_mask=0;
 		int fields;
@@ -80,6 +85,12 @@ static int __init pci_stub_init(void)
 		if (rc)
--
 	while (cnt >= 4) {
 		unsigned int val;
 		pci_user_read_config_dword(dev, pos, &val);
@@ -101,6 +106,12 @@ proc_bus_pci_read(struct file *file, cha
 		buf += 4;
 		pos += 4;
--
 	while (cnt >= 4) {
 		__le32 val;
 		__get_user(val, (__le32 __user *) buf);
@@ -171,6 +187,12 @@ proc_bus_pci_write(struct file *file, co
 		buf += 4;
 		pos += 4;
--
 	while (pos) {
 		rc = pci_read_config_byte(dev, pos + 3, &cap);
 		if (rc != PCIBIOS_SUCCESSFUL)
@@ -385,6 +390,12 @@ static int __pci_find_next_ht_cap(struct
 		pos = __pci_find_next_cap_ttl(dev->bus, dev->devfn,
 					      pos + PCI_CAP_LIST_NEXT,
--
 	while (cap->size) {
 		struct pci_cap_saved_state *tmp;
 
@@ -1052,6 +1068,12 @@ int pci_load_saved_state(struct pci_dev
 		memcpy(tmp->cap.data, cap->data, tmp->cap.size);
 		cap = (struct pci_cap_saved_data *)((u8 *)cap +
--
 	while (bus->parent) {
 		struct pci_dev *bridge = bus->self;
 
@@ -1770,6 +1797,12 @@ bool pci_dev_run_wake(struct pci_dev *de
 			return true;
 
--
 	while (*val > 1023) {
 		*val = (*val + 31) / 32;
 		scale++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!pci_is_root_bus(dev->bus)) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (!pci_is_root_bus(dev->bus)) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (bus) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (bus) {
 		bridge = bus->self;
 		if (bridge) {
 			pci_read_config_word(bridge, PCI_BRIDGE_CONTROL,
@@ -3425,6 +3496,12 @@ int pci_set_vga_state(struct pci_dev *de
 					      cmd);
--
 	while (str) {
 		char *k = strchr(str, ',');
 		if (k)
@@ -3611,6 +3693,12 @@ static int __init pci_setup(char *str)
 			}
 		}
--
 	while (size > 3) {
 		u32 val;
 		pci_user_read_config_dword(dev, off, &val);
@@ -473,6 +478,12 @@ pci_read_config(struct file *filp, struc
 		data[off - init_off + 3] = (val >> 24) & 0xff;
 		off += 4;
--
 	while (size > 3) {
 		u32 val = data[off - init_off];
 		val |= (u32) data[off - init_off + 1] << 8;
@@ -534,6 +550,12 @@ pci_write_config(struct file* filp, stru
 		pci_user_write_config_dword(dev, off, val);
 		off += 4;
--
 	while (clocks->xfer_speed) {
 		if (clocks->xfer_speed == speed)
 			return clocks->timing;
 		clocks++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (list[i] != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (list[i] != NULL) {
 		if (!strcmp(list[i], model_num)) {
 			pr_warn("%s is not supported for %s\n",
 				modestr, list[i]);
 			return 1;
 		}
--
 		while (sg_len) {
 			u32 offset = addr & 0xffff;
 			u32 len = sg_len;
@@ -1782,6 +1787,12 @@ static void mv_fill_sg(struct ata_queued
 
 			last_sg = mv_sg;
--
 	while (in_index != pp->resp_idx) {
 		unsigned int tag;
 		struct mv_crpb *response = &pp->crpb[pp->resp_idx];
@@ -2797,6 +2813,12 @@ static void mv_process_crpb_entries(stru
 		if (mv_process_crpb_response(ap, response, tag, ncq_enabled))
 			done_mask |= 1 << tag;
--
 	while (status & 0x03) {
 		udelay(1);
 		pci_read_config_byte(dev, 0x43, &status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 		while (sg_len) {
 			/* table overflow should never happen */
 			BUG_ON (pi++ >= MAX_DCMDS);
@@ -549,6 +554,12 @@ static void pata_macio_qc_prep(struct at
 			addr += len;
 			sg_len -= len;
--
 	while (priv->timings[i].mode > 0) {
 		unsigned int mask = 1U << (priv->timings[i].mode & 0x0f);
 		switch(priv->timings[i].mode & 0xf0) {
@@ -1022,6 +1038,12 @@ static void __devinit pmac_macio_calc_ti
 			break;
 		}
--
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -624,6 +629,12 @@ static void pdc_fill_sg(struct ata_queue
 			idx++;
 			sg_len -= len;
--
 	while (clocks->xfer_mode) {
 		if (clocks->xfer_mode == speed)
 			return clocks->timing;
 		clocks++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
-	while (list[i] != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (list[i] != NULL) {
 		if (!strcmp(list[i], model_num)) {
 			pr_warn("%s is not supported for %s\n",
 				modestr, list[i]);
 			return 1;
 		}
--
-	while ((dev = pci_get_device(PCI_VENDOR_ID_CYRIX, PCI_ANY_ID, dev)) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((dev = pci_get_device(PCI_VENDOR_ID_CYRIX, PCI_ANY_ID, dev)) != NULL) {
 		switch (dev->device) {
 			case PCI_DEVICE_ID_CYRIX_PCI_MASTER:
 				master_0 = pci_dev_get(dev);
@@ -216,6 +221,12 @@ static int cs5530_init_chip(void)
 				cs5530_0 = pci_dev_get(dev);
--
 	while (lap->device) {
 		if (lap->device == pdev->device &&
 		    lap->subvendor == pdev->subsystem_vendor &&
@@ -765,6 +770,12 @@ static int ich_pata_cable_detect(struct
 			return ATA_CBL_PATA40_SHORT;
 
--
 	while ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82454NX, pdev)) != NULL) {
 		/* Look for 450NX PXB. Check for problem configurations
 		   A PCI quirk checks bit 6 already */
@@ -1358,6 +1374,12 @@ static int __devinit piix_check_450nx_er
 		/* On all revisions below 5 PXB bus lock must be disabled for IDE */
 		else if (cfg & (1<<14) && pdev->revision < 5)
--
 	while (--i >= 0) {
 		struct Scsi_Host *shost = host->ports[i]->scsi_host;
 
 		scsi_remove_host(shost);
 		scsi_host_put(shost);
+		if (_cur < timeout) {
--
-	while (time_before(jiffies, timeout)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (time_before(jiffies, timeout)) {
 		if ((readl(fifo_reg) >> 28) == 0)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while(n++ < 10) {
 		status = ioread8(ap->ioaddr.status_addr);
 		if (status & ATA_ERR) {
@@ -685,6 +690,12 @@ static u8 *it821x_firmware_command(struc
 			return (u8 *)buf;
 		}
--
-	while (sglen) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sglen) {
 		xfer_cnt = min(sglen, MAX_XFER_COUNT);
 		spin_lock_irqsave(&acdev->host->lock, flags);
 		xfer_ctr = readl(acdev->vbase + XFER_CTR) &
@@ -464,6 +469,11 @@ static int sg_xfer(struct arasan_cf_dev
 		spin_unlock_irqrestore(&acdev->host->lock, flags);
--
 		while (xfer_cnt) {
 			/* wait for read to complete */
 			if (!write) {
@@ -494,6 +504,18 @@ static int sg_xfer(struct arasan_cf_dev
 				if (ret)
 					goto fail;
--
 	while(cb->device) {
 		if (cb->device == pdev->device &&
 		    (cb->subvendor == pdev->subsystem_vendor ||
@@ -112,6 +117,12 @@ static int serverworks_cable_detect(stru
 			return cb->cable_detect(ap);
 		}
--
 	while (status != 0xff && (status & ATA_BUSY) &&
 	       time_before(jiffies, timeout)) {
 		ata_msleep(ap, 50);
 		status = ata_sff_busy_wait(ap, ATA_BUSY, 3);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (status != 0xff && (status & ATA_BUSY) &&
 	       time_before(jiffies, timeout)) {
 		ata_msleep(ap, 50);
 		status = ap->ops->sff_check_status(ap);
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -2670,6 +2697,12 @@ static void ata_bmdma_fill_sg(struct ata
 			pi++;
 			sg_len -= len;
--
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -2730,6 +2768,12 @@ static void ata_bmdma_fill_sg_dumb(struc
 			pi++;
 			sg_len -= len;
--
 	while (clocks->xfer_speed) {
 		if (clocks->xfer_speed == speed)
 			return clocks->timing;
 		clocks++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (--ata_dev >= link->device) {
 		ata_tdev_delete(ata_dev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
 	while (ap->pflags & (ATA_PFLAG_EH_PENDING | ATA_PFLAG_EH_IN_PROGRESS)) {
 		prepare_to_wait(&ap->eh_wait_q, &wait, TASK_UNINTERRUPTIBLE);
 		spin_unlock_irqrestore(ap->lock, flags);
 		schedule();
 		spin_lock_irqsave(ap->lock, flags);
+		if (_cur < timeout) {
--
 	while (len > 0) {
 		c = id[ofs] >> 8;
 		*s = c;
@@ -1121,6 +1126,12 @@ void ata_id_string(const u16 *id, unsign
 
 		ofs++;
--
 	while (1) {
 		unsigned long now = jiffies;
 		int ready, tmp;
@@ -3413,6 +3429,12 @@ int ata_wait_ready(struct ata_link *link
 		}
 
--
 	while (1) {
 		ata_msleep(link->ap, interval);
 		if ((rc = sata_scr_read(link, SCR_STATUS, &cur)))
@@ -3505,6 +3532,12 @@ int sata_link_debounce(struct ata_link *
 		 */
 		if (time_after(jiffies, deadline))
--
 		while (*text) {
 			if (glob_match(text, pattern) == 0)
 				return 0;  /* Remainder matched */
 			++text;  /* Absorb (match) this char and try again */
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (ad->model_num) {
 		if (!glob_match(model_num, ad->model_num)) {
 			if (ad->model_rev == NULL)
@@ -4259,6 +4308,12 @@ static unsigned long ata_dev_blacklisted
 				return ad->horkage;
 		}
--
 	while (done_mask) {
 		struct ata_queued_cmd *qc;
 		unsigned int tag = __ffs(done_mask);
@@ -4998,6 +5058,12 @@ int ata_qc_complete_multiple(struct ata_
 			nr_done++;
 		}
--
 	while (--i >= 0) {
 		struct ata_port *ap = host->ports[i];
 
 		if (ap->ops->port_stop)
 			ap->ops->port_stop(ap);
+			if (_cur < timeout) {
--
 	while (--i >= 0) {
 		ata_tport_delete(host->ports[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
--
 	while ((tmp & mask) == val && time_before(jiffies, deadline)) {
 		ata_msleep(ap, interval);
 		tmp = ioread32(reg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
-	while (bfin_port_info[board_idx].udma_mask > 0 &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bfin_port_info[board_idx].udma_mask > 0 &&
 			udma_fsclk[udma_mode] > fsclk) {
 		udma_mode--;
 		bfin_port_info[board_idx].udma_mask >>= 1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
--
-		while (addr < length) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (addr < length) {
 			pdc20621_put_to_dimm(host, buf, addr,
 					     ECC_ERASE_BUF_SZ);
 			addr += ECC_ERASE_BUF_SZ;
+			if (_cur < timeout) {
+			rdstcll(_cur);
--
 		while (cur_len) {
 			unsigned int tc = min(cur_len, MAX_DMA_BUFFER_SIZE);
 			bd = (struct bcom_ata_bd *)
@@ -486,6 +491,12 @@ mpc52xx_ata_build_dmatable(struct ata_qu
 					"too small\n");
 				goto use_pio_instead;
--
 	while (tag_mask) {
 		num_processed++;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
--
 		while (!(tag_mask & 0x00000001)) {
 			tag++;
 			tag_mask <<= 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
--
 	} /* while tag_mask */
 
 	/*
diff -u -p a/ata/pata_octeon_cf.c b/ata/pata_octeon_cf.c
--- a/ata/pata_octeon_cf.c
+++ b/ata/pata_octeon_cf.c
--
 		while (words--) {
 			iowrite8(*buffer, data_addr);
 			buffer++;
@@ -270,6 +275,12 @@ static unsigned int octeon_cf_data_xfer8
 				ioread8(ap->ioaddr.altstatus_addr);
 				count = 16;
--
 		while (words--) {
 			iowrite16(*(uint16_t *)buffer, data_addr);
 			buffer += sizeof(uint16_t);
@@ -309,11 +325,28 @@ static unsigned int octeon_cf_data_xfer1
 				ioread8(ap->ioaddr.altstatus_addr);
 				count = 16;
--
 		while (words--) {
 			*(uint16_t *)buffer = ioread16(data_addr);
 			buffer += sizeof(uint16_t);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (lap->device) {
 		if (lap->device == dev->device &&
 		    lap->subvendor == dev->subsystem_vendor &&
 		    lap->subdevice == dev->subsystem_device)
 			return 1;
 		lap++;
--
 	while (!(status & NV_ADMA_STAT_IDLE) && count < 20) {
 		ndelay(50);
 		status = readw(mmio + NV_ADMA_STAT);
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (!(status & NV_ADMA_STAT_LEGACY) && count < 20) {
 		ndelay(50);
 		status = readw(mmio + NV_ADMA_STAT);
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (((status & NV_ADMA_STAT_LEGACY) ||
 	      !(status & NV_ADMA_STAT_IDLE)) && count < 20) {
 		ndelay(50);
 		status = readw(mmio + NV_ADMA_STAT);
 		count++;
+		if (_cur < timeout) {
--
-			while ((pos = ffs(check_commands))) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((pos = ffs(check_commands))) {
 				pos--;
 				rc = nv_adma_check_cpb(ap, pos,
 						notifier_error & (1 << pos));
@@ -1019,6 +1057,12 @@ static irqreturn_t nv_adma_interrupt(int
 				else if (unlikely(rc < 0))
--
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -2033,6 +2082,12 @@ static void nv_swncq_fill_sg(struct ata_
 			idx++;
 			sg_len -= len;
--
 	while ((fbs & PORT_FBS_DEC) && retries--) {
 		udelay(1);
 		fbs = readl(port_mmio + PORT_FBS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (status) {
 		if (status & 1)
 			do_IRQ(dev->irq_start + virq);
 		status >>= 1;
 		virq++;
+		if (_cur < timeout) {
--
-	while (ids->id) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ids->id) {
 		if (ids->id == vdev->dev_id) {
 			vdev->divisor = ids->divisor;
 			vlynq_set_drvdata(vdev, ids);
@@ -337,6 +353,12 @@ static int vlynq_device_match(struct dev
 		printk(KERN_DEBUG "Not using the %08x VLYNQ device's driver"
--
 		while (id->name[0] || id->vendor[0]) {
 			if (strcmp(tdev->name, id->name) == 0 &&
 			    strcmp(tdev->vendor, id->vendor) == 0)
 				return id;
 			id++;
+			if (_cur < timeout) {
--
 		while (new_min > 192 && new_div < 3) {
 			new_div++;
 			new_min /= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (begin != end) {
 		int middle = begin + (end - begin) / 2;
 		entry = applesmc_get_entry_by_index(middle);
@@ -365,6 +370,12 @@ static int applesmc_get_lower_bound(unsi
 			begin = middle + 1;
 		else
--
 	while (begin != end) {
 		int middle = begin + (end - begin) / 2;
 		entry = applesmc_get_entry_by_index(middle);
@@ -387,6 +403,12 @@ static int applesmc_get_upper_bound(unsi
 			end = middle;
 		else
--
 	while (inb_p(data->addr + ABIT_UGURU_DATA) != state) {
 		timeout--;
 		if (timeout == 0)
@@ -240,6 +245,12 @@ static int abituguru_wait(struct abitugu
 		   this where ABIT_UGURU_WAIT_TIMEOUT_SLEEP is defined. */
 		if (timeout <= ABIT_UGURU_WAIT_TIMEOUT_SLEEP)
--
-	while (inb_p(data->addr + ABIT_UGURU_CMD) != 0xAC) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb_p(data->addr + ABIT_UGURU_CMD) != 0xAC) {
 		timeout--;
 		if (timeout == 0) {
 			ABIT_UGURU_DEBUG(1,
@@ -271,12 +287,23 @@ static int abituguru_ready(struct abitug
 			return -EIO;
--
-	while (inb_p(data->addr + ABIT_UGURU_DATA) != ABIT_UGURU_STATUS_INPUT) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb_p(data->addr + ABIT_UGURU_DATA) != ABIT_UGURU_STATUS_INPUT) {
 		timeout--;
 		if (timeout == 0) {
 			ABIT_UGURU_DEBUG(1,
@@ -284,6 +311,12 @@ static int abituguru_ready(struct abitug
 			return -EIO;
--
-	while (inb_p(data->addr + ABIT_UGURU_CMD) != 0xAC) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb_p(data->addr + ABIT_UGURU_CMD) != 0xAC) {
 		timeout--;
 		if (timeout == 0) {
 			ABIT_UGURU_DEBUG(1, "CMD reg does not hold 0xAC after "
@@ -408,6 +446,12 @@ static int abituguru_write(struct abitug
 			return -EIO;
--
 	while (len--) {
 		crc = sht15_crc8_table[*value ^ crc];
 		value++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
@@ -621,7 +621,12 @@ static int abituguru3_wait_while_busy(st
 	u8 x;
 	int timeout = ABIT_UGURU3_WAIT_TIMEOUT;
 
-	while ((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
 			ABIT_UGURU3_STATUS_BUSY) {
 		timeout--;
 		if (timeout == 0)
@@ -630,6 +635,12 @@ static int abituguru3_wait_while_busy(st
 		   last chance to respond. */
 		if (timeout == 1)
 			msleep(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
-	while (!((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
 			ABIT_UGURU3_STATUS_READY_FOR_READ)) {
 		timeout--;
 		if (timeout == 0)
@@ -649,6 +665,12 @@ static int abituguru3_wait_for_read(stru
 		   last chance to respond. */
--
-	while ((x = inb(data->addr + ABIT_UGURU3_CMD)) != 0xAC) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((x = inb(data->addr + ABIT_UGURU3_CMD)) != 0xAC) {
 		timeout--;
 		if (timeout == 0) {
 			ABIT_UGURU3_DEBUG("synchronize timeout cmd does not "
@@ -701,6 +728,12 @@ static int abituguru3_synchronize(struct
 			return -EIO;
--
-	while (!aem_find_aem2(probe, &fi_resp, i)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!aem_find_aem2(probe, &fi_resp, i)) {
 		if (fi_resp.major != 2) {
 			dev_err(probe->bmc_device, "Unknown AEM v%d; please "
 				"report this to the maintainer.\n",
@@ -780,6 +785,12 @@ static void aem_init_aem2(struct aem_ipm
 				err, fi_resp.module_handle);
--
 	while (ro->label) {
 		sysfs_attr_init(&sensors->dev_attr.attr);
 		sensors->dev_attr.attr.name = ro->label;
@@ -942,9 +958,20 @@ static int aem_register_sensors(struct a
 		}
 		sensors++;
--
 	while (rw->label) {
 		sysfs_attr_init(&sensors->dev_attr.attr);
 		sensors->dev_attr.attr.name = rw->label;
@@ -960,6 +987,12 @@ static int aem_register_sensors(struct a
 		}
 		sensors++;
--
 	while (fan_min > 255
 	    && (data->fan_status[attr->index] & 0x60) != 0x60) {
 		fan_min >>= 1;
 		data->fan[attr->index] >>= 1;
 		data->fan_status[attr->index] += 0x20;
+		if (_cur < timeout) {
--
 		while (!(data->fan_min[nr] & 0x80) /* min "nails" divider */
 		 && data->fan[nr] < 85 /* bad accuracy */
 		 && (data->fan_status[nr] & 0x60) != 0x00) {
@@ -1484,6 +1500,12 @@ static void pc87360_autodiv(struct devic
 				"clock divider to %d for fan %d\n",
 				FAN_DIV_FROM_REG(data->fan_status[nr]),
--
 	while (R > 0) {
 		val *= 10;
 		R--;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (R < 0) {
 		val = DIV_ROUND_CLOSEST(val, 10);
 		R++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (val >= MAX_MANTISSA && exponent < 15) {
 		exponent++;
 		val >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (val < MIN_MANTISSA && exponent > -15) {
 		exponent--;
 		val <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (R > 0) {
 		val *= 10;
 		R--;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (R < 0) {
 		val = DIV_ROUND_CLOSEST(val, 10);
 		R++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while ((i < 2) && mux_cnv) {
 		i++;
 		ret = ads7871_read_reg8(spi, REG_GAIN_MUX);
 		mux_cnv = ((ret & MUX_CNV_bm)>>MUX_CNV_bv);
 		msleep_interruptible(1);
+		if (_cur < timeout) {
--
 	while (vrm_models[i].vendor!=X86_VENDOR_UNKNOWN) {
 		if (vrm_models[i].vendor==vendor)
 			if ((vrm_models[i].eff_family==eff_family)
@@ -262,6 +267,12 @@ static u8 find_vrm(u8 eff_family, u8 eff
 			     (eff_stepping <= vrm_models[i].eff_stepping))
 				return vrm_models[i].vrm_type;
--
 		while (reg > 192 && new_div < 7) {
 			reg >>= 1;
 			new_div++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
--
 	while (end > start) {
 		mid = start + (end - start) / 2;
 		if (data->comp[mid].ohm < ohm)
@@ -183,6 +188,12 @@ static int lookup_comp(struct ntc_data *
 			start = mid + 1;
 		else
--
 	while (ro->label) {
 		sensors->dev_attr.attr.name = ro->label;
 		sensors->dev_attr.attr.mode = S_IRUGO;
@@ -640,6 +645,12 @@ static int register_ro_attrs(struct acpi
 		sensors++;
 		resource->num_sensors++;
--
 	while (rw->label) {
 		sensors->dev_attr.attr.name = rw->label;
 		sensors->dev_attr.attr.mode = S_IRUGO | S_IWUSR;
@@ -669,6 +685,12 @@ static int register_rw_attrs(struct acpi
 		sensors++;
 		resource->num_sensors++;
--
 	while (eromptr < eromend) {
 		struct bcma_device *core = kzalloc(sizeof(*core), GFP_KERNEL);
 		if (!core)
@@ -419,6 +424,12 @@ int bcma_bus_scan(struct bcma_bus *bus)
 			core->id.class);
 
--
 	while (eromptr < eromend) {
 		memset(core, 0, sizeof(*core));
 		INIT_LIST_HEAD(&core->list);
@@ -477,6 +493,12 @@ int __init bcma_bus_scan_early(struct bc
 		list_add(&core->list, &bus->cores);
 		err = 0;
--
 		while (count) {
 			*buf = __raw_readb(addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			*buf = (__force __le32)__raw_readl(addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writeb(*buf, addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 		while (count) {
 			__raw_writel((__force u32)(*buf), addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
--
 	while (((mul == 0) || (div == 0)) && (tried <= 3)) {
 		for (xdiv = 2; xdiv <= 0x80; xdiv++)
 			for (xmul = 1; xmul <= 0xfe; xmul++)
@@ -99,6 +104,12 @@ static int nforce2_calc_pll(unsigned int
 					div = xdiv;
 				}
--
-	while ((tfsb != fsb) && (tfsb <= max_fsb) && (tfsb >= min_fsb)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((tfsb != fsb) && (tfsb <= max_fsb) && (tfsb >= min_fsb)) {
 		if (diff < 0)
 			tfsb++;
 		else
@@ -219,6 +235,12 @@ static int nforce2_set_fsb(unsigned int
 #ifdef NFORCE2_DELAY
--
 	while ((drv_attr) && (*drv_attr)) {
 		ret = sysfs_create_file(&policy->kobj, &((*drv_attr)->attr));
 		if (ret)
 			goto err_out_kobj_put;
 		drv_attr++;
+		if (_cur < timeout) {
--
 	while (msr_tmp != msr_decode_fsb[i].bitmap) {
 		if (msr_decode_fsb[i].bitmap == 0xff)
 			return 0;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	while (msr_lo != msr_decode_mult[j].bitmap) {
 		if (msr_decode_mult[j].bitmap == 0xff)
 			return 0;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
--
 	/* Wait while CPU is busy */
 	rdmsr(MSR_IA32_PERF_STATUS, lo, hi);
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
--
 	while (lo & ((1 << 16) | (1 << 17))) {
 		udelay(16);
 		rdmsr(MSR_IA32_PERF_STATUS, lo, hi);
@@ -127,6 +132,12 @@ static int eps_set_state(struct eps_cpu_
 			err = -ENODEV;
 			goto postchange;
--
-	while (data->currvid > reqvid) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (data->currvid > reqvid) {
 		pr_debug("ph1: curr 0x%x, req vid 0x%x\n",
 			data->currvid, reqvid);
 		if (decrease_vid_code_by_step(data, reqvid, data->vidmvs))
 			return 1;
+			if (_cur < timeout) {
--
-	while ((rvosteps > 0) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((rvosteps > 0) &&
 			((rvomult * data->rvo + data->currvid) > reqvid)) {
 		if (data->currvid == maxvid) {
 			rvosteps = 0;
@@ -373,6 +389,12 @@ static int core_voltage_pre_transition(s
 				return 1;
--
 	while (vcofiddiff > 2) {
 		(data->currfid & 1) ? (fid_interval = 1) : (fid_interval = 2);
 
@@ -437,6 +464,12 @@ static int core_frequency_transition(str
 		vcocurrfid = convert_fid_to_vco_fid(data->currfid);
 		vcofiddiff = vcocurrfid > vcoreqfid ? vcocurrfid - vcoreqfid
--
 	while (count > 0 && freq->frequency != CPUFREQ_TABLE_END) {
 		if (freq->frequency == CPUFREQ_ENTRY_INVALID)
 			continue;
@@ -177,6 +182,12 @@ static void __init s3c64xx_cpufreq_confi
 		}
 
--
 	while (freq->frequency != CPUFREQ_TABLE_END) {
 		unsigned long r;
 
@@ -236,6 +252,12 @@ static int s3c64xx_cpufreq_driver_init(s
 			freq->frequency = CPUFREQ_ENTRY_INVALID;
 
--
 		while (bm_status && bm_timeout) {
 			outw(1 << 4, acpi_regs_addr);
 			bm_timeout--;
 			bm_status = inw(acpi_regs_addr);
 			bm_status &= 1 << 4;
+			if (_cur < timeout) {
--
-	while (longhaul_table[j].frequency != CPUFREQ_TABLE_END) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (longhaul_table[j].frequency != CPUFREQ_TABLE_END) {
 		speed = longhaul_table[j].frequency;
 		if (speed > min_vid_speed)
 			pos = (speed - min_vid_speed) / kHz_step + minvid.pos;
@@ -617,6 +633,12 @@ static void __cpuinit longhaul_setup_vol
 		printk(KERN_INFO PFX "f: %d kHz, index: %d, vid: %d mV\n",
--
 		while (i != table_index) {
 			vid = (longhaul_table[i].index >> 8) & 0x1f;
 			if (vid != current_vid) {
@@ -670,6 +697,12 @@ static int longhaul_target(struct cpufre
 				i++;
 			else
--
 	while (tmp_freq < policy->min) {
 		tmp_freq += stock_freq / max_duration;
 		tmp_freq = gx_validate_speed(tmp_freq, &tmp1, &tmp2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
--
 	while (tmp_freq > policy->max) {
 		tmp_freq -= stock_freq / max_duration;
 		tmp_freq = gx_validate_speed(tmp_freq, &tmp1, &tmp2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
