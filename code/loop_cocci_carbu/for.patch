diff -u -p a/mca/mca-bus.c b/mca/mca-bus.c
--- a/mca/mca-bus.c
+++ b/mca/mca-bus.c
@@ -51,11 +51,22 @@ static int mca_bus_match (struct device
 	int i = 0;
 
 	if (mca_ids) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(i = 0; mca_ids[i]; i++) {
 			if (mca_ids[i] == mca_dev->pos_id) {
 				mca_dev->index = i;
 				return 1;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	/* If the integrated id is present, treat it as though it were an
diff -u -p a/mca/mca-proc.c b/mca/mca-proc.c
--- a/mca/mca-proc.c
+++ b/mca/mca-proc.c
@@ -52,11 +52,22 @@ static int get_mca_info(char *page, char
 		struct mca_device *mca_dev;
 		/* Format POS registers of eight MCA slots */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(i=0; i<MCA_MAX_SLOT_NR; i++) {
 			mca_dev = mca_find_device_by_slot(i);
 
 			len += sprintf(page+len, "Slot %d: ", i+1);
 			len = get_mca_info_helper(mca_dev, page, len);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Format POS registers of integrated video subsystem */
@@ -122,8 +133,19 @@ static int mca_default_procfn(char* buf,
 	len += sprintf(buf+len, "Enabled: %s\nPOS: ",
 		mca_device_status(mca_dev) == MCA_ADAPTER_NORMAL ?
 			"Yes" : "No");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i=0; i<8; i++) {
 		len += sprintf(buf+len, "%02x ", mca_dev->pos[i]);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	len += sprintf(buf+len, "\nDriver Installed: %s",
 		mca_device_claimed(mca_dev) ? "Yes" : "No");
@@ -189,6 +211,11 @@ void __init mca_do_proc_init(void)
 
 	/* Initialize /proc/mca entries for existing adapters */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < MCA_NUMADAPTERS; i++) {
 		enum MCA_AdapterStatus status;
 		mca_dev = mca_find_device_by_slot(i);
@@ -214,6 +241,12 @@ void __init mca_do_proc_init(void)
 			printk("Failed to allocate memory for MCA proc-entries!");
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 } /* mca_do_proc_init() */
diff -u -p a/oprofile/oprofile_perf.c b/oprofile/oprofile_perf.c
--- a/oprofile/oprofile_perf.c
+++ b/oprofile/oprofile_perf.c
@@ -59,6 +59,11 @@ static void op_perf_setup(void)
 	u32 size = sizeof(struct perf_event_attr);
 	struct perf_event_attr *attr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_counters; ++i) {
 		attr = &counter_config[i].attr;
 		memset(attr, 0, size);
@@ -67,6 +72,12 @@ static void op_perf_setup(void)
 		attr->config		= counter_config[i].event;
 		attr->sample_period	= counter_config[i].count;
 		attr->pinned		= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -115,10 +126,21 @@ static int op_perf_start(void)
 	int cpu, event, ret = 0;
 
 	for_each_online_cpu(cpu) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (event = 0; event < num_counters; ++event) {
 			ret = op_create_counter(cpu, event);
 			if (ret)
 				return ret;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
@@ -141,6 +163,11 @@ static int oprofile_perf_create_files(st
 {
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_counters; i++) {
 		struct dentry *dir;
 		char buf[4];
@@ -153,6 +180,12 @@ static int oprofile_perf_create_files(st
 		oprofilefs_create_ulong(sb, dir, "unit_mask", &counter_config[i].unit_mask);
 		oprofilefs_create_ulong(sb, dir, "kernel", &counter_config[i].kernel);
 		oprofilefs_create_ulong(sb, dir, "user", &counter_config[i].user);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -256,10 +289,21 @@ void oprofile_perf_exit(void)
 	struct perf_event *event;
 
 	for_each_possible_cpu(cpu) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (id = 0; id < num_counters; ++id) {
 			event = perf_events[cpu][id];
 			if (event)
 				perf_event_release_kernel(event);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 
 		kfree(perf_events[cpu]);
diff -u -p a/oprofile/buffer_sync.c b/oprofile/buffer_sync.c
--- a/oprofile/buffer_sync.c
+++ b/oprofile/buffer_sync.c
@@ -229,6 +229,11 @@ static unsigned long get_exec_dcookie(st
 	if (!mm)
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
 		if (!vma->vm_file)
 			continue;
@@ -236,6 +241,12 @@ static unsigned long get_exec_dcookie(st
 			continue;
 		cookie = fast_get_dcookie(&vma->vm_file->f_path);
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
@@ -254,6 +265,11 @@ lookup_dcookie(struct mm_struct *mm, uns
 	unsigned long cookie = NO_COOKIE;
 	struct vm_area_struct *vma;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vma = find_vma(mm, addr); vma; vma = vma->vm_next) {
 
 		if (addr < vma->vm_start || addr >= vma->vm_end)
@@ -269,6 +285,12 @@ lookup_dcookie(struct mm_struct *mm, uns
 		}
 
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!vma)
diff -u -p a/virtio/virtio.c b/virtio/virtio.c
--- a/virtio/virtio.c
+++ b/virtio/virtio.c
@@ -123,11 +123,22 @@ static int virtio_dev_probe(struct devic
 
 	/* Features supported by both device and driver into dev->features. */
 	memset(dev->features, 0, sizeof(dev->features));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < drv->feature_table_size; i++) {
 		unsigned int f = drv->feature_table[i];
 		BUG_ON(f >= 32);
 		if (device_features & (1 << f))
 			set_bit(f, dev->features);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	/* Transport features always preserved to pass to finalize_features. */
diff -u -p a/virtio/virtio_ring.c b/virtio/virtio_ring.c
--- a/virtio/virtio_ring.c
+++ b/virtio/virtio_ring.c
@@ -133,12 +133,23 @@ static int vring_add_indirect(struct vri
 		return -ENOMEM;
 
 	/* Transfer entries from the sg list into the indirect page */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < out; i++) {
 		desc[i].flags = VRING_DESC_F_NEXT;
 		desc[i].addr = sg_phys(sg);
 		desc[i].len = sg->length;
 		desc[i].next = i+1;
 		sg++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	for (; i < (out + in); i++) {
 		desc[i].flags = VRING_DESC_F_NEXT|VRING_DESC_F_WRITE;
@@ -209,12 +220,23 @@ int virtqueue_add_buf_gfp(struct virtque
 	vq->num_free -= out + in;
 
 	head = vq->free_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
 		vq->vring.desc[i].flags = VRING_DESC_F_NEXT;
 		vq->vring.desc[i].addr = sg_phys(sg);
 		vq->vring.desc[i].len = sg->length;
 		prev = i;
 		sg++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	for (; in; i = vq->vring.desc[i].next, in--) {
 		vq->vring.desc[i].flags = VRING_DESC_F_NEXT|VRING_DESC_F_WRITE;
@@ -462,6 +484,11 @@ void *virtqueue_detach_unused_buf(struct
 
 	START_USE(vq);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < vq->vring.num; i++) {
 		if (!vq->data[i])
 			continue;
@@ -471,6 +498,12 @@ void *virtqueue_detach_unused_buf(struct
 		vq->vring.avail->idx--;
 		END_USE(vq);
 		return buf;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* That should have freed everything. */
 	BUG_ON(vq->num_free != vq->vring.num);
@@ -544,9 +577,20 @@ struct virtqueue *vring_new_virtqueue(un
 	/* Put everything in free lists. */
 	vq->num_free = num;
 	vq->free_head = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num-1; i++) {
 		vq->vring.desc[i].next = i+1;
 		vq->data[i] = NULL;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	vq->data[i] = NULL;
 
@@ -566,7 +610,12 @@ void vring_transport_features(struct vir
 {
 	unsigned int i;
 
-	for (i = VIRTIO_TRANSPORT_F_START; i < VIRTIO_TRANSPORT_F_END; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = VIRTIO_TRANSPORT_F_START; i < VIRTIO_TRANSPORT_F_END; i++) {
 		switch (i) {
 		case VIRTIO_RING_F_INDIRECT_DESC:
 			break;
@@ -576,6 +625,12 @@ void vring_transport_features(struct vir
 			/* We don't understand this bit. */
 			clear_bit(i, vdev->features);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(vring_transport_features);
diff -u -p a/virtio/virtio_pci.c b/virtio/virtio_pci.c
--- a/virtio/virtio_pci.c
+++ b/virtio/virtio_pci.c
@@ -537,7 +537,12 @@ static int vp_try_to_find_vqs(struct vir
 
 	vp_dev->per_vq_vectors = per_vq_vectors;
 	allocated_vectors = vp_dev->msix_used_vectors;
-	for (i = 0; i < nvqs; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < nvqs; ++i) {
 		if (!callbacks[i] || !vp_dev->msix_enabled)
 			msix_vec = VIRTIO_MSI_NO_VECTOR;
 		else if (vp_dev->per_vq_vectors)
@@ -566,6 +571,12 @@ static int vp_try_to_find_vqs(struct vir
 			vp_del_vq(vqs[i]);
 			goto error_find;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
diff -u -p a/virtio/virtio_balloon.c b/virtio/virtio_balloon.c
--- a/virtio/virtio_balloon.c
+++ b/virtio/virtio_balloon.c
@@ -129,9 +129,20 @@ static void release_pages_by_pfn(const u
 {
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num; i++) {
 		__free_page(pfn_to_page(pfns[i]));
 		totalram_pages++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -142,11 +153,22 @@ static void leak_balloon(struct virtio_b
 	/* We can only do one array worth at a time. */
 	num = min(num, ARRAY_SIZE(vb->pfns));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vb->num_pfns = 0; vb->num_pfns < num; vb->num_pfns++) {
 		page = list_first_entry(&vb->pages, struct page, lru);
 		list_del(&page->lru);
 		vb->pfns[vb->num_pfns] = page_to_balloon_pfn(page);
 		vb->num_pages--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 
diff -u -p a/virtio/virtio_mmio.c b/virtio/virtio_mmio.c
--- a/virtio/virtio_mmio.c
+++ b/virtio/virtio_mmio.c
@@ -117,10 +117,21 @@ static void vm_finalize_features(struct
 	/* Give virtio_ring a chance to accept features. */
 	vring_transport_features(vdev);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(vdev->features); i++) {
 		writel(i, vm_dev->base + VIRTIO_MMIO_GUEST_FEATURES_SEL);
 		writel(vdev->features[i],
 				vm_dev->base + VIRTIO_MMIO_GUEST_FEATURES);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -350,12 +361,23 @@ static int vm_find_vqs(struct virtio_dev
 	if (err)
 		return err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nvqs; ++i) {
 		vqs[i] = vm_setup_vq(vdev, i, callbacks[i], names[i]);
 		if (IS_ERR(vqs[i])) {
 			vm_del_vqs(vdev);
 			return PTR_ERR(vqs[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/base/map.c b/base/map.c
--- a/base/map.c
+++ b/base/map.c
@@ -46,6 +46,11 @@ int kobj_map(struct kobj_map *domain, de
 	if (p == NULL)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n; i++, p++) {
 		p->owner = module;
 		p->get = probe;
@@ -53,14 +58,31 @@ int kobj_map(struct kobj_map *domain, de
 		p->dev = dev;
 		p->range = range;
 		p->data = data;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_lock(domain->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, p -= n; i < n; i++, p++, index++) {
 		struct probe **s = &domain->probes[index % 255];
 		while (*s && (*s)->range < range)
 			s = &(*s)->next;
 		p->next = *s;
 		*s = p;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(domain->lock);
 	return 0;
@@ -77,6 +99,11 @@ void kobj_unmap(struct kobj_map *domain,
 		n = 255;
 
 	mutex_lock(domain->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n; i++, index++) {
 		struct probe **s;
 		for (s = &domain->probes[index % 255]; *s; s = &(*s)->next) {
@@ -88,6 +115,12 @@ void kobj_unmap(struct kobj_map *domain,
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(domain->lock);
 	kfree(found);
diff -u -p a/base/bus.c b/base/bus.c
--- a/base/bus.c
+++ b/base/bus.c
@@ -527,10 +527,21 @@ static int driver_add_attrs(struct bus_t
 	int i;
 
 	if (bus->drv_attrs) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; attr_name(bus->drv_attrs[i]); i++) {
 			error = driver_create_file(drv, &bus->drv_attrs[i]);
 			if (error)
 				goto err;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 done:
@@ -795,10 +806,21 @@ static int bus_add_attrs(struct bus_type
 	int i;
 
 	if (bus->bus_attrs) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; attr_name(bus->bus_attrs[i]); i++) {
 			error = bus_create_file(bus, &bus->bus_attrs[i]);
 			if (error)
 				goto err;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 done:
diff -u -p a/base/node.c b/base/node.c
--- a/base/node.c
+++ b/base/node.c
@@ -385,6 +385,11 @@ int register_mem_sect_under_node(struct
 	sect_start_pfn = section_nr_to_pfn(mem_blk->start_section_nr);
 	sect_end_pfn = section_nr_to_pfn(mem_blk->end_section_nr);
 	sect_end_pfn += PAGES_PER_SECTION - 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pfn = sect_start_pfn; pfn <= sect_end_pfn; pfn++) {
 		int page_nid;
 
@@ -402,6 +407,12 @@ int register_mem_sect_under_node(struct
 		return sysfs_create_link_nowarn(&mem_blk->sysdev.kobj,
 				&node_devices[nid].sysdev.kobj,
 				kobject_name(&node_devices[nid].sysdev.kobj));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* mem section does not span the specified node */
 	return 0;
@@ -424,6 +435,11 @@ int unregister_mem_sect_under_nodes(stru
 
 	sect_start_pfn = section_nr_to_pfn(phys_index);
 	sect_end_pfn = sect_start_pfn + PAGES_PER_SECTION - 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pfn = sect_start_pfn; pfn <= sect_end_pfn; pfn++) {
 		int nid;
 
@@ -438,6 +454,12 @@ int unregister_mem_sect_under_nodes(stru
 			 kobject_name(&mem_blk->sysdev.kobj));
 		sysfs_remove_link(&mem_blk->sysdev.kobj,
 			 kobject_name(&node_devices[nid].sysdev.kobj));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	NODEMASK_FREE(unlinked_nodes);
 	return 0;
@@ -451,6 +473,11 @@ static int link_mem_sections(int nid)
 	struct memory_block *mem_blk = NULL;
 	int err = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {
 		unsigned long section_nr = pfn_to_section_nr(pfn);
 		struct mem_section *mem_sect;
@@ -465,6 +492,12 @@ static int link_mem_sections(int nid)
 			err = ret;
 
 		/* discard ref obtained in find_memory_block() */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (mem_blk)
diff -u -p a/base/class.c b/base/class.c
--- a/base/class.c
+++ b/base/class.c
@@ -135,10 +135,21 @@ static int add_class_attrs(struct class
 	int error = 0;
 
 	if (cls->class_attrs) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; attr_name(cls->class_attrs[i]); i++) {
 			error = class_create_file(cls, &cls->class_attrs[i]);
 			if (error)
 				goto error;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 done:
diff -u -p a/base/memory.c b/base/memory.c
--- a/base/memory.c
+++ b/base/memory.c
@@ -171,11 +171,22 @@ static ssize_t show_mem_removable(struct
 	struct memory_block *mem =
 		container_of(dev, struct memory_block, sysdev);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sections_per_block; i++) {
 		if (!present_section_nr(mem->start_section_nr + i))
 			continue;
 		pfn = section_nr_to_pfn(mem->start_section_nr + i);
 		ret &= is_mem_section_removable(pfn, PAGES_PER_SECTION);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return sprintf(buf, "%d\n", ret);
@@ -241,12 +252,22 @@ static bool pages_correctly_reserved(uns
 	 * SPARSEMEM_VMEMMAP. We lookup the page once per section
 	 * and assume memmap is contiguous within each section
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sections_per_block; i++, pfn += PAGES_PER_SECTION) {
 		if (WARN_ON_ONCE(!pfn_valid(pfn)))
 			return false;
 		page = pfn_to_page(pfn);
 
-		for (j = 0; j < PAGES_PER_SECTION; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (j = 0; j < PAGES_PER_SECTION; j++) {
 			if (PageReserved(page + j))
 				continue;
 
@@ -255,6 +276,18 @@ static bool pages_correctly_reserved(uns
 				pfn_to_section_nr(pfn), j);
 
 			return false;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -411,7 +444,12 @@ memory_probe_store(struct class *class,
 	if (phys_addr & ((pages_per_block << PAGE_SHIFT) - 1))
 		return -EINVAL;
 
-	for (i = 0; i < sections_per_block; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < sections_per_block; i++) {
 		nid = memory_add_physaddr_to_nid(phys_addr);
 		ret = add_memory(nid, phys_addr,
 				 PAGES_PER_SECTION << PAGE_SHIFT);
@@ -419,6 +457,12 @@ memory_probe_store(struct class *class,
 			goto out;
 
 		phys_addr += MIN_MEMORY_BLOCK_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = count;
@@ -678,13 +722,24 @@ int __init memory_dev_init(void)
 	 * Create entries for memory sections that were found
 	 * during boot and have been initialized
 	 */
-	for (i = 0; i < NR_MEM_SECTIONS; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < NR_MEM_SECTIONS; i++) {
 		if (!present_section_nr(i))
 			continue;
 		err = add_memory_section(0, __nr_to_section(i), MEM_ONLINE,
 					 BOOT);
 		if (!ret)
 			ret = err;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	err = memory_probe_init();
diff -u -p a/base/platform.c b/base/platform.c
--- a/base/platform.c
+++ b/base/platform.c
@@ -61,11 +61,22 @@ struct resource *platform_get_resource(s
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dev->num_resources; i++) {
 		struct resource *r = &dev->resource[i];
 
 		if (type == resource_type(r) && num-- == 0)
 			return r;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NULL;
 }
@@ -96,11 +107,22 @@ struct resource *platform_get_resource_b
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dev->num_resources; i++) {
 		struct resource *r = &dev->resource[i];
 
 		if (type == resource_type(r) && !strcmp(r->name, name))
 			return r;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NULL;
 }
@@ -278,6 +300,11 @@ int platform_device_add(struct platform_
 	else
 		dev_set_name(&pdev->dev, "%s", pdev->name);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdev->num_resources; i++) {
 		struct resource *p, *r = &pdev->resource[i];
 
@@ -299,6 +326,12 @@ int platform_device_add(struct platform_
 			ret = -EBUSY;
 			goto failed;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_debug("Registering platform device '%s'. Parent at %s\n",
@@ -336,12 +369,23 @@ void platform_device_del(struct platform
 	if (pdev) {
 		device_del(&pdev->dev);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < pdev->num_resources; i++) {
 			struct resource *r = &pdev->resource[i];
 			unsigned long type = resource_type(r);
 
 			if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
 				release_resource(r);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 }
@@ -1059,6 +1103,11 @@ void __init early_platform_add_devices(s
 	int i;
 
 	/* simply add the devices to list */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num; i++) {
 		dev = &devs[i]->dev;
 
@@ -1067,6 +1116,12 @@ void __init early_platform_add_devices(s
 			list_add_tail(&dev->devres_head,
 				      &early_platform_device_list);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/base/firmware_class.c b/base/firmware_class.c
--- a/base/firmware_class.c
+++ b/base/firmware_class.c
@@ -38,12 +38,23 @@ static bool fw_get_builtin_firmware(stru
 {
 	struct builtin_fw *b_fw;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++) {
 		if (strcmp(name, b_fw->name) == 0) {
 			fw->size = b_fw->size;
 			fw->data = b_fw->data;
 			return true;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return false;
diff -u -p a/base/regmap/regmap.c b/base/regmap/regmap.c
--- a/base/regmap/regmap.c
+++ b/base/regmap/regmap.c
@@ -535,10 +535,21 @@ int regmap_bulk_read(struct regmap *map,
 		for (i = 0; i < val_count * val_bytes; i += val_bytes)
 			map->format.parse_val(val + i);
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < val_count; i++) {
 			ret = regmap_read(map, reg + i, val + (i * val_bytes));
 			if (ret != 0)
 				return ret;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
diff -u -p a/base/regmap/regcache.c b/base/regmap/regcache.c
--- a/base/regmap/regcache.c
+++ b/base/regmap/regcache.c
@@ -51,12 +51,23 @@ static int regcache_hw_init(struct regma
 	}
 
 	/* calculate the size of reg_defaults */
-	for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (count = 0, i = 0; i < map->num_reg_defaults_raw; i++) {
 		val = regcache_get_val(map->reg_defaults_raw,
 				       i, map->cache_word_size);
 		if (regmap_volatile(map, i))
 			continue;
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	map->reg_defaults = kmalloc(count * sizeof(struct reg_default),
@@ -66,7 +77,12 @@ static int regcache_hw_init(struct regma
 
 	/* fill the reg_defaults */
 	map->num_reg_defaults = count;
-	for (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {
 		val = regcache_get_val(map->reg_defaults_raw,
 				       i, map->cache_word_size);
 		if (regmap_volatile(map, i))
@@ -74,6 +90,12 @@ static int regcache_hw_init(struct regma
 		map->reg_defaults[j].reg = i;
 		map->reg_defaults[j].def = val;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -244,6 +266,11 @@ int regcache_sync(struct regmap *map)
 	if (map->cache_ops->sync) {
 		ret = map->cache_ops->sync(map);
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < map->num_reg_defaults; i++) {
 			ret = regcache_read(map, i, &val);
 			if (ret < 0)
@@ -256,6 +283,12 @@ int regcache_sync(struct regmap *map)
 			dev_dbg(map->dev, "Synced register %#x, value %#x\n",
 				map->reg_defaults[i].reg,
 				map->reg_defaults[i].def);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	}
diff -u -p a/base/regmap/regcache-rbtree.c b/base/regmap/regcache-rbtree.c
--- a/base/regmap/regcache-rbtree.c
+++ b/base/regmap/regcache-rbtree.c
@@ -138,12 +138,23 @@ static int regcache_rbtree_init(struct r
 	rbtree_ctx->root = RB_ROOT;
 	rbtree_ctx->cached_rbnode = NULL;
 
-	for (i = 0; i < map->num_reg_defaults; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < map->num_reg_defaults; i++) {
 		ret = regcache_rbtree_write(map,
 					    map->reg_defaults[i].reg,
 					    map->reg_defaults[i].def);
 		if (ret)
 			goto err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -253,9 +264,19 @@ static int regcache_rbtree_write(struct
 					     map->cache_word_size);
 	} else {
 		/* look for an adjacent register to the one we are about to add */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (node = rb_first(&rbtree_ctx->root); node;
 		     node = rb_next(node)) {
 			rbnode_tmp = rb_entry(node, struct regcache_rbtree_node, node);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < rbnode_tmp->blklen; i++) {
 				reg_tmp = rbnode_tmp->base_reg + i;
 				if (abs(reg_tmp - reg) != 1)
@@ -272,6 +293,18 @@ static int regcache_rbtree_write(struct
 					return ret;
 				rbtree_ctx->cached_rbnode = rbnode_tmp;
 				return 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 		/* we did not manage to find a place to insert it in an existing
@@ -309,9 +342,19 @@ static int regcache_rbtree_sync(struct r
 	int i;
 
 	rbtree_ctx = map->cache;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&rbtree_ctx->root); node; node = rb_next(node)) {
 		rbnode = rb_entry(node, struct regcache_rbtree_node, node);
-		for (i = 0; i < rbnode->blklen; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < rbnode->blklen; i++) {
 			regtmp = rbnode->base_reg + i;
 			val = regcache_rbtree_get_register(rbnode, i,
 							   map->cache_word_size);
@@ -328,6 +371,18 @@ static int regcache_rbtree_sync(struct r
 				return ret;
 			dev_dbg(map->dev, "Synced register %#x, value %#x\n",
 				regtmp, val);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
diff -u -p a/base/regmap/regcache-lzo.c b/base/regmap/regcache-lzo.c
--- a/base/regmap/regcache-lzo.c
+++ b/base/regmap/regcache-lzo.c
@@ -154,7 +154,12 @@ static int regcache_lzo_init(struct regm
 	bitmap_zero(sync_bmp, bmp_size);
 
 	/* allocate the lzo blocks and initialize them */
-	for (i = 0; i < blkcount; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < blkcount; i++) {
 		lzo_blocks[i] = kzalloc(sizeof **lzo_blocks,
 					GFP_KERNEL);
 		if (!lzo_blocks[i]) {
@@ -168,12 +173,23 @@ static int regcache_lzo_init(struct regm
 		ret = regcache_lzo_prepare(lzo_blocks[i]);
 		if (ret < 0)
 			goto err;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	blksize = regcache_lzo_get_blksize(map);
 	p = map->reg_defaults_raw;
 	end = map->reg_defaults_raw + map->cache_size_raw;
 	/* compress the register map and fill the lzo blocks */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < blkcount; i++, p += blksize) {
 		lzo_blocks[i]->src = p;
 		if (p + blksize > end)
@@ -186,6 +202,12 @@ static int regcache_lzo_init(struct regm
 			goto err;
 		lzo_blocks[i]->decompressed_size =
 			lzo_blocks[i]->src_len;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
@@ -211,6 +233,11 @@ static int regcache_lzo_exit(struct regm
 	 */
 	if (lzo_blocks[0])
 		kfree(lzo_blocks[0]->sync_bmp);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < blkcount; i++) {
 		if (lzo_blocks[i]) {
 			kfree(lzo_blocks[i]->wmem);
@@ -218,6 +245,12 @@ static int regcache_lzo_exit(struct regm
 		}
 		/* each lzo_block is a pointer returned by kmalloc or NULL */
 		kfree(lzo_blocks[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(lzo_blocks);
 	map->cache = NULL;
diff -u -p a/base/regmap/regcache-indexed.c b/base/regmap/regcache-indexed.c
--- a/base/regmap/regcache-indexed.c
+++ b/base/regmap/regcache-indexed.c
@@ -43,7 +43,12 @@ static int regcache_indexed_sync(struct
 	unsigned int i;
 	int ret;
 
-	for (i = 0; i < map->num_reg_defaults; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < map->num_reg_defaults; i++) {
 		ret = _regmap_write(map, map->reg_defaults[i].reg,
 				    map->reg_defaults[i].def);
 		if (ret < 0)
@@ -51,6 +56,12 @@ static int regcache_indexed_sync(struct
 		dev_dbg(map->dev, "Synced register %#x, value %#x\n",
 			map->reg_defaults[i].reg,
 			map->reg_defaults[i].def);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/base/power/trace.c b/base/power/trace.c
--- a/base/power/trace.c
+++ b/base/power/trace.c
@@ -173,7 +173,12 @@ static int show_file_hash(unsigned int v
 	char *tracedata;
 
 	match = 0;
-	for (tracedata = &__tracedata_start ; tracedata < &__tracedata_end ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (tracedata = &__tracedata_start ; tracedata < &__tracedata_end ;
 			tracedata += 2 + sizeof(unsigned long)) {
 		unsigned short lineno = *(unsigned short *)tracedata;
 		const char *file = *(const char **)(tracedata + 2);
@@ -182,6 +187,12 @@ static int show_file_hash(unsigned int v
 			continue;
 		pr_info("  hash matches %s:%u\n", file, lineno);
 		match++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return match;
 }
diff -u -p a/base/attribute_container.c b/base/attribute_container.c
--- a/base/attribute_container.c
+++ b/base/attribute_container.c
@@ -327,11 +327,22 @@ attribute_container_add_attrs(struct dev
 	if (cont->grp)
 		return sysfs_create_group(&classdev->kobj, cont->grp);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; attrs[i]; i++) {
 		sysfs_attr_init(&attrs[i]->attr);
 		error = device_create_file(classdev, attrs[i]);
 		if (error)
 			return error;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
diff -u -p a/misc/eeprom/at24.c b/misc/eeprom/at24.c
--- a/misc/eeprom/at24.c
+++ b/misc/eeprom/at24.c
@@ -610,7 +610,12 @@ static int at24_probe(struct i2c_client
 	at24->client[0] = client;
 
 	/* use dummy devices for multiple-address chips */
-	for (i = 1; i < num_addresses; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 1; i < num_addresses; i++) {
 		at24->client[i] = i2c_new_dummy(client->adapter,
 					client->addr + i);
 		if (!at24->client[i]) {
@@ -619,6 +624,12 @@ static int at24_probe(struct i2c_client
 			err = -EADDRINUSE;
 			goto err_clients;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	err = sysfs_create_bin_file(&client->dev.kobj, &at24->bin);
diff -u -p a/misc/eeprom/max6875.c b/misc/eeprom/max6875.c
--- a/misc/eeprom/max6875.c
+++ b/misc/eeprom/max6875.c
@@ -92,12 +92,23 @@ static void max6875_update_slice(struct
 				goto exit_up;
 			}
 		} else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < SLICE_SIZE; i++) {
 				j = i2c_smbus_read_byte(client);
 				if (j < 0) {
 					goto exit_up;
 				}
 				buf[i] = j;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		data->last_updated[slice] = jiffies;
diff -u -p a/misc/eeprom/eeprom_93cx6.c b/misc/eeprom/eeprom_93cx6.c
--- a/misc/eeprom/eeprom_93cx6.c
+++ b/misc/eeprom/eeprom_93cx6.c
@@ -105,6 +105,11 @@ static void eeprom_93cx6_write_bits(stru
 	/*
 	 * Start writing all bits.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = count; i > 0; i--) {
 		/*
 		 * Check if this bit needs to be set.
@@ -121,6 +126,12 @@ static void eeprom_93cx6_write_bits(stru
 		 */
 		eeprom_93cx6_pulse_high(eeprom);
 		eeprom_93cx6_pulse_low(eeprom);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	eeprom->reg_data_in = 0;
@@ -144,6 +155,11 @@ static void eeprom_93cx6_read_bits(struc
 	/*
 	 * Start reading all bits.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = count; i > 0; i--) {
 		eeprom_93cx6_pulse_high(eeprom);
 
@@ -161,6 +177,12 @@ static void eeprom_93cx6_read_bits(struc
 			buf |= (1 << (i - 1));
 
 		eeprom_93cx6_pulse_low(eeprom);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*data = buf;
@@ -223,10 +245,21 @@ void eeprom_93cx6_multiread(struct eepro
 	unsigned int i;
 	u16 tmp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < words; i++) {
 		tmp = 0;
 		eeprom_93cx6_read(eeprom, word + i, &tmp);
 		data[i] = cpu_to_le16(tmp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(eeprom_93cx6_multiread);
diff -u -p a/misc/eeprom/eeprom.c b/misc/eeprom/eeprom.c
--- a/misc/eeprom/eeprom.c
+++ b/misc/eeprom/eeprom.c
@@ -66,12 +66,23 @@ static void eeprom_update_client(struct
 							!= 32)
 					goto exit;
 		} else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = slice << 5; i < (slice + 1) << 5; i += 2) {
 				int word = i2c_smbus_read_word_data(client, i);
 				if (word < 0)
 					goto exit;
 				data->data[i] = word & 0xff;
 				data->data[i + 1] = word >> 8;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		data->last_updated[slice] = jiffies;
@@ -105,12 +116,23 @@ static ssize_t eeprom_read(struct file *
 	if (data->nature == VAIO && !capable(CAP_SYS_ADMIN)) {
 		int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; i++) {
 			if ((off + i <= 0x1f) ||
 			    (off + i >= 0xc0 && off + i <= 0xdf))
 				buf[i] = 0;
 			else
 				buf[i] = data->data[off + i];
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	} else {
 		memcpy(buf, &data->data[off], count);
diff -u -p a/misc/lis3lv02d/lis3lv02d.c b/misc/lis3lv02d/lis3lv02d.c
--- a/misc/lis3lv02d/lis3lv02d.c
+++ b/misc/lis3lv02d/lis3lv02d.c
@@ -320,6 +320,11 @@ static int lis3lv02d_selftest(struct lis
 
 	if (lis3->pdata) {
 		int i;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 3; i++) {
 			/* Check against selftest acceptance limits */
 			if ((results[i] < lis3->pdata->st_min_limits[i]) ||
@@ -327,6 +332,12 @@ static int lis3lv02d_selftest(struct lis
 				ret = SELFTEST_FAIL;
 				goto fail;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/misc/sgi-gru/grufault.c b/misc/sgi-gru/grufault.c
--- a/misc/sgi-gru/grufault.c
+++ b/misc/sgi-gru/grufault.c
@@ -160,6 +160,11 @@ static void get_clear_fault_map(struct g
 
 	tfm = get_tfm_for_cpu(gru, gru_cpu_fault_map_id());
 	prefetchw(tfm);		/* Helps on hardware, required for emulator */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < BITS_TO_LONGS(GRU_NUM_CBE); i++) {
 		k = tfm->fault_bits[i];
 		if (k)
@@ -169,6 +174,12 @@ static void get_clear_fault_map(struct g
 		if (k)
 			k = xchg(&tfm->done_bits[i], 0UL);
 		dmap->fault_bits[i] = k;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -754,6 +765,11 @@ static int gru_unload_all_contexts(void)
 	foreach_gid(gid) {
 		gru = GID_TO_GRU(gid);
 		spin_lock(&gru->gs_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (ctxnum = 0; ctxnum < GRU_NUM_CCH; ctxnum++) {
 			gts = gru->gs_gts[ctxnum];
 			if (gts && mutex_trylock(&gts->ts_ctxlock)) {
@@ -762,6 +778,12 @@ static int gru_unload_all_contexts(void)
 				mutex_unlock(&gts->ts_ctxlock);
 				spin_lock(&gru->gs_lock);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		spin_unlock(&gru->gs_lock);
 	}
diff -u -p a/misc/sgi-gru/grukservices.c b/misc/sgi-gru/grukservices.c
--- a/misc/sgi-gru/grukservices.c
+++ b/misc/sgi-gru/grukservices.c
@@ -197,6 +197,11 @@ static int gru_free_kernel_contexts(void
 	struct gru_thread_state *kgts;
 	int bid, ret = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bid = 0; bid < GRU_MAX_BLADES; bid++) {
 		bs = gru_base[bid];
 		if (!bs)
@@ -213,6 +218,12 @@ static int gru_free_kernel_contexts(void
 		} else {
 			ret++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return ret;
 }
diff -u -p a/misc/sgi-gru/grumain.c b/misc/sgi-gru/grumain.c
--- a/misc/sgi-gru/grumain.c
+++ b/misc/sgi-gru/grumain.c
@@ -115,6 +115,11 @@ static int gru_reset_asid_limit(struct g
 	gru_flush_all_tlb(gru);
 	gid = gru->gs_gid;
 again:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GRU_NUM_CCH; i++) {
 		if (!gru->gs_gts[i] || is_kernel_context(gru->gs_gts[i]))
 			continue;
@@ -138,6 +143,12 @@ again:
 
 		if ((inuse_asid > asid) && (inuse_asid < limit))
 			limit = inuse_asid;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	gru->gs_asid_limit = limit;
 	gru->gs_asid = asid;
@@ -624,9 +635,20 @@ void gru_load_context(struct gru_thread_
 		cch->tfm_done_bit_enable = 0;
 		cch->cb_int_enable = 0;
 		asid = gru_load_mm_tracker(gru, gts);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 8; i++) {
 			cch->asid[i] = asid + i;
 			cch->sizeavail[i] = gts->ts_sizeavail;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/misc/sgi-gru/grukdump.c b/misc/sgi-gru/grukdump.c
--- a/misc/sgi-gru/grukdump.c
+++ b/misc/sgi-gru/grukdump.c
@@ -84,10 +84,21 @@ static int gru_dump_tfm(struct gru_state
 	if (bytes > ubufend - ubuf)
 		ret = -EFBIG;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GRU_NUM_TFM; i++) {
 		tfm = get_tfm(gru->gs_gru_base_vaddr, i);
 		if (gru_user_copy_handle(&ubuf, tfm))
 			goto fail;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return GRU_NUM_TFM * GRU_CACHE_LINE_BYTES;
 
@@ -105,10 +116,21 @@ static int gru_dump_tgh(struct gru_state
 	if (bytes > ubufend - ubuf)
 		ret = -EFBIG;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GRU_NUM_TGH; i++) {
 		tgh = get_tgh(gru->gs_gru_base_vaddr, i);
 		if (gru_user_copy_handle(&ubuf, tgh))
 			goto fail;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return GRU_NUM_TGH * GRU_CACHE_LINE_BYTES;
 
@@ -214,6 +236,11 @@ int gru_dump_chiplet_request(unsigned lo
 		goto fail;
 	ubuf += ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ctxnum = 0; ctxnum < GRU_NUM_CCH; ctxnum++) {
 		if (req.ctxnum == ctxnum || req.ctxnum < 0) {
 			ret = gru_dump_context(gru, ctxnum, ubuf, ubufend,
@@ -224,6 +251,12 @@ int gru_dump_chiplet_request(unsigned lo
 			ubuf += ret;
 			cnt++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (copy_to_user((void __user *)arg, &req, sizeof(req)))
diff -u -p a/misc/sgi-gru/grufile.c b/misc/sgi-gru/grufile.c
--- a/misc/sgi-gru/grufile.c
+++ b/misc/sgi-gru/grufile.c
@@ -282,7 +282,12 @@ static int gru_init_tables(unsigned long
 
 		dsrbytes = 0;
 		cbrs = 0;
-		for (gru = gru_base[bid]->bs_grus, chip = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (gru = gru_base[bid]->bs_grus, chip = 0;
 				chip < GRU_CHIPLETS_PER_BLADE;
 				chip++, gru++) {
 			paddr = gru_chiplet_paddr(gru_base_paddr, pnode, chip);
@@ -292,6 +297,12 @@ static int gru_init_tables(unsigned long
 			cbrs = max(cbrs, n);
 			n = hweight64(gru->gs_dsr_map) * GRU_DSR_AU_BYTES;
 			dsrbytes = max(dsrbytes, n);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		max_user_cbrs = min(max_user_cbrs, cbrs);
 		max_user_dsr_bytes = min(max_user_dsr_bytes, dsrbytes);
diff -u -p a/misc/sgi-gru/gruprocfs.c b/misc/sgi-gru/gruprocfs.c
--- a/misc/sgi-gru/gruprocfs.c
+++ b/misc/sgi-gru/gruprocfs.c
@@ -133,12 +133,23 @@ static int mcs_statistics_show(struct se
 		"tfh_write_restart", "tgh_invalidate"};
 
 	seq_printf(s, "%-20s%12s%12s%12s\n", "#id", "count", "aver-clks", "max-clks");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (op = 0; op < mcsop_last; op++) {
 		count = atomic_long_read(&mcs_op_statistics[op].count);
 		total = atomic_long_read(&mcs_op_statistics[op].total);
 		max = mcs_op_statistics[op].max;
 		seq_printf(s, "%-20s%12ld%12ld%12ld\n", id[op], count,
 			   count ? total / count : 0, max);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return 0;
 }
@@ -184,19 +195,31 @@ static int cch_seq_show(struct seq_file
 	if (gid == 0)
 		seq_printf(file, "#%5s%5s%6s%7s%9s%6s%8s%8s\n", "gid", "bid",
 			   "ctx#", "asid", "pid", "cbrs", "dsbytes", "mode");
-	if (gru)
-		for (i = 0; i < GRU_NUM_CCH; i++) {
-			ts = gru->gs_gts[i];
-			if (!ts)
-				continue;
-			seq_printf(file, " %5d%5d%6d%7d%9d%6d%8d%8s\n",
-				   gru->gs_gid, gru->gs_blade_id, i,
-				   is_kernel_context(ts) ? 0 : ts->ts_gms->ms_asids[gid].mt_asid,
-				   is_kernel_context(ts) ? 0 : ts->ts_tgid_owner,
-				   ts->ts_cbr_au_count * GRU_CBR_AU_SIZE,
-				   ts->ts_cbr_au_count * GRU_DSR_AU_BYTES,
-				   mode[ts->ts_user_options &
-					GRU_OPT_MISS_MASK]);
+	if (gru) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < GRU_NUM_CCH; i++) {
+				ts = gru->gs_gts[i];
+				if (!ts)
+					continue;
+				seq_printf(file, " %5d%5d%6d%7d%9d%6d%8d%8s\n",
+				gru->gs_gid, gru->gs_blade_id, i,
+				is_kernel_context(ts) ? 0 : ts->ts_gms->ms_asids[gid].mt_asid,
+				is_kernel_context(ts) ? 0 : ts->ts_tgid_owner,
+				ts->ts_cbr_au_count * GRU_CBR_AU_SIZE,
+				ts->ts_cbr_au_count * GRU_DSR_AU_BYTES,
+				mode[ts->ts_user_options &
+				GRU_OPT_MISS_MASK]);
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
+			}
 		}
 
 	return 0;
diff -u -p a/misc/cs5535-mfgpt.c b/misc/cs5535-mfgpt.c
--- a/misc/cs5535-mfgpt.c
+++ b/misc/cs5535-mfgpt.c
@@ -276,6 +276,11 @@ static int __devinit scan_timers(struct
 
 	/* just to be safe, protect this section w/ lock */
 	spin_lock_irqsave(&mfgpt->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MFGPT_MAX_TIMERS; i++) {
 		timer.nr = i;
 		val = cs5535_mfgpt_read(&timer, MFGPT_REG_SETUP);
@@ -283,6 +288,12 @@ static int __devinit scan_timers(struct
 			__set_bit(i, mfgpt->avail);
 			timers++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&mfgpt->lock, flags);
 
diff -u -p a/misc/ti-st/st_core.c b/misc/ti-st/st_core.c
--- a/misc/ti-st/st_core.c
+++ b/misc/ti-st/st_core.c
@@ -142,6 +142,11 @@ void st_reg_complete(struct st_data_s *s
 {
 	unsigned char i = 0;
 	pr_info(" %s ", __func__);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ST_MAX_CHANNELS; i++) {
 		if (likely(st_gdata != NULL &&
 			st_gdata->is_registered[i] == true &&
@@ -154,6 +159,12 @@ void st_reg_complete(struct st_data_s *s
 				st_gdata->is_registered[i] = false;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -723,11 +734,22 @@ static void st_tty_close(struct tty_stru
 	 * un-installed for some reason - what should be done ?
 	 */
 	spin_lock_irqsave(&st_gdata->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ST_BT; i < ST_MAX_CHANNELS; i++) {
 		if (st_gdata->is_registered[i] == true)
 			pr_err("%d not un-registered", i);
 		st_gdata->list[i] = NULL;
 		st_gdata->is_registered[i] = false;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	st_gdata->protos_registered = 0;
 	spin_unlock_irqrestore(&st_gdata->lock, flags);
diff -u -p a/misc/enclosure.c b/misc/enclosure.c
--- a/misc/enclosure.c
+++ b/misc/enclosure.c
@@ -354,6 +354,11 @@ int enclosure_remove_device(struct enclo
 	if (!edev || !dev)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < edev->components; i++) {
 		cdev = &edev->component[i];
 		if (cdev->dev == dev) {
@@ -363,6 +368,12 @@ int enclosure_remove_device(struct enclo
 			cdev->dev = NULL;
 			return device_add(&cdev->cdev);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -ENODEV;
 }
diff -u -p a/misc/carma/carma-fpga.c b/misc/carma/carma-fpga.c
--- a/misc/carma/carma-fpga.c
+++ b/misc/carma/carma-fpga.c
@@ -416,10 +416,21 @@ static int data_setup_corl_table(struct
 
 	/* Add the DATA FPGA registers to the scatterlist */
 	sg = table->sgl;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_FPGA; i++) {
 		sg_dma_address(sg) = fpga_start_addr(priv, i);
 		sg_dma_len(sg) = REG_BLOCK_SIZE;
 		sg = sg_next(sg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Add the SYS-FPGA registers to the scatterlist */
@@ -428,12 +439,34 @@ static int data_setup_corl_table(struct
 	sg = sg_next(sg);
 
 	/* Add the FPGA correlation data blocks to the scatterlist */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_FPGA; i++) {
 		info = &priv->info[i];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < info->num_lag_ram; j++) {
 			sg_dma_address(sg) = fpga_block_addr(priv, i, j);
 			sg_dma_len(sg) = info->blk_size;
 			sg = sg_next(sg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -484,6 +517,11 @@ static int data_calculate_bufsize(struct
 	priv->bufsize = (1 + NUM_FPGA) * REG_BLOCK_SIZE;
 
 	/* Read and store the configuration data for each FPGA */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_FPGA; i++) {
 		version = fpga_read_reg(priv, i, MMAP_REG_VERSION);
 		conf1 = fpga_read_reg(priv, i, MMAP_REG_CORL_CONF1);
@@ -517,6 +555,12 @@ static int data_calculate_bufsize(struct
 		dev_dbg(priv->dev, "FPGA %d NUM_META: %d\n", i, num_meta);
 		dev_dbg(priv->dev, "FPGA %d NUM_QCNT: %d\n", i, num_qcnt);
 		dev_dbg(priv->dev, "FPGA %d BLK_SIZE: %d\n", i, blk_size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev_dbg(priv->dev, "TOTAL BUFFER SIZE: %zu bytes\n", priv->bufsize);
@@ -691,12 +735,23 @@ static irqreturn_t data_irq(int irq, voi
 	int i;
 
 	/* detect spurious interrupts via FPGA status */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		status = fpga_read_reg(priv, i, MMAP_REG_STATUS);
 		if (!(status & (CORL_DONE | CORL_ERR))) {
 			dev_err(priv->dev, "spurious irq detected (FPGA)\n");
 			return IRQ_NONE;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* detect spurious interrupts via raw IRQ pin readback */
diff -u -p a/misc/isl29003.c b/misc/isl29003.c
--- a/misc/isl29003.c
+++ b/misc/isl29003.c
@@ -344,12 +344,23 @@ static int isl29003_init_client(struct i
 
 	/* read all the registers once to fill the cache.
 	 * if one of the reads fails, we consider the init failed */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(data->reg_cache); i++) {
 		int v = i2c_smbus_read_byte_data(client, i);
 		if (v < 0)
 			return -ENODEV;
 
 		data->reg_cache[i] = v;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* set defaults */
diff -u -p a/misc/tifm_core.c b/misc/tifm_core.c
--- a/misc/tifm_core.c
+++ b/misc/tifm_core.c
@@ -222,9 +222,20 @@ void tifm_remove_adapter(struct tifm_ada
 	unsigned int cnt;
 
 	flush_workqueue(workqueue);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < fm->num_sockets; ++cnt) {
 		if (fm->sockets[cnt])
 			device_unregister(&fm->sockets[cnt]->dev);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	spin_lock(&tifm_adapter_lock);
diff -u -p a/misc/sgi-xp/xpc_channel.c b/misc/sgi-xp/xpc_channel.c
--- a/misc/sgi-xp/xpc_channel.c
+++ b/misc/sgi-xp/xpc_channel.c
@@ -560,6 +560,11 @@ xpc_process_sent_chctl_flags(struct xpc_
 	 * kthreads and/or create new kthreads as needed.
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ch_number = 0; ch_number < part->nchannels; ch_number++) {
 		ch = &part->channels[ch_number];
 
@@ -601,6 +606,12 @@ xpc_process_sent_chctl_flags(struct xpc_
 
 		if (chctl.flags[ch_number] & XPC_MSG_CHCTL_FLAGS)
 			xpc_arch_ops.process_msg_chctl_flags(part, ch_number);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -630,6 +641,11 @@ xpc_partition_going_down(struct xpc_part
 
 	/* disconnect channels associated with the partition going down */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ch_number = 0; ch_number < part->nchannels; ch_number++) {
 		ch = &part->channels[ch_number];
 
@@ -640,6 +656,12 @@ xpc_partition_going_down(struct xpc_part
 
 		spin_unlock_irqrestore(&ch->lock, irq_flags);
 		xpc_msgqueue_deref(ch);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	xpc_wakeup_channel_mgr(part);
@@ -660,6 +682,11 @@ xpc_initiate_connect(int ch_number)
 
 	DBUG_ON(ch_number < 0 || ch_number >= XPC_MAX_NCHANNELS);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (partid = 0; partid < xp_max_npartitions; partid++) {
 		part = &xpc_partitions[partid];
 
@@ -673,6 +700,12 @@ xpc_initiate_connect(int ch_number)
 			xpc_wakeup_channel_mgr(part);
 			xpc_part_deref(part);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -717,6 +750,11 @@ xpc_initiate_disconnect(int ch_number)
 	DBUG_ON(ch_number < 0 || ch_number >= XPC_MAX_NCHANNELS);
 
 	/* initiate the channel disconnect for every active partition */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (partid = 0; partid < xp_max_npartitions; partid++) {
 		part = &xpc_partitions[partid];
 
@@ -738,6 +776,12 @@ xpc_initiate_disconnect(int ch_number)
 			xpc_msgqueue_deref(ch);
 			xpc_part_deref(part);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	xpc_disconnect_wait(ch_number);
diff -u -p a/misc/sgi-xp/xpc_uv.c b/misc/sgi-xp/xpc_uv.c
--- a/misc/sgi-xp/xpc_uv.c
+++ b/misc/sgi-xp/xpc_uv.c
@@ -72,12 +72,23 @@ xpc_setup_partitions_uv(void)
 	short partid;
 	struct xpc_partition_uv *part_uv;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (partid = 0; partid < XP_MAX_NPARTITIONS_UV; partid++) {
 		part_uv = &xpc_partitions[partid].sn.uv;
 
 		mutex_init(&part_uv->cached_activate_gru_mq_desc_mutex);
 		spin_lock_init(&part_uv->flags_lock);
 		part_uv->remote_act_state = XPC_P_AS_INACTIVE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -89,6 +100,11 @@ xpc_teardown_partitions_uv(void)
 	struct xpc_partition_uv *part_uv;
 	unsigned long irq_flags;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (partid = 0; partid < XP_MAX_NPARTITIONS_UV; partid++) {
 		part_uv = &xpc_partitions[partid].sn.uv;
 
@@ -102,6 +118,12 @@ xpc_teardown_partitions_uv(void)
 			mutex_unlock(&part_uv->
 				     cached_activate_gru_mq_desc_mutex);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1014,11 +1036,22 @@ xpc_setup_ch_structures_uv(struct xpc_pa
 	struct xpc_channel_uv *ch_uv;
 	int ch_number;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ch_number = 0; ch_number < part->nchannels; ch_number++) {
 		ch_uv = &part->channels[ch_number].sn.uv;
 
 		xpc_init_fifo_uv(&ch_uv->msg_slot_free_list);
 		xpc_init_fifo_uv(&ch_uv->recv_msg_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return xpSuccess;
@@ -1088,18 +1121,34 @@ xpc_allocate_send_msg_slot_uv(struct xpc
 	int entry;
 	size_t nbytes;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nentries = ch->local_nentries; nentries > 0; nentries--) {
 		nbytes = nentries * sizeof(struct xpc_send_msg_slot_uv);
 		ch_uv->send_msg_slots = kzalloc(nbytes, GFP_KERNEL);
 		if (ch_uv->send_msg_slots == NULL)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (entry = 0; entry < nentries; entry++) {
 			msg_slot = &ch_uv->send_msg_slots[entry];
 
 			msg_slot->msg_slot_number = entry;
 			xpc_put_fifo_entry_uv(&ch_uv->msg_slot_free_list,
 					      &msg_slot->next);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		spin_lock_irqsave(&ch->lock, irq_flags);
@@ -1107,6 +1156,12 @@ xpc_allocate_send_msg_slot_uv(struct xpc
 			ch->local_nentries = nentries;
 		spin_unlock_irqrestore(&ch->lock, irq_flags);
 		return xpSuccess;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return xpNoMemory;
@@ -1122,17 +1177,33 @@ xpc_allocate_recv_msg_slot_uv(struct xpc
 	int entry;
 	size_t nbytes;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nentries = ch->remote_nentries; nentries > 0; nentries--) {
 		nbytes = nentries * ch->entry_size;
 		ch_uv->recv_msg_slots = kzalloc(nbytes, GFP_KERNEL);
 		if (ch_uv->recv_msg_slots == NULL)
 			continue;
 
-		for (entry = 0; entry < nentries; entry++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (entry = 0; entry < nentries; entry++) {
 			msg_slot = ch_uv->recv_msg_slots +
 			    entry * ch->entry_size;
 
 			msg_slot->hdr.msg_slot_number = entry;
+			if (_cur < timeout) {
+			    rdstcll(_cur);
+			}
+			else {
+			    break;
+			}
 		}
 
 		spin_lock_irqsave(&ch->lock, irq_flags);
@@ -1140,6 +1211,12 @@ xpc_allocate_recv_msg_slot_uv(struct xpc
 			ch->remote_nentries = nentries;
 		spin_unlock_irqrestore(&ch->lock, irq_flags);
 		return xpSuccess;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return xpNoMemory;
@@ -1316,10 +1393,21 @@ xpc_any_partition_engaged_uv(void)
 	struct xpc_partition_uv *part_uv;
 	short partid;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (partid = 0; partid < XP_MAX_NPARTITIONS_UV; partid++) {
 		part_uv = &xpc_partitions[partid].sn.uv;
 		if ((part_uv->flags & XPC_P_ENGAGED_UV) != 0)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/misc/sgi-xp/xpc_main.c b/misc/sgi-xp/xpc_main.c
--- a/misc/sgi-xp/xpc_main.c
+++ b/misc/sgi-xp/xpc_main.c
@@ -447,6 +447,11 @@ xpc_setup_ch_structures(struct xpc_parti
 	atomic_set(&part->nchannels_active, 0);
 	atomic_set(&part->nchannels_engaged, 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ch_number = 0; ch_number < part->nchannels; ch_number++) {
 		ch = &part->channels[ch_number];
 
@@ -467,6 +472,12 @@ xpc_setup_ch_structures(struct xpc_parti
 		atomic_set(&ch->n_on_msg_allocate_wq, 0);
 		init_waitqueue_head(&ch->msg_allocate_wq);
 		init_waitqueue_head(&ch->idle_wq);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	ret = xpc_arch_ops.setup_ch_structures(part);
@@ -860,6 +871,11 @@ xpc_disconnect_wait(int ch_number)
 	int wakeup_channel_mgr;
 
 	/* now wait for all callouts to the caller's function to cease */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (partid = 0; partid < xp_max_npartitions; partid++) {
 		part = &xpc_partitions[partid];
 
@@ -897,6 +913,12 @@ xpc_disconnect_wait(int ch_number)
 			xpc_wakeup_channel_mgr(part);
 
 		xpc_part_deref(part);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -921,6 +943,11 @@ xpc_setup_partitions(void)
 	 * ENTRIES ARE MEANINGFUL UNTIL AFTER AN ENTRY'S CORRESPONDING
 	 * PARTITION HAS BEEN ACTIVATED.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (partid = 0; partid < xp_max_npartitions; partid++) {
 		part = &xpc_partitions[partid];
 
@@ -939,6 +966,12 @@ xpc_setup_partitions(void)
 		part->setup_state = XPC_P_SS_UNSET;
 		init_waitqueue_head(&part->teardown_wq);
 		atomic_set(&part->references, 0);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 
 	return xpc_arch_ops.setup_partitions();
@@ -987,6 +1020,11 @@ xpc_do_exit(enum xp_retval reason)
 	do {
 		active_part_count = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (partid = 0; partid < xp_max_npartitions; partid++) {
 			part = &xpc_partitions[partid];
 
@@ -1001,6 +1039,12 @@ xpc_do_exit(enum xp_retval reason)
 
 			if (part->disengage_timeout > disengage_timeout)
 				disengage_timeout = part->disengage_timeout;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (xpc_arch_ops.any_partition_engaged()) {
@@ -1107,6 +1151,11 @@ xpc_die_deactivate(void)
 
 	xpc_arch_ops.disallow_all_hbs();   /*indicate we're deactivated */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (partid = 0; partid < xp_max_npartitions; partid++) {
 		part = &xpc_partitions[partid];
 
@@ -1115,6 +1164,12 @@ xpc_die_deactivate(void)
 			xpc_arch_ops.request_partition_deactivation(part);
 			xpc_arch_ops.indicate_partition_disengaged(part);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -1137,6 +1192,11 @@ xpc_die_deactivate(void)
 		}
 
 		if (!keep_waiting--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (partid = 0; partid < xp_max_npartitions;
 			     partid++) {
 				if (xpc_arch_ops.partition_engaged(partid)) {
@@ -1144,6 +1204,12 @@ xpc_die_deactivate(void)
 						 "remote partition %d timed "
 						 "out\n", partid);
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			break;
 		}
diff -u -p a/misc/sgi-xp/xpc_sn2.c b/misc/sgi-xp/xpc_sn2.c
--- a/misc/sgi-xp/xpc_sn2.c
+++ b/misc/sgi-xp/xpc_sn2.c
@@ -1239,7 +1239,12 @@ xpc_setup_ch_structures_sn2(struct xpc_p
 	timer->expires = jiffies + XPC_DROPPED_NOTIFY_IRQ_WAIT_INTERVAL;
 	add_timer(timer);
 
-	for (ch_number = 0; ch_number < part->nchannels; ch_number++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (ch_number = 0; ch_number < part->nchannels; ch_number++) {
 		ch_sn2 = &part->channels[ch_number].sn.sn2;
 
 		ch_sn2->local_GP = &part_sn2->local_GPs[ch_number];
@@ -1247,6 +1252,12 @@ xpc_setup_ch_structures_sn2(struct xpc_p
 		    &part_sn2->local_openclose_args[ch_number];
 
 		mutex_init(&ch_sn2->msg_to_pull_mutex);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 
 	/*
@@ -1565,7 +1576,12 @@ xpc_allocate_local_msgqueue_sn2(struct x
 	int nentries;
 	size_t nbytes;
 
-	for (nentries = ch->local_nentries; nentries > 0; nentries--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (nentries = ch->local_nentries; nentries > 0; nentries--) {
 
 		nbytes = nentries * ch->entry_size;
 		ch_sn2->local_msgqueue =
@@ -1592,6 +1608,12 @@ xpc_allocate_local_msgqueue_sn2(struct x
 		}
 		spin_unlock_irqrestore(&ch->lock, irq_flags);
 		return xpSuccess;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev_dbg(xpc_chan, "can't get memory for local message queue and notify "
@@ -1612,7 +1634,12 @@ xpc_allocate_remote_msgqueue_sn2(struct
 
 	DBUG_ON(ch->remote_nentries <= 0);
 
-	for (nentries = ch->remote_nentries; nentries > 0; nentries--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (nentries = ch->remote_nentries; nentries > 0; nentries--) {
 
 		nbytes = nentries * ch->entry_size;
 		ch_sn2->remote_msgqueue =
@@ -1631,6 +1658,12 @@ xpc_allocate_remote_msgqueue_sn2(struct
 		}
 		spin_unlock_irqrestore(&ch->lock, irq_flags);
 		return xpSuccess;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev_dbg(xpc_chan, "can't get memory for cached remote message queue, "
diff -u -p a/misc/cb710/core.c b/misc/cb710/core.c
--- a/misc/cb710/core.c
+++ b/misc/cb710/core.c
@@ -74,10 +74,21 @@ static irqreturn_t cb710_irq_handler(int
 
 	spin_lock(&chip->irq_lock); /* incl. smp_rmb() */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nr = chip->slots; nr; ++slot, --nr) {
 		cb710_irq_handler_t handler_func = slot->irq_handler;
 		if (handler_func && handler_func(slot))
 			handled = IRQ_HANDLED;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	spin_unlock(&chip->irq_lock);
diff -u -p a/misc/ibmasm/remote.c b/misc/ibmasm/remote.c
--- a/misc/ibmasm/remote.c
+++ b/misc/ibmasm/remote.c
@@ -242,11 +242,22 @@ int ibmasm_init_remote_input_dev(struct
 	keybd_dev->evbit[0]  = BIT_MASK(EV_KEY);
 	keybd_dev->name = "ibmasm RSA I remote keyboard";
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < XLATE_SIZE; i++) {
 		if (xlate_high[i])
 			set_bit(xlate_high[i], keybd_dev->keybit);
 		if (xlate[i])
 			set_bit(xlate[i], keybd_dev->keybit);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	error = input_register_device(mouse_dev);
diff -u -p a/misc/lkdtm.c b/misc/lkdtm.c
--- a/misc/lkdtm.c
+++ b/misc/lkdtm.c
@@ -203,9 +203,20 @@ static enum ctype parse_cp_type(const ch
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(cp_type); i++) {
 		if (!strcmp(what, cp_type[i]))
 			return i + 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return CT_NONE;
@@ -252,11 +263,22 @@ static int lkdtm_parse_commandline(void)
 	if (cptype == CT_NONE)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(cp_name); i++) {
 		if (!strcmp(cpoint_name, cp_name[i])) {
 			cpoint = i + 1;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Could not find a valid crash point */
@@ -639,6 +661,11 @@ static int __init lkdtm_module_init(void
 	n_debugfs_entries = ARRAY_SIZE(crash_entries);
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n_debugfs_entries; i++) {
 		const struct crash_entry *cur = &crash_entries[i];
 		struct dentry *de;
@@ -650,6 +677,12 @@ static int __init lkdtm_module_init(void
 					cur->name);
 			goto out_err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (lkdtm_parse_commandline() == -EINVAL) {
diff -u -p a/misc/ics932s401.c b/misc/ics932s401.c
--- a/misc/ics932s401.c
+++ b/misc/ics932s401.c
@@ -144,9 +144,20 @@ static struct ics932s401_data *ics932s40
 	 * Not really sure why this is; setting the "byte count programming"
 	 * register to 1 does not fix this problem.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_MIRRORED_REGS; i++) {
 		temp = i2c_smbus_read_word_data(client, regs_to_copy[i]);
 		data->regs[regs_to_copy[i]] = temp >> 8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	data->sensors_last_updated = local_jiffies;
diff -u -p a/misc/kgdbts.c b/misc/kgdbts.c
--- a/misc/kgdbts.c
+++ b/misc/kgdbts.c
@@ -1009,11 +1009,22 @@ static void kgdbts_run_tests(void)
 	v1printk("kgdbts:RUN bad memory access test\n");
 	run_bad_read_test();
 	v1printk("kgdbts:RUN singlestep test %i iterations\n", sstep_test);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sstep_test; i++) {
 		run_singlestep_break_test();
 		if (i % 100 == 0)
 			v1printk("kgdbts:RUN singlestep [%i/%i]\n",
 				 i, sstep_test);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* ===Optional tests=== */
diff -u -p a/misc/pch_phub.c b/misc/pch_phub.c
--- a/misc/pch_phub.c
+++ b/misc/pch_phub.c
@@ -211,12 +211,23 @@ static void pch_phub_save_reg_conf(struc
 		chip->intpin_reg_wpermit_reg1,
 		chip->intpin_reg_wpermit_reg2,
 		chip->intpin_reg_wpermit_reg3);
-	for (i = 0; i < MAX_NUM_INT_REDUCE_CONTROL_REG; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < MAX_NUM_INT_REDUCE_CONTROL_REG; i++) {
 		chip->int_reduce_control_reg[i] =
 		    ioread32(p + PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE + 4 * i);
 		dev_dbg(&pdev->dev, "%s : "
 			"chip->int_reduce_control_reg[%d]=%x\n",
 			__func__, i, chip->int_reduce_control_reg[i]);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 	chip->clkcfg_reg = ioread32(p + CLKCFG_REG_OFFSET);
 	if ((chip->ioh_type == 2) || (chip->ioh_type == 4))
@@ -272,12 +283,23 @@ static void pch_phub_restore_reg_conf(st
 		chip->intpin_reg_wpermit_reg1,
 		chip->intpin_reg_wpermit_reg2,
 		chip->intpin_reg_wpermit_reg3);
-	for (i = 0; i < MAX_NUM_INT_REDUCE_CONTROL_REG; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < MAX_NUM_INT_REDUCE_CONTROL_REG; i++) {
 		iowrite32(chip->int_reduce_control_reg[i],
 			p + PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE + 4 * i);
 		dev_dbg(&pdev->dev, "%s : "
 			"chip->int_reduce_control_reg[%d]=%x\n",
 			__func__, i, chip->int_reduce_control_reg[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	iowrite32(chip->clkcfg_reg, p + CLKCFG_REG_OFFSET);
@@ -483,10 +505,21 @@ static int pch_phub_write_gbe_mac_addr(s
 	if (retval)
 		return retval;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ETH_ALEN; i++) {
 		retval = pch_phub_write_serial_rom_val(chip, i, data[i]);
 		if (retval)
 			return retval;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return retval;
@@ -539,10 +572,21 @@ static ssize_t pch_phub_bin_read(struct
 			goto return_ok;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (addr_offset = 0; addr_offset < count; addr_offset++) {
 			pch_phub_read_serial_rom(chip,
 			    chip->pch_opt_rom_start_address + addr_offset + off,
 			    &buf[addr_offset]);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 		}
 	} else {
 		err = -ENODATA;
@@ -591,7 +635,12 @@ static ssize_t pch_phub_bin_write(struct
 		goto exrom_map_err;
 	}
 
-	for (addr_offset = 0; addr_offset < count; addr_offset++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (addr_offset = 0; addr_offset < count; addr_offset++) {
 		if (PCH_PHUB_OROM_SIZE < off + addr_offset)
 			goto return_ok;
 
@@ -602,6 +651,12 @@ static ssize_t pch_phub_bin_write(struct
 			err = ret;
 			goto return_err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 return_ok:
diff -u -p a/misc/hpilo.c b/misc/hpilo.c
--- a/misc/hpilo.c
+++ b/misc/hpilo.c
@@ -331,9 +331,20 @@ static void ilo_ccb_open(struct ilo_hwin
 
 	/* put packets on the send and receive queues */
 	pkt_sz = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pkt_id = 0; pkt_id < NR_QENTRY; pkt_id++) {
 		ilo_pkt_enqueue(hw, driver_ccb, SENDQ, pkt_id, pkt_sz);
 		doorbell_set(driver_ccb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pkt_sz = desc_mem_sz(1);
@@ -424,10 +435,21 @@ static void ilo_set_reset(struct ilo_hwi
 	 * Mapped memory is zeroed on ilo reset, so set a per ccb flag
 	 * to indicate that this ccb needs to be closed and reopened.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (slot = 0; slot < MAX_CCB; slot++) {
 		if (!hw->ccb_alloc[slot])
 			continue;
 		set_channel_reset(&hw->ccb_alloc[slot]->driver_ccb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -663,11 +685,22 @@ static irqreturn_t ilo_isr(int irq, void
 		ilo_set_reset(hw);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_CCB; i++) {
 		if (!hw->ccb_alloc[i])
 			continue;
 		if (pending & (1 << i))
 			wake_up_interruptible(&hw->ccb_alloc[i]->ccb_waitq);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* clear the device of the channels that have been handled */
@@ -809,13 +842,24 @@ static int __devinit ilo_probe(struct pc
 		goto remove_isr;
 	}
 
-	for (minor = 0 ; minor < MAX_CCB; minor++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (minor = 0 ; minor < MAX_CCB; minor++) {
 		struct device *dev;
 		dev = device_create(ilo_class, &pdev->dev,
 				    MKDEV(ilo_major, minor), NULL,
 				    "hpilo!d%dccb%d", devnum, minor);
 		if (IS_ERR(dev))
 			dev_err(&pdev->dev, "Could not create files\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
diff -u -p a/misc/tifm_7xx1.c b/misc/tifm_7xx1.c
--- a/misc/tifm_7xx1.c
+++ b/misc/tifm_7xx1.c
@@ -53,6 +53,11 @@ static irqreturn_t tifm_7xx1_isr(int irq
 	if (irq_status & TIFM_IRQ_ENABLE) {
 		writel(TIFM_IRQ_ENABLE, fm->addr + FM_CLEAR_INTERRUPT_ENABLE);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cnt = 0; cnt < fm->num_sockets; cnt++) {
 			sock = fm->sockets[cnt];
 			if (sock) {
@@ -61,6 +66,12 @@ static irqreturn_t tifm_7xx1_isr(int irq
 				if ((irq_status >> cnt) & TIFM_IRQ_CARDMASK(1))
 					sock->card_event(sock);
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 
 		fm->socket_change_set |= irq_status
@@ -158,6 +169,11 @@ static void tifm_7xx1_switch_media(struc
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < fm->num_sockets; cnt++) {
 		if (!(socket_change_set & (1 << cnt)))
 			continue;
@@ -197,6 +213,12 @@ static void tifm_7xx1_switch_media(struc
 				tifm_free_device(&sock->dev);
 		}
 		spin_lock_irqsave(&fm->lock, flags);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	writel(TIFM_IRQ_FIFOMASK(socket_change_set)
@@ -220,9 +242,20 @@ static int tifm_7xx1_suspend(struct pci_
 
 	dev_dbg(&dev->dev, "suspending host\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < fm->num_sockets; cnt++) {
 		if (fm->sockets[cnt])
 			tifm_7xx1_sock_power_off(fm->sockets[cnt]->addr);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	pci_save_state(dev);
@@ -254,6 +287,11 @@ static int tifm_7xx1_resume(struct pci_d
 		new_ids[rc] = tifm_7xx1_toggle_sock_power(
 					tifm_7xx1_sock_addr(fm->addr, rc));
 	spin_lock_irqsave(&fm->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rc = 0; rc < fm->num_sockets; rc++) {
 		if (fm->sockets[rc]) {
 			if (fm->sockets[rc]->type == new_ids[rc])
@@ -261,6 +299,12 @@ static int tifm_7xx1_resume(struct pci_d
 			else
 				bad_sockets |= 1 << rc;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	writel(TIFM_IRQ_ENABLE | TIFM_IRQ_SOCKMASK((1 << fm->num_sockets) - 1),
diff -u -p a/misc/iwmc3200top/main.c b/misc/iwmc3200top/main.c
--- a/misc/iwmc3200top/main.c
+++ b/misc/iwmc3200top/main.c
@@ -418,17 +418,39 @@ void iwmct_dbg_init_params(struct iwmct_
 #ifdef CONFIG_IWMC3200TOP_DEBUG
 	int i;
 
-	for (i = 0; i < log_level_argc; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < log_level_argc; i++) {
 		dev_notice(&priv->func->dev, "log_level[%d]=0x%X\n",
 						i, log_level[i]);
 		iwmct_log_set_filter((log_level[i] >> 8) & 0xFF,
 			       log_level[i] & 0xFF);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
-	for (i = 0; i < log_level_fw_argc; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < log_level_fw_argc; i++) {
 		dev_notice(&priv->func->dev, "log_level_fw[%d]=0x%X\n",
 						i, log_level_fw[i]);
 		iwmct_log_set_fw_filter((log_level_fw[i] >> 8) & 0xFF,
 				  log_level_fw[i] & 0xFF);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 #endif
 
diff -u -p a/misc/iwmc3200top/log.c b/misc/iwmc3200top/log.c
--- a/misc/iwmc3200top/log.c
+++ b/misc/iwmc3200top/log.c
@@ -146,10 +146,21 @@ void iwmct_log_top_message(struct iwmct_
 static int _log_get_filter_str(u8 *logdefs, int logdefsz, char *buf, int size)
 {
 	int i, pos, len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, pos = 0; (pos < size-1) && (i < logdefsz); i++) {
 		len = snprintf(&buf[pos], size - pos - 1, "0x%02X%02X,",
 				i, logdefs[i]);
 		pos += len;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	buf[pos-1] = '\n';
 	buf[pos] = '\0';
@@ -305,7 +316,12 @@ ssize_t store_iwmct_log_level_fw(struct
 	cmd.hdr.category = COMM_CATEGORY_DEBUG;
 	cmd.hdr.opcode = CMD_DBG_LOG_LEVEL;
 
-	for (i = 0; ((token = strsep(&str_buf, ",")) != NULL) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; ((token = strsep(&str_buf, ",")) != NULL) &&
 		     (i < FW_LOG_SRC_MAX); i++) {
 
 		while (isspace(*token))
@@ -325,6 +341,12 @@ ssize_t store_iwmct_log_level_fw(struct
 
 		cmd.u.logdefs[i].logsource = src;
 		cmd.u.logdefs[i].sevmask = mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	cmd.hdr.length = cpu_to_le16(i * sizeof(cmd.u.logdefs[0]));
diff -u -p a/misc/c2port/core.c b/misc/c2port/core.c
--- a/misc/c2port/core.c
+++ b/misc/c2port/core.c
@@ -116,11 +116,22 @@ static void c2port_write_ar(struct c2por
 	c2port_strobe_ck(dev);
 
 	/* ADDRESS field */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		ops->c2d_set(dev, addr & 0x01);
 		c2port_strobe_ck(dev);
 
 		addr >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* STOP field */
@@ -146,12 +157,23 @@ static int c2port_read_ar(struct c2port_
 	/* ADDRESS field */
 	ops->c2d_dir(dev, 1);
 	*addr = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		*addr >>= 1;	/* shift in 8-bit ADDRESS field LSB first */
 
 		c2port_strobe_ck(dev);
 		if (ops->c2d_get(dev))
 			*addr |= 0x80;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* STOP field */
@@ -182,11 +204,22 @@ static int c2port_write_dr(struct c2port
 	c2port_strobe_ck(dev);
 
 	/* DATA field */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		ops->c2d_set(dev, data & 0x01);
 		c2port_strobe_ck(dev);
 
 		data >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* WAIT field */
@@ -244,12 +277,23 @@ static int c2port_read_dr(struct c2port_
 
 	/* DATA field */
 	*data = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		*data >>= 1;	/* shift in 8-bit DATA field LSB first */
 
 		c2port_strobe_ck(dev);
 		if (ops->c2d_get(dev))
 			*data |= 0x80;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* STOP field */
@@ -694,6 +738,11 @@ static ssize_t __c2port_read_flash_data(
 		return -EBUSY;
 
 	/* Read flash block */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nread; i++) {
 		ret = c2port_poll_out_ready(dev);
 		if (ret < 0)
@@ -702,6 +751,12 @@ static ssize_t __c2port_read_flash_data(
 		ret = c2port_read_dr(dev, buffer+i);
 		if (ret < 0)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return nread;
@@ -805,6 +860,11 @@ static ssize_t __c2port_write_flash_data
 		return -EBUSY;
 
 	/* Write flash block */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nwrite; i++) {
 		ret = c2port_write_dr(dev, *(buffer+i));
 		if (ret < 0)
@@ -814,6 +874,12 @@ static ssize_t __c2port_write_flash_data
 		if (ret < 0)
 			return ret;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	/* Wait for last flash write to complete */
diff -u -p a/misc/pti.c b/misc/pti.c
--- a/misc/pti.c
+++ b/misc/pti.c
@@ -129,10 +129,21 @@ static void pti_write_to_aperture(struct
 		dwordcnt--;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dwordcnt; i++) {
 		ptiword = be32_to_cpu(*(u32 *)p);
 		p += 4;
 		iowrite32(ptiword, aperture);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	aperture += PTI_LASTDWORD_DTS;	/* adding DTS signals that is EOM */
diff -u -p a/misc/altera-stapl/altera-jtag.c b/misc/altera-stapl/altera-jtag.c
--- a/misc/altera-stapl/altera-jtag.c
+++ b/misc/altera-stapl/altera-jtag.c
@@ -146,6 +146,11 @@ int altera_set_dr_pre(struct altera_jtag
 		js->dr_pre = count;
 
 	if (status == 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; ++i) {
 			j = i + start_index;
 
@@ -160,6 +165,12 @@ int altera_set_dr_pre(struct altera_jtag
 							~(u32)(1 << (i & 7));
 
 			}
+			if (_cur < timeout) {
+							rdstcll(_cur);
+			}
+			else {
+							break;
+			}
 		}
 	}
 
@@ -185,6 +196,11 @@ int altera_set_ir_pre(struct altera_jtag
 		js->ir_pre = count;
 
 	if (status == 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; ++i) {
 			j = i + start_index;
 			if (preamble_data == NULL)
@@ -198,6 +214,12 @@ int altera_set_ir_pre(struct altera_jtag
 							~(u32)(1 << (i & 7));
 
 			}
+			if (_cur < timeout) {
+							rdstcll(_cur);
+			}
+			else {
+							break;
+			}
 		}
 	}
 
@@ -224,6 +246,11 @@ int altera_set_dr_post(struct altera_jta
 		js->dr_post = count;
 
 	if (status == 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; ++i) {
 			j = i + start_index;
 
@@ -238,6 +265,12 @@ int altera_set_dr_post(struct altera_jta
 					    ~(u32)(1 << (i & 7));
 
 			}
+			if (_cur < timeout) {
+					    rdstcll(_cur);
+			}
+			else {
+					    break;
+			}
 		}
 	}
 
@@ -265,6 +298,11 @@ int altera_set_ir_post(struct altera_jta
 	if (status != 0)
 		return status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; ++i) {
 		j = i + start_index;
 
@@ -278,6 +316,12 @@ int altera_set_ir_post(struct altera_jta
 				    ~(u32)(1 << (i & 7));
 
 		}
+		if (_cur < timeout) {
+				    rdstcll(_cur);
+		}
+		else {
+				    break;
+		}
 	}
 
 	return status;
@@ -416,12 +460,23 @@ static void altera_concatenate_data(u8 *
 {
 	u32 i, j, k;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0L; i < preamble_count; ++i) {
 		if (preamble_data[i >> 3L] & (1L << (i & 7L)))
 			buffer[i >> 3L] |= (1L << (i & 7L));
 		else
 			buffer[i >> 3L] &= ~(u32)(1L << (i & 7L));
 
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	j = start_index;
@@ -485,6 +540,11 @@ static int alt_jtag_drscan(struct altera
 
 	if (status) {
 		/* loop in the SHIFT-DR state */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; i++) {
 			tdo_bit = alt_jtag_io(
 					(i == count - 1),
@@ -498,6 +558,12 @@ static int alt_jtag_drscan(struct altera
 					tdo[i >> 3] &= ~(u32)(1 << (i & 7));
 
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 
 		alt_jtag_io(0, 0, 0);	/* DRPAUSE */
@@ -549,6 +615,11 @@ static int alt_jtag_irscan(struct altera
 
 	if (status) {
 		/* loop in the SHIFT-IR state */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; i++) {
 			tdo_bit = alt_jtag_io(
 				      (i == count - 1),
@@ -561,6 +632,12 @@ static int alt_jtag_irscan(struct altera
 					tdo[i >> 3] &= ~(u32)(1 << (i & 7));
 
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 
 		alt_jtag_io(0, 0, 0);	/* IRPAUSE */
@@ -585,12 +662,23 @@ static void altera_extract_target_data(u
 
 	j = preamble_count;
 	k = start_index + target_count;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start_index; i < k; ++i, ++j) {
 		if (buffer[j >> 3] & (1 << (j & 7)))
 			target_data[i >> 3] |= (1 << (i & 7));
 		else
 			target_data[i >> 3] &= ~(u32)(1 << (i & 7));
 
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/misc/altera-stapl/altera.c b/misc/altera-stapl/altera.c
--- a/misc/altera-stapl/altera.c
+++ b/misc/altera-stapl/altera.c
@@ -160,6 +160,11 @@ static void altera_export_bool_array(cha
 							key, count);
 		lines = (count + (HEX_LINE_BITS - 1)) / HEX_LINE_BITS;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (line = 0; line < lines; ++line) {
 			if (line < (lines - 1)) {
 				linebits = HEX_LINE_BITS;
@@ -176,6 +181,11 @@ static void altera_export_bool_array(cha
 			j = size - 1;
 			value = 0;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (k = 0; k < linebits; ++k) {
 				i = k + offset;
 				if (data[i >> 3] & (1 << (i & 7)))
@@ -185,11 +195,23 @@ static void altera_export_bool_array(cha
 					value = 0;
 					--j;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if ((k & 3) > 0)
 				sprintf(&string[j], "%1x", value);
 
 			dprintk("%s\n", string);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	} else {
@@ -198,6 +220,11 @@ static void altera_export_bool_array(cha
 		j = size - 1;
 		value = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; ++i) {
 			if (data[i >> 3] & (1 << (i & 7)))
 				value |= (1 << (i & 3));
@@ -206,6 +233,12 @@ static void altera_export_bool_array(cha
 				value = 0;
 				--j;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if ((i & 3) > 0)
 			sprintf(&string[j], "%1x", value);
@@ -335,6 +368,11 @@ static int altera_execute(struct altera_
 
 	delta = version * 2;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sym_count; ++i) {
 		offset = (sym_table + ((11 + delta) * i));
 
@@ -427,7 +465,13 @@ static int altera_execute(struct altera_
 		} else
 			vars[i] = 0;
 
-	}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 
 exit_done:
 	if (status != 0)
@@ -448,7 +492,12 @@ exit_done:
 			done = 1;
 		} else {
 			int action_found = 0;
-			for (i = 0; (i < action_count) && !action_found; ++i) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (i = 0; (i < action_count) && !action_found; ++i) {
 				name_id = get_unaligned_be32(&p[action_table +
 								(12 * i)]);
 
@@ -460,6 +509,12 @@ exit_done:
 						get_unaligned_be32(&p[action_table +
 								(12 * i) + 8]);
 				}
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 
 			if (!action_found) {
@@ -529,9 +584,20 @@ exit_done:
 			printk("opcode: %02x\n", opcode);
 
 		arg_count = (opcode >> 6) & 3;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < arg_count; ++i) {
 			args[i] = get_unaligned_be32(&p[pc]);
 			pc += 4;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+		}
+		else {
+					break;
+		}
 		}
 
 		switch (opcode) {
@@ -1146,10 +1212,21 @@ exit_done:
 				}
 
 				/* copy previous contents into buffer */
-				for (i = 0; i < count; ++i) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					for (i = 0; i < count; ++i) {
 					longptr_tmp[i] =
 						get_unaligned_be32(&p[long_tmp]);
 					long_tmp += sizeof(long);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				/*
@@ -1210,13 +1287,29 @@ exit_done:
 				}
 
 				/* zero the buffer */
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (long_idx = 0L;
 					long_idx < long_tmp;
 					++long_idx) {
 					charptr_tmp[long_idx] = 0;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				/* copy previous contents into buffer */
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (long_idx = 0L;
 					long_idx < var_size[variable_id];
 					++long_idx) {
@@ -1227,6 +1320,12 @@ exit_done:
 						charptr_tmp[long_idx >> 3] |=
 							(1 << (long_idx & 7));
 					}
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
 				}
 
 				/*
@@ -1290,6 +1389,11 @@ exit_done:
 				break;
 			}
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < long_count; ++i) {
 				if (long_tmp & (1L << (s32) i))
 					charptr_tmp[long_idx >> 3L] |=
@@ -1299,6 +1403,12 @@ exit_done:
 						~(1L << (long_idx & 7L));
 
 				++long_idx;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 
 			break;
@@ -1667,7 +1777,12 @@ exit_done:
 					break;
 				}
 
-				for (i = 0; i < long_count; ++i) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+						for (i = 0; i < long_count; ++i) {
 					if (charptr_tmp[k >> 3] &
 							(1 << (k & 7)))
 						charptr_tmp2[i >> 3] |=
@@ -1677,6 +1792,12 @@ exit_done:
 								~(1 << (i & 7));
 
 					++k;
+					if (_cur < timeout) {
+								rdstcll(_cur);
+					}
+					else {
+								break;
+					}
 				}
 				charptr_tmp = charptr_tmp2;
 
@@ -1793,7 +1914,12 @@ exit_done:
 					charptr_tmp[long_idx] = 0;
 
 				/* copy previous contents into buffer */
-				for (long_idx = 0L;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					for (long_idx = 0L;
 					long_idx < var_size[variable_id];
 								++long_idx) {
 					long_idx2 = long_idx;
@@ -1803,6 +1929,12 @@ exit_done:
 						charptr_tmp[long_idx >> 3] |=
 							(1 << (long_idx & 7));
 
+							if (_cur < timeout) {
+					rdstcll(_cur);
+							}
+							else {
+					break;
+							}
 				}
 
 				/*
@@ -1831,7 +1963,12 @@ exit_done:
 			if (reverse)
 				index2 += (count - 1);
 
-			for (i = 0; i < count; ++i) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+					for (i = 0; i < count; ++i) {
 				if (charptr_tmp2[index >> 3] &
 							(1 << (index & 7)))
 					charptr_tmp[index2 >> 3] |=
@@ -1845,6 +1982,12 @@ exit_done:
 					--index2;
 				else
 					++index2;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 
 			break;
@@ -1914,7 +2057,12 @@ exit_done:
 					charptr_tmp[long_idx] = 0;
 
 				/* copy previous contents into buffer */
-				for (long_idx = 0L;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					for (long_idx = 0L;
 					long_idx < var_size[variable_id];
 								++long_idx) {
 					long_idx2 = long_idx;
@@ -1924,6 +2072,12 @@ exit_done:
 						charptr_tmp[long_idx >> 3] |=
 							(1 << (long_idx & 7));
 
+							if (_cur < timeout) {
+					rdstcll(_cur);
+							}
+							else {
+					break;
+							}
 				}
 
 				/*
@@ -2069,6 +2223,11 @@ exit_done:
 			else {
 				count = long_count;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < count; ++i) {
 					if (mask[mask_index >> 3] &
 						(1 << (mask_index & 7))) {
@@ -2085,6 +2244,12 @@ exit_done:
 					++index1;
 					++index2;
 					++mask_index;
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
 				}
 			}
 
@@ -2171,7 +2336,12 @@ static int altera_get_note(u8 *p, s32 pr
 		 * We will search for the first note with a specific key,
 		 * and return only the value
 		 */
-		for (i = 0; (i < note_count) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; (i < note_count) &&
 						(status != 0); ++i) {
 			key_ptr = &p[note_strings +
 					get_unaligned_be32(
@@ -2188,6 +2358,12 @@ static int altera_get_note(u8 *p, s32 pr
 					strlcpy(value, value_ptr, length);
 
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	} else {
 		/*
@@ -2250,8 +2426,18 @@ static int altera_check_crc(u8 *p, s32 p
 	if (status == 0) {
 		local_expected = (u16)get_unaligned_be16(&p[crc_section]);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < crc_section; ++i) {
 			databyte = p[i];
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (bit = 0; bit < 8; bit++) {
 				feedback = (databyte ^ shift_reg) & 0x01;
 				shift_reg >>= 1;
@@ -2259,6 +2445,18 @@ static int altera_check_crc(u8 *p, s32 p
 					shift_reg ^= 0x8408;
 
 				databyte >>= 1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+		break;
 			}
 		}
 
@@ -2471,7 +2669,12 @@ int altera_init(struct altera_config *co
 
 	if (debug && (format_version == 2) && (action_count > 0)) {
 		printk(KERN_INFO "%s: Actions available:\n", __func__);
-		for (index = 0; index < action_count; ++index) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (index = 0; index < action_count; ++index) {
 			altera_get_act_info((u8 *)fw->data, fw->size,
 						index, &action_name,
 						&description,
@@ -2500,6 +2703,12 @@ int altera_init(struct altera_config *co
 				kfree(procptr);
 				procptr = proc_list;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		printk(KERN_INFO "\n");
diff -u -p a/misc/altera-stapl/altera-comp.c b/misc/altera-stapl/altera-comp.c
--- a/misc/altera-stapl/altera-comp.c
+++ b/misc/altera-stapl/altera-comp.c
@@ -92,12 +92,23 @@ u32 altera_shrink(u8 *in, u32 in_length,
 		out[i] = 0;
 
 	/* Read number of bytes in data. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sizeof(in_length); ++i) {
 		data_length = data_length | (
 			altera_read_packed(in,
 					CHAR_BITS,
 					&bits_avail,
 					&in_index) << (i * CHAR_BITS));
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (data_length > out_length) {
@@ -110,7 +121,12 @@ u32 altera_shrink(u8 *in, u32 in_length,
 		/* A 0 bit indicates literal data. */
 		if (altera_read_packed(in, 1, &bits_avail,
 						&in_index) == 0) {
-			for (j = 0; j < DATA_BLOB_LENGTH; ++j) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (j = 0; j < DATA_BLOB_LENGTH; ++j) {
 				if (i < data_length) {
 					out[i] = (u8)altera_read_packed(in,
 							CHAR_BITS,
@@ -118,6 +134,12 @@ u32 altera_shrink(u8 *in, u32 in_length,
 							&in_index);
 					i++;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
 			/* A 1 bit indicates offset/length to follow. */
@@ -129,11 +151,22 @@ u32 altera_shrink(u8 *in, u32 in_length,
 			length = altera_read_packed(in, CHAR_BITS,
 					&bits_avail,
 					&in_index);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < length; ++j) {
 				if (i < data_length) {
 					out[i] = out[i - offset];
 					i++;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
diff -u -p a/input/keyboard/atakbd.c b/input/keyboard/atakbd.c
--- a/input/keyboard/atakbd.c
+++ b/input/keyboard/atakbd.c
@@ -243,8 +243,19 @@ static int __init atakbd_init(void)
 	atakbd_dev->keycodesize = sizeof(unsigned char);
 	atakbd_dev->keycodemax = ARRAY_SIZE(atakbd_keycode);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < 0x72; i++) {
 		set_bit(atakbd_keycode[i], atakbd_dev->keybit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* error check */
diff -u -p a/input/keyboard/qt2160.c b/input/keyboard/qt2160.c
--- a/input/keyboard/qt2160.c
+++ b/input/keyboard/qt2160.c
@@ -134,6 +134,11 @@ static int qt2160_get_key_matrix(struct
 	qt2160->key_matrix = new_matrix = (regs[2] << 8) | regs[1];
 
 	mask = 0x01;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; ++i, mask <<= 1) {
 		int keyval = new_matrix & mask;
 
@@ -142,6 +147,12 @@ static int qt2160_get_key_matrix(struct
 			dev_dbg(&client->dev, "key %d %s\n",
 				i, keyval ? "pressed" : "released");
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_sync(input);
@@ -301,9 +312,20 @@ static int __devinit qt2160_probe(struct
 
 	__set_bit(EV_KEY, input->evbit);
 	__clear_bit(EV_REP, input->evbit);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(qt2160_key2code); i++) {
 		qt2160->keycodes[i] = qt2160_key2code[i];
 		__set_bit(qt2160_key2code[i], input->keybit);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	__clear_bit(KEY_RESERVED, input->keybit);
 
diff -u -p a/input/keyboard/qt1070.c b/input/keyboard/qt1070.c
--- a/input/keyboard/qt1070.c
+++ b/input/keyboard/qt1070.c
@@ -128,11 +128,22 @@ static irqreturn_t qt1070_interrupt(int
 	/* Read which key changed */
 	new_keys = qt1070_read(client, KEY_STATUS);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(qt1070_key2code); i++) {
 		keyval = new_keys & mask;
 		if ((data->last_keys & mask) != keyval)
 			input_report_key(input, data->keycodes[i], keyval);
 		mask <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	input_sync(input);
 
@@ -187,9 +198,20 @@ static int __devinit qt1070_probe(struct
 
 	__set_bit(EV_KEY, input->evbit);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(qt1070_key2code); i++) {
 		data->keycodes[i] = qt1070_key2code[i];
 		__set_bit(qt1070_key2code[i], input->keybit);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Calibrate device */
diff -u -p a/input/keyboard/stmpe-keypad.c b/input/keyboard/stmpe-keypad.c
--- a/input/keyboard/stmpe-keypad.c
+++ b/input/keyboard/stmpe-keypad.c
@@ -123,12 +123,23 @@ static int stmpe_keypad_read_data(struct
 		return stmpe_block_read(stmpe, STMPE_KPC_DATA_BYTE0,
 					variant->num_data, data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < variant->num_data; i++) {
 		ret = stmpe_reg_read(stmpe, STMPE_KPC_DATA_BYTE0 + i);
 		if (ret < 0)
 			return ret;
 
 		data[i] = ret;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -147,6 +158,11 @@ static irqreturn_t stmpe_keypad_irq(int
 	if (ret < 0)
 		return IRQ_NONE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < variant->num_normal_data; i++) {
 		u8 data = fifo[i];
 		int row = (data & STMPE_KPC_DATA_ROW) >> 3;
@@ -161,6 +177,12 @@ static irqreturn_t stmpe_keypad_irq(int
 		input_event(input, EV_MSC, MSC_SCAN, code);
 		input_report_key(input, keypad->keymap[code], !up);
 		input_sync(input);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return IRQ_HANDLED;
@@ -186,6 +208,11 @@ static int __devinit stmpe_keypad_altfun
 	 * for the keypad) are used on the board.
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < variant->max_cols; i++) {
 		int num = __ffs(col_gpios);
 
@@ -193,8 +220,19 @@ static int __devinit stmpe_keypad_altfun
 			pins |= 1 << num;
 
 		col_gpios &= ~(1 << num);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < variant->max_rows; i++) {
 		int num = __ffs(row_gpios);
 
@@ -202,6 +240,12 @@ static int __devinit stmpe_keypad_altfun
 			pins |= 1 << num;
 
 		row_gpios &= ~(1 << num);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return stmpe_set_altfunc(stmpe, pins, STMPE_BLOCK_KEYPAD);
@@ -302,11 +346,22 @@ static int __devinit stmpe_keypad_probe(
 	matrix_keypad_build_keymap(plat->keymap_data, STMPE_KEYPAD_ROW_SHIFT,
 				   input->keycode, input->keybit);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < plat->keymap_data->keymap_size; i++) {
 		unsigned int key = plat->keymap_data->keymap[i];
 
 		keypad->cols |= 1 << KEY_COL(key);
 		keypad->rows |= 1 << KEY_ROW(key);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	keypad->stmpe = stmpe;
diff -u -p a/input/keyboard/matrix_keypad.c b/input/keyboard/matrix_keypad.c
--- a/input/keyboard/matrix_keypad.c
+++ b/input/keyboard/matrix_keypad.c
@@ -127,6 +127,11 @@ static void matrix_keypad_scan(struct wo
 	memset(new_state, 0, sizeof(new_state));
 
 	/* assert each column and read the row status out */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = 0; col < pdata->num_col_gpios; col++) {
 
 		activate_col(pdata, col, true);
@@ -136,8 +141,19 @@ static void matrix_keypad_scan(struct wo
 				row_asserted(pdata, row) ? (1 << row) : 0;
 
 		activate_col(pdata, col, false);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = 0; col < pdata->num_col_gpios; col++) {
 		uint32_t bits_changed;
 
@@ -145,6 +161,11 @@ static void matrix_keypad_scan(struct wo
 		if (bits_changed == 0)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (row = 0; row < pdata->num_row_gpios; row++) {
 			if ((bits_changed & (1 << row)) == 0)
 				continue;
@@ -154,6 +175,18 @@ static void matrix_keypad_scan(struct wo
 			input_report_key(input_dev,
 					 keypad->keycodes[code],
 					 new_state[col] & (1 << row));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 	input_sync(input_dev);
@@ -236,6 +269,11 @@ static void matrix_keypad_enable_wakeup(
 			keypad->gpio_all_disabled = true;
 	} else {
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < pdata->num_row_gpios; i++) {
 			if (!test_bit(i, keypad->disabled_gpios)) {
 				gpio = pdata->row_gpios[i];
@@ -243,6 +281,12 @@ static void matrix_keypad_enable_wakeup(
 				if (enable_irq_wake(gpio_to_irq(gpio)) == 0)
 					__set_bit(i, keypad->disabled_gpios);
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 }
@@ -259,11 +303,22 @@ static void matrix_keypad_disable_wakeup
 			keypad->gpio_all_disabled = false;
 		}
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < pdata->num_row_gpios; i++) {
 			if (test_and_clear_bit(i, keypad->disabled_gpios)) {
 				gpio = pdata->row_gpios[i];
 				disable_irq_wake(gpio_to_irq(gpio));
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -305,6 +360,11 @@ static int __devinit init_matrix_gpio(st
 	int i, err = -EINVAL;
 
 	/* initialized strobe lines as outputs, activated */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_col_gpios; i++) {
 		err = gpio_request(pdata->col_gpios[i], "matrix_kbd_col");
 		if (err) {
@@ -315,8 +375,19 @@ static int __devinit init_matrix_gpio(st
 		}
 
 		gpio_direction_output(pdata->col_gpios[i], !pdata->active_low);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_row_gpios; i++) {
 		err = gpio_request(pdata->row_gpios[i], "matrix_kbd_row");
 		if (err) {
@@ -327,6 +398,12 @@ static int __devinit init_matrix_gpio(st
 		}
 
 		gpio_direction_input(pdata->row_gpios[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (pdata->clustered_irq > 0) {
@@ -340,7 +417,12 @@ static int __devinit init_matrix_gpio(st
 			goto err_free_rows;
 		}
 	} else {
-		for (i = 0; i < pdata->num_row_gpios; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < pdata->num_row_gpios; i++) {
 			err = request_irq(gpio_to_irq(pdata->row_gpios[i]),
 					matrix_keypad_interrupt,
 					IRQF_TRIGGER_RISING |
@@ -353,6 +435,12 @@ static int __devinit init_matrix_gpio(st
 					pdata->row_gpios[i]);
 				goto err_free_irqs;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/input/keyboard/gpio_keys.c b/input/keyboard/gpio_keys.c
--- a/input/keyboard/gpio_keys.c
+++ b/input/keyboard/gpio_keys.c
@@ -167,6 +167,11 @@ static ssize_t gpio_keys_attr_show_helpe
 	if (!bits)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ddata->n_buttons; i++) {
 		struct gpio_button_data *bdata = &ddata->data[i];
 
@@ -177,6 +182,12 @@ static ssize_t gpio_keys_attr_show_helpe
 			continue;
 
 		__set_bit(bdata->button->code, bits);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = bitmap_scnlistprintf(buf, PAGE_SIZE - 2, bits, n_events);
@@ -215,6 +226,11 @@ static ssize_t gpio_keys_attr_store_help
 		goto out;
 
 	/* First validate */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ddata->n_buttons; i++) {
 		struct gpio_button_data *bdata = &ddata->data[i];
 
@@ -226,10 +242,21 @@ static ssize_t gpio_keys_attr_store_help
 			error = -EINVAL;
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_lock(&ddata->disable_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ddata->n_buttons; i++) {
 		struct gpio_button_data *bdata = &ddata->data[i];
 
@@ -240,6 +267,12 @@ static ssize_t gpio_keys_attr_store_help
 			gpio_keys_disable_button(bdata);
 		else
 			gpio_keys_enable_button(bdata);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	mutex_unlock(&ddata->disable_lock);
@@ -598,6 +631,11 @@ static int __devinit gpio_keys_probe(str
 	if (pdata->rep)
 		__set_bit(EV_REP, input->evbit);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->nbuttons; i++) {
 		struct gpio_keys_button *button = &pdata->buttons[i];
 		struct gpio_button_data *bdata = &ddata->data[i];
@@ -614,6 +652,12 @@ static int __devinit gpio_keys_probe(str
 			wakeup = 1;
 
 		input_set_capability(input, type, button->code);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	error = sysfs_create_group(&pdev->dev.kobj, &gpio_keys_attr_group);
@@ -671,6 +715,11 @@ static int __devexit gpio_keys_remove(st
 
 	device_init_wakeup(&pdev->dev, 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ddata->n_buttons; i++) {
 		int irq = gpio_to_irq(ddata->data[i].button->gpio);
 		free_irq(irq, &ddata->data[i]);
@@ -678,6 +727,12 @@ static int __devexit gpio_keys_remove(st
 			del_timer_sync(&ddata->data[i].timer);
 		cancel_work_sync(&ddata->data[i].work);
 		gpio_free(ddata->data[i].button->gpio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_unregister_device(input);
@@ -702,12 +757,23 @@ static int gpio_keys_suspend(struct devi
 	int i;
 
 	if (device_may_wakeup(dev)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ddata->n_buttons; i++) {
 			struct gpio_keys_button *button = ddata->data[i].button;
 			if (button->wakeup) {
 				int irq = gpio_to_irq(button->gpio);
 				enable_irq_wake(irq);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -719,6 +785,11 @@ static int gpio_keys_resume(struct devic
 	struct gpio_keys_drvdata *ddata = dev_get_drvdata(dev);
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ddata->n_buttons; i++) {
 
 		struct gpio_keys_button *button = ddata->data[i].button;
@@ -728,6 +799,12 @@ static int gpio_keys_resume(struct devic
 		}
 
 		gpio_keys_report_event(&ddata->data[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	input_sync(ddata->input);
 
diff -u -p a/input/keyboard/pmic8xxx-keypad.c b/input/keyboard/pmic8xxx-keypad.c
--- a/input/keyboard/pmic8xxx-keypad.c
+++ b/input/keyboard/pmic8xxx-keypad.c
@@ -193,10 +193,21 @@ static int pmic8xxx_kp_read_data(struct
 	if (rc)
 		return rc;
 
-	for (row = 0; row < kp->pdata->num_rows; row++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (row = 0; row < kp->pdata->num_rows; row++) {
 		dev_dbg(kp->dev, "new_data[%d] = %d\n", row,
 					new_data[row]);
 		state[row] = pmic8xxx_col_state(kp, new_data[row]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return rc;
@@ -255,12 +266,22 @@ static void __pmic8xxx_kp_scan_matrix(st
 {
 	int row, col, code;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (row = 0; row < kp->pdata->num_rows; row++) {
 		int bits_changed = new_state[row] ^ old_state[row];
 
 		if (!bits_changed)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (col = 0; col < kp->pdata->num_cols; col++) {
 			if (!(bits_changed & (1 << col)))
 				continue;
@@ -277,6 +298,18 @@ static void __pmic8xxx_kp_scan_matrix(st
 					!(new_state[row] & (1 << col)));
 
 			input_sync(kp->input);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
@@ -287,7 +320,12 @@ static bool pmic8xxx_detect_ghost_keys(s
 	u16 check, row_state;
 
 	check = 0;
-	for (row = 0; row < kp->pdata->num_rows; row++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (row = 0; row < kp->pdata->num_rows; row++) {
 		row_state = (~new_state[row]) &
 				 ((1 << kp->pdata->num_cols) - 1);
 
@@ -301,6 +339,12 @@ static bool pmic8xxx_detect_ghost_keys(s
 			}
 		}
 		check |= row_state;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return false;
 }
@@ -455,6 +499,11 @@ static int  __devinit pmic8xxx_kp_config
 	if (gpio_start < 0 || num_gpios < 0)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_gpios; i++) {
 		rc = pm8xxx_gpio_config(gpio_start + i, gpio_config);
 		if (rc) {
@@ -463,6 +512,12 @@ static int  __devinit pmic8xxx_kp_config
 					__func__, gpio_start + i, rc);
 			return rc;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	 }
 
 	return 0;
diff -u -p a/input/keyboard/hil_kbd.c b/input/keyboard/hil_kbd.c
--- a/input/keyboard/hil_kbd.c
+++ b/input/keyboard/hil_kbd.c
@@ -167,6 +167,11 @@ static void hil_dev_handle_kbd_events(st
 		break;
 
 	case HIL_POL_CHARTYPE_SET1:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 1; i < idx - 1; i++) {
 			unsigned int key = kbd->data[i];
 			int up = key & HIL_KBD_SET1_UPBIT;
@@ -174,10 +179,21 @@ static void hil_dev_handle_kbd_events(st
 			key &= (~HIL_KBD_SET1_UPBIT & 0xff);
 			key = hil_kbd_set1[key >> HIL_KBD_SET1_SHIFT];
 			input_report_key(dev, key, !up);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		break;
 
 	case HIL_POL_CHARTYPE_SET2:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 1; i < idx - 1; i++) {
 			unsigned int key = kbd->data[i];
 			int up = key & HIL_KBD_SET2_UPBIT;
@@ -185,10 +201,21 @@ static void hil_dev_handle_kbd_events(st
 			key &= (~HIL_KBD_SET1_UPBIT & 0xff);
 			key = key >> HIL_KBD_SET2_SHIFT;
 			input_report_key(dev, key, !up);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		break;
 
 	case HIL_POL_CHARTYPE_SET3:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 1; i < idx - 1; i++) {
 			unsigned int key = kbd->data[i];
 			int up = key & HIL_KBD_SET3_UPBIT;
@@ -196,6 +223,12 @@ static void hil_dev_handle_kbd_events(st
 			key &= (~HIL_KBD_SET1_UPBIT & 0xff);
 			key = hil_kbd_set3[key >> HIL_KBD_SET3_SHIFT];
 			input_report_key(dev, key, !up);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		break;
 	}
@@ -223,6 +256,11 @@ static void hil_dev_handle_ptr_events(st
 	ax16 = ptr->idd[1] & HIL_IDD_HEADER_16BIT; /* 8 or 16bit resolution */
 	absdev = ptr->idd[1] & HIL_IDD_HEADER_ABS;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 1; i < laxis; i++) {
 		unsigned int lo, hi, val;
 
@@ -246,6 +284,12 @@ static void hil_dev_handle_ptr_events(st
 				val *= -1;
 			input_report_rel(dev, REL_X + i, val);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	while (cnt < idx - 1) {
@@ -334,9 +378,20 @@ static void hil_dev_keyboard_setup(struc
 	input_dev->ledbit[0]	= BIT_MASK(LED_NUML) | BIT_MASK(LED_CAPSL) |
 				  BIT_MASK(LED_SCROLLL);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 128; i++) {
 		__set_bit(hil_kbd_set1[i], input_dev->keybit);
 		__set_bit(hil_kbd_set3[i], input_dev->keybit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	__clear_bit(KEY_RESERVED, input_dev->keybit);
 
@@ -387,12 +442,23 @@ static void hil_dev_pointer_setup(struct
 					0, HIL_IDD_AXIS_MAX(idd, i - 3), 0, 0);
 
 #ifdef TABLET_AUTOADJUST
-		for (i = 0; i < ABS_MAX; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < ABS_MAX; i++) {
 			int diff = input_abs_get_max(input_dev, ABS_X + i) / 10;
 			input_abs_set_min(input_dev, ABS_X + i,
 				input_abs_get_min(input_dev, ABS_X + i) + diff);
 			input_abs_set_max(input_dev, ABS_X + i,
 				input_abs_get_max(input_dev, ABS_X + i) - diff);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 #endif
 
@@ -420,9 +486,20 @@ static void hil_dev_pointer_setup(struct
 	if ((did & HIL_IDD_DID_REL_MOUSE_MASK) == HIL_IDD_DID_REL_MOUSE)
 		btntype = BTN_MOUSE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ptr->nbtn; i++) {
 		__set_bit(btntype | i, input_dev->keybit);
 		ptr->btnmap[i] = btntype | i;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	if (btntype == BTN_MOUSE) {
diff -u -p a/input/keyboard/davinci_keyscan.c b/input/keyboard/davinci_keyscan.c
--- a/input/keyboard/davinci_keyscan.c
+++ b/input/keyboard/davinci_keyscan.c
@@ -144,6 +144,11 @@ static irqreturn_t davinci_ks_interrupt(
 		 * It goes through all bits in 'changed' to ensure
 		 * that no key changes are being missed
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0 ; i < keymapsize; i++) {
 			if ((changed>>i) & 0x1) {
 				keycode = keymap[i];
@@ -154,6 +159,12 @@ static irqreturn_t davinci_ks_interrupt(
 						 !release);
 				input_sync(davinci_ks->input);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* Clearing interrupt */
 		__raw_writel(DAVINCI_KEYSCAN_INT_ALL,
diff -u -p a/input/keyboard/gpio_keys_polled.c b/input/keyboard/gpio_keys_polled.c
--- a/input/keyboard/gpio_keys_polled.c
+++ b/input/keyboard/gpio_keys_polled.c
@@ -71,6 +71,11 @@ static void gpio_keys_polled_poll(struct
 	struct input_dev *input = dev->input;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bdev->pdata->nbuttons; i++) {
 		struct gpio_keys_button_data *bdata = &bdev->data[i];
 
@@ -79,6 +84,12 @@ static void gpio_keys_polled_poll(struct
 		else
 			gpio_keys_polled_check_state(input, &pdata->buttons[i],
 						     bdata);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -146,6 +157,11 @@ static int __devinit gpio_keys_polled_pr
 	input->id.product = 0x0001;
 	input->id.version = 0x0100;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->nbuttons; i++) {
 		struct gpio_keys_button *button = &pdata->buttons[i];
 		struct gpio_keys_button_data *bdata = &bdev->data[i];
@@ -180,6 +196,12 @@ static int __devinit gpio_keys_polled_pr
 						pdata->poll_interval);
 
 		input_set_capability(input, type, button->code);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	bdev->poll_dev = poll_dev;
diff -u -p a/input/keyboard/sh_keysc.c b/input/keyboard/sh_keysc.c
--- a/input/keyboard/sh_keysc.c
+++ b/input/keyboard/sh_keysc.c
@@ -106,6 +106,11 @@ static irqreturn_t sh_keysc_isr(int irq,
 
 		sh_keysc_write(priv, KYCR2, KYCR2_IRQ_DISABLED);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < keyout_nr; i++) {
 			n = keyin_nr * i;
 
@@ -115,13 +120,30 @@ static irqreturn_t sh_keysc_isr(int irq,
 			tmp = sh_keysc_read(priv, KYINDR);
 
 			/* set bit if key press has been detected */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (k = 0; k < keyin_nr; k++) {
 				if (tmp & (1 << k))
 					__set_bit(n + k, keys);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 			}
 
 			/* keep track of which KEYIN bits that have been set */
 			keyin_set |= tmp ^ ((1 << keyin_nr) - 1);
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 
 		sh_keysc_level_mode(priv, keyin_set);
@@ -138,6 +160,11 @@ static irqreturn_t sh_keysc_isr(int irq,
 	sh_keysc_map_dbg(&pdev->dev, keys0, "keys0");
 	sh_keysc_map_dbg(&pdev->dev, keys1, "keys1");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < SH_KEYSC_MAXKEYS; i++) {
 		k = pdata->keycodes[i];
 		if (!k)
@@ -156,6 +183,12 @@ static irqreturn_t sh_keysc_isr(int irq,
 			__clear_bit(i, priv->last_keys);
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	input_sync(priv->input);
 
diff -u -p a/input/keyboard/mpr121_touchkey.c b/input/keyboard/mpr121_touchkey.c
--- a/input/keyboard/mpr121_touchkey.c
+++ b/input/keyboard/mpr121_touchkey.c
@@ -132,6 +132,11 @@ static int __devinit mpr121_phys_init(co
 	int i, t, vdd, ret;
 
 	/* Set up touch/release threshold for ele0-ele11 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= MPR121_MAX_KEY_COUNT; i++) {
 		t = ELE0_TOUCH_THRESHOLD_ADDR + (i * 2);
 		ret = i2c_smbus_write_byte_data(client, t, TOUCH_THRESHOLD);
@@ -141,14 +146,31 @@ static int __devinit mpr121_phys_init(co
 						RELEASE_THRESHOLD);
 		if (ret < 0)
 			goto err_i2c_write;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* Set up init register */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(init_reg_table); i++) {
 		reg = &init_reg_table[i];
 		ret = i2c_smbus_write_byte_data(client, reg->addr, reg->val);
 		if (ret < 0)
 			goto err_i2c_write;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 
@@ -235,9 +257,20 @@ static int __devinit mpr_touchkey_probe(
 	input_dev->keycodesize = sizeof(mpr121->keycodes[0]);
 	input_dev->keycodemax = mpr121->keycount;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->keymap_size; i++) {
 		input_set_capability(input_dev, EV_KEY, pdata->keymap[i]);
 		mpr121->keycodes[i] = pdata->keymap[i];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	error = mpr121_phys_init(pdata, mpr121, client);
diff -u -p a/input/keyboard/jornada680_kbd.c b/input/keyboard/jornada680_kbd.c
--- a/input/keyboard/jornada680_kbd.c
+++ b/input/keyboard/jornada680_kbd.c
@@ -81,6 +81,11 @@ static void jornada_parse_kbd(struct jor
 	unsigned int sync_me = 0;
 	unsigned int i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < JORNADA_SCAN_SIZE; i++) {
 		unsigned char new = jornadakbd->new_scan[i];
 		unsigned char old = jornadakbd->old_scan[i];
@@ -89,6 +94,11 @@ static void jornada_parse_kbd(struct jor
 		if (xor == 0)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 8; j++) {
 			unsigned int bit = 1 << j;
 			if (xor & bit) {
@@ -100,7 +110,19 @@ static void jornada_parse_kbd(struct jor
 						 !(new & bit));
 				sync_me = 1;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+	    }
+	    else {
+			break;
+	    }
 	}
 
 	if (sync_me)
@@ -142,6 +164,11 @@ static void jornada_scan_keyb(unsigned c
 	dc_static = (__raw_readw(PDCR) & (~0xcc0c));
 	ec_static = (__raw_readw(PECR) & (~0xf0cf));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		/* disable output for all but the one we want to scan */
 		__raw_writew((dc_static | *y++), PDCR);
@@ -156,6 +183,12 @@ static void jornada_scan_keyb(unsigned c
 		/* Read data */
 		*s++ = __raw_readb(PCDR);
 		*s++ = __raw_readb(PFDR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Scan no lines */
 	__raw_writeb(0xff, PDDR);
diff -u -p a/input/keyboard/lm8323.c b/input/keyboard/lm8323.c
--- a/input/keyboard/lm8323.c
+++ b/input/keyboard/lm8323.c
@@ -397,12 +397,23 @@ static irqreturn_t lm8323_irq(int irq, v
 						  "reinitialising\n");
 			lm8323_configure(lm);
 		}
-		for (i = 0; i < LM8323_NUM_PWMS; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < LM8323_NUM_PWMS; i++) {
 			if (ints & (1 << (INT_PWM1 + i))) {
 				dev_vdbg(&lm->client->dev,
 					 "pwm%d engine completed\n", i);
 				pwm_done(&lm->pwm[i]);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -699,11 +710,22 @@ static int __devinit lm8323_probe(struct
 		goto fail1;
 	}
 
-	for (pwm = 0; pwm < LM8323_NUM_PWMS; pwm++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pwm = 0; pwm < LM8323_NUM_PWMS; pwm++) {
 		err = init_pwm(lm, pwm + 1, &client->dev,
 			       pdata->pwm_names[pwm]);
 		if (err < 0)
 			goto fail2;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	lm->kp_enabled = true;
@@ -718,9 +740,20 @@ static int __devinit lm8323_probe(struct
 
 	idev->evbit[0] = BIT(EV_KEY) | BIT(EV_MSC);
 	__set_bit(MSC_SCAN, idev->mscbit);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < LM8323_KEYMAP_SIZE; i++) {
 		__set_bit(pdata->keymap[i], idev->keybit);
 		lm->keymap[i] = pdata->keymap[i];
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	__clear_bit(KEY_RESERVED, idev->keybit);
 
diff -u -p a/input/keyboard/pxa27x_keypad.c b/input/keyboard/pxa27x_keypad.c
--- a/input/keyboard/pxa27x_keypad.c
+++ b/input/keyboard/pxa27x_keypad.c
@@ -125,6 +125,11 @@ static void pxa27x_keypad_build_keycode(
 	unsigned short keycode;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->matrix_key_map_size; i++) {
 		unsigned int key = pdata->matrix_key_map[i];
 		unsigned int row = KEY_ROW(key);
@@ -135,12 +140,29 @@ static void pxa27x_keypad_build_keycode(
 		keycode = KEY_VAL(key);
 		keypad->keycodes[scancode] = keycode;
 		__set_bit(keycode, input_dev->keybit);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->direct_key_num; i++) {
 		keycode = pdata->direct_key_map[i];
 		keypad->keycodes[MAX_MATRIX_KEY_NUM + i] = keycode;
 		__set_bit(keycode, input_dev->keybit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (pdata->enable_rotary0) {
@@ -224,6 +246,11 @@ static void pxa27x_keypad_scan_matrix(st
 		new_state[7] = (kpasmkp3 >> 16) & KPASMKP_MKC_MASK;
 	}
 scan:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = 0; col < pdata->matrix_key_cols; col++) {
 		uint32_t bits_changed;
 		int code;
@@ -232,6 +259,11 @@ scan:
 		if (bits_changed == 0)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (row = 0; row < pdata->matrix_key_rows; row++) {
 			if ((bits_changed & (1 << row)) == 0)
 				continue;
@@ -240,6 +272,18 @@ scan:
 			input_event(input_dev, EV_MSC, MSC_SCAN, code);
 			input_report_key(input_dev, keypad->keycodes[code],
 					 new_state[col] & (1 << row));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 	input_sync(input_dev);
@@ -317,6 +361,11 @@ static void pxa27x_keypad_scan_direct(st
 	if (bits_changed == 0)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->direct_key_num; i++) {
 		if (bits_changed & (1 << i)) {
 			int code = MAX_MATRIX_KEY_NUM + i;
@@ -325,6 +374,12 @@ static void pxa27x_keypad_scan_direct(st
 			input_report_key(input_dev, keypad->keycodes[code],
 					 new_state & (1 << i));
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	input_sync(input_dev);
 	keypad->direct_key_state = new_state;
diff -u -p a/input/keyboard/twl4030_keypad.c b/input/keyboard/twl4030_keypad.c
--- a/input/keyboard/twl4030_keypad.c
+++ b/input/keyboard/twl4030_keypad.c
@@ -191,6 +191,11 @@ static bool twl4030_is_in_ghost_state(st
 	int i;
 	u16 check = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < kp->n_rows; i++) {
 		u16 col = key_state[i];
 
@@ -198,6 +203,12 @@ static bool twl4030_is_in_ghost_state(st
 			return true;
 
 		check |= col;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return false;
@@ -223,6 +234,11 @@ static void twl4030_kp_scan(struct twl40
 	}
 
 	/* check for changes and print those */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (row = 0; row < kp->n_rows; row++) {
 		int changed = new_state[row] ^ kp->kp_state[row];
 
@@ -230,6 +246,11 @@ static void twl4030_kp_scan(struct twl40
 			continue;
 
 		/* Extra column handles "all gnd" rows */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (col = 0; col < kp->n_cols + 1; col++) {
 			int code;
 
@@ -244,8 +265,20 @@ static void twl4030_kp_scan(struct twl40
 			input_event(input, EV_MSC, MSC_SCAN, code);
 			input_report_key(input, kp->keymap[code],
 					 new_state[row] & (1 << col));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		kp->kp_state[row] = new_state[row];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	input_sync(input);
 }
diff -u -p a/input/keyboard/adp5588-keys.c b/input/keyboard/adp5588-keys.c
--- a/input/keyboard/adp5588-keys.c
+++ b/input/keyboard/adp5588-keys.c
@@ -206,10 +206,21 @@ static int __devinit adp5588_gpio_add(st
 		return error;
 	}
 
-	for (i = 0; i <= ADP5588_BANK(ADP5588_MAXGPIO); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i <= ADP5588_BANK(ADP5588_MAXGPIO); i++) {
 		kpad->dat_out[i] = adp5588_read(kpad->client,
 						GPIO_DAT_OUT1 + i);
 		kpad->dir[i] = adp5588_read(kpad->client, GPIO_DIR1 + i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (gpio_data->setup) {
@@ -260,6 +271,11 @@ static void adp5588_report_events(struct
 {
 	int i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ev_cnt; i++) {
 		int key = adp5588_read(kpad->client, Key_EVENTA + i);
 		int key_val = key & KEY_EV_MASK;
@@ -278,6 +294,12 @@ static void adp5588_report_events(struct
 					 kpad->keycode[key_val - 1],
 					 key & KEY_EV_PRESSED);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -338,6 +360,11 @@ static int __devinit adp5588_setup(struc
 	for (i = 0; i < KEYP_MAX_EVENT; i++)
 		ret |= adp5588_read(client, Key_EVENTA);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->gpimapsize; i++) {
 		unsigned short pin = pdata->gpimap[i].pin;
 
@@ -347,6 +374,12 @@ static int __devinit adp5588_setup(struc
 			evt_mode2 |= ((1 << (pin - GPI_PIN_COL_BASE)) & 0xFF);
 			evt_mode3 |= ((1 << (pin - GPI_PIN_COL_BASE)) >> 8);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (pdata->gpimapsize) {
@@ -356,11 +389,22 @@ static int __devinit adp5588_setup(struc
 	}
 
 	if (gpio_data) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i <= ADP5588_BANK(ADP5588_MAXGPIO); i++) {
 			int pull_mask = gpio_data->pullup_dis_mask;
 
 			ret |= adp5588_write(client, GPIO_PULL1 + i,
 				(pull_mask >> (8 * i)) & 0xFF);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -389,6 +433,11 @@ static void __devinit adp5588_report_swi
 	int gpi_stat_tmp, pin_loc;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < kpad->gpimapsize; i++) {
 		unsigned short pin = kpad->gpimap[i].pin;
 
@@ -413,6 +462,12 @@ static void __devinit adp5588_report_swi
 		input_report_switch(kpad->input,
 				    kpad->gpimap[i].sw_evt,
 				    !(gpi_stat_tmp & (1 << pin_loc)));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_sync(kpad->input);
@@ -460,6 +515,11 @@ static int __devinit adp5588_probe(struc
 		return -EINVAL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->gpimapsize; i++) {
 		unsigned short pin = pdata->gpimap[i].pin;
 
@@ -479,6 +539,12 @@ static int __devinit adp5588_probe(struc
 				return -EINVAL;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!client->irq) {
diff -u -p a/input/keyboard/atkbd.c b/input/keyboard/atkbd.c
--- a/input/keyboard/atkbd.c
+++ b/input/keyboard/atkbd.c
@@ -980,6 +980,11 @@ static void atkbd_set_keycode_table(stru
 	bitmap_zero(atkbd->force_release_mask, ATKBD_KEYMAP_SIZE);
 
 	if (atkbd->translated) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 128; i++) {
 			scancode = atkbd_unxlate_table[i];
 			atkbd->keycode[i] = atkbd_set2_keycode[scancode];
@@ -988,16 +993,34 @@ static void atkbd_set_keycode_table(stru
 				for (j = 0; j < ARRAY_SIZE(atkbd_scroll_keys); j++)
 					if ((scancode | 0x80) == atkbd_scroll_keys[j].set2)
 						atkbd->keycode[i | 0x80] = atkbd_scroll_keys[j].keycode;
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
 		}
 	} else if (atkbd->set == 3) {
 		memcpy(atkbd->keycode, atkbd_set3_keycode, sizeof(atkbd->keycode));
 	} else {
 		memcpy(atkbd->keycode, atkbd_set2_keycode, sizeof(atkbd->keycode));
 
-		if (atkbd->scroll)
-			for (i = 0; i < ARRAY_SIZE(atkbd_scroll_keys); i++) {
-				scancode = atkbd_scroll_keys[i].set2;
-				atkbd->keycode[scancode] = atkbd_scroll_keys[i].keycode;
+		if (atkbd->scroll) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (i = 0; i < ARRAY_SIZE(atkbd_scroll_keys); i++) {
+					scancode = atkbd_scroll_keys[i].set2;
+					atkbd->keycode[scancode] = atkbd_scroll_keys[i].keycode;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 		}
 	}
 
@@ -1084,12 +1107,23 @@ static void atkbd_set_device_attrs(struc
 	input_dev->keycodesize = sizeof(unsigned short);
 	input_dev->keycodemax = ARRAY_SIZE(atkbd_set2_keycode);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ATKBD_KEYMAP_SIZE; i++) {
 		if (atkbd->keycode[i] != KEY_RESERVED &&
 		    atkbd->keycode[i] != ATKBD_KEY_NULL &&
 		    atkbd->keycode[i] < ATKBD_SPECIAL) {
 			__set_bit(atkbd->keycode[i], input_dev->keybit);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/input/keyboard/nomadik-ske-keypad.c b/input/keyboard/nomadik-ske-keypad.c
--- a/input/keyboard/nomadik-ske-keypad.c
+++ b/input/keyboard/nomadik-ske-keypad.c
@@ -148,6 +148,11 @@ static void ske_keypad_read_data(struct
 	 * lower byte contains row value for column 2*x,
 	 * upper byte contains row value for column 2*x + 1
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < SKE_NUM_ASRX_REGISTERS; i++) {
 		ske_asr = readl(keypad->reg_base + SKE_ASR0 + (4 * i));
 		if (!ske_asr)
@@ -172,6 +177,12 @@ static void ske_keypad_read_data(struct
 		input_event(input, EV_MSC, MSC_SCAN, code);
 		input_report_key(input, keypad->keymap[code], key_pressed);
 		input_sync(input);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/input/keyboard/tc3589x-keypad.c b/input/keyboard/tc3589x-keypad.c
--- a/input/keyboard/tc3589x-keypad.c
+++ b/input/keyboard/tc3589x-keypad.c
@@ -176,7 +176,12 @@ static irqreturn_t tc3589x_keypad_irq(in
 	u8 i, row_index, col_index, kbd_code, up;
 	u8 code;
 
-	for (i = 0; i < TC35893_DATA_REGS * 2; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (i = 0; i < TC35893_DATA_REGS * 2; i++) {
 		kbd_code = tc3589x_reg_read(tc3589x, TC3589x_EVTCODE_FIFO);
 
 		/* loop till fifo is empty and no more keys are pressed */
@@ -194,6 +199,12 @@ static irqreturn_t tc3589x_keypad_irq(in
 		input_event(keypad->input, EV_MSC, MSC_SCAN, code);
 		input_report_key(keypad->input, keypad->keymap[code], !up);
 		input_sync(keypad->input);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* clear IRQ */
diff -u -p a/input/keyboard/samsung-keypad.c b/input/keyboard/samsung-keypad.c
--- a/input/keyboard/samsung-keypad.c
+++ b/input/keyboard/samsung-keypad.c
@@ -91,6 +91,11 @@ static void samsung_keypad_scan(struct s
 	unsigned int col;
 	unsigned int val;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = 0; col < keypad->cols; col++) {
 		if (samsung_keypad_is_s5pv210(dev)) {
 			val = S5PV210_KEYIFCOLEN_MASK;
@@ -105,6 +110,12 @@ static void samsung_keypad_scan(struct s
 
 		val = readl(keypad->base + SAMSUNG_KEYIFROW);
 		row_state[col] = ~val & ((1 << keypad->rows) - 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* KEYIFCOL reg clear */
@@ -121,12 +132,22 @@ static bool samsung_keypad_report(struct
 	unsigned int val;
 	unsigned int col, row;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = 0; col < keypad->cols; col++) {
 		changed = row_state[col] ^ keypad->row_state[col];
 		key_down |= row_state[col];
 		if (!changed)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (row = 0; row < keypad->rows; row++) {
 			if (!(changed & (1 << row)))
 				continue;
@@ -142,8 +163,20 @@ static bool samsung_keypad_report(struct
 			input_event(input_dev, EV_MSC, MSC_SCAN, val);
 			input_report_key(input_dev,
 					keypad->keycodes[val], pressed);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		input_sync(keypad->input_dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	memcpy(keypad->row_state, row_state, sizeof(keypad->row_state));
diff -u -p a/input/keyboard/max7359_keypad.c b/input/keyboard/max7359_keypad.c
--- a/input/keyboard/max7359_keypad.c
+++ b/input/keyboard/max7359_keypad.c
@@ -90,6 +90,11 @@ static void max7359_build_keycode(struct
 	struct input_dev *input_dev = keypad->input_dev;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < keymap_data->keymap_size; i++) {
 		unsigned int key = keymap_data->keymap[i];
 		unsigned int row = KEY_ROW(key);
@@ -100,6 +105,12 @@ static void max7359_build_keycode(struct
 
 		keypad->keycodes[scancode] = keycode;
 		__set_bit(keycode, input_dev->keybit);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	__clear_bit(KEY_RESERVED, input_dev->keybit);
 }
diff -u -p a/input/keyboard/mcs_touchkey.c b/input/keyboard/mcs_touchkey.c
--- a/input/keyboard/mcs_touchkey.c
+++ b/input/keyboard/mcs_touchkey.c
@@ -158,12 +158,23 @@ static int __devinit mcs_touchkey_probe(
 	input_dev->keycodesize = sizeof(data->keycodes[0]);
 	input_dev->keycodemax = pdata->key_maxval + 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->keymap_size; i++) {
 		unsigned int val = MCS_KEY_VAL(pdata->keymap[i]);
 		unsigned int code = MCS_KEY_CODE(pdata->keymap[i]);
 
 		data->keycodes[val] = code;
 		__set_bit(code, input_dev->keybit);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
diff -u -p a/input/keyboard/amikbd.c b/input/keyboard/amikbd.c
--- a/input/keyboard/amikbd.c
+++ b/input/keyboard/amikbd.c
@@ -207,21 +207,54 @@ static int __init amikbd_probe(struct pl
 	for (i = 0; i < 0x78; i++)
 		set_bit(i, dev->keybit);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_NR_KEYMAPS; i++) {
 		static u_short temp_map[NR_KEYS] __initdata;
 		if (!key_maps[i])
 			continue;
 		memset(temp_map, 0, sizeof(temp_map));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 0x78; j++) {
 			if (!amikbd_keycode[j])
 				continue;
 			temp_map[j] = key_maps[i][amikbd_keycode[j]];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < NR_KEYS; j++) {
 			if (!temp_map[j])
 				temp_map[j] = 0xf200;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		memcpy(key_maps[i], temp_map, sizeof(temp_map));
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	ciaa.cra &= ~0x41;	 /* serial data in, turn off TA */
 	err = request_irq(IRQ_AMIGA_CIAA_SP, amikbd_interrupt, 0, "amikbd",
diff -u -p a/input/keyboard/imx_keypad.c b/input/keyboard/imx_keypad.c
--- a/input/keyboard/imx_keypad.c
+++ b/input/keyboard/imx_keypad.c
@@ -87,6 +87,11 @@ static void imx_keypad_scan_matrix(struc
 	int col;
 	unsigned short reg_val;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {
 		if ((keypad->cols_en_mask & (1 << col)) == 0)
 			continue;
@@ -131,6 +136,12 @@ static void imx_keypad_scan_matrix(struc
 		 */
 		reg_val = readw(keypad->mmio_base + KPDR);
 		matrix_volatile_state[col] = (~reg_val) & keypad->rows_en_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -152,6 +163,11 @@ static void imx_keypad_fire_events(struc
 	struct input_dev *input_dev = keypad->input_dev;
 	int row, col;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {
 		unsigned short bits_changed;
 		int code;
@@ -165,6 +181,11 @@ static void imx_keypad_fire_events(struc
 		if (bits_changed == 0)
 			continue; /* Column does not contain changes */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (row = 0; row < MAX_MATRIX_KEY_ROWS; row++) {
 			if ((keypad->rows_en_mask & (1 << row)) == 0)
 				continue; /* Row is not enabled */
@@ -178,6 +199,18 @@ static void imx_keypad_fire_events(struc
 			dev_dbg(&input_dev->dev, "Event code: %d, val: %d",
 				keypad->keycodes[code],
 				matrix_volatile_state[col] & (1 << row));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 	input_sync(input_dev);
@@ -475,9 +508,20 @@ static int __devinit imx_keypad_probe(st
 	}
 
 	/* Search for rows and cols enabled */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < keymap_data->keymap_size; i++) {
 		keypad->rows_en_mask |= 1 << KEY_ROW(keymap_data->keymap[i]);
 		keypad->cols_en_mask |= 1 << KEY_COL(keymap_data->keymap[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (keypad->rows_en_mask > ((1 << MAX_MATRIX_KEY_ROWS) - 1) ||
diff -u -p a/input/keyboard/opencores-kbd.c b/input/keyboard/opencores-kbd.c
--- a/input/keyboard/opencores-kbd.c
+++ b/input/keyboard/opencores-kbd.c
@@ -99,6 +99,11 @@ static int __devinit opencores_kbd_probe
 
 	__set_bit(EV_KEY, input->evbit);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(opencores_kbd->keycodes); i++) {
 		/*
 		 * OpenCores controller happens to have scancodes match
@@ -106,6 +111,12 @@ static int __devinit opencores_kbd_probe
 		 */
 		opencores_kbd->keycodes[i] = i;
 		__set_bit(opencores_kbd->keycodes[i], input->keybit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	__clear_bit(KEY_RESERVED, input->keybit);
 
diff -u -p a/input/keyboard/adp5589-keys.c b/input/keyboard/adp5589-keys.c
--- a/input/keyboard/adp5589-keys.c
+++ b/input/keyboard/adp5589-keys.c
@@ -532,11 +532,22 @@ static int __devinit adp5589_gpio_add(st
 		return error;
 	}
 
-	for (i = 0; i <= kpad->var->bank(kpad->var->maxgpio); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i <= kpad->var->bank(kpad->var->maxgpio); i++) {
 		kpad->dat_out[i] = adp5589_read(kpad->client, kpad->var->reg(
 						ADP5589_GPO_DATA_OUT_A) + i);
 		kpad->dir[i] = adp5589_read(kpad->client, kpad->var->reg(
 					    ADP5589_GPIO_DIRECTION_A) + i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (gpio_data->setup) {
@@ -602,6 +613,11 @@ static void adp5589_report_events(struct
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ev_cnt; i++) {
 		int key = adp5589_read(kpad->client, ADP5589_5_FIFO_1 + i);
 		int key_val = key & KEY_EV_MASK;
@@ -614,6 +630,12 @@ static void adp5589_report_events(struct
 					 kpad->keycode[key_val - 1],
 					 key & KEY_EV_PRESSED);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -688,6 +710,11 @@ static int __devinit adp5589_setup(struc
 	for (i = 0; i < KEYP_MAX_EVENT; i++)
 		ret |= adp5589_read(client, ADP5589_5_FIFO_1 + i);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->gpimapsize; i++) {
 		unsigned short pin = pdata->gpimap[i].pin;
 
@@ -700,6 +727,12 @@ static int __devinit adp5589_setup(struc
 				evt_mode3 |= ((1 << (pin -
 					kpad->var->gpi_pin_col_base)) >> 8);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (pdata->gpimapsize) {
@@ -717,6 +750,11 @@ static int __devinit adp5589_setup(struc
 		pdata->pullup_en_300k & pdata->pulldown_en_300k)
 		dev_warn(&client->dev, "Conflicting pull resistor config\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= kpad->var->max_row_num; i++) {
 		unsigned val = 0, bit = (1 << i);
 		if (pdata->pullup_en_300k & bit)
@@ -735,8 +773,19 @@ static int __devinit adp5589_setup(struc
 					     + (i >> 2), pull_mask);
 			pull_mask = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= kpad->var->max_col_num; i++) {
 		unsigned val = 0, bit = 1 << (i + kpad->var->col_shift);
 		if (pdata->pullup_en_300k & bit)
@@ -756,6 +805,12 @@ static int __devinit adp5589_setup(struc
 					     (i >> 2), pull_mask);
 			pull_mask = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (pdata->reset1_key_1 && pdata->reset1_key_2 && pdata->reset1_key_3) {
@@ -831,6 +886,11 @@ static void __devinit adp5589_report_swi
 	int gpi_stat3 = !kpad->is_adp5585 ?
 			adp5589_read(kpad->client, ADP5589_GPI_STATUS_C) : 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < kpad->gpimapsize; i++) {
 		unsigned short pin = kpad->gpimap[i].pin;
 
@@ -855,6 +915,12 @@ static void __devinit adp5589_report_swi
 		input_report_switch(kpad->input,
 				    kpad->gpimap[i].sw_evt,
 				    !(gpi_stat_tmp & (1 << pin_loc)));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_sync(kpad->input);
@@ -924,6 +990,11 @@ static int __devinit adp5589_probe(struc
 		goto err_free_mem;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->gpimapsize; i++) {
 		unsigned short pin = pdata->gpimap[i].pin;
 
@@ -940,6 +1011,12 @@ static int __devinit adp5589_probe(struc
 			error = -EINVAL;
 			goto err_free_mem;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!client->irq) {
diff -u -p a/input/keyboard/tegra-kbc.c b/input/keyboard/tegra-kbc.c
--- a/input/keyboard/tegra-kbc.c
+++ b/input/keyboard/tegra-kbc.c
@@ -230,6 +230,11 @@ static void tegra_kbc_report_released_ke
 {
 	unsigned int i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < old_num_keys; i++) {
 		for (j = 0; j < new_num_keys; j++)
 			if (old_keycodes[i] == new_keycodes[j])
@@ -237,6 +242,12 @@ static void tegra_kbc_report_released_ke
 
 		if (j == new_num_keys)
 			input_report_key(input, old_keycodes[i], 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -247,9 +258,20 @@ static void tegra_kbc_report_pressed_key
 {
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_pressed_keys; i++) {
 		input_event(input, EV_MSC, MSC_SCAN, scancodes[i]);
 		input_report_key(input, keycodes[i], 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -264,6 +286,11 @@ static void tegra_kbc_report_keys(struct
 	bool key_in_same_row = false;
 	bool key_in_same_col = false;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < KBC_MAX_KPENT; i++) {
 		if ((i % 4) == 0)
 			val = readl(kbc->mmio + KBC_KP_ENT0_0 + i);
@@ -284,6 +311,12 @@ static void tegra_kbc_report_keys(struct
 		}
 
 		val >>= 8;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/*
@@ -293,6 +326,11 @@ static void tegra_kbc_report_keys(struct
 	 * If so ignore the key presses for this iteration.
 	 */
 	if (kbc->use_ghost_filter && num_down >= 3) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < num_down; i++) {
 			unsigned int j;
 			u8 curr_col = scancodes[i] & 0x07;
@@ -302,6 +340,11 @@ static void tegra_kbc_report_keys(struct
 			 * Find 2 keys such that one key is in the same row
 			 * and the other is in the same column as the i-th key.
 			 */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = i + 1; j < num_down; j++) {
 				u8 col = scancodes[j] & 0x07;
 				u8 row = scancodes[j] >> KBC_ROW_SHIFT;
@@ -310,6 +353,18 @@ static void tegra_kbc_report_keys(struct
 					key_in_same_col = true;
 				if (row == curr_row)
 					key_in_same_row = true;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
 			}
 		}
 	}
@@ -319,9 +374,20 @@ static void tegra_kbc_report_keys(struct
 	 * Function keycodes are KBC_MAX_KEY apart from the plain keycodes.
 	 */
 	if (fn_keypress) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < num_down; i++) {
 			scancodes[i] += KBC_MAX_KEY;
 			keycodes[i] = kbc->keycode[scancodes[i]];
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
@@ -434,6 +500,11 @@ static void tegra_kbc_config_pins(struct
 	const struct tegra_kbc_platform_data *pdata = kbc->pdata;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < KBC_MAX_GPIO; i++) {
 		u32 r_shft = 5 * (i % 6);
 		u32 c_shft = 4 * (i % 8);
@@ -454,6 +525,12 @@ static void tegra_kbc_config_pins(struct
 
 		writel(row_cfg, kbc->mmio + r_offs);
 		writel(col_cfg, kbc->mmio + c_offs);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -552,6 +629,11 @@ tegra_kbc_check_pin_cfg(const struct teg
 
 	*num_rows = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < KBC_MAX_GPIO; i++) {
 		const struct tegra_kbc_pin_cfg *pin_cfg = &pdata->pin_cfg[i];
 
@@ -571,6 +653,12 @@ tegra_kbc_check_pin_cfg(const struct teg
 				return false;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return true;
diff -u -p a/input/keyboard/bf54x-keys.c b/input/keyboard/bf54x-keys.c
--- a/input/keyboard/bf54x-keys.c
+++ b/input/keyboard/bf54x-keys.c
@@ -104,9 +104,20 @@ static inline void bfin_keycodecpy(unsig
 {
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < keymapsize; i++) {
 		keycode[i] = pdata_kc[i] & 0xffff;
 		keycode[i + keymapsize] = pdata_kc[i] >> 16;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/input/keyboard/omap-keypad.c b/input/keyboard/omap-keypad.c
--- a/input/keyboard/omap-keypad.c
+++ b/input/keyboard/omap-keypad.c
@@ -82,9 +82,20 @@ static u8 get_row_gpio_val(struct omap_k
 	int row;
 	u8 value = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (row = 0; row < omap_kp->rows; row++) {
 		if (gpio_get_value(row_gpios[row]))
 			value |= (1 << row);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return value;
 }
@@ -101,6 +112,11 @@ static irqreturn_t omap_kp_interrupt(int
 	if (cpu_is_omap24xx()) {
 		int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < omap_kp->rows; i++) {
 			int gpio_irq = gpio_to_irq(row_gpios[i]);
 			/*
@@ -113,6 +129,12 @@ static irqreturn_t omap_kp_interrupt(int
 				disable_irq_nosync(gpio_irq);
 			else
 				disable_irq(gpio_irq);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	} else
 		/* disable keyboard interrupt and schedule for handling */
@@ -135,9 +157,20 @@ static void omap_kp_scan_keypad(struct o
 	/* read the keypad status */
 	if (cpu_is_omap24xx()) {
 		/* read the keypad status */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (col = 0; col < omap_kp->cols; col++) {
 			set_col_gpio_val(omap_kp, ~(1 << col));
 			state[col] = ~(get_row_gpio_val(omap_kp)) & 0xff;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		set_col_gpio_val(omap_kp, 0);
 
@@ -147,7 +180,12 @@ static void omap_kp_scan_keypad(struct o
 
 		/* read the keypad status */
 		omap_writew(0xff, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBC);
-		for (col = 0; col < omap_kp->cols; col++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (col = 0; col < omap_kp->cols; col++) {
 			omap_writew(~(1 << col) & 0xff,
 				    OMAP1_MPUIO_BASE + OMAP_MPUIO_KBC);
 
@@ -155,6 +193,12 @@ static void omap_kp_scan_keypad(struct o
 
 			state[col] = ~omap_readw(OMAP1_MPUIO_BASE +
 						 OMAP_MPUIO_KBR_LATCH) & 0xff;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		omap_writew(0x00, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBC);
 		udelay(2);
@@ -174,12 +218,22 @@ static void omap_kp_tasklet(unsigned lon
 	omap_kp_scan_keypad(omap_kp_data, new_state);
 
 	/* check for changes and print those */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = 0; col < omap_kp_data->cols; col++) {
 		changed = new_state[col] ^ keypad_state[col];
 		key_down |= new_state[col];
 		if (changed == 0)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (row = 0; row < omap_kp_data->rows; row++) {
 			int key;
 			if (!(changed & (1 << row)))
@@ -207,7 +261,19 @@ static void omap_kp_tasklet(unsigned lon
 			input_report_key(omap_kp_data->input, key & ~GROUP_MASK,
 					 new_state[col] & (1 << row));
 #endif
+if (_cur < timeout) {
+			rdstcll(_cur);
+}
+else {
+			break;
+}
 		}
+		if (_cur < timeout) {
+rdstcll(_cur);
+                }
+                else {
+			break;
+                }
 	}
 	input_sync(omap_kp_data->input);
 	memcpy(keypad_state, new_state, sizeof(keypad_state));
@@ -336,7 +402,12 @@ static int __devinit omap_kp_probe(struc
 
 	if (cpu_is_omap24xx()) {
 		/* Cols: outputs */
-		for (col_idx = 0; col_idx < omap_kp->cols; col_idx++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (col_idx = 0; col_idx < omap_kp->cols; col_idx++) {
 			if (gpio_request(col_gpios[col_idx], "omap_kp_col") < 0) {
 				printk(KERN_ERR "Failed to request"
 				       "GPIO%d for keypad\n",
@@ -344,9 +415,20 @@ static int __devinit omap_kp_probe(struc
 				goto err1;
 			}
 			gpio_direction_output(col_gpios[col_idx], 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* Rows: inputs */
-		for (row_idx = 0; row_idx < omap_kp->rows; row_idx++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (row_idx = 0; row_idx < omap_kp->rows; row_idx++) {
 			if (gpio_request(row_gpios[row_idx], "omap_kp_row") < 0) {
 				printk(KERN_ERR "Failed to request"
 				       "GPIO%d for keypad\n",
@@ -354,6 +436,12 @@ static int __devinit omap_kp_probe(struc
 				goto err2;
 			}
 			gpio_direction_input(row_gpios[row_idx]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		col_idx = 0;
@@ -403,12 +491,23 @@ static int __devinit omap_kp_probe(struc
 		}
 		omap_writew(0, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);
 	} else {
-		for (irq_idx = 0; irq_idx < omap_kp->rows; irq_idx++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				for (irq_idx = 0; irq_idx < omap_kp->rows; irq_idx++) {
 			if (request_irq(gpio_to_irq(row_gpios[irq_idx]),
 					omap_kp_interrupt,
 					IRQF_TRIGGER_FALLING,
 					"omap-keypad", omap_kp) < 0)
 				goto err5;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 	}
 	return 0;
@@ -443,9 +542,20 @@ static int __devexit omap_kp_remove(stru
 		int i;
 		for (i = 0; i < omap_kp->cols; i++)
 			gpio_free(col_gpios[i]);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < omap_kp->rows; i++) {
 			gpio_free(row_gpios[i]);
 			free_irq(gpio_to_irq(row_gpios[i]), omap_kp);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		omap_writew(1, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);
diff -u -p a/input/keyboard/tnetv107x-keypad.c b/input/keyboard/tnetv107x-keypad.c
--- a/input/keyboard/tnetv107x-keypad.c
+++ b/input/keyboard/tnetv107x-keypad.c
@@ -83,6 +83,11 @@ static irqreturn_t keypad_irq(int irq, v
 		for (i = 0; i < 3; i++)
 			curr_keys[i] = keypad_read(kp, pres[i]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		change = curr_keys[i] ^ kp->prev_keys[i];
 
@@ -99,6 +104,12 @@ static irqreturn_t keypad_irq(int irq, v
 			input_report_key(kp->input_dev, kp->keycodes[code],
 					 val);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	input_sync(kp->input_dev);
 	memcpy(kp->prev_keys, curr_keys, sizeof(curr_keys));
diff -u -p a/input/keyboard/locomokbd.c b/input/keyboard/locomokbd.c
--- a/input/keyboard/locomokbd.c
+++ b/input/keyboard/locomokbd.c
@@ -136,12 +136,22 @@ static void locomokbd_scankeyboard(struc
 	locomokbd_charge_all(membase);
 
 	num_pressed = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = 0; col < KB_COLS; col++) {
 
 		locomokbd_activate_col(membase, col);
 		udelay(KB_DELAY);
 
 		rowd = ~locomo_readl(membase + LOCOMO_KIB);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (row = 0; row < KB_ROWS; row++) {
 			unsigned int scancode, pressed, key;
 
@@ -170,8 +180,20 @@ static void locomokbd_scankeyboard(struc
 				locomokbd->suspend_jiffies = jiffies;
 			} else
 				locomokbd->count_cancel = 0;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		locomokbd_reset_col(membase, col);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	locomokbd_activate_all(membase);
 
diff -u -p a/input/keyboard/omap4-keypad.c b/input/keyboard/omap4-keypad.c
--- a/input/keyboard/omap4-keypad.c
+++ b/input/keyboard/omap4-keypad.c
@@ -98,11 +98,21 @@ static irqreturn_t omap4_keypad_interrup
 	*(new_state + 1) = __raw_readl(keypad_data->base
 						+ OMAP4_KBD_FULLCODE63_32);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (row = 0; row < keypad_data->rows; row++) {
 		changed = key_state[row] ^ keypad_data->key_state[row];
 		if (!changed)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (col = 0; col < keypad_data->cols; col++) {
 			if (changed & (1 << col)) {
 				code = MATRIX_SCAN_CODE(row, col,
@@ -112,6 +122,18 @@ static irqreturn_t omap4_keypad_interrup
 						 keypad_data->keymap[code],
 						 key_state[row] & (1 << col));
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
diff -u -p a/input/keyboard/maple_keyb.c b/input/keyboard/maple_keyb.c
--- a/input/keyboard/maple_keyb.c
+++ b/input/keyboard/maple_keyb.c
@@ -99,13 +99,29 @@ static void dc_scan_kbd(struct dc_kbd *k
 	int code, keycode;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		code = i + 224;
 		keycode = kbd->keycode[code];
 		input_event(dev, EV_MSC, MSC_SCAN, code);
 		input_report_key(dev, keycode, (kbd->new[0] >> i) & 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 2; i < 8; i++) {
 		ptr = memchr(kbd->new + 2, kbd->old[i], 6);
 		code = kbd->old[i];
@@ -131,6 +147,12 @@ static void dc_scan_kbd(struct dc_kbd *k
 					"Unknown key (scancode %#x) pressed.",
 					code);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	input_sync(dev);
 	memcpy(kbd->old, kbd->new, 8);
diff -u -p a/input/keyboard/tca6416-keypad.c b/input/keyboard/tca6416-keypad.c
--- a/input/keyboard/tca6416-keypad.c
+++ b/input/keyboard/tca6416-keypad.c
@@ -104,6 +104,11 @@ static void tca6416_keys_scan(struct tca
 	val = reg_val ^ chip->reg_input;
 	chip->reg_input = reg_val;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, pin_index = 0; i < 16; i++) {
 		if (val & (1 << i)) {
 			struct tca6416_button *button = &chip->buttons[pin_index];
@@ -117,6 +122,12 @@ static void tca6416_keys_scan(struct tca
 
 		if (chip->pinmask & (1 << i))
 			pin_index++;
+			if (_cur < timeout) {
+						rdstcll(_cur);
+			}
+			else {
+						break;
+			}
 	}
 }
 
@@ -252,12 +263,23 @@ static int __devinit tca6416_keypad_prob
 	if (pdata->rep)
 		__set_bit(EV_REP, input->evbit);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->nbuttons; i++) {
 		unsigned int type;
 
 		chip->buttons[i] = pdata->buttons[i];
 		type = (pdata->buttons[i].type) ?: EV_KEY;
 		input_set_capability(input, type, pdata->buttons[i].code);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_set_drvdata(input, chip);
diff -u -p a/input/input-mt.c b/input/input-mt.c
--- a/input/input-mt.c
+++ b/input/input-mt.c
@@ -140,6 +140,11 @@ void input_mt_report_pointer_emulation(s
 	int count = 0;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dev->mtsize; ++i) {
 		struct input_mt_slot *ps = &dev->mt[i];
 		int id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);
@@ -151,6 +156,12 @@ void input_mt_report_pointer_emulation(s
 			oldid = id;
 		}
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_event(dev, EV_KEY, BTN_TOUCH, count > 0);
diff -u -p a/input/misc/cobalt_btns.c b/input/misc/cobalt_btns.c
--- a/input/misc/cobalt_btns.c
+++ b/input/misc/cobalt_btns.c
@@ -55,6 +55,11 @@ static void handle_buttons(struct input_
 
 	status = ~readl(bdev->reg) >> 24;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(bdev->keymap); i++) {
 		if (status & (1U << i)) {
 			if (++bdev->count[i] == BUTTONS_COUNT_THRESHOLD) {
@@ -70,6 +75,12 @@ static void handle_buttons(struct input_
 			}
 			bdev->count[i] = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/input/misc/wistron_btns.c b/input/misc/wistron_btns.c
--- a/input/misc/wistron_btns.c
+++ b/input/misc/wistron_btns.c
@@ -94,10 +94,21 @@ static ssize_t __init locate_wistron_bio
 		{ 0x42, 0x21, 0x55, 0x30 };
 	ssize_t offset;
 
-	for (offset = 0; offset < 0x10000; offset += 0x10) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (offset = 0; offset < 0x10000; offset += 0x10) {
 		if (check_signature(base + offset, signature,
 				    sizeof(signature)) != 0)
 			return offset;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	return -1;
 }
@@ -243,11 +254,22 @@ static int __init dmi_matched(const stru
 	const struct key_entry *key;
 
 	keymap = dmi->driver_data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (key = keymap; key->type != KE_END; key++) {
 		if (key->type == KE_WIFI)
 			have_wifi = true;
 		else if (key->type == KE_BLUETOOTH)
 			have_bluetooth = true;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	leds_present = key->code & (FE_MAIL_LED | FE_WIFI_LED);
 
diff -u -p a/input/misc/ati_remote2.c b/input/misc/ati_remote2.c
--- a/input/misc/ati_remote2.c
+++ b/input/misc/ati_remote2.c
@@ -558,10 +558,32 @@ static int ati_remote2_setkeycode(struct
 	ar2->keycode[mode][offset] = ke->keycode;
 	__set_bit(ke->keycode, idev->keybit);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mode = 0; mode < ATI_REMOTE2_MODES; mode++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (index = 0; index < ARRAY_SIZE(ati_remote2_key_table); index++) {
 			if (ar2->keycode[mode][index] == *old_keycode)
 				return 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}
 
@@ -587,10 +609,32 @@ static int ati_remote2_input_init(struct
 		BIT_MASK(BTN_RIGHT);
 	idev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mode = 0; mode < ATI_REMOTE2_MODES; mode++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (index = 0; index < ARRAY_SIZE(ati_remote2_key_table); index++) {
 			ar2->keycode[mode][index] = ati_remote2_key_table[index].keycode;
 			__set_bit(ar2->keycode[mode][index], idev->keybit);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -634,6 +678,11 @@ static int ati_remote2_urb_init(struct a
 	struct usb_device *udev = ar2->udev;
 	int i, pipe, maxp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		ar2->buf[i] = usb_alloc_coherent(udev, 4, GFP_KERNEL, &ar2->buf_dma[i]);
 		if (!ar2->buf[i])
@@ -652,6 +701,12 @@ static int ati_remote2_urb_init(struct a
 				 ar2, ar2->ep[i]->bInterval);
 		ar2->urb[i]->transfer_dma = ar2->buf_dma[i];
 		ar2->urb[i]->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
@@ -661,9 +716,20 @@ static void ati_remote2_urb_cleanup(stru
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		usb_free_urb(ar2->urb[i]);
 		usb_free_coherent(ar2->udev, 4, ar2->buf[i], ar2->buf_dma[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/input/misc/xen-kbdfront.c b/input/misc/xen-kbdfront.c
--- a/input/misc/xen-kbdfront.c
+++ b/input/misc/xen-kbdfront.c
@@ -59,6 +59,11 @@ static irqreturn_t input_handler(int rq,
 	if (prod == page->in_cons)
 		return IRQ_HANDLED;
 	rmb();			/* ensure we see ring contents up to prod */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cons = page->in_cons; cons != prod; cons++) {
 		union xenkbd_in_event *event;
 		struct input_dev *dev;
@@ -96,6 +101,12 @@ static irqreturn_t input_handler(int rq,
 		}
 		if (dev)
 			input_sync(dev);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	mb();			/* ensure we got ring contents */
 	page->in_cons = cons;
diff -u -p a/input/misc/sgi_btns.c b/input/misc/sgi_btns.c
--- a/input/misc/sgi_btns.c
+++ b/input/misc/sgi_btns.c
@@ -73,6 +73,11 @@ static void handle_buttons(struct input_
 
 	status = button_status();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(bdev->keymap); i++) {
 		if (status & (1U << i)) {
 			if (++bdev->count[i] == BUTTONS_COUNT_THRESHOLD) {
@@ -88,6 +93,12 @@ static void handle_buttons(struct input_
 			}
 			bdev->count[i] = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/input/misc/yealink.c b/input/misc/yealink.c
--- a/input/misc/yealink.c
+++ b/input/misc/yealink.c
@@ -164,6 +164,11 @@ static int setChar(struct yealink_dev *y
 	}
 
 	val = map_to_seg7(&map_seg7, chr);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(lcdMap[0].u.s); i++) {
 		m = lcdMap[el].u.s[i].m;
 
@@ -176,6 +181,12 @@ static int setChar(struct yealink_dev *y
 		else
 			yld->master.b[a] &= ~m;
 		val = val >> 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 };
@@ -396,12 +407,23 @@ send_update:
 		yld->ctl_data->offset	= cpu_to_be16(ix);
 		yld->ctl_data->size	= len;
 		yld->ctl_data->sum	= -CMD_LCD - ix - val - len;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(i=1; i<len; i++) {
 			ix++;
 			val = yld->master.b[ix];
 			yld->copy.b[ix]		= val;
 			yld->ctl_data->data[i]	= val;
 			yld->ctl_data->sum     -= val;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 	}
 	yld->stat_ix = ix + 1;
@@ -692,12 +714,23 @@ static ssize_t get_icons(struct device *
 		return -ENODEV;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(lcdMap); i++) {
 		if (lcdMap[i].type != '.')
 			continue;
 		ret += sprintf(&buf[ret], "%s %s\n",
 				yld->lcdMap[i] == ' ' ? "  " : "on",
 				lcdMap[i].u.p.name);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	up_read(&sysfs_rwsema);
 	return ret;
@@ -953,6 +986,11 @@ static int usb_probe(struct usb_interfac
 
 	/* register available key events */
 	input_dev->evbit[0] = BIT_MASK(EV_KEY);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 256; i++) {
 		int k = map_p1k_to_key(i);
 		if (k >= 0) {
@@ -960,6 +998,12 @@ static int usb_probe(struct usb_interfac
 			if (k >> 8)
 				set_bit(k >> 8, input_dev->keybit);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	ret = input_register_device(yld->idev);
diff -u -p a/input/misc/uinput.c b/input/misc/uinput.c
--- a/input/misc/uinput.c
+++ b/input/misc/uinput.c
@@ -137,12 +137,23 @@ static void uinput_flush_requests(struct
 
 	spin_lock(&udev->requests_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < UINPUT_NUM_REQUESTS; i++) {
 		request = udev->requests[i];
 		if (request) {
 			request->retval = -ENODEV;
 			uinput_request_done(udev, request);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock(&udev->requests_lock);
@@ -390,11 +401,22 @@ static int uinput_setup_device(struct ui
 	dev->id.product	= user_dev->id.product;
 	dev->id.version	= user_dev->id.version;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ABS_CNT; i++) {
 		input_abs_set_max(dev, i, user_dev->absmax[i]);
 		input_abs_set_min(dev, i, user_dev->absmin[i]);
 		input_abs_set_fuzz(dev, i, user_dev->absfuzz[i]);
 		input_abs_set_flat(dev, i, user_dev->absflat[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* check if absmin/absmax/absfuzz/absflat are filled as
diff -u -p a/input/misc/apanel.c b/input/misc/apanel.c
--- a/input/misc/apanel.c
+++ b/input/misc/apanel.c
@@ -258,10 +258,21 @@ static __init const void __iomem *bios_s
 	ssize_t offset;
 	const unsigned char signature[] = "FJKEYINF";
 
-	for (offset = 0; offset < 0x10000; offset += 0x10) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (offset = 0; offset < 0x10000; offset += 0x10) {
 		if (check_signature(bios + offset, signature,
 				    sizeof(signature)-1))
 			return bios + offset;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	pr_notice(APANEL ": Fujitsu BIOS signature '%s' not found...\n",
 		  signature);
diff -u -p a/input/misc/pcf8574_keypad.c b/input/misc/pcf8574_keypad.c
--- a/input/misc/pcf8574_keypad.c
+++ b/input/misc/pcf8574_keypad.c
@@ -112,9 +112,20 @@ static int __devinit pcf8574_kp_probe(st
 	idev->keycodesize = sizeof(lp->btncode[0]);
 	idev->keycodemax = ARRAY_SIZE(lp->btncode);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(pcf8574_kp_btncode); i++) {
 		lp->btncode[i] = pcf8574_kp_btncode[i];
 		__set_bit(lp->btncode[i] & KEY_MAX, idev->keybit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sprintf(lp->name, DRV_NAME);
diff -u -p a/input/misc/ad714x.c b/input/misc/ad714x.c
--- a/input/misc/ad714x.c
+++ b/input/misc/ad714x.c
@@ -166,11 +166,22 @@ static int ad714x_cal_highest_stage(stru
 	int max_idx = 0;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start_stage; i <= end_stage; i++) {
 		if (ad714x->sensor_val[i] > max_res) {
 			max_res = ad714x->sensor_val[i];
 			max_idx = i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return max_idx;
@@ -256,12 +267,23 @@ static void ad714x_slider_cal_sensor_val
 			&ad714x->adc_reg[hw->start_stage],
 			hw->end_stage - hw->start_stage + 1);
 
-	for (i = hw->start_stage; i <= hw->end_stage; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = hw->start_stage; i <= hw->end_stage; i++) {
 		ad714x->read(ad714x, STAGE0_AMBIENT + i * PER_STAGE_REG_NUM,
 				&ad714x->amb_reg[i], 1);
 
 		ad714x->sensor_val[i] =
 			abs(ad714x->adc_reg[i] - ad714x->amb_reg[i]);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 }
 
@@ -428,7 +450,12 @@ static void ad714x_wheel_cal_sensor_val(
 			&ad714x->adc_reg[hw->start_stage],
 			hw->end_stage - hw->start_stage + 1);
 
-	for (i = hw->start_stage; i <= hw->end_stage; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = hw->start_stage; i <= hw->end_stage; i++) {
 		ad714x->read(ad714x, STAGE0_AMBIENT + i * PER_STAGE_REG_NUM,
 				&ad714x->amb_reg[i], 1);
 		if (ad714x->adc_reg[i] > ad714x->amb_reg[i])
@@ -436,6 +463,12 @@ static void ad714x_wheel_cal_sensor_val(
 				ad714x->adc_reg[i] - ad714x->amb_reg[i];
 		else
 			ad714x->sensor_val[i] = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -582,7 +615,12 @@ static void touchpad_cal_sensor_val(stru
 			&ad714x->adc_reg[hw->x_start_stage],
 			hw->x_end_stage - hw->x_start_stage + 1);
 
-	for (i = hw->x_start_stage; i <= hw->x_end_stage; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = hw->x_start_stage; i <= hw->x_end_stage; i++) {
 		ad714x->read(ad714x, STAGE0_AMBIENT + i * PER_STAGE_REG_NUM,
 				&ad714x->amb_reg[i], 1);
 		if (ad714x->adc_reg[i] > ad714x->amb_reg[i])
@@ -590,6 +628,12 @@ static void touchpad_cal_sensor_val(stru
 				ad714x->adc_reg[i] - ad714x->amb_reg[i];
 		else
 			ad714x->sensor_val[i] = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -620,28 +664,72 @@ static int touchpad_check_second_peak(st
 	struct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = hw->x_start_stage; i < sw->x_highest_stage; i++) {
 		if ((ad714x->sensor_val[i] - ad714x->sensor_val[i + 1])
 			> (ad714x->sensor_val[i + 1] / 10))
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = sw->x_highest_stage; i < hw->x_end_stage; i++) {
 		if ((ad714x->sensor_val[i + 1] - ad714x->sensor_val[i])
 			> (ad714x->sensor_val[i] / 10))
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = hw->y_start_stage; i < sw->y_highest_stage; i++) {
 		if ((ad714x->sensor_val[i] - ad714x->sensor_val[i + 1])
 			> (ad714x->sensor_val[i + 1] / 10))
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = sw->y_highest_stage; i < hw->y_end_stage; i++) {
 		if ((ad714x->sensor_val[i + 1] - ad714x->sensor_val[i])
 			> (ad714x->sensor_val[i] / 10))
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -919,11 +1007,22 @@ static void ad714x_hw_init(struct ad714x
 
 	/* configuration CDC and interrupts */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < STAGE_NUM; i++) {
 		reg_base = AD714X_STAGECFG_REG + i * STAGE_CFGREG_NUM;
 		for (j = 0; j < STAGE_CFGREG_NUM; j++)
 			ad714x->write(ad714x, reg_base + j,
 					ad714x->hw->stage_cfg_reg[i][j]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i < SYS_CFGREG_NUM; i++)
@@ -1038,6 +1137,11 @@ struct ad714x_chip *ad714x_probe(struct
 	if (ad714x->hw->slider_num > 0) {
 		struct ad714x_slider_plat *sd_plat = ad714x->hw->slider;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ad714x->hw->slider_num; i++) {
 			sd_drv[i].input = input[alloc_idx] = input_allocate_device();
 			if (!input[alloc_idx]) {
@@ -1063,6 +1167,12 @@ struct ad714x_chip *ad714x_probe(struct
 				goto err_free_dev;
 
 			alloc_idx++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1070,6 +1180,11 @@ struct ad714x_chip *ad714x_probe(struct
 	if (ad714x->hw->wheel_num > 0) {
 		struct ad714x_wheel_plat *wl_plat = ad714x->hw->wheel;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ad714x->hw->wheel_num; i++) {
 			wl_drv[i].input = input[alloc_idx] = input_allocate_device();
 			if (!input[alloc_idx]) {
@@ -1095,6 +1210,12 @@ struct ad714x_chip *ad714x_probe(struct
 				goto err_free_dev;
 
 			alloc_idx++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1102,6 +1223,11 @@ struct ad714x_chip *ad714x_probe(struct
 	if (ad714x->hw->touchpad_num > 0) {
 		struct ad714x_touchpad_plat *tp_plat = ad714x->hw->touchpad;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ad714x->hw->touchpad_num; i++) {
 			tp_drv[i].input = input[alloc_idx] = input_allocate_device();
 			if (!input[alloc_idx]) {
@@ -1130,6 +1256,12 @@ struct ad714x_chip *ad714x_probe(struct
 				goto err_free_dev;
 
 			alloc_idx++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1144,9 +1276,20 @@ struct ad714x_chip *ad714x_probe(struct
 		}
 
 		__set_bit(EV_KEY, input[alloc_idx]->evbit);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ad714x->hw->button_num; i++) {
 			bt_drv[i].input = input[alloc_idx];
 			__set_bit(bt_plat[i].keycode, input[alloc_idx]->keybit);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		input[alloc_idx]->id.bustype = bus_type;
diff -u -p a/input/misc/keyspan_remote.c b/input/misc/keyspan_remote.c
--- a/input/misc/keyspan_remote.c
+++ b/input/misc/keyspan_remote.c
@@ -219,6 +219,11 @@ static void keyspan_check_data(struct us
 
 		found = 0;
 		while ((remote->data.bits_left >= 14 || remote->data.pos < remote->data.len) && !found) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 8; ++i) {
 				if (keyspan_load_tester(remote, 14) != 0) {
 					remote->stage = 0;
@@ -234,6 +239,12 @@ static void keyspan_check_data(struct us
 					remote->data.tester = remote->data.tester >> 1;
 					--remote->data.bits_left;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
@@ -255,6 +266,11 @@ static void keyspan_check_data(struct us
 		remote->data.len += RECV_SIZE;
 
 		message.system = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 9; i++) {
 			keyspan_load_tester(remote, 6);
 
@@ -271,9 +287,20 @@ static void keyspan_check_data(struct us
 				remote->stage = 0;
 				return;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		message.button = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 5; i++) {
 			keyspan_load_tester(remote, 6);
 
@@ -290,6 +317,12 @@ static void keyspan_check_data(struct us
 				remote->stage = 0;
 				return;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		keyspan_load_tester(remote, 6);
@@ -424,6 +457,11 @@ static struct usb_endpoint_descriptor *k
 	struct usb_endpoint_descriptor *endpoint;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < iface->desc.bNumEndpoints; ++i) {
 		endpoint = &iface->endpoint[i].desc;
 
@@ -431,6 +469,12 @@ static struct usb_endpoint_descriptor *k
 			/* we found our interrupt in endpoint */
 			return endpoint;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/input/misc/cm109.c b/input/misc/cm109.c
--- a/input/misc/cm109.c
+++ b/input/misc/cm109.c
@@ -758,10 +758,21 @@ static int cm109_usb_probe(struct usb_in
 	input_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);
 
 	/* register available key events */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < KEYMAP_SIZE; i++) {
 		unsigned short k = keymap(i);
 		dev->keymap[i] = k;
 		__set_bit(k, input_dev->keybit);
+		if (_cur < timeout) {
+					rdstcll(_cur);
+		}
+		else {
+					break;
+		}
 	}
 	__clear_bit(KEY_RESERVED, input_dev->keybit);
 
diff -u -p a/input/misc/adxl34x.c b/input/misc/adxl34x.c
--- a/input/misc/adxl34x.c
+++ b/input/misc/adxl34x.c
@@ -281,10 +281,21 @@ static void adxl34x_send_key_events(stru
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ADXL_X_AXIS; i <= ADXL_Z_AXIS; i++) {
 		if (status & (1 << (ADXL_Z_AXIS - i)))
 			input_report_key(ac->input,
 					 pdata->ev_code_tap[i], press);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/input/misc/atlas_btns.c b/input/misc/atlas_btns.c
--- a/input/misc/atlas_btns.c
+++ b/input/misc/atlas_btns.c
@@ -93,12 +93,23 @@ static int atlas_acpi_button_add(struct
 
 	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
 	__set_bit(EV_KEY, input_dev->evbit);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(atlas_keymap); i++) {
 		if (i < 9) {
 			atlas_keymap[i] = KEY_F1 + i;
 			__set_bit(KEY_F1 + i, input_dev->keybit);
 		} else
 			atlas_keymap[i] = KEY_RESERVED;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	err = input_register_device(input_dev);
diff -u -p a/input/serio/ams_delta_serio.c b/input/serio/ams_delta_serio.c
--- a/input/serio/ams_delta_serio.c
+++ b/input/serio/ams_delta_serio.c
@@ -49,9 +49,20 @@ static int check_data(int data)
 		return SERIO_FRAME;
 	}
 	/* calculate the parity */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < 10; i++) {
 		if (data & (1 << i))
 			parity++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+		break;
+		}
 	}
 	/* it should be odd */
 	if (!(parity & 0x01)) {
diff -u -p a/input/serio/serport.c b/input/serio/serport.c
--- a/input/serio/serport.c
+++ b/input/serio/serport.c
@@ -132,7 +132,12 @@ static void serport_ldisc_receive(struct
 	if (!test_bit(SERPORT_ACTIVE, &serport->flags))
 		goto out;
 
-	for (i = 0; i < count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < count; i++) {
 		switch (fp[i]) {
 		case TTY_FRAME:
 			ch_flags = SERIO_FRAME;
@@ -148,6 +153,12 @@ static void serport_ldisc_receive(struct
 		}
 
 		serio_interrupt(serport->serio, cp[i], ch_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
diff -u -p a/input/serio/ps2mult.c b/input/serio/ps2mult.c
--- a/input/serio/ps2mult.c
+++ b/input/serio/ps2mult.c
@@ -179,11 +179,22 @@ static int ps2mult_connect(struct serio
 	spin_lock_init(&psm->lock);
 	psm->mx_serio = serio;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < PS2MULT_NUM_PORTS; i++) {
 		psm->ports[i].sel = ps2mult_controls[i];
 		error = ps2mult_create_port(psm, i);
 		if (error)
 			goto err_out;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	psm->in_port = psm->out_port = &psm->ports[PS2MULT_KBD_PORT];
@@ -195,11 +206,22 @@ static int ps2mult_connect(struct serio
 
 	ps2mult_reset(psm);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <  PS2MULT_NUM_PORTS; i++) {
 		struct serio *s = psm->ports[i].serio;
 
 		dev_info(&serio->dev, "%s port at %s\n", s->name, serio->phys);
 		serio_register_port(s);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/input/serio/hil_mlc.c b/input/serio/hil_mlc.c
--- a/input/serio/hil_mlc.c
+++ b/input/serio/hil_mlc.c
@@ -149,6 +149,11 @@ static inline void hil_mlc_clean_serio_m
 {
 	int idx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < HIL_MLC_DEVMEM; idx++) {
 		int j, found = 0;
 
@@ -158,6 +163,12 @@ static inline void hil_mlc_clean_serio_m
 
 		if (!found)
 			mlc->serio_map[idx].di_revmap = -1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -927,6 +938,11 @@ int hil_mlc_register(hil_mlc *mlc)
 
 	hil_mlc_clear_di_scratch(mlc);
 	hil_mlc_clear_di_map(mlc, 0);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < HIL_MLC_DEVMEM; i++) {
 		struct serio *mlc_serio;
 		hil_mlc_copy_di_scratch(mlc, i);
@@ -951,6 +967,12 @@ int hil_mlc_register(hil_mlc *mlc)
 		mlc->serio_opacket[i]		= 0;
 		mlc->serio_oidx[i]		= 0;
 		serio_register_port(mlc_serio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mlc->tasklet = &hil_mlcs_tasklet;
@@ -986,9 +1008,20 @@ int hil_mlc_unregister(hil_mlc *mlc)
 	list_del(tmp);
 	write_unlock_irqrestore(&hil_mlcs_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < HIL_MLC_DEVMEM; i++) {
 		serio_unregister_port(mlc->serio[i]);
 		mlc->serio[i] = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tasklet_schedule(&hil_mlcs_tasklet);
diff -u -p a/input/serio/i8042.c b/input/serio/i8042.c
--- a/input/serio/i8042.c
+++ b/input/serio/i8042.c
@@ -262,14 +262,30 @@ static int __i8042_command(unsigned char
 	dbg("%02x -> i8042 (command)\n", command & 0xff);
 	i8042_write_command(command & 0xff);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ((command >> 12) & 0xf); i++) {
 		error = i8042_wait_write();
 		if (error)
 			return error;
 		dbg("%02x -> i8042 (parameter)\n", param[i]);
 		i8042_write_data(param[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ((command >> 8) & 0xf); i++) {
 		error = i8042_wait_read();
 		if (error) {
@@ -285,6 +301,12 @@ static int __i8042_command(unsigned char
 
 		param[i] = i8042_read_data();
 		dbg("%02x <- i8042 (return)\n", param[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -581,9 +603,20 @@ static int i8042_enable_mux_ports(void)
 	unsigned char param;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < I8042_NUM_MUX_PORTS; i++) {
 		i8042_command(&param, I8042_CMD_MUX_PFX + i);
 		i8042_command(&param, I8042_CMD_AUX_ENABLE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return i8042_enable_aux_port();
@@ -708,6 +741,11 @@ static int __init i8042_toggle_aux(bool
 		return -1;
 
 	/* some chips need some time to set the I8042_CTR_AUXDIS bit */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 100; i++) {
 		udelay(50);
 
@@ -716,6 +754,12 @@ static int __init i8042_toggle_aux(bool
 
 		if (!(param & I8042_CTR_AUXDIS) == on)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return -1;
@@ -1262,9 +1306,20 @@ static void __init i8042_free_aux_ports(
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = I8042_AUX_PORT_NO; i < I8042_NUM_PORTS; i++) {
 		kfree(i8042_ports[i].serio);
 		i8042_ports[i].serio = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1272,6 +1327,11 @@ static void __init i8042_register_ports(
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < I8042_NUM_PORTS; i++) {
 		if (i8042_ports[i].serio) {
 			printk(KERN_INFO "serio: %s at %#lx,%#lx irq %d\n",
@@ -1281,6 +1341,12 @@ static void __init i8042_register_ports(
 				i8042_ports[i].irq);
 			serio_register_port(i8042_ports[i].serio);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1288,11 +1354,22 @@ static void __devexit i8042_unregister_p
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < I8042_NUM_PORTS; i++) {
 		if (i8042_ports[i].serio) {
 			serio_unregister_port(i8042_ports[i].serio);
 			i8042_ports[i].serio = NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1336,10 +1413,21 @@ static int __init i8042_setup_aux(void)
 			goto err_free_ports;
 		aux_enable = i8042_enable_aux_port;
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < I8042_NUM_MUX_PORTS; i++) {
 			error = i8042_create_aux_port(i);
 			if (error)
 				goto err_free_ports;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		aux_enable = i8042_enable_mux_ports;
 	}
diff -u -p a/input/mousedev.c b/input/mousedev.c
--- a/input/mousedev.c
+++ b/input/mousedev.c
@@ -694,6 +694,11 @@ static ssize_t mousedev_write(struct fil
 	unsigned char c;
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i++) {
 
 		if (get_user(c, buffer + i))
@@ -720,6 +725,12 @@ static ssize_t mousedev_write(struct fil
 		mousedev_generate_response(client, c);
 
 		spin_unlock_irq(&client->packet_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kill_fasync(&client->fasync, SIGIO, POLL_IN);
diff -u -p a/input/input.c b/input/input.c
--- a/input/input.c
+++ b/input/input.c
@@ -592,11 +592,22 @@ static void input_dev_release_keys(struc
 	int code;
 
 	if (is_event_supported(EV_KEY, dev->evbit, EV_MAX)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (code = 0; code <= KEY_MAX; code++) {
 			if (is_event_supported(code, dev->keybit, KEY_MAX) &&
 			    __test_and_clear_bit(code, dev->key)) {
 				input_pass_event(dev, EV_KEY, code, 0);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		input_pass_event(dev, EV_SYN, SYN_REPORT, 1);
 	}
@@ -857,6 +868,11 @@ static const struct input_device_id *inp
 	const struct input_device_id *id;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (id = handler->id_table; id->flags || id->driver_info; id++) {
 
 		if (id->flags & INPUT_DEVICE_ID_MATCH_BUS)
@@ -887,6 +903,12 @@ static const struct input_device_id *inp
 
 		if (!handler->match || handler->match(handler, dev))
 			return id;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NULL;
@@ -1016,12 +1038,23 @@ static void input_seq_print_bitmap(struc
 
 	seq_printf(seq, "B: %s=", name);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = BITS_TO_LONGS(max) - 1; i >= 0; i--) {
 		if (input_bits_to_string(buf, sizeof(buf),
 					 bitmap[i], skip_empty)) {
 			skip_empty = false;
 			seq_printf(seq, "%s%s", buf, i > 0 ? " " : "");
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -1339,7 +1372,12 @@ static int input_print_bitmap(char *buf,
 	int len = 0;
 	bool skip_empty = true;
 
-	for (i = BITS_TO_LONGS(max) - 1; i >= 0; i--) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = BITS_TO_LONGS(max) - 1; i >= 0; i--) {
 		len += input_bits_to_string(buf + len, max(buf_size - len, 0),
 					    bitmap[i], skip_empty);
 		if (len) {
@@ -1347,6 +1385,12 @@ static int input_print_bitmap(char *buf,
 			if (i > 0)
 				len += snprintf(buf + len, max(buf_size - len, 0), " ");
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/*
@@ -1765,6 +1809,11 @@ static unsigned int input_estimate_event
 
 	events = mt_slots + 1; /* count SYN_MT_REPORT and SYN_REPORT */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ABS_CNT; i++) {
 		if (test_bit(i, dev->absbit)) {
 			if (input_is_mt_axis(i))
@@ -1772,6 +1821,12 @@ static unsigned int input_estimate_event
 			else
 				events++;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	for (i = 0; i < REL_CNT; i++)
diff -u -p a/input/joystick/amijoy.c b/input/joystick/amijoy.c
--- a/input/joystick/amijoy.c
+++ b/input/joystick/amijoy.c
@@ -108,6 +108,11 @@ static int __init amijoy_init(void)
 	int i, j;
 	int err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		if (!amijoy[i])
 			continue;
@@ -138,9 +143,20 @@ static int __init amijoy_init(void)
 		amijoy_dev[i]->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y);
 		amijoy_dev[i]->keybit[BIT_WORD(BTN_LEFT)] = BIT_MASK(BTN_LEFT) |
 			BIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 2; j++) {
 			input_set_abs_params(amijoy_dev[i], ABS_X + j,
 					     -1, 1, 0, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		err = input_register_device(amijoy_dev[i]);
@@ -148,6 +164,12 @@ static int __init amijoy_init(void)
 			input_free_device(amijoy_dev[i]);
 			goto fail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
diff -u -p a/input/joystick/cobra.c b/input/joystick/cobra.c
--- a/input/joystick/cobra.c
+++ b/input/joystick/cobra.c
@@ -64,9 +64,20 @@ static unsigned char cobra_read_packet(s
 
 	int strobe = gameport_time(gameport, COBRA_MAX_STROBE);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		r[i] = buf[i] = 0;
 		t[i] = COBRA_MAX_STROBE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	local_irq_save(flags);
@@ -90,6 +101,11 @@ static unsigned char cobra_read_packet(s
 
 	ret = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 
 		if (r[i] != COBRA_LENGTH) continue;
@@ -103,6 +119,12 @@ static unsigned char cobra_read_packet(s
 			| ((buf[i] >>  9) & 0x0007c00) | ((buf[i] >> 10) & 0x00f8000)
 			| ((buf[i] >> 11) & 0x1f00000);
 
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 	}
 
 	return ret;
@@ -190,6 +212,11 @@ static int cobra_connect(struct gameport
 	gameport_set_poll_handler(gameport, cobra_poll);
 	gameport_set_poll_interval(gameport, 20);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		if (~(cobra->exists >> i) & 1)
 			continue;
@@ -225,6 +252,12 @@ static int cobra_connect(struct gameport
 		err = input_register_device(cobra->dev[i]);
 		if (err)
 			goto fail4;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
diff -u -p a/input/joystick/twidjoy.c b/input/joystick/twidjoy.c
--- a/input/joystick/twidjoy.c
+++ b/input/joystick/twidjoy.c
@@ -109,12 +109,23 @@ static void twidjoy_process_packet(struc
 
 	button_bits = ((data[1] & 0x7f) << 7) | (data[0] & 0x7f);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bp = twidjoy_buttons; bp->bitmask; bp++) {
 		int value = (button_bits & (bp->bitmask << bp->bitshift)) >> bp->bitshift;
 		int i;
 
 		for (i = 0; i < bp->bitmask; i++)
 			input_report_key(dev, bp->buttons[i], i+1 == value);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	abs_x = ((data[4] & 0x07) << 5) | ((data[3] & 0x7C) >> 2);
diff -u -p a/input/joystick/gf2k.c b/input/joystick/gf2k.c
--- a/input/joystick/gf2k.c
+++ b/input/joystick/gf2k.c
@@ -330,6 +330,11 @@ static int gf2k_connect(struct gameport
 	gf2k_read_packet(gameport, gf2k->length, data);
 	gf2k_read(gf2k, data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < gf2k_axes[gf2k->id]; i++) {
 		int max = i < 2 ?
 			input_abs_get_val(input_dev, gf2k_abs[i]) * 2 :
@@ -339,6 +344,12 @@ static int gf2k_connect(struct gameport
 
 		input_set_abs_params(input_dev, gf2k_abs[i],
 				     32, max - 32, 8, flat);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	err = input_register_device(gf2k->dev);
diff -u -p a/input/joystick/grip_mp.c b/input/joystick/grip_mp.c
--- a/input/joystick/grip_mp.c
+++ b/input/joystick/grip_mp.c
@@ -136,11 +136,22 @@ static inline int poll_until(u8 onbits,
 	int i, nloops;
 
 	nloops = gameport_time(gp, u_sec);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nloops; i++) {
 		*data = gameport_read(gp);
 		if ((*data & onbits) == onbits &&
 		    (~(*data) & offbits) == offbits)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	dbg("gameport timed out after %d microseconds.\n", u_sec);
 	return 0;
@@ -177,9 +188,20 @@ static int mp_io(struct gameport* gamepo
 	if (raw_data & 1)
 		return IO_RETRY;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 64; i++) {
 		raw_data = gameport_read(gameport);
 		portvals |= 1 << ((raw_data >> 4) & 3); /* Demux B4, B5 */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (portvals == 1) {                            /* B4, B5 off */
@@ -321,10 +343,21 @@ static int dig_mode_start(struct gamepor
 	int i;
 	int flags, tries = 0, bads = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(init_seq); i++) {     /* Send magic sequence */
 		if (init_seq[i])
 			gameport_trigger(gameport);
 		udelay(GRIP_INIT_DELAY);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i < 16; i++)            /* Wait for multiport to settle */
@@ -454,11 +487,22 @@ static int slots_valid(struct grip_mp *g
 	if (!(flags & IO_GOT_PACKET))
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (slot = 0; slot < 4; slot++) {
 		if (grip->port[slot]->mode == GRIP_MODE_RESET)
 			invalid = 1;
 		if (grip->port[slot]->mode != GRIP_MODE_NONE)
 			active = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Return true if no active slot but multiport sent all its data */
diff -u -p a/input/joystick/grip.c b/input/joystick/grip.c
--- a/input/joystick/grip.c
+++ b/input/joystick/grip.c
@@ -187,6 +187,11 @@ static void grip_poll(struct gameport *g
 	struct input_dev *dev;
 	int i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 
 		dev = grip->dev[i];
@@ -278,6 +283,12 @@ static void grip_poll(struct gameport *g
 		}
 
 		input_sync(dev);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -315,6 +326,11 @@ static int grip_connect(struct gameport
 	if (err)
 		goto fail1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		if (!grip_gpp_read_packet(gameport, (i << 1) + 4, data)) {
 			grip->mode[i] = GRIP_MODE_GPP;
@@ -332,6 +348,12 @@ static int grip_connect(struct gameport
 			grip->mode[i] = GRIP_MODE_DC;
 			continue;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!grip->mode[0] && !grip->mode[1]) {
@@ -342,6 +364,11 @@ static int grip_connect(struct gameport
 	gameport_set_poll_handler(gameport, grip_poll);
 	gameport_set_poll_interval(gameport, 20);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		if (!grip->mode[i])
 			continue;
@@ -370,6 +397,11 @@ static int grip_connect(struct gameport
 
 		input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; (t = grip_abs[grip->mode[i]][j]) >= 0; j++) {
 
 			if (j < grip_cen[grip->mode[i]])
@@ -378,6 +410,12 @@ static int grip_connect(struct gameport
 				input_set_abs_params(input_dev, t, 3, 57, 1, 0);
 			else
 				input_set_abs_params(input_dev, t, -1, 1, 0, 0);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+			}
 		}
 
 		for (j = 0; (t = grip_btn[grip->mode[i]][j]) >= 0; j++)
@@ -387,6 +425,12 @@ static int grip_connect(struct gameport
 		err = input_register_device(grip->dev[i]);
 		if (err)
 			goto fail4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/input/joystick/gamecon.c b/input/joystick/gamecon.c
--- a/input/joystick/gamecon.c
+++ b/input/joystick/gamecon.c
@@ -151,10 +151,21 @@ static void gc_n64_send_command(struct g
 	struct parport *port = gc->pd->port;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GC_N64_LENGTH; i++) {
 		unsigned char data = (cmd >> i) & 1 ? target : 0;
 		parport_write_data(port, GC_N64_POWER_W | data);
 		udelay(GC_N64_DWS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -164,10 +175,21 @@ static void gc_n64_send_stop_bit(struct
 	struct parport *port = gc->pd->port;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GC_N64_STOP_LENGTH; i++) {
 		unsigned char data = (GC_N64_STOP_BIT >> i) & 1 ? target : 0;
 		parport_write_data(port, GC_N64_POWER_W | data);
 		udelay(GC_N64_DWS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -202,11 +224,22 @@ static void gc_n64_read_packet(struct gc
  * Grab data (ignoring the last bit, which is a stop bit)
  */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GC_N64_LENGTH; i++) {
 		parport_write_data(gc->pd->port, GC_N64_POWER_R);
 		udelay(2);
 		data[i] = parport_read_status(gc->pd->port);
 		parport_write_data(gc->pd->port, GC_N64_POWER_R | GC_N64_CLOCK);
+		if (_cur < timeout) {
+			 rdstcll(_cur);
+		}
+		else {
+			 break;
+		}
 	 }
 
 /*
@@ -226,6 +259,11 @@ static void gc_n64_process_packet(struct
 
 	gc_n64_read_packet(gc, data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GC_MAX_DEVICES; i++) {
 
 		if (gc->pads[i].type != GC_N64)
@@ -238,11 +276,22 @@ static void gc_n64_process_packet(struct
 
 			x = y = 0;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < 8; j++) {
 				if (data[23 - j] & s)
 					x |= 1 << j;
 				if (data[31 - j] & s)
 					y |= 1 << j;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 			}
 
 			input_report_abs(dev, ABS_X,  x);
@@ -259,6 +308,12 @@ static void gc_n64_process_packet(struct
 
 			input_sync(dev);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -361,12 +416,23 @@ static void gc_nes_read_packet(struct gc
 	udelay(GC_NES_DELAY * 2);
 	parport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < length; i++) {
 		udelay(GC_NES_DELAY);
 		parport_write_data(gc->pd->port, GC_NES_POWER);
 		data[i] = parport_read_status(gc->pd->port) ^ 0x7f;
 		udelay(GC_NES_DELAY);
 		parport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -383,6 +449,11 @@ static void gc_nes_process_packet(struct
 
 	gc_nes_read_packet(gc, len, data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GC_MAX_DEVICES; i++) {
 
 		pad = &gc->pads[i];
@@ -429,6 +500,11 @@ static void gc_nes_process_packet(struct
 				input_report_key(dev, BTN_RIGHT, s & data[8]);
 
 				x_rel = y_rel = 0;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = 0; j < 7; j++) {
 					x_rel <<= 1;
 					if (data[25 + j] & s)
@@ -437,6 +513,12 @@ static void gc_nes_process_packet(struct
 					y_rel <<= 1;
 					if (data[17 + j] & s)
 						y_rel |= 1;
+						if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				if (x_rel) {
@@ -458,6 +540,12 @@ static void gc_nes_process_packet(struct
 		default:
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -476,9 +564,20 @@ static void gc_multi_read_packet(struct
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < length; i++) {
 		parport_write_data(gc->pd->port, ~(1 << i));
 		data[i] = parport_read_status(gc->pd->port) ^ 0x7f;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -492,6 +591,11 @@ static void gc_multi_process_packet(stru
 
 	gc_multi_read_packet(gc, data_len, data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GC_MAX_DEVICES; i++) {
 		pad = &gc->pads[i];
 		dev = pad->dev;
@@ -514,6 +618,12 @@ static void gc_multi_process_packet(stru
 		default:
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -569,6 +679,11 @@ static void gc_psx_command(struct gc *gc
 
 	memset(data, 0, GC_MAX_DEVICES);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GC_PSX_LENGTH; i++, b >>= 1) {
 		cmd = (b & 1) ? GC_PSX_COMMAND : 0;
 		parport_write_data(port, cmd | GC_PSX_POWER);
@@ -576,15 +691,32 @@ static void gc_psx_command(struct gc *gc
 
 		read = parport_read_status(port) ^ 0x80;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < GC_MAX_DEVICES; j++) {
 			struct gc_pad *pad = &gc->pads[j];
 
 			if (pad->type == GC_PSX || pad->type == GC_DDR)
 				data[j] |= (read & gc_status_bit[j]) ? (1 << i) : 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 
 		parport_write_data(gc->pd->port, cmd | GC_PSX_CLOCK | GC_PSX_POWER);
 		udelay(gc_psx_delay);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -615,6 +747,11 @@ static void gc_psx_read_packet(struct gc
 	gc_psx_command(gc, 0, data2);		/* Dump status */
 
 	/* Find the longest pad */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GC_MAX_DEVICES; i++) {
 		struct gc_pad *pad = &gc->pads[i];
 
@@ -623,13 +760,30 @@ static void gc_psx_read_packet(struct gc
 		    GC_PSX_LEN(id[i]) <= GC_PSX_BYTES) {
 			max_len = GC_PSX_LEN(id[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Read in all the data */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < max_len; i++) {
 		gc_psx_command(gc, 0, data2);
 		for (j = 0; j < GC_MAX_DEVICES; j++)
 			data[j][i] = data2[j];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	local_irq_restore(flags);
@@ -730,10 +884,21 @@ static void gc_psx_process_packet(struct
 
 	gc_psx_read_packet(gc, data, id);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GC_MAX_DEVICES; i++) {
 		pad = &gc->pads[i];
 		if (pad->type == GC_PSX || pad->type == GC_DDR)
 			gc_psx_report_one(pad, id[i], data[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -862,9 +1027,20 @@ static int __init gc_setup_pad(struct gc
 		for (i = 0; i < 10; i++)
 			__set_bit(gc_n64_btn[i], input_dev->keybit);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 2; i++) {
 			input_set_abs_params(input_dev, ABS_X + i, -127, 126, 0, 2);
 			input_set_abs_params(input_dev, ABS_HAT0X + i, -1, 1, 0, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		err = gc_n64_init_ff(input_dev, idx);
@@ -960,6 +1136,11 @@ static struct gc __init *gc_probe(int pa
 	gc->pd = pd;
 	setup_timer(&gc->timer, gc_timer, (long) gc);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n_pads && i < GC_MAX_DEVICES; i++) {
 		if (!pads[i])
 			continue;
@@ -969,6 +1150,12 @@ static struct gc __init *gc_probe(int pa
 			goto err_unreg_devs;
 
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (count == 0) {
diff -u -p a/input/joystick/iforce/iforce-serio.c b/input/joystick/iforce/iforce-serio.c
--- a/input/joystick/iforce/iforce-serio.c
+++ b/input/joystick/iforce/iforce-serio.c
@@ -55,10 +55,21 @@ again:
 	cs ^= iforce->xmit.buf[iforce->xmit.tail];
 	XMIT_INC(iforce->xmit.tail, 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=iforce->xmit.buf[iforce->xmit.tail]; i >= 0; --i) {
 		serio_write(iforce->serio, iforce->xmit.buf[iforce->xmit.tail]);
 		cs ^= iforce->xmit.buf[iforce->xmit.tail];
 		XMIT_INC(iforce->xmit.tail, 1);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	serio_write(iforce->serio, cs);
diff -u -p a/input/joystick/iforce/iforce-main.c b/input/joystick/iforce/iforce-main.c
--- a/input/joystick/iforce/iforce-main.c
+++ b/input/joystick/iforce/iforce-main.c
@@ -389,6 +389,11 @@ int iforce_init_device(struct iforce *if
 		set_bit(iforce->type->btn[i], input_dev->keybit);
 	set_bit(BTN_DEAD, input_dev->keybit);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; iforce->type->abs[i] >= 0; i++) {
 
 		signed short t = iforce->type->abs[i];
@@ -423,6 +428,12 @@ int iforce_init_device(struct iforce *if
 				input_set_abs_params(input_dev, t, -1, 1, 0, 0);
 				break;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (ff_effects) {
diff -u -p a/input/joystick/iforce/iforce-ff.c b/input/joystick/iforce/iforce-ff.c
--- a/input/joystick/iforce/iforce-ff.c
+++ b/input/joystick/iforce/iforce-ff.c
@@ -210,6 +210,11 @@ static int need_condition_modifier(struc
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		ret |= old->u.condition[i].right_saturation != new->u.condition[i].right_saturation
 			|| old->u.condition[i].left_saturation != new->u.condition[i].left_saturation
@@ -217,6 +222,12 @@ static int need_condition_modifier(struc
 			|| old->u.condition[i].left_coeff != new->u.condition[i].left_coeff
 			|| old->u.condition[i].deadband != new->u.condition[i].deadband
 			|| old->u.condition[i].center != new->u.condition[i].center;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	return ret;
 }
diff -u -p a/input/joystick/iforce/iforce-packets.c b/input/joystick/iforce/iforce-packets.c
--- a/input/joystick/iforce/iforce-packets.c
+++ b/input/joystick/iforce/iforce-packets.c
@@ -141,6 +141,11 @@ static int mark_core_as_ready(struct ifo
 	if (!iforce->dev->ff)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < iforce->dev->ff->max_effects; ++i) {
 		if (test_bit(FF_CORE_IS_USED, iforce->core_effects[i].flags) &&
 		    (iforce->core_effects[i].mod1_chunk.start == addr ||
@@ -148,6 +153,12 @@ static int mark_core_as_ready(struct ifo
 			clear_bit(FF_CORE_UPDATE, iforce->core_effects[i].flags);
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_warn(&iforce->dev->dev, "unused effect %04x updated !!!\n", addr);
 	return -1;
diff -u -p a/input/joystick/analog.c b/input/joystick/analog.c
--- a/input/joystick/analog.c
+++ b/input/joystick/analog.c
@@ -266,11 +266,22 @@ static int analog_cooked_read(struct ana
 
 	this <<= 4;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (--i; i >= 0; i--) {
 		this |= data[i];
 		for (j = 0; j < 4; j++)
 			if (data[i] & (1 << j))
 				port->axes[j] = (DELTA(start, time[i]) << ANALOG_FUZZ_BITS) / port->loop;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 	}
 
 	return -(this != port->mask);
@@ -386,16 +397,38 @@ static void analog_calibrate_timer(struc
 
 	tx = ~0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 50; i++) {
 		local_irq_save(flags);
 		GET_TIME(t1);
-		for (t = 0; t < 50; t++) { gameport_read(gameport); GET_TIME(t2); }
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (t = 0; t < 50; t++) { gameport_read(gameport); GET_TIME(t2); if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
+		}
 		GET_TIME(t3);
 		local_irq_restore(flags);
 		udelay(i);
 		t = DELTA(t1, t2) - DELTA(t2, t3);
 		if (t < tx) tx = t;
-	}
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
+        }
 
         port->loop = tx / 50;
 }
@@ -484,11 +517,23 @@ static int analog_init_device(struct ana
 		}
 
 	for (i = j = 0; i < 3; i++)
-		if (analog->mask & analog_exts[i])
-			for (x = 0; x < 2; x++) {
-				t = analog_hats[j++];
-				input_set_abs_params(input_dev, t, -1, 1, 0, 0);
+		if (analog->mask & analog_exts[i]) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (x = 0; x < 2; x++) {
+			t = analog_hats[j++];
+			input_set_abs_params(input_dev, t, -1, 1, 0, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
 			}
+			else {
+			break;
+			}
+			}
+		}
 
 	for (i = j = 0; i < 4; i++)
 		if (analog->mask & (0x10 << i))
@@ -723,6 +768,11 @@ static void analog_parse_options(void)
 	int i, j;
 	char *end;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < js_nargs; i++) {
 
 		for (j = 0; analog_types[j].name; j++)
@@ -739,6 +789,12 @@ static void analog_parse_options(void)
 		if (!strlen(js[i])) continue;
 
 		printk(KERN_WARNING "analog.c: Bad config for port %d - \"%s\"\n", i, js[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (; i < ANALOG_PORTS; i++)
diff -u -p a/input/joystick/db9.c b/input/joystick/db9.c
--- a/input/joystick/db9.c
+++ b/input/joystick/db9.c
@@ -241,12 +241,23 @@ static unsigned char db9_saturn_read_pac
 			/* read multitap */
 			if (db9_saturn_read_analog(port, type, powered) != 0x60)
 				return data[0] = 0xff;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 60; i += 10) {
 				data[i] = db9_saturn_read_analog(port, type, powered);
 				if (data[i] != 0xff)
 					/* read each pad */
 					for (j = 0; j < (data[i] & 0x0f); j++)
 						data[i + j + 1] = db9_saturn_read_analog(port, type, powered);
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
 			}
 			db9_saturn_write_sub(port, type, 3, powered, 0);
 			return 0x41;
@@ -276,6 +287,11 @@ static int db9_saturn_report(unsigned ch
 	int tmp, i, j;
 
 	tmp = (id == 0x41) ? 60 : 10;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < tmp && n < max_pads; j += 10, n++) {
 		dev = devs[n];
 		switch (data[j]) {
@@ -329,6 +345,12 @@ static int db9_saturn_report(unsigned ch
 				input_report_key(dev, db9_cd32_btn[i], 0);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return n;
 }
@@ -356,9 +378,20 @@ static int db9_saturn(int mode, struct p
 		return -1;
 	}
 	max_pads = min(db9_modes[mode].n_pads, DB9_MAX_DEVICES);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tmp = 0, i = 0; i < n; i++) {
 		id = db9_saturn_read_packet(port, data, type + i, 1);
 		tmp = db9_saturn_report(id, data, devs, tmp, max_pads);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return 0;
 }
@@ -498,11 +531,22 @@ static void db9_timer(unsigned long priv
 
 			parport_write_control(port, 0x0a);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 7; i++) {
 				data = parport_read_data(port);
 				parport_write_control(port, 0x02);
 				parport_write_control(port, 0x0a);
 				input_report_key(dev, db9_cd32_btn[i], ~data & DB9_FIRE2);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 			}
 
 			parport_write_control(port, 0x00);
@@ -605,6 +649,11 @@ static struct db9 __init *db9_probe(int
 	db9->timer.data = (long) db9;
 	db9->timer.function = db9_timer;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (min(db9_mode->n_pads, DB9_MAX_DEVICES)); i++) {
 
 		db9->dev[i] = input_dev = input_allocate_device();
@@ -632,16 +681,33 @@ static struct db9 __init *db9_probe(int
 		input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 		for (j = 0; j < db9_mode->n_buttons; j++)
 			set_bit(db9_mode->buttons[j], input_dev->keybit);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < db9_mode->n_axis; j++) {
 			if (j < 2)
 				input_set_abs_params(input_dev, db9_abs[j], -1, 1, 0, 0);
 			else
 				input_set_abs_params(input_dev, db9_abs[j], 1, 255, 0, 0);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		err = input_register_device(input_dev);
 		if (err)
 			goto err_free_dev;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	parport_put_port(pp);
diff -u -p a/input/joystick/joydump.c b/input/joystick/joydump.c
--- a/input/joystick/joydump.c
+++ b/input/joystick/joydump.c
@@ -130,12 +130,23 @@ static int joydump_connect(struct gamepo
 	printk(" |\n");
 	dump++;
 
-	for (i = 1; i < t; i++, dump++, prev++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 1; i < t; i++, dump++, prev++) {
 		printk(KERN_INFO "joydump: | index: %3d delta: %3d us data: ",
 			i, dump->time - prev->time);
 		for (j = 7; j >= 0; j--)
 			printk("%d", (dump->data >> j) & 1);
 		printk(" |\n");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(buf);
 
diff -u -p a/input/joystick/adi.c b/input/joystick/adi.c
--- a/input/joystick/adi.c
+++ b/input/joystick/adi.c
@@ -144,10 +144,21 @@ static void adi_read_packet(struct adi_p
 	int t[2], s[2], i;
 	unsigned long flags;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		adi[i].ret = -1;
 		t[i] = gameport_time(gameport, ADI_MAX_START);
 		s[i] = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	local_irq_save(flags);
@@ -158,6 +169,11 @@ static void adi_read_packet(struct adi_p
 	do {
 		u = v;
 		w = u ^ (v = x = gameport_read(gameport));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 2; i++, w >>= 2, x >>= 2) {
 			t[i]--;
 			if ((w & 0x30) && s[i]) {
@@ -166,6 +182,12 @@ static void adi_read_packet(struct adi_p
 					t[i] = gameport_time(gameport, ADI_MAX_STROBE);
 				} else t[i] = 0;
 			} else if (!(x & 0x30)) s[i] = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} while (t[0] > 0 || t[1] > 0);
 
@@ -230,6 +252,11 @@ static int adi_decode(struct adi *adi)
 	for (i = 0; i < adi->axes8; i++)
 		input_report_abs(dev, *abs++, adi_get_bits(adi, 8));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < adi->buttons && i < 63; i++) {
 		if (i == adi->pad) {
 			t = adi_get_bits(adi, 4);
@@ -237,12 +264,29 @@ static int adi_decode(struct adi *adi)
 			input_report_abs(dev, *abs++, ((t >> 1) & 1) - ((t >> 3) & 1));
 		}
 		input_report_key(dev, *key++, adi_get_bits(adi, 1));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < adi->hats; i++) {
 		if ((t = adi_get_bits(adi, 4)) > 8) t = 0;
 		input_report_abs(dev, *abs++, adi_hat_to_axis[t].x);
 		input_report_abs(dev, *abs++, adi_hat_to_axis[t].y);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 63; i < adi->buttons; i++)
@@ -317,6 +361,11 @@ static void adi_init_digital(struct game
 	int seq[] = { 4, -2, -3, 10, -6, -11, -7, -9, 11, 0 };
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; seq[i]; i++) {
 		gameport_trigger(gameport);
 		if (seq[i] > 0)
@@ -325,6 +374,12 @@ static void adi_init_digital(struct game
 			mdelay(-seq[i]);
 			udelay(-seq[i]*14);	/* It looks like mdelay() is off by approx 1.4% */
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -449,6 +504,11 @@ static void adi_init_center(struct adi *
 	if (!adi->length)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < adi->axes10 + adi->axes8 + (adi->hats + (adi->pad != -1)) * 2; i++) {
 
 		t = adi->abs[i];
@@ -463,6 +523,12 @@ static void adi_init_center(struct adi *
 			input_set_abs_params(adi->dev, t, 48, x * 2 - 48, 1, 16);
 		else
 			input_set_abs_params(adi->dev, t, -1, 1, 0, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -494,6 +560,11 @@ static int adi_connect(struct gameport *
 	if (port->adi[0].ret >= ADI_MIN_LEN_LENGTH)
 		adi_move_bits(port, adi_get_bits(port->adi, 10));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		adi_id_decode(port->adi + i, port);
 
@@ -503,6 +574,12 @@ static int adi_connect(struct gameport *
 		err = adi_init_input(port->adi + i, port, i);
 		if (err)
 			goto fail2;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	if (!port->adi[0].length && !port->adi[1].length) {
diff -u -p a/input/joystick/maplecontrol.c b/input/joystick/maplecontrol.c
--- a/input/joystick/maplecontrol.c
+++ b/input/joystick/maplecontrol.c
@@ -114,6 +114,11 @@ static int __devinit probe_maple_control
 	idev->open = dc_pad_open;
 	idev->close = dc_pad_close;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 32; i++) {
 		if (data & (1 << i)) {
 			if (btn_bit[i] >= 0)
@@ -121,6 +126,12 @@ static int __devinit probe_maple_control
 			else if (abs_bit[i] >= 0)
 				__set_bit(abs_bit[i], idev->absbit);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (idev->keybit[BIT_WORD(BTN_JOYSTICK)])
diff -u -p a/input/joystick/walkera0701.c b/input/joystick/walkera0701.c
--- a/input/joystick/walkera0701.c
+++ b/input/joystick/walkera0701.c
@@ -69,17 +69,39 @@ static inline void walkera0701_parse_fra
 	int val1, val2, val3, val4, val5, val6, val7, val8;
 	int crc1, crc2;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (crc1 = crc2 = i = 0; i < 10; i++) {
 		crc1 += w->buf[i] & 7;
 		crc2 += (w->buf[i] & 8) >> 3;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if ((w->buf[10] & 7) != (crc1 & 7))
 		return;
 	if (((w->buf[10] & 8) >> 3) != (((crc1 >> 3) + crc2) & 1))
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (crc1 = crc2 = 0, i = 11; i < 23; i++) {
 		crc1 += w->buf[i] & 7;
 		crc2 += (w->buf[i] & 8) >> 3;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if ((w->buf[23] & 7) != (crc1 & 7))
 		return;
diff -u -p a/input/joystick/turbografx.c b/input/joystick/turbografx.c
--- a/input/joystick/turbografx.c
+++ b/input/joystick/turbografx.c
@@ -192,6 +192,11 @@ static struct tgfx __init *tgfx_probe(in
 	tgfx->timer.data = (long) tgfx;
 	tgfx->timer.function = tgfx_timer;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n_devs; i++) {
 		if (n_buttons[i] < 1)
 			continue;
@@ -237,7 +242,13 @@ static struct tgfx __init *tgfx_probe(in
 		err = input_register_device(tgfx->dev[i]);
 		if (err)
 			goto err_free_dev;
-	}
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+		else {
+		break;
+		}
+        }
 
         if (!tgfx->sticks) {
 		printk(KERN_ERR "turbografx.c: No valid devices specified\n");
diff -u -p a/input/joystick/interact.c b/input/joystick/interact.c
--- a/input/joystick/interact.c
+++ b/input/joystick/interact.c
@@ -269,11 +269,22 @@ static int interact_connect(struct gamep
 
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; (t = interact_type[interact->type].abs[i]) >= 0; i++) {
 		if (i < interact_type[interact->type].b8)
 			input_set_abs_params(input_dev, t, 0, 255, 0, 0);
 		else
 			input_set_abs_params(input_dev, t, -1, 1, 0, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	for (i = 0; (t = interact_type[interact->type].btn[i]) >= 0; i++)
diff -u -p a/input/joystick/sidewinder.c b/input/joystick/sidewinder.c
--- a/input/joystick/sidewinder.c
+++ b/input/joystick/sidewinder.c
@@ -333,6 +333,11 @@ static int sw_parse(unsigned char *buf,
 
 		case SW_ID_GP:
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < sw->number; i ++) {
 
 				if (sw_parity(GB(i*15,15)))
@@ -345,6 +350,12 @@ static int sw_parse(unsigned char *buf,
 					input_report_key(sw->dev[i], sw_btn[SW_ID_GP][j], !GB(i*15+j+4,1));
 
 				input_sync(sw->dev[i]);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			return 0;
@@ -731,7 +742,12 @@ static int sw_connect(struct gameport *g
 	k = i;
 	l = j;
 
-	for (i = 0; i < sw->number; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < sw->number; i++) {
 		int bits, code;
 
 		snprintf(sw->name, sizeof(sw->name),
@@ -760,6 +776,11 @@ static int sw_connect(struct gameport *g
 
 		input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; (bits = sw_bit[sw->type][j]); j++) {
 			int min, max, fuzz, flat;
 
@@ -772,6 +793,12 @@ static int sw_connect(struct gameport *g
 
 			input_set_abs_params(input_dev, code,
 					     min, max, fuzz, flat);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		for (j = 0; (code = sw_btn[sw->type][j]); j++)
@@ -782,6 +809,12 @@ static int sw_connect(struct gameport *g
 		err = input_register_device(sw->dev[i]);
 		if (err)
 			goto fail4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
  out:	kfree(buf);
diff -u -p a/input/joystick/a3d.c b/input/joystick/a3d.c
--- a/input/joystick/a3d.c
+++ b/input/joystick/a3d.c
@@ -340,6 +340,11 @@ static int a3d_connect(struct gameport *
 
 		a3d_read(a3d, data);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 4; i++) {
 			if (i < 2)
 				input_set_abs_params(input_dev, axes[i],
@@ -347,6 +352,12 @@ static int a3d_connect(struct gameport *
 			else
 				input_set_abs_params(input_dev, axes[i], 2, 253, 0, 0);
 			input_set_abs_params(input_dev, ABS_HAT0X + i, -1, 1, 0, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	} else {
diff -u -p a/input/joystick/spaceball.c b/input/joystick/spaceball.c
--- a/input/joystick/spaceball.c
+++ b/input/joystick/spaceball.c
@@ -245,9 +245,20 @@ static int spaceball_connect(struct seri
 				BIT_MASK(BTN_8);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		input_set_abs_params(input_dev, ABS_X + i, -8000, 8000, 8, 40);
 		input_set_abs_params(input_dev, ABS_RX + i, -1600, 1600, 2, 8);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	serio_set_drvdata(serio, spaceball);
diff -u -p a/input/joystick/tmdc.c b/input/joystick/tmdc.c
--- a/input/joystick/tmdc.c
+++ b/input/joystick/tmdc.c
@@ -152,9 +152,20 @@ static int tmdc_read_packet(struct gamep
 
 	p = gameport_time(gameport, TMDC_MAX_STROBE);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < 2; k++) {
 		t[k] = gameport_time(gameport, TMDC_MAX_START);
 		i[k] = j[k] = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	local_irq_save(flags);
@@ -166,6 +177,11 @@ static int tmdc_read_packet(struct gamep
 		x = w;
 		w = gameport_read(gameport) >> 4;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (k = 0, v = w, u = x; k < 2; k++, v >>= 2, u >>= 2) {
 			if (~v & u & 2) {
 				if (t[k] <= 0 || i[k] >= TMDC_MAX_LENGTH) continue;
@@ -181,6 +197,12 @@ static int tmdc_read_packet(struct gamep
 				data[k][i[k]] |= (~v & 1) << (j[k]++ - 1);	/* Data bit */
 			}
 			t[k]--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} while (t[0] > 0 || t[1] > 0);
 
@@ -196,11 +218,22 @@ static int tmdc_parse_packet(struct tmdc
 	if (data[TMDC_BYTE_ID] != port->mode)
 		return -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < port->absc; i++) {
 		if (port->abs[i] < 0)
 			return 0;
 
 		input_report_abs(port->dev, port->abs[i], data[tmdc_byte_a[i]]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	switch (port->mode) {
@@ -221,11 +254,22 @@ static int tmdc_parse_packet(struct tmdc
 
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = l = 0; k < 4; k++) {
 		for (i = 0; i < port->btnc[k]; i++)
 			input_report_key(port->dev, port->btn[i + l],
 				((data[tmdc_byte_d[k]] >> (i + port->btno[k])) & 1));
 		l += port->btnc[k];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_sync(port->dev);
@@ -249,12 +293,23 @@ static void tmdc_poll(struct gameport *g
 	if ((r = tmdc_read_packet(tmdc->gameport, data)) != tmdc->exists)
 		bad = 1;
 	else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 2; i++) {
 			if (r & (1 << i) & tmdc->exists) {
 
 				if (tmdc_parse_packet(tmdc->port[i], data[i]))
 					bad = 1;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
@@ -340,10 +395,21 @@ static int tmdc_setup_port(struct tmdc *
 	for (i = 0; i < model->hats && i < TMDC_ABS_HAT; i++)
 		input_set_abs_params(input_dev, tmdc_abs_hat[i], -1, 1, 0, 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		for (j = 0; j < port->btnc[i] && j < TMDC_BTN; j++)
 			set_bit(port->btn[j + b], input_dev->keybit);
 		b += port->btnc[i];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	err = input_register_device(port->dev);
@@ -387,6 +453,11 @@ static int tmdc_connect(struct gameport
 	gameport_set_poll_handler(gameport, tmdc_poll);
 	gameport_set_poll_interval(gameport, 20);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		if (tmdc->exists & (1 << i)) {
 
@@ -394,6 +465,12 @@ static int tmdc_connect(struct gameport
 			if (err)
 				goto fail3;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return 0;
@@ -415,11 +492,22 @@ static void tmdc_disconnect(struct gamep
 	struct tmdc *tmdc = gameport_get_drvdata(gameport);
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		if (tmdc->port[i]) {
 			input_unregister_device(tmdc->port[i]->dev);
 			kfree(tmdc->port[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	gameport_close(gameport);
 	gameport_set_drvdata(gameport, NULL);
diff -u -p a/input/sparse-keymap.c b/input/sparse-keymap.c
--- a/input/sparse-keymap.c
+++ b/input/sparse-keymap.c
@@ -186,6 +186,11 @@ int sparse_keymap_setup(struct input_dev
 
 	memcpy(map, keymap, map_size * sizeof (struct key_entry));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < map_size; i++) {
 		entry = &map[i];
 
@@ -207,6 +212,12 @@ int sparse_keymap_setup(struct input_dev
 			__set_bit(entry->sw.code, dev->swbit);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (test_bit(EV_KEY, dev->evbit)) {
diff -u -p a/input/gameport/gameport.c b/input/gameport/gameport.c
--- a/input/gameport/gameport.c
+++ b/input/gameport/gameport.c
@@ -86,6 +86,11 @@ static int gameport_measure_speed(struct
 
 	tx = 1 << 30;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 50; i++) {
 		local_irq_save(flags);
 		GET_TIME(t1);
@@ -95,6 +100,12 @@ static int gameport_measure_speed(struct
 		local_irq_restore(flags);
 		udelay(i * 10);
 		if ((t = DELTA(t2,t1) - DELTA(t3,t2)) < tx) tx = t;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	gameport_close(gameport);
@@ -110,6 +121,11 @@ static int gameport_measure_speed(struct
 
 	tx = 1 << 30;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 50; i++) {
 		local_irq_save(flags);
 		rdtscl(t1);
@@ -118,6 +134,12 @@ static int gameport_measure_speed(struct
 		local_irq_restore(flags);
 		udelay(i * 10);
 		if (t2 - t1 < tx) tx = t2 - t1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	gameport_close(gameport);
diff -u -p a/input/gameport/lightning.c b/input/gameport/lightning.c
--- a/input/gameport/lightning.c
+++ b/input/gameport/lightning.c
@@ -140,10 +140,21 @@ static int l4_getcal(int port, int *cal)
 		goto out;
         outb(port & 3, L4_PORT);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		if (l4_wait_ready())
 			goto out;
 		cal[i] = inb(L4_PORT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	result = 0;
@@ -176,10 +187,21 @@ static int l4_setcal(int port, int *cal)
 		goto out;
         outb(port & 3, L4_PORT);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		if (l4_wait_ready())
 			goto out;
 		outb(cal[i], L4_PORT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	result = 0;
@@ -202,12 +224,23 @@ static int l4_calibrate(struct gameport
 	if (l4_getcal(l4->port, cal))
 		return -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		t = (max[i] * cal[i]) / 200;
 		t = (t < 1) ? 1 : ((t > 255) ? 255 : t);
 		axes[i] = (axes[i] < 0) ? -1 : (axes[i] * cal[i]) / t;
 		axes[i] = (axes[i] > 252) ? 252 : axes[i];
 		cal[i] = t;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (l4_setcal(l4->port, cal))
@@ -222,6 +255,11 @@ static int __init l4_create_ports(int ca
 	struct gameport *port;
 	int i, idx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 
 		idx = card_no * 4 + i;
@@ -247,6 +285,12 @@ static int __init l4_create_ports(int ca
 
 		if (idx == 0)
 			port->io = L4_PORT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -290,12 +334,23 @@ static int __init l4_add_card(int card_n
 	printk(KERN_INFO "gameport: PDPI Lightning 4 %s card v%d.%d at %#x\n",
 		card_no ? "secondary" : "primary", rev >> 4, rev, L4_PORT);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		l4 = &l4_ports[card_no * 4 + i];
 
 		if (rev > 0x28)		/* on 2.9+ the setcal command works correctly */
 			l4_setcal(l4->port, cal);
 		gameport_register_port(l4->gameport);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/input/ff-memless.c b/input/ff-memless.c
--- a/input/ff-memless.c
+++ b/input/ff-memless.c
@@ -131,6 +131,11 @@ static void ml_schedule_timer(struct ml_
 
 	pr_debug("calculating next timer\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < FF_MEMLESS_EFFECTS; i++) {
 
 		state = &ml->states[i];
@@ -146,6 +151,12 @@ static void ml_schedule_timer(struct ml_
 		if (time_before_eq(now, next_at) &&
 		    (++events == 1 || time_before(next_at, earliest)))
 			earliest = next_at;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!events) {
@@ -333,6 +344,11 @@ static int ml_get_combo_effect(struct ml
 
 	memset(combo_effect, 0, sizeof(struct ff_effect));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < FF_MEMLESS_EFFECTS; i++) {
 		if (__test_and_set_bit(i, effect_handled))
 			continue;
@@ -381,6 +397,12 @@ static int ml_get_combo_effect(struct ml
 			state->adj_at = jiffies;
 			ml_combine_effects(combo_effect, state, ml->gain);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return combo_effect->type != 0;
diff -u -p a/input/tablet/wacom_wac.c b/input/tablet/wacom_wac.c
--- a/input/tablet/wacom_wac.c
+++ b/input/tablet/wacom_wac.c
@@ -686,6 +686,11 @@ static int wacom_tpc_mt_touch(struct wac
 	int contact_with_no_pen_down_count = 0;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		int p = data[1] & (1 << i);
 		bool touch = p && !wacom->shared->stylus_in_proximity;
@@ -700,6 +705,12 @@ static int wacom_tpc_mt_touch(struct wac
 			input_report_abs(input, ABS_MT_POSITION_Y, y);
 			contact_with_no_pen_down_count++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* keep touch state for pen event */
@@ -799,6 +810,11 @@ static int wacom_bpt_touch(struct wacom_
 	unsigned char *data = wacom->data;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		int offset = (data[1] & 0x80) ? (8 * i) : (9 * i);
 		bool touch = data[offset + 3] & 0x80;
@@ -823,6 +839,12 @@ static int wacom_bpt_touch(struct wacom_
 			input_report_abs(input, ABS_MT_POSITION_X, x);
 			input_report_abs(input, ABS_MT_POSITION_Y, y);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_mt_report_pointer_emulation(input, true);
diff -u -p a/input/tablet/hanwang.c b/input/tablet/hanwang.c
--- a/input/tablet/hanwang.c
+++ b/input/tablet/hanwang.c
@@ -220,11 +220,22 @@ static void hanwang_parse_packet(struct
 			input_report_abs(input_dev, ABS_RY,
 					((data[3] & 0x1f) << 8) | data[4]);
 			input_report_key(input_dev, BTN_0, data[5] & 0x01);
-			for (i = 0; i < 4; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (i = 0; i < 4; i++) {
 				input_report_key(input_dev,
 					 BTN_1 + i, data[5] & (1 << i));
 				input_report_key(input_dev,
 					 BTN_5 + i, data[6] & (1 << i));
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			break;
 		}
@@ -293,12 +304,23 @@ static bool get_features(struct usb_devi
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(features_array); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(features_array); i++) {
 		if (le16_to_cpu(dev->descriptor.idProduct) ==
 				features_array[i].pid) {
 			hanwang->features = &features_array[i];
 			return true;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return false;
diff -u -p a/input/tablet/wacom_sys.c b/input/tablet/wacom_sys.c
--- a/input/tablet/wacom_sys.c
+++ b/input/tablet/wacom_sys.c
@@ -194,6 +194,11 @@ static int wacom_parse_hid(struct usb_in
 	if (result < 0)
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < hid_desc->wDescriptorLength; i++) {
 
 		switch (report[i]) {
@@ -314,6 +319,12 @@ static int wacom_parse_hid(struct usb_in
 			finger = usage = 0;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
  out:
diff -u -p a/input/mouse/sentelic.c b/input/mouse/sentelic.c
--- a/input/mouse/sentelic.c
+++ b/input/mouse/sentelic.c
@@ -557,7 +557,12 @@ static ssize_t fsp_attr_set_flags(struct
 	struct fsp_data *pad = psmouse->private;
 	size_t i;
 
-	for (i = 0; i < count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < count; i++) {
 		switch (buf[i]) {
 		case 'C':
 			pad->flags |= FSPDRV_FLAG_EN_OPC;
@@ -568,6 +573,12 @@ static ssize_t fsp_attr_set_flags(struct
 		default:
 			return -EINVAL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return count;
 }
diff -u -p a/input/mouse/appletouch.c b/input/mouse/appletouch.c
--- a/input/mouse/appletouch.c
+++ b/input/mouse/appletouch.c
@@ -335,6 +335,11 @@ static int atp_calculate_abs(int *xy_sen
 
 	*fingers = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nb_sensors; i++) {
 		if (xy_sensors[i] < threshold) {
 			if (is_increasing)
@@ -374,6 +379,12 @@ static int atp_calculate_abs(int *xy_sen
 		 */
 		pcum += (xy_sensors[i] - threshold) * i;
 		psum += (xy_sensors[i] - threshold);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (psum > 0) {
@@ -486,17 +497,44 @@ static void atp_complete_geyser_1_2(stru
 		 */
 
 		/* read X values */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0, j = 19; i < 20; i += 2, j += 3) {
 			dev->xy_cur[i] = dev->data[j];
 			dev->xy_cur[i + 1] = dev->data[j + 1];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* read Y values */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0, j = 1; i < 9; i += 2, j += 3) {
 			dev->xy_cur[ATP_XSENSORS + i] = dev->data[j];
 			dev->xy_cur[ATP_XSENSORS + i + 1] = dev->data[j + 1];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 8; i++) {
 			/* X values */
 			dev->xy_cur[i +  0] = dev->data[5 * i +  2];
@@ -508,6 +546,12 @@ static void atp_complete_geyser_1_2(stru
 			/* Y values */
 			dev->xy_cur[ATP_XSENSORS + i] = dev->data[5 * i +  1];
 			dev->xy_cur[ATP_XSENSORS + i + 8] = dev->data[5 * i + 3];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -529,6 +573,11 @@ static void atp_complete_geyser_1_2(stru
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ATP_XSENSORS + ATP_YSENSORS; i++) {
 		/* accumulate the change */
 		signed char change = dev->xy_old[i] - dev->xy_cur[i];
@@ -537,6 +586,12 @@ static void atp_complete_geyser_1_2(stru
 		/* prevent down drifting */
 		if (dev->xy_acc[i] < 0)
 			dev->xy_acc[i] = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	memcpy(dev->xy_old, dev->xy_cur, sizeof(dev->xy_old));
@@ -615,14 +670,36 @@ static void atp_complete_geyser_3_4(stru
 	 */
 
 	/* read X values */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 19; i < 20; i += 2, j += 3) {
 		dev->xy_cur[i] = dev->data[j + 1];
 		dev->xy_cur[i + 1] = dev->data[j + 2];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* read Y values */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 1; i < 9; i += 2, j += 3) {
 		dev->xy_cur[ATP_XSENSORS + i] = dev->data[j + 1];
 		dev->xy_cur[ATP_XSENSORS + i + 1] = dev->data[j + 2];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dbg_dump("sample", dev->xy_cur);
@@ -636,6 +713,11 @@ static void atp_complete_geyser_3_4(stru
 		goto exit;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ATP_XSENSORS + ATP_YSENSORS; i++) {
 		/* calculate the change */
 		dev->xy_acc[i] = dev->xy_cur[i] - dev->xy_old[i];
@@ -650,6 +732,12 @@ static void atp_complete_geyser_3_4(stru
 		/* prevent down drifting */
 		if (dev->xy_acc[i] < 0)
 			dev->xy_acc[i] = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	dbg_dump("accumulator", dev->xy_acc);
diff -u -p a/input/mouse/psmouse-base.c b/input/mouse/psmouse-base.c
--- a/input/mouse/psmouse-base.c
+++ b/input/mouse/psmouse-base.c
@@ -392,10 +392,21 @@ int psmouse_sliced_command(struct psmous
 	if (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11))
 		return -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 6; i >= 0; i -= 2) {
 		unsigned char d = (command >> i) & 3;
 		if (ps2_command(&psmouse->ps2dev, &d, PSMOUSE_CMD_SETRES))
 			return -1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -544,9 +555,20 @@ static int thinking_detect(struct psmous
 	ps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);
 	param[0] = 0;
 	ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(seq); i++) {
 		param[0] = seq[i];
 		ps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ps2_command(ps2dev, param, PSMOUSE_CMD_GETID);
 
@@ -910,12 +932,23 @@ static const struct psmouse_protocol *ps
 	const struct psmouse_protocol *p;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(psmouse_protocols); i++) {
 		p = &psmouse_protocols[i];
 
 		if ((strlen(p->name) == len && !strncmp(p->name, name, len)) ||
 		    (strlen(p->alias) == len && !strncmp(p->alias, name, len)))
 			return &psmouse_protocols[i];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NULL;
diff -u -p a/input/mouse/gpio_mouse.c b/input/mouse/gpio_mouse.c
--- a/input/mouse/gpio_mouse.c
+++ b/input/mouse/gpio_mouse.c
@@ -66,6 +66,11 @@ static int __devinit gpio_mouse_probe(st
 		goto out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GPIO_MOUSE_PIN_MAX; i++) {
 		pin = pdata->pins[i];
 
@@ -92,6 +97,12 @@ static int __devinit gpio_mouse_probe(st
 
 			gpio_direction_input(pin);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_poll = input_allocate_polled_device();
@@ -159,10 +170,21 @@ static int __devexit gpio_mouse_remove(s
 	input_unregister_polled_device(input);
 	input_free_polled_device(input);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < GPIO_MOUSE_PIN_MAX; i++) {
 		pin = pdata->pins[i];
 		if (pin >= 0)
 			gpio_free(pin);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	platform_set_drvdata(pdev, NULL);
diff -u -p a/input/mouse/vsxxxaa.c b/input/mouse/vsxxxaa.c
--- a/input/mouse/vsxxxaa.c
+++ b/input/mouse/vsxxxaa.c
@@ -186,6 +186,11 @@ static int vsxxxaa_check_packet(struct v
 	}
 
 	/* Check all following bytes */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < packet_len; i++) {
 		if (IS_HDR_BYTE(mouse->buf[i])) {
 			printk(KERN_ERR
@@ -195,6 +200,12 @@ static int vsxxxaa_check_packet(struct v
 			    packet_len, i, mouse->buf[i]);
 			return i - 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/input/mouse/elantech.c b/input/mouse/elantech.c
--- a/input/mouse/elantech.c
+++ b/input/mouse/elantech.c
@@ -482,11 +482,22 @@ static void process_packet_status_v4(str
 
 	/* notify finger state change */
 	fingers = packet[1] & 0x1f;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ETP_MAX_FINGERS; i++) {
 		if ((fingers & (1 << i)) == 0) {
 			input_mt_slot(dev, i);
 			input_mt_report_slot_state(dev, MT_TOOL_FINGER, false);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	elantech_input_sync_v4(psmouse);
diff -u -p a/input/mouse/hgpk.c b/input/mouse/hgpk.c
--- a/input/mouse/hgpk.c
+++ b/input/mouse/hgpk.c
@@ -94,10 +94,21 @@ static int hgpk_mode_from_name(const cha
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(hgpk_mode_names); i++) {
 		const char *name = hgpk_mode_names[i];
 		if (strlen(name) == len && !strncasecmp(name, buf, len))
 			return i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return HGPK_MODE_INVALID;
diff -u -p a/input/touchscreen/usbtouchscreen.c b/input/touchscreen/usbtouchscreen.c
--- a/input/touchscreen/usbtouchscreen.c
+++ b/input/touchscreen/usbtouchscreen.c
@@ -781,6 +781,11 @@ static int nexio_init(struct usbtouch_us
 	int input_ep = 0, output_ep = 0;
 
 	/* find first input and output endpoint */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < interface->desc.bNumEndpoints; i++) {
 		if (!input_ep &&
 		    usb_endpoint_dir_in(&interface->endpoint[i].desc))
@@ -788,6 +793,12 @@ static int nexio_init(struct usbtouch_us
 		if (!output_ep &&
 		    usb_endpoint_dir_out(&interface->endpoint[i].desc))
 			output_ep = interface->endpoint[i].desc.bEndpointAddress;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!input_ep || !output_ep)
 		return -ENXIO;
@@ -797,12 +808,23 @@ static int nexio_init(struct usbtouch_us
 		goto out_buf;
 
 	/* two empty reads */
-	for (i = 0; i < 2; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 2; i++) {
 		ret = usb_bulk_msg(dev, usb_rcvbulkpipe(dev, input_ep),
 				   buf, NEXIO_BUFSIZE, &actual_len,
 				   NEXIO_TIMEOUT);
 		if (ret < 0)
 			goto out_buf;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* send init command */
@@ -814,7 +836,12 @@ static int nexio_init(struct usbtouch_us
 		goto out_buf;
 
 	/* read replies */
-	for (i = 0; i < 3; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 3; i++) {
 		memset(buf, 0, NEXIO_BUFSIZE);
 		ret = usb_bulk_msg(dev, usb_rcvbulkpipe(dev, input_ep),
 				   buf, NEXIO_BUFSIZE, &actual_len,
@@ -831,6 +858,12 @@ static int nexio_init(struct usbtouch_us
 				device_name = kstrdup(&buf[2], GFP_NOIO);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_INFO "Nexio device: %s, firmware version: %s\n",
@@ -896,6 +929,11 @@ static int nexio_read_data(struct usbtou
 	 * it's disabled (and untested) here as there's no X driver for that.
 	 */
 	begin_x = end_x = begin_y = end_y = -1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (x = 0; x < x_len; x++) {
 		if (begin_x == -1 && packet->data[x] > NEXIO_THRESHOLD) {
 			begin_x = x;
@@ -903,6 +941,11 @@ static int nexio_read_data(struct usbtou
 		}
 		if (end_x == -1 && begin_x != -1 && packet->data[x] < NEXIO_THRESHOLD) {
 			end_x = x - 1;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (y = x_len; y < data_len; y++) {
 				if (begin_y == -1 && packet->data[y] > NEXIO_THRESHOLD) {
 					begin_y = y - x_len;
@@ -934,10 +977,22 @@ static int nexio_read_data(struct usbtou
 					begin_y = end_y = -1;
 					return 1;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			begin_x = end_x = -1;
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/input/touchscreen/wacom_w8001.c b/input/touchscreen/wacom_w8001.c
--- a/input/touchscreen/wacom_w8001.c
+++ b/input/touchscreen/wacom_w8001.c
@@ -148,6 +148,11 @@ static void parse_multi_touch(struct w80
 	int i;
 	int count = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		bool touch = data[0] & (1 << i);
 
@@ -165,6 +170,12 @@ static void parse_multi_touch(struct w80
 			input_report_abs(dev, ABS_MT_POSITION_Y, y);
 			count++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* emulate single touch events when stylus is out of proximity.
diff -u -p a/input/touchscreen/ad7879-spi.c b/input/touchscreen/ad7879-spi.c
--- a/input/touchscreen/ad7879-spi.c
+++ b/input/touchscreen/ad7879-spi.c
@@ -84,6 +84,11 @@ static int ad7879_spi_xfer(struct spi_de
 	spi_message_add_tail(&xfers[0], &msg);
 	++xfers;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < count; ++idx) {
 		if (rx_buf)
 			xfers[idx].rx_buf = &rx_buf[idx];
@@ -91,6 +96,12 @@ static int ad7879_spi_xfer(struct spi_de
 			xfers[idx].tx_buf = &tx_buf[idx];
 		xfers[idx].len = 2;
 		spi_message_add_tail(&xfers[idx], &msg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = spi_sync(spi, &msg);
diff -u -p a/input/touchscreen/wm831x-ts.c b/input/touchscreen/wm831x-ts.c
--- a/input/touchscreen/wm831x-ts.c
+++ b/input/touchscreen/wm831x-ts.c
@@ -115,6 +115,11 @@ static irqreturn_t wm831x_ts_data_irq(in
 	 * individual reading does so.
 	 */
 	wm831x_ts->pen_down = true;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i++) {
 		if (!(data[i] & WM831X_TCH_PD)) {
 			wm831x_ts->pen_down = false;
@@ -122,6 +127,12 @@ static irqreturn_t wm831x_ts_data_irq(in
 		}
 		input_report_abs(wm831x_ts->input_dev, data_types[i],
 				 data[i] & WM831X_TCH_DATA_MASK);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!wm831x_ts->pen_down) {
diff -u -p a/input/touchscreen/ad7877.c b/input/touchscreen/ad7877.c
--- a/input/touchscreen/ad7877.c
+++ b/input/touchscreen/ad7877.c
@@ -673,12 +673,23 @@ static void ad7877_setup_ts_def_msg(stru
 
 	spi_message_add_tail(&ts->xfer[1], m);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < AD7877_NR_SENSE; i++) {
 		ts->xfer[i + 2].rx_buf = &ts->conversion_data[AD7877_SEQ_YPOS + i];
 		ts->xfer[i + 2].len = 2;
 		if (i < (AD7877_NR_SENSE - 1))
 			ts->xfer[i + 2].cs_change = 1;
 		spi_message_add_tail(&ts->xfer[i + 2], m);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/input/touchscreen/max11801_ts.c b/input/touchscreen/max11801_ts.c
--- a/input/touchscreen/max11801_ts.c
+++ b/input/touchscreen/max11801_ts.c
@@ -121,6 +121,11 @@ static irqreturn_t max11801_ts_interrupt
 		if (ret < XY_BUFSIZE)
 			goto out;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < XY_BUFSIZE; i += XY_BUFSIZE / 2) {
 			if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_X_TAG)
 				x = (buf[i] << XY_BUF_OFFSET) +
@@ -128,6 +133,12 @@ static irqreturn_t max11801_ts_interrupt
 			else if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_Y_TAG)
 				y = (buf[i] << XY_BUF_OFFSET) +
 				    (buf[i + 1] >> XY_BUF_OFFSET);
+				    if (_cur < timeout) {
+				    		rdstcll(_cur);
+				    }
+				    else {
+					break;
+			}
 		}
 
 		if ((buf[1] & EVENT_TAG_MASK) != (buf[3] & EVENT_TAG_MASK))
diff -u -p a/input/touchscreen/st1232.c b/input/touchscreen/st1232.c
--- a/input/touchscreen/st1232.c
+++ b/input/touchscreen/st1232.c
@@ -106,6 +106,11 @@ static irqreturn_t st1232_ts_irq_handler
 		goto end;
 
 	/* multi touch protocol */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_FINGERS; i++) {
 		if (!finger[i].is_valid)
 			continue;
@@ -115,6 +120,12 @@ static irqreturn_t st1232_ts_irq_handler
 		input_report_abs(input_dev, ABS_MT_POSITION_Y, finger[i].y);
 		input_mt_sync(input_dev);
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* SYN_MT_REPORT only if no contact */
diff -u -p a/input/touchscreen/bu21013_ts.c b/input/touchscreen/bu21013_ts.c
--- a/input/touchscreen/bu21013_ts.c
+++ b/input/touchscreen/bu21013_ts.c
@@ -167,12 +167,23 @@ static int bu21013_read_block_data(struc
 {
 	int ret, i;
 
-	for (i = 0; i < I2C_RETRY_COUNT; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < I2C_RETRY_COUNT; i++) {
 		ret = i2c_smbus_read_i2c_block_data
 			(data->client, BU21013_SENSORS_BTN_0_7_REG,
 				LENGTH_OF_BUFFER, buf);
 		if (ret == LENGTH_OF_BUFFER)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return -EINVAL;
 }
@@ -204,6 +215,11 @@ static int bu21013_do_touch_report(struc
 	if (!has_x_sensors || !has_y_sensors)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_FINGERS; i++) {
 		const u8 *p = &buf[4 * i + 3];
 		unsigned int x = p[0] << SHIFT_2 | (p[1] & MASK_BITS);
@@ -213,6 +229,12 @@ static int bu21013_do_touch_report(struc
 		pos_x[finger_down_count] = x;
 		pos_y[finger_down_count] = y;
 		finger_down_count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (finger_down_count) {
@@ -222,6 +244,11 @@ static int bu21013_do_touch_report(struc
 			return 0;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < finger_down_count; i++) {
 			if (data->chip->x_flip)
 				pos_x[i] = data->chip->touch_x_max - pos_x[i];
@@ -233,6 +260,12 @@ static int bu21013_do_touch_report(struc
 			input_report_abs(data->in_dev,
 					 ABS_MT_POSITION_Y, pos_y[i]);
 			input_mt_sync(data->in_dev);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	} else
 		input_mt_sync(data->in_dev);
diff -u -p a/input/touchscreen/elo.c b/input/touchscreen/elo.c
--- a/input/touchscreen/elo.c
+++ b/input/touchscreen/elo.c
@@ -238,10 +238,21 @@ static int elo_command_10(struct elo *el
 	if (serio_write(elo->serio, ELO10_LEAD_BYTE))
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ELO10_PACKET_LEN; i++) {
 		csum += packet[i];
 		if (serio_write(elo->serio, packet[i]))
 			goto out;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	if (serio_write(elo->serio, csum))
diff -u -p a/input/touchscreen/atmel_mxt_ts.c b/input/touchscreen/atmel_mxt_ts.c
--- a/input/touchscreen/atmel_mxt_ts.c
+++ b/input/touchscreen/atmel_mxt_ts.c
@@ -460,10 +460,21 @@ mxt_get_object(struct mxt_data *data, u8
 	struct mxt_object *object;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < data->info.object_num; i++) {
 		object = data->object_table + i;
 		if (object->type == type)
 			return object;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	dev_err(&data->client->dev, "Invalid object type\n");
@@ -521,7 +532,12 @@ static void mxt_input_report(struct mxt_
 	int finger_num = 0;
 	int id;
 
-	for (id = 0; id < MXT_MAX_FINGER; id++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (id = 0; id < MXT_MAX_FINGER; id++) {
 		if (!finger[id].status)
 			continue;
 
@@ -542,6 +558,12 @@ static void mxt_input_report(struct mxt_
 		} else {
 			finger[id].status = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_report_key(input_dev, BTN_TOUCH, finger_num > 0);
@@ -657,12 +679,22 @@ static int mxt_check_reg_init(struct mxt
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < data->info.object_num; i++) {
 		object = data->object_table + i;
 
 		if (!mxt_object_writable(object->type))
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0;
 		     j < (object->size + 1) * (object->instances + 1);
 		     j++) {
@@ -673,8 +705,20 @@ static int mxt_check_reg_init(struct mxt
 			}
 			mxt_write_object(data, object->type, j,
 					 pdata->config[config_offset]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		index += (object->size + 1) * (object->instances + 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -793,6 +837,11 @@ static int mxt_get_object_table(struct m
 	u8 reportid = 0;
 	u8 buf[MXT_OBJECT_SIZE];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < data->info.object_num; i++) {
 		struct mxt_object *object = data->object_table + i;
 
@@ -812,6 +861,12 @@ static int mxt_get_object_table(struct m
 					(object->instances + 1);
 			object->max_reportid = reportid;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -907,6 +962,11 @@ static ssize_t mxt_object_show(struct de
 	int error;
 	u8 val;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < data->info.object_num; i++) {
 		object = data->object_table + i;
 
@@ -924,7 +984,12 @@ static ssize_t mxt_object_show(struct de
 			continue;
 		}
 
-		for (j = 0; j < object->size + 1; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (j = 0; j < object->size + 1; j++) {
 			error = mxt_read_object(data,
 						object->type, j, &val);
 			if (error)
@@ -934,11 +999,23 @@ static ssize_t mxt_object_show(struct de
 					"\t[%2d]: %02x (%d)\n", j, val, val);
 			if (count >= PAGE_SIZE)
 				return PAGE_SIZE - 1;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 
 		count += snprintf(buf + count, PAGE_SIZE - count, "\n");
 		if (count >= PAGE_SIZE)
 			return PAGE_SIZE - 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return count;
diff -u -p a/input/touchscreen/intel-mid-touch.c b/input/touchscreen/intel-mid-touch.c
--- a/input/touchscreen/intel-mid-touch.c
+++ b/input/touchscreen/intel-mid-touch.c
@@ -179,9 +179,20 @@ static int mrstouch_ts_bias_set(uint off
 	chan = PMICADDR0 + offset;
 	start = MRST_TS_CHAN10;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; count <= 3; count++) {
 		reg[count] = chan++;
 		data[count] = bias | (start + count);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return intel_scu_ipc_writev(reg, data, 4);
@@ -255,9 +266,20 @@ static int mrstouch_fs_adc_read_prepare(
 	chan = PMICADDR0 + tsdev->asr;
 
 	/* Set X BIAS */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; count <= 3; count++) {
 		reg[count] = chan++;
 		data[count] = 0x2A;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	reg[count] =  chan++; /* Dummy */
 	data[count] = 0;
@@ -269,9 +291,20 @@ static int mrstouch_fs_adc_read_prepare(
 	msleep(WAIT_ADC_COMPLETION);
 
 	/* Set Y BIAS */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; count <= 3; count++) {
 		reg[count] = chan++;
 		data[count] = 0x4A;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	reg[count] = chan++; /* Dummy */
 	data[count] = 0;
@@ -351,17 +384,39 @@ static int mrstouch_fs_adc_read_finish(s
 
 	/* Clear all TS channels */
 	chan = PMICADDR0 + tsdev->asr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; count <= 4; count++) {
 		reg[count] = chan++;
 		data[count] = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	err = intel_scu_ipc_writev(reg, data, 5);
 	if (err)
 		goto ipc_error;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; count <= 4; count++) {
 		reg[count] = chan++;
 		data[count] = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	err = intel_scu_ipc_writev(reg, data, 5);
 	if (err)
@@ -485,10 +540,21 @@ static int __devinit mrstouch_ts_chan_se
 	int ret, count;
 
 	chan = PMICADDR0 + offset;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; count <= 3; count++) {
 		ret = intel_scu_ipc_iowrite8(chan++, MRST_TS_CHAN10 + count);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return intel_scu_ipc_iowrite8(chan++, END_OF_CHANNEL);
 }
diff -u -p a/input/touchscreen/penmount.c b/input/touchscreen/penmount.c
--- a/input/touchscreen/penmount.c
+++ b/input/touchscreen/penmount.c
@@ -72,7 +72,12 @@ static void pm_mtevent(struct pm *pm, st
 {
 	int i;
 
-	for (i = 0; i < pm->maxcontacts; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < pm->maxcontacts; ++i) {
 		input_mt_slot(input, i);
 		input_mt_report_slot_state(input, MT_TOOL_FINGER,
 				pm->slots[i].active);
@@ -80,6 +85,12 @@ static void pm_mtevent(struct pm *pm, st
 			input_event(input, EV_ABS, ABS_MT_POSITION_X, pm->slots[i].x);
 			input_event(input, EV_ABS, ABS_MT_POSITION_Y, pm->slots[i].y);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_mt_report_pointer_emulation(input, true);
diff -u -p a/input/joydev.c b/input/joydev.c
--- a/input/joydev.c
+++ b/input/joydev.c
@@ -475,11 +475,22 @@ static int joydev_handle_JSIOCSAXMAP(str
 		goto out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < joydev->nabs; i++) {
 		if (abspam[i] > ABS_MAX) {
 			retval = -EINVAL;
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	memcpy(joydev->abspam, abspam, len);
@@ -511,11 +522,22 @@ static int joydev_handle_JSIOCSBTNMAP(st
 		goto out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < joydev->nkey; i++) {
 		if (keypam[i] > KEY_MAX || keypam[i] < BTN_MISC) {
 			retval = -EINVAL;
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	memcpy(joydev->keypam, keypam, len);
@@ -568,9 +590,20 @@ static int joydev_ioctl_common(struct jo
 			      sizeof(joydev->corr[0]) * joydev->nabs))
 			return -EFAULT;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < joydev->nabs; i++) {
 			int val = input_abs_get_val(dev, joydev->abspam[i]);
 			joydev->abs[i] = joydev_correct(val, &joydev->corr[i]);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		return 0;
 
@@ -850,6 +883,11 @@ static int joydev_connect(struct input_h
 			joydev->nkey++;
 		}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < joydev->nabs; i++) {
 		j = joydev->abspam[i];
 		if (input_abs_get_max(dev, j) == input_abs_get_min(dev, j)) {
@@ -874,6 +912,12 @@ static int joydev_connect(struct input_h
 				joydev_correct(input_abs_get_val(dev, j),
 					       joydev->corr + i);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	joydev->dev.devt = MKDEV(INPUT_MAJOR, JOYDEV_MINOR_BASE + minor);
diff -u -p a/lguest/segments.c b/lguest/segments.c
--- a/lguest/segments.c
+++ b/lguest/segments.c
@@ -68,6 +68,11 @@ static void fixup_gdt_table(struct lg_cp
 {
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i < end; i++) {
 		/*
 		 * We never copy these ones to real GDT, so we don't care what
@@ -91,6 +96,12 @@ static void fixup_gdt_table(struct lg_cp
 		 * writable by the Guest, so bad things can happen.
 		 */
 		cpu->arch.gdt[i].b |= 0x00000100;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/lguest/interrupts_and_traps.c b/lguest/interrupts_and_traps.c
--- a/lguest/interrupts_and_traps.c
+++ b/lguest/interrupts_and_traps.c
@@ -573,6 +573,11 @@ void copy_traps(const struct lg_cpu *cpu
 	 * We can simply copy the direct traps, otherwise we use the default
 	 * ones in the Switcher: they will return to the Host.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(cpu->arch.idt); i++) {
 		const struct desc_struct *gidt = &cpu->arch.idt[i];
 
@@ -594,6 +599,12 @@ void copy_traps(const struct lg_cpu *cpu
 			idt[i] = *gidt;
 		else
 			default_idt_entry(&idt[i], i, def[i], gidt);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/lguest/lguest_user.c b/lguest/lguest_user.c
--- a/lguest/lguest_user.c
+++ b/lguest/lguest_user.c
@@ -466,6 +466,11 @@ static int close(struct inode *inode, st
 	/* Free up the shadow page tables for the Guest. */
 	free_guest_pagetable(lg);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < lg->nr_cpus; i++) {
 		/* Cancels the hrtimer set via LHCALL_SET_CLOCKEVENT. */
 		hrtimer_cancel(&lg->cpus[i].hrt);
@@ -476,6 +481,12 @@ static int close(struct inode *inode, st
 		 * the Launcher's memory management structure.
 		 */
 		mmput(lg->cpus[i].mm);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Release any eventfds they registered. */
diff -u -p a/lguest/core.c b/lguest/core.c
--- a/lguest/core.c
+++ b/lguest/core.c
@@ -67,12 +67,23 @@ static __init int map_switcher(void)
 	 * Now we actually allocate the pages.  The Guest will see these pages,
 	 * so we make sure they're zeroed.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < TOTAL_SWITCHER_PAGES; i++) {
 		switcher_page[i] = alloc_page(GFP_KERNEL|__GFP_ZERO);
 		if (!switcher_page[i]) {
 			err = -ENOMEM;
 			goto free_some_pages;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/lguest/page_tables.c b/lguest/page_tables.c
--- a/lguest/page_tables.c
+++ b/lguest/page_tables.c
@@ -1092,9 +1092,20 @@ static __init void populate_switcher_pte
 	pte_t *pte = switcher_pte_page(cpu);
 
 	/* The first entries are easy: they map the Switcher code. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pages; i++) {
 		set_pte(&pte[i], mk_pte(switcher_page[i],
 				__pgprot(_PAGE_PRESENT|_PAGE_ACCESSED)));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* The only other thing we map is this CPU's pair of pages. */
diff -u -p a/lguest/lguest_device.c b/lguest/lguest_device.c
--- a/lguest/lguest_device.c
+++ b/lguest/lguest_device.c
@@ -143,9 +143,20 @@ static void lg_finalize_features(struct
 	 */
 	memset(out_features, 0, desc->feature_len);
 	bits = min_t(unsigned, desc->feature_len, sizeof(vdev->features)) * 8;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bits; i++) {
 		if (test_bit(i, vdev->features))
 			out_features[i / 8] |= (1 << (i % 8));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* Tell Host we've finished with this device's feature negotiation */
@@ -369,10 +380,21 @@ static int lg_find_vqs(struct virtio_dev
 	if (nvqs > ldev->desc->num_vq)
 		return -ENOENT;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nvqs; ++i) {
 		vqs[i] = lg_find_vq(vdev, i, callbacks[i], names[i]);
 		if (IS_ERR(vqs[i]))
 			goto error;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 
diff -u -p a/w1/w1_io.c b/w1/w1_io.c
--- a/w1/w1_io.c
+++ b/w1/w1_io.c
@@ -140,11 +140,23 @@ void w1_write_8(struct w1_master *dev, u
 		w1_pre_write(dev);
 		dev->bus_master->write_byte(dev->bus_master->data, byte);
 	}
-	else
-		for (i = 0; i < 8; ++i) {
-			if (i == 7)
-				w1_pre_write(dev);
-			w1_touch_bit(dev, (byte >> i) & 0x1);
+	else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < 8; ++i) {
+				if (i == 7)
+					w1_pre_write(dev);
+				w1_touch_bit(dev, (byte >> i) & 0x1);
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
+			}
 		}
 	w1_post_write(dev);
 }
@@ -271,15 +283,37 @@ void w1_touch_block(struct w1_master *de
 	int i, j;
 	u8 tmp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; ++i) {
 		tmp = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 8; ++j) {
 			if (j == 7)
 				w1_pre_write(dev);
 			tmp |= w1_touch_bit(dev, (buf[i] >> j) & 0x1) << j;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		buf[i] = tmp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(w1_touch_block);
diff -u -p a/w1/slaves/w1_therm.c b/w1/slaves/w1_therm.c
--- a/w1/slaves/w1_therm.c
+++ b/w1/slaves/w1_therm.c
@@ -241,10 +241,21 @@ static int __init w1_therm_init(void)
 {
 	int err, i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(w1_therm_families); ++i) {
 		err = w1_register_family(w1_therm_families[i].f);
 		if (err)
 			w1_therm_families[i].broken = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/w1/slaves/w1_ds2423.c b/w1/slaves/w1_ds2423.c
--- a/w1/slaves/w1_ds2423.c
+++ b/w1/slaves/w1_ds2423.c
@@ -70,7 +70,12 @@ static ssize_t w1_counter_read(struct de
 	if (!w1_reset_select_slave(sl)) {
 		w1_write_block(dev, wrbuf, 3);
 		read_byte_count = 0;
-		for (p = 0; p < 4; p++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (p = 0; p < 4; p++) {
 			/*
 			 * 1 byte for first bytes in ram page read
 			 * 4 bytes for counter
@@ -108,10 +113,21 @@ static ssize_t w1_counter_read(struct de
 				}
 				if (crc == CRC16_VALID) {
 					result = 0;
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					for (ii = 4; ii > 0; ii--) {
 						result <<= 8;
 						result |= rbuf[(p *
 							READ_BYTE_COUNT) + ii];
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
 					}
 					c -= snprintf(out_buf + PAGE_SIZE - c,
 						c, "crc=YES c=%d\n", result);
@@ -120,6 +136,12 @@ static ssize_t w1_counter_read(struct de
 						c, "crc=NO\n");
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		c -= snprintf(out_buf + PAGE_SIZE - c, c, "Connection error");
diff -u -p a/w1/slaves/w1_ds2433.c b/w1/slaves/w1_ds2433.c
--- a/w1/slaves/w1_ds2433.c
+++ b/w1/slaves/w1_ds2433.c
@@ -113,11 +113,22 @@ static ssize_t w1_f23_read_bin(struct fi
 
 	min_page = (off >> W1_PAGE_BITS);
 	max_page = (off + count - 1) >> W1_PAGE_BITS;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = min_page; i <= max_page; i++) {
 		if (w1_f23_refresh_block(sl, data, i)) {
 			count = -EIO;
 			goto out_up;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	memcpy(buf, &data->memory[off], count);
 
@@ -225,11 +236,22 @@ static ssize_t w1_f23_write_bin(struct f
 	}
 
 	/* make sure the block CRCs are valid */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < count; idx += W1_PAGE_SIZE) {
 		if (crc16(CRC16_INIT, &buf[idx], W1_PAGE_SIZE) != CRC16_VALID) {
 			dev_err(&sl->dev, "bad CRC at offset %d\n", (int)off);
 			return -EINVAL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 #endif	/* CONFIG_W1_SLAVE_DS2433_CRC */
 
diff -u -p a/w1/masters/ds2490.c b/w1/masters/ds2490.c
--- a/w1/masters/ds2490.c
+++ b/w1/masters/ds2490.c
@@ -291,6 +291,11 @@ static void ds_dump_status(struct ds_dev
 		ds_print_msg(buf, "reserved", 14);
 		ds_print_msg(buf, "reserved", 15);
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 16; i < count; ++i) {
 		if (buf[i] == RR_DETECT) {
 			ds_print_msg(buf, "new device detect", i);
@@ -313,6 +318,12 @@ static void ds_dump_status(struct ds_dev
 			printk(KERN_INFO "RDP: redirected page\n");
 		if (buf[i] & RR_EOS)
 			printk(KERN_INFO "EOS: end of search error\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -952,7 +963,12 @@ static int ds_probe(struct usb_interface
 	 * This loop doesn'd show control 0 endpoint,
 	 * so we will fill only 1-3 endpoints entry.
 	 */
-	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
 		endpoint = &iface_desc->endpoint[i].desc;
 
 		dev->ep[i+1] = endpoint->bEndpointAddress;
@@ -962,6 +978,12 @@ static int ds_probe(struct usb_interface
 			(endpoint->bEndpointAddress & USB_DIR_IN)?"IN":"OUT",
 			endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);
 #endif
+if (_cur < timeout) {
+		rdstcll(_cur);
+}
+else {
+		break;
+		}
 	}
 
 	err = ds_w1_init(dev);
diff -u -p a/w1/masters/ds2482.c b/w1/masters/ds2482.c
--- a/w1/masters/ds2482.c
+++ b/w1/masters/ds2482.c
@@ -457,6 +457,11 @@ static int ds2482_probe(struct i2c_clien
 	mutex_init(&data->access_lock);
 
 	/* Register 1-wire interface(s) */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < data->w1_count; idx++) {
 		data->w1_ch[idx].pdev = data;
 		data->w1_ch[idx].channel = idx;
@@ -474,14 +479,31 @@ static int ds2482_probe(struct i2c_clien
 			data->w1_ch[idx].pdev = NULL;
 			goto exit_w1_remove;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
 
 exit_w1_remove:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < data->w1_count; idx++) {
 		if (data->w1_ch[idx].pdev != NULL)
 			w1_remove_master_device(&data->w1_ch[idx].w1_bm);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 exit_free:
 	kfree(data);
@@ -495,9 +517,20 @@ static int ds2482_remove(struct i2c_clie
 	int idx;
 
 	/* Unregister the 1-wire bridge(s) */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < data->w1_count; idx++) {
 		if (data->w1_ch[idx].pdev != NULL)
 			w1_remove_master_device(&data->w1_ch[idx].w1_bm);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* Free the memory */
diff -u -p a/uwb/i1480/dfu/usb.c b/uwb/i1480/dfu/usb.c
--- a/uwb/i1480/dfu/usb.c
+++ b/uwb/i1480/dfu/usb.c
@@ -160,6 +160,11 @@ int i1480_usb_read(struct i1480 *i1480,
 	if (addr >= 0x8000d200 && addr < 0x8000d400)	/* Yeah, HW quirk */
 		read_size = 4;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (itr = 0; itr < size; itr += read_size) {
 		size_t itr_addr = addr + itr;
 		size_t itr_size = min(read_size, size - itr);
@@ -182,6 +187,12 @@ int i1480_usb_read(struct i1480 *i1480,
 			goto out;
 		}
 		bytes += result;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	result = bytes;
 out:
diff -u -p a/uwb/i1480/dfu/phy.c b/uwb/i1480/dfu/phy.c
--- a/uwb/i1480/dfu/phy.c
+++ b/uwb/i1480/dfu/phy.c
@@ -112,9 +112,20 @@ int i1480_mpi_read(struct i1480 *i1480,
 	cmd->rccb.bCommandType = i1480_CET_VS1;
 	cmd->rccb.wCommand = cpu_to_le16(i1480_CMD_MPI_READ);
 	cmd->size = cpu_to_le16(3*size);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < size; cnt++) {
 		cmd->data[cnt].page = (srcaddr + cnt) >> 8;
 		cmd->data[cnt].offset = (srcaddr + cnt) & 0xff;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	reply->rceb.bEventType = i1480_CET_VS1;
 	reply->rceb.wEvent = i1480_CMD_MPI_READ;
@@ -127,6 +138,11 @@ int i1480_mpi_read(struct i1480 *i1480,
 			reply->bResultCode);
 		result = -EIO;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < size; cnt++) {
 		if (reply->data[cnt].page != (srcaddr + cnt) >> 8)
 			dev_err(i1480->dev, "MPI-READ: page inconsistency at "
@@ -138,6 +154,12 @@ int i1480_mpi_read(struct i1480 *i1480,
 				(srcaddr + cnt) & 0x00ff,
 				reply->data[cnt].offset);
 		data[cnt] = reply->data[cnt].value;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	result = 0;
 out:
@@ -172,12 +194,23 @@ int i1480_phy_fw_upload(struct i1480 *i1
 	if (result < 0)
 		goto out;
 	/* Loop writing data in chunks as big as possible until done. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (data_itr = fw->data, data_top = data_itr + fw->size;
 	     data_itr < data_top; data_itr += MAX_BLK_SIZE) {
 		data_size = min(MAX_BLK_SIZE, (size_t) (data_top - data_itr));
 		result = i1480_mpi_write(i1480, data_itr, data_size);
 		if (result < 0)
 			goto error_mpi_write;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	/* Read MPI page 0, offset 6; if 0, PHY was initialized correctly. */
 	result = i1480_mpi_read(i1480, &phy_stat, 0x0006, 1);
diff -u -p a/uwb/i1480/dfu/mac.c b/uwb/i1480/dfu/mac.c
--- a/uwb/i1480/dfu/mac.c
+++ b/uwb/i1480/dfu/mac.c
@@ -421,6 +421,11 @@ int i1480_fw_is_running_q(struct i1480 *
 	int result;
 	u32 *val = (u32 *) i1480->cmd_buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < 10; cnt++) {
 		msleep(100);
 		result = i1480->read(i1480, 0x80080000, 4);
@@ -430,6 +435,12 @@ int i1480_fw_is_running_q(struct i1480 *
 		}
 		if (*val == 0x55555555UL)	/* fw running? cool */
 			goto out;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	dev_err(i1480->dev, "Timed out waiting for fw to start\n");
 	result = -ETIMEDOUT;
diff -u -p a/uwb/allocator.c b/uwb/allocator.c
--- a/uwb/allocator.c
+++ b/uwb/allocator.c
@@ -28,11 +28,21 @@ static void uwb_rsv_fill_column_alloc(st
 	struct uwb_rsv_col_info *ci = ai->ci;
 	unsigned char c;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = ci->csi.start_col; col < UWB_NUM_ZONES; col += ci->csi.interval) {
     
 		safe_mas   = ci->csi.safe_mas_per_col;
 		unsafe_mas = ci->csi.unsafe_mas_per_col;
     
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (mas = 0; mas < UWB_MAS_PER_ZONE; mas++ ) {
 			if (bm[col * UWB_MAS_PER_ZONE + mas] == 0) {
 	
@@ -47,6 +57,18 @@ static void uwb_rsv_fill_column_alloc(st
 				}
 				bm[col * UWB_MAS_PER_ZONE + mas] = c;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
@@ -60,6 +82,11 @@ static void uwb_rsv_fill_row_alloc(struc
 
 	rows = 1;
 	c = UWB_RSV_MAS_SAFE;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mas = UWB_MAS_PER_ZONE - 1; mas >= 0; mas--) {
 		if (ri->avail[mas] == 1) {
       
@@ -69,6 +96,11 @@ static void uwb_rsv_fill_row_alloc(struc
 				c = UWB_RSV_MAS_UNSAFE;
 			}
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (col = 0; col < UWB_NUM_ZONES; col++) {
 				if (bm[col * UWB_NUM_ZONES + mas] != UWB_RSV_MAS_NOT_AVAIL) {
 					bm[col * UWB_NUM_ZONES + mas] = c;
@@ -77,9 +109,21 @@ static void uwb_rsv_fill_row_alloc(struc
 					else
 						ai->unsafe_allocated_mases++;
 				}
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 			rows++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ai->total_allocated_mases = ai->safe_allocated_mases + ai->unsafe_allocated_mases;
 }
@@ -149,14 +193,29 @@ static int uwb_rsv_find_best_column_set(
 	start_col_deep = interval;
 	n_mas = num_unsafe_mas + num_safe_mas;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (deep = 0; ((interval >> deep) & 0x1) == 0; deep++) {
 		start_col_deep /= 2;
 		col_start_set = 0;
 		lowest_max_mas_in_deep = UWB_MAS_PER_ZONE;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (set = 1; set <= (1 << deep); set++) {
 			max_mas_in_set = 0;
 			start_col = start_col_deep + col_start_set;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (col = start_col; col < UWB_NUM_ZONES; col += interval) {
                 
 				if (ci[col].max_avail_safe >= num_safe_mas &&
@@ -167,6 +226,12 @@ static int uwb_rsv_find_best_column_set(
 					max_mas_in_set = 0;
 					break;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if ((lowest_max_mas_in_deep > max_mas_in_set) && max_mas_in_set) {
 				lowest_max_mas_in_deep = max_mas_in_set;
@@ -174,6 +239,12 @@ static int uwb_rsv_find_best_column_set(
 				tmp_csi.start_col = start_col;
 			}
 			col_start_set += (interval >> deep);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (lowest_max_mas_in_deep < 8) {
@@ -186,6 +257,12 @@ static int uwb_rsv_find_best_column_set(
 			csi->start_col = tmp_csi.start_col;
 			found = UWB_RSV_ALLOC_FOUND;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (found == UWB_RSV_ALLOC_FOUND) {
@@ -208,6 +285,11 @@ static void get_row_descriptors(struct u
 	int col, mas;
   
 	ri->free_rows = 16;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mas = 0; mas < UWB_MAS_PER_ZONE; mas ++) {
 		ri->avail[mas] = 1;
 		for (col = 1; col < UWB_NUM_ZONES; col++) {
@@ -217,6 +299,12 @@ static void get_row_descriptors(struct u
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -232,6 +320,11 @@ static void uwb_rsv_fill_column_info(uns
 
 	rci->max_avail_safe = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mas = 0; mas < UWB_MAS_PER_ZONE; mas ++) {
 		if (!bm[column * UWB_NUM_ZONES + mas]) {
 			available++;
@@ -252,6 +345,12 @@ static void uwb_rsv_fill_column_info(uns
 		} else {
 			previous_avail = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!rci->max_avail_safe)
 		rci->max_avail_safe = rci->max_avail_unsafe;
@@ -263,8 +362,19 @@ static void get_column_descriptors(struc
 	struct uwb_rsv_col_info *ci = ai->ci;
 	int col;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = 1; col < UWB_NUM_ZONES; col++) {
 		uwb_rsv_fill_column_info(bm, col, &ci[col]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -275,6 +385,11 @@ static int uwb_rsv_find_best_row_alloc(s
 	int min_rows = ai->min_mas / UWB_USABLE_MAS_PER_ROW;
 	if (ai->min_mas % UWB_USABLE_MAS_PER_ROW)
 		min_rows++;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n_rows = max_rows; n_rows >= min_rows; n_rows--) {
 		if (n_rows <= ai->ri.free_rows) {
 			ai->ri.used_rows = n_rows;
@@ -282,6 +397,12 @@ static int uwb_rsv_find_best_row_alloc(s
 			uwb_rsv_fill_row_alloc(ai);
 			return UWB_RSV_ALLOC_FOUND;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}  
 	return UWB_RSV_ALLOC_NOT_FOUND;
 }
@@ -304,15 +425,37 @@ static int uwb_rsv_find_best_col_alloc(s
 		max_per_zone = UWB_MAS_PER_ZONE;
 	}
     
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n_mas = max_per_zone; n_mas >= min_per_zone; n_mas--) {
 		if (uwb_rsv_find_best_column_set(ai, interval, 0, n_mas) == UWB_RSV_ALLOC_NOT_FOUND)
 			continue;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (n_safe = n_mas; n_safe >= 0; n_safe--) {
 			n_unsafe = n_mas - n_safe;
 			if (uwb_rsv_find_best_column_set(ai, interval, n_safe, n_unsafe) == UWB_RSV_ALLOC_FOUND) {
 				uwb_rsv_fill_column_alloc(ai);
 				return UWB_RSV_ALLOC_FOUND;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 	return UWB_RSV_ALLOC_NOT_FOUND;
@@ -334,9 +477,20 @@ int uwb_rsv_find_best_allocation(struct
 
 
 	/* fill the not available vector from the available bm */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit_index = 0; bit_index < UWB_NUM_MAS; bit_index++) {
 		if (!test_bit(bit_index, available->bm))
 			ai->bm[bit_index] = UWB_RSV_MAS_NOT_AVAIL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ai->max_interval == 1) {
@@ -349,11 +503,22 @@ int uwb_rsv_find_best_allocation(struct
 
 	get_column_descriptors(ai);
         
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (interval = 16; interval >= 2; interval>>=1) {
 		if (interval > ai->max_interval)
 			continue;
 		if (uwb_rsv_find_best_col_alloc(ai, interval) == UWB_RSV_ALLOC_FOUND)
 			goto alloc_found;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	/* try row reservation if no column is found */
@@ -367,11 +532,22 @@ int uwb_rsv_find_best_allocation(struct
 	bitmap_zero(result->bm, UWB_NUM_MAS);
 	bitmap_zero(result->unsafe_bm, UWB_NUM_MAS);
 	/* fill the safe and unsafe bitmaps */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit_index = 0; bit_index < UWB_NUM_MAS; bit_index++) {
 		if (ai->bm[bit_index] == UWB_RSV_MAS_SAFE)
 			set_bit(bit_index, result->bm);
 		else if (ai->bm[bit_index] == UWB_RSV_MAS_UNSAFE)
 			set_bit(bit_index, result->unsafe_bm);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	bitmap_or(result->bm, result->bm, result->unsafe_bm, UWB_NUM_MAS);
 
diff -u -p a/uwb/est.c b/uwb/est.c
--- a/uwb/est.c
+++ b/uwb/est.c
@@ -444,7 +444,12 @@ ssize_t uwb_est_find_size(struct uwb_rc
 		goto out;
 	event = le16_to_cpu(rceb->wEvent);
 	type_event_high = rceb->bEventType << 8 | (event & 0xff00) >> 8;
-	for (itr = 0; itr < uwb_est_used; itr++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (itr = 0; itr < uwb_est_used; itr++) {
 		if (uwb_est[itr].type_event_high != type_event_high)
 			continue;
 		size = uwb_est_get_size(rc, &uwb_est[itr],
@@ -452,6 +457,12 @@ ssize_t uwb_est_find_size(struct uwb_rc
 		/* try more tables that might handle the same type */
 		if (size != -ENOENT)
 			goto out;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	dev_dbg(dev, "event 0x%02x/%04x/%02x: no handlers available; "
 		"RCEB %02x %02x %02x %02x\n",
diff -u -p a/uwb/drp-ie.c b/uwb/drp-ie.c
--- a/uwb/drp-ie.c
+++ b/uwb/drp-ie.c
@@ -152,6 +152,11 @@ static void uwb_drp_ie_from_bm(struct uw
 	bitmap_copy(tmp_bmp, mas->bm, UWB_NUM_MAS);
 
 	/* Determine unique MAS bitmaps in zones from bitmap. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (z = 0; z < UWB_NUM_ZONES; z++) {
 		bitmap_copy(tmp_mas_bm, tmp_bmp, UWB_MAS_PER_ZONE);
 		if (bitmap_weight(tmp_mas_bm, UWB_MAS_PER_ZONE) > 0) {
@@ -172,12 +177,29 @@ static void uwb_drp_ie_from_bm(struct uw
 			}
 		}
 		bitmap_shift_right(tmp_bmp, tmp_bmp, UWB_MAS_PER_ZONE, UWB_NUM_MAS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Store in format ready for transmission (le16). */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_fields; i++) {
 		drp_ie->allocs[i].zone_bm = cpu_to_le16(zones[i].zone_bm);
 		drp_ie->allocs[i].mas_bm = cpu_to_le16(zones[i].mas_bm);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	drp_ie->hdr.length = sizeof(struct uwb_ie_drp) - sizeof(struct uwb_ie_hdr)
@@ -271,10 +293,21 @@ void uwb_drp_ie_single_zone_to_bm(struct
 	int mas;
 	u16 mas_mask;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mas = 0; mas < UWB_MAS_PER_ZONE; mas++) {
 		mas_mask = 1 << mas;
 		if (mas_bm & mas_mask)
 			set_bit(zone * UWB_NUM_ZONES + mas, bm->bm);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -304,14 +337,36 @@ void uwb_drp_ie_to_bm(struct uwb_mas_bm
 
 	bitmap_zero(bm->bm, UWB_NUM_MAS);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < numallocs; cnt++) {
 		alloc = &drp_ie->allocs[cnt];
 		zone_bm = le16_to_cpu(alloc->zone_bm);
 		mas_bm = le16_to_cpu(alloc->mas_bm);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (zone = 0; zone < UWB_NUM_ZONES; zone++)   {
 			zone_mask = 1 << zone;
 			if (zone_bm & zone_mask)
 				uwb_drp_ie_single_zone_to_bm(bm, zone, mas_bm);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}
 }
diff -u -p a/uwb/whci.c b/uwb/whci.c
--- a/uwb/whci.c
+++ b/uwb/whci.c
@@ -193,6 +193,11 @@ static int whci_probe(struct pci_dev *pc
 		goto error_iomap;
 
 	/* Add each capability. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 0; n <= card->n_caps; n++) {
 		err = whci_add_cap(card, n);
 		if (err < 0 && n == 0) {
@@ -203,6 +208,12 @@ static int whci_probe(struct pci_dev *pc
 		if (err < 0)
 			dev_warn(&pci->dev, "warning: cannot bind capability "
 				 "#%u: %d\n", n, err);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	pci_set_drvdata(pci, card);
 	return 0;
diff -u -p a/video/vt8500lcdfb.c b/video/vt8500lcdfb.c
--- a/video/vt8500lcdfb.c
+++ b/video/vt8500lcdfb.c
@@ -106,11 +106,22 @@ static int vt8500lcd_set_par(struct fb_i
 					info->var.xres_virtual << 1;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		if (bpp_values[i] == info->var.bits_per_pixel) {
 			reg_bpp = i;
 			continue;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	control0 = readl(fbi->regbase) & ~0xf;
diff -u -p a/video/bf537-lq035.c b/video/bf537-lq035.c
--- a/video/bf537-lq035.c
+++ b/video/bf537-lq035.c
@@ -319,17 +319,39 @@ static int config_dma(void)
 
 	if (landscape) {
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < U_LINES; ++i) {
 			/* blanking lines point to first line of fb_buffer */
 			dma_desc_table[2*i] = (unsigned long)&dma_desc_table[2*i+2];
 			dma_desc_table[2*i+1] = (unsigned long)fb_buffer;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = U_LINES; i < U_LINES + LCD_Y_RES; ++i) {
 			/* visible lines */
 			dma_desc_table[2*i] = (unsigned long)&dma_desc_table[2*i+2];
 			dma_desc_table[2*i+1] = (unsigned long)fb_buffer +
 						(LCD_Y_RES+U_LINES-1-i)*2;
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
 		}
 
 		/* last descriptor points to first */
diff -u -p a/video/sis/sis_main.c b/video/sis/sis_main.c
--- a/video/sis/sis_main.c
+++ b/video/sis/sis_main.c
@@ -174,8 +174,19 @@ sisfb_search_mode(char *name, bool quiet
 
 	if(strlen(name) <= 19) {
 		strcpy(strbuf1, name);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(i = 0; i < strlen(strbuf1); i++) {
 			if(strbuf1[i] < '0' || strbuf1[i] > '9') strbuf1[i] = ' ';
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* This does some fuzzy mode naming detection */
@@ -378,6 +389,11 @@ sisfb_detect_custom_timing(struct sis_vi
 		    (mycustomttable[i].pcisubsysvendor == ivideo->subsysvendor) &&
 		    (mycustomttable[i].pcisubsyscard == ivideo->subsysdevice) ) {
 			footprint = true;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for(j = 0; j < 5; j++) {
 				if(mycustomttable[i].biosFootprintAddr[j]) {
 					if(ivideo->SiS_Pr.UseROM) {
@@ -388,6 +404,12 @@ sisfb_detect_custom_timing(struct sis_vi
 					} else
 						footprint = false;
 				}
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 			if(footprint) {
 				ivideo->SiS_Pr.SiS_CustomT = mycustomttable[i].SpecialID;
@@ -463,6 +485,11 @@ sisfb_interpret_edid(struct sisfb_monito
 	   monitor->vmin = 65535; monitor->vmax = 0;
 	   monitor->dclockmax = 0;
 	   emodes = buffer[0x23] | (buffer[0x24] << 8) | (buffer[0x25] << 16);
+	   unsigned long long delta = (cpu / khz / HZ) * 2;
+	   unsigned long long _start = 0;
+	   unsigned long long _cur = 0;
+	   unsigned long long timeout;
+	   timeout = rdstcll(start) + delta;
 	   for(i = 0; i < 13; i++) {
 	      if(emodes & sisfb_ddcsmodes[i].mask) {
 		 if(monitor->hmin > sisfb_ddcsmodes[i].h) monitor->hmin = sisfb_ddcsmodes[i].h;
@@ -471,8 +498,19 @@ sisfb_interpret_edid(struct sisfb_monito
 		 if(monitor->vmax < sisfb_ddcsmodes[i].v) monitor->vmax = sisfb_ddcsmodes[i].v;
 		 if(monitor->dclockmax < sisfb_ddcsmodes[i].d) monitor->dclockmax = sisfb_ddcsmodes[i].d;
 	      }
+	      if (_cur < timeout) {
+		 rdstcll(_cur);
+	      }
+	      else {
+		 break;
+	      }
 	   }
 	   index = 0x26;
+	   unsigned long long delta = (cpu / khz / HZ) * 2;
+	   unsigned long long _start = 0;
+	   unsigned long long _cur = 0;
+	   unsigned long long timeout;
+	   timeout = rdstcll(start) + delta;
 	   for(i = 0; i < 8; i++) {
 	      xres = (buffer[index] + 31) * 8;
 	      switch(buffer[index + 1] & 0xc0) {
@@ -483,6 +521,11 @@ sisfb_interpret_edid(struct sisfb_monito
 	      }
 	      refresh = (buffer[index + 1] & 0x3f) + 60;
 	      if((xres >= 640) && (yres >= 480)) {
+		 unsigned long long delta = (cpu / khz / HZ) * 2;
+		 unsigned long long _start = 0;
+		 unsigned long long _cur = 0;
+		 unsigned long long timeout;
+		 timeout = rdstcll(start) + delta;
 		 for(j = 0; j < 8; j++) {
 		    if((xres == sisfb_ddcfmodes[j].x) &&
 		       (yres == sisfb_ddcfmodes[j].y) &&
@@ -493,9 +536,21 @@ sisfb_interpret_edid(struct sisfb_monito
 		      if(monitor->vmax < sisfb_ddcsmodes[j].v) monitor->vmax = sisfb_ddcsmodes[j].v;
 		      if(monitor->dclockmax < sisfb_ddcsmodes[j].d) monitor->dclockmax = sisfb_ddcsmodes[j].d;
 		    }
+		    if (_cur < timeout) {
+		      rdstcll(_cur);
+		    }
+		    else {
+		      break;
+		    }
 		 }
 	      }
 	      index += 2;
+	      if (_cur < timeout) {
+		 rdstcll(_cur);
+	      }
+	      else {
+		 break;
+	      }
 	   }
 	   if((monitor->hmin <= monitor->hmax) && (monitor->vmin <= monitor->vmax)) {
 	      monitor->datavalid = true;
@@ -2354,7 +2409,12 @@ SISDoSense(struct sis_video_info *ivideo
 
     for(j = 0; j < 10; j++) {
        result = 0;
-       for(i = 0; i < 3; i++) {
+       unsigned long long delta = (cpu / khz / HZ) * 2;
+       unsigned long long _start = 0;
+       unsigned long long _cur = 0;
+       unsigned long long timeout;
+          timeout = rdstcll(start) + delta;
+          for(i = 0; i < 3; i++) {
           mytest = test;
 	   SiS_SetReg(SISPART4, 0x11, (type & 0x00ff));
           temp = (type >> 8) | (mytest & 0x00ff);
@@ -2371,6 +2431,12 @@ SISDoSense(struct sis_video_info *ivideo
 	  SiS_SetRegAND(SISPART4, 0x10, 0xe0);
 	  SiS_DDC2Delay(&ivideo->SiS_Pr, 0x1000);
 #endif
+if (_cur < timeout) {
+	  rdstcll(_cur);
+}
+else {
+	  break;
+}
        }
        if((result == 0) || (result >= 2)) break;
     }
@@ -2507,9 +2573,20 @@ SiS_Sense30x(struct sis_video_info *ivid
     if(ivideo->vbflags2 & VB2_30xCLV) {
 	biosflag = SiS_GetReg(SISPART2, 0x00);
        if(biosflag & 0x20) {
-          for(myflag = 2; myflag > 0; myflag--) {
+          unsigned long long delta = (cpu / khz / HZ) * 2;
+          unsigned long long _start = 0;
+          unsigned long long _cur = 0;
+          unsigned long long timeout;
+	  timeout = rdstcll(start) + delta;
+	  for(myflag = 2; myflag > 0; myflag--) {
 	     biosflag ^= 0x20;
 	     SiS_SetReg(SISPART2, 0x00, biosflag);
+	     if (_cur < timeout) {
+	     rdstcll(_cur);
+	     }
+	     else {
+	     break;
+	     }
 	  }
        }
     }
@@ -2555,6 +2632,11 @@ SiS_SenseCh(struct sis_video_info *ivide
 		SiS_DDC2Delay(&ivideo->SiS_Pr, 300);
 	   }
 	   /* Sense connected TV devices */
+	   unsigned long long delta = (cpu / khz / HZ) * 2;
+	   unsigned long long _start = 0;
+	   unsigned long long _cur = 0;
+	   unsigned long long timeout;
+	   timeout = rdstcll(start) + delta;
 	   for(i = 0; i < 3; i++) {
 	       SiS_SetCH700x(&ivideo->SiS_Pr, 0x10, 0x01);
 	       SiS_DDC2Delay(&ivideo->SiS_Pr, 0x96);
@@ -2565,6 +2647,12 @@ SiS_SenseCh(struct sis_video_info *ivide
 	       else if(!(temp1 & 0x02))  test[i] = 0x01;
 	       else                      test[i] = 0;
 	       SiS_DDC2Delay(&ivideo->SiS_Pr, 0x96);
+	       if (_cur < timeout) {
+	           rdstcll(_cur);
+	       }
+	       else {
+	           break;
+	       }
 	   }
 
 	   if(test[0] == test[1])      temp1 = test[0];
@@ -3228,9 +3316,20 @@ sisfb_poh_new_node(struct SIS_HEAP *memh
 		cOhs = (SIS_OH_ALLOC_SIZE - sizeof(struct SIS_OHALLOC)) / sizeof(struct SIS_OH) + 1;
 
 		poh = &poha->aoh[0];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(i = cOhs - 1; i != 0; i--) {
 			poh->poh_next = poh + 1;
 			poh = poh + 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		poh->poh_next = NULL;
@@ -4124,6 +4223,11 @@ sisfb_find_rom(struct pci_dev *pdev)
 	{
 		u32 temp;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (temp = 0x000c0000; temp < 0x000f0000; temp += 0x00001000) {
 
 			rom_base = ioremap(temp, 65536);
@@ -4141,6 +4245,12 @@ sisfb_find_rom(struct pci_dev *pdev)
 			iounmap(rom_base);
 			break;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	}
@@ -4189,6 +4299,11 @@ sisfb_post_300_buswidth(struct sis_video
 	SiS_SetReg(SISSR, 0x13, 0x00);
 	SiS_SetReg(SISSR, 0x14, 0xBF);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 2; i++) {
 		temp = 0x1234;
 		for(j = 0; j < 4; j++) {
@@ -4203,6 +4318,12 @@ sisfb_post_300_buswidth(struct sis_video
 			reg = SiS_GetReg(SISSR, 0x05);
 			temp++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	writel(0x01234567L, FBAddress);
@@ -4251,6 +4372,11 @@ sisfb_post_300_rwtest(struct sis_video_i
 		{0x09,0x08,0x01,0x01,0x00}
 	};
 
+	 unsigned long long delta = (cpu / khz / HZ) * 2;
+	 unsigned long long _start = 0;
+	 unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
 	 for(k = 0; k <= 16; k++) {
 
 		RankCapacity = buswidth * SiS_DRAMType[k][3];
@@ -4303,6 +4429,12 @@ sisfb_post_300_rwtest(struct sis_video_i
 		/* Read data */
 		if(readw(FBAddr + BankNumHigh + PhysicalAdrHigh) == PhysicalAdrHigh)
 			return 1;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	return 0;
@@ -4317,9 +4449,19 @@ sisfb_post_300_ramsize(struct pci_dev *p
 
 	buswidth = sisfb_post_300_buswidth(ivideo);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 6; i >= 0; i--) {
 		PseudoRankCapacity = 1 << i;
-		for(j = 4; j >= 1; j--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for(j = 4; j >= 1; j--) {
 			PseudoAdrPinCount = 15 - j;
 			if((PseudoRankCapacity * j) <= 64) {
 				if(sisfb_post_300_rwtest(ivideo,
@@ -4330,6 +4472,18 @@ sisfb_post_300_ramsize(struct pci_dev *p
 						mapsize))
 					return;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
@@ -4564,9 +4718,20 @@ sisfb_post_xgi_delay(struct sis_video_in
 	unsigned int i;
 	u8 reg;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i <= (delay * 10 * 36); i++) {
 		reg = SiS_GetReg(SISSR, 0x05);
 		reg++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4599,10 +4764,21 @@ sisfb_post_xgi_rwtest(struct sis_video_i
 
 	writel(0, ivideo->video_vbase);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = starta; i <= enda; i++) {
 		pos = 1 << i;
 		if(pos < mapsize)
 			writel(pos, ivideo->video_vbase + pos);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	sisfb_post_xgi_delay(ivideo, 150);
@@ -4610,6 +4786,11 @@ sisfb_post_xgi_rwtest(struct sis_video_i
 	if(readl(ivideo->video_vbase) != 0)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = starta; i <= enda; i++) {
 		pos = 1 << i;
 		if(pos < mapsize) {
@@ -4617,6 +4798,12 @@ sisfb_post_xgi_rwtest(struct sis_video_i
 				return 0;
 		} else
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 1;
@@ -5181,31 +5368,86 @@ sisfb_post_xgi(struct pci_dev *pdev)
 		return 0;
 
 	/* Clear some regs */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 0x22; i++) {
 		if(0x06 + i == 0x20) continue;
 		SiS_SetReg(SISSR, 0x06 + i, 0x00);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 0x0b; i++) {
 		SiS_SetReg(SISSR, 0x31 + i, 0x00);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 0x10; i++) {
 		SiS_SetReg(SISCR, 0x30 + i, 0x00);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ptr = cs78;
 	if(ivideo->haveXGIROM) {
 		ptr = (const u8 *)&bios[0x78];
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 3; i++) {
 		SiS_SetReg(SISSR, 0x23 + i, ptr[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ptr = cs76;
 	if(ivideo->haveXGIROM) {
 		ptr = (const u8 *)&bios[0x76];
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 2; i++) {
 		SiS_SetReg(SISSR, 0x21 + i, ptr[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	v1 = 0x18; v2 = 0x00;
@@ -5224,8 +5466,19 @@ sisfb_post_xgi(struct pci_dev *pdev)
 	if(ivideo->haveXGIROM) {
 		ptr = (const u8 *)&bios[0x7b];
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 3; i++) {
 		SiS_SetReg(SISSR, 0x31 + i, ptr[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if(ivideo->chip == XGI_40) {
@@ -5410,8 +5663,19 @@ sisfb_post_xgi(struct pci_dev *pdev)
 	if(ivideo->haveXGIROM) {
 		ptr = (const u8 *)&bios[0x128];
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0, j = 0; i < 3; i++, j += 8) {
 		SiS_SetReg(SISCR, 0x68 + i, ptr[j + regb]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ptr  = cs31a;
@@ -5421,6 +5685,11 @@ sisfb_post_xgi(struct pci_dev *pdev)
 		ptr  = (const u8 *)&bios[index];
 		ptr2 = (const u8 *)&bios[index + 0x20];
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 2; i++) {
 		if(i == 0) {
 			regd = le32_to_cpu(((u32 *)ptr)[regb]);
@@ -5430,6 +5699,11 @@ sisfb_post_xgi(struct pci_dev *pdev)
 			rega = 0x6e;
 		}
 		reg = 0x00;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(j = 0; j < 16; j++) {
 			reg &= 0xf3;
 			if(regd & 0x01) reg |= 0x04;
@@ -5439,6 +5713,18 @@ sisfb_post_xgi(struct pci_dev *pdev)
 			reg = SiS_GetReg(SISCR, rega);
 			reg = SiS_GetReg(SISCR, rega);
 			reg += 0x10;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -5449,9 +5735,19 @@ sisfb_post_xgi(struct pci_dev *pdev)
 		index = (ivideo->chip == XGI_20) ? 0x35a : 0x3e6;
 		ptr  = (const u8 *)&bios[index];
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 4; i++) {
 		SiS_SetRegANDOR(SISCR, 0x6e, 0xfc, i);
 		reg = 0x00;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(j = 0; j < 2; j++) {
 			regd = 0;
 			if(ptr) {
@@ -5459,6 +5755,11 @@ sisfb_post_xgi(struct pci_dev *pdev)
 				ptr += 4;
 			}
 			/* reg = 0x00; */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for(k = 0; k < 16; k++) {
 				reg &= 0xfc;
 				if(regd & 0x01) reg |= 0x01;
@@ -5468,7 +5769,25 @@ sisfb_post_xgi(struct pci_dev *pdev)
 				reg = SiS_GetReg(SISCR, 0x6f);
 				reg = SiS_GetReg(SISCR, 0x6f);
 				reg += 0x08;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
 			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -5476,8 +5795,19 @@ sisfb_post_xgi(struct pci_dev *pdev)
 	if(ivideo->haveXGIROM) {
 		ptr  = (const u8 *)&bios[0x148];
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0, j = 0; i < 2; i++, j += 8) {
 		SiS_SetReg(SISCR, 0x80 + i, ptr[j + regb]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	SiS_SetRegAND(SISCR, 0x89, 0x8f);
@@ -5489,6 +5819,11 @@ sisfb_post_xgi(struct pci_dev *pdev)
 	}
 	regd = le16_to_cpu(((const u16 *)ptr)[regb]);
 	reg = 0x80;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i < 5; i++) {
 		reg &= 0xfc;
 		if(regd & 0x01) reg |= 0x01;
@@ -5498,6 +5833,12 @@ sisfb_post_xgi(struct pci_dev *pdev)
 		reg = SiS_GetReg(SISCR, 0x89);
 		reg = SiS_GetReg(SISCR, 0x89);
 		reg += 0x10;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	v1 = 0xb5; v2 = 0x20; v3 = 0xf0; v4 = 0x13;
@@ -5516,8 +5857,19 @@ sisfb_post_xgi(struct pci_dev *pdev)
 	if(ivideo->haveXGIROM) {
 		ptr  = (const u8 *)&bios[0x170];
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0, j = 0; i < 7; i++, j += 8) {
 		SiS_SetReg(SISCR, 0x90 + i, ptr[j + regb]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	SiS_SetReg(SISCR, 0x59, v3);
@@ -5526,16 +5878,38 @@ sisfb_post_xgi(struct pci_dev *pdev)
 	if(ivideo->haveXGIROM) {
 		ptr  = (const u8 *)&bios[0x1a8];
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0, j = 0; i < 3; i++, j += 8) {
 		SiS_SetReg(SISCR, 0xc3 + i, ptr[j + regb]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ptr  = cs100;
 	if(ivideo->haveXGIROM) {
 		ptr  = (const u8 *)&bios[0x100];
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0, j = 0; i < 2; i++, j += 8) {
 		SiS_SetReg(SISCR, 0x8a + i, ptr[j + regb]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	SiS_SetReg(SISCR, 0xcf, v4);
@@ -6077,8 +6451,19 @@ sisfb_probe(struct pci_dev *pdev, const
 			      || (sisfb_resetcard)
 #endif
 						   ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(i = 0x30; i <= 0x3f; i++) {
 			SiS_SetReg(SISCR, i, 0x00);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 	}
 
diff -u -p a/video/sis/init301.c b/video/sis/init301.c
--- a/video/sis/init301.c
+++ b/video/sis/init301.c
@@ -581,8 +581,19 @@ static void
 SiS_PanelDelayLoop(struct SiS_Private *SiS_Pr, unsigned short DelayTime, unsigned short DelayLoop)
 {
    int i;
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 0; i < DelayLoop; i++) {
       SiS_PanelDelay(SiS_Pr, DelayTime);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
+         break;
+      }
    }
 }
 #endif
@@ -649,7 +660,17 @@ SiS_VBWait(struct SiS_Private *SiS_Pr)
    unsigned short tempal,temp,i,j;
 
    temp = 0;
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 0; i < 3; i++) {
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(j = 0; j < 100; j++) {
         tempal = SiS_GetRegByte(SiS_Pr->SiS_P3da);
         if(temp & 0x01) {
@@ -659,8 +680,20 @@ SiS_VBWait(struct SiS_Private *SiS_Pr)
 	   if(!(tempal & 0x08)) continue;
 	   else break;
         }
+        if (_cur < timeout) {
+	   rdstcll(_cur);
+        }
+        else {
+	   break;
+        }
      }
      temp ^= 0x01;
+     if (_cur < timeout) {
+        rdstcll(_cur);
+     }
+     else {
+        break;
+     }
    }
 }
 
@@ -5303,17 +5336,61 @@ SiS_SetGroup1_301(struct SiS_Private *Si
   SiS_CalcCRRegisters(SiS_Pr, 0);
   SiS_Pr->CCRT1CRTC[16] &= ~0xE0;
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i = 0; i <= 7; i++) {
      SiS_SetReg(SiS_Pr->SiS_Part1Port,CRTranslation[i],SiS_Pr->CCRT1CRTC[i]);
+     if (_cur < timeout) {
+        rdstcll(_cur);
+     }
+     else {
+        break;
+     }
   }
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i = 0x10, j = 8; i <= 0x12; i++, j++) {
      SiS_SetReg(SiS_Pr->SiS_Part1Port,CRTranslation[i],SiS_Pr->CCRT1CRTC[j]);
+     if (_cur < timeout) {
+        rdstcll(_cur);
+     }
+     else {
+        break;
+     }
   }
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i = 0x15, j = 11; i <= 0x16; i++, j++) {
      SiS_SetReg(SiS_Pr->SiS_Part1Port,CRTranslation[i],SiS_Pr->CCRT1CRTC[j]);
+     if (_cur < timeout) {
+        rdstcll(_cur);
+     }
+     else {
+        break;
+     }
   }
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i = 0x0a, j = 13; i <= 0x0c; i++, j++) {
      SiS_SetReg(SiS_Pr->SiS_Part1Port,CRTranslation[i],SiS_Pr->CCRT1CRTC[j]);
+     if (_cur < timeout) {
+        rdstcll(_cur);
+     }
+     else {
+        break;
+     }
   }
 
   temp = SiS_Pr->CCRT1CRTC[16] & 0xE0;
@@ -5778,18 +5855,51 @@ SiS_SetGroup1_LVDS(struct SiS_Private *S
      }
 
      SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x02,0xbf);
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(i=0; i<5; i++) {
 	SiS_SetTrumpionBlock(SiS_Pr, trumpdata);
+	if (_cur < timeout) {
+	   rdstcll(_cur);
+	}
+	else {
+	   break;
+	}
      }
      if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {
 	if(ModeNo == 0x13) {
+	   unsigned long long delta = (cpu / khz / HZ) * 2;
+	   unsigned long long _start = 0;
+	   unsigned long long _cur = 0;
+	   unsigned long long timeout;
+	   timeout = rdstcll(start) + delta;
 	   for(i=0; i<4; i++) {
 	      SiS_SetTrumpionBlock(SiS_Pr, &TrumpMode13[0]);
+	      if (_cur < timeout) {
+	      rdstcll(_cur);
+	      }
+	      else {
+	      break;
+	      }
 	   }
 	} else if(ModeNo == 0x10) {
+	   unsigned long long delta = (cpu / khz / HZ) * 2;
+	   unsigned long long _start = 0;
+	   unsigned long long _cur = 0;
+	   unsigned long long timeout;
+	   timeout = rdstcll(start) + delta;
 	   for(i=0; i<4; i++) {
 	      SiS_SetTrumpionBlock(SiS_Pr, &TrumpMode10_1[0]);
 	      SiS_SetTrumpionBlock(SiS_Pr, &TrumpMode10_2[0]);
+	      if (_cur < timeout) {
+	      rdstcll(_cur);
+	      }
+	      else {
+	      break;
+	      }
 	   }
 	}
      }
@@ -6331,13 +6441,35 @@ SiS_SetGroup2_C_ELV(struct SiS_Private *
    if(!(SiS_Pr->SiS_VBType & VB_SISTAP4SCALER)) return;
 
    tableptr = SiS_GetGroup2CLVXPtr(SiS_Pr, 0);
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 0x80, j = 0; i <= 0xbf; i++, j++) {
       SiS_SetReg(SiS_Pr->SiS_Part2Port, i, tableptr[j]);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
+         break;
+      }
    }
    if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {
       tableptr = SiS_GetGroup2CLVXPtr(SiS_Pr, 1);
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(i = 0xc0, j = 0; i <= 0xff; i++, j++) {
          SiS_SetReg(SiS_Pr->SiS_Part2Port, i, tableptr[j]);
+         if (_cur < timeout) {
+            rdstcll(_cur);
+         }
+         else {
+            break;
+         }
       }
    }
    temp = 0x10;
@@ -6465,14 +6597,47 @@ SiS_Set300Part2Regs(struct SiS_Private *
 
   SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x01,0x80,(CRT2Part2Ptr+resindex)->CR[0]);
   SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x02,0x80,(CRT2Part2Ptr+resindex)->CR[1]);
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i = 2, j = 0x04; j <= 0x06; i++, j++ ) {
      SiS_SetReg(SiS_Pr->SiS_Part2Port,j,(CRT2Part2Ptr+resindex)->CR[i]);
+     if (_cur < timeout) {
+       rdstcll(_cur);
+     }
+     else {
+       break;
+     }
   }
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(j = 0x1c; j <= 0x1d; i++, j++ ) {
      SiS_SetReg(SiS_Pr->SiS_Part2Port,j,(CRT2Part2Ptr+resindex)->CR[i]);
+     if (_cur < timeout) {
+       rdstcll(_cur);
+     }
+     else {
+       break;
+     }
   }
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(j = 0x1f; j <= 0x21; i++, j++ ) {
      SiS_SetReg(SiS_Pr->SiS_Part2Port,j,(CRT2Part2Ptr+resindex)->CR[i]);
+     if (_cur < timeout) {
+       rdstcll(_cur);
+     }
+     else {
+       break;
+     }
   }
   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x23,(CRT2Part2Ptr+resindex)->CR[10]);
   SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x25,0x0f,(CRT2Part2Ptr+resindex)->CR[11]);
@@ -6494,8 +6659,19 @@ SiS_SetTVSpecial(struct SiS_Private *SiS
 		0x58,0xe4,0x73,0xda,0x13
 	};
 	int i, j;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0x1c, j = 0; i <= 0x30; i++, j++) {
 	   SiS_SetReg(SiS_Pr->SiS_Part2Port,i,specialtv[j]);
+	   if (_cur < timeout) {
+	      rdstcll(_cur);
+	   }
+	   else {
+	      break;
+	   }
 	}
 	SiS_SetReg(SiS_Pr->SiS_Part2Port,0x43,0x72);
 	if(!(SiS_Pr->SiS_VBInfo & SetCRT2ToYPbPr525750)) {
@@ -6673,15 +6849,48 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr
      }
   }
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i = 0x31, j = 0; i <= 0x34; i++, j++) {
      SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS_TVPhase[(PhaseIndex * 4) + j]);
+     if (_cur < timeout) {
+        rdstcll(_cur);
+     }
+     else {
+        break;
+     }
   }
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i = 0x01, j = 0; i <= 0x2D; i++, j++) {
      SiS_SetReg(SiS_Pr->SiS_Part2Port,i,TimingPoint[j]);
+     if (_cur < timeout) {
+        rdstcll(_cur);
+     }
+     else {
+        break;
+     }
   }
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i = 0x39; i <= 0x45; i++, j++) {
      SiS_SetReg(SiS_Pr->SiS_Part2Port,i,TimingPoint[j]);
+     if (_cur < timeout) {
+        rdstcll(_cur);
+     }
+     else {
+        break;
+     }
   }
 
   if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {
@@ -6978,14 +7187,47 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr
 
       SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x01,0x80,(CRT2Part2Ptr+resindex)->CR[0]);
       SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x02,0x80,(CRT2Part2Ptr+resindex)->CR[1]);
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(i = 2, j = 0x04; j <= 0x06; i++, j++ ) {
         SiS_SetReg(SiS_Pr->SiS_Part2Port,j,(CRT2Part2Ptr+resindex)->CR[i]);
+        if (_cur < timeout) {
+     rdstcll(_cur);
+        }
+        else {
+     break;
+        }
       }
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(j = 0x1c; j <= 0x1d; i++, j++ ) {
         SiS_SetReg(SiS_Pr->SiS_Part2Port,j,(CRT2Part2Ptr+resindex)->CR[i]);
+        if (_cur < timeout) {
+             rdstcll(_cur);
+        }
+        else {
+             break;
+        }
       }
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(j = 0x1f; j <= 0x21; i++, j++ ) {
         SiS_SetReg(SiS_Pr->SiS_Part2Port,j,(CRT2Part2Ptr+resindex)->CR[i]);
+        if (_cur < timeout) {
+             rdstcll(_cur);
+        }
+        else {
+             break;
+        }
       }
       SiS_SetReg(SiS_Pr->SiS_Part2Port,0x23,(CRT2Part2Ptr+resindex)->CR[10]);
       SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x25,0x0f,(CRT2Part2Ptr+resindex)->CR[11]);
@@ -7225,8 +7467,19 @@ SiS_SetGroup3(struct SiS_Private *SiS_Pr
      }
   }
   if(tempdi) {
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(i=0; i<=0x3E; i++) {
         SiS_SetReg(SiS_Pr->SiS_Part3Port,i,tempdi[i]);
+        if (_cur < timeout) {
+	   rdstcll(_cur);
+	}
+	else {
+	   break;
+	}
      }
      if(SiS_Pr->SiS_VBType & VB_SIS30xCLV) {
 	if(SiS_Pr->SiS_TVMode & TVSetYPbPr525p) {
@@ -7741,14 +7994,36 @@ SiS_ModCRT1CRTC(struct SiS_Private *SiS_
 
      SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x11,0x7f);
 
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(i = 0; i <= 10; i++) {
         tempah = (LVDSCRT1Ptr + ResIndex)->CR[i];
         SiS_SetReg(SiS_Pr->SiS_P3d4,CRIdx[i],tempah);
+        if (_cur < timeout) {
+    rdstcll(_cur);
+        }
+        else {
+    break;
+        }
      }
 
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(i = 0x0A, j = 11; i <= 0x0C; i++, j++) {
         tempah = (LVDSCRT1Ptr + ResIndex)->CR[j];
         SiS_SetReg(SiS_Pr->SiS_P3c4,i,tempah);
+        if (_cur < timeout) {
+    rdstcll(_cur);
+        }
+        else {
+    break;
+        }
      }
 
      tempah = (LVDSCRT1Ptr + ResIndex)->CR[14] & 0xE0;
@@ -8104,8 +8379,19 @@ SiS_ChrontelPowerSequencing(struct SiS_P
      } else return;
   }
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i=0; i<5; i++) {
      SiS_SetCH701x(SiS_Pr, regtable[i], tableptr[i]);
+     if (_cur < timeout) {
+	rdstcll(_cur);
+     }
+     else {
+	break;
+     }
   }
 }
 
@@ -8182,8 +8468,19 @@ SiS_SetCH701xForLCD(struct SiS_Private *
   if(SiS_Pr->ChipType == SIS_740) tempbh = 0x0d;
   else     			  tempbh = 0x0c;
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i = 0; i < tempbh; i++) {
      SiS_SetCH701x(SiS_Pr, regtable[i], tableptr[i]);
+     if (_cur < timeout) {
+        rdstcll(_cur);
+     }
+     else {
+        break;
+     }
   }
   SiS_ChrontelPowerSequencing(SiS_Pr);
   tempbh = SiS_GetCH701x(SiS_Pr,0x1e);
@@ -8733,6 +9030,11 @@ SiS_SetTrumpBlockLoop(struct SiS_Private
   unsigned short tempah,temp;
   unsigned char *mydataptr;
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i=0; i<20; i++) {				/* Do 20 attempts to write */
      mydataptr = dataptr;
      num = *mydataptr++;
@@ -8756,6 +9058,12 @@ SiS_SetTrumpBlockLoop(struct SiS_Private
      if(temp) continue;
      if(SiS_SetStop(SiS_Pr)) continue;
      return mydataptr;
+     if (_cur < timeout) {
+	rdstcll(_cur);
+     }
+     else {
+	break;
+     }
   }
   return NULL;
 }
@@ -8791,6 +9099,11 @@ SiS_SetChReg(struct SiS_Private *SiS_Pr,
 {
   unsigned short temp, i;
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i=0; i<20; i++) {				/* Do 20 attempts to write */
      if(i) {
 	SiS_SetStop(SiS_Pr);
@@ -8806,6 +9119,12 @@ SiS_SetChReg(struct SiS_Private *SiS_Pr,
      if(SiS_SetStop(SiS_Pr)) continue;					/* Set stop condition */
      SiS_Pr->SiS_ChrontelInit = 1;
      return true;
+     if (_cur < timeout) {
+	rdstcll(_cur);
+     }
+     else {
+	break;
+     }
   }
   return false;
 }
@@ -8864,6 +9183,11 @@ SiS_GetChReg(struct SiS_Private *SiS_Pr,
 {
   unsigned short tempah, temp, i;
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i=0; i<20; i++) {				/* Do 20 attempts to read */
      if(i) {
 	SiS_SetStop(SiS_Pr);
@@ -8881,6 +9205,12 @@ SiS_GetChReg(struct SiS_Private *SiS_Pr,
      if(SiS_SetStop(SiS_Pr)) continue;					/* Stop condition */
      SiS_Pr->SiS_ChrontelInit = 1;
      return tempah;
+     if (_cur < timeout) {
+	rdstcll(_cur);
+     }
+     else {
+	break;
+     }
   }
   return 0xFFFF;
 }
@@ -9191,11 +9521,22 @@ SiS_ReadDDC(struct SiS_Private *SiS_Pr,
       if(DDCdatatype != 1) length = 255;
       chksum = 0;
       gotcha = 0;
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(i=0; i<length; i++) {
 	 buffer[i] = (unsigned char)SiS_ReadDDC2Data(SiS_Pr);
 	 chksum += buffer[i];
 	 gotcha |= buffer[i];
 	 SiS_SendACK(SiS_Pr, 0);
+	 if (_cur < timeout) {
+	    rdstcll(_cur);
+	 }
+	 else {
+	    break;
+	 }
       }
       buffer[i] = (unsigned char)SiS_ReadDDC2Data(SiS_Pr);
       chksum += buffer[i];
@@ -9358,6 +9699,11 @@ SiS_WriteDDC2Data(struct SiS_Private *Si
   unsigned short i,flag,temp;
 
   flag = 0x80;
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   for(i = 0; i < 8; i++) {
     SiS_SetSCLKLow(SiS_Pr);					/* SC->low */
     if(tempax & flag) {
@@ -9373,6 +9719,12 @@ SiS_WriteDDC2Data(struct SiS_Private *Si
     }
     SiS_SetSCLKHigh(SiS_Pr);					/* SC->high */
     flag >>= 1;
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
   temp = SiS_CheckACK(SiS_Pr);					/* Check acknowledge */
   return temp;
@@ -9384,7 +9736,12 @@ SiS_ReadDDC2Data(struct SiS_Private *SiS
   unsigned short i, temp, getdata;
 
   getdata = 0;
-  for(i = 0; i < 8; i++) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
+    for(i = 0; i < 8; i++) {
     getdata <<= 1;
     SiS_SetSCLKLow(SiS_Pr);
     SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,
@@ -9394,6 +9751,12 @@ SiS_ReadDDC2Data(struct SiS_Private *SiS
     SiS_SetSCLKHigh(SiS_Pr);
     temp = SiS_GetReg(SiS_Pr->SiS_DDC_Port,SiS_Pr->SiS_DDC_Index);
     if(temp & SiS_Pr->SiS_DDC_Data) getdata |= 0x01;
+    if (_cur < timeout) {
+    rdstcll(_cur);
+    }
+    else {
+    break;
+    }
   }
   return getdata;
 }
@@ -10042,15 +10405,48 @@ SetYFilter(struct SiS_Private *SiS_Pr, u
   if(SiS_Pr->SiS_VBInfo & SetCRT2ToHiVision) temp = 1;  /* HiVision uses PAL */
 
   if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(i=0x35, j=0; i<=0x38; i++, j++) {
         SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVYFilter2[temp][index][j]);
+        if (_cur < timeout) {
+          rdstcll(_cur);
+        }
+        else {
+          break;
+        }
      }
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(i=0x48; i<=0x4A; i++, j++) {
         SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVYFilter2[temp][index][j]);
+        if (_cur < timeout) {
+          rdstcll(_cur);
+        }
+        else {
+          break;
+        }
      }
   } else {
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(i=0x35, j=0; i<=0x38; i++, j++) {
         SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVYFilter1[temp][index][j]);
+        if (_cur < timeout) {
+          rdstcll(_cur);
+        }
+        else {
+          break;
+        }
      }
   }
 }
@@ -10070,8 +10466,19 @@ SetPhaseIncr(struct SiS_Private *SiS_Pr,
   if((SiS_Pr->ChipType >= SIS_661) || SiS_Pr->SiS_ROMNew) {
      lindex = GetOEMTVPtr661_2_OLD(SiS_Pr) & 0xffff;
      lindex <<= 2;
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(j=0, i=0x31; i<=0x34; i++, j++) {
         SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS_TVPhase[lindex + j]);
+        if (_cur < timeout) {
+	   rdstcll(_cur);
+        }
+        else {
+	   break;
+        }
      }
      return;
   }
@@ -10109,12 +10516,28 @@ SetPhaseIncr(struct SiS_Private *SiS_Pr,
   }
   if(romptr) {
      romptr += (temp << 2);
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(j=0, i=0x31; i<=0x34; i++, j++) {
         SiS_SetReg(SiS_Pr->SiS_Part2Port,i,ROMAddr[romptr + j]);
+        if (_cur < timeout) {
+	   rdstcll(_cur);
+        }
+        else {
+	   break;
+        }
      }
   } else {
      index = temp % 2;
      temp >>= 1;          /* 0:NTSC, 1:PAL, 2:HiTV */
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(j=0, i=0x31; i<=0x34; i++, j++) {
         if(!(SiS_Pr->SiS_VBType & VB_SIS30xBLV))
 	   SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVPhaseIncr1[temp][index][j]);
@@ -10122,6 +10545,12 @@ SetPhaseIncr(struct SiS_Private *SiS_Pr,
            SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVPhaseIncr2[temp][index][j]);
         else
            SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVPhaseIncr1[temp][index][j]);
+           if (_cur < timeout) {
+           rdstcll(_cur);
+           }
+           else {
+           break;
+           }
      }
   }
 
@@ -10668,6 +11097,11 @@ SetOEMLCDData2(struct SiS_Private *SiS_P
      if(modeflag & HalfDCLK) myindex = 1;
 
      if(SiS_Pr->SiS_SetFlag & LowModeTests) {
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for(i=0; i<7; i++) {
            if(barco_p1[myindex][crt2crtc][i][0]) {
 	      SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,
@@ -10675,6 +11109,12 @@ SetOEMLCDData2(struct SiS_Private *SiS_P
 	   	   	      barco_p1[myindex][crt2crtc][i][2],
 			      barco_p1[myindex][crt2crtc][i][1]);
 	   }
+	   if (_cur < timeout) {
+	      rdstcll(_cur);
+	   }
+	   else {
+	      break;
+	   }
         }
      }
      temp = SiS_GetReg(SiS_Pr->SiS_Part1Port,0x00);
@@ -10952,20 +11392,53 @@ SetOEMPhaseIncr(struct SiS_Private *SiS_
   index = SiS_Pr->SiS_VBModeIDTable[ModeIdIndex].VB_TVPhaseIndex;
 
   if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      for(i=0x31, j=0; i<=0x34; i++, j++) {
         SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS300_Phase2[temp][index][j]);
+        if (_cur < timeout) {
+	   rdstcll(_cur);
+        }
+        else {
+	   break;
+        }
      }
   } else {
      if(romptr) {
         romptr += (temp * 2);
 	romptr = SISGETROMW(romptr);
 	romptr += (index * 4);
-        for(i=0x31, j=0; i<=0x34; i++, j++) {
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for(i=0x31, j=0; i<=0x34; i++, j++) {
 	   SiS_SetReg(SiS_Pr->SiS_Part2Port,i,ROMAddr[romptr + j]);
-	}
+	   if (_cur < timeout) {
+	     rdstcll(_cur);
+	   }
+	   else {
+	     break;
+	   }
+        }
      } else {
-        for(i=0x31, j=0; i<=0x34; i++, j++) {
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for(i=0x31, j=0; i<=0x34; i++, j++) {
            SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS300_Phase1[temp][index][j]);
+           if (_cur < timeout) {
+             rdstcll(_cur);
+           }
+           else {
+             break;
+           }
 	}
      }
   }
@@ -10994,23 +11467,67 @@ SetOEMYFilter(struct SiS_Private *SiS_Pr
   index = SiS_Pr->SiS_VBModeIDTable[ModeIdIndex].VB_TVYFilterIndex;
 
   if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(i=0x35, j=0; i<=0x38; i++, j++) {
        	SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS300_Filter2[temp][index][j]);
-      }
+       	if (_cur < timeout) {
+       	    rdstcll(_cur);
+       	}
+       	else {
+       	    break;
+       	}
+      }
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(i=0x48; i<=0x4A; i++, j++) {
      	SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS300_Filter2[temp][index][j]);
+     	if (_cur < timeout) {
+       	    rdstcll(_cur);
+     	}
+     	else {
+       	    break;
+         }
       }
   } else {
       if((romptr) && (!(SiS_Pr->SiS_TVMode & (TVSetPALM|TVSetPALN)))) {
          romptr += (temp * 2);
 	 romptr = SISGETROMW(romptr);
 	 romptr += (index * 4);
-	 for(i=0x35, j=0; i<=0x38; i++, j++) {
+	 unsigned long long delta = (cpu / khz / HZ) * 2;
+	 unsigned long long _start = 0;
+	 unsigned long long _cur = 0;
+	 unsigned long long timeout;
+         timeout = rdstcll(start) + delta;
+         for(i=0x35, j=0; i<=0x38; i++, j++) {
        	    SiS_SetReg(SiS_Pr->SiS_Part2Port,i,ROMAddr[romptr + j]);
+       	    if (_cur < timeout) {
+       	      rdstcll(_cur);
+       	    }
+       	    else {
+       	      break;
+       	    }
          }
       } else {
+         unsigned long long delta = (cpu / khz / HZ) * 2;
+         unsigned long long _start = 0;
+         unsigned long long _cur = 0;
+         unsigned long long timeout;
+         timeout = rdstcll(start) + delta;
          for(i=0x35, j=0; i<=0x38; i++, j++) {
        	    SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS300_Filter1[temp][index][j]);
+       	    if (_cur < timeout) {
+       	      rdstcll(_cur);
+       	    }
+       	    else {
+       	      break;
+       	    }
          }
       }
   }
diff -u -p a/video/sis/init.c b/video/sis/init.c
--- a/video/sis/init.c
+++ b/video/sis/init.c
@@ -1849,9 +1849,20 @@ SiS_SetSeqRegs(struct SiS_Private *SiS_P
 
    SiS_SetReg(SiS_Pr->SiS_P3c4,0x01,SRdata);
 
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 2; i <= 4; i++) {
       SRdata = SiS_Pr->SiS_StandTable[StandTableIndex].SR[i - 1];
       SiS_SetReg(SiS_Pr->SiS_P3c4,i,SRdata);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
+         break;
+      }
    }
 }
 
@@ -1890,16 +1901,38 @@ SiS_SetCRTCRegs(struct SiS_Private *SiS_
    /* Unlock CRTC */
    SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x11,0x7f);
 
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 0; i <= 0x18; i++) {
       CRTCdata = SiS_Pr->SiS_StandTable[StandTableIndex].CRTC[i];
       SiS_SetReg(SiS_Pr->SiS_P3d4,i,CRTCdata);
+      if (_cur < timeout) {
+	 rdstcll(_cur);
+      }
+      else {
+	 break;
+      }
    }
 
    if(SiS_Pr->ChipType >= SIS_661) {
       SiS_OpenCRTC(SiS_Pr);
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(i = 0x13; i <= 0x14; i++) {
 	 CRTCdata = SiS_Pr->SiS_StandTable[StandTableIndex].CRTC[i];
 	 SiS_SetReg(SiS_Pr->SiS_P3d4,i,CRTCdata);
+	 if (_cur < timeout) {
+	    rdstcll(_cur);
+	 }
+	 else {
+	    break;
+	 }
       }
    } else if( ( (SiS_Pr->ChipType == SIS_630) ||
 	        (SiS_Pr->ChipType == SIS_730) )  &&
@@ -1922,6 +1955,11 @@ SiS_SetATTRegs(struct SiS_Private *SiS_P
    unsigned char  ARdata;
    unsigned short i;
 
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 0; i <= 0x13; i++) {
       ARdata = SiS_Pr->SiS_StandTable[StandTableIndex].ATTR[i];
 
@@ -1961,6 +1999,12 @@ SiS_SetATTRegs(struct SiS_Private *SiS_P
       SiS_GetRegByte(SiS_Pr->SiS_P3da);		/* reset 3da  */
       SiS_SetRegByte(SiS_Pr->SiS_P3c0,i);	/* set index  */
       SiS_SetRegByte(SiS_Pr->SiS_P3c0,ARdata);	/* set data   */
+      if (_cur < timeout) {
+	 rdstcll(_cur);
+      }
+      else {
+	 break;
+      }
    }
 
    SiS_GetRegByte(SiS_Pr->SiS_P3da);		/* reset 3da  */
@@ -1982,9 +2026,20 @@ SiS_SetGRCRegs(struct SiS_Private *SiS_P
    unsigned char  GRdata;
    unsigned short i;
 
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 0; i <= 0x08; i++) {
       GRdata = SiS_Pr->SiS_StandTable[StandTableIndex].GRC[i];
       SiS_SetReg(SiS_Pr->SiS_P3ce,i,GRdata);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
+         break;
+      }
    }
 
    if(SiS_Pr->SiS_ModeType > ModeVGA) {
@@ -2002,8 +2057,19 @@ SiS_ClearExt1Regs(struct SiS_Private *Si
 {
    unsigned short i;
 
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 0x0A; i <= 0x0E; i++) {
       SiS_SetReg(SiS_Pr->SiS_P3c4,i,0x00);
+      if (_cur < timeout) {
+	 rdstcll(_cur);
+      }
+      else {
+	 break;
+      }
    }
 
    if(SiS_Pr->ChipType >= SIS_315H) {
@@ -2095,17 +2161,61 @@ SiS_SetCRT1CRTC(struct SiS_Private *SiS_
    /* unlock cr0-7 */
    SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x11,0x7f);
 
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 0, j = 0; i <= 7; i++, j++) {
       SiS_SetReg(SiS_Pr->SiS_P3d4,j,crt1data[i]);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
+         break;
+      }
    }
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(j = 0x10; i <= 10; i++, j++) {
       SiS_SetReg(SiS_Pr->SiS_P3d4,j,crt1data[i]);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
+         break;
+      }
    }
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(j = 0x15; i <= 12; i++, j++) {
       SiS_SetReg(SiS_Pr->SiS_P3d4,j,crt1data[i]);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
+         break;
+      }
    }
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(j = 0x0A; i <= 15; i++, j++) {
       SiS_SetReg(SiS_Pr->SiS_P3c4,j,crt1data[i]);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
+         break;
+      }
    }
 
    SiS_SetReg(SiS_Pr->SiS_P3c4,0x0E,crt1data[16] & 0xE0);
@@ -2904,38 +3014,115 @@ SiS_LoadDAC(struct SiS_Private *SiS_Pr,
 
    SiS_SetRegByte(DACAddr,0x00);
 
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 0; i < j; i++) {
       data = table[i];
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(k = 0; k < 3; k++) {
 	data2 = 0;
 	if(data & 0x01) data2 += 0x2A;
 	if(data & 0x02) data2 += 0x15;
 	SiS_SetRegByte(DACData, (data2 << sf));
 	data >>= 2;
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
+      }
+      if (_cur < timeout) {
+	rdstcll(_cur);
+      }
+      else {
+	break;
       }
    }
 
    if(time == 256) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(i = 16; i < 32; i++) {
 	 data = table[i] << sf;
 	 for(k = 0; k < 3; k++) SiS_SetRegByte(DACData, data);
+	 if (_cur < timeout) {
+	    rdstcll(_cur);
+	 }
+	 else {
+	    break;
+	 }
       }
       si = 32;
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
       for(m = 0; m < 9; m++) {
 	 di = si;
 	 bx = si + 4;
+	 unsigned long long delta = (cpu / khz / HZ) * 2;
+	 unsigned long long _start = 0;
+	 unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
 	 for(n = 0; n < 3; n++) {
+	    unsigned long long delta = (cpu / khz / HZ) * 2;
+	    unsigned long long _start = 0;
+	    unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
 	    for(o = 0; o < 5; o++) {
 	       SiS_WriteDAC(SiS_Pr, DACData, sf, n, table[di], table[bx], table[si]);
 	       si++;
+	       if (_cur < timeout) {
+	          rdstcll(_cur);
+	       }
+	       else {
+	          break;
+	       }
 	    }
 	    si -= 2;
+	    unsigned long long delta = (cpu / khz / HZ) * 2;
+	    unsigned long long _start = 0;
+	    unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
 	    for(o = 0; o < 3; o++) {
 	       SiS_WriteDAC(SiS_Pr, DACData, sf, n, table[di], table[si], table[bx]);
 	       si--;
+	       if (_cur < timeout) {
+	          rdstcll(_cur);
+	       }
+	       else {
+	          break;
+	       }
+	    }
+	    if (_cur < timeout) {
+	       rdstcll(_cur);
+	    }
+	    else {
+	       break;
 	    }
 	 }            /* for n < 3 */
 	 si += 5;
+	 if (_cur < timeout) {
+	    rdstcll(_cur);
+	 }
+	 else {
+	    break;
+	 }
       }               /* for m < 9 */
    }
 }
@@ -3510,17 +3697,61 @@ SiS_CalcLCDACRT1Timing(struct SiS_Privat
 
    SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x11,0x7f);
 
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(i = 0, j = 0; i <= 7; i++, j++) {
       SiS_SetReg(SiS_Pr->SiS_P3d4,j,SiS_Pr->CCRT1CRTC[i]);
+      if (_cur < timeout) {
+      rdstcll(_cur);
+      }
+      else {
+      break;
+      }
    }
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(j = 0x10; i <= 10; i++, j++) {
       SiS_SetReg(SiS_Pr->SiS_P3d4,j,SiS_Pr->CCRT1CRTC[i]);
+      if (_cur < timeout) {
+      rdstcll(_cur);
+      }
+      else {
+      break;
+      }
    }
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(j = 0x15; i <= 12; i++, j++) {
       SiS_SetReg(SiS_Pr->SiS_P3d4,j,SiS_Pr->CCRT1CRTC[i]);
+      if (_cur < timeout) {
+      rdstcll(_cur);
+      }
+      else {
+      break;
+      }
    }
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    for(j = 0x0A; i <= 15; i++, j++) {
       SiS_SetReg(SiS_Pr->SiS_P3c4,j,SiS_Pr->CCRT1CRTC[i]);
+      if (_cur < timeout) {
+      rdstcll(_cur);
+      }
+      else {
+      break;
+      }
    }
 
    tempax = SiS_Pr->CCRT1CRTC[16] & 0xE0;
diff -u -p a/video/imxfb.c b/video/imxfb.c
--- a/video/imxfb.c
+++ b/video/imxfb.c
@@ -293,9 +293,20 @@ static const struct imx_fb_videomode *im
 	struct imx_fb_videomode *m;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, m = &fbi->mode[0]; i < fbi->num_modes; i++, m++) {
 		if (!strcmp(m->mode.name, fb_mode))
 			return m;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NULL;
 }
diff -u -p a/video/igafb.c b/video/igafb.c
--- a/video/igafb.c
+++ b/video/igafb.c
@@ -234,6 +234,11 @@ static int igafb_mmap(struct fb_info *in
 	/* Each page, see which map applies */
 	for (page = 0; page < size; ) {
 		map_size = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; par->mmap_map[i].size; i++) {
 			unsigned long start = par->mmap_map[i].voff;
 			unsigned long end = start + par->mmap_map[i].size;
@@ -247,6 +252,12 @@ static int igafb_mmap(struct fb_info *in
 			map_size = par->mmap_map[i].size - (offset - start);
 			map_offset = par->mmap_map[i].poff + (offset - start);
 			break;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!map_size) {
 			page += PAGE_SIZE;
diff -u -p a/video/pm2fb.c b/video/pm2fb.c
--- a/video/pm2fb.c
+++ b/video/pm2fb.c
@@ -263,10 +263,25 @@ static void pm2_mnp(u32 clk, unsigned ch
 	s32 delta = 100000;
 
 	*mm = *nn = *pp = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 2; n < 15; n++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (m = 2; m; m++) {
 			f = PM2_REFERENCE_CLOCK * m / n;
 			if (f >= 150000 && f <= 300000) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (p = 0; p < 5; p++, f >>= 1) {
 					curr = (clk > f) ? clk - f : f - clk;
 					if (curr < delta) {
@@ -275,8 +290,26 @@ static void pm2_mnp(u32 clk, unsigned ch
 						*nn = n;
 						*pp = p;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
@@ -291,8 +324,23 @@ static void pm2v_mnp(u32 clk, unsigned c
 	s32 delta = 1000;
 
 	*mm = *nn = *pp = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = 1; m < 128; m++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (n = 2 * m + 1; n; n++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (p = 0; p < 2; p++) {
 				f = (PM2_REFERENCE_CLOCK >> (p + 1)) * n / m;
 				if (clk > f - delta && clk < f + delta) {
@@ -301,8 +349,26 @@ static void pm2v_mnp(u32 clk, unsigned c
 					*nn = n;
 					*pp = p;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1324,6 +1390,11 @@ static int pm2vfb_cursor(struct fb_info
 		int i;
 		int pos = PM2VI_RD_CURSOR_PATTERN;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < cursor->image.height; i++) {
 			int j = (cursor->image.width + 7) >> 3;
 			int k = 8 - j;
@@ -1350,6 +1421,12 @@ static int pm2vfb_cursor(struct fb_info
 				pm2v_RDAC_WR(par, pos++, 0);
 				pm2v_RDAC_WR(par, pos++, 0);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		while (pos < (1024 + PM2VI_RD_CURSOR_PATTERN)) {
@@ -1433,6 +1510,11 @@ static int pm2fb_cursor(struct fb_info *
 		WAIT_FIFO(par, 1);
 		pm2_WR(par, PM2R_RD_PALETTE_WRITE_ADDRESS, 0);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < cursor->image.height; i++) {
 			int j = (cursor->image.width + 7) >> 3;
 			int k = 8 - j;
@@ -1450,6 +1532,12 @@ static int pm2fb_cursor(struct fb_info *
 			}
 			for (; k > 0; k--)
 				pm2_WR(par, PM2R_RD_CURSOR_DATA, 0);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+			else {
+				break;
+			}
 		}
 		for (; i < 64; i++) {
 			int j = 8;
@@ -1459,6 +1547,11 @@ static int pm2fb_cursor(struct fb_info *
 		}
 
 		mask = (u8 *)cursor->mask;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < cursor->image.height; i++) {
 			int j = (cursor->image.width + 7) >> 3;
 			int k = 8 - j;
@@ -1471,6 +1564,12 @@ static int pm2fb_cursor(struct fb_info *
 			}
 			for (; k > 0; k--)
 				pm2_WR(par, PM2R_RD_CURSOR_DATA, 0);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+			else {
+				break;
+			}
 		}
 		for (; i < 64; i++) {
 			int j = 8;
diff -u -p a/video/maxinefb.c b/video/maxinefb.c
--- a/video/maxinefb.c
+++ b/video/maxinefb.c
@@ -140,6 +140,11 @@ int __init maxinefb_init(void)
 	maxinefb_fix.smem_start = fb_start;
 	
 	/* erase hardware cursor */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 512; i++) {
 		maxinefb_ims332_write_register(IMS332_REG_CURSOR_RAM + i,
 					       0);
@@ -149,6 +154,12 @@ int __init maxinefb_init(void)
 		   else
 		   maxinefb_ims332_write_register (IMS332_REG_CURSOR_RAM + i, 0xf0);
 		 */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	fb_info.fbops = &maxinefb_ops;
diff -u -p a/video/ffb.c b/video/ffb.c
--- a/video/ffb.c
+++ b/video/ffb.c
@@ -588,6 +588,11 @@ static void ffb_imageblit(struct fb_info
 		upa_writel(xy, &fbc->fontxy);
 		xy += (32 << 0);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < image->height; i++) {
 			u32 val = (((u32)data[0] << 24) |
 				   ((u32)data[1] << 16) |
@@ -597,6 +602,12 @@ static void ffb_imageblit(struct fb_info
 			upa_writel(val, &fbc->font);
 
 			data += stride;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		data = next_data;
@@ -608,6 +619,11 @@ static void ffb_imageblit(struct fb_info
 		upa_writel(width, &fbc->fontw);
 		upa_writel(xy, &fbc->fontxy);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < image->height; i++) {
 			u32 val = (((u32)data[0] << 24) |
 				   ((u32)data[1] << 16) |
@@ -617,6 +633,12 @@ static void ffb_imageblit(struct fb_info
 			upa_writel(val, &fbc->font);
 
 			data += stride;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -699,9 +721,20 @@ static int ffb_blank(int blank, struct f
 	}
 	upa_writel(FFB_DAC_TGEN, &dac->type);
 	upa_writel(val, &dac->value);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10; i++) {
 		upa_writel(FFB_DAC_TGEN, &dac->type);
 		upa_readl(&dac->value);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock_irqrestore(&par->lock, flags);
diff -u -p a/video/valkyriefb.c b/video/valkyriefb.c
--- a/video/valkyriefb.c
+++ b/video/valkyriefb.c
@@ -268,11 +268,22 @@ static void set_valkyrie_clock(unsigned
 	int i;
 
 #ifdef CONFIG_ADB_CUDA
-	for (i = 0; i < 3; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 3; ++i) {
 		cuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC,
 			     0x50, i + 1, params[i]);
 		while (!req.complete)
 			cuda_poll();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 #endif
 }
diff -u -p a/video/ep93xx-fb.c b/video/ep93xx-fb.c
--- a/video/ep93xx-fb.c
+++ b/video/ep93xx-fb.c
@@ -372,9 +372,20 @@ static int ep93xxfb_setcolreg(unsigned i
 		lut_current = !!(ctrl & EP93XXFB_LUT_SW_CONTROL_SWTCH);
 
 		if (lut_stat == lut_current) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 256; i++) {
 				ep93xxfb_writel(fbi, pal[i],
 					EP93XXFB_COLOR_LUT + (i << 2));
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			ep93xxfb_writel(fbi,
@@ -426,6 +437,11 @@ static int __init ep93xxfb_calc_fbsize(s
 		fb_size = EP93XXFB_MAX_XRES * EP93XXFB_MAX_YRES *
 			mach_info->bpp / 8;
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < mach_info->num_modes; i++) {
 			const struct fb_videomode *mode;
 			int size;
@@ -434,6 +450,12 @@ static int __init ep93xxfb_calc_fbsize(s
 			size = mode->xres * mode->yres * mach_info->bpp / 8;
 			if (size > fb_size)
 				fb_size = size;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
diff -u -p a/video/tmiofb.c b/video/tmiofb.c
--- a/video/tmiofb.c
+++ b/video/tmiofb.c
@@ -561,6 +561,11 @@ tmiofb_find_mode(struct fb_info *info, s
 	struct fb_videomode *best = NULL;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < data->num_modes; i++) {
 		struct fb_videomode *mode = data->modes + i;
 
@@ -568,6 +573,12 @@ tmiofb_find_mode(struct fb_info *info, s
 				&& (!best || (mode->xres < best->xres
 					   && mode->yres < best->yres)))
 			best = mode;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	return best;
diff -u -p a/video/s3c2410fb.c b/video/s3c2410fb.c
--- a/video/s3c2410fb.c
+++ b/video/s3c2410fb.c
@@ -726,6 +726,11 @@ static void s3c2410fb_write_palette(stru
 
 	fbi->palette_ready = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 256; i++) {
 		unsigned long ent = fbi->palette_buffer[i];
 		if (ent == PALETTE_BUFF_CLEAR)
@@ -742,6 +747,12 @@ static void s3c2410fb_write_palette(stru
 			fbi->palette_buffer[i] = PALETTE_BUFF_CLEAR;
 		else
 			fbi->palette_ready = 1;   /* retry */
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -932,6 +943,11 @@ static int __devinit s3c24xxfb_probe(str
 	info->clk_rate = clk_get_rate(info->clk);
 
 	/* find maximum required memory size for display */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mach_info->num_displays; i++) {
 		unsigned long smem_len = mach_info->displays[i].xres;
 
@@ -940,6 +956,12 @@ static int __devinit s3c24xxfb_probe(str
 		smem_len >>= 3;
 		if (fbinfo->fix.smem_len < smem_len)
 			fbinfo->fix.smem_len = smem_len;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+		else {
+		break;
+		}
 	}
 
 	/* Initialize video memory */
diff -u -p a/video/sgivwfb.c b/video/sgivwfb.c
--- a/video/sgivwfb.c
+++ b/video/sgivwfb.c
@@ -195,6 +195,11 @@ static void dbe_TurnOffDma(struct sgivw_
 	//    turned off for sure.  I've left this in for now, in
 	//    case dbe needs it.
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10000; i++) {
 		DBE_GETREG(frm_inhwctrl, readVal);
 		if (GET_DBE_FIELD(FRM_INHWCTRL, FRM_DMA_ENABLE, readVal) ==
@@ -215,6 +220,12 @@ static void dbe_TurnOffDma(struct sgivw_
 					break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -437,8 +448,19 @@ static int sgivwfb_set_par(struct fb_inf
 	/* dbe_InitGammaMap(); */
 	udelay(10);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 256; i++) {
 		DBE_ISETREG(gmap, i, (i << 24) | (i << 16) | (i << 8));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* dbe_TurnOn(); */
@@ -450,17 +472,39 @@ static int sgivwfb_set_par(struct fb_inf
 		dbe_TurnOffDma(par);
 
 	/* dbe_Initdbe(); */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 256; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 100; j++) {
 			DBE_GETREG(cm_fifo, readVal);
 			if (readVal != 0x00000000)
 				break;
 			else
 				udelay(10);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 
 		// DBE_ISETREG(cmap, i, 0x00000000);
 		DBE_ISETREG(cmap, i, (i << 8) | (i << 16) | (i << 24));
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/* dbe_InitFramebuffer(); */
@@ -511,8 +555,19 @@ static int sgivwfb_set_par(struct fb_inf
 	}
 	SET_DBE_FIELD(WID, BUF, outputVal, DBE_BMODE_BOTH);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 32; i++) {
 		DBE_ISETREG(mode_regs, i, outputVal);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* dbe_InitTiming(); */
@@ -632,6 +687,11 @@ static int sgivwfb_set_par(struct fb_inf
 	DBE_SETREG(did_control, 0);
 
 	// Wait for dbe to take frame settings
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 100000; i++) {
 		DBE_GETREG(frm_inhwctrl, readVal);
 		if (GET_DBE_FIELD(FRM_INHWCTRL, FRM_DMA_ENABLE, readVal) !=
@@ -639,6 +699,12 @@ static int sgivwfb_set_par(struct fb_inf
 			break;
 		else
 			udelay(1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (i == 100000)
diff -u -p a/video/atafb_mfb.c b/video/atafb_mfb.c
--- a/video/atafb_mfb.c
+++ b/video/atafb_mfb.c
@@ -65,11 +65,22 @@ void atafb_mfb_fillrect(struct fb_info *
 		else
 			fb_memclear(dest, height * (width >> 3));
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (rows = height; rows--; dest += next_line) {
 			if (color)
 				fb_memset255(dest, width >> 3);
 			else
 				fb_memclear_small(dest, width >> 3);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 }
diff -u -p a/video/au1200fb.c b/video/au1200fb.c
--- a/video/au1200fb.c
+++ b/video/au1200fb.c
@@ -686,9 +686,20 @@ static int fbinfo2index (struct fb_info
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < device_count; ++i) {
 		if (fb_info == _au1200fb_infos[i])
 			return i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	printk("au1200fb: ERROR: fbinfo2index failed!\n");
 	return -1;
@@ -1579,6 +1590,11 @@ static int __devinit au1200fb_drv_probe(
 	/* Kickstart the panel */
 	au1200_setpanel(panel);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (plane = 0; plane < device_count; ++plane) {
 		bpp = winbpp(win->w[plane].mode_winctrl1);
 		if (win->w[plane].xres == 0)
@@ -1613,11 +1629,22 @@ static int __devinit au1200fb_drv_probe(
 		 * Set page reserved so that mmap will work. This is necessary
 		 * since we'll be remapping normal memory.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (page = (unsigned long)fbdev->fb_phys;
 		     page < PAGE_ALIGN((unsigned long)fbdev->fb_phys +
 			     fbdev->fb_len);
 		     page += PAGE_SIZE) {
 			SetPageReserved(pfn_to_page(page >> PAGE_SHIFT)); /* LCD DMA is NOT coherent on Au1200 */
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		print_dbg("Framebuffer memory map at %p", fbdev->fb_mem);
 		print_dbg("phys=0x%08x, size=%dK", fbdev->fb_phys, fbdev->fb_len / 1024);
@@ -1643,6 +1670,12 @@ static int __devinit au1200fb_drv_probe(
 				fb_show_logo(fbi, FB_ROTATE_UR);
 			}
 #endif
+if (_cur < timeout) {
+			rdstcll(_cur);
+}
+else {
+			break;
+}
 	}
 
 	/* Now hook interrupt too */
@@ -1681,6 +1714,11 @@ static int __devexit au1200fb_drv_remove
 	/* Turn off the panel */
 	au1200_setpanel(NULL);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (plane = 0; plane < device_count; ++plane)	{
 		fbi = _au1200fb_infos[plane];
 		fbdev = fbi->par;
@@ -1697,6 +1735,12 @@ static int __devexit au1200fb_drv_remove
 
 		framebuffer_release(fbi);
 		_au1200fb_infos[plane] = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	free_irq(platform_get_irq(dev, 0), (void *)dev);
@@ -1723,9 +1767,20 @@ static int au1200fb_drv_resume(struct de
 	/* Kickstart the panel */
 	au1200_setpanel(panel);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < device_count; i++) {
 		fbi = _au1200fb_infos[i];
 		au1200fb_fb_set_par(fbi);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/s3fb.c b/video/s3fb.c
--- a/video/s3fb.c
+++ b/video/s3fb.c
@@ -310,11 +310,33 @@ static void s3fb_settile_fast(struct fb_
 	}
 
 	fb += 2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < map->height; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (c = 0; c < map->length; c++) {
 			fb_writeb(font[c * map->height + i], fb + c * 4);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		fb += 1024;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -367,16 +389,38 @@ static void s3fb_iplan_imageblit(struct
 	dst1 = info->screen_base + (image->dy * info->fix.line_length)
 		 + ((image->dx / 8) * 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < image->height; y++) {
 		src = src1;
 		dst = (u32 __iomem *) dst1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < image->width; x += 8) {
 			val = *(src++) * 0x01010101;
 			val = (val & fg) | (~val & bg);
 			fb_writel(val, dst++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		src1 += image->width / 8;
 		dst1 += info->fix.line_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -392,12 +436,34 @@ static void s3fb_iplan_fillrect(struct f
 	dst1 = info->screen_base + (rect->dy * info->fix.line_length)
 		 + ((rect->dx / 8) * 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < rect->height; y++) {
 		dst = (u32 __iomem *) dst1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < rect->width; x += 8) {
 			fb_writel(fg, dst++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dst1 += info->fix.line_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -424,16 +490,38 @@ static void s3fb_cfb4_imageblit(struct f
 	dst1 = info->screen_base + (image->dy * info->fix.line_length)
 		 + ((image->dx / 8) * 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < image->height; y++) {
 		src = src1;
 		dst = (u32 __iomem *) dst1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < image->width; x += 8) {
 			val = expand_pixel(*(src++));
 			val = (val & fg) | (~val & bg);
 			fb_writel(val, dst++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		src1 += image->width / 8;
 		dst1 += info->fix.line_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/jz4740_fb.c b/video/jz4740_fb.c
--- a/video/jz4740_fb.c
+++ b/video/jz4740_fb.c
@@ -277,9 +277,20 @@ static struct fb_videomode *jzfb_get_mod
 	size_t i;
 	struct fb_videomode *mode = jzfb->pdata->modes;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < jzfb->pdata->num_modes; ++i, ++mode) {
 		if (mode->xres == var->xres && mode->yres == var->yres)
 			return mode;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NULL;
@@ -558,9 +569,20 @@ static int jzfb_alloc_devmem(struct jzfb
 	void *page;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < jzfb->pdata->num_modes; ++mode, ++i) {
 		if (max_videosize < mode->xres * mode->yres)
 			max_videosize = mode->xres * mode->yres;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	max_videosize *= jzfb_get_controller_bpp(jzfb) >> 3;
@@ -580,10 +602,21 @@ static int jzfb_alloc_devmem(struct jzfb
 	if (!jzfb->vidmem)
 		goto err_free_framedesc;
 
-	for (page = jzfb->vidmem;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (page = jzfb->vidmem;
 		 page < jzfb->vidmem + PAGE_ALIGN(jzfb->vidmem_size);
 		 page += PAGE_SIZE) {
 		SetPageReserved(virt_to_page(page));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	jzfb->framedesc->next = jzfb->framedesc_phys;
diff -u -p a/video/fbmem.c b/video/fbmem.c
--- a/video/fbmem.c
+++ b/video/fbmem.c
@@ -124,6 +124,11 @@ void fb_pad_unaligned_buffer(u8 *dst, u3
 	int i, j;
 
 	for (i = height; i--; ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < idx; j++) {
 			tmp = dst[j];
 			tmp &= mask;
@@ -132,6 +137,12 @@ void fb_pad_unaligned_buffer(u8 *dst, u3
 			tmp = *src << shift_high;
 			dst[j+1] = tmp;
 			src++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		tmp = dst[idx];
 		tmp &= mask;
@@ -207,6 +218,11 @@ static void fb_set_logocmap(struct fb_in
 	palette_cmap.blue = palette_blue;
 	palette_cmap.transp = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < logo->clutsize; i += n) {
 		n = logo->clutsize - i;
 		/* palette_cmap provides space for only 16 colors at once */
@@ -214,13 +230,30 @@ static void fb_set_logocmap(struct fb_in
 			n = 16;
 		palette_cmap.start = 32 + i;
 		palette_cmap.len = n;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < n; ++j) {
 			palette_cmap.red[j] = clut[0] << 8 | clut[0];
 			palette_cmap.green[j] = clut[1] << 8 | clut[1];
 			palette_cmap.blue[j] = clut[2] << 8 | clut[2];
 			clut += 3;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		fb_set_cmap(&palette_cmap, info);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -246,11 +279,22 @@ static void  fb_set_logo_truepalette(str
 	greenshift = info->var.green.offset - (8 - info->var.green.length);
 	blueshift  = info->var.blue.offset  - (8 - info->var.blue.length);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for ( i = 0; i < logo->clutsize; i++) {
 		palette[i+32] = (safe_shift((clut[0] & redmask), redshift) |
 				 safe_shift((clut[1] & greenmask), greenshift) |
 				 safe_shift((clut[2] & bluemask), blueshift));
 		clut += 3;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -296,24 +340,69 @@ static void fb_set_logo(struct fb_info *
 
 	switch (depth) {
 	case 4:
-		for (i = 0; i < logo->height; i++)
-			for (j = 0; j < logo->width; src++) {
-				*dst++ = *src >> 4;
-				j++;
-				if (j < logo->width) {
-					*dst++ = *src & 0x0f;
+		for (i = 0; i < logo->height; i++) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (j = 0; j < logo->width; src++) {
+					*dst++ = *src >> 4;
 					j++;
+					if (j < logo->width) {
+							*dst++ = *src & 0x0f;
+							j++;
+					}
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
 				}
 			}
 		break;
 	case 1:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < logo->height; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < logo->width; src++) {
 				d = *src ^ xor;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (k = 7; k >= 0; k--) {
 					*dst++ = ((d >> k) & 1) ? fg : 0;
 					j++;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
+				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
 				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 		break;
@@ -421,28 +510,72 @@ static void fb_do_show_logo(struct fb_in
 	unsigned int x;
 
 	if (rotate == FB_ROTATE_UR) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0;
 		     x < num && image->dx + image->width <= info->var.xres;
 		     x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dx += image->width + 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else if (rotate == FB_ROTATE_UD) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < num && image->dx >= 0; x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dx -= image->width + 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else if (rotate == FB_ROTATE_CW) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0;
 		     x < num && image->dy + image->height <= info->var.yres;
 		     x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dy += image->height + 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else if (rotate == FB_ROTATE_CCW) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < num && image->dy >= 0; x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dy -= image->height + 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -1510,8 +1643,18 @@ static bool fb_do_apertures_overlap(stru
 	if (!hwa || !gena)
 		return false;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < hwa->count; ++i) {
 		struct aperture *h = &hwa->ranges[i];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < gena->count; ++j) {
 			struct aperture *g = &gena->ranges[j];
 			printk(KERN_DEBUG "checking generic (%llx %llx) vs hw (%llx %llx)\n",
@@ -1521,6 +1664,18 @@ static bool fb_do_apertures_overlap(stru
 				(unsigned long long)h->size);
 			if (apertures_overlap(g, h))
 				return true;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}
 
@@ -1536,6 +1691,11 @@ static void do_remove_conflicting_frameb
 	int i;
 
 	/* check all firmware fbs and kick off if the base addr overlaps */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0 ; i < FB_MAX; i++) {
 		struct apertures_struct *gen_aper;
 		if (!registered_fb[i])
@@ -1554,6 +1714,12 @@ static void do_remove_conflicting_frameb
 			       name, registered_fb[i]->fix.id);
 			do_unregister_framebuffer(registered_fb[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1856,6 +2022,11 @@ int fb_get_options(char *name, char **op
 		retval = 1;
 
 	if (name_len && !retval) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < FB_MAX; i++) {
 			if (video_options[i] == NULL)
 				continue;
@@ -1865,6 +2036,12 @@ int fb_get_options(char *name, char **op
 			if (!strncmp(name, opt, name_len) &&
 			    opt[name_len] == ':')
 				options = opt + name_len + 1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 	if (options && !strncmp(options, "off", 3))
diff -u -p a/video/modedb.c b/video/modedb.c
--- a/video/modedb.c
+++ b/video/modedb.c
@@ -593,6 +593,11 @@ int fb_find_mode(struct fb_var_screeninf
 		int margins = 0;
 		u32 best, diff, tdiff;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = namelen-1; i >= 0; i--) {
 			switch (name[i]) {
 			case '@':
@@ -647,6 +652,12 @@ int fb_find_mode(struct fb_var_screeninf
 			default:
 				goto done;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (i < 0 && yres_specified) {
 			xres = simple_strtol(name, NULL, 10);
@@ -707,6 +718,11 @@ done:
 
 		diff = -1;
 		best = -1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dbsize; i++) {
 			if ((name_matches(db[i], name, namelen) ||
 			     (res_specified && res_matches(db[i], xres, yres))) &&
@@ -719,6 +735,12 @@ done:
 					best = i;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (best != -1) {
 			fb_try_mode(var, info, &db[best], bpp);
@@ -728,6 +750,11 @@ done:
 		diff = 2 * (xres + yres);
 		best = -1;
 		DPRINTK("Trying best-fit modes\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dbsize; i++) {
 			DPRINTK("Trying %ix%i\n", db[i].xres, db[i].yres);
 			if (!fb_try_mode(var, info, &db[i], bpp)) {
@@ -746,6 +773,12 @@ done:
 					best = i;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (best != -1) {
 			fb_try_mode(var, info, &db[best], bpp);
@@ -1059,9 +1092,20 @@ void fb_videomode_to_modelist(const stru
 
 	INIT_LIST_HEAD(head);
 
-	for (i = 0; i < num; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+for (i = 0; i < num; i++) {
 		if (fb_add_videomode(&modedb[i], head))
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/video/ps3fb.c b/video/ps3fb.c
--- a/video/ps3fb.c
+++ b/video/ps3fb.c
@@ -657,11 +657,22 @@ static int ps3fb_set_par(struct fb_info
 	if (par->full_offset)
 		lines++;
 	maxlines = info->fix.smem_len / ddr_line_length;
-	for (dst = 0; lines; dst += maxlines * ddr_line_length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (dst = 0; lines; dst += maxlines * ddr_line_length) {
 		unsigned int l = min(lines, maxlines);
 		ps3fb_sync_image(info->device, 0, dst, 0, vmode->xres, l,
 				 ddr_line_length, ddr_line_length);
 		lines -= l;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/matrox/matroxfb_accel.c b/video/matrox/matroxfb_accel.c
--- a/video/matrox/matroxfb_accel.c
+++ b/video/matrox/matroxfb_accel.c
@@ -88,16 +88,38 @@
 static inline void matrox_cfb4_pal(u_int32_t* pal) {
 	unsigned int i;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i++) {
 		pal[i] = i * 0x11111111U;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
 static inline void matrox_cfb8_pal(u_int32_t* pal) {
 	unsigned int i;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i++) {
 		pal[i] = i * 0x01010101U;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -372,18 +394,40 @@ static void matroxfb_cfb4_clear(struct m
 			unsigned int uaddr = sy * step + sx - 1;
 			u_int32_t loop;
 			u_int8_t bgx2 = bgx & 0xF0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (loop = height; loop > 0; loop --) {
 				mga_writeb(vbase, uaddr, (mga_readb(vbase, uaddr) & 0x0F) | bgx2);
 				uaddr += step;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		if (whattodo & 2) {
 			unsigned int uaddr = sy * step + sx + width;
 			u_int32_t loop;
 			u_int8_t bgx2 = bgx & 0x0F;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (loop = height; loop > 0; loop --) {
 				mga_writeb(vbase, uaddr, (mga_readb(vbase, uaddr) & 0xF0) | bgx2);
 				uaddr += step;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -482,9 +526,20 @@ static void matroxfb_1bpp_imageblit(stru
 			while (height--) {
 				size_t i;
 				
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < step; i += 4) {
 					/* Hope that there are at least three readable bytes beyond the end of bitmap */
 					fb_writel(get_unaligned((u_int32_t*)(chardata + i)),mmio.vaddr);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				chardata += step;
 			}
diff -u -p a/video/matrox/matroxfb_crtc2.c b/video/matrox/matroxfb_crtc2.c
--- a/video/matrox/matroxfb_crtc2.c
+++ b/video/matrox/matroxfb_crtc2.c
@@ -137,6 +137,11 @@ static void matroxfb_dh_restore(struct m
 		int i;
 
 		mga_outl(0x3C10, tmp & ~0x02000000);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 2; i++) {
 			unsigned int nl;
 			unsigned int lastl = 0;
@@ -144,6 +149,12 @@ static void matroxfb_dh_restore(struct m
 			while ((nl = mga_inl(0x3C48) & 0xFFF) >= lastl) {
 				lastl = nl;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	mga_outl(0x3C10, tmp);
@@ -354,6 +365,11 @@ static int matroxfb_dh_set_par(struct fb
 		pos += m2info->video.offbase;
 		cnt = 0;
 		down_read(&minfo->altout.lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {
 			if (minfo->outputs[out].src == MATROXFB_SRC_CRTC2) {
 				cnt++;
@@ -361,6 +377,12 @@ static int matroxfb_dh_set_par(struct fb
 					minfo->outputs[out].output->compute(minfo->outputs[out].data, &mt);
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		minfo->crtc2.pixclock = mt.pixclock;
 		minfo->crtc2.mnp = mt.mnp;
@@ -373,17 +395,39 @@ static int matroxfb_dh_set_par(struct fb
 		DAC1064_global_init(minfo);
 		DAC1064_global_restore(minfo);
 		down_read(&minfo->altout.lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {
 			if (minfo->outputs[out].src == MATROXFB_SRC_CRTC2 &&
 			    minfo->outputs[out].output->program) {
 				minfo->outputs[out].output->program(minfo->outputs[out].data);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {
 			if (minfo->outputs[out].src == MATROXFB_SRC_CRTC2 &&
 			    minfo->outputs[out].output->start) {
 				minfo->outputs[out].output->start(minfo->outputs[out].data);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		up_read(&minfo->altout.lock);
 	}
@@ -466,6 +510,11 @@ static int matroxfb_dh_ioctl(struct fb_i
 
 				if (get_user(tmp, (u_int32_t __user *)arg))
 					return -EFAULT;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (out = 0; out < 32; out++) {
 					if (tmp & (1 << out)) {
 						if (out >= MATROXFB_MAX_OUTPUTS)
@@ -480,6 +529,12 @@ static int matroxfb_dh_ioctl(struct fb_i
 								return -EBUSY;
 						}
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (minfo->devflags.panellink) {
 					if (tmp & MATROXFB_OUTPUT_CONN_DFP)
@@ -488,6 +543,11 @@ static int matroxfb_dh_ioctl(struct fb_i
 						return -EBUSY;
 				}
 				changes = 0;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {
 					if (tmp & (1 << out)) {
 						if (minfo->outputs[out].src != MATROXFB_SRC_CRTC2) {
@@ -498,6 +558,12 @@ static int matroxfb_dh_ioctl(struct fb_i
 						changes = 1;
 						minfo->outputs[out].src = MATROXFB_SRC_NONE;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (!changes)
 					return 0;
@@ -509,10 +575,21 @@ static int matroxfb_dh_ioctl(struct fb_i
 				u_int32_t conn = 0;
 				int out;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {
 					if (minfo->outputs[out].src == MATROXFB_SRC_CRTC2) {
 						conn |= 1 << out;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (put_user(conn, (u_int32_t __user *)arg))
 					return -EFAULT;
@@ -523,6 +600,11 @@ static int matroxfb_dh_ioctl(struct fb_i
 				u_int32_t tmp = 0;
 				int out;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {
 					if (minfo->outputs[out].output) {
 						switch (minfo->outputs[out].src) {
@@ -532,6 +614,12 @@ static int matroxfb_dh_ioctl(struct fb_i
 								break;
 						}
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (minfo->devflags.panellink) {
 					tmp &= ~MATROXFB_OUTPUT_CONN_DFP;
diff -u -p a/video/matrox/matroxfb_maven.c b/video/matrox/matroxfb_maven.c
--- a/video/matrox/matroxfb_maven.c
+++ b/video/matrox/matroxfb_maven.c
@@ -111,6 +111,11 @@ static const struct mctl maven_controls[
 static int get_ctrl_id(__u32 v4l2_id) {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAVCTRLS; i++) {
 		if (v4l2_id < maven_controls[i].desc.id) {
 			if (maven_controls[i].desc.id == 0x08000000) {
@@ -121,6 +126,12 @@ static int get_ctrl_id(__u32 v4l2_id) {
 		if (v4l2_id == maven_controls[i].desc.id) {
 			return i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EINVAL;
 }
@@ -715,7 +726,12 @@ static int maven_find_exact_clocks(unsig
 	m->regs[0x81] = 0x07;
 	m->regs[0x82] = 0x81;
 
-	for (x = 0; x < 8; x++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (x = 0; x < 8; x++) {
 		unsigned int c;
 		unsigned int uninitialized_var(a), uninitialized_var(b),
 			     uninitialized_var(h2);
@@ -733,6 +749,12 @@ static int maven_find_exact_clocks(unsig
 				m->htotal = h - 2;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return err != ~0U;
 }
@@ -1209,8 +1231,19 @@ static int maven_init_client(struct i2c_
 	{
 		unsigned int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < MAVCTRLS; ++i) {
 			*get_ctrl_ptr(md, i) = maven_controls[i].desc.default_value;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/video/matrox/matroxfb_misc.c b/video/matrox/matroxfb_misc.c
--- a/video/matrox/matroxfb_misc.c
+++ b/video/matrox/matroxfb_misc.c
@@ -372,10 +372,21 @@ void matroxfb_vgaHWrestore(struct matrox
 		mga_setr(M_CRTC_INDEX, i, hw->CRTC[i]);
 	for (i = 0; i < 9; i++)
 		mga_setr(M_GRAPHICS_INDEX, i, hw->GCTL[i]);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 21; i++) {
 		mga_inb(M_ATTR_RESET);
 		mga_outb(M_ATTR_INDEX, i);
 		mga_outb(M_ATTR_INDEX, hw->ATTR[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mga_outb(M_PALETTE_MASK, 0xFF);
 	mga_outb(M_DAC_REG, 0x00);
@@ -403,8 +414,19 @@ static void get_pins(unsigned char __iom
 		*dst++ = 0x41;
 		*dst++ = pins_len;
 		cksum = 0x2E + 0x41 + pins_len;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 3; i < pins_len; i++) {
 			cksum += *dst++ = readb(pins+i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (cksum) {
 			return;
@@ -416,8 +438,19 @@ static void get_pins(unsigned char __iom
 
 		*dst++ = 0x40;
 		*dst++ = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 2; i < 0x40; i++) {
 			*dst++ = readb(pins+i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		bd->pins_len = 0x40;
 	}
diff -u -p a/video/matrox/matroxfb_g450.c b/video/matrox/matroxfb_g450.c
--- a/video/matrox/matroxfb_g450.c
+++ b/video/matrox/matroxfb_g450.c
@@ -66,6 +66,11 @@ static const struct mctl g450_controls[]
 static int get_ctrl_id(__u32 v4l2_id) {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < G450CTRLS; i++) {
 		if (v4l2_id < g450_controls[i].desc.id) {
 			if (g450_controls[i].desc.id == 0x08000000) {
@@ -76,6 +81,12 @@ static int get_ctrl_id(__u32 v4l2_id) {
 		if (v4l2_id == g450_controls[i].desc.id) {
 			return i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EINVAL;
 }
@@ -89,8 +100,19 @@ static void tvo_fill_defaults(struct mat
 {
 	unsigned int i;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < G450CTRLS; i++) {
 		*get_ctrl_ptr(minfo, i) = g450_controls[i].desc.default_value;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -511,8 +533,19 @@ static void cve2_init_TV(struct matrox_f
 	
 	cve2_set_reg(minfo, 0x3E, 0x01);
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 0x3E; i++) {
 		LR(i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	cve2_set_reg(minfo, 0x3E, 0x00);
 }
diff -u -p a/video/matrox/matroxfb_Ti3026.c b/video/matrox/matroxfb_Ti3026.c
--- a/video/matrox/matroxfb_Ti3026.c
+++ b/video/matrox/matroxfb_Ti3026.c
@@ -584,8 +584,19 @@ static void Ti3026_restore(struct matrox
 	for (i = 0; i < 6; i++)
 		mga_setr(M_EXTVGA_INDEX, i, hw->CRTCEXT[i]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 21; i++) {
 		outTi3026(minfo, DACseq[i], hw->DACreg[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	outTi3026(minfo, TVP3026_XPLLADDR, 0x00);
@@ -656,9 +667,20 @@ static void Ti3026_restore(struct matrox
 
 #ifdef DEBUG
 	dprintk(KERN_DEBUG "3026DACregs ");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 21; i++) {
 		dprintk("R%02X=%02X ", DACseq[i], hw->DACreg[i]);
 		if ((i & 0x7) == 0x7) dprintk(KERN_DEBUG "continuing... ");
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	dprintk(KERN_DEBUG "DACclk ");
 	for (i = 0; i < 6; i++)
diff -u -p a/video/matrox/matroxfb_base.c b/video/matrox/matroxfb_base.c
--- a/video/matrox/matroxfb_base.c
+++ b/video/matrox/matroxfb_base.c
@@ -805,11 +805,22 @@ static int matroxfb_set_par(struct fb_in
 			hw = &minfo->hw;
 
 			down_read(&minfo->altout.lock);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {
 				if (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&
 				    minfo->outputs[out].output->compute) {
 					minfo->outputs[out].output->compute(minfo->outputs[out].data, &mt);
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			up_read(&minfo->altout.lock);
 			minfo->crtc1.pixclock = mt.pixclock;
@@ -825,17 +836,39 @@ static int matroxfb_set_par(struct fb_in
 			minfo->hw_switch->restore(minfo);
 			update_crtc2(minfo, pos);
 			down_read(&minfo->altout.lock);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {
 				if (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&
 				    minfo->outputs[out].output->program) {
 					minfo->outputs[out].output->program(minfo->outputs[out].data);
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {
 				if (minfo->outputs[out].src == MATROXFB_SRC_CRTC1 &&
 				    minfo->outputs[out].output->start) {
 					minfo->outputs[out].output->start(minfo->outputs[out].data);
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			up_read(&minfo->altout.lock);
 			matrox_cfbX_init(minfo);
@@ -995,6 +1028,11 @@ static int matroxfb_ioctl(struct fb_info
 
 				if (copy_from_user(&tmp, argp, sizeof(tmp)))
 					return -EFAULT;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < 32; i++) {
 					if (tmp & (1 << i)) {
 						if (i >= MATROXFB_MAX_OUTPUTS)
@@ -1009,19 +1047,41 @@ static int matroxfb_ioctl(struct fb_info
 								return -EBUSY;
 						}
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (minfo->devflags.panellink) {
 					if (tmp & MATROXFB_OUTPUT_CONN_DFP) {
 						if (tmp & MATROXFB_OUTPUT_CONN_SECONDARY)
 							return -EINVAL;
+						unsigned long long delta = (cpu / khz / HZ) * 2;
+						unsigned long long _start = 0;
+						unsigned long long _cur = 0;
+						unsigned long long timeout;
+						timeout = rdstcll(start) + delta;
 						for (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {
 							if (minfo->outputs[i].src == MATROXFB_SRC_CRTC2) {
 								return -EBUSY;
 							}
+							if (_cur < timeout) {
+								rdstcll(_cur);
+							}
+							else {
+								break;
+							}
 						}
 					}
 				}
 				changes = 0;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {
 					if (tmp & (1 << i)) {
 						if (minfo->outputs[i].src != MATROXFB_SRC_CRTC1) {
@@ -1032,6 +1092,12 @@ static int matroxfb_ioctl(struct fb_info
 						changes = 1;
 						minfo->outputs[i].src = MATROXFB_SRC_NONE;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (!changes)
 					return 0;
@@ -1043,10 +1109,21 @@ static int matroxfb_ioctl(struct fb_info
 				u_int32_t conn = 0;
 				int i;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {
 					if (minfo->outputs[i].src == MATROXFB_SRC_CRTC1) {
 						conn |= 1 << i;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (put_user(conn, (u_int32_t __user *)arg))
 					return -EFAULT;
@@ -1057,6 +1134,11 @@ static int matroxfb_ioctl(struct fb_info
 				u_int32_t conn = 0;
 				int i;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {
 					if (minfo->outputs[i].output) {
 						switch (minfo->outputs[i].src) {
@@ -1066,6 +1148,12 @@ static int matroxfb_ioctl(struct fb_info
 								break;
 						}
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (minfo->devflags.panellink) {
 					if (conn & MATROXFB_OUTPUT_CONN_DFP)
@@ -1082,10 +1170,21 @@ static int matroxfb_ioctl(struct fb_info
 				u_int32_t conn = 0;
 				int i;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < MATROXFB_MAX_OUTPUTS; i++) {
 					if (minfo->outputs[i].output) {
 						conn |= 1 << i;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (put_user(conn, (u_int32_t __user *)arg))
 					return -EFAULT;
@@ -1931,6 +2030,11 @@ int matroxfb_register_driver(struct matr
 	struct matrox_fb_info* minfo;
 
 	list_add(&drv->node, &matroxfb_driver_list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (minfo = matroxfb_l(matroxfb_list.next);
 	     minfo != matroxfb_l(&matroxfb_list);
 	     minfo = matroxfb_l(minfo->next_fb.next)) {
@@ -1943,6 +2047,12 @@ int matroxfb_register_driver(struct matr
 			minfo->drivers_data[minfo->drivers_count] = p;
 			minfo->drivers[minfo->drivers_count++] = drv;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1951,6 +2061,11 @@ void matroxfb_unregister_driver(struct m
 	struct matrox_fb_info* minfo;
 
 	list_del(&drv->node);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (minfo = matroxfb_l(matroxfb_list.next);
 	     minfo != matroxfb_l(&matroxfb_list);
 	     minfo = matroxfb_l(minfo->next_fb.next)) {
@@ -1965,6 +2080,12 @@ void matroxfb_unregister_driver(struct m
 			} else
 				i++;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -1992,11 +2113,22 @@ static void matroxfb_unregister_device(s
 	int i;
 
 	list_del(&minfo->next_fb);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < minfo->drivers_count; i++) {
 		struct matroxfb_driver* drv = minfo->drivers[i];
 
 		if (drv && drv->remove)
 			drv->remove(minfo, minfo->drivers_data[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -2011,11 +2143,22 @@ static int matroxfb_probe(struct pci_dev
 
 	svid = pdev->subsystem_vendor;
 	sid = pdev->subsystem_device;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (b = dev_list; b->vendor; b++) {
 		if ((b->vendor != pdev->vendor) || (b->device != pdev->device) || (b->rev < pdev->revision)) continue;
 		if (b->svid)
 			if ((b->svid != svid) || (b->sid != sid)) continue;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* not match... */
 	if (!b->vendor)
diff -u -p a/video/matrox/g450_pll.c b/video/matrox/g450_pll.c
--- a/video/matrox/g450_pll.c
+++ b/video/matrox/g450_pll.c
@@ -211,17 +211,39 @@ static inline int g450_isplllocked(const
 {
 	unsigned int j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < 1000; j++) {
 		if (matroxfb_DAC_in(minfo, regidx) & 0x40) {
 			unsigned int r = 0;
 			int i;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 100; i++) {
 				r += matroxfb_DAC_in(minfo, regidx) & 0x40;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			return r >= (90 * 0x40);
 		}
 		/* udelay(1)... but DAC_in is much slower... */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -259,6 +281,11 @@ static inline unsigned int g450_findwork
 	unsigned int idx;
 	unsigned int mnpfound = mnparray[0];
 		
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < mnpcount; idx++) {
 		unsigned int sarray[3];
 		unsigned int *sptr;
@@ -292,6 +319,12 @@ static inline unsigned int g450_findwork
 				found = 1;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	g450_setpll(minfo, mnpfound, pll);
 	return mnpfound;
@@ -312,6 +345,11 @@ static int g450_checkcache(struct matrox
 	unsigned int i;
 	
 	mnp_key &= G450_MNP_FREQBITS;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ci->valid; i++) {
 		if (ci->data[i].mnp_key == mnp_key) {
 			unsigned int mnp;
@@ -324,6 +362,12 @@ static int g450_checkcache(struct matrox
 			}
 			return mnp;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NO_MORE_MNP;
 }
@@ -435,6 +479,11 @@ static int __g450_setclk(struct matrox_f
 		unsigned int mnp;
 		unsigned int xvco;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (mnp = g450_firstpll(minfo, pi, &xvco, fout); mnp != NO_MORE_MNP; mnp = g450_nextpll(minfo, pi, &xvco, mnp)) {
 			unsigned int idx;
 			unsigned int vco;
@@ -485,6 +534,12 @@ static int __g450_setclk(struct matrox_f
 			mnparray[idx] = mnp;
 			deltaarray[idx] = delta;
 			mnpcount++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	/* VideoPLL and PixelPLL matched: do nothing... In all other cases we should get at least one frequency */
diff -u -p a/video/matrox/matroxfb_DAC1064.c b/video/matrox/matroxfb_DAC1064.c
--- a/video/matrox/matroxfb_DAC1064.c
+++ b/video/matrox/matroxfb_DAC1064.c
@@ -391,15 +391,31 @@ static int DAC1064_init_2(struct matrox_
 	if (minfo->fbcon.var.bits_per_pixel > 16) {	/* 256 entries */
 		int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 256; i++) {
 			hw->DACpal[i * 3 + 0] = i;
 			hw->DACpal[i * 3 + 1] = i;
 			hw->DACpal[i * 3 + 2] = i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else if (minfo->fbcon.var.bits_per_pixel > 8) {
 		if (minfo->fbcon.var.green.length == 5) {	/* 0..31, 128..159 */
 			int i;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 32; i++) {
 				/* with p15 == 0 */
 				hw->DACpal[i * 3 + 0] = i << 3;
@@ -409,14 +425,31 @@ static int DAC1064_init_2(struct matrox_
 				hw->DACpal[(i + 128) * 3 + 0] = i << 3;
 				hw->DACpal[(i + 128) * 3 + 1] = i << 3;
 				hw->DACpal[(i + 128) * 3 + 2] = i << 3;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
 			int i;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 64; i++) {		/* 0..63 */
 				hw->DACpal[i * 3 + 0] = i << 3;
 				hw->DACpal[i * 3 + 1] = i << 2;
 				hw->DACpal[i * 3 + 2] = i << 3;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	} else {
@@ -445,9 +478,20 @@ static void DAC1064_restore_1(struct mat
 	{
 		unsigned int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < sizeof(MGA1064_DAC_regs); i++) {
 			if ((i != POS1064_XPIXCLKCTRL) && (i != POS1064_XMISCCTRL))
 				outDAC1064(minfo, MGA1064_DAC_regs[i], hw->DACreg[i]);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
@@ -466,9 +510,20 @@ static void DAC1064_restore_2(struct mat
 
 #ifdef DEBUG
 	dprintk(KERN_DEBUG "DAC1064regs ");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sizeof(MGA1064_DAC_regs); i++) {
 		dprintk("R%02X=%02X ", MGA1064_DAC_regs[i], minfo->hw.DACreg[i]);
 		if ((i & 0x7) == 0x7) dprintk(KERN_DEBUG "continuing... ");
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	dprintk(KERN_DEBUG "DAC1064clk ");
 	for (i = 0; i < 6; i++)
diff -u -p a/video/cirrusfb.c b/video/cirrusfb.c
--- a/video/cirrusfb.c
+++ b/video/cirrusfb.c
@@ -2778,6 +2778,11 @@ static void bestclock(long freq, int *no
 
 	diff = freq;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 32; n < 128; n++) {
 		int s = 0;
 
@@ -2813,6 +2818,12 @@ static void bestclock(long freq, int *no
 				*div = s;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/cyber2000fb.c b/video/cyber2000fb.c
--- a/video/cyber2000fb.c
+++ b/video/cyber2000fb.c
@@ -463,11 +463,22 @@ static void cyber2000fb_set_timing(struc
 	/*
 	 * Blank palette
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NR_PALETTE; i++) {
 		cyber2000fb_writeb(i, 0x3c8, cfb);
 		cyber2000fb_writeb(0, 0x3c9, cfb);
 		cyber2000fb_writeb(0, 0x3c9, cfb);
 		cyber2000fb_writeb(0, 0x3c9, cfb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	cyber2000fb_writeb(0xef, 0x3c2, cfb);
@@ -1040,18 +1051,40 @@ static int cyber2000fb_blank(int blank,
 	 * Soft blank/unblank the display.
 	 */
 	if (blank) {	/* soft blank */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < NR_PALETTE; i++) {
 			cyber2000fb_writeb(i, 0x3c8, cfb);
 			cyber2000fb_writeb(0, 0x3c9, cfb);
 			cyber2000fb_writeb(0, 0x3c9, cfb);
 			cyber2000fb_writeb(0, 0x3c9, cfb);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 	} else {	/* unblank */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < NR_PALETTE; i++) {
 			cyber2000fb_writeb(i, 0x3c8, cfb);
 			cyber2000fb_writeb(cfb->palette[i].red, 0x3c9, cfb);
 			cyber2000fb_writeb(cfb->palette[i].green, 0x3c9, cfb);
 			cyber2000fb_writeb(cfb->palette[i].blue, 0x3c9, cfb);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 	}
 
diff -u -p a/video/pmagb-b-fb.c b/video/pmagb-b-fb.c
--- a/video/pmagb-b-fb.c
+++ b/video/pmagb-b-fb.c
@@ -193,6 +193,11 @@ static void __devinit pmagbbfb_osc_setup
 	int i, j;
 
 	gp0_write(par, 0);				/* select Osc0 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < 16; j++) {
 		mb();
 		sfb_write(par, SFB_REG_TCCLK_COUNT, 0);
@@ -203,9 +208,20 @@ static void __devinit pmagbbfb_osc_setup
 			udelay(1);
 		}
 		count0 += sfb_read(par, SFB_REG_VIDCLK_COUNT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	gp0_write(par, 1);				/* select Osc1 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < 16; j++) {
 		mb();
 		sfb_write(par, SFB_REG_TCCLK_COUNT, 0);
@@ -216,6 +232,12 @@ static void __devinit pmagbbfb_osc_setup
 			udelay(1);
 		}
 		count1 += sfb_read(par, SFB_REG_VIDCLK_COUNT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	freq0 = (freqtc * count0 + counttc / 2) / counttc;
diff -u -p a/video/pvr2fb.c b/video/pvr2fb.c
--- a/video/pvr2fb.c
+++ b/video/pvr2fb.c
@@ -720,6 +720,11 @@ static ssize_t pvr2fb_write(struct fb_in
 	}
 
 	/* Not contiguous, writeout per-page instead.. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nr_pages; i++, dst += PAGE_SIZE) {
 		if ((*ppos + (i << PAGE_SHIFT)) > fb_info->fix.smem_len) {
 			ret = -ENOSPC;
@@ -729,6 +734,12 @@ static ssize_t pvr2fb_write(struct fb_in
 		dma_write_page(shdma, (unsigned long)page_address(pages[i]), 0);
 		dma_write_page(pvr2dma, 0, dst);
 		dma_wait_for_completion(pvr2dma);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
@@ -998,6 +1009,11 @@ static int __devinit pvr2_get_param(cons
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0 ; i < size ; i++ ) {
 		if (s != NULL) {
 			if (!strnicmp(p[i].name, s, strlen(s)))
@@ -1006,6 +1022,12 @@ static int __devinit pvr2_get_param(cons
 			if (p[i].val == val)
 				return (int)p[i].name;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return -1;
 }
@@ -1118,11 +1140,22 @@ static void __exit pvr2fb_exit(void)
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(board_driver); i++) {
 		struct pvr2_board *pvr_board = board_driver + i;
 
 		if (pvr_board->exit)
 			pvr_board->exit();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 #ifdef CONFIG_SH_STORE_QUEUES
diff -u -p a/video/gbefb.c b/video/gbefb.c
--- a/video/gbefb.c
+++ b/video/gbefb.c
@@ -234,6 +234,11 @@ static void gbe_turn_off(void)
 
 	/* We have to wait through two vertical retrace periods before
 	 * the pixel DMA is turned off for sure. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10000; i++) {
 		val = gbe->frm_inhwctrl;
 		if (GET_GBE_FIELD(FRM_INHWCTRL, FRM_DMA_ENABLE, val)) {
@@ -250,6 +255,12 @@ static void gbe_turn_off(void)
 					break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (i == 10000)
 		printk(KERN_ERR "gbefb: turn off DMA timed out\n");
@@ -285,12 +296,23 @@ static void gbe_turn_off(void)
 	SET_GBE_FIELD(VT_XY, FREEZE, val, 1);
 	gbe->vt_xy = val;
 	udelay(10000);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10000; i++) {
 		val = gbe->vt_xy;
 		if (GET_GBE_FIELD(VT_XY, FREEZE, val) != 1)
 			udelay(10);
 		else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 	if (i == 10000)
 		printk(KERN_ERR "gbefb: turn off pixel clock timed out\n");
@@ -300,12 +322,23 @@ static void gbe_turn_off(void)
 	SET_GBE_FIELD(DOTCLK, RUN, val, 0);
 	gbe->dotclock = val;
 	udelay(10000);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10000; i++) {
 		val = gbe->dotclock;
 		if (GET_GBE_FIELD(DOTCLK, RUN, val))
 			udelay(10);
 		else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 	if (i == 10000)
 		printk(KERN_ERR "gbefb: turn off dotclock timed out\n");
@@ -337,12 +370,23 @@ static void gbe_turn_on(void)
 	SET_GBE_FIELD(DOTCLK, RUN, val, 1);
 	gbe->dotclock = val;
 	udelay(10000);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10000; i++) {
 		val = gbe->dotclock;
 		if (GET_GBE_FIELD(DOTCLK, RUN, val) != 1)
 			udelay(10);
 		else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 	if (i == 10000)
 		printk(KERN_ERR "gbefb: turn on dotclock timed out\n");
@@ -352,12 +396,23 @@ static void gbe_turn_on(void)
 	SET_GBE_FIELD(VT_XY, FREEZE, val, 0);
 	gbe->vt_xy = val;
 	udelay(10000);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10000; i++) {
 		val = gbe->vt_xy;
 		if (GET_GBE_FIELD(VT_XY, FREEZE, val))
 			udelay(10);
 		else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 	if (i == 10000)
 		printk(KERN_ERR "gbefb: turn on pixel clock timed out\n");
@@ -367,12 +422,23 @@ static void gbe_turn_on(void)
 	SET_GBE_FIELD(FRM_CONTROL, FRM_DMA_ENABLE, val, 1);
 	gbe->frm_control = val;
 	udelay(1000);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10000; i++) {
 		val = gbe->frm_inhwctrl;
 		if (GET_GBE_FIELD(FRM_INHWCTRL, FRM_DMA_ENABLE, val) != 1)
 			udelay(10);
 		else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 	if (i == 10000)
 		printk(KERN_ERR "gbefb: turn on DMA timed out\n");
@@ -384,6 +450,11 @@ static void gbe_loadcmap(void)
 {
 	int i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 256; i++) {
 		for (j = 0; j < 1000 && gbe->cm_fifo >= 63; j++)
 			udelay(10);
@@ -391,6 +462,12 @@ static void gbe_loadcmap(void)
 			printk(KERN_ERR "gbefb: cmap FIFO timeout\n");
 
 		gbe->cmap[i] = gbe_cmap[i];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -484,27 +561,39 @@ static int compute_gbe_timing(struct fb_
 	best_error = 1000000000;
 	best_n = best_m = best_p = 0;
 	for (pll_p = 0; pll_p < 4; pll_p++)
-		for (pll_m = 1; pll_m < 256; pll_m++)
-			for (pll_n = 1; pll_n < 64; pll_n++) {
-				pixclock = (1000000 / gbe_pll->clock_rate) *
-						(pll_n << pll_p) / pll_m;
-
-				error = var->pixclock - pixclock;
-
-				if (error < 0)
-					error = -error;
-
-				if (error < best_error &&
-				    pll_m / pll_n >
-				    gbe_pll->fvco_min / gbe_pll->clock_rate &&
- 				    pll_m / pll_n <
-				    gbe_pll->fvco_max / gbe_pll->clock_rate) {
-					best_error = error;
-					best_m = pll_m;
-					best_n = pll_n;
-					best_p = pll_p;
+		for (pll_m = 1; pll_m < 256; pll_m++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (pll_n = 1; pll_n < 64; pll_n++) {
+					pixclock = (1000000 / gbe_pll->clock_rate) *
+							(pll_n << pll_p) / pll_m;
+
+						error = var->pixclock - pixclock;
+
+					if (error < 0)
+								error = -error;
+
+					if (error < best_error &&
+					pll_m / pll_n >
+					gbe_pll->fvco_min / gbe_pll->clock_rate &&
+					pll_m / pll_n <
+					gbe_pll->fvco_max / gbe_pll->clock_rate) {
+						best_error = error;
+						best_m = pll_m;
+						best_n = pll_n;
+						best_p = pll_p;
+					}
+					if (_cur < timeout) {
+								rdstcll(_cur);
+					}
+					else {
+								break;
+					}
 				}
-			}
+		}
 
 	if (!best_n || !best_m)
 		return -EINVAL;	/* Resolution to high */
diff -u -p a/video/pxafb.c b/video/pxafb.c
--- a/video/pxafb.c
+++ b/video/pxafb.c
@@ -368,6 +368,11 @@ static struct pxafb_mode_info *pxafb_get
 	unsigned int best_x = 0xffffffff, best_y = 0xffffffff;
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mach->num_modes; i++) {
 		if (modelist[i].xres >= var->xres &&
 		    modelist[i].yres >= var->yres &&
@@ -378,6 +383,12 @@ static struct pxafb_mode_info *pxafb_get
 			best_y = modelist[i].yres;
 			mode = &modelist[i];
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return mode;
@@ -930,6 +941,11 @@ static void __devinit pxafb_overlay_init
 	if (!pxafb_overlay_supported())
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		struct pxafb_layer *ofb = &fbi->overlay[i];
 		init_pxafb_overlay(fbi, ofb, i);
@@ -947,6 +963,12 @@ static void __devinit pxafb_overlay_init
 			continue;
 		}
 		ofb->registered = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* mask all IU/BS/EOF/SOF interrupts */
@@ -962,6 +984,11 @@ static void __devexit pxafb_overlay_exit
 	if (!pxafb_overlay_supported())
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		struct pxafb_layer *ofb = &fbi->overlay[i];
 		if (ofb->registered) {
@@ -970,6 +997,12 @@ static void __devexit pxafb_overlay_exit
 					ofb->video_mem_size);
 			unregister_framebuffer(&ofb->fb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 #else
@@ -1199,6 +1232,11 @@ int pxafb_smart_queue(struct fb_info *in
 	int i;
 	struct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n_cmds; i++, cmds++) {
 		/* if it is a software delay, flush and delay */
 		if ((*cmds & 0xff00) == SMART_CMD_DELAY) {
@@ -1212,6 +1250,12 @@ int pxafb_smart_queue(struct fb_info *in
 			pxafb_smart_flush(info);
 
 		fbi->smart_cmds[fbi->n_smart_cmds++] = *cmds;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1859,6 +1903,11 @@ static int __devinit parse_opt_mode(stru
 	unsigned int xres = 0, yres = 0, bpp = 0;
 	int yres_specified = 0;
 	int i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = namelen-1; i >= 0; i--) {
 		switch (name[i]) {
 		case '-':
@@ -1881,6 +1930,12 @@ static int __devinit parse_opt_mode(stru
 		default:
 			goto done;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (i < 0 && yres_specified) {
 		xres = simple_strtoul(name, NULL, 0);
diff -u -p a/video/via/lcd.c b/video/via/lcd.c
--- a/video/via/lcd.c
+++ b/video/via/lcd.c
@@ -831,11 +831,22 @@ static void lcd_powersequence_off(void)
 	/* Software control power sequence */
 	viafb_write_reg_mask(CR91, VIACR, 0x11, 0x11);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		mask = PowerSequenceOff[0][i];
 		data = PowerSequenceOff[1][i] & mask;
 		viafb_write_reg_mask(CR91, VIACR, (u8) data, (u8) mask);
 		udelay(PowerSequenceOff[2][i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Disable LCD */
@@ -852,11 +863,22 @@ static void lcd_powersequence_on(void)
 	/* Enable LCD */
 	viafb_write_reg_mask(CR6A, VIACR, 0x08, 0x08);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		mask = PowerSequenceOn[0][i];
 		data = PowerSequenceOn[1][i] & mask;
 		viafb_write_reg_mask(CR91, VIACR, (u8) data, (u8) mask);
 		udelay(PowerSequenceOn[2][i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	udelay(1);
diff -u -p a/video/via/viafbdev.c b/video/via/viafbdev.c
--- a/video/via/viafbdev.c
+++ b/video/via/viafbdev.c
@@ -864,19 +864,41 @@ static int viafb_cursor(struct fb_info *
 			return -ENOMEM;
 
 		if (cur_size == 32) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < (CURSOR_SIZE / 4); i++) {
 				cr_data->bak[i] = 0x0;
 				cr_data->bak[i + 1] = 0xFFFFFFFF;
 				i += 1;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		} else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < (CURSOR_SIZE / 4); i++) {
 				cr_data->bak[i] = 0x0;
 				cr_data->bak[i + 1] = 0x0;
 				cr_data->bak[i + 2] = 0xFFFFFFFF;
 				cr_data->bak[i + 3] = 0xFFFFFFFF;
 				i += 3;
-			}
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+		}
 		}
 
 		switch (cursor->rop) {
@@ -894,18 +916,40 @@ static int viafb_cursor(struct fb_info *
 		}
 
 		if (cur_size == 32) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < size; i++) {
 				cr_data->bak[j] = (u32) cr_data->data[i];
 				cr_data->bak[j + 1] = ~cr_data->bak[j];
 				j += 2;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		} else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < size; i++) {
 				cr_data->bak[j] = (u32) cr_data->data[i];
 				cr_data->bak[j + 1] = 0x0;
 				cr_data->bak[j + 2] = ~cr_data->bak[j];
 				cr_data->bak[j + 3] = ~cr_data->bak[j + 1];
 				j += 4;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 
@@ -1155,6 +1199,11 @@ static ssize_t viafb_dvp0_proc_write(str
 		return -EFAULT;
 	buf[length - 1] = '\0';	/*Ensure end string */
 	pbuf = &buf[0];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		value = strsep(&pbuf, " ");
 		if (value != NULL) {
@@ -1185,6 +1234,12 @@ static ssize_t viafb_dvp0_proc_write(str
 		} else {
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return count;
 }
@@ -1226,6 +1281,11 @@ static ssize_t viafb_dvp1_proc_write(str
 		return -EFAULT;
 	buf[length - 1] = '\0';	/*Ensure end string */
 	pbuf = &buf[0];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		value = strsep(&pbuf, " ");
 		if (value != NULL) {
@@ -1250,6 +1310,12 @@ static ssize_t viafb_dvp1_proc_write(str
 		} else {
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return count;
 }
@@ -1395,6 +1461,11 @@ static ssize_t viafb_vt1636_proc_write(s
 	pbuf = &buf[0];
 	switch (viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {
 	case VT1636_LVDS:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 2; i++) {
 			value = strsep(&pbuf, " ");
 			if (value != NULL) {
@@ -1425,6 +1496,12 @@ static ssize_t viafb_vt1636_proc_write(s
 			} else {
 				break;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	default:
@@ -1432,6 +1509,11 @@ static ssize_t viafb_vt1636_proc_write(s
 	}
 	switch (viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name) {
 	case VT1636_LVDS:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 2; i++) {
 			value = strsep(&pbuf, " ");
 			if (value != NULL) {
@@ -1462,6 +1544,12 @@ static ssize_t viafb_vt1636_proc_write(s
 			} else {
 				break;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	default:
diff -u -p a/video/via/viamode.c b/video/via/viamode.c
--- a/video/via/viamode.c
+++ b/video/via/viamode.c
@@ -887,10 +887,21 @@ static struct crt_mode_table *get_best_m
 		return NULL;
 
 	best = &vmt->crtc[0];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < vmt->mode_array; i++) {
 		if (abs(vmt->crtc[i].refresh_rate - refresh)
 			< abs(best->refresh_rate - refresh))
 			best = &vmt->crtc[i];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return best;
diff -u -p a/video/via/via-gpio.c b/video/via/via-gpio.c
--- a/video/via/via-gpio.c
+++ b/video/via/via-gpio.c
@@ -224,6 +224,11 @@ static __devinit int viafb_gpio_probe(st
 	 * Set up entries for all GPIOs which have been configured to
 	 * operate as such (as opposed to as i2c ports).
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < VIAFB_NUM_PORTS; i++) {
 		if (port_cfg[i].mode != VIA_MODE_GPIO)
 			continue;
@@ -235,6 +240,12 @@ static __devinit int viafb_gpio_probe(st
 					gpio->vg_name;
 				ngpio++;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	viafb_gpio_config.gpio_chip.ngpio = ngpio;
 	viafb_gpio_config.gpio_chip.names = viafb_gpio_config.gpio_names;
diff -u -p a/video/via/dvi.c b/video/via/dvi.c
--- a/video/via/dvi.c
+++ b/video/via/dvi.c
@@ -295,6 +295,11 @@ static void __devinit dvi_get_panel_size
 
 	restore = tmds_chip->tmds_chip_slave_addr;
 	tmds_chip->tmds_chip_slave_addr = 0xA0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0x25; i < 0x6D; i++) {
 		switch (i) {
 		case 0x36:
@@ -315,6 +320,12 @@ static void __devinit dvi_get_panel_size
 		default:
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DEBUG_MSG(KERN_INFO "DVI max pixelclock = %d\n",
diff -u -p a/video/via/hw.c b/video/via/hw.c
--- a/video/via/hw.c
+++ b/video/via/hw.c
@@ -918,6 +918,11 @@ u32 via_parse_odev(char *input, char **e
 
 	while (next) {
 		next = false;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ARRAY_SIZE(device_mapping); i++) {
 			len = strlen(device_mapping[i].name);
 			if (!strncmp(ptr, device_mapping[i].name, len)) {
@@ -928,6 +933,12 @@ u32 via_parse_odev(char *input, char **e
 					next = true;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -939,6 +950,11 @@ void via_odev_to_seq(struct seq_file *m,
 {
 	int i, count = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(device_mapping); i++) {
 		if (odev & device_mapping[i].device) {
 			if (count > 0)
@@ -947,6 +963,12 @@ void via_odev_to_seq(struct seq_file *m,
 			seq_puts(m, device_mapping[i].name);
 			count++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	seq_putc(m, '\n');
@@ -988,6 +1010,11 @@ void viafb_load_reg(int timing_value, in
 	int start_index, end_index, cr_index;
 	u16 get_bit;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < viafb_load_reg_num; i++) {
 		reg_mask = 0;
 		data = 0;
@@ -996,6 +1023,11 @@ void viafb_load_reg(int timing_value, in
 		cr_index = reg[i].io_addr;
 
 		shift_next_reg = bit_num;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = start_index; j <= end_index; j++) {
 			/*if (bit_num==8) timing_value = timing_value >>8; */
 			reg_mask = reg_mask | (BIT0 << j);
@@ -1003,11 +1035,23 @@ void viafb_load_reg(int timing_value, in
 			data =
 			    data | ((get_bit >> shift_next_reg) << start_index);
 			bit_num++;
+			if (_cur < timeout) {
+			    rdstcll(_cur);
+			}
+			else {
+			    break;
+			}
 		}
 		if (io_type == VIACR)
 			viafb_write_reg_mask(cr_index, VIACR, data, reg_mask);
 		else
 			viafb_write_reg_mask(cr_index, VIASR, data, reg_mask);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 }
@@ -1392,6 +1436,11 @@ static struct via_pll_config get_pll_con
 	const u32 f0 = 14318180; /* X1 frequency */
 	int i, f;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < size; i++) {
 		cur.rshift = limits[i].rshift;
 		cur.divisor = limits[i].divisor;
@@ -1413,6 +1462,12 @@ static struct via_pll_config get_pll_con
 		f = abs(get_pll_output_frequency(f0, cur) - clk);
 		if (f < abs(get_pll_output_frequency(f0, best) - clk))
 			best = cur;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return best;
@@ -1695,10 +1750,21 @@ void __devinit viafb_init_dac(int set_ig
 		viafb_write_reg_mask(SR1A, VIASR, 0x00, BIT0);
 		/* turn off LCK */
 		viafb_write_reg_mask(SR1B, VIASR, 0x00, BIT7 + BIT6);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 256; i++) {
 			write_dac_reg(i, palLUT_table[i].red,
 				      palLUT_table[i].green,
 				      palLUT_table[i].blue);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* turn on LCK */
 		viafb_write_reg_mask(SR1B, VIASR, 0xC0, BIT7 + BIT6);
@@ -1707,10 +1773,21 @@ void __devinit viafb_init_dac(int set_ig
 		/* access Secondary Display's LUT */
 		viafb_write_reg_mask(CR6A, VIACR, 0x40, BIT6);
 		viafb_write_reg_mask(SR1A, VIASR, 0x01, BIT0);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 256; i++) {
 			write_dac_reg(i, palLUT_table[i].red,
 				      palLUT_table[i].green,
 				      palLUT_table[i].blue);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* set IGA1 DAC for default */
 		viafb_write_reg_mask(SR1A, VIASR, 0x00, BIT0);
@@ -1832,10 +1909,21 @@ static void hw_init(void)
 		via_write_reg(VIAGR, i, VPIT.GR[i]);
 
 	/* Write Attribute Controller */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < StdAR; i++) {
 		inb(VIAStatus);
 		outb(i, VIAAR);
 		outb(VPIT.AR[i], VIAAR);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	inb(VIAStatus);
@@ -1864,12 +1952,23 @@ int viafb_setmode(int video_bpp, int vid
 	if ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266
 		|| viaparinfo->chip_info->gfx_chip_name == UNICHROME_K400)
 		&& viafbinfo->var.xres == 1024 && viafbinfo->var.yres == 768) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < res_patch_table[0].table_length; j++) {
 			index = res_patch_table[0].io_reg_table[j].index;
 			port = res_patch_table[0].io_reg_table[j].port;
 			value = res_patch_table[0].io_reg_table[j].value;
 			mask = res_patch_table[0].io_reg_table[j].mask;
 			viafb_write_reg_mask(index, port, value, mask);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/video/via/via_utility.c b/video/via/via_utility.c
--- a/video/via/via_utility.c
+++ b/video/via/via_utility.c
@@ -135,10 +135,21 @@ void viafb_set_gamma_table(int bpp, unsi
 	int active_device_amount = 0;
 	int device_status = viafb_DeviceStatus;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sizeof(viafb_DeviceStatus) * 8; i++) {
 		if (device_status & 1)
 			active_device_amount++;
 		device_status >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* 8 bpp mode can't adjust gamma */
@@ -167,10 +178,21 @@ void viafb_set_gamma_table(int bpp, unsi
 
 	/* Fill IGA1 Gamma Table */
 	outb(0, LUT_INDEX_WRITE);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 256; i++) {
 		outb(gamma_table[i] >> 16, LUT_DATA);
 		outb(gamma_table[i] >> 8 & 0xFF, LUT_DATA);
 		outb(gamma_table[i] & 0xFF, LUT_DATA);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If adjust Gamma value in SAMM, fill IGA1,
@@ -185,10 +207,21 @@ void viafb_set_gamma_table(int bpp, unsi
 
 		/* Fill IGA2 Gamma Table */
 		outb(0, LUT_INDEX_WRITE);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 256; i++) {
 			outb(gamma_table[i] >> 16, LUT_DATA);
 			outb(gamma_table[i] >> 8 & 0xFF, LUT_DATA);
 			outb(gamma_table[i] & 0xFF, LUT_DATA);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 	viafb_write_reg(SR1A, VIASR, sr1a);
@@ -222,6 +255,11 @@ void viafb_get_gamma_table(unsigned int
 
 	/* Reading gamma table to get color value */
 	outb(0, LUT_INDEX_READ);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 256; i++) {
 		color_r = inb(LUT_DATA);
 		color_g = inb(LUT_DATA);
@@ -229,6 +267,12 @@ void viafb_get_gamma_table(unsigned int
 		gamma_table[i] =
 		    ((((u32) color_r) << 16) |
 		     (((u16) color_g) << 8)) | color_b;
+		    if (_cur < timeout) {
+		rdstcll(_cur);
+		    }
+		    else {
+		break;
+		    }
 	}
 	viafb_write_reg(SR1A, VIASR, sr1a);
 }
diff -u -p a/video/via/via_i2c.c b/video/via/via_i2c.c
--- a/video/via/via_i2c.c
+++ b/video/via/via_i2c.c
@@ -233,6 +233,11 @@ static int viafb_i2c_probe(struct platfo
 	i2c_vdev = platdev->dev.platform_data;
 	configs = i2c_vdev->port_cfg;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < VIAFB_NUM_PORTS; i++) {
 		struct via_port_cfg *adap_cfg = configs++;
 		struct via_i2c_stuff *i2c_stuff = &via_i2c_par[i];
@@ -249,6 +254,12 @@ static int viafb_i2c_probe(struct platfo
 			continue;  /* Still try to make the rest */
 		}
 		i2c_stuff->is_active = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -258,6 +269,11 @@ static int viafb_i2c_remove(struct platf
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < VIAFB_NUM_PORTS; i++) {
 		struct via_i2c_stuff *i2c_stuff = &via_i2c_par[i];
 		/*
@@ -266,6 +282,12 @@ static int viafb_i2c_remove(struct platf
 		 */
 		if (i2c_stuff->is_active)
 			i2c_del_adapter(&i2c_stuff->adapter);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/video/atafb_iplan2p4.c b/video/atafb_iplan2p4.c
--- a/video/atafb_iplan2p4.c
+++ b/video/atafb_iplan2p4.c
@@ -62,11 +62,22 @@ void atafb_iplan2p4_copyarea(struct fb_i
 				d = (u32 *)dst;
 				w *= BPL / 2;
 				l = next_line - w * 4;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = height; j > 0; j--) {
 					for (i = w; i > 0; i--)
 						*d++ = *s++;
 					s = (u32 *)((u8 *)s + l);
 					d = (u32 *)((u8 *)d + l);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 			if (width & 15)
@@ -88,11 +99,22 @@ void atafb_iplan2p4_copyarea(struct fb_i
 				d = (u32 *)dst;
 				w *= BPL / 2;
 				l = next_line - w * 4;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = height; j > 0; j--) {
 					for (i = w; i > 0; i--)
 						*--d = *--s;
 					s = (u32 *)((u8 *)s - l);
 					d = (u32 *)((u8 *)d - l);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 			if (sx & 15)
@@ -120,6 +142,11 @@ void atafb_iplan2p4_copyarea(struct fb_i
 			if ((sx + width) & 15)
 				f |= 2;
 			w >>= 4;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = height; i; i--) {
 				src32 = (u32 *)src;
 				dst32 = (u32 *)dst;
@@ -132,6 +159,11 @@ void atafb_iplan2p4_copyarea(struct fb_i
 					pval[1] = dst32[1] & mask;
 				}
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = w; j > 0; j--) {
 					v = *src32++;
 					v1 = v & mask;
@@ -141,6 +173,12 @@ void atafb_iplan2p4_copyarea(struct fb_i
 					v1 = v & mask;
 					*dst32++ = pval[1] | (v1 >> 8);
 					pval[1] = (v ^ v1) << 8;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				if (f & 2) {
@@ -150,6 +188,12 @@ void atafb_iplan2p4_copyarea(struct fb_i
 
 				src += next_line;
 				dst += next_line;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
 			u32 *src32, *dst32;
@@ -169,6 +213,11 @@ void atafb_iplan2p4_copyarea(struct fb_i
 				w += 8;
 			}
 			w >>= 4;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = height; i; i--) {
 				src32 = (u32 *)src;
 				dst32 = (u32 *)dst;
@@ -181,6 +230,11 @@ void atafb_iplan2p4_copyarea(struct fb_i
 					pval[1] = (*--src32 >> 8) & mask;
 				}
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = w; j > 0; j--) {
 					v = *--src32;
 					v1 = v & mask;
@@ -190,6 +244,12 @@ void atafb_iplan2p4_copyarea(struct fb_i
 					v1 = v & mask;
 					*--dst32 = pval[1] | (v1 << 8);
 					pval[1] = (v ^ v1) >> 8;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				if (!(f & 2)) {
@@ -199,6 +259,12 @@ void atafb_iplan2p4_copyarea(struct fb_i
 
 				src -= next_line;
 				dst -= next_line;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -217,9 +283,20 @@ void atafb_iplan2p4_fillrect(struct fb_i
 
 		expand8_col2mask(color, cval);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = height; i; i--) {
 			fill8_col(dest8, cval);
 			dest8 += next_line;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dest += BPL / 2;
 		width -= 8;
@@ -230,9 +307,20 @@ void atafb_iplan2p4_fillrect(struct fb_i
 	if (rows) {
 		u32 *d = dest;
 		u32 off = next_line - rows * BPL * 2;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = height; i; i--) {
 			d = fill16_col(d, rows, cval);
 			d = (u32 *)((long)d + off);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dest += rows * BPL / 2;
 		width &= 15;
@@ -243,9 +331,20 @@ void atafb_iplan2p4_fillrect(struct fb_i
 
 		expand8_col2mask(color, cval);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = height; i; i--) {
 			fill8_col(dest8, cval);
 			dest8 += next_line;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -270,11 +369,22 @@ void atafb_iplan2p4_linefill(struct fb_i
 		data16 = (const u16 *)data;
 		expand16_2col2mask(fgcolor, bgcolor, fgm, bgm);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (rows = width / 16; rows; rows--) {
 			u16 d = *data16++;
 			m = d | ((u32)d << 16);
 			*dest++ = (m & fgm[0]) ^ bgm[0];
 			*dest++ = (m & fgm[1]) ^ bgm[1];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		data = (const u8 *)data16;
diff -u -p a/video/sbuslib.c b/video/sbuslib.c
--- a/video/sbuslib.c
+++ b/video/sbuslib.c
@@ -136,6 +136,11 @@ int sbusfb_ioctl_helper(unsigned long cm
 		cmap.green = &green;
 		cmap.blue = &blue;
 		cmap.transp = NULL;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; i++) {
 			int err;
 
@@ -152,6 +157,12 @@ int sbusfb_ioctl_helper(unsigned long cm
 			err = fb_set_cmap(&cmap, info);
 			if (err)
 				return err;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		return 0;
 	}
@@ -174,6 +185,11 @@ int sbusfb_ioctl_helper(unsigned long cm
 		if (index + count > cmap->len)
 			return -EINVAL;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; i++) {
 			red = cmap->red[index + i] >> 8;
 			green = cmap->green[index + i] >> 8;
@@ -182,6 +198,12 @@ int sbusfb_ioctl_helper(unsigned long cm
 			    put_user(green, &ugreen[i]) ||
 			    put_user(blue, &ublue[i]))
 				return -EFAULT;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		return 0;
 	}
diff -u -p a/video/leo.c b/video/leo.c
--- a/video/leo.c
+++ b/video/leo.c
@@ -457,6 +457,11 @@ static void leo_wid_put(struct fb_info *
 
 	leo_wait(lx_krn);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, wi = wl->wl_list; i < wl->wl_count; i++, wi++) {
 		switch (wi->wi_type) {
 		case FB_WID_DBL_8:
@@ -472,6 +477,12 @@ static void leo_wid_put(struct fb_info *
 		};
 		sbus_writel(0x5800 + j, &lx_krn->krn_type);
 		sbus_writel(wi->wi_values[0], &lx_krn->krn_value);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	sbus_writel(LEO_KRN_TYPE_WID, &lx_krn->krn_type);
 
diff -u -p a/video/svgalib.c b/video/svgalib.c
--- a/video/svgalib.c
+++ b/video/svgalib.c
@@ -204,13 +204,35 @@ void svga_settile(struct fb_info *info,
 	}
 
 	fb += 2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (c = 0; c < map->length; c++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < map->height; i++) {
 			fb_writeb(font[i], fb + i * 4);
 //			fb[i * 4] = font[i];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		fb += 128;
 		font += map->height;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -238,17 +260,39 @@ void svga_tilecopy(struct fb_info *info,
 		rowstride = -rowstride;
 	    }
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dy = 0; dy < area->height; dy++) {
 		u16 __iomem *src2 = src;
 		u16 __iomem *dst2 = dst;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (dx = 0; dx < area->width; dx++) {
 			fb_writew(fb_readw(src2), dst2);
 //			*dst2 = *src2;
 			src2 += colstride;
 			dst2 += colstride;
+			if (_cur < timeout) {
+			 rdstcll(_cur);
+			}
+			else {
+			 break;
+			}
 		}
 		src += rowstride;
 		dst += rowstride;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -262,14 +306,36 @@ void svga_tilefill(struct fb_info *info,
 	u8 __iomem *fb = (u8 __iomem *)info->screen_base;
 	fb += rect->sx * colstride + rect->sy * rowstride;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dy = 0; dy < rect->height; dy++) {
 		u8 __iomem *fb2 = fb;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (dx = 0; dx < rect->width; dx++) {
 			fb_writeb(rect->index, fb2);
 			fb_writeb(attr, fb2 + 1);
 			fb2 += colstride;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		fb += rowstride;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -284,16 +350,38 @@ void svga_tileblit(struct fb_info *info,
 	fb += blit->sx * colstride + blit->sy * rowstride;
 
 	i=0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dy=0; dy < blit->height; dy ++) {
 		u8 __iomem *fb2 = fb;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (dx = 0; dx < blit->width; dx ++) {
 			fb_writeb(blit->indices[i], fb2);
 			fb_writeb(attr, fb2 + 1);
 			fb2 += colstride;
 			i ++;
 			if (i == blit->length) return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		fb += rowstride;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
diff -u -p a/video/sh_mobile_meram.c b/video/sh_mobile_meram.c
--- a/video/sh_mobile_meram.c
+++ b/video/sh_mobile_meram.c
@@ -169,6 +169,11 @@ static inline int meram_check_overlap(st
 			test_bit(new->cache_icb,  &priv->used_icb))
 		return  1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < priv->used_meram_cache_regions; i++) {
 		used_start = MERAM_CACHE_START(priv->used_meram_cache[i]);
 		used_end   = MERAM_CACHE_END(priv->used_meram_cache[i]);
@@ -178,6 +183,12 @@ static inline int meram_check_overlap(st
 		if ((meram_start >= used_start && meram_start < used_end) ||
 			(meram_end > used_start && meram_end < used_end))
 			return 1;
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 	}
 
 	return 0;
@@ -544,16 +555,38 @@ static int sh_mobile_meram_runtime_suspe
 		priv->cmn_saved_regs[k] = meram_read_reg(priv->base,
 			common_regs[k]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < 32; j++) {
 		if (!test_bit(j, &priv->used_icb))
 			continue;
-		for (k = 0; k < ICB_REGS_SIZE; k++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (k = 0; k < ICB_REGS_SIZE; k++) {
 			priv->icb_saved_regs[j * ICB_REGS_SIZE + k] =
 				meram_read_icb(priv->base, j, icb_regs[k]);
 			/* Reset ICB on resume */
 			if (icb_regs[k] == MExxCTL)
 				priv->icb_saved_regs[j * ICB_REGS_SIZE + k] |=
 					MExxCTL_WBF | MExxCTL_WF | MExxCTL_RF;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+		}
+		if (_cur < timeout) {
+					rdstcll(_cur);
+		}
+		else {
+					break;
 		}
 	}
 	return 0;
@@ -565,12 +598,34 @@ static int sh_mobile_meram_runtime_resum
 	struct sh_mobile_meram_priv *priv = platform_get_drvdata(pdev);
 	int k, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < 32; j++) {
 		if (!test_bit(j, &priv->used_icb))
 			continue;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (k = 0; k < ICB_REGS_SIZE; k++) {
 			meram_write_icb(priv->base, j, icb_regs[k],
 			priv->icb_saved_regs[j * ICB_REGS_SIZE + k]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
diff -u -p a/video/msm/msm_fb.c b/video/msm/msm_fb.c
--- a/video/msm/msm_fb.c
+++ b/video/msm/msm_fb.c
@@ -387,7 +387,12 @@ static int msmfb_blit(struct fb_info *in
 	if (copy_from_user(&req_list, p, sizeof(req_list)))
 		return -EFAULT;
 
-	for (i = 0; i < req_list.count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < req_list.count; i++) {
 		struct mdp_blit_req_list *list =
 			(struct mdp_blit_req_list *)p;
 		if (copy_from_user(&req, &list->req[i], sizeof(req)))
@@ -395,6 +400,12 @@ static int msmfb_blit(struct fb_info *in
 		ret = mdp->blit(mdp, info, &req);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/video/msm/mddi.c b/video/msm/mddi.c
--- a/video/msm/mddi.c
+++ b/video/msm/mddi.c
@@ -168,10 +168,21 @@ static void mddi_handle_rev_data(struct
 					 "len=%04x type=%04x CURR_REV_PTR=%x\n",
 			       rev->hdr.length, rev->hdr.type,
 			       mddi_readl(CURR_REV_PTR));
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < rev->hdr.length + 2; i++) {
 				if ((i % 16) == 0)
 					printk(KERN_INFO "\n");
 				printk(KERN_INFO " %02x", rev->raw[i]);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			printk(KERN_INFO "\n");
 			mddi_reset_rev_encap_ptr(mddi);
diff -u -p a/video/msm/mdp.c b/video/msm/mdp.c
--- a/video/msm/mdp.c
+++ b/video/msm/mdp.c
@@ -323,7 +323,12 @@ int mdp_blit(struct mdp_device *mdp_dev,
 		unsigned int remainder = req->dst_rect.h % 16;
 		req->src_rect.w = 16*req->src_rect.w / req->dst_rect.h;
 		req->dst_rect.h = 16;
-		for (i = 0; i < tiles; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < tiles; i++) {
 			enable_mdp_irq(mdp, DL0_ROI_DONE);
 			ret = mdp_ppp_blit(mdp, req, src_file, src_start,
 					   src_len, dst_file, dst_start,
@@ -335,6 +340,12 @@ int mdp_blit(struct mdp_device *mdp_dev,
 				goto err_wait_failed;
 			req->dst_rect.y += 16;
 			req->src_rect.x += req->src_rect.w;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!remainder)
 			goto end;
diff -u -p a/video/udlfb.c b/video/udlfb.c
--- a/video/udlfb.c
+++ b/video/udlfb.c
@@ -599,6 +599,11 @@ int dlfb_handle_damage(struct dlfb_data
 		return 0;
 	cmd = urb->transfer_buffer;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = y; i < y + height ; i++) {
 		const int line_offset = dev->info->fix.line_length * i;
 		const int byte_offset = line_offset + (x * BPP);
@@ -608,6 +613,12 @@ int dlfb_handle_damage(struct dlfb_data
 				      &cmd, byte_offset, width * BPP,
 				      &bytes_identical, &bytes_sent))
 			goto error;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+		}
 	}
 
 	if (cmd > (char *) urb->transfer_buffer) {
@@ -1290,6 +1301,11 @@ static int dlfb_setup_modes(struct dlfb_
 	/* If we've got modes, let's pick a best default mode */
 	if (info->monspecs.modedb_len > 0) {
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < info->monspecs.modedb_len; i++) {
 			if (dlfb_is_valid_mode(&info->monspecs.modedb[i], info))
 				fb_add_videomode(&info->monspecs.modedb[i],
@@ -1300,6 +1316,12 @@ static int dlfb_setup_modes(struct dlfb_
 					info->monspecs.misc
 						&= ~FB_MISC_1ST_DETAIL;
 			}
+			if (_cur < timeout) {
+						rdstcll(_cur);
+			}
+			else {
+						break;
+			}
 		}
 
 		default_vmode = fb_find_best_display(&info->monspecs,
@@ -1317,11 +1339,22 @@ static int dlfb_setup_modes(struct dlfb_
 		 * overspec monitor and/or are incorrect aspect ratio, etc.
 		 * But at least the user has a chance to choose
 		 */
-		for (i = 0; i < VESA_MODEDB_SIZE; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				for (i = 0; i < VESA_MODEDB_SIZE; i++) {
 			if (dlfb_is_valid_mode((struct fb_videomode *)
 						&vesa_modes[i], info))
 				fb_add_videomode(&vesa_modes[i],
 						 &info->modelist);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 
 		/*
@@ -1665,12 +1698,23 @@ static int dlfb_usb_probe(struct usb_int
 		goto error;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(fb_device_attrs); i++) {
 		retval = device_create_file(info->dev, &fb_device_attrs[i]);
 		if (retval) {
 			pr_err("device_create_file failed %d\n", retval);
 			goto err_del_attrs;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	retval = device_create_bin_file(info->dev, &edid_attr);
diff -u -p a/video/tcx.c b/video/tcx.c
--- a/video/tcx.c
+++ b/video/tcx.c
@@ -133,11 +133,22 @@ static void __tcx_set_control_plane(stru
 	p = par->cplane;
 	if (p == NULL)
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pend = p + info->fix.smem_len; p < pend; p++) {
 		u32 tmp = sbus_readl(p);
 
 		tmp &= 0xffffff;
 		sbus_writel(tmp, p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -419,6 +430,11 @@ static int __devinit tcx_probe(struct pl
 	info->fix.smem_start = op->resource[0].start;
 	par->which_io = op->resource[0].flags & IORESOURCE_BITS;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < TCX_MMAP_ENTRIES; i++) {
 		int j;
 
@@ -436,6 +452,12 @@ static int __devinit tcx_probe(struct pl
 			break;
 		};
 		par->mmap_map[i].poff = op->resource[j].start;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	info->flags = FBINFO_DEFAULT;
diff -u -p a/video/neofb.c b/video/neofb.c
--- a/video/neofb.c
+++ b/video/neofb.c
@@ -182,6 +182,11 @@ static int neoFindMode(int xres, int yre
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < size; i++) {
 		if (xres <= mode[i].x_res) {
 			xres_s = mode[i].x_res;
@@ -192,6 +197,12 @@ static int neoFindMode(int xres, int yre
 					return mode[i].mode;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return mode[size - 1].mode;
 }
@@ -1026,12 +1037,23 @@ static int neofb_set_par(struct fb_info
 		/* TrueColor, 64k */
 		info->fix.visual = FB_VISUAL_TRUECOLOR;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 64; i++) {
 			outb(i, 0x3c8);
 
 			outb(i << 1, 0x3c9);
 			outb(i, 0x3c9);
 			outb(i << 1, 0x3c9);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		break;
 	case 24:
@@ -1041,12 +1063,23 @@ static int neofb_set_par(struct fb_info
 		/* TrueColor, 16m */
 		info->fix.visual = FB_VISUAL_TRUECOLOR;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 256; i++) {
 			outb(i, 0x3c8);
 
 			outb(i, 0x3c9);
 			outb(i, 0x3c9);
 			outb(i, 0x3c9);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 		}
 		break;
 	}
diff -u -p a/video/tridentfb.c b/video/tridentfb.c
--- a/video/tridentfb.c
+++ b/video/tridentfb.c
@@ -717,20 +717,32 @@ static void set_vclk(struct tridentfb_pa
 	unsigned char shift = !is_oldclock(par->chip_id) ? 2 : 1;
 
 	d = 20000;
-	for (k = shift; k >= 0; k--)
-		for (m = 1; m < 32; m++) {
-			n = ((m + 2) << shift) - 8;
-			for (n = (n < 0 ? 0 : n); n < 122; n++) {
-				fi = ((14318l * (n + 8)) / (m + 2)) >> k;
-				di = abs(fi - freq);
-				if (di < d || (di == d && k == best_k)) {
-					d = di;
-					best_n = n;
-					best_m = m;
-					best_k = k;
-				}
-				if (fi > freq)
-					break;
+	for (k = shift; k >= 0; k--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (m = 1; m < 32; m++) {
+				n = ((m + 2) << shift) - 8;
+				for (n = (n < 0 ? 0 : n); n < 122; n++) {
+					fi = ((14318l * (n + 8)) / (m + 2)) >> k;
+					di = abs(fi - freq);
+					if (di < d || (di == d && k == best_k)) {
+						d = di;
+						best_n = n;
+						best_m = m;
+						best_k = k;
+					}
+					if (fi > freq)
+						break;
+					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 			}
 		}
 
diff -u -p a/video/fbcmap.c b/video/fbcmap.c
--- a/video/fbcmap.c
+++ b/video/fbcmap.c
@@ -332,25 +332,69 @@ void fb_invert_cmaps(void)
 {
     u_int i;
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (i = 0; i < ARRAY_SIZE(red2); i++) {
 	red2[i] = ~red2[i];
 	green2[i] = ~green2[i];
 	blue2[i] = ~blue2[i];
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (i = 0; i < ARRAY_SIZE(red4); i++) {
 	red4[i] = ~red4[i];
 	green4[i] = ~green4[i];
 	blue4[i] = ~blue4[i];
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (i = 0; i < ARRAY_SIZE(red8); i++) {
 	red8[i] = ~red8[i];
 	green8[i] = ~green8[i];
 	blue8[i] = ~blue8[i];
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (i = 0; i < ARRAY_SIZE(red16); i++) {
 	red16[i] = ~red16[i];
 	green16[i] = ~green16[i];
 	blue16[i] = ~blue16[i];
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
 }
 
diff -u -p a/video/arcfb.c b/video/arcfb.c
--- a/video/arcfb.c
+++ b/video/arcfb.c
@@ -167,12 +167,34 @@ static void ks108_clear_lcd(struct arcfb
 {
 	int i,j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= 8; i++) {
 		ks108_set_yaddr(par, chipindex, i);
 		ks108_set_xaddr(par, chipindex, 0);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 64; j++) {
 			ks108_writeb_data(par, chipindex,
 				(unsigned char) splashval);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
@@ -206,8 +228,19 @@ static int arcfb_pan_display(struct fb_v
 
 	if ((var->vmode & FB_VMODE_YWRAP) && (var->yoffset < 64)
 		&& (info->var.yres <= 64)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < num_cols; i++) {
 			ks108_set_start_line(par, i, var->yoffset);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		info->var.yoffset = var->yoffset;
 		return 0;
@@ -268,6 +301,11 @@ static void arcfb_lcd_update_page(struct
 	rightshift=0;
 	while (left <= right) {
 		val = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 8; i++) {
 			if ( i > rightshift) {
 				val |= (*(src + (i*linesize)) & bitmask)
@@ -276,6 +314,12 @@ static void arcfb_lcd_update_page(struct
 				val |= (*(src + (i*linesize)) & bitmask)
 						 >> (rightshift - i);
 			}
+			if (_cur < timeout) {
+						 rdstcll(_cur);
+			}
+			else {
+						 break;
+			}
 		}
 		ks108_writeb_data(par, chipindex, val);
 		left++;
@@ -560,21 +604,43 @@ static int __devinit arcfb_probe(struct
 	       info->node, videomemorysize >> 10);
 
 	/* this inits the lcd but doesn't clear dirty pixels */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_cols * num_rows; i++) {
 		ks108_writeb_ctl(par, i, KS_DPY_OFF);
 		ks108_set_start_line(par, i, 0);
 		ks108_set_yaddr(par, i, 0);
 		ks108_set_xaddr(par, i, 0);
 		ks108_writeb_ctl(par, i, KS_DPY_ON);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if we were told to splash the screen, we just clear it */
 	if (!nosplash) {
-		for (i = 0; i < num_cols * num_rows; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < num_cols * num_rows; i++) {
 			printk(KERN_INFO "fb%d: splashing lcd %d\n",
 				info->node, i);
 			ks108_set_start_line(par, i, 0);
 			ks108_clear_lcd(par, i);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
diff -u -p a/video/omap2/omapfb/omapfb-ioctl.c b/video/omap2/omapfb/omapfb-ioctl.c
--- a/video/omap2/omapfb/omapfb-ioctl.c
+++ b/video/omap2/omapfb/omapfb-ioctl.c
@@ -230,6 +230,11 @@ static int omapfb_setup_mem(struct fb_in
 		goto out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct omapfb_info *ofbi2 = FB2OFB(fbdev->fbs[i]);
 		int j;
@@ -237,11 +242,28 @@ static int omapfb_setup_mem(struct fb_in
 		if (ofbi2->region != rg)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < ofbi2->num_overlays; j++) {
 			if (ofbi2->overlays[j]->info.enabled) {
 				r = -EBUSY;
 				goto out;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
diff -u -p a/video/omap2/omapfb/omapfb-main.c b/video/omap2/omapfb/omapfb-main.c
--- a/video/omap2/omapfb/omapfb-main.c
+++ b/video/omap2/omapfb/omapfb-main.c
@@ -111,7 +111,17 @@ static void fill_fb(struct fb_info *fbi)
 
 	DBG("fill_fb %dx%d, line_len %d bytes\n", w, h, fbi->fix.line_length);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < h; y++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < w; x++) {
 			if (x < 20 && y < 20)
 				draw_pixel(fbi, x, y, 0xffffff);
@@ -154,6 +164,18 @@ static void fill_fb(struct fb_info *fbi)
 			} else {
 				draw_pixel(fbi, x, y, 0);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
@@ -315,6 +337,11 @@ static int fb_mode_to_dss_mode(struct fb
 
 	/* first match with nonstd field */
 	if (var->nonstd) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {
 			struct omapfb_colormode *m = &omapfb_colormodes[i];
 			if (var->nonstd == m->nonstd) {
@@ -322,12 +349,23 @@ static int fb_mode_to_dss_mode(struct fb
 				*mode = m->dssmode;
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		return -EINVAL;
 	}
 
 	/* then try exact match of bpp and colors */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {
 		struct omapfb_colormode *m = &omapfb_colormodes[i];
 		if (cmp_var_to_colormode(var, m)) {
@@ -335,6 +373,12 @@ static int fb_mode_to_dss_mode(struct fb
 			*mode = m->dssmode;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+	else {
+			break;
+	}
 	}
 
 	/* match with bpp if user has not filled color fields
@@ -368,6 +412,11 @@ static int fb_mode_to_dss_mode(struct fb
 		return -EINVAL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {
 		struct omapfb_colormode *m = &omapfb_colormodes[i];
 		if (dssmode == m->dssmode) {
@@ -375,6 +424,12 @@ static int fb_mode_to_dss_mode(struct fb
 			*mode = m->dssmode;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -EINVAL;
@@ -588,12 +643,23 @@ int dss_mode_to_fb_mode(enum omap_color_
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {
 		struct omapfb_colormode *mode = &omapfb_colormodes[i];
 		if (dssmode == mode->dssmode) {
 			assign_colormode_to_var(var, mode);
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -ENOENT;
 }
@@ -680,11 +746,22 @@ int check_fb_var(struct fb_info *fbi, st
 		return r;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ofbi->num_overlays; ++i) {
 		if ((ofbi->overlays[i]->supported_modes & mode) == 0) {
 			DBG("invalid mode\n");
 			return -EINVAL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (var->rotate > 3)
@@ -853,12 +930,23 @@ int omapfb_setup_overlay(struct fb_info
 
 	WARN_ON(!atomic_read(&ofbi->region->lock_count));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ofbi->num_overlays; i++) {
 		if (ovl != ofbi->overlays[i])
 			continue;
 
 		rotation = (rotation + ofbi->rotation[i]) % 4;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DBG("setup_overlay %d, posx %d, posy %d, outw %d, outh %d\n", ofbi->id,
@@ -946,6 +1034,11 @@ int omapfb_apply_changes(struct fb_info
 
 	WARN_ON(!atomic_read(&ofbi->region->lock_count));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ofbi->num_overlays; i++) {
 		ovl = ofbi->overlays[i];
 
@@ -988,6 +1081,12 @@ int omapfb_apply_changes(struct fb_info
 
 		if (!init && ovl->manager)
 			ovl->manager->apply(ovl->manager);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 err:
@@ -1220,6 +1319,11 @@ static int omapfb_setcmap(struct fb_cmap
 	transp  = cmap->transp;
 	index   = cmap->start;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; count < cmap->len; count++) {
 		if (transp)
 			trans = *transp++;
@@ -1227,6 +1331,12 @@ static int omapfb_setcmap(struct fb_cmap
 				count == cmap->len - 1);
 		if (r != 0)
 			return r;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
@@ -1363,10 +1473,21 @@ static int omapfb_free_all_fbmem(struct
 
 	DBG("free all fbmem\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct fb_info *fbi = fbdev->fbs[i];
 		omapfb_free_fbmem(fbi);
 		clear_fb_info(fbi);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1613,6 +1734,11 @@ static int omapfb_allocate_all_fbs(struc
 	if (fbdev->dev->platform_data) {
 		struct omapfb_platform_data *opd;
 		opd = fbdev->dev->platform_data;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < opd->mem_desc.region_cnt; ++i) {
 			if (!vram_sizes[i]) {
 				unsigned long size;
@@ -1624,9 +1750,20 @@ static int omapfb_allocate_all_fbs(struc
 				vram_sizes[i] = size;
 				vram_paddrs[i] = paddr;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		/* allocate memory automatically only for fb0, or if
 		 * excplicitly defined with vram or plat data option */
@@ -1637,8 +1774,19 @@ static int omapfb_allocate_all_fbs(struc
 			if (r)
 				return r;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);
 		struct omapfb2_mem_region *rg;
@@ -1649,6 +1797,12 @@ static int omapfb_allocate_all_fbs(struc
 				rg->paddr,
 				rg->vaddr,
 				rg->size);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return 0;
@@ -1930,11 +2084,27 @@ static void omapfb_free_resources(struct
 	/* free the reserved fbmem */
 	omapfb_free_all_fbmem(fbdev);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		fbinfo_cleanup(fbdev, fbdev->fbs[i]);
 		framebuffer_release(fbdev->fbs[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_displays; i++) {
 		struct omap_dss_device *dssdev = fbdev->displays[i].dssdev;
 
@@ -1945,6 +2115,12 @@ static void omapfb_free_resources(struct
 			dssdev->driver->disable(dssdev);
 
 		omap_dss_put_device(dssdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (fbdev->auto_update_wq != NULL) {
@@ -1966,7 +2142,12 @@ static int omapfb_create_framebuffers(st
 	DBG("create %d framebuffers\n",	CONFIG_FB_OMAP2_NUM_FBS);
 
 	/* allocate fb_infos */
-	for (i = 0; i < CONFIG_FB_OMAP2_NUM_FBS; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < CONFIG_FB_OMAP2_NUM_FBS; i++) {
 		struct fb_info *fbi;
 		struct omapfb_info *ofbi;
 
@@ -1997,16 +2178,33 @@ static int omapfb_create_framebuffers(st
 		ofbi->mirror = def_mirror;
 
 		fbdev->num_fbs++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DBG("fb_infos allocated\n");
 
 	/* assign overlays for the fbs */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < min(fbdev->num_fbs, fbdev->num_overlays); i++) {
 		struct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);
 
 		ofbi->overlays[0] = fbdev->overlays[i];
 		ofbi->num_overlays = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* allocate fb memories */
@@ -2019,6 +2217,11 @@ static int omapfb_create_framebuffers(st
 	DBG("fbmems allocated\n");
 
 	/* setup fb_infos */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct fb_info *fbi = fbdev->fbs[i];
 		struct omapfb_info *ofbi = FB2OFB(fbi);
@@ -2031,21 +2234,43 @@ static int omapfb_create_framebuffers(st
 			dev_err(fbdev->dev, "failed to setup fb_info\n");
 			return r;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DBG("fb_infos initialized\n");
 
-	for (i = 0; i < fbdev->num_fbs; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < fbdev->num_fbs; i++) {
 		r = register_framebuffer(fbdev->fbs[i]);
 		if (r != 0) {
 			dev_err(fbdev->dev,
 				"registering framebuffer %d failed\n", i);
 			return r;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DBG("framebuffers registered\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct fb_info *fbi = fbdev->fbs[i];
 		struct omapfb_info *ofbi = FB2OFB(fbi);
@@ -2058,6 +2283,12 @@ static int omapfb_create_framebuffers(st
 			dev_err(fbdev->dev, "failed to change mode\n");
 			return r;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Enable fb0 */
@@ -2308,6 +2539,11 @@ static int omapfb_find_best_mode(struct
 	best_xres = 0;
 	best_idx = -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < specs->modedb_len; ++i) {
 		struct fb_videomode *m;
 		struct omap_video_timings t;
@@ -2328,6 +2564,12 @@ static int omapfb_find_best_mode(struct
 			best_xres = m->xres;
 			best_idx = i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (best_xres == 0) {
@@ -2503,12 +2745,23 @@ static int omapfb_probe(struct platform_
 	if (r)
 		goto cleanup;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_managers; i++) {
 		struct omap_overlay_manager *mgr;
 		mgr = fbdev->managers[i];
 		r = mgr->apply(mgr);
 		if (r)
 			dev_warn(fbdev->dev, "failed to apply dispc config\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DBG("mgr->apply'ed\n");
diff -u -p a/video/omap2/omapfb/omapfb-sysfs.c b/video/omap2/omapfb/omapfb-sysfs.c
--- a/video/omap2/omapfb/omapfb-sysfs.c
+++ b/video/omap2/omapfb/omapfb-sysfs.c
@@ -153,6 +153,11 @@ static ssize_t show_overlays(struct devi
 		return -ENODEV;
 	omapfb_lock(fbdev);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (t = 0; t < ofbi->num_overlays; t++) {
 		struct omap_overlay *ovl = ofbi->overlays[t];
 		int ovlnum;
@@ -163,6 +168,12 @@ static ssize_t show_overlays(struct devi
 
 		l += snprintf(buf + l, PAGE_SIZE - l, "%s%d",
 				t == 0 ? "" : ",", ovlnum);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	l += snprintf(buf + l, PAGE_SIZE - l, "\n");
@@ -178,12 +189,34 @@ static struct omapfb_info *get_overlay_f
 {
 	int i, t;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (t = 0; t < ofbi->num_overlays; t++) {
 			if (ofbi->overlays[t] == ovl)
 				return ofbi;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}
 
@@ -244,6 +277,11 @@ static ssize_t store_overlays(struct dev
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_ovls; ++i) {
 		struct omapfb_info *ofbi2 = get_overlay_fb(fbdev, ovls[i]);
 		if (ofbi2 && ofbi2 != ofbi) {
@@ -251,9 +289,20 @@ static ssize_t store_overlays(struct dev
 			r = -EINVAL;
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* detach unused overlays */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ofbi->num_overlays; ++i) {
 		int t, found;
 
@@ -282,15 +331,37 @@ static ssize_t store_overlays(struct dev
 
 		omapfb_put_mem_region(ofbi->region);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (t = i + 1; t < ofbi->num_overlays; t++) {
 			ofbi->rotation[t-1] = ofbi->rotation[t];
 			ofbi->overlays[t-1] = ofbi->overlays[t];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		ofbi->num_overlays--;
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_ovls; ++i) {
 		int t, found;
 
@@ -311,6 +382,12 @@ static ssize_t store_overlays(struct dev
 		ofbi->overlays[ofbi->num_overlays++] = ovl;
 
 		added = true;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (added) {
@@ -343,9 +420,20 @@ static ssize_t show_overlays_rotate(stru
 	if (!lock_fb_info(fbi))
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (t = 0; t < ofbi->num_overlays; t++) {
 		l += snprintf(buf + l, PAGE_SIZE - l, "%s%d",
 				t == 0 ? "" : ",", ofbi->rotation[t]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	l += snprintf(buf + l, PAGE_SIZE - l, "\n");
@@ -465,6 +553,11 @@ static ssize_t store_size(struct device
 		goto out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct omapfb_info *ofbi2 = FB2OFB(fbdev->fbs[i]);
 		int j;
@@ -472,11 +565,28 @@ static ssize_t store_size(struct device
 		if (ofbi2->region != rg)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < ofbi2->num_overlays; j++) {
 			if (ofbi2->overlays[j]->info.enabled) {
 				r = -EBUSY;
 				goto out;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -568,9 +678,19 @@ int omapfb_create_sysfs(struct omapfb2_d
 	int r;
 
 	DBG("create sysfs for fbs\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		int t;
-		for (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++) {
 			r = device_create_file(fbdev->fbs[i]->dev,
 					&omapfb_attrs[t]);
 
@@ -579,6 +699,18 @@ int omapfb_create_sysfs(struct omapfb2_d
 						"file\n");
 				return r;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -590,10 +722,21 @@ void omapfb_remove_sysfs(struct omapfb2_
 	int i, t;
 
 	DBG("remove sysfs for fbs\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		for (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++)
 			device_remove_file(fbdev->fbs[i]->dev,
 					&omapfb_attrs[t]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/video/omap2/displays/panel-tpo-td043mtea1.c b/video/omap2/displays/panel-tpo-td043mtea1.c
--- a/video/omap2/displays/panel-tpo-td043mtea1.c
+++ b/video/omap2/displays/panel-tpo-td043mtea1.c
@@ -197,12 +197,23 @@ static ssize_t tpo_td043_gamma_show(stru
 	int ret;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(tpo_td043->gamma); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(tpo_td043->gamma); i++) {
 		ret = snprintf(buf + len, PAGE_SIZE - len, "%u ",
 				tpo_td043->gamma[i]);
 		if (ret < 0)
 			return ret;
 		len += ret;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	buf[len - 1] = '\n';
 
diff -u -p a/video/omap2/displays/panel-taal.c b/video/omap2/displays/panel-taal.c
--- a/video/omap2/displays/panel-taal.c
+++ b/video/omap2/displays/panel-taal.c
@@ -66,10 +66,21 @@ static void free_regulators(struct panel
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n; i++) {
 		/* disable/put in reverse order */
 		regulator_disable(regulators[n - i - 1].regulator);
 		regulator_put(regulators[n - i - 1].regulator);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -78,6 +89,11 @@ static int init_regulators(struct omap_d
 {
 	int r, i, v;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n; i++) {
 		struct regulator *reg;
 
@@ -112,6 +128,12 @@ static int init_regulators(struct omap_d
 		}
 
 		regulators[i].regulator = reg;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/omap2/displays/panel-picodlp.c b/video/omap2/displays/panel-picodlp.c
--- a/video/omap2/displays/panel-picodlp.c
+++ b/video/omap2/displays/panel-picodlp.c
@@ -159,11 +159,22 @@ static int picodlp_i2c_write_array(struc
 			int count)
 {
 	int i, r = 0;
-	for (i = 0; i < count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < count; i++) {
 		r = picodlp_i2c_write(client, commands[i].reg,
 						commands[i].value);
 		if (r)
 			return r;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return r;
 }
diff -u -p a/video/omap2/dss/dss.c b/video/omap2/dss/dss.c
--- a/video/omap2/dss/dss.c
+++ b/video/omap2/dss/dss.c
@@ -554,7 +554,12 @@ retry:
 		if (cpu_is_omap3630() || cpu_is_omap44xx())
 			fck_div_max = 32;
 
-		for (fck_div = fck_div_max; fck_div > 0; --fck_div) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (fck_div = fck_div_max; fck_div > 0; --fck_div) {
 			struct dispc_clock_info cur_dispc;
 
 			if (fck_div_max == 32)
@@ -584,7 +589,13 @@ retry:
 				if (cur_dispc.pck == req_pck)
 					goto found;
 			}
-		}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
+			}
 	}
 
 found:
diff -u -p a/video/omap2/dss/dsi.c b/video/omap2/dss/dsi.c
--- a/video/omap2/dss/dsi.c
+++ b/video/omap2/dss/dsi.c
@@ -648,7 +648,12 @@ static void dsi_handle_irq_errors(struct
 		print_irq_status(irqstatus);
 	}
 
-	for (i = 0; i < 4; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 4; ++i) {
 		if (vcstatus[i] & DSI_VC_IRQ_ERROR_MASK) {
 			DSSERR("DSI VC(%d) error, vc irqstatus %x\n",
 				       i, vcstatus[i]);
@@ -656,6 +661,12 @@ static void dsi_handle_irq_errors(struct
 		} else if (debug_irq) {
 			print_irq_status_vc(i, vcstatus[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ciostatus & DSI_CIO_IRQ_ERROR_MASK) {
@@ -672,10 +683,21 @@ static void dsi_call_isrs(struct dsi_isr
 	struct dsi_isr_data *isr_data;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < isr_array_size; i++) {
 		isr_data = &isr_array[i];
 		if (isr_data->isr && isr_data->mask & irqstatus)
 			isr_data->isr(isr_data->arg, irqstatus);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -688,12 +710,23 @@ static void dsi_handle_isrs(struct dsi_i
 			ARRAY_SIZE(isr_tables->isr_table),
 			irqstatus);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; ++i) {
 		if (vcstatus[i] == 0)
 			continue;
 		dsi_call_isrs(isr_tables->isr_table_vc[i],
 				ARRAY_SIZE(isr_tables->isr_table_vc[i]),
 				vcstatus[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ciostatus != 0)
@@ -726,6 +759,11 @@ static irqreturn_t omap_dsi_irq_handler(
 	/* flush posted write */
 	dsi_read_reg(dsidev, DSI_IRQSTATUS);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; ++i) {
 		if ((irqstatus & (1 << i)) == 0) {
 			vcstatus[i] = 0;
@@ -737,6 +775,12 @@ static irqreturn_t omap_dsi_irq_handler(
 		dsi_write_reg(dsidev, DSI_VC_IRQSTATUS(i), vcstatus[i]);
 		/* flush posted write */
 		dsi_read_reg(dsidev, DSI_VC_IRQSTATUS(i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (irqstatus & DSI_IRQ_COMPLEXIO_ERR) {
@@ -784,6 +828,11 @@ static void _omap_dsi_configure_irqs(str
 
 	mask = default_mask;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < isr_array_size; i++) {
 		isr_data = &isr_array[i];
 
@@ -791,6 +840,12 @@ static void _omap_dsi_configure_irqs(str
 			continue;
 
 		mask |= isr_data->mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	old_mask = dsi_read_reg(dsidev, enable_reg);
@@ -867,7 +922,12 @@ static int _dsi_register_isr(omap_dsi_is
 
 	/* check for duplicate entry and find a free slot */
 	free_idx = -1;
-	for (i = 0; i < isr_array_size; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < isr_array_size; i++) {
 		isr_data = &isr_array[i];
 
 		if (isr_data->isr == isr && isr_data->arg == arg &&
@@ -877,6 +937,12 @@ static int _dsi_register_isr(omap_dsi_is
 
 		if (isr_data->isr == NULL && free_idx == -1)
 			free_idx = i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (free_idx == -1)
@@ -896,7 +962,12 @@ static int _dsi_unregister_isr(omap_dsi_
 	struct dsi_isr_data *isr_data;
 	int i;
 
-	for (i = 0; i < isr_array_size; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (i = 0; i < isr_array_size; i++) {
 		isr_data = &isr_array[i];
 		if (isr_data->isr != isr || isr_data->arg != arg ||
 				isr_data->mask != mask)
@@ -907,6 +978,12 @@ static int _dsi_unregister_isr(omap_dsi_
 		isr_data->mask = 0;
 
 		return 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -EINVAL;
@@ -1370,6 +1447,11 @@ retry:
 	/* no highfreq: 0.75MHz < Fint = clkin / regn < 2.1MHz */
 	/* highfreq: 0.75MHz < Fint = clkin / (2*regn) < 2.1MHz */
 	/* To reduce PLL lock time, keep Fint high (around 2 MHz) */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur.regn = 1; cur.regn < dsi->regn_max; ++cur.regn) {
 		if (cur.highfreq == 0)
 			cur.fint = cur.clkin / cur.regn;
@@ -1428,7 +1510,13 @@ retry:
 				}
 			}
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+			}
+		}
 found:
 	if (!match) {
 		if (min_fck_per_pck) {
@@ -1759,10 +1847,21 @@ void dsi_dump_clocks(struct seq_file *s)
 	struct platform_device *dsidev;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for  (i = 0; i < MAX_NUM_DSI; i++) {
 		dsidev = dsi_get_dsidev_from_id(i);
 		if (dsidev)
 			dsi_dump_dsidev_clocks(dsidev, s);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -2339,21 +2438,43 @@ static int dsi_cio_wait_tx_clk_esc_reset
 		l = dsi_read_reg(dsidev, DSI_DSIPHY_CFG5);
 
 		ok = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 3; ++i) {
 			if (!in_use[i] || (l & (1 << bits[i])))
 				ok++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+			else {
+				break;
+			}
 		}
 
 		if (ok == 3)
 			break;
 
 		if (--t == 0) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 3; ++i) {
 				if (!in_use[i] || (l & (1 << bits[i])))
 					continue;
 
 				DSSERR("CIO TXCLKESC%d domain not coming " \
 						"out of reset\n", i);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			return -EIO;
 		}
@@ -2525,6 +2646,11 @@ static void dsi_config_tx_fifo(struct pl
 	dsi->vc[2].fifo_size = size3;
 	dsi->vc[3].fifo_size = size4;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		u8 v;
 		int size = dsi->vc[i].fifo_size;
@@ -2538,6 +2664,12 @@ static void dsi_config_tx_fifo(struct pl
 		r |= v << (8 * i);
 		/*DSSDBG("TX FIFO vc %d: size %d, add %d\n", i, size, add); */
 		add += size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dsi_write_reg(dsidev, DSI_TX_FIFO_VC_SIZE, r);
@@ -2557,6 +2689,11 @@ static void dsi_config_rx_fifo(struct pl
 	dsi->vc[2].fifo_size = size3;
 	dsi->vc[3].fifo_size = size4;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		u8 v;
 		int size = dsi->vc[i].fifo_size;
@@ -2570,6 +2707,12 @@ static void dsi_config_rx_fifo(struct pl
 		r |= v << (8 * i);
 		/*DSSDBG("RX FIFO vc %d: size %d, add %d\n", i, size, add); */
 		add += size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dsi_write_reg(dsidev, DSI_RX_FIFO_VC_SIZE, r);
@@ -3015,6 +3158,11 @@ static int dsi_vc_send_long(struct platf
 	dsi_vc_write_long_header(dsidev, channel, data_type, len, ecc);
 
 	p = data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len >> 2; i++) {
 		if (dsi->debug_write)
 			DSSDBG("\tsending full packet %d\n", i);
@@ -3025,6 +3173,12 @@ static int dsi_vc_send_long(struct platf
 		b4 = *p++;
 
 		dsi_vc_write_long_payload(dsidev, channel, b1, b2, b3, b4);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	i = len % 4;
@@ -3369,11 +3523,22 @@ static int dsi_vc_read_rx_fifo(struct pl
 						(val >> 16) & 0xff,
 						(val >> 24) & 0xff);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (b = 0; b < 4; ++b) {
 				if (w < len)
 					buf[w] = (val >> (b * 8)) & 0xff;
 				/* we discard the 2 byte checksum */
 				++w;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
@@ -4558,12 +4723,23 @@ int omap_dsi_request_vc(struct omap_dss_
 	struct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(dsi->vc); i++) {
 		if (!dsi->vc[i].dssdev) {
 			dsi->vc[i].dssdev = dssdev;
 			*channel = i;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DSSERR("cannot get VC for display %s", dssdev->name);
@@ -4755,10 +4931,21 @@ static int omap_dsihw_probe(struct platf
 	}
 
 	/* DSI VCs initialization */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(dsi->vc); i++) {
 		dsi->vc[i].source = DSI_VC_SOURCE_L4;
 		dsi->vc[i].dssdev = NULL;
 		dsi->vc[i].vc_id = 0;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	dsi_calc_clock_param_ranges(dsidev);
diff -u -p a/video/omap2/dss/dispc.c b/video/omap2/dss/dispc.c
--- a/video/omap2/dss/dispc.c
+++ b/video/omap2/dss/dispc.c
@@ -188,6 +188,11 @@ static void dispc_save_context(void)
 		SR(CONFIG2);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dss_feat_get_num_mgrs(); i++) {
 		SR(DEFAULT_COLOR(i));
 		SR(TRANS_COLOR(i));
@@ -208,8 +213,19 @@ static void dispc_save_context(void)
 			SR(CPR_COEF_G(i));
 			SR(CPR_COEF_B(i));
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dss_feat_get_num_ovls(); i++) {
 		SR(OVL_BA0(i));
 		SR(OVL_BA1(i));
@@ -263,6 +279,12 @@ static void dispc_save_context(void)
 		}
 		if (dss_has_feature(FEAT_ATTR2))
 			SR(OVL_ATTRIBUTES2(i));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (dss_has_feature(FEAT_CORE_CLK_DIV))
@@ -301,6 +323,11 @@ static void dispc_restore_context(void)
 	if (dss_has_feature(FEAT_MGR_LCD2))
 		RR(CONFIG2);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dss_feat_get_num_mgrs(); i++) {
 		RR(DEFAULT_COLOR(i));
 		RR(TRANS_COLOR(i));
@@ -321,8 +348,19 @@ static void dispc_restore_context(void)
 			RR(CPR_COEF_G(i));
 			RR(CPR_COEF_B(i));
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dss_feat_get_num_ovls(); i++) {
 		RR(OVL_BA0(i));
 		RR(OVL_BA1(i));
@@ -376,6 +414,12 @@ static void dispc_restore_context(void)
 		}
 		if (dss_has_feature(FEAT_ATTR2))
 			RR(OVL_ATTRIBUTES2(i));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (dss_has_feature(FEAT_CORE_CLK_DIV))
@@ -621,6 +665,11 @@ static void dispc_ovl_set_scale_coef(enu
 	else
 		v_coef = five_taps ? coef_vdown_5tap : coef_vdown_3tap;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		u32 h, hv;
 
@@ -641,9 +690,20 @@ static void dispc_ovl_set_scale_coef(enu
 			dispc_ovl_write_firhv2_reg(plane, i, hv);
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (five_taps) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 8; i++) {
 			u32 v;
 			v = FLD_VAL(v_coef[i].vc00, 7, 0)
@@ -652,6 +712,12 @@ static void dispc_ovl_set_scale_coef(enu
 				dispc_ovl_write_firv_reg(plane, i, v);
 			else
 				dispc_ovl_write_firv2_reg(plane, i, v);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 }
@@ -672,7 +738,12 @@ static void _dispc_setup_color_conv_coef
 
 	ct = &ctbl_bt601_5;
 
-	for (i = 1; i < dss_feat_get_num_ovls(); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 1; i < dss_feat_get_num_ovls(); i++) {
 		dispc_write_reg(DISPC_OVL_CONV_COEF(i, 0),
 			CVAL(ct->rcr, ct->ry));
 		dispc_write_reg(DISPC_OVL_CONV_COEF(i, 1),
@@ -686,6 +757,12 @@ static void _dispc_setup_color_conv_coef
 
 		REG_FLD_MOD(DISPC_OVL_ATTRIBUTES(i), ct->full_range,
 			11, 11);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 #undef CVAL
@@ -1045,10 +1122,21 @@ static void dispc_read_plane_fifo_sizes(
 
 	dss_feat_get_reg_field(FEAT_REG_FIFOSIZE, &start, &end);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (plane = 0; plane < dss_feat_get_num_ovls(); ++plane) {
 		size = REG_GET(DISPC_OVL_FIFO_SIZE_STATUS(plane), start, end);
 		size *= unit;
 		dispc.fifo_size[plane] = size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2016,11 +2104,22 @@ static void dispc_mgr_enable_digit_out(b
 
 	_enable_digit_out(enable);
 
-	for (i = 0; i < num_irqs; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < num_irqs; ++i) {
 		if (!wait_for_completion_timeout(&frame_done_completion,
 					msecs_to_jiffies(100)))
 			DSSERR("timeout waiting for digit out to %s\n",
 					enable ? "start" : "stop");
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	r = omap_dispc_unregister_isr(dispc_disable_isr, &frame_done_completion,
@@ -2648,6 +2747,11 @@ void dispc_dump_regs(struct seq_file *s)
 	p_names = mgr_names;
 
 	/* DISPC channel specific registers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dss_feat_get_num_mgrs(); i++) {
 		DUMPREG(i, DISPC_DEFAULT_COLOR);
 		DUMPREG(i, DISPC_TRANS_COLOR);
@@ -2673,10 +2777,21 @@ void dispc_dump_regs(struct seq_file *s)
 			DUMPREG(i, DISPC_CPR_COEF_G);
 			DUMPREG(i, DISPC_CPR_COEF_B);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	p_names = ovl_names;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dss_feat_get_num_ovls(); i++) {
 		DUMPREG(i, DISPC_OVL_BA0);
 		DUMPREG(i, DISPC_OVL_BA1);
@@ -2711,6 +2826,12 @@ void dispc_dump_regs(struct seq_file *s)
 			DUMPREG(i, DISPC_OVL_ATTRIBUTES2);
 		if (dss_has_feature(FEAT_PRELOAD))
 			DUMPREG(i, DISPC_OVL_PRELOAD);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 #undef DISPC_REG
@@ -2725,6 +2846,11 @@ void dispc_dump_regs(struct seq_file *s)
 	/* Video pipeline coefficient registers */
 
 	/* start from OMAP_DSS_VIDEO1 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < dss_feat_get_num_ovls(); i++) {
 		for (j = 0; j < 8; j++)
 			DUMPREG(i, DISPC_OVL_FIR_COEF_H, j);
@@ -2750,6 +2876,12 @@ void dispc_dump_regs(struct seq_file *s)
 			for (j = 0; j < 8; j++)
 				DUMPREG(i, DISPC_OVL_FIR_COEF_V2, j);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	dispc_runtime_put();
@@ -2894,6 +3026,11 @@ static void _omap_dispc_set_irqs(void)
 
 	mask = dispc.irq_error_mask;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
 		isr_data = &dispc.registered_isr[i];
 
@@ -2901,6 +3038,12 @@ static void _omap_dispc_set_irqs(void)
 			continue;
 
 		mask |= isr_data->mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	old_mask = dispc_read_reg(DISPC_IRQENABLE);
@@ -2923,6 +3066,11 @@ int omap_dispc_register_isr(omap_dispc_i
 	spin_lock_irqsave(&dispc.irq_lock, flags);
 
 	/* check for duplicate entry */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
 		isr_data = &dispc.registered_isr[i];
 		if (isr_data->isr == isr && isr_data->arg == arg &&
@@ -2930,11 +3078,22 @@ int omap_dispc_register_isr(omap_dispc_i
 			ret = -EINVAL;
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	isr_data = NULL;
 	ret = -EBUSY;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
 		isr_data = &dispc.registered_isr[i];
 
@@ -2947,6 +3106,12 @@ int omap_dispc_register_isr(omap_dispc_i
 		ret = 0;
 
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ret)
@@ -2973,7 +3138,12 @@ int omap_dispc_unregister_isr(omap_dispc
 
 	spin_lock_irqsave(&dispc.irq_lock, flags);
 
-	for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
 		isr_data = &dispc.registered_isr[i];
 		if (isr_data->isr != isr || isr_data->arg != arg ||
 				isr_data->mask != mask)
@@ -2987,6 +3157,12 @@ int omap_dispc_unregister_isr(omap_dispc
 
 		ret = 0;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ret == 0)
@@ -3073,6 +3249,11 @@ static irqreturn_t omap_dispc_irq_handle
 
 	spin_unlock(&dispc.irq_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
 		isr_data = &registered_isr[i];
 
@@ -3083,6 +3264,12 @@ static irqreturn_t omap_dispc_irq_handle
 			isr_data->isr(isr_data->arg, irqstatus);
 			handledirqs |= isr_data->mask;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_lock(&dispc.irq_lock);
@@ -3128,6 +3315,11 @@ static void dispc_error_worker(struct wo
 
 	dispc_runtime_get();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
 		struct omap_overlay *ovl;
 		unsigned bit;
@@ -3142,8 +3334,19 @@ static void dispc_error_worker(struct wo
 			dispc_mgr_go(ovl->manager->id);
 			mdelay(50);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {
 		struct omap_overlay_manager *mgr;
 		unsigned bit;
@@ -3162,13 +3365,24 @@ static void dispc_error_worker(struct wo
 			enable = dssdev->state == OMAP_DSS_DISPLAY_ACTIVE;
 			dssdev->driver->disable(dssdev);
 
-			for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+					for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
 				struct omap_overlay *ovl;
 				ovl = omap_dss_get_overlay(i);
 
 				if (ovl->id != OMAP_DSS_GFX &&
 						ovl->manager == mgr)
 					dispc_ovl_enable(ovl->id, false);
+					if (_cur < timeout) {
+				rdstcll(_cur);
+					}
+				else {
+				break;
+				}
 			}
 
 			dispc_mgr_go(mgr->id);
@@ -3177,14 +3391,31 @@ static void dispc_error_worker(struct wo
 			if (enable)
 				dssdev->driver->enable(dssdev);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (errors & DISPC_IRQ_OCP_ERR) {
 		DSSERR("OCP_ERR\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {
 			struct omap_overlay_manager *mgr;
 			mgr = omap_dss_get_overlay_manager(i);
 			mgr->device->driver->disable(mgr->device);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -3264,6 +3495,11 @@ void dispc_fake_vsync_irq(void)
 
 	WARN_ON(!in_interrupt());
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
 		struct omap_dispc_isr_data *isr_data;
 		isr_data = &dispc.registered_isr[i];
@@ -3273,6 +3509,12 @@ void dispc_fake_vsync_irq(void)
 
 		if (isr_data->mask & irqstatus)
 			isr_data->isr(isr_data->arg, irqstatus);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 #endif
diff -u -p a/video/omap2/dss/ti_hdmi_4xxx_ip.c b/video/omap2/dss/ti_hdmi_4xxx_ip.c
--- a/video/omap2/dss/ti_hdmi_4xxx_ip.c
+++ b/video/omap2/dss/ti_hdmi_4xxx_ip.c
@@ -415,6 +415,11 @@ static int hdmi_core_ddc_edid(struct hdm
 		return -EIO;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 0x80; ++i) {
 		int t;
 
@@ -435,6 +440,12 @@ static int hdmi_core_ddc_edid(struct hdm
 		}
 
 		pedid[i] = REG_GET(base, HDMI_CORE_DDC_DATA, 7, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	checksum = 0;
diff -u -p a/video/omap2/dss/rfbi.c b/video/omap2/dss/rfbi.c
--- a/video/omap2/dss/rfbi.c
+++ b/video/omap2/dss/rfbi.c
@@ -259,11 +259,22 @@ void omap_rfbi_write_pixels(const void _
 		pd += start_offset;
 
 		for (; h; --h) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < w; ++i) {
 				const u8 __iomem *b = (const u8 __iomem *)pd;
 				rfbi_write_reg(RFBI_PARAM, __raw_readb(b+1));
 				rfbi_write_reg(RFBI_PARAM, __raw_readb(b+0));
 				++pd;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			pd += horiz_offset;
 		}
@@ -273,12 +284,23 @@ void omap_rfbi_write_pixels(const void _
 		pd += start_offset;
 
 		for (; h; --h) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < w; ++i) {
 				const u8 __iomem *b = (const u8 __iomem *)pd;
 				rfbi_write_reg(RFBI_PARAM, __raw_readb(b+2));
 				rfbi_write_reg(RFBI_PARAM, __raw_readb(b+1));
 				rfbi_write_reg(RFBI_PARAM, __raw_readb(b+0));
 				++pd;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			pd += horiz_offset;
 		}
@@ -288,9 +310,20 @@ void omap_rfbi_write_pixels(const void _
 		pd += start_offset;
 
 		for (; h; --h) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < w; ++i) {
 				rfbi_write_reg(RFBI_PARAM, __raw_readw(pd));
 				++pd;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			pd += horiz_offset;
 		}
diff -u -p a/video/omap2/dss/overlay.c b/video/omap2/dss/overlay.c
--- a/video/omap2/dss/overlay.c
+++ b/video/omap2/dss/overlay.c
@@ -503,6 +503,11 @@ int dss_check_overlay(struct omap_overla
 		 * overlay which is enabled and is also connected to the same
 		 * manager
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < omap_dss_get_num_overlays(); i++) {
 			struct omap_overlay *tmp_ovl = omap_dss_get_overlay(i);
 
@@ -514,6 +519,12 @@ int dss_check_overlay(struct omap_overla
 					ovl->name, tmp_ovl->name, info->zorder);
 				return -EINVAL;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -658,6 +669,11 @@ void dss_init_overlays(struct platform_d
 
 	num_overlays = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dss_feat_get_num_ovls(); ++i) {
 		struct omap_overlay *ovl;
 		ovl = kzalloc(sizeof(*ovl), GFP_KERNEL);
@@ -715,7 +731,13 @@ void dss_init_overlays(struct platform_d
 		}
 
 		dispc_overlays[i] = ovl;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 #ifdef L4_EXAMPLE
 	{
@@ -790,6 +812,11 @@ void dss_recheck_connections(struct omap
 	if (mgr) {
 		dispc_runtime_get();
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dss_feat_get_num_ovls(); i++) {
 			struct omap_overlay *ovl;
 			ovl = omap_dss_get_overlay(i);
@@ -798,6 +825,12 @@ void dss_recheck_connections(struct omap
 					omap_dss_unset_manager(ovl);
 				omap_dss_set_manager(ovl, mgr);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		dispc_runtime_put();
diff -u -p a/video/omap2/dss/core.c b/video/omap2/dss/core.c
--- a/video/omap2/dss/core.c
+++ b/video/omap2/dss/core.c
@@ -221,6 +221,11 @@ static int omap_dss_probe(struct platfor
 	if (r)
 		goto err_debugfs;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_devices; ++i) {
 		struct omap_dss_device *dssdev = pdata->devices[i];
 
@@ -237,6 +242,12 @@ static int omap_dss_probe(struct platfor
 
 		if (def_disp_name && strcmp(def_disp_name, dssdev->name) == 0)
 			pdata->default_device = dssdev;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/video/omap2/vrfb.c b/video/omap2/vrfb.c
--- a/video/omap2/vrfb.c
+++ b/video/omap2/vrfb.c
@@ -104,11 +104,22 @@ void omap_vrfb_restore_context(void)
 	int i;
 	unsigned long map = ctx_map;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ffs(map); i; i = ffs(map)) {
 		/* i=1..32 */
 		i--;
 		map &= ~(1 << i);
 		restore_hw_context(i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -249,11 +260,22 @@ void omap_vrfb_release_ctx(struct vrfb *
 
 	clear_bit(ctx, &ctx_map);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rot = 0; rot < 4; ++rot) {
 		if (vrfb->paddr[rot]) {
 			release_mem_region(vrfb->paddr[rot], OMAP_VRFB_SIZE);
 			vrfb->paddr[rot] = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	vrfb->context = 0xff;
@@ -291,6 +313,11 @@ int omap_vrfb_request_ctx(struct vrfb *v
 
 	vrfb->context = ctx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rot = 0; rot < 4; ++rot) {
 		paddr = SMS_ROT_VIRT_BASE(ctx, rot);
 		if (!request_mem_region(paddr, OMAP_VRFB_SIZE, "vrfb")) {
@@ -305,6 +332,12 @@ int omap_vrfb_request_ctx(struct vrfb *v
 		vrfb->paddr[rot] = paddr;
 
 		DBG("VRFB %d/%d: %lx\n", ctx, rot*90, vrfb->paddr[rot]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	r = 0;
diff -u -p a/video/fsl-diu-fb.c b/video/fsl-diu-fb.c
--- a/video/fsl-diu-fb.c
+++ b/video/fsl-diu-fb.c
@@ -1510,7 +1510,12 @@ static int __devinit fsl_diu_probe(struc
 
 	spin_lock_init(&machine_data->reg_lock);
 
-	for (i = 0; i < ARRAY_SIZE(machine_data->fsl_diu_info); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(machine_data->fsl_diu_info); i++) {
 		machine_data->fsl_diu_info[i] =
 			framebuffer_alloc(sizeof(struct mfb_info), &pdev->dev);
 		if (!machine_data->fsl_diu_info[i]) {
@@ -1532,6 +1537,12 @@ static int __devinit fsl_diu_probe(struc
 				mfbi->edid_data = kmemdup(prop, EDID_LENGTH,
 							  GFP_KERNEL);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	machine_data->diu_reg = of_iomap(np, 0);
@@ -1602,6 +1613,11 @@ static int __devinit fsl_diu_probe(struc
 	out_be32(&machine_data->diu_reg->desc[1], machine_data->dummy_ad->paddr);
 	out_be32(&machine_data->diu_reg->desc[2], machine_data->dummy_ad->paddr);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(machine_data->fsl_diu_info); i++) {
 		machine_data->fsl_diu_info[i]->fix.smem_start = 0;
 		mfbi = machine_data->fsl_diu_info[i]->par;
@@ -1614,6 +1630,12 @@ static int __devinit fsl_diu_probe(struc
 			dev_err(&pdev->dev, "could not register fb %d\n", i);
 			goto error;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (request_irq_local(machine_data)) {
diff -u -p a/video/pxa3xx-gcu.c b/video/pxa3xx-gcu.c
--- a/video/pxa3xx-gcu.c
+++ b/video/pxa3xx-gcu.c
@@ -588,12 +588,23 @@ pxa3xx_gcu_probe(struct platform_device
 	if (!priv)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		ret = add_buffer(dev, priv);
 		if (ret) {
 			dev_err(&dev->dev, "failed to allocate DMA memory\n");
 			goto err_free_priv;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	init_waitqueue_head(&priv->wait_idle);
diff -u -p a/video/s3c-fb.c b/video/s3c-fb.c
--- a/video/s3c-fb.c
+++ b/video/s3c-fb.c
@@ -1429,16 +1429,32 @@ static int __devinit s3c_fb_probe(struct
 		s3c_fb_clear_win(sfb, win);
 
 	/* initialise colour key controls */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (win = 0; win < (fbdrv->variant.nr_windows - 1); win++) {
 		void __iomem *regs = sfb->regs + sfb->variant.keycon;
 
 		regs += (win * 8);
 		writel(0xffffff, regs + WKEYCON0);
 		writel(0xffffff, regs + WKEYCON1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* we have the register setup, start allocating framebuffers */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (win = 0; win < fbdrv->variant.nr_windows; win++) {
 		if (!pd->win[win])
 			continue;
@@ -1454,6 +1470,12 @@ static int __devinit s3c_fb_probe(struct
 				s3c_fb_release_win(sfb, sfb->windows[win]);
 			goto err_irq;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	platform_set_drvdata(pdev, sfb);
@@ -1532,6 +1554,11 @@ static int s3c_fb_suspend(struct device
 	struct s3c_fb_win *win;
 	int win_no;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (win_no = S3C_FB_MAX_WIN - 1; win_no >= 0; win_no--) {
 		win = sfb->windows[win_no];
 		if (!win)
@@ -1539,6 +1566,12 @@ static int s3c_fb_suspend(struct device
 
 		/* use the blank function to push into power-down */
 		s3c_fb_blank(FB_BLANK_POWERDOWN, win->fbinfo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!sfb->variant.has_clksel)
@@ -1569,15 +1602,31 @@ static int s3c_fb_resume(struct device *
 	for (win_no = 0; win_no < sfb->variant.nr_windows; win_no++)
 		s3c_fb_clear_win(sfb, win_no);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (win_no = 0; win_no < sfb->variant.nr_windows - 1; win_no++) {
 		void __iomem *regs = sfb->regs + sfb->variant.keycon;
 
 		regs += (win_no * 8);
 		writel(0xffffff, regs + WKEYCON0);
 		writel(0xffffff, regs + WKEYCON1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* restore framebuffers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (win_no = 0; win_no < S3C_FB_MAX_WIN; win_no++) {
 		win = sfb->windows[win_no];
 		if (!win)
@@ -1585,6 +1634,12 @@ static int s3c_fb_resume(struct device *
 
 		dev_dbg(&pdev->dev, "resuming window %d\n", win_no);
 		s3c_fb_set_par(win->fbinfo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1597,6 +1652,11 @@ static int s3c_fb_runtime_suspend(struct
 	struct s3c_fb_win *win;
 	int win_no;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (win_no = S3C_FB_MAX_WIN - 1; win_no >= 0; win_no--) {
 		win = sfb->windows[win_no];
 		if (!win)
@@ -1604,6 +1664,12 @@ static int s3c_fb_runtime_suspend(struct
 
 		/* use the blank function to push into power-down */
 		s3c_fb_blank(FB_BLANK_POWERDOWN, win->fbinfo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!sfb->variant.has_clksel)
@@ -1634,15 +1700,31 @@ static int s3c_fb_runtime_resume(struct
 	for (win_no = 0; win_no < sfb->variant.nr_windows; win_no++)
 		s3c_fb_clear_win(sfb, win_no);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (win_no = 0; win_no < sfb->variant.nr_windows - 1; win_no++) {
 		void __iomem *regs = sfb->regs + sfb->variant.keycon;
 
 		regs += (win_no * 8);
 		writel(0xffffff, regs + WKEYCON0);
 		writel(0xffffff, regs + WKEYCON1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* restore framebuffers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (win_no = 0; win_no < S3C_FB_MAX_WIN; win_no++) {
 		win = sfb->windows[win_no];
 		if (!win)
@@ -1650,6 +1732,12 @@ static int s3c_fb_runtime_resume(struct
 
 		dev_dbg(&pdev->dev, "resuming window %d\n", win_no);
 		s3c_fb_set_par(win->fbinfo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/omap/lcd_mipid.c b/video/omap/lcd_mipid.c
--- a/video/omap/lcd_mipid.c
+++ b/video/omap/lcd_mipid.c
@@ -293,6 +293,11 @@ static int mipid_run_test(struct lcd_pan
 	if (test_num != MIPID_TEST_RGB_LINES)
 		return MIPID_TEST_INVALID;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(test_values); i++) {
 		int delay;
 		unsigned long tmo;
@@ -316,6 +321,12 @@ static int mipid_run_test(struct lcd_pan
 			}
 			delay = 10;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -370,9 +381,20 @@ static void ls041y3_esd_check_mode2(stru
 	mipid_read(md, rd->cmd, rbuf, 2);
 	rd++;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++, rd++) {
 		udelay(10);
 		mipid_write(md, rd->cmd, (u8 *)rd->wbuf, rd->wlen);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev_dbg(&md->spi->dev, "ESD mode 2 state %02x\n", rbuf[1]);
diff -u -p a/video/omap/omapfb_main.c b/video/omap/omapfb_main.c
--- a/video/omap/omapfb_main.c
+++ b/video/omap/omapfb_main.c
@@ -197,12 +197,23 @@ static int ctrl_init(struct omapfb_devic
 	}
 
 #ifdef DEBUG
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fbdev->mem_desc.region_cnt; i++) {
 		dev_dbg(fbdev->dev, "region%d phys %08x virt %p size=%lu\n",
 			 i,
 			 fbdev->mem_desc.region[i].paddr,
 			 fbdev->mem_desc.region[i].vaddr,
 			 fbdev->mem_desc.region[i].size);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 #endif
 	return 0;
@@ -340,6 +351,11 @@ static int omapfb_setcmap(struct fb_cmap
 	transp  = cmap->transp;
 	index   = cmap->start;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; count < cmap->len; count++) {
 		if (transp)
 			trans = *transp++;
@@ -347,6 +363,12 @@ static int omapfb_setcmap(struct fb_cmap
 				count == cmap->len - 1);
 		if (r != 0)
 			return r;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
@@ -1331,27 +1353,60 @@ static ssize_t omapfb_show_caps_text(str
 		omapfb_get_caps(fbdev, plane, &caps);
 		size += snprintf(&buf[size], PAGE_SIZE - size,
 				 "plane#%d:\n", plane);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ARRAY_SIZE(ctrl_caps) &&
 		     size < PAGE_SIZE; i++) {
 			if (ctrl_caps[i].flag & caps.ctrl)
 				size += snprintf(&buf[size], PAGE_SIZE - size,
 					" %s\n", ctrl_caps[i].name);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		size += snprintf(&buf[size], PAGE_SIZE - size,
 				 " plane colors:\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ARRAY_SIZE(color_caps) &&
 		     size < PAGE_SIZE; i++) {
 			if (color_caps[i].flag & caps.plane_color)
 				size += snprintf(&buf[size], PAGE_SIZE - size,
 					"  %s\n", color_caps[i].name);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		size += snprintf(&buf[size], PAGE_SIZE - size,
 				 " window colors:\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ARRAY_SIZE(color_caps) &&
 		     size < PAGE_SIZE; i++) {
 			if (color_caps[i].flag & caps.wnd_color)
 				size += snprintf(&buf[size], PAGE_SIZE - size,
 					"  %s\n", color_caps[i].name);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 
 		plane++;
@@ -1559,7 +1614,12 @@ static int planes_init(struct omapfb_dev
 	int i;
 	int r;
 
-	for (i = 0; i < fbdev->mem_desc.region_cnt; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < fbdev->mem_desc.region_cnt; i++) {
 		struct omapfb_plane_struct *plane;
 		fbi = framebuffer_alloc(sizeof(struct omapfb_plane_struct),
 					fbdev->dev);
@@ -1582,6 +1642,12 @@ static int planes_init(struct omapfb_dev
 		}
 		plane->info.out_width = fbi->var.xres;
 		plane->info.out_height = fbi->var.yres;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1796,7 +1862,12 @@ static int omapfb_do_probe(struct platfo
 	init_state++;
 
 	vram = 0;
-	for (i = 0; i < fbdev->mem_desc.region_cnt; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < fbdev->mem_desc.region_cnt; i++) {
 		r = register_framebuffer(fbdev->fb_info[i]);
 		if (r != 0) {
 			dev_err(fbdev->dev,
@@ -1804,6 +1875,12 @@ static int omapfb_do_probe(struct platfo
 			goto cleanup;
 		}
 		vram += fbdev->mem_desc.region[i].size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	fbdev->state = OMAPFB_ACTIVE;
diff -u -p a/video/omap/dispc.c b/video/omap/dispc.c
--- a/video/omap/dispc.c
+++ b/video/omap/dispc.c
@@ -509,9 +509,20 @@ static void set_upsampling_coef_table(in
 	};
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		write_firh_reg(plane, i, coef[i][0]);
 		write_firhv_reg(plane, i, coef[i][1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -828,11 +839,22 @@ static void recalc_irq_mask(void)
 	int i;
 	unsigned long irq_mask = DISPC_IRQ_MASK_ERROR;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_IRQ_HANDLERS; i++) {
 		if (!dispc.irq_handlers[i].callback)
 			continue;
 
 		irq_mask |= dispc.irq_handlers[i].irq_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	enable_lcd_clocks(1);
@@ -847,6 +869,11 @@ int omap_dispc_request_irq(unsigned long
 
 	BUG_ON(callback == NULL);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_IRQ_HANDLERS; i++) {
 		if (dispc.irq_handlers[i].callback)
 			continue;
@@ -857,6 +884,12 @@ int omap_dispc_request_irq(unsigned long
 		recalc_irq_mask();
 
 		return 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -EBUSY;
@@ -868,6 +901,11 @@ void omap_dispc_free_irq(unsigned long i
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_IRQ_HANDLERS; i++) {
 		if (dispc.irq_handlers[i].callback == callback &&
 		    dispc.irq_handlers[i].data == data) {
@@ -877,6 +915,12 @@ void omap_dispc_free_irq(unsigned long i
 			recalc_irq_mask();
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	BUG();
@@ -901,11 +945,22 @@ static irqreturn_t omap_dispc_irq_handle
 		}
 	}
 
-	for (i = 0; i < MAX_IRQ_HANDLERS; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (i = 0; i < MAX_IRQ_HANDLERS; i++) {
 		if (unlikely(dispc.irq_handlers[i].callback &&
 			     (stat & dispc.irq_handlers[i].irq_mask)))
 			dispc.irq_handlers[i].callback(
 						dispc.irq_handlers[i].data);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	dispc_write_reg(DISPC_IRQSTATUS, stat);
@@ -1295,6 +1350,11 @@ static int setup_fbmem(struct omapfb_mem
 	memset(mem_start, 0xff, sizeof(mem_start));
 	memset(mem_end, 0, sizeof(mem_end));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < req_md->region_cnt; i++, rg++) {
 		int mtype;
 		if (rg->paddr) {
@@ -1320,8 +1380,19 @@ static int setup_fbmem(struct omapfb_mem
 			mem_start[mtype] = rg->paddr;
 		if (rg->paddr + rg->size > mem_end[mtype])
 			mem_end[mtype] = rg->paddr + rg->size;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < DISPC_MEMTYPE_NUM; i++) {
 		unsigned long start;
 		size_t size;
@@ -1338,15 +1409,32 @@ static int setup_fbmem(struct omapfb_mem
 		 * freed.
 		 */
 		resmap_reserve_region(start, size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dispc.mem_desc = *req_md;
 
 	return 0;
 fail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < DISPC_MEMTYPE_NUM; i++) {
 		if (dispc.res_map[i] != NULL)
 			cleanup_resmap(dispc.res_map[i]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return r;
 }
@@ -1356,11 +1444,27 @@ static void cleanup_fbmem(void)
 	struct omapfb_mem_region *rg;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < DISPC_MEMTYPE_NUM; i++) {
 		if (dispc.res_map[i] != NULL)
 			cleanup_resmap(dispc.res_map[i]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	rg = &dispc.mem_desc.region[0];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dispc.mem_desc.region_cnt; i++, rg++) {
 		if (rg->alloc)
 			free_fbmem(rg);
@@ -1368,6 +1472,12 @@ static void cleanup_fbmem(void)
 			if (rg->map)
 				unmap_kern(rg);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -1467,9 +1577,20 @@ static int omap_dispc_init(struct omapfb
 		goto fail3;
 
 	if (!skip_init) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dispc.mem_desc.region_cnt; i++) {
 			memset(dispc.mem_desc.region[i].vaddr, 0,
 				dispc.mem_desc.region[i].size);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		/* Set logic clock to fck, pixel clock to fck/2 for now */
diff -u -p a/video/omap/blizzard.c b/video/omap/blizzard.c
--- a/video/omap/blizzard.c
+++ b/video/omap/blizzard.c
@@ -473,6 +473,11 @@ static int do_full_screen_update(struct
 	int i;
 	int flags;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		struct plane_info *p = &blizzard.plane[i];
 		if (!(blizzard.enabled_planes & (1 << i))) {
@@ -487,6 +492,12 @@ static int do_full_screen_update(struct
 				p->width, p->height,
 				p->color_mode);
 		blizzard.int_ctrl->enable_plane(i, 1);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	dev_dbg(blizzard.fbdev->dev, "sw %d sh %d\n",
@@ -557,6 +568,11 @@ static int do_partial_update(struct bliz
 		gy2_out = gy1_out + h_out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < OMAPFB_PLANE_NUM; i++) {
 		struct plane_info *p = &blizzard.plane[i];
 		int px1, py1;
@@ -633,6 +649,12 @@ static int do_partial_update(struct bliz
 				p->color_mode);
 
 		blizzard.int_ctrl->enable_plane(i, 1);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
 	}
 
 	switch (wnd_color_mode) {
@@ -1375,10 +1397,21 @@ static void _save_regs(const struct bliz
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < cnt; i++, list++) {
 		int reg;
 		for (reg = list->start; reg <= list->end; reg += 2)
 			blizzard_reg_cache[reg / 2] = blizzard_read_reg(reg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -1386,10 +1419,21 @@ static void _restore_regs(const struct b
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < cnt; i++, list++) {
 		int reg;
 		for (reg = list->start; reg <= list->end; reg += 2)
 			blizzard_write_reg(reg, blizzard_reg_cache[reg / 2]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/video/backlight/vgg2432a4.c b/video/backlight/vgg2432a4.c
--- a/video/backlight/vgg2432a4.c
+++ b/video/backlight/vgg2432a4.c
@@ -178,9 +178,20 @@ static int vgg2432a4_lcd_init(struct ili
 	ili9320_write(lcd, ILI9320_BASE_IMAGE, 0x1);
 	ili9320_write(lcd, ILI9320_VERT_SCROLL, 0x00);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (addr = ILI9320_PARTIAL1_POSITION; addr <= ILI9320_PARTIAL2_END;
 	     addr++) {
 		ili9320_write(lcd, addr, 0x0);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	ili9320_write(lcd, ILI9320_INTERFACE1, 0x10);
diff -u -p a/video/backlight/corgi_lcd.c b/video/backlight/corgi_lcd.c
--- a/video/backlight/corgi_lcd.c
+++ b/video/backlight/corgi_lcd.c
@@ -143,12 +143,23 @@ static void lcdtg_i2c_send_byte(struct c
 				uint8_t base, uint8_t data)
 {
 	int i;
-	for (i = 0; i < 8; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 8; i++) {
 		if (data & 0x80)
 			lcdtg_i2c_send_bit(lcd, base | POWER0_COM_DOUT);
 		else
 			lcdtg_i2c_send_bit(lcd, base);
 		data <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/backlight/ams369fg06.c b/video/backlight/ams369fg06.c
--- a/video/backlight/ams369fg06.c
+++ b/video/backlight/ams369fg06.c
@@ -224,6 +224,11 @@ static int _ams369fg06_gamma_ctl(struct
 	unsigned int i = 0;
 	int ret = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0 ; i < GAMMA_TABLE_COUNT / 3; i++) {
 		ret = ams369fg06_spi_write(lcd, 0x40 + i, gamma[i]);
 		ret = ams369fg06_spi_write(lcd, 0x50 + i, gamma[i+7*1]);
@@ -232,6 +237,12 @@ static int _ams369fg06_gamma_ctl(struct
 			dev_err(lcd->dev, "failed to set gamma table.\n");
 			goto gamma_err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 gamma_err:
diff -u -p a/video/backlight/ld9040.c b/video/backlight/ld9040.c
--- a/video/backlight/ld9040.c
+++ b/video/backlight/ld9040.c
@@ -450,12 +450,23 @@ static int _ld9040_gamma_ctl(struct ld90
 		goto gamma_err;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0 ; i < GAMMA_TABLE_COUNT; i++) {
 		ret = ld9040_spi_write(lcd, DATA_ONLY, gamma[i]);
 		if (ret) {
 			dev_err(lcd->dev, "failed to set gamma table.\n");
 			goto gamma_err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* update gamma table. */
diff -u -p a/video/backlight/adp8860_bl.c b/video/backlight/adp8860_bl.c
--- a/video/backlight/adp8860_bl.c
+++ b/video/backlight/adp8860_bl.c
@@ -239,6 +239,11 @@ static int __devinit adp8860_led_probe(s
 		goto err_free;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_leds; ++i) {
 		cur_led = &pdata->leds[i];
 		led_dat = &led[i];
@@ -279,6 +284,12 @@ static int __devinit adp8860_led_probe(s
 			i++;
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	data->led = led;
@@ -286,9 +297,20 @@ static int __devinit adp8860_led_probe(s
 	return 0;
 
  err:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = i - 1; i >= 0; --i) {
 		led_classdev_unregister(&led[i].cdev);
 		cancel_work_sync(&led[i].work);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
  err_free:
@@ -304,9 +326,20 @@ static int __devexit adp8860_led_remove(
 	struct adp8860_bl *data = i2c_get_clientdata(client);
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_leds; i++) {
 		led_classdev_unregister(&data->led[i].cdev);
 		cancel_work_sync(&data->led[i].work);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(data->led);
diff -u -p a/video/backlight/lms283gf05.c b/video/backlight/lms283gf05.c
--- a/video/backlight/lms283gf05.c
+++ b/video/backlight/lms283gf05.c
@@ -109,6 +109,11 @@ static void lms283gf05_toggle(struct spi
 	char buf[3];
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sz; i++) {
 		buf[0] = 0x74;
 		buf[1] = 0x00;
@@ -121,6 +126,12 @@ static void lms283gf05_toggle(struct spi
 		spi_write(spi, buf, 3);
 
 		mdelay(seq[i].delay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/backlight/ili9320.c b/video/backlight/ili9320.c
--- a/video/backlight/ili9320.c
+++ b/video/backlight/ili9320.c
@@ -66,10 +66,21 @@ int ili9320_write_regs(struct ili9320 *i
 	int index;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < nr_values; index++, values++) {
 		ret = ili9320_write(ili, values->address, values->value);
 		if (ret != 0)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/video/backlight/s6e63m0.c b/video/backlight/s6e63m0.c
--- a/video/backlight/s6e63m0.c
+++ b/video/backlight/s6e63m0.c
@@ -426,12 +426,23 @@ static int _s6e63m0_gamma_ctl(struct s6e
 		goto gamma_err;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0 ; i < GAMMA_TABLE_COUNT; i++) {
 		ret = s6e63m0_spi_write(lcd, DATA_ONLY, gamma[i]);
 		if (ret) {
 			dev_err(lcd->dev, "failed to set gamma table.\n");
 			goto gamma_err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* update gamma table. */
diff -u -p a/video/backlight/adp8870_bl.c b/video/backlight/adp8870_bl.c
--- a/video/backlight/adp8870_bl.c
+++ b/video/backlight/adp8870_bl.c
@@ -265,6 +265,11 @@ static int __devinit adp8870_led_probe(s
 	if (ret)
 		goto err_free;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_leds; ++i) {
 		cur_led = &pdata->leds[i];
 		led_dat = &led[i];
@@ -305,6 +310,12 @@ static int __devinit adp8870_led_probe(s
 			i++;
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	data->led = led;
@@ -312,9 +323,20 @@ static int __devinit adp8870_led_probe(s
 	return 0;
 
  err:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = i - 1; i >= 0; --i) {
 		led_classdev_unregister(&led[i].cdev);
 		cancel_work_sync(&led[i].work);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
  err_free:
@@ -330,9 +352,20 @@ static int __devexit adp8870_led_remove(
 	struct adp8870_bl *data = i2c_get_clientdata(client);
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_leds; i++) {
 		led_classdev_unregister(&data->led[i].cdev);
 		cancel_work_sync(&data->led[i].work);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(data->led);
diff -u -p a/video/grvga.c b/video/grvga.c
--- a/video/grvga.c
+++ b/video/grvga.c
@@ -459,10 +459,21 @@ static int __devinit grvga_probe(struct
 		/* Set page reserved so that mmap will work. This is necessary
 		 * since we'll be remapping normal memory.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (page = virtual_start;
 		     page < PAGE_ALIGN(virtual_start + grvga_mem_size);
 		     page += PAGE_SIZE) {
 			SetPageReserved(virt_to_page(page));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		par->fb_alloced = 1;
diff -u -p a/video/cg6.c b/video/cg6.c
--- a/video/cg6.c
+++ b/video/cg6.c
@@ -421,6 +421,11 @@ static void cg6_imageblit(struct fb_info
 
 	x = image->dx;
 	y = image->dy;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < image->height; i++) {
 		width = image->width;
 
@@ -465,6 +470,12 @@ static void cg6_imageblit(struct fb_info
 
 		y += 1;
 		x = image->dx;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&par->lock, flags);
diff -u -p a/video/arkfb.c b/video/arkfb.c
--- a/video/arkfb.c
+++ b/video/arkfb.c
@@ -144,10 +144,26 @@ static void arkfb_settile(struct fb_info
 	}
 
 	fb += 2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (c = 0; c < map->length; c++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < map->height; i++) {
 			fb_writeb(font[i], &fb[i * 4]);
 			fb_writeb(font[i], &fb[i * 4 + (128 * 8)]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		fb += 128;
 
@@ -155,6 +171,12 @@ static void arkfb_settile(struct fb_info
 			fb += 128*8;
 
 		font += map->height;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -199,16 +221,38 @@ static void arkfb_iplan_imageblit(struct
 	dst1 = info->screen_base + (image->dy * info->fix.line_length)
 		 + ((image->dx / 8) * 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < image->height; y++) {
 		src = src1;
 		dst = (u32 __iomem *) dst1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < image->width; x += 8) {
 			val = *(src++) * 0x01010101;
 			val = (val & fg) | (~val & bg);
 			fb_writel(val, dst++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		src1 += image->width / 8;
 		dst1 += info->fix.line_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -224,12 +268,34 @@ static void arkfb_iplan_fillrect(struct
 	dst1 = info->screen_base + (rect->dy * info->fix.line_length)
 		 + ((rect->dx / 8) * 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < rect->height; y++) {
 		dst = (u32 __iomem *) dst1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < rect->width; x += 8) {
 			fb_writel(fg, dst++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dst1 += info->fix.line_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -257,16 +323,38 @@ static void arkfb_cfb4_imageblit(struct
 	dst1 = info->screen_base + (image->dy * info->fix.line_length)
 		 + ((image->dx / 8) * 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < image->height; y++) {
 		src = src1;
 		dst = (u32 __iomem *) dst1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < image->width; x += 8) {
 			val = expand_pixel(*(src++));
 			val = (val & fg) | (~val & bg);
 			fb_writel(val, dst++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		src1 += image->width / 8;
 		dst1 += info->fix.line_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
diff -u -p a/video/smscufx.c b/video/smscufx.c
--- a/video/smscufx.c
+++ b/video/smscufx.c
@@ -261,12 +261,23 @@ static int ufx_blank(struct ufx_data *de
 	if (!wait)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 250; i++) {
 		status = ufx_reg_read(dev, 0x2004, &dc_sts);
 		check_warn_return(status, "ufx_blank error reading 0x2004");
 
 		if (dc_sts & 0x00000100)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* timed out waiting for display to blank */
@@ -298,12 +309,23 @@ static int ufx_unblank(struct ufx_data *
 	if (!wait)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 250; i++) {
 		status = ufx_reg_read(dev, 0x2004, &dc_sts);
 		check_warn_return(status, "ufx_unblank error reading 0x2004");
 
 		if ((dc_sts & 0x00000100) == 0)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* timed out waiting for display to unblank */
@@ -335,12 +357,23 @@ static int ufx_disable(struct ufx_data *
 	if (!wait)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 250; i++) {
 		status = ufx_reg_read(dev, 0x2004, &dc_sts);
 		check_warn_return(status, "ufx_disable error reading 0x2004");
 
 		if ((dc_sts & 0x00000001) == 0)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* timed out waiting for display to disable */
@@ -372,12 +405,23 @@ static int ufx_enable(struct ufx_data *d
 	if (!wait)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 250; i++) {
 		status = ufx_reg_read(dev, 0x2004, &dc_sts);
 		check_warn_return(status, "ufx_enable error reading 0x2004");
 
 		if (dc_sts & 0x00000001)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* timed out waiting for display to enable */
@@ -838,11 +882,22 @@ static void ufx_raw_rect(struct ufx_data
 	cmd[11] = cpu_to_le16(dev->info->var.yres);
 
 	/* packed data */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (line = 0; line < height; line++) {
 		const int line_offset = dev->info->fix.line_length * (y + line);
 		const int byte_offset = line_offset + (x * BPP);
 		memcpy(&cmd[(24 + (packed_line_len * line)) / 2],
 			(char *)dev->info->fix.smem_start + byte_offset, width * BPP);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1401,6 +1456,11 @@ static int ufx_i2c_wait_busy(struct ufx_
 	u32 tmp;
 	int i, status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 15; i++) {
 		status = ufx_reg_read(dev, 0x1100, &tmp);
 		check_warn_return(status, "0x1100 read failed");
@@ -1418,6 +1478,12 @@ static int ufx_i2c_wait_busy(struct ufx_
 		/* perform the first 10 retries without delay */
 		if (i >= 10)
 			msleep(10);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	pr_warn("I2C access timed out, resetting I2C hardware");
@@ -1444,6 +1510,11 @@ static int ufx_read_edid(struct ufx_data
 	memset(edid, 0xff, EDID_LENGTH);
 
 	/* Read the 128-byte EDID as 2 bursts of 64 bytes */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		u32 temp = 0x28070000 | (63 << 20) | (((u32)(i * 64)) << 8);
 		status = ufx_reg_write(dev, 0x1100, temp);
@@ -1456,19 +1527,47 @@ static int ufx_read_edid(struct ufx_data
 		status = ufx_i2c_wait_busy(dev);
 		check_warn_return(status, "Timeout waiting for I2C BUSY to clear");
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 16; j++) {
 			u32 data_reg_addr = 0x1110 + (j * 4);
 			status = ufx_reg_read(dev, data_reg_addr, edid_u32++);
 			check_warn_return(status, "Error reading i2c data");
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
 	/* all FF's in the first 16 bytes indicates nothing is connected */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i++) {
 		if (edid[i] != 0xFF) {
 			pr_debug("edid data read succesfully");
 			return EDID_LENGTH;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_warn("edid data contains all 0xff");
@@ -1549,12 +1648,23 @@ static int ufx_setup_modes(struct ufx_da
 	/* If we've got modes, let's pick a best default mode */
 	if (info->monspecs.modedb_len > 0) {
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < info->monspecs.modedb_len; i++) {
 			if (ufx_is_valid_mode(&info->monspecs.modedb[i], info))
 				fb_add_videomode(&info->monspecs.modedb[i],
 					&info->modelist);
 			else /* if we've removed top/best mode */
 				info->monspecs.misc &= ~FB_MISC_1ST_DETAIL;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 
 		default_vmode = fb_find_best_display(&info->monspecs,
@@ -1571,11 +1681,22 @@ static int ufx_setup_modes(struct ufx_da
 		 * overspec monitor and/or are incorrect aspect ratio, etc.
 		 * But at least the user has a chance to choose
 		 */
-		for (i = 0; i < VESA_MODEDB_SIZE; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				for (i = 0; i < VESA_MODEDB_SIZE; i++) {
 			if (ufx_is_valid_mode((struct fb_videomode *)
 						&vesa_modes[i], info))
 				fb_add_videomode(&vesa_modes[i],
 						 &info->modelist);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 
 		/* default to resolution safe for projectors
diff -u -p a/video/broadsheetfb.c b/video/broadsheetfb.c
--- a/video/broadsheetfb.c
+++ b/video/broadsheetfb.c
@@ -192,12 +192,23 @@ static void broadsheet_gpio_burst_write(
 	par->board->set_ctl(par, BS_CS, 0);
 	par->board->set_ctl(par, BS_DC, 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < size; i++) {
 		par->board->set_ctl(par, BS_WR, 0);
 		tmp = (data[i] & 0x0F) << 4;
 		tmp |= (data[i] & 0x0F00) << 4;
 		par->board->set_hdb(par, tmp);
 		par->board->set_ctl(par, BS_WR, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	par->board->set_ctl(par, BS_CS, 1);
@@ -209,10 +220,21 @@ static void broadsheet_mmio_burst_write(
 	int i;
 	u16 tmp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < size; i++) {
 		tmp = (data[i] & 0x0F) << 4;
 		tmp |= (data[i] & 0x0F00) << 4;
 		par->board->mmio_write(par, BS_MMIO_DATA, tmp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -447,11 +469,22 @@ static int broadsheet_spiflash_op_on_add
 	if (err)
 		return err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 2; i >= 0; i--) {
 		tmp = ((addr >> (i * 8)) & 0xFF);
 		err = broadsheet_spiflash_write_byte(par, tmp);
 		if (err)
 			return err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return err;
@@ -551,10 +584,21 @@ static int broadsheet_spiflash_read_rang
 	if (err)
 		goto failout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < size; i++) {
 		err = broadsheet_spiflash_read_byte(par, &data[i]);
 		if (err)
 			goto failout;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 failout:
@@ -575,10 +619,21 @@ static int broadsheet_spiflash_write_pag
 	if (err)
 		goto failout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < BS_SPIFLASH_PAGE_SIZE; i++) {
 		err = broadsheet_spiflash_write_byte(par, data[i]);
 		if (err)
 			goto failout;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	broadsheet_write_reg(par, 0x0208, 0);
@@ -595,10 +650,21 @@ static int broadsheet_spiflash_write_sec
 	int i;
 	int err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sector_size; i += BS_SPIFLASH_PAGE_SIZE) {
 		err = broadsheet_spiflash_write_page(par, addr + i, &data[i]);
 		if (err)
 			return err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/video/nvidia/nvidia.c b/video/nvidia/nvidia.c
--- a/video/nvidia/nvidia.c
+++ b/video/nvidia/nvidia.c
@@ -129,11 +129,21 @@ static void nvidiafb_load_cursor_image(s
 
 	w = (w + 1) & ~1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < h; i++) {
 		b = *data++;
 		reverse_order(&b);
 
-		for (j = 0; j < w / 2; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (j = 0; j < w / 2; j++) {
 			tmp = 0;
 #if defined (__BIG_ENDIAN)
 			tmp = (b & (1 << 31)) ? fg << 16 : bg << 16;
@@ -147,8 +157,20 @@ static void nvidiafb_load_cursor_image(s
 			b >>= 1;
 #endif
 			NV_WR32(&par->CURSOR[k++], 0, tmp);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		k += (MAX_CURS - w) / 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -263,17 +285,33 @@ static void nvidia_write_regs(struct nvi
 
 	NVWriteMiscOut(par, state->misc_output);
 
-	for (i = 1; i < NUM_SEQ_REGS; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (i = 1; i < NUM_SEQ_REGS; i++) {
 #ifdef DUMP_REG
 		printk(" SEQ[%02x] = %08x\n", i, state->seq[i]);
 #endif
 		NVWriteSeq(par, i, state->seq[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Ensure CRTC registers 0-7 are unlocked by clearing bit 7 of CRTC[17] */
 	NVWriteCrtc(par, 0x11, state->crtc[0x11] & ~0x80);
 
-	for (i = 0; i < NUM_CRT_REGS; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+for (i = 0; i < NUM_CRT_REGS; i++) {
 		switch (i) {
 		case 0x19:
 		case 0x20 ... 0x40:
@@ -284,20 +322,48 @@ static void nvidia_write_regs(struct nvi
 #endif
 			NVWriteCrtc(par, i, state->crtc[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
-	for (i = 0; i < NUM_GRC_REGS; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (i = 0; i < NUM_GRC_REGS; i++) {
 #ifdef DUMP_REG
 		printk(" GRA[%02x] = %08x\n", i, state->gra[i]);
 #endif
 		NVWriteGr(par, i, state->gra[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
-	for (i = 0; i < NUM_ATC_REGS; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (i = 0; i < NUM_ATC_REGS; i++) {
 #ifdef DUMP_REG
 		printk("ATTR[%02x] = %08x\n", i, state->attr[i]);
 #endif
 		NVWriteAttr(par, i, state->attr[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	NVTRACE_LEAVE();
@@ -733,18 +799,40 @@ static int nvidiafb_setcolreg(unsigned r
 		break;
 	case 16:
 		if (info->var.green.length == 5) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 8; i++) {
 				nvidia_write_clut(par, regno * 8 + i, red >> 8,
 						  green >> 8, blue >> 8);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
 			u8 r, g, b;
 
 			if (regno < 32) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < 8; i++) {
 					nvidia_write_clut(par, regno * 8 + i,
 							  red >> 8, green >> 8,
 							  blue >> 8);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 
diff -u -p a/video/nvidia/nv_hw.c b/video/nvidia/nv_hw.c
--- a/video/nvidia/nv_hw.c
+++ b/video/nvidia/nv_hw.c
@@ -782,9 +782,19 @@ static void CalcVClock(int clockIn,
 		highM = 14;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (P = 0; P <= 4; P++) {
 		Freq = VClk << P;
 		if ((Freq >= 128000) && (Freq <= 350000)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (M = lowM; M <= highM; M++) {
 				N = ((VClk << P) * M) / par->CrystalFreqKHz;
 				if (N <= 255) {
@@ -802,8 +812,20 @@ static void CalcVClock(int clockIn,
 						DeltaOld = DeltaNew;
 					}
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -822,10 +844,20 @@ static void CalcVClock2Stage(int clockIn
 
 	VClk = (unsigned)clockIn;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (P = 0; P <= 6; P++) {
 		Freq = VClk << P;
 		if ((Freq >= 400000) && (Freq <= 1000000)) {
-			for (M = 1; M <= 13; M++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (M = 1; M <= 13; M++) {
 				N = ((VClk << P) * M) /
 				    (par->CrystalFreqKHz << 2);
 				if ((N >= 5) && (N <= 255)) {
@@ -843,8 +875,20 @@ static void CalcVClock2Stage(int clockIn
 						DeltaOld = DeltaNew;
 					}
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -960,10 +1004,21 @@ void NVLoadStateExt(struct nvidia_par *p
 			NV_WR32(par->PFB, 0x0200, state->config);
 	} else if ((par->Architecture < NV_ARCH_40) ||
 		   (par->Chipset & 0xfff0) == 0x0040) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 8; i++) {
 			NV_WR32(par->PFB, 0x0240 + (i * 0x10), 0);
 			NV_WR32(par->PFB, 0x0244 + (i * 0x10),
 				par->FbMapSize - 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		int regions = 12;
@@ -974,10 +1029,21 @@ void NVLoadStateExt(struct nvidia_par *p
 		    ((par->Chipset & 0xfff0) == 0x0390) ||
 		    ((par->Chipset & 0xfff0) == 0x03D0))
 			regions = 15;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(i = 0; i < regions; i++) {
 			NV_WR32(par->PFB, 0x0600 + (i * 0x10), 0);
 			NV_WR32(par->PFB, 0x0604 + (i * 0x10),
 				par->FbMapSize - 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1357,11 +1423,22 @@ void NVLoadStateExt(struct nvidia_par *p
 
 			if ((par->Architecture < NV_ARCH_40) ||
 			    ((par->Chipset & 0xfff0) == 0x0040)) {
-				for (i = 0; i < 32; i++) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					for (i = 0; i < 32; i++) {
 					NV_WR32(par->PGRAPH, 0x0900 + i*4,
 						NV_RD32(par->PFB, 0x0240 +i*4));
 					NV_WR32(par->PGRAPH, 0x6900 + i*4,
 						NV_RD32(par->PFB, 0x0240 +i*4));
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 				}
 			} else {
 				if (((par->Chipset & 0xfff0) == 0x0090) ||
@@ -1369,7 +1446,12 @@ void NVLoadStateExt(struct nvidia_par *p
 				    ((par->Chipset & 0xfff0) == 0x0290) ||
 				    ((par->Chipset & 0xfff0) == 0x0390) ||
 				    ((par->Chipset & 0xfff0) == 0x03D0)) {
-					for (i = 0; i < 60; i++) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+						for (i = 0; i < 60; i++) {
 						NV_WR32(par->PGRAPH,
 							0x0D00 + i*4,
 							NV_RD32(par->PFB,
@@ -1378,9 +1460,20 @@ void NVLoadStateExt(struct nvidia_par *p
 							0x6900 + i*4,
 							NV_RD32(par->PFB,
 								0x0600 + i*4));
+						if (_cur < timeout) {
+						rdstcll(_cur);
+						}
+						else {
+						break;
+						}
 					}
 				} else {
-					for (i = 0; i < 48; i++) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+						for (i = 0; i < 48; i++) {
 						NV_WR32(par->PGRAPH,
 							0x0900 + i*4,
 							NV_RD32(par->PFB,
@@ -1395,6 +1488,12 @@ void NVLoadStateExt(struct nvidia_par *p
 								0x6900 + i*4,
 								NV_RD32(par->PFB,
 									0x0600 + i*4));
+							if (_cur < timeout) {
+						rdstcll(_cur);
+							}
+							else {
+						break;
+							}
 					}
 				}
 			}
diff -u -p a/video/nvidia/nv_i2c.c b/video/nvidia/nv_i2c.c
--- a/video/nvidia/nv_i2c.c
+++ b/video/nvidia/nv_i2c.c
@@ -141,11 +141,22 @@ void nvidia_delete_i2c_busses(struct nvi
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		if (!par->chan[i].par)
 			continue;
 		i2c_del_adapter(&par->chan[i].adapter);
 		par->chan[i].par = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/i810/i810_gtf.c b/video/i810/i810_gtf.c
--- a/video/i810/i810_gtf.c
+++ b/video/i810/i810_gtf.c
@@ -261,7 +261,12 @@ u32 i810_get_watermark(const struct fb_v
 
 	pixclock = 1000000/var->pixclock;
 	min = ~0;
-	for (i = 0; i < size; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < size; i++) {
 		if (pixclock <= wmark[i].freq) 
 			diff = wmark[i].freq - pixclock;
 		else 
@@ -270,6 +275,12 @@ u32 i810_get_watermark(const struct fb_v
 			wm_best = wmark[i].wm;
 			min = diff;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return wm_best;		
 }	
diff -u -p a/video/i810/i810_dvt.c b/video/i810/i810_dvt.c
--- a/video/i810/i810_dvt.c
+++ b/video/i810/i810_dvt.c
@@ -217,6 +217,11 @@ static int i810fb_find_best_mode(u32 xre
 	u32 diff = 0, diff_best = 0xFFFFFFFF, i = 0, i_best = 0; 
 	u8 hfl = (u8) ((xres >> 3) - 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(std_modes); i++) { 
 		if (std_modes[i].cr01 == hfl) { 
 			if (std_modes[i].pixclock <= pixclock)
@@ -226,6 +231,12 @@ static int i810fb_find_best_mode(u32 xre
 		    		diff_best = diff;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return i_best;
 }
diff -u -p a/video/i810/i810_main.c b/video/i810/i810_main.c
--- a/video/i810/i810_main.c
+++ b/video/i810/i810_main.c
@@ -494,9 +494,20 @@ static void i810_restore_vgax(struct i81
 	u8 i, j;
 	u8 __iomem *mmio = par->mmio_start_virtual;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		i810_writeb(CR_INDEX_CGA, mmio, CR30+i);
 		i810_writeb(CR_DATA_CGA, mmio, *(&(par->hw_state.cr30) + i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	i810_writeb(CR_INDEX_CGA, mmio, CR35);
 	i810_writeb(CR_DATA_CGA, mmio, par->hw_state.cr35);
@@ -528,13 +539,35 @@ static void i810_restore_vga(struct i810
 	u8 i;
 	u8 __iomem *mmio = par->mmio_start_virtual;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10; i++) {
 		i810_writeb(CR_INDEX_CGA, mmio, CR00 + i);
 		i810_writeb(CR_DATA_CGA, mmio, *((&par->hw_state.cr00) + i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		i810_writeb(CR_INDEX_CGA, mmio, CR10 + i);
 		i810_writeb(CR_DATA_CGA, mmio, *((&par->hw_state.cr10) + i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -609,9 +642,20 @@ static void i810_save_vgax(struct i810fb
 	u8 i;
 	u8 __iomem *mmio = par->mmio_start_virtual;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		i810_writeb(CR_INDEX_CGA, mmio, CR30 + i);
 		*(&(par->hw_state.cr30) + i) = i810_readb(CR_DATA_CGA, mmio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	i810_writeb(CR_INDEX_CGA, mmio, CR35);
 	par->hw_state.cr35 = i810_readb(CR_DATA_CGA, mmio);
@@ -633,13 +677,35 @@ static void i810_save_vga(struct i810fb_
 	u8 i;
 	u8 __iomem *mmio = par->mmio_start_virtual;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10; i++) {
 		i810_writeb(CR_INDEX_CGA, mmio, CR00 + i);
 		*((&par->hw_state.cr00) + i) = i810_readb(CR_DATA_CGA, mmio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		i810_writeb(CR_INDEX_CGA, mmio, CR10 + i);
 		*((&par->hw_state.cr10) + i) = i810_readb(CR_DATA_CGA, mmio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -785,9 +851,20 @@ static void i810_reset_cursor_image(stru
 	int i, j;
 
 	for (i = 64; i--; ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 8; j++) {             
 			i810_writeb(j, addr, 0xff);   
 			i810_writeb(j+8, addr, 0x00); 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}	
 		addr +=16;
 	}
@@ -803,9 +880,20 @@ static void i810_load_cursor_image(int w
 	t_mask = 0xff >> mod;
 	d_mask = ~(0xff >> mod); 
 	for (i = height; i--; ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < w; j++) {
 			i810_writeb(j+0, addr, 0x00);
 			i810_writeb(j+8, addr, *data++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (mod) {
 			i810_writeb(j+0, addr, t_mask);
diff -u -p a/video/metronomefb.c b/video/metronomefb.c
--- a/video/metronomefb.c
+++ b/video/metronomefb.c
@@ -210,11 +210,22 @@ static int __devinit load_waveform(u8 *m
 	}
 	wfm_hdr->mc += 1;
 	wfm_hdr->trc += 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 5; i++) {
 		if (*(wfm_hdr->stuff2a + i) != 0) {
 			dev_err(dev, "Error: unexpected value in padding\n");
 			return -EINVAL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* calculating trn. trn is something used to index into
@@ -348,9 +359,20 @@ static int __devinit metronome_powerup_c
 	cs = par->metromem_cmd->opcode;
 
 	/* set pwr1,2,3 to 1024 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		par->metromem_cmd->args[i] = 1024;
 		cs += par->metromem_cmd->args[i];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* the rest are 0 */
@@ -455,9 +477,20 @@ static u16 metronomefb_dpy_update_page(s
 	u16 *img = (u16 *)(par->metromem_img + index);
 
 	/* swizzle from vm to metromem and recalc cksum at the same time*/
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < PAGE_SIZE/2; i++) {
 		*(img + i) = (buf[i] << 5) & 0xE0E0;
 		csum += *(img + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return csum;
 }
diff -u -p a/video/hgafb.c b/video/hgafb.c
--- a/video/hgafb.c
+++ b/video/hgafb.c
@@ -322,9 +322,20 @@ static int __devinit hga_card_detect(voi
 	
 	p_save = q_save = inb_p(HGA_STATUS_PORT) & HGA_STATUS_VSYNC;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count=0; count < 50000 && p_save == q_save; count++) {
 		q_save = inb(HGA_STATUS_PORT) & HGA_STATUS_VSYNC;
 		udelay(2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (p_save == q_save) 
@@ -461,6 +472,11 @@ static void hgafb_fillrect(struct fb_inf
 
 	y = rect->dy;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rows = rect->height; rows--; y++) {
 		dest = rowaddr(info, y) + (rect->dx >> 3);
 		switch (rect->rop) {
@@ -471,6 +487,12 @@ static void hgafb_fillrect(struct fb_inf
 			fb_writeb(~(fb_readb(dest)), dest);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -513,11 +535,33 @@ static void hgafb_imageblit(struct fb_in
 	u_int x;
 	u8 d;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rows = image->height; rows--; y++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < image->width; x+= 8) {
 			d = *cdat++;
 			dest = rowaddr(info, y) + ((image->dx + x)>> 3);
 			fb_writeb(d, dest);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
diff -u -p a/video/macmodes.c b/video/macmodes.c
--- a/video/macmodes.c
+++ b/video/macmodes.c
@@ -318,6 +318,11 @@ int mac_var_to_vmode(const struct fb_var
      * Find the mac_mode with a matching resolution or failing that, the
      * closest larger resolution. Skip modes with a shorter pixel clock period.
      */
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (map = mac_modes; map->vmode != -1; map++) {
 	const struct fb_videomode *mode = map->mode;
 
@@ -349,6 +354,12 @@ int mac_var_to_vmode(const struct fb_var
 	    map++;
 	}
 	return 0;
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
     return -EINVAL;
 }
diff -u -p a/video/amifb.c b/video/amifb.c
--- a/video/amifb.c
+++ b/video/amifb.c
@@ -2348,12 +2348,23 @@ default_chipset:
 	 * Replace the Tag Values with the Real Pixel Clock Values
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_TOTAL_MODES; i++) {
 		struct fb_videomode *mode = &ami_modedb[i];
 		tag = mode->pixclock;
 		if (tag == TAG_SHRES || tag == TAG_HIRES || tag == TAG_LORES) {
 			mode->pixclock = pixclock[tag];
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+	    }
 	}
 
 	/*
@@ -3350,8 +3361,18 @@ static int ami_get_var_cursorinfo(struct
 		sspr = shfsprite + (delta<<1);
 	else
 		sspr = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (height = (short)var->height-1; height >= 0; height--) {
 		bits = 0; words = delta; datawords = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (width = (short)var->width-1; width >= 0; width--) {
 			if (bits == 0) {
 				bits = 16; --words;
@@ -3374,6 +3395,12 @@ static int ami_get_var_cursorinfo(struct
 			datawords <<= 1;
 #endif
 			put_user(color, data++);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if (bits > 0) {
 			--words; ++lspr;
@@ -3391,6 +3418,12 @@ static int ami_get_var_cursorinfo(struct
 			sspr = tmp;
 		}
 #endif
+if (_cur < timeout) {
+		rdstcll(_cur);
+}
+else {
+		break;
+}
 	}
 	return 0;
 }
@@ -3439,9 +3472,19 @@ static int ami_set_var_cursorinfo(struct
 		memset(lspr, 0, (var->height+2)<<fmode<<2);
 		sspr = NULL;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (height = (short)var->height-1; height >= 0; height--) {
 		bits = 16; words = delta; datawords = 0;
-		for (width = (short)var->width-1; width >= 0; width--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+for (width = (short)var->width-1; width >= 0; width--) {
 			unsigned long tdata = 0;
 			get_user(tdata, data);
 			data++;
@@ -3466,6 +3509,12 @@ static int ami_set_var_cursorinfo(struct
 				*lspr++ = (u_short) (datawords & 0xffff);
 #endif
 			}
+			if (_cur < timeout) {
+rdstcll(_cur);
+			}
+			else {
+break;
+			}
 		}
 		if (bits < 16) {
 			--words;
@@ -3499,6 +3548,12 @@ static int ami_set_var_cursorinfo(struct
 			sspr = tmp;
 		}
 #endif
+if (_cur < timeout) {
+		rdstcll(_cur);
+}
+else {
+		break;
+}
 	}
 	par->crsr.height = var->height;
 	par->crsr.width = var->width;
@@ -3603,10 +3658,21 @@ static void __init ami_init_copper(void)
 	} else
 		(cop++)->l = CMOVE(BPC0_COLOR, bplcon0);
 	p = ZTWO_PADDR(dummysprite);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		(cop++)->l = CMOVE(0, spr[i].pos);
 		(cop++)->l = CMOVE(highw(p), sprpt[i]);
 		(cop++)->l = CMOVE2(loww(p), sprpt[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	(cop++)->l = CMOVE(IF_SETCLR | IF_COPER, intreq);
@@ -3729,9 +3795,20 @@ static void ami_rebuild_copper(void)
 	if (par->vmode & FB_VMODE_YWRAP) {
 		if ((par->vyres-par->yoffset) != 1 || !mod2(par->diwstrt_v)) {
 			if (par->yoffset > par->vyres-par->yres) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {
 					(copl++)->l = CMOVE(highw(p), bplpt[i]);
 					(copl++)->l = CMOVE2(loww(p), bplpt[i]);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				line = par->diwstrt_v + ((par->vyres-par->yoffset)<<par->line_shift) - 1;
 				while (line >= 512) {
@@ -3746,9 +3823,20 @@ static void ami_rebuild_copper(void)
 			}
 		} else p = par->bplpt0wrap;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {
 		(copl++)->l = CMOVE(highw(p), bplpt[i]);
 		(copl++)->l = CMOVE2(loww(p), bplpt[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	copl->l = CEND;
 
@@ -3762,9 +3850,20 @@ static void ami_rebuild_copper(void)
 		if (par->vmode & FB_VMODE_YWRAP) {
 			if ((par->vyres-par->yoffset) != 1 || mod2(par->diwstrt_v)) {
 				if (par->yoffset > par->vyres-par->yres+1) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					for (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {
 						(cops++)->l = CMOVE(highw(p), bplpt[i]);
 						(cops++)->l = CMOVE2(loww(p), bplpt[i]);
+						if (_cur < timeout) {
+					rdstcll(_cur);
+						}
+						else {
+					break;
+						}
 					}
 					line = par->diwstrt_v + ((par->vyres-par->yoffset)<<par->line_shift) - 2;
 					while (line >= 512) {
@@ -3783,9 +3882,20 @@ static void ami_rebuild_copper(void)
 				}
 			} else p = par->bplpt0wrap - par->next_line;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {
 			(cops++)->l = CMOVE(highw(p), bplpt[i]);
 			(cops++)->l = CMOVE2(loww(p), bplpt[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		cops->l = CEND;
 	}
diff -u -p a/video/savage/savagefb_driver.c b/video/savage/savagefb_driver.c
--- a/video/savage/savagefb_driver.c
+++ b/video/savage/savagefb_driver.c
@@ -438,8 +438,18 @@ static void SavageCalcClock(long freq, i
 	/* work out suitable timings */
 	best_diff = freq;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n2=min_n2; n2<=max_n2; n2++) {
-		for (n1=min_n1+2; n1<=max_n1+2; n1++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (n1=min_n1+2; n1<=max_n1+2; n1++) {
 			m = (freq * n1 * (1 << n2) + HALF_BASE_FREQ) /
 				BASE_FREQ;
 			if (m < min_m+2 || m > 127+2)
@@ -456,6 +466,18 @@ static void SavageCalcClock(long freq, i
 					best_n2 = n2;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -476,8 +498,18 @@ static int common_calc_clock(long freq,
 
 	best_diff = freq;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n2 = min_n2; n2 <= max_n2; n2++) {
-		for (n1 = min_n1+2; n1 <= max_n1+2; n1++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (n1 = min_n1+2; n1 <= max_n1+2; n1++) {
 			m = (freq * n1 * (1 << n2) + HALF_BASE_FREQ) /
 				BASE_FREQ;
 			if (m < min_m + 2 || m > 127+2)
@@ -494,6 +526,18 @@ static int common_calc_clock(long freq,
 					best_n2 = n2;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -519,21 +563,43 @@ static void SavagePrintRegs(struct savag
 	printk(KERN_DEBUG "SR    x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE "
 	       "xF");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 0x70; i++) {
 		if (!(i % 16))
 			printk(KERN_DEBUG "\nSR%xx ", i >> 4);
 		vga_out8(0x3c4, i, par);
 		printk(KERN_DEBUG " %02x", vga_in8(0x3c5, par));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_DEBUG "\n\nCR    x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC "
 	       "xD xE xF");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 0xB7; i++) {
 		if (!(i % 16))
 			printk(KERN_DEBUG "\nCR%xx ", i >> 4);
 		vga_out8(vgaCRIndex, i, par);
 		printk(KERN_DEBUG " %02x", vga_in8(vgaCRReg, par));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_DEBUG "\n\n");
@@ -667,9 +733,20 @@ static void savage_get_default_par(struc
 	if (par->chip == S3_SAVAGE_MX) {
 		int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 8; i++) {
 			vga_out8(0x3c4, 0x54+i, par);
 			reg->SR54[i] = vga_in8(0x3c5, par);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -820,9 +897,20 @@ static void savage_set_default_par(struc
 	if (par->chip == S3_SAVAGE_MX) {
 		int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 8; i++) {
 			vga_out8(0x3c4, 0x54+i, par);
 			vga_out8(0x3c5, reg->SR54[i], par);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1323,9 +1411,20 @@ static void savagefb_set_par_int(struct
 	if (par->chip == S3_SAVAGE_MX) {
 		int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 8; i++) {
 			vga_out8(0x3c4, 0x54+i, par);
 			vga_out8(0x3c5, reg->SR54[i], par);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/video/fb_defio.c b/video/fb_defio.c
--- a/video/fb_defio.c
+++ b/video/fb_defio.c
@@ -226,9 +226,20 @@ void fb_deferred_io_cleanup(struct fb_in
 	cancel_delayed_work_sync(&info->deferred_work);
 
 	/* clear out the mapping that we setup */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0 ; i < info->fix.smem_len; i += PAGE_SIZE) {
 		page = fb_deferred_io_page(info, i);
 		page->mapping = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	info->fbops->fb_mmap = NULL;
diff -u -p a/video/geode/lxfb_ops.c b/video/geode/lxfb_ops.c
--- a/video/geode/lxfb_ops.c
+++ b/video/geode/lxfb_ops.c
@@ -170,12 +170,23 @@ static void lx_set_clock(struct fb_info
 
 	min = abs(pll_table[0].freq - freq);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(pll_table); i++) {
 		diff = abs(pll_table[i].freq - freq);
 		if (diff < min) {
 			min = diff;
 			best = i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lx_set_dotpll(pll_table[best].pllval & 0x00017FFF);
@@ -622,17 +633,39 @@ static void lx_save_regs(struct lxfb_par
 
 	/* save the horizontal filter coefficients */
 	filt = par->dc[DC_IRQ_FILT_CTL] | DC_IRQ_FILT_CTL_H_FILT_SEL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->hcoeff); i += 2) {
 		write_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);
 		par->hcoeff[i] = read_dc(par, DC_FILT_COEFF1);
 		par->hcoeff[i + 1] = read_dc(par, DC_FILT_COEFF2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* save the vertical filter coefficients */
 	filt &= ~DC_IRQ_FILT_CTL_H_FILT_SEL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->vcoeff); i++) {
 		write_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);
 		par->vcoeff[i] = read_dc(par, DC_FILT_COEFF1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* save video coeff ram */
@@ -646,6 +679,11 @@ static void lx_restore_gfx_proc(struct l
 	/* a bunch of registers require GP_RASTER_MODE to be set first */
 	write_gp(par, GP_RASTER_MODE, par->gp[GP_RASTER_MODE]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->gp); i++) {
 		switch (i) {
 		case GP_RASTER_MODE:
@@ -662,6 +700,12 @@ static void lx_restore_gfx_proc(struct l
 		default:
 			write_gp(par, i, par->gp[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -672,6 +716,11 @@ static void lx_restore_display_ctlr(stru
 
 	wrmsrl(MSR_LX_SPARE_MSR, par->msr.dcspare);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->dc); i++) {
 		switch (i) {
 		case DC_UNLOCK:
@@ -707,6 +756,12 @@ static void lx_restore_display_ctlr(stru
 		default:
 			write_dc(par, i, par->dc[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* restore the palette */
@@ -716,17 +771,39 @@ static void lx_restore_display_ctlr(stru
 
 	/* restore the horizontal filter coefficients */
 	filt = par->dc[DC_IRQ_FILT_CTL] | DC_IRQ_FILT_CTL_H_FILT_SEL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->hcoeff); i += 2) {
 		write_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);
 		write_dc(par, DC_FILT_COEFF1, par->hcoeff[i]);
 		write_dc(par, DC_FILT_COEFF2, par->hcoeff[i + 1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* restore the vertical filter coefficients */
 	filt &= ~DC_IRQ_FILT_CTL_H_FILT_SEL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->vcoeff); i++) {
 		write_dc(par, DC_IRQ_FILT_CTL, (filt & 0xffffff00) | i);
 		write_dc(par, DC_FILT_COEFF1, par->vcoeff[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -737,6 +814,11 @@ static void lx_restore_video_proc(struct
 	wrmsrl(MSR_LX_GLD_MSR_CONFIG, par->msr.dfglcfg);
 	wrmsrl(MSR_LX_MSR_PADSEL, par->msr.padsel);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->vp); i++) {
 		switch (i) {
 		case VP_VCFG:
@@ -754,6 +836,12 @@ static void lx_restore_video_proc(struct
 		default:
 			write_vp(par, i, par->vp[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* restore video processor palette */
@@ -775,6 +863,11 @@ static void lx_restore_regs(struct lxfb_
 	lx_restore_video_proc(par);
 
 	/* Flat Panel */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->fp); i++) {
 		switch (i) {
 		case FP_PM:
@@ -789,6 +882,12 @@ static void lx_restore_regs(struct lxfb_
 		default:
 			write_fp(par, i, par->fp[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* control the panel */
diff -u -p a/video/geode/display_gx1.c b/video/geode/display_gx1.c
--- a/video/geode/display_gx1.c
+++ b/video/geode/display_gx1.c
@@ -65,10 +65,21 @@ int gx1_frame_buffer_size(void)
 	/* Calculate the total size of both DIMM0 and DIMM1. */
 	bank_cfg = readl(mc_regs + MC_BANK_CFG);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (d = 0; d < 2; d++) {
 		if ((bank_cfg & MC_BCFG_DIMM0_PG_SZ_MASK) != MC_BCFG_DIMM0_PG_SZ_NO_DIMM)
 			dram_size += 0x400000 << ((bank_cfg & MC_BCFG_DIMM0_SZ_MASK) >> 8);
 		bank_cfg >>= 16; /* look at DIMM1 next */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	fb_base = (readl(mc_regs + MC_GBASE_ADD) & MC_GADD_GBADD_MASK) << 19;
diff -u -p a/video/geode/suspend_gx.c b/video/geode/suspend_gx.c
--- a/video/geode/suspend_gx.c
+++ b/video/geode/suspend_gx.c
@@ -71,6 +71,11 @@ static void gx_restore_gfx_proc(struct g
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->gp); i++) {
 		switch (i) {
 		case GP_VECTOR_MODE:
@@ -82,6 +87,12 @@ static void gx_restore_gfx_proc(struct g
 		default:
 			write_gp(par, i, par->gp[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -89,6 +100,11 @@ static void gx_restore_display_ctlr(stru
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->dc); i++) {
 		switch (i) {
 		case DC_UNLOCK:
@@ -127,6 +143,12 @@ static void gx_restore_display_ctlr(stru
 		default:
 			write_dc(par, i, par->dc[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* restore the palette */
@@ -141,6 +163,11 @@ static void gx_restore_video_proc(struct
 
 	wrmsrl(MSR_GX_MSR_PADSEL, par->msr.padsel);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->vp); i++) {
 		switch (i) {
 		case VP_VCFG:
@@ -169,6 +196,12 @@ static void gx_restore_video_proc(struct
 		default:
 			write_vp(par, i, par->vp[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -182,9 +215,20 @@ static void gx_restore_regs(struct gxfb_
 	gx_restore_video_proc(par);
 
 	/* Flat Panel */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(par->fp); i++) {
 		if (i != FP_PM && i != FP_RSVD_0)
 			write_fp(par, i, par->fp[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/video/geode/video_gx.c b/video/geode/video_gx.c
--- a/video/geode/video_gx.c
+++ b/video/geode/video_gx.c
@@ -138,12 +138,23 @@ void gx_set_dclk_frequency(struct fb_inf
 	/* Search the table for the closest pixclock. */
 	best_i = 0;
 	min = abs(pll_table[0].pixclock - info->var.pixclock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < pll_table_len; i++) {
 		diff = abs(pll_table[i].pixclock - info->var.pixclock);
 		if (diff < min) {
 			min = diff;
 			best_i = i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rdmsrl(MSR_GLCP_SYS_RSTPLL, sys_rstpll);
diff -u -p a/video/geode/video_cs5530.c b/video/geode/video_cs5530.c
--- a/video/geode/video_cs5530.c
+++ b/video/geode/video_cs5530.c
@@ -80,6 +80,11 @@ static void cs5530_set_dclk_frequency(st
 	value = cs5530_pll_table[0].pll_value;
 	min = cs5530_pll_table[0].pixclock - info->var.pixclock;
 	if (min < 0) min = -min;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < ARRAY_SIZE(cs5530_pll_table); i++) {
 		diff = cs5530_pll_table[i].pixclock - info->var.pixclock;
 		if (diff < 0L) diff = -diff;
@@ -87,6 +92,12 @@ static void cs5530_set_dclk_frequency(st
 			min = diff;
 			value = cs5530_pll_table[i].pll_value;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	writel(value, par->vid_regs + CS5530_DOT_CLK_CONFIG);
diff -u -p a/video/sstfb.c b/video/sstfb.c
--- a/video/sstfb.c
+++ b/video/sstfb.c
@@ -870,6 +870,11 @@ static int __devinit sst_detect_att(stru
 	struct sstfb_par *par = info->par;
 	int i, mir, dir;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		sst_dac_write(DACREG_WMA, 0); 	/* backdoor */
 		sst_dac_read(DACREG_RMR);	/* read 4 times RMR */
@@ -886,6 +891,12 @@ static int __devinit sst_detect_att(stru
 		if (mir == DACREG_MIR_ATT && dir == DACREG_DIR_ATT) {
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -895,6 +906,11 @@ static int __devinit sst_detect_ti(struc
 	struct sstfb_par *par = info->par;
 	int i, mir, dir;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i<3; i++) {
 		sst_dac_write(DACREG_WMA, 0); 	/* backdoor */
 		sst_dac_read(DACREG_RMR);	/* read 4 times RMR */
@@ -911,6 +927,12 @@ static int __devinit sst_detect_ti(struc
 		if ((mir == DACREG_MIR_TI ) && (dir == DACREG_DIR_TI)) {
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -933,6 +955,11 @@ static int __devinit sst_detect_ics(stru
 	int n_clk0_1, n_clk0_7, n_clk1_b;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i<5; i++ ) {
 		sst_dac_write(DACREG_ICS_PLLRMA, 0x1);	/* f1 */
 		m_clk0_1 = sst_dac_read(DACREG_ICS_PLLDATA);
@@ -952,6 +979,12 @@ static int __devinit sst_detect_ics(stru
 		    && (m_clk1_b == DACREG_ICS_PLL_CLK1_B_INI)) {
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/video/dnfb.c b/video/dnfb.c
--- a/video/dnfb.c
+++ b/video/dnfb.c
@@ -183,6 +183,11 @@ void dnfb_copyarea(struct fb_info *info,
 			pre_read = 1;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < area->height; i++) {
 
 		out_8(AP_CONTROL_3A, 0xc | (dest >> 16));
@@ -199,10 +204,21 @@ void dnfb_copyarea(struct fb_info *info,
 			dest += incr;
 			out_8(AP_WRITE_ENABLE, 0);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 1; j < (x_word_count - 1); j++) {
 				*src = dest;
 				src += incr;
 				dest += incr;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			out_8(AP_WRITE_ENABLE, start_mask);
@@ -217,6 +233,12 @@ void dnfb_copyarea(struct fb_info *info,
 		}
 		src += (y_delta / 16);
 		dest += (y_delta / 16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	out_8(AP_CONTROL_0, NORMAL_MODE);
 }
diff -u -p a/video/intelfb/intelfb_i2c.c b/video/intelfb/intelfb_i2c.c
--- a/video/intelfb/intelfb_i2c.c
+++ b/video/intelfb/intelfb_i2c.c
@@ -196,6 +196,11 @@ void intelfb_delete_i2c_busses(struct in
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_OUTPUTS; i++) {
 		if (dinfo->output[i].i2c_bus.dinfo) {
 			i2c_del_adapter(&dinfo->output[i].i2c_bus.adapter);
@@ -205,5 +210,11 @@ void intelfb_delete_i2c_busses(struct in
 			i2c_del_adapter(&dinfo->output[i].ddc_bus.adapter);
 			dinfo->output[i].ddc_bus.dinfo = NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
diff -u -p a/video/intelfb/intelfbhw.c b/video/intelfb/intelfbhw.c
--- a/video/intelfb/intelfbhw.c
+++ b/video/intelfb/intelfbhw.c
@@ -597,9 +597,20 @@ int intelfbhw_read_hw_state(struct intel
 	if (flag == 6)
 		return flag;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		hw->cursor_a_palette[i] = INREG(CURSOR_A_PALETTE0 + (i << 2));
 		hw->cursor_b_palette[i] = INREG(CURSOR_B_PALETTE0 + (i << 2));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (flag == 7)
@@ -630,11 +641,22 @@ int intelfbhw_read_hw_state(struct intel
 	if (flag == 11)
 		return flag;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 7; i++) {
 		hw->swf0x[i] = INREG(SWF00 + (i << 2));
 		hw->swf1x[i] = INREG(SWF10 + (i << 2));
 		if (i < 3)
 			hw->swf3x[i] = INREG(SWF30 + (i << 2));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i < 8; i++)
@@ -817,17 +839,39 @@ void intelfbhw_print_hw_state(struct int
 	printk("	CURSOR_B_BASEADDR:	0x%08x\n", hw->cursor_b_base);
 
 	printk("	CURSOR_A_PALETTE:	");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		printk("0x%08x", hw->cursor_a_palette[i]);
 		if (i < 3)
 			printk(", ");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	printk("\n");
 	printk("	CURSOR_B_PALETTE:	");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		printk("0x%08x", hw->cursor_b_palette[i]);
 		if (i < 3)
 			printk(", ");
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 	}
 	printk("\n");
 
@@ -843,17 +887,50 @@ void intelfbhw_print_hw_state(struct int
 	printk("	VGACNTRL:		0x%08x\n", hw->vgacntrl);
 	printk("	ADD_ID:			0x%08x\n", hw->add_id);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 7; i++) {
 		printk("	SWF0%d			0x%08x\n", i,
 			hw->swf0x[i]);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 7; i++) {
 		printk("	SWF1%d			0x%08x\n", i,
 			hw->swf1x[i]);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		printk("	SWF3%d			0x%08x\n", i,
 		       hw->swf3x[i]);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	for (i = 0; i < 8; i++)
 		printk("	FENCE%d			0x%08x\n", i,
@@ -883,7 +960,17 @@ static int splitm(int index, unsigned in
 	struct pll_min_max *pll = &plls[index];
 
 	/* no point optimising too much - brute force m */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m1 = pll->min_m1; m1 < pll->max_m1 + 1; m1++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (m2 = pll->min_m2; m2 < pll->max_m2 + 1; m2++) {
 			testm = (5 * (m1 + 2)) + (m2 + 2);
 			if (testm == m) {
@@ -891,6 +978,18 @@ static int splitm(int index, unsigned in
 				*retm2 = (unsigned int)m2;
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 	return 1;
@@ -976,6 +1075,11 @@ static int calc_pll_params(int index, in
 				m = pll->min_m + 1;
 			if (m > pll->max_m)
 				m = pll->max_m - 1;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (testm = m - 1; testm <= m; testm++) {
 				f_out = calc_vclock3(index, testm, n, p);
 				if (splitm(index, testm, &m1, &m2)) {
@@ -995,6 +1099,12 @@ static int calc_pll_params(int index, in
 					f_best = f_out;
 					err_best = f_err;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			n++;
 		} while ((n <= pll->max_n) && (f_out >= clock));
@@ -1817,15 +1927,37 @@ int intelfbhw_do_drawglyph(struct intelf
 	iw = ROUND_UP_TO(w, 8) / 8;
 	while (ndwords--) {
 		dat = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 2; ++j) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 2; ++i) {
 				if (ix != iw || i == 0)
 					dat |= cdat[iy*iw + ix++] << (i+j*2)*8;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			if (ix == iw && iy != (h-1)) {
 				ix = 0;
 				++iy;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		OUT_RING(dat);
 	}
@@ -1973,9 +2105,20 @@ void intelfbhw_cursor_load(struct intelf
 	t_mask = 0xff >> mod;
 	d_mask = ~(0xff >> mod);
 	for (i = height; i--; ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < w; j++) {
 			writeb(0x00, addr + j);
 			writeb(*(data++), addr + j+8);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (mod) {
 			writeb(t_mask, addr + j);
@@ -1998,9 +2141,20 @@ void intelfbhw_cursor_reset(struct intel
 		return;
 
 	for (i = 64; i--; ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 8; j++) {
 			writeb(0xff, addr + j+0);
 			writeb(0x00, addr + j+8);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		addr += 16;
 	}
diff -u -p a/video/tdfxfb.c b/video/tdfxfb.c
--- a/video/tdfxfb.c
+++ b/video/tdfxfb.c
@@ -313,7 +313,17 @@ static u32 do_calc_pll(int freq, int *fr
 	best_error = freq;
 	best_n = best_m = best_k = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 3; k >= 0; k--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (m = 63; m >= 0; m--) {
 			/*
 			 * Estimate value of n that produces target frequency
@@ -322,6 +332,11 @@ static u32 do_calc_pll(int freq, int *fr
 			int n_estimated = ((freq * (m + 2) << k) / fref) - 2;
 
 			/* Search neighborhood of estimated n */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (n = max(0, n_estimated);
 				n <= min(255, n_estimated + 1);
 				n++) {
@@ -342,7 +357,25 @@ static u32 do_calc_pll(int freq, int *fr
 					best_m = m;
 					best_k = k;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
 			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -1028,6 +1061,11 @@ static void tdfxfb_imageblit(struct fb_i
 	fifo_free = 0;
 
 	/* Send four bytes at a time of data */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = (size >> 2); i > 0; i--) {
 		if (--fifo_free < 0) {
 			fifo_free = 31;
@@ -1035,6 +1073,12 @@ static void tdfxfb_imageblit(struct fb_i
 		}
 		tdfx_outl(par, LAUNCH_2D, *(u32 *)chardata);
 		chardata += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+	}
 	}
 
 	/* Send the leftovers now */
@@ -1137,6 +1181,11 @@ static int tdfxfb_cursor(struct fb_info
 
 		fb_memset(cursorbase, 0, 1024);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < cursor->image.height; i++) {
 			int h = 0;
 			int j = (cursor->image.width + 7) >> 3;
@@ -1154,6 +1203,12 @@ static int tdfxfb_cursor(struct fb_info
 				h++;
 			}
 			cursorbase += 16;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 0;
diff -u -p a/video/controlfb.c b/video/controlfb.c
--- a/video/controlfb.c
+++ b/video/controlfb.c
@@ -395,11 +395,22 @@ static void set_control_clock(unsigned c
 	struct adb_request req;
 	int i;
 
-	for (i = 0; i < 3; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 3; ++i) {
 		cuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC,
 			     0x50, i + 1, params[i]);
 		while (!req.complete)
 			cuda_poll();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 #endif	
 }
@@ -808,6 +819,11 @@ static int calc_clock_params(unsigned lo
 	l = clk << p2;
 	p0 = 0;
 	p1 = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 1, min = l; k < 32; k++) {
 		unsigned long rem;
 
@@ -819,6 +835,12 @@ static int calc_clock_params(unsigned lo
 			p1 = n;
 			min = rem;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!p0 || !p1)
 		return 1;
diff -u -p a/video/riva/riva_hw.c b/video/riva/riva_hw.c
--- a/video/riva/riva_hw.c
+++ b/video/riva/riva_hw.c
@@ -536,10 +536,25 @@ static char nv3_get_param(nv3_fifo_info
     int done, g,v, p;
     
     done = 0;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (p=0; p < 2; p++)
     {
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for (g=128 ; g > 32; g= g>> 1)
         {
+            unsigned long long delta = (cpu / khz / HZ) * 2;
+            unsigned long long _start = 0;
+            unsigned long long _cur = 0;
+            unsigned long long timeout;
+            timeout = rdstcll(start) + delta;
             for (v=128; v >=32; v = v>> 1)
             {
                 ainfo->priority = p;
@@ -551,7 +566,25 @@ static char nv3_get_param(nv3_fifo_info
                         done = 0;
                 if (done)
                     goto Done;
+                    if (_cur < timeout) {
+                        rdstcll(_cur);
+                    }
+                    else {
+                        break;
+                    }
             }
+            if (_cur < timeout) {
+                    rdstcll(_cur);
+            }
+            else {
+                    break;
+            }
+        }
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
         }
     }
 
@@ -1197,11 +1230,21 @@ static int CalcVClock
     }                      
 
     highP = 4 - (chip->Architecture == NV_ARCH_03);
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (P = 0; P <= highP; P ++)
     {
         Freq = VClk << P;
         if ((Freq >= 128000) && (Freq <= chip->MaxVClockFreqKHz))
         {
+            unsigned long long delta = (cpu / khz / HZ) * 2;
+            unsigned long long _start = 0;
+            unsigned long long _cur = 0;
+            unsigned long long timeout;
+            timeout = rdstcll(start) + delta;
             for (M = lowM; M <= highM; M++)
             {
                 N    = (VClk << P) * M / chip->CrystalFreqKHz;
@@ -1220,8 +1263,20 @@ static int CalcVClock
                     DeltaOld  = DeltaNew;
                 }
             }
+            if (_cur < timeout) {
+                rdstcll(_cur);
+            }
+            else {
+                break;
+            }
         }
     }
+    if (_cur < timeout) {
+        rdstcll(_cur);
+    }
+    else {
+        break;
+    }
     }
 
     /* non-zero: M/N/P/clock values assigned.  zero: error (not set) */
diff -u -p a/video/riva/fbdev.c b/video/riva/fbdev.c
--- a/video/riva/fbdev.c
+++ b/video/riva/fbdev.c
@@ -510,11 +510,21 @@ static void rivafb_load_cursor_image(str
 
 	w = (w + 1) & ~1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < h; i++) {
 		b = *data++;
 		reverse_order(&b);
 		
-		for (j = 0; j < w/2; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (j = 0; j < w/2; j++) {
 			tmp = 0;
 #if defined (__BIG_ENDIAN)
 			tmp = (b & (1 << 31)) ? fg << 16 : bg << 16;
@@ -528,8 +538,20 @@ static void rivafb_load_cursor_image(str
 			b >>= 1;
 #endif
 			writel(tmp, &par->riva.CURSOR[k++]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		k += (MAX_CURS - w)/2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -653,7 +675,12 @@ static void riva_load_state(struct riva_
 
 	MISCout(par, regs->misc_output);
 
-	for (i = 0; i < NUM_CRT_REGS; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < NUM_CRT_REGS; i++) {
 		switch (i) {
 		case 0x19:
 		case 0x20 ... 0x40:
@@ -661,6 +688,12 @@ static void riva_load_state(struct riva_
 		default:
 			CRTCout(par, i, regs->crtc[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i < NUM_ATC_REGS; i++)
@@ -1365,18 +1398,40 @@ static int rivafb_setcolreg(unsigned reg
 		break;
 	case 16:
 		if (info->var.green.length == 5) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 8; i++) {
 				riva_wclut(chip, regno*8+i, red >> 8,
 					   green >> 8, blue >> 8);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
 			u8 r, g, b;
 
 			if (regno < 32) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < 8; i++) {
 					riva_wclut(chip, regno*8+i,
 						   red >> 8, green >> 8,
 						   blue >> 8);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 				}
 			}
 			riva_rclut(chip, regno*4, &r, &g, &b);
@@ -1562,21 +1617,43 @@ static void rivafb_imageblit(struct fb_i
 	size = width * image->height;
 	while (size >= 16) {
 		RIVA_FIFO_FREE(par->riva, Bitmap, 16);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 16; i++) {
 			tmp = *((u32 *)cdat);
 			cdat = (u8 *)((u32 *)cdat + 1);
 			reverse_order(&tmp);
 			NV_WR32(d, i*4, tmp);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 		}
 		size -= 16;
 	}
 	if (size) {
 		RIVA_FIFO_FREE(par->riva, Bitmap, size);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < size; i++) {
 			tmp = *((u32 *) cdat);
 			cdat = (u8 *)((u32 *)cdat + 1);
 			reverse_order(&tmp);
 			NV_WR32(d, i*4, tmp);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 		}
 	}
 }
@@ -1765,6 +1842,11 @@ static int __devinit riva_get_EDID_OF(st
 			continue;
 		if (strncmp(disptype, "LCD", 3) != 0)
 			continue;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; propnames[i] != NULL; ++i) {
 			pedid = of_get_property(dp, propnames[i], NULL);
 			if (pedid != NULL) {
@@ -1772,6 +1854,12 @@ static int __devinit riva_get_EDID_OF(st
 				NVTRACE("LCD found.\n");
 				return 1;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	NVTRACE_LEAVE();
diff -u -p a/video/riva/rivafb-i2c.c b/video/riva/rivafb-i2c.c
--- a/video/riva/rivafb-i2c.c
+++ b/video/riva/rivafb-i2c.c
@@ -142,11 +142,22 @@ void riva_delete_i2c_busses(struct riva_
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		if (!par->chan[i].par)
 			continue;
 		i2c_del_adapter(&par->chan[i].adapter);
 		par->chan[i].par = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/gxt4500.c b/video/gxt4500.c
--- a/video/gxt4500.c
+++ b/video/gxt4500.c
@@ -235,7 +235,17 @@ static int calc_pll(int period_ps, struc
 		return -1;
 
 	best_error = 1000000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pdiv1 = 1; pdiv1 <= 8; ++pdiv1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (pdiv2 = 1; pdiv2 <= pdiv1; ++pdiv2) {
 			postdiv = pdiv1 * pdiv2;
 			pll_period = DIV_ROUND_UP(period_ps, postdiv);
@@ -259,6 +269,18 @@ static int calc_pll(int period_ps, struc
 					best_error = t;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 	if (best_error == 1000000)
@@ -474,11 +496,22 @@ static int gxt4500_set_par(struct fb_inf
 	 * We set all WAT entries the same so it doesn't matter what the
 	 * window ID (WID) plane contains.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 32; ++i) {
 		writereg(par, WAT_FMT + (i << 4), watfmt[pixfmt]);
 		writereg(par, WAT_CMAP_OFFSET + (i << 4), 0);
 		writereg(par, WAT_CTRL + (i << 4), 0);
 		writereg(par, WAT_GAMMA_CTRL + (i << 4), WAT_GAMMA_DISABLE);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	/* Set sync polarity etc. */
diff -u -p a/video/vt8623fb.c b/video/vt8623fb.c
--- a/video/vt8623fb.c
+++ b/video/vt8623fb.c
@@ -162,16 +162,38 @@ static void vt8623fb_iplan_imageblit(str
 	dst1 = info->screen_base + (image->dy * info->fix.line_length)
 		 + ((image->dx / 8) * 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < image->height; y++) {
 		src = src1;
 		dst = (u32 __iomem *) dst1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < image->width; x += 8) {
 			val = *(src++) * 0x01010101;
 			val = (val & fg) | (~val & bg);
 			fb_writel(val, dst++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		src1 += image->width / 8;
 		dst1 += info->fix.line_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -186,12 +208,34 @@ static void vt8623fb_iplan_fillrect(stru
 	dst1 = info->screen_base + (rect->dy * info->fix.line_length)
 		 + ((rect->dx / 8) * 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < rect->height; y++) {
 		dst = (u32 __iomem *) dst1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < rect->width; x += 8) {
 			fb_writel(fg, dst++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dst1 += info->fix.line_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -218,16 +262,38 @@ static void vt8623fb_cfb4_imageblit(stru
 	dst1 = info->screen_base + (image->dy * info->fix.line_length)
 		 + ((image->dx / 8) * 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < image->height; y++) {
 		src = src1;
 		dst = (u32 __iomem *) dst1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < image->width; x += 8) {
 			val = expand_pixel(*(src++));
 			val = (val & fg) | (~val & bg);
 			fb_writel(val, dst++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		src1 += image->width / 8;
 		dst1 += info->fix.line_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/pm3fb.c b/video/pm3fb.c
--- a/video/pm3fb.c
+++ b/video/pm3fb.c
@@ -159,8 +159,23 @@ static void pm3fb_calculate_clock(unsign
 	long freqerr = 1000;
 	long currerr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (f = 1; f < 256; f++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (pre = 1; pre < 256; pre++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (post = 0; post < 5; post++) {
 				freq = ((2*PM3_REF_CLOCK * f) >> post) / pre;
 				currerr = (reqclock > freq)
@@ -172,7 +187,25 @@ static void pm3fb_calculate_clock(unsign
 					*prescale = pre;
 					*postscale = post;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
 			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
@@ -688,6 +721,11 @@ static int pm3fb_cursor(struct fb_info *
 		int i;
 		int pos = PM3RD_CursorPattern(0);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < cursor->image.height; i++) {
 			int j = (cursor->image.width + 7) >> 3;
 			int k = 8 - j;
@@ -712,6 +750,12 @@ static int pm3fb_cursor(struct fb_info *
 				PM3_WRITE_DAC_REG(par, pos++, 0);
 				PM3_WRITE_DAC_REG(par, pos++, 0);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		while (pos < PM3RD_CursorPattern(1024))
 			PM3_WRITE_DAC_REG(par, pos++, 0);
@@ -1263,7 +1307,12 @@ static unsigned long __devinit pm3fb_siz
 	/* pm3 split up memory, replicates, and do a lot of
 	 * nasty stuff IMHO ;-)
 	 */
-	for (i = 0; i < 32; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 32; i++) {
 		fb_writel(i * 0x00345678,
 			  (screen_mem + (i * 1048576)));
 		mb();
@@ -1274,18 +1323,40 @@ static unsigned long __devinit pm3fb_siz
 			memsize = i;
 		else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	DPRINTK("First detect pass already got %ld MB\n", memsize + 1);
 
 	if (memsize + 1 == i) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 32; i++) {
 			/* Clear first 32MB ; 0 is 0, no need to byteswap */
 			writel(0x0000000, (screen_mem + (i * 1048576)));
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		wmb();
 
-		for (i = 32; i < 64; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 32; i < 64; i++) {
 			fb_writel(i * 0x00345678,
 				  (screen_mem + (i * 1048576)));
 			mb();
@@ -1298,6 +1369,12 @@ static unsigned long __devinit pm3fb_siz
 				memsize = i;
 			else
 				break;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 	DPRINTK("Second detect pass got %ld MB\n", memsize + 1);
diff -u -p a/video/kyro/STG4000VTG.c b/video/kyro/STG4000VTG.c
--- a/video/kyro/STG4000VTG.c
+++ b/video/kyro/STG4000VTG.c
@@ -25,8 +25,19 @@ void DisableVGA(volatile STG4000REG __io
 	STG_WRITE_REG(SoftwareReset, tmp);
 
 	/* Just for Delay */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 1000; i++) {
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Pull-out the VGA registers from reset */
diff -u -p a/video/kyro/STG4000InitDevice.c b/video/kyro/STG4000InitDevice.c
--- a/video/kyro/STG4000InitDevice.c
+++ b/video/kyro/STG4000InitDevice.c
@@ -140,6 +140,11 @@ u32 ProgramClock(u32 refClock,
 	ulScaleClockReq = coreClock >> STG4K3_PLL_SCALER;
 
 	/* Iterate through post divider values */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ODIndex = 0; ODIndex < 3; ODIndex++) {
 		OD = ODValues[ODIndex];
 		R = STG4K3_PLL_MIN_R;
@@ -220,6 +225,12 @@ u32 ProgramClock(u32 refClock,
 			}
 			R++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/video/imsttfb.c b/video/imsttfb.c
--- a/video/imsttfb.c
+++ b/video/imsttfb.c
@@ -1377,18 +1377,40 @@ init_imstt(struct fb_info *info)
 		eieio();
 		par->cmap_regs[PIDXHI] = 0;
 		eieio();
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ARRAY_SIZE(ibm_initregs); i++) {
 			par->cmap_regs[PIDXLO] = ibm_initregs[i].addr;
 			eieio();
 			par->cmap_regs[PIDXDATA] = ibm_initregs[i].value;
 			eieio();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ARRAY_SIZE(tvp_initregs); i++) {
 			par->cmap_regs[TVPADDRW] = tvp_initregs[i].addr;
 			eieio();
 			par->cmap_regs[TVPIDATA] = tvp_initregs[i].value;
 			eieio();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/video/vermilion/vermilion.c b/video/vermilion/vermilion.c
--- a/video/vermilion/vermilion.c
+++ b/video/vermilion/vermilion.c
@@ -119,8 +119,19 @@ static int vmlfb_alloc_vram_area(struct
 	 */
 
 	memset((void *)va->logical, 0x00, va->size);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = va->logical; i < va->logical + va->size; i += PAGE_SIZE) {
 		get_page(virt_to_page(i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -159,9 +170,20 @@ static void vmlfb_free_vram_area(struct
 		 * to compensate for upping when allocating.
 		 */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = va->logical; j < va->logical + va->size;
 		     j += PAGE_SIZE) {
 			(void)put_page_testzero(virt_to_page(j));
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 
 		printk(KERN_DEBUG MODULE_NAME
@@ -181,8 +203,19 @@ static void vmlfb_free_vram(struct vml_i
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < vinfo->num_areas; ++i) {
 		vmlfb_free_vram_area(&vinfo->vram[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	vinfo->num_areas = 0;
 }
@@ -305,12 +338,23 @@ static int vmlfb_vram_offset(struct vml_
 	unsigned long aoffset;
 	unsigned i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < vinfo->num_areas; ++i) {
 		aoffset = offset - (vinfo->vram[i].phys - vinfo->vram_start);
 
 		if (aoffset < vinfo->vram[i].size) {
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -EINVAL;
@@ -586,6 +630,11 @@ static int vml_nearest_clock(int clock)
 	cur_index = 0;
 	cur_diff = clock - vml_clocks[0];
 	cur_diff = (cur_diff < 0) ? -cur_diff : cur_diff;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < vml_num_clocks; ++i) {
 		diff = clock - vml_clocks[i];
 		diff = (diff < 0) ? -diff : diff;
@@ -593,6 +642,12 @@ static int vml_nearest_clock(int clock)
 			cur_index = i;
 			cur_diff = diff;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return vml_clocks[cur_index];
 }
diff -u -p a/video/vermilion/cr_pll.c b/video/vermilion/cr_pll.c
--- a/video/vermilion/cr_pll.c
+++ b/video/vermilion/cr_pll.c
@@ -106,6 +106,11 @@ static int crvml_nearest_index(const str
 
 	cur_diff = clock - crvml_clocks[0];
 	cur_diff = (cur_diff < 0) ? -cur_diff : cur_diff;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < crvml_num_clocks; ++i) {
 		diff = clock - crvml_clocks[i];
 		diff = (diff < 0) ? -diff : diff;
@@ -113,6 +118,12 @@ static int crvml_nearest_index(const str
 			cur_index = i;
 			cur_diff = diff;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return cur_index;
 }
diff -u -p a/video/acornfb.c b/video/acornfb.c
--- a/video/acornfb.c
+++ b/video/acornfb.c
@@ -536,12 +536,23 @@ acornfb_setcolreg(u_int regno, u_int red
 
 		pal.p = 0;
 		vidc_writel(0x10000000);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 256; i += 1) {
 			pal.vidc20.red   = current_par.palette[ i       & 31].vidc20.red;
 			pal.vidc20.green = current_par.palette[(i >> 1) & 31].vidc20.green;
 			pal.vidc20.blue  = current_par.palette[(i >> 2) & 31].vidc20.blue;
 			vidc_writel(pal.p);
 			/* Palette register pointer auto-increments */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		vidc_writel(0x10000000 | regno);
diff -u -p a/video/fb-puv3.c b/video/fb-puv3.c
--- a/video/fb-puv3.c
+++ b/video/fb-puv3.c
@@ -104,9 +104,20 @@ static void unifb_sync(struct fb_info *i
 	/* TODO: may, this can be replaced by interrupt */
 	int cnt;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < 0x10000000; cnt++) {
 		if (readl(UGE_COMMAND) & 0x1000000)
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	if (cnt > 0x8000000)
diff -u -p a/video/sh_mobile_hdmi.c b/video/sh_mobile_hdmi.c
--- a/video/sh_mobile_hdmi.c
+++ b/video/sh_mobile_hdmi.c
@@ -746,7 +746,12 @@ static int sh_hdmi_read_edid(struct sh_h
 
 	/* Read EDID */
 	dev_dbg(hdmi->dev, "Read back EDID code:");
-	for (i = 0; i < 128; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (i = 0; i < 128; i++) {
 		edid[i] = hdmi_read(hdmi, HDMI_EDID_KSV_FIFO_ACCESS_WINDOW);
 #ifdef DEBUG
 		if ((i % 16) == 0) {
@@ -756,6 +761,12 @@ static int sh_hdmi_read_edid(struct sh_h
 			printk(KERN_CONT " %02X", edid[i]);
 		}
 #endif
+if (_cur < timeout) {
+		rdstcll(_cur);
+}
+else {
+		break;
+}
 	}
 #ifdef DEBUG
 	printk(KERN_CONT "\n");
@@ -811,6 +822,11 @@ static int sh_hdmi_read_edid(struct sh_h
 	}
 
 	/* Walk monitor modes to find the best or the exact match */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, mode = hdmi->monspec.modedb;
 	     i < hdmi->monspec.modedb_len && scanning;
 	     i++, mode++) {
@@ -867,6 +883,12 @@ static int sh_hdmi_read_edid(struct sh_h
 
 		found = mode;
 		found_rate_error = rate_error;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	hdmi->var.width = hdmi->monspec.max_x * 10;
diff -u -p a/video/uvesafb.c b/video/uvesafb.c
--- a/video/uvesafb.c
+++ b/video/uvesafb.c
@@ -319,6 +319,11 @@ static int uvesafb_vbe_find_mode(struct
 {
 	int i, match = -1, h = 0, d = 0x7fffffff;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < par->vbe_modes_cnt; i++) {
 		h = abs(par->vbe_modes[i].x_res - xres) +
 		    abs(par->vbe_modes[i].y_res - yres) +
@@ -335,6 +340,12 @@ static int uvesafb_vbe_find_mode(struct
 			d = h;
 			match = i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	i = 1;
 
@@ -731,6 +742,11 @@ static void __devinit uvesafb_vbe_getmon
 				 "default refresh rate will be used\n");
 
 	/* Add VBE modes to the modelist. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < par->vbe_modes_cnt; i++) {
 		struct fb_var_screeninfo var;
 		struct vbe_mode_ib *mode;
@@ -745,19 +761,47 @@ static void __devinit uvesafb_vbe_getmon
 		fb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON, 60, &var, info);
 		fb_var_to_videomode(&vmode, &var);
 		fb_add_videomode(&vmode, &info->modelist);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Add valid VESA modes to our modelist. */
-	for (i = 0; i < VESA_MODEDB_SIZE; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (i = 0; i < VESA_MODEDB_SIZE; i++) {
 		if (uvesafb_is_valid_mode((struct fb_videomode *)
 						&vesa_modes[i], info))
 			fb_add_videomode(&vesa_modes[i], &info->modelist);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < info->monspecs.modedb_len; i++) {
 		if (uvesafb_is_valid_mode(&info->monspecs.modedb[i], info))
 			fb_add_videomode(&info->monspecs.modedb[i],
 					&info->modelist);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	return;
@@ -847,6 +891,11 @@ static int __devinit uvesafb_vbe_init_mo
 
 	/* Has the user requested a specific VESA mode? */
 	if (vbemode) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < par->vbe_modes_cnt; i++) {
 			if (par->vbe_modes[i].mode_id == vbemode) {
 				modeid = i;
@@ -861,6 +910,12 @@ static int __devinit uvesafb_vbe_init_mo
 				info->var.pixclock = 0;
 				goto gotmode;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		printk(KERN_INFO "uvesafb: requested VBE mode 0x%x is "
 				 "unavailable\n", vbemode);
@@ -956,11 +1011,22 @@ static int uvesafb_setpalette(struct uve
 	/* Use VGA registers if mode is VGA-compatible. */
 	if (i >= 0 && i < par->vbe_modes_cnt &&
 	    par->vbe_modes[i].mode_attr & VBE_MODE_VGACOMPAT) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; i++) {
 			outb_p(start + i,        dac_reg);
 			outb_p(entries[i].red,   dac_val);
 			outb_p(entries[i].green, dac_val);
 			outb_p(entries[i].blue,  dac_val);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 #ifdef CONFIG_X86_32
@@ -1066,11 +1132,22 @@ static int uvesafb_setcmap(struct fb_cma
 		if (!entries)
 			return -ENOMEM;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < cmap->len; i++) {
 			entries[i].red   = cmap->red[i]   >> shift;
 			entries[i].green = cmap->green[i] >> shift;
 			entries[i].blue  = cmap->blue[i]  >> shift;
 			entries[i].pad   = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		err = uvesafb_setpalette(entries, cmap->len, cmap->start, info);
 		kfree(entries);
@@ -1080,10 +1157,21 @@ static int uvesafb_setcmap(struct fb_cma
 		 * the fb_info struct. We rely on uvesafb_setcolreg to do all
 		 * sanity checking.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < cmap->len; i++) {
 			err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
 						cmap->green[i], cmap->blue[i],
 						0, info);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return err;
@@ -1457,11 +1545,22 @@ static void __devinit uvesafb_init_info(
 	 * the highest resolution.
 	 */
 	size_remap = 0;
-	for (i = 0; i < par->vbe_modes_cnt; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < par->vbe_modes_cnt; i++) {
 		h = par->vbe_modes[i].bytes_per_scan_line *
 					par->vbe_modes[i].y_res;
 		if (h > size_remap)
 			size_remap = h;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	size_remap *= 2;
 
@@ -1613,11 +1712,22 @@ static ssize_t uvesafb_show_vbe_modes(st
 	struct uvesafb_par *par = info->par;
 	int ret = 0, i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < par->vbe_modes_cnt && ret < PAGE_SIZE; i++) {
 		ret += snprintf(buf + ret, PAGE_SIZE - ret,
 			"%dx%d-%d, 0x%.4x\n",
 			par->vbe_modes[i].x_res, par->vbe_modes[i].y_res,
 			par->vbe_modes[i].depth, par->vbe_modes[i].mode_id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
diff -u -p a/video/sh_mobile_lcdcfb.c b/video/sh_mobile_lcdcfb.c
--- a/video/sh_mobile_lcdcfb.c
+++ b/video/sh_mobile_lcdcfb.c
@@ -319,6 +319,11 @@ static irqreturn_t sh_mobile_lcdc_irq(in
 	is_sub = (lcdc_read(priv, _LDSR) & LDSR_MSS) ? 1 : 0;
 
 	/* wake up channel and disable clocks */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < ARRAY_SIZE(priv->ch); k++) {
 		ch = &priv->ch[k];
 
@@ -338,6 +343,12 @@ static irqreturn_t sh_mobile_lcdc_irq(in
 		/* VSYNC End */
 		if (ldintr & LDINTR_VES)
 			complete(&ch->vsync_completion);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return IRQ_HANDLED;
@@ -449,6 +460,11 @@ static void __sh_mobile_lcdc_start(struc
 
 	/* Configure power supply, dot clocks and start them. */
 	tmp = priv->lddckr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < ARRAY_SIZE(priv->ch); k++) {
 		ch = &priv->ch[k];
 		if (!ch->enabled)
@@ -473,6 +489,12 @@ static void __sh_mobile_lcdc_start(struc
 		if (m == 1)
 			m = LDDCKR_MOSEL;
 		tmp |= m << (lcdc_chan_is_sublcd(ch) ? 8 : 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lcdc_write(priv, _LDDCKR, tmp);
@@ -480,6 +502,11 @@ static void __sh_mobile_lcdc_start(struc
 	lcdc_wait_bit(priv, _LDDCKSTPR, ~0, 0);
 
 	/* Setup geometry, format, frame buffer memory and operation mode. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < ARRAY_SIZE(priv->ch); k++) {
 		ch = &priv->ch[k];
 		if (!ch->enabled)
@@ -533,6 +560,12 @@ static void __sh_mobile_lcdc_start(struc
 		} else {
 			lcdc_write_chan(ch, LDSM1R, 0);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Word and long word swap. */
@@ -570,15 +603,31 @@ static int sh_mobile_lcdc_start(struct s
 	int k;
 
 	/* enable clocks before accessing the hardware */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < ARRAY_SIZE(priv->ch); k++) {
 		if (priv->ch[k].enabled)
 			sh_mobile_lcdc_clk_on(priv);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* reset */
 	lcdc_write(priv, _LDCNT2R, lcdc_read(priv, _LDCNT2R) | LDCNT2R_BR);
 	lcdc_wait_bit(priv, _LDCNT2R, LDCNT2R_BR, 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < ARRAY_SIZE(priv->ch); k++) {
 		ch = &priv->ch[k];
 
@@ -592,9 +641,20 @@ static int sh_mobile_lcdc_start(struct s
 			if (ret)
 				return ret;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/* Compute frame buffer base address and pitch for each channel. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < ARRAY_SIZE(priv->ch); k++) {
 		struct sh_mobile_meram_cfg *cfg;
 		int pixelformat;
@@ -636,6 +696,12 @@ static int sh_mobile_lcdc_start(struct s
 					&ch->pitch);
 		if (!ret)
 			ch->meram_enabled = 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* Start the LCDC. */
@@ -644,6 +710,11 @@ static int sh_mobile_lcdc_start(struct s
 	/* Setup deferred I/O, tell the board code to enable the panels, and
 	 * turn backlight on.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < ARRAY_SIZE(priv->ch); k++) {
 		ch = &priv->ch[k];
 		if (!ch->enabled)
@@ -667,6 +738,12 @@ static int sh_mobile_lcdc_start(struct s
 			ch->bl->props.power = FB_BLANK_UNBLANK;
 			backlight_update_status(ch->bl);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -679,6 +756,11 @@ static void sh_mobile_lcdc_stop(struct s
 	int k;
 
 	/* clean up deferred io and ask board code to disable panel */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < ARRAY_SIZE(priv->ch); k++) {
 		ch = &priv->ch[k];
 		if (!ch->enabled)
@@ -718,6 +800,12 @@ static void sh_mobile_lcdc_stop(struct s
 			ch->meram_enabled = 0;
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* stop the lcdc */
@@ -1064,6 +1152,11 @@ static int sh_mobile_check_var(struct fb
 	 * distance between two modes is defined as the size of the
 	 * non-overlapping parts of the two rectangles.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ch->cfg.num_cfg; ++i) {
 		const struct fb_videomode *mode = &ch->cfg.lcd_cfg[i];
 		unsigned int dist;
@@ -1081,6 +1174,12 @@ static int sh_mobile_check_var(struct fb
 			best_yres = mode->yres;
 			best_dist = dist;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If no available mode can be used, return an error. */
@@ -1389,6 +1488,11 @@ static int sh_mobile_lcdc_remove(struct
 
 	sh_mobile_lcdc_stop(priv);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(priv->ch); i++) {
 		info = priv->ch[i].info;
 
@@ -1404,11 +1508,28 @@ static int sh_mobile_lcdc_remove(struct
 					  priv->ch[i].dma_handle);
 		fb_dealloc_cmap(&info->cmap);
 		framebuffer_release(info);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(priv->ch); i++) {
 		if (priv->ch[i].bl)
 			sh_mobile_lcdc_bl_remove(priv->ch[i].bl);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (priv->dot_clk)
@@ -1461,6 +1582,11 @@ static int __devinit sh_mobile_lcdc_chan
 	max_mode = NULL;
 	max_size = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, mode = cfg->lcd_cfg; i < cfg->num_cfg; i++, mode++) {
 		unsigned int size = mode->yres * mode->xres;
 
@@ -1476,6 +1602,12 @@ static int __devinit sh_mobile_lcdc_chan
 			max_mode = mode;
 			max_size = size;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!max_size)
@@ -1587,6 +1719,11 @@ static int __devinit sh_mobile_lcdc_prob
 	priv->irq = i;
 	atomic_set(&priv->hw_usecnt, -1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, num_channels = 0; i < ARRAY_SIZE(pdata->ch); i++) {
 		struct sh_mobile_lcdc_chan *ch = priv->ch + num_channels;
 
@@ -1618,6 +1755,12 @@ static int __devinit sh_mobile_lcdc_prob
 			num_channels++;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!num_channels) {
@@ -1642,12 +1785,23 @@ static int __devinit sh_mobile_lcdc_prob
 
 	priv->meram_dev = pdata->meram_dev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_channels; i++) {
 		struct sh_mobile_lcdc_chan *ch = priv->ch + i;
 
 		error = sh_mobile_lcdc_channel_init(ch, &pdev->dev);
 		if (error)
 			goto err1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	error = sh_mobile_lcdc_start(priv);
@@ -1656,6 +1810,11 @@ static int __devinit sh_mobile_lcdc_prob
 		goto err1;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_channels; i++) {
 		struct sh_mobile_lcdc_chan *ch = priv->ch + i;
 		struct fb_info *info = ch->info;
@@ -1686,6 +1845,12 @@ static int __devinit sh_mobile_lcdc_prob
 		/* deferred io mode: disable clock to save power */
 		if (info->fbdefio || info->state == FBINFO_STATE_SUSPENDED)
 			sh_mobile_lcdc_clk_off(priv);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* Failure ignored */
diff -u -p a/video/mbx/mbxfb.c b/video/mbx/mbxfb.c
--- a/video/mbx/mbxfb.c
+++ b/video/mbx/mbxfb.c
@@ -144,8 +144,23 @@ static unsigned int mbxfb_get_pixclock(u
 	 * get divided by 2. Preventing N=1 by starting the following
 	 * loop at 2 prevents this. Is this a bug with my chip
 	 * revision or something I dont understand? */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = 1; m < 64; m++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (n = 2; n < 8; n++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (p = 0; p < 8; p++) {
 				clk = (ref_clk * m) / (n * (1 << p));
 				err = (clk > pixclock) ? (clk - pixclock) :
@@ -157,7 +172,25 @@ static unsigned int mbxfb_get_pixclock(u
 					div->n = n;
 					div->p = p;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
 			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 	return KHZ2PICOS(best_clk);
@@ -714,8 +747,19 @@ static void __devinit setup_memc(struct
 	/* enable memory controller */
 	write_reg_dly(LMPWR_MC_PWR_ACT, LMPWR);
 	/* perform dummy reads */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for ( i = 0; i < 16; i++ ) {
 		tmp = readl(fbi->screen_base);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 }
 
diff -u -p a/video/macfb.c b/video/macfb.c
--- a/video/macfb.c
+++ b/video/macfb.c
@@ -170,7 +170,12 @@ static int dafb_setpalette(unsigned int
 		nop();
 
 		/* Loop until we get to the register we want */
-		for (i = 0; i < regno; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < regno; i++) {
 			nubus_writeb(info->cmap.red[i] >> 8,
 				     &dafb_cmap_regs->lut);
 			nop();
@@ -180,6 +185,12 @@ static int dafb_setpalette(unsigned int
 			nubus_writeb(info->cmap.blue[i] >> 8,
 				     &dafb_cmap_regs->lut);
 			nop();
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
diff -u -p a/video/nuc900fb.c b/video/nuc900fb.c
--- a/video/nuc900fb.c
+++ b/video/nuc900fb.c
@@ -609,6 +609,11 @@ static int __devinit nuc900fb_probe(stru
 	fbi->clk_rate = clk_get_rate(fbi->clk);
 
 	/* calutate the video buffer size */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mach_info->num_displays; i++) {
 		unsigned long smem_len = mach_info->displays[i].xres;
 		smem_len *= mach_info->displays[i].yres;
@@ -616,6 +621,12 @@ static int __devinit nuc900fb_probe(stru
 		smem_len >>= 3;
 		if (fbinfo->fix.smem_len < smem_len)
 			fbinfo->fix.smem_len = smem_len;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+		else {
+		break;
+		}
 	}
 
 	/* Initialize Video Memory */
diff -u -p a/video/aty/radeon_pm.c b/video/aty/radeon_pm.c
--- a/video/aty/radeon_pm.c
+++ b/video/aty/radeon_pm.c
@@ -1303,6 +1303,11 @@ static void radeon_pm_full_reset_sdram(s
 		/* Program the SDRAM */
 		sdram_mode_reg = mrtable[0];
 		OUTREG(MEM_SDRAM_MODE_REG, sdram_mode_reg);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < mrtable_size; i++) {
 			if (mrtable[i] == 0xffffffffu)
 				radeon_pm_m10_program_mode_wait(rinfo);
@@ -1315,6 +1320,12 @@ static void radeon_pm_full_reset_sdram(s
 				OUTREG(MEM_SDRAM_MODE_REG, sdram_mode_reg);
 				mdelay(1);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Restore memory refresh */
diff -u -p a/video/aty/mach64_cursor.c b/video/aty/mach64_cursor.c
--- a/video/aty/mach64_cursor.c
+++ b/video/aty/mach64_cursor.c
@@ -156,7 +156,17 @@ static int atyfb_cursor(struct fb_info *
 
 	    offset = align - width*2;
 
+	    unsigned long long delta = (cpu / khz / HZ) * 2;
+	    unsigned long long _start = 0;
+	    unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
 	    for (i = 0; i < height; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < width; j++) {
 			u16 l = 0xaaaa;
 			b = *src++;
@@ -185,8 +195,20 @@ static int atyfb_cursor(struct fb_info *
 			}
 			fb_writeb(l & 0xff, dst++);
 			fb_writeb(l >> 8, dst++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dst += offset;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	    }
 	}
 
diff -u -p a/video/aty/radeon_base.c b/video/aty/radeon_base.c
--- a/video/aty/radeon_base.c
+++ b/video/aty/radeon_base.c
@@ -1367,10 +1367,21 @@ void radeon_write_mode (struct radeonfb_
 		OUTREG(common_regs[i].reg, common_regs[i].val);
 
 	/* Apply surface registers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i<8; i++) {
 		OUTREG(SURFACE0_LOWER_BOUND + 0x10*i, mode->surf_lower_bound[i]);
 		OUTREG(SURFACE0_UPPER_BOUND + 0x10*i, mode->surf_upper_bound[i]);
 		OUTREG(SURFACE0_INFO + 0x10*i, mode->surf_info[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	OUTREG(CRTC_GEN_CNTL, mode->crtc_gen_cntl);
@@ -1705,10 +1716,21 @@ static int radeonfb_set_par(struct fb_in
 #endif
 
 	/* Clear surface registers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i<8; i++) {
 		newmode->surf_lower_bound[i] = 0;
 		newmode->surf_upper_bound[i] = 0x1f;
 		newmode->surf_info[i] = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_debug("h_total_disp = 0x%x\t   hsync_strt_wid = 0x%x\n",
diff -u -p a/video/aty/mach64_gx.c b/video/aty/mach64_gx.c
--- a/video/aty/mach64_gx.c
+++ b/video/aty/mach64_gx.c
@@ -459,14 +459,36 @@ static void aty_set_pll18818(const struc
 	aty_ICS2595_put1bit(0, par);	/* Start bit */
 	aty_ICS2595_put1bit(0, par);	/* Read / ~Write */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 5; i++) {	/* Location 0..4 */
 		aty_ICS2595_put1bit(locationAddr & 1, par);
 		locationAddr >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8 + 1 + 2 + 2; i++) {
 		aty_ICS2595_put1bit(program_bits & 1, par);
 		program_bits >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mdelay(1);		/* delay for 1 ms */
@@ -649,7 +671,17 @@ static int aty_var_to_pll_8398(const str
 		diff = 0;
 		preDiff = 0xFFFFFFFF;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (m = MIN_M; m <= MAX_M; m++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (n = MIN_N; n <= MAX_N; n++) {
 				tempA = 938356;		/* 14.31818 * 65536 */
 				tempA *= (n + 8);	/* 43..256 */
@@ -667,6 +699,18 @@ static int aty_var_to_pll_8398(const str
 					save_n = n;
 					preDiff = diff;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 
diff -u -p a/video/aty/atyfb_base.c b/video/aty/atyfb_base.c
--- a/video/aty/atyfb_base.c
+++ b/video/aty/atyfb_base.c
@@ -1475,10 +1475,21 @@ static int atyfb_set_par(struct fb_info
 	/* CRTC registers */
 	base = 0x2000;
 	printk("debug atyfb: Mach64 non-shadow register values:");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 256; i = i+4) {
 		if (i % 16 == 0)
 			printk("\ndebug atyfb: 0x%04X: ", base + i);
 		printk(" %08X", aty_ld_le32(i, par));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("\n\n");
 
@@ -1486,12 +1497,23 @@ static int atyfb_set_par(struct fb_info
 	/* PLL registers */
 	base = 0x00;
 	printk("debug atyfb: Mach64 PLL register values:");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 64; i++) {
 		if (i % 16 == 0)
 			printk("\ndebug atyfb: 0x%02X: ", base + i);
 		if (i % 4 == 0)
 			printk(" ");
 		printk("%02X", aty_ld_pll_ct(i, par));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("\n\n");
 #endif	/* CONFIG_FB_ATY_CT */
@@ -1502,19 +1524,41 @@ static int atyfb_set_par(struct fb_info
 		base = 0x00;
 		printk("debug atyfb: LCD register values:");
 		if (M64_HAS(LT_LCD_REGS)) {
-			for (i = 0; i <= POWER_MANAGEMENT; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (i = 0; i <= POWER_MANAGEMENT; i++) {
 				if (i == EXT_VERT_STRETCH)
 					continue;
 				printk("\ndebug atyfb: 0x%04X: ",
 				       lt_lcd_regs[i]);
 				printk(" %08X", aty_ld_lcd(i, par));
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		} else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 64; i++) {
 				if (i % 4 == 0)
 					printk("\ndebug atyfb: 0x%02X: ",
 					       base + i);
 				printk(" %08X", aty_ld_lcd(i, par));
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		printk("\n\n");
@@ -1954,6 +1998,11 @@ static int atyfb_mmap(struct fb_info *in
 	/* Each page, see which map applies */
 	for (page = 0; page < size;) {
 		map_size = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; par->mmap_map[i].size; i++) {
 			unsigned long start = par->mmap_map[i].voff;
 			unsigned long end = start + par->mmap_map[i].size;
@@ -1967,6 +2016,12 @@ static int atyfb_mmap(struct fb_info *in
 			map_size = par->mmap_map[i].size - (offset - start);
 			map_offset = par->mmap_map[i].poff + (offset - start);
 			break;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!map_size) {
 			page += PAGE_SIZE;
@@ -2997,6 +3052,11 @@ static int __devinit atyfb_setup_sparc(s
 		return -ENOMEM;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 2; i < 6 && pdev->resource[i].start; i++) {
 		struct resource *rp = &pdev->resource[i];
 		int io, breg = PCI_BASE_ADDRESS_0 + (i << 2);
@@ -3049,6 +3109,12 @@ static int __devinit atyfb_setup_sparc(s
 		par->mmap_map[j].prot_mask = _PAGE_CACHE;
 		par->mmap_map[j].prot_flag = _PAGE_E;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = correct_chipset(par);
@@ -3292,6 +3358,11 @@ static void __devinit aty_init_lcd(struc
 		refresh_rates = *(u16 *)(par->lcd_table+62);
 		m = 1;
 		f = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 16; i++) {
 			if (refresh_rates & m) {
 				if (f == 0) {
@@ -3305,6 +3376,12 @@ static void __devinit aty_init_lcd(struc
 				strcat(refresh_rates_buf, strbuf);
 			}
 			m = m << 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		default_refresh_rate = (*(u8 *)(par->lcd_table+61) & 0xf0) >> 4;
 		PRINTKI("       supports refresh rates [%s], default %d Hz\n",
@@ -3640,7 +3717,12 @@ static int __init atyfb_atari_probe(void
 	u32 clock_r;
 	int num_found = 0;
 
-	for (m64_num = 0; m64_num < mach64_count; m64_num++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (m64_num = 0; m64_num < mach64_count; m64_num++) {
 		if (!phys_vmembase[m64_num] || !phys_size[m64_num] ||
 		    !phys_guiregbase[m64_num]) {
 			PRINTKI("phys_*[%d] parameters not set => "
@@ -3706,6 +3788,12 @@ static int __init atyfb_atari_probe(void
 		} else {
 			num_found++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return num_found ? 0 : -ENXIO;
diff -u -p a/video/aty/mach64_accel.c b/video/aty/mach64_accel.c
--- a/video/aty/mach64_accel.c
+++ b/video/aty/mach64_accel.c
@@ -387,9 +387,19 @@ void atyfb_imageblit(struct fb_info *inf
 		u32 hostdword;
 
 		for (width = image->width, inbit = 7, mult24 = 0; src_bytes; ) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (hostdword = 0, pbitmapout = (u8*)&hostdword, byte_id_in_dword = 0;
 				byte_id_in_dword < 4 && src_bytes;
 				byte_id_in_dword++, pbitmapout++) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (outbit = 7; outbit >= 0; outbit--) {
 					*pbitmapout |= (((*pbitmapin >> inbit) & 1) << outbit);
 					mult24++;
@@ -411,6 +421,18 @@ void atyfb_imageblit(struct fb_info *inf
 						    outbit = 0;
 						}
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
 				}
 			}
 			wait_for_fifo(1, par);
@@ -418,9 +440,20 @@ void atyfb_imageblit(struct fb_info *inf
 		}
 	} else {
 		u32 *pbitmap, dwords = (src_bytes + 3) / 4;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (pbitmap = (u32*)(image->data); dwords; dwords--, pbitmap++) {
 			wait_for_fifo(1, par);
 			aty_st_le32(HOST_DATA0, get_unaligned_le32(pbitmap), par);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/video/aty/radeon_monitor.c b/video/aty/radeon_monitor.c
--- a/video/aty/radeon_monitor.c
+++ b/video/aty/radeon_monitor.c
@@ -275,6 +275,11 @@ static void __devinit radeon_parse_conne
 	 */
 	chips = BIOS_IN8(offset++) >> 4;
 	pr_debug("%d chips in connector info\n", chips);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < chips; i++) {
 		tmp = BIOS_IN8(offset++);
 		connectors = tmp & 0x0f;
@@ -288,6 +293,12 @@ static void __devinit radeon_parse_conne
 			pr_debug("  * connector %d of type %d (%s) : %04x\n",
 			       conn, type, __conn_type_table[type], tmp);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -978,6 +989,11 @@ int  radeon_match_mode(struct radeonfb_i
 
 	/* Now look for a mode in the database */
 	while (db) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dbsize; i++) {
 			int d;
 
@@ -993,6 +1009,12 @@ int  radeon_match_mode(struct radeonfb_i
 				candidate = &db[i];
 				distance = d;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		db = NULL;
 		/* If we have a scaler, we allow any mode from the database */
diff -u -p a/video/aty/aty128fb.c b/video/aty/aty128fb.c
--- a/video/aty/aty128fb.c
+++ b/video/aty/aty128fb.c
@@ -608,10 +608,21 @@ static void do_wait_for_fifo(u16 entries
 	int i;
 
 	for (;;) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 2000000; i++) {
 			par->fifo_slots = aty_ld_le32(GUI_STAT) & 0x0fff;
 			if (par->fifo_slots >= entries)
 				return;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		aty128_reset_engine(par);
 	}
@@ -625,12 +636,23 @@ static void wait_for_idle(struct aty128f
 	do_wait_for_fifo(64, par);
 
 	for (;;) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 2000000; i++) {
 			if (!(aty_ld_le32(GUI_STAT) & (1 << 31))) {
 				aty128_flush_pixel_cache(par);
 				par->blitter_may_be_busy = 0;
 				return;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		aty128_reset_engine(par);
 	}
diff -u -p a/video/atafb_iplan2p8.c b/video/atafb_iplan2p8.c
--- a/video/atafb_iplan2p8.c
+++ b/video/atafb_iplan2p8.c
@@ -69,11 +69,22 @@ void atafb_iplan2p8_copyarea(struct fb_i
 				d = (u32 *)dst;
 				w *= BPL / 2;
 				l = next_line - w * 4;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = height; j > 0; j--) {
 					for (i = w; i > 0; i--)
 						*d++ = *s++;
 					s = (u32 *)((u8 *)s + l);
 					d = (u32 *)((u8 *)d + l);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 			if (width & 15)
@@ -95,11 +106,22 @@ void atafb_iplan2p8_copyarea(struct fb_i
 				d = (u32 *)dst;
 				w *= BPL / 2;
 				l = next_line - w * 4;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = height; j > 0; j--) {
 					for (i = w; i > 0; i--)
 						*--d = *--s;
 					s = (u32 *)((u8 *)s - l);
 					d = (u32 *)((u8 *)d - l);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 			if (sx & 15)
@@ -127,6 +149,11 @@ void atafb_iplan2p8_copyarea(struct fb_i
 			if ((sx + width) & 15)
 				f |= 2;
 			w >>= 4;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = height; i; i--) {
 				src32 = (u32 *)src;
 				dst32 = (u32 *)dst;
@@ -143,6 +170,11 @@ void atafb_iplan2p8_copyarea(struct fb_i
 					pval[3] = dst32[3] & mask;
 				}
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = w; j > 0; j--) {
 					v = *src32++;
 					v1 = v & mask;
@@ -160,6 +192,12 @@ void atafb_iplan2p8_copyarea(struct fb_i
 					v1 = v & mask;
 					*dst32++ = pval[3] | (v1 >> 8);
 					pval[3] = (v ^ v1) << 8;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				if (f & 2) {
@@ -171,6 +209,12 @@ void atafb_iplan2p8_copyarea(struct fb_i
 
 				src += next_line;
 				dst += next_line;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
 			u32 *src32, *dst32;
@@ -190,6 +234,11 @@ void atafb_iplan2p8_copyarea(struct fb_i
 				w += 8;
 			}
 			w >>= 4;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = height; i; i--) {
 				src32 = (u32 *)src;
 				dst32 = (u32 *)dst;
@@ -206,6 +255,11 @@ void atafb_iplan2p8_copyarea(struct fb_i
 					pval[3] = (*--src32 >> 8) & mask;
 				}
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = w; j > 0; j--) {
 					v = *--src32;
 					v1 = v & mask;
@@ -223,6 +277,12 @@ void atafb_iplan2p8_copyarea(struct fb_i
 					v1 = v & mask;
 					*--dst32 = pval[3] | (v1 << 8);
 					pval[3] = (v ^ v1) >> 8;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				if (!(f & 2)) {
@@ -234,6 +294,12 @@ void atafb_iplan2p8_copyarea(struct fb_i
 
 				src -= next_line;
 				dst -= next_line;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -252,9 +318,20 @@ void atafb_iplan2p8_fillrect(struct fb_i
 
 		expand8_col2mask(color, cval);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = height; i; i--) {
 			fill8_col(dest8, cval);
 			dest8 += next_line;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dest += BPL / 2;
 		width -= 8;
@@ -265,9 +342,20 @@ void atafb_iplan2p8_fillrect(struct fb_i
 	if (rows) {
 		u32 *d = dest;
 		u32 off = next_line - rows * BPL * 2;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = height; i; i--) {
 			d = fill16_col(d, rows, cval);
 			d = (u32 *)((long)d + off);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dest += rows * BPL / 2;
 		width &= 15;
@@ -278,9 +366,20 @@ void atafb_iplan2p8_fillrect(struct fb_i
 
 		expand8_col2mask(color, cval);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = height; i; i--) {
 			fill8_col(dest8, cval);
 			dest8 += next_line;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -305,6 +404,11 @@ void atafb_iplan2p8_linefill(struct fb_i
 		data16 = (const u16 *)data;
 		expand16_2col2mask(fgcolor, bgcolor, fgm, bgm);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (rows = width / 16; rows; rows--) {
 			u16 d = *data16++;
 			m = d | ((u32)d << 16);
@@ -312,6 +416,12 @@ void atafb_iplan2p8_linefill(struct fb_i
 			*dest++ = (m & fgm[1]) ^ bgm[1];
 			*dest++ = (m & fgm[2]) ^ bgm[2];
 			*dest++ = (m & fgm[3]) ^ bgm[3];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		data = (const u8 *)data16;
diff -u -p a/video/sm501fb.c b/video/sm501fb.c
--- a/video/sm501fb.c
+++ b/video/sm501fb.c
@@ -282,9 +282,20 @@ static void sm501fb_setup_gamma(struct s
 	int offset;
 
 	/* set gamma values */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < 256 * 4; offset += 4) {
 		smc501_writel(value, fbi->regs + palette + offset);
 		value += 0x010101; 	/* Advance RGB by 1,1,1.*/
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1128,7 +1139,17 @@ static int sm501fb_cursor(struct fb_info
 		for (op = 0; op < (64*64*2)/8; op+=4)
 			smc501_writel(0x0, dst + op);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (y = 0; y < cursor->image.height; y++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (x = 0; x < cursor->image.width; x++) {
 				if ((x % 8) == 0) {
 					dcol = *pcol++;
@@ -1145,8 +1166,20 @@ static int sm501fb_cursor(struct fb_info
 					op |= readb(dst + (x / 4));
 					writeb(op, dst + (x / 4));
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			dst += (64*2)/8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/video/atafb.c b/video/atafb.c
--- a/video/atafb.c
+++ b/video/atafb.c
@@ -1135,6 +1135,11 @@ static int falcon_decode_var(struct fb_v
 			int i;
 			unsigned long pcl = ULONG_MAX;
 			pclock = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 1; i <= 4; i *= 2) {
 				if (f25.t * i >= var->pixclock &&
 				    f25.t * i < pcl) {
@@ -1151,6 +1156,12 @@ static int falcon_decode_var(struct fb_v
 					pcl = fext.t * i;
 					pclock = &fext;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if (!pclock)
 				return -EINVAL;
diff -u -p a/video/fm2fb.c b/video/fm2fb.c
--- a/video/fm2fb.c
+++ b/video/fm2fb.c
@@ -262,6 +262,11 @@ static int __devinit fm2fb_probe(struct
 
 	/* make EBU color bars on display */
 	ptr = (unsigned long *)fb_fix.smem_start;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < 576; y++) {
 		for (x = 0; x < 96; x++) *ptr++ = 0xffffff;/* white */
 		for (x = 0; x < 96; x++) *ptr++ = 0xffff00;/* yellow */
@@ -271,6 +276,12 @@ static int __devinit fm2fb_probe(struct
 		for (x = 0; x < 96; x++) *ptr++ = 0xff0000;/* red */
 		for (x = 0; x < 96; x++) *ptr++ = 0x0000ff;/* blue */
 		for (x = 0; x < 96; x++) *ptr++ = 0x000000;/* black */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	fm2fb_blank(0, info);
 
diff -u -p a/video/console/fbcon.c b/video/console/fbcon.c
--- a/video/console/fbcon.c
+++ b/video/console/fbcon.c
@@ -240,6 +240,11 @@ static void fbcon_rotate_all(struct fb_i
 	if (!ops || ops->currcon < 0 || rotate > 3)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = first_fb_vc; i <= last_fb_vc; i++) {
 		vc = vc_cons[i].d;
 		if (!vc || vc->vc_mode != KD_TEXT ||
@@ -248,6 +253,12 @@ static void fbcon_rotate_all(struct fb_i
 
 		p = &fb_display[vc->vc_num];
 		p->con_rotate = rotate;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	fbcon_set_all_vcs(info);
@@ -470,11 +481,22 @@ static int __init fb_console_setup(char
 		if (!strncmp(options, "map:", 4)) {
 			options += 4;
 			if (*options) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0, j = 0; i < MAX_NR_CONSOLES; i++) {
 					if (!options[j])
 						j = 0;
 					con2fb_map_boot[i] =
 						(options[j++]-'0') % FB_MAX;
+						if (_cur < timeout) {
+						rdstcll(_cur);
+						}
+						else {
+						break;
+						}
 				}
 
 				fbcon_map_override();
@@ -512,9 +534,20 @@ static int search_fb_in_map(int idx)
 {
 	int i, retval = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = first_fb_vc; i <= last_fb_vc; i++) {
 		if (con2fb_map[i] == idx)
 			retval = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return retval;
 }
@@ -523,9 +556,20 @@ static int search_for_mapped_con(void)
 {
 	int i, retval = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = first_fb_vc; i <= last_fb_vc; i++) {
 		if (con2fb_map[i] != -1)
 			retval = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return retval;
 }
@@ -574,8 +618,19 @@ static int fbcon_takeover(int show_logo)
 				fbcon_is_default);
 
 	if (err) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = first_fb_vc; i <= last_fb_vc; i++) {
 			con2fb_map[i] = -1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		info_idx = -1;
 	} else {
@@ -634,9 +689,20 @@ static void fbcon_prepare_logo(struct vc
 	if (r == q) {
 		/* We can scroll screen down */
 		r = q - step - cols;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cnt = rows - logo_lines; cnt > 0; cnt--) {
 			scr_memcpyw(r + step, r, vc->vc_size_row);
 			r -= cols;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!save) {
 			int lines;
@@ -2217,12 +2283,23 @@ static int fbcon_switch(struct vc_data *
 	 *
 	 * info->currcon = vc->vc_num;
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < FB_MAX; i++) {
 		if (registered_fb[i] != NULL && registered_fb[i]->fbcon_par) {
 			struct fbcon_ops *o = registered_fb[i]->fbcon_par;
 
 			o->currcon = vc->vc_num;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	memset(&var, 0, sizeof(struct fb_var_screeninfo));
 	display_to_var(&var, p);
@@ -2422,38 +2499,93 @@ static int fbcon_get_font(struct vc_data
 
 	if (font->width <= 8) {
 		j = vc->vc_font.height;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < font->charcount; i++) {
 			memcpy(data, fontdata, j);
 			memset(data + j, 0, 32 - j);
 			data += 32;
 			fontdata += j;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else if (font->width <= 16) {
 		j = vc->vc_font.height * 2;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < font->charcount; i++) {
 			memcpy(data, fontdata, j);
 			memset(data + j, 0, 64 - j);
 			data += 64;
 			fontdata += j;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else if (font->width <= 24) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < font->charcount; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < vc->vc_font.height; j++) {
 				*data++ = fontdata[0];
 				*data++ = fontdata[1];
 				*data++ = fontdata[2];
 				fontdata += sizeof(u32);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			memset(data, 0, 3 * (32 - j));
 			data += 3 * (32 - j);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		j = vc->vc_font.height * 4;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < font->charcount; i++) {
 			memcpy(data, fontdata, j);
 			memset(data + j, 0, 128 - j);
 			data += 128;
 			fontdata += j;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 0;
@@ -2621,8 +2753,19 @@ static int fbcon_set_font(struct vc_data
 	FNTSIZE(new_data) = size;
 	FNTCHARCNT(new_data) = charcount;
 	REFCOUNT(new_data) = 0;	/* usage counter */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i< charcount; i++) {
 		memcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Since linux has a nice crc32 function use it for counting font
@@ -2686,6 +2829,11 @@ static int fbcon_set_palette(struct vc_d
 
 	depth = fb_get_color_depth(&info->var, &info->fix);
 	if (depth > 3) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = j = 0; i < 16; i++) {
 			k = table[i];
 			val = vc->vc_palette[j++];
@@ -2694,6 +2842,12 @@ static int fbcon_set_palette(struct vc_d
 			palette_green[k] = (val << 8) | val;
 			val = vc->vc_palette[j++];
 			palette_blue[k] = (val << 8) | val;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		palette_cmap.len = 16;
 		palette_cmap.start = 0;
@@ -2957,6 +3111,11 @@ static void fbcon_set_all_vcs(struct fb_
 	if (!ops || ops->currcon < 0)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = first_fb_vc; i <= last_fb_vc; i++) {
 		vc = vc_cons[i].d;
 		if (!vc || vc->vc_mode != KD_TEXT ||
@@ -2976,6 +3135,12 @@ static void fbcon_set_all_vcs(struct fb_
 		cols /= vc->vc_font.width;
 		rows /= vc->vc_font.height;
 		vc_resize(vc, cols, rows);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (fg != -1)
@@ -3045,9 +3210,20 @@ static int fbcon_fb_unbind(int idx)
 	}
 
 	if (new_idx != -1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = first_fb_vc; i <= last_fb_vc; i++) {
 			if (con2fb_map[i] == idx)
 				set_con2fb_map(i, new_idx, 0);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	} else
 		ret = fbcon_unbind();
@@ -3061,9 +3237,20 @@ static int fbcon_fb_unregistered(struct
 	int i, idx;
 
 	idx = info->node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = first_fb_vc; i <= last_fb_vc; i++) {
 		if (con2fb_map[i] == idx)
 			con2fb_map[i] = -1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (idx == info_idx) {
@@ -3078,9 +3265,20 @@ static int fbcon_fb_unregistered(struct
 	}
 
 	if (info_idx != -1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = first_fb_vc; i <= last_fb_vc; i++) {
 			if (con2fb_map[i] == -1)
 				con2fb_map[i] = info_idx;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
@@ -3157,9 +3355,20 @@ static int fbcon_fb_registered(struct fb
 		if (info_idx != -1)
 			ret = do_fbcon_takeover(1);
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = first_fb_vc; i <= last_fb_vc; i++) {
 			if (con2fb_map_boot[i] == idx)
 				set_con2fb_map(i, idx, 0);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
@@ -3195,6 +3404,11 @@ static void fbcon_new_modelist(struct fb
 	struct fb_var_screeninfo var;
 	const struct fb_videomode *mode;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = first_fb_vc; i <= last_fb_vc; i++) {
 		if (registered_fb[con2fb_map[i]] != info)
 			continue;
@@ -3206,6 +3420,12 @@ static void fbcon_new_modelist(struct fb
 					    &info->modelist);
 		fb_videomode_to_var(&var, mode);
 		fbcon_set_disp(info, &var, vc->vc_num);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -3218,6 +3438,11 @@ static void fbcon_get_requirement(struct
 	if (caps->flags) {
 		int i, charcnt;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = first_fb_vc; i <= last_fb_vc; i++) {
 			vc = vc_cons[i].d;
 			if (vc && vc->vc_mode == KD_TEXT &&
@@ -3230,6 +3455,12 @@ static void fbcon_get_requirement(struct
 				if (caps->len < charcnt)
 					caps->len = charcnt;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	} else {
 		vc = vc_cons[fg_console].d;
@@ -3552,6 +3783,11 @@ static void fbcon_exit(void)
 	kfree((void *)softback_buf);
 	softback_buf = 0UL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < FB_MAX; i++) {
 		int pending = 0;
 
@@ -3566,9 +3802,20 @@ static void fbcon_exit(void)
 		DPRINTK("fbcon: %s pending work\n", (pending ? "canceled" :
 			"no"));
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = first_fb_vc; j <= last_fb_vc; j++) {
 			if (con2fb_map[j] == i)
 				mapped = 1;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (mapped) {
@@ -3588,6 +3835,12 @@ static void fbcon_exit(void)
 			if (info->queue.func == fb_flashcursor)
 				info->queue.func = NULL;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	fbcon_has_exited = 1;
diff -u -p a/video/console/fbcon_cw.c b/video/console/fbcon_cw.c
--- a/video/console/fbcon_cw.c
+++ b/video/console/fbcon_cw.c
@@ -29,7 +29,17 @@ static void cw_update_attr(u8 *dst, u8 *
 	int width = (vc->vc_font.height + 7) >> 3;
 	u8 c, t = 0, msk = ~(0xff >> offset);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < vc->vc_font.width; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < width; j++) {
 			c = *src;
 			if (attribute & FBCON_ATTRIBUTE_UNDERLINE && !j)
@@ -41,6 +51,18 @@ static void cw_update_attr(u8 *dst, u8 *
 			src++;
 			*dst++ = c;
 			t = c;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
diff -u -p a/video/console/vgacon.c b/video/console/vgacon.c
--- a/video/console/vgacon.c
+++ b/video/console/vgacon.c
@@ -472,10 +472,21 @@ static const char *vgacon_startup(void)
 				 * DAC entries.
 				 */
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < 16; i++) {
 					inb_p(VGA_IS1_RC);
 					outb_p(i, VGA_ATT_W);
 					outb_p(i, VGA_ATT_W);
+					if (_cur < timeout) {
+				rdstcll(_cur);
+					}
+					else {
+				break;
+					}
 				}
 				outb_p(0x20, VGA_ATT_W);
 
@@ -483,11 +494,22 @@ static const char *vgacon_startup(void)
 				 * Now set the DAC registers back to their
 				 * default values
 				 */
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < 16; i++) {
 					outb_p(color_table[i], VGA_PEL_IW);
 					outb_p(default_red[i], VGA_PEL_D);
 					outb_p(default_grn[i], VGA_PEL_D);
 					outb_p(default_blu[i], VGA_PEL_D);
+					if (_cur < timeout) {
+				rdstcll(_cur);
+					}
+					else {
+				break;
+					}
 				}
 			}
 		} else {
@@ -851,11 +873,22 @@ static void vga_set_palette(struct vc_da
 	int i, j;
 
 	vga_w(state.vgabase, VGA_PEL_MSK, 0xff);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = j = 0; i < 16; i++) {
 		vga_w(state.vgabase, VGA_PEL_IW, table[i]);
 		vga_w(state.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
 		vga_w(state.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
 		vga_w(state.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -994,11 +1027,22 @@ static void vga_pal_blank(struct vgastat
 	int i;
 
 	vga_w(state->vgabase, VGA_PEL_MSK, 0xff);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i++) {
 		vga_w(state->vgabase, VGA_PEL_IW, i);
 		vga_w(state->vgabase, VGA_PEL_D, 0);
 		vga_w(state->vgabase, VGA_PEL_D, 0);
 		vga_w(state->vgabase, VGA_PEL_D, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1124,15 +1168,39 @@ static int vgacon_do_font_op(struct vgas
 	raw_spin_unlock_irq(&vga_lock);
 
 	if (arg) {
-		if (set)
-			for (i = 0; i < cmapsz; i++) {
-				vga_writeb(arg[i], charmap + i);
-				cond_resched();
+		if (set) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (i = 0; i < cmapsz; i++) {
+		vga_writeb(arg[i], charmap + i);
+		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+				}
 			}
-		else
-			for (i = 0; i < cmapsz; i++) {
+		else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (i = 0; i < cmapsz; i++) {
 				arg[i] = vga_readb(charmap + i);
 				cond_resched();
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
+		break;
+				}
+				}
 			}
 
 		/*
@@ -1143,15 +1211,39 @@ static int vgacon_do_font_op(struct vgas
 		if (ch512) {
 			charmap += 2 * cmapsz;
 			arg += cmapsz;
-			if (set)
-				for (i = 0; i < cmapsz; i++) {
-					vga_writeb(arg[i], charmap + i);
-					cond_resched();
+			if (set) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					for (i = 0; i < cmapsz; i++) {
+				vga_writeb(arg[i], charmap + i);
+				cond_resched();
+				if (_cur < timeout) {
+		rdstcll(_cur);
 				}
-			else
-				for (i = 0; i < cmapsz; i++) {
+				else {
+		break;
+				}
+					}
+				}
+			else {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					for (i = 0; i < cmapsz; i++) {
 					arg[i] = vga_readb(charmap + i);
 					cond_resched();
+					if (_cur < timeout) {
+				rdstcll(_cur);
+					}
+					else {
+				break;
+					}
+					}
 				}
 		}
 	}
@@ -1193,6 +1285,11 @@ static int vgacon_do_font_op(struct vgas
 	raw_spin_unlock_irq(&vga_lock);
 
 	if (clear_attribs) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < MAX_NR_CONSOLES; i++) {
 			struct vc_data *c = vc_cons[i].d;
 			if (c && c->vc_sw == &vga_con) {
@@ -1202,6 +1299,12 @@ static int vgacon_do_font_op(struct vgas
 				clear_buffer_attributes(c);
 				c->vc_hi_font_mask = ch512 ? 0x0800 : 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 0;
@@ -1250,6 +1353,11 @@ static int vgacon_adjust_height(struct v
 	raw_spin_unlock_irq(&vga_lock);
 	vga_video_font_height = fontheight;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_NR_CONSOLES; i++) {
 		struct vc_data *c = vc_cons[i].d;
 
@@ -1263,6 +1371,12 @@ static int vgacon_adjust_height(struct v
 			c->vc_font.height = fontheight;
 			vc_resize(c, 0, rows);	/* Adjust console size */
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/video/console/fbcon_ccw.c b/video/console/fbcon_ccw.c
--- a/video/console/fbcon_ccw.c
+++ b/video/console/fbcon_ccw.c
@@ -36,7 +36,17 @@ static void ccw_update_attr(u8 *dst, u8
 	if (offset > mod)
 		msk1 |= 0x01;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < vc->vc_font.width; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < width; j++) {
 			c = *src;
 
@@ -55,6 +65,18 @@ static void ccw_update_attr(u8 *dst, u8
 				c = ~c;
 			src++;
 			*dst++ = c;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
diff -u -p a/video/console/fonts.c b/video/console/fonts.c
--- a/video/console/fonts.c
+++ b/video/console/fonts.c
@@ -117,7 +117,12 @@ const struct font_desc *get_default_font
 
     g = NULL;
     cc = -10000;
-    for(i=0; i<num_fonts; i++) {
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for(i=0; i<num_fonts; i++) {
 	f = fonts[i];
 	c = f->pref;
 #if defined(__mc68000__)
@@ -141,6 +146,12 @@ const struct font_desc *get_default_font
 	    cc = c;
 	    g = f;
 	}
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
     return g;
 }
diff -u -p a/video/console/mdacon.c b/video/console/mdacon.c
--- a/video/console/mdacon.c
+++ b/video/console/mdacon.c
@@ -257,9 +257,20 @@ static int mda_detect(void)
 	
 	p_save = q_save = inb_p(mda_status_port) & MDA_STATUS_VSYNC;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count=0; count < 50000 && p_save == q_save; count++) {
 		q_save = inb(mda_status_port) & MDA_STATUS_VSYNC;
 		udelay(2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (p_save != q_save) {
diff -u -p a/video/console/fbcon_ud.c b/video/console/fbcon_ud.c
--- a/video/console/fbcon_ud.c
+++ b/video/console/fbcon_ud.c
@@ -32,6 +32,11 @@ static void ud_update_attr(u8 *dst, u8 *
 
 	offset = offset * width;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < cellsize; i++) {
 		c = src[i];
 		if (attribute & FBCON_ATTRIBUTE_UNDERLINE && i < offset)
@@ -41,6 +46,12 @@ static void ud_update_attr(u8 *dst, u8 *
 		if (attribute & FBCON_ATTRIBUTE_REVERSE)
 			c = ~c;
 		dst[i] = c;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/console/bitblit.c b/video/console/bitblit.c
--- a/video/console/bitblit.c
+++ b/video/console/bitblit.c
@@ -31,6 +31,11 @@ static void update_attr(u8 *dst, u8 *src
 	u8 c;
 
 	offset = cellsize - (offset * width);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < cellsize; i++) {
 		c = src[i];
 		if (attribute & FBCON_ATTRIBUTE_UNDERLINE && i >= offset)
@@ -40,6 +45,12 @@ static void update_attr(u8 *dst, u8 *src
 		if (attribute & FBCON_ATTRIBUTE_REVERSE)
 			c = ~c;
 		dst[i] = c;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/console/newport_con.c b/video/console/newport_con.c
--- a/video/console/newport_con.c
+++ b/video/console/newport_con.c
@@ -89,12 +89,23 @@ static inline void newport_init_cmap(voi
 {
 	unsigned short i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i++) {
 		newport_bfwait(npregs);
 		newport_cmap_setaddr(npregs, color_table[i]);
 		newport_cmap_setrgb(npregs,
 				    default_red[i],
 				    default_grn[i], default_blu[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -111,11 +122,22 @@ static const struct linux_logo *newport_
 	clut = logo->clut;
 	data = logo->data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < logo->clutsize; i++) {
 		newport_bfwait(npregs);
 		newport_cmap_setaddr(npregs, i + 0x20);
 		newport_cmap_setrgb(npregs, clut[0], clut[1], clut[2]);
 		clut += 3;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	newport_wait(npregs);
@@ -170,12 +192,23 @@ static void newport_reset(void)
 	newport_vc2_set(npregs, VC2_IREG_RADDR, treg);
 	npregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |
 			       NPORT_DMODE_W2 | VC2_PROTOCOL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 128; i++) {
 		newport_bfwait(npregs);
 		if (i == 92 || i == 94)
 			npregs->set.dcbdata0.byshort.s1 = 0xff00;
 		else
 			npregs->set.dcbdata0.byshort.s1 = 0x0000;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	newport_init_cmap();
@@ -210,12 +243,28 @@ static void newport_get_screensize(void)
 	newport_vc2_set(npregs, VC2_IREG_RADDR, ventry);
 	npregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |
 			       NPORT_DMODE_W2 | VC2_PROTOCOL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 128; i++) {
 		newport_bfwait(npregs);
 		linetable[i] = npregs->set.dcbdata0.byshort.s1;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	newport_xsize = newport_ysize = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(linetable) - 1 && linetable[i + 1]; i += 2) {
 		cols = 0;
 		newport_vc2_set(npregs, VC2_IREG_RADDR, linetable[i]);
@@ -236,6 +285,12 @@ static void newport_get_screensize(void)
 				newport_xsize = cols;
 			newport_ysize += linetable[i + 1];
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("NG1: Screensize %dx%d\n", newport_xsize, newport_ysize);
 }
@@ -424,6 +479,11 @@ static void newport_putcs(struct vc_data
 				 NPORT_DMODE0_STOPX | NPORT_DMODE0_ZPENAB |
 				 NPORT_DMODE0_L32);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i++, xpos += 8) {
 		p = &font_data[vc->vc_num][(scr_readw(s++) & 0xff) << 4];
 
@@ -436,6 +496,12 @@ static void newport_putcs(struct vc_data
 
 		/* Go, baby, go... */
 		RENDER(npregs, p);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 }
 
@@ -522,10 +588,21 @@ static int newport_set_font(int unit, st
 	REFCOUNT(new_data) = 0;	/* usage counter */
 
 	p = new_data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < op->charcount; i++) {
 		memcpy(p, data, h);
 		data += 32;
 		p += h;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* check if font is already used by other console */
@@ -634,7 +711,12 @@ static int newport_scroll(struct vc_data
 					vc->vc_size_row * (b - lines));
 		x = 0;
 		y = b - lines;
-		for (count = 0; count < (lines * vc->vc_cols); count++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (count = 0; count < (lines * vc->vc_cols); count++) {
 			if (scr_readw(d) != vc->vc_video_erase_char) {
 				newport_putc(vc, vc->vc_video_erase_char,
 					     y, x);
@@ -645,6 +727,12 @@ static int newport_scroll(struct vc_data
 				x = 0;
 				y++;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		x = vc->vc_cols - 1;
@@ -669,7 +757,12 @@ static int newport_scroll(struct vc_data
 					vc->vc_size_row * t);
 		x = 0;
 		y = t;
-		for (count = 0; count < (lines * vc->vc_cols); count++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (count = 0; count < (lines * vc->vc_cols); count++) {
 			if (scr_readw(d) != vc->vc_video_erase_char) {
 				newport_putc(vc, vc->vc_video_erase_char,
 					     y, x);
@@ -680,6 +773,12 @@ static int newport_scroll(struct vc_data
 				x = 0;
 				y++;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 1;
diff -u -p a/video/console/sticore.c b/video/console/sticore.c
--- a/video/console/sticore.c
+++ b/video/console/sticore.c
@@ -626,10 +626,21 @@ sti_search_font(struct sti_cooked_rom *r
 	struct sti_cooked_font *font;
 	int i = 0;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (font = rom->font_start; font; font = font->next_font, i++) {
 		if ((font->raw->width == width) &&
 		    (font->raw->height == height))
 			return i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/video/vgastate.c b/video/vgastate.c
--- a/video/vgastate.c
+++ b/video/vgastate.c
@@ -240,9 +240,20 @@ static void save_vga_mode(struct vgastat
 	
 	vga_r(state->vgabase, iobase + 0xa); 
 	vga_w(state->vgabase, VGA_ATT_W, 0x00);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < state->num_attr; i++) {
 		vga_r(state->vgabase, iobase + 0xa);
 		saved->attr[i] = vga_rattr(state->vgabase, i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	vga_r(state->vgabase, iobase + 0xa);
 	vga_w(state->vgabase, VGA_ATT_W, 0x20);
@@ -290,9 +301,20 @@ static void restore_vga_mode(struct vgas
 	for (i = 0; i < state->num_gfx; i++) 
 		vga_wgfx(state->vgabase, i, saved->gfx[i]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < state->num_attr; i++) {
 		vga_r(state->vgabase, iobase + 0xa);
 		vga_wattr(state->vgabase, i, saved->attr[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* reenable sequencer */
diff -u -p a/video/atafb_iplan2p2.c b/video/atafb_iplan2p2.c
--- a/video/atafb_iplan2p2.c
+++ b/video/atafb_iplan2p2.c
@@ -62,11 +62,22 @@ void atafb_iplan2p2_copyarea(struct fb_i
 				d = (u32 *)dst;
 				w *= BPL / 2;
 				l = next_line - w * 4;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = height; j > 0; j--) {
 					for (i = w; i > 0; i--)
 						*d++ = *s++;
 					s = (u32 *)((u8 *)s + l);
 					d = (u32 *)((u8 *)d + l);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 			if (width & 15)
@@ -88,11 +99,22 @@ void atafb_iplan2p2_copyarea(struct fb_i
 				d = (u32 *)dst;
 				w *= BPL / 2;
 				l = next_line - w * 4;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = height; j > 0; j--) {
 					for (i = w; i > 0; i--)
 						*--d = *--s;
 					s = (u32 *)((u8 *)s - l);
 					d = (u32 *)((u8 *)d - l);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 			if (sx & 15)
@@ -120,6 +142,11 @@ void atafb_iplan2p2_copyarea(struct fb_i
 			if ((sx + width) & 15)
 				f |= 2;
 			w >>= 4;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = height; i; i--) {
 				src32 = (u32 *)src;
 				dst32 = (u32 *)dst;
@@ -130,11 +157,22 @@ void atafb_iplan2p2_copyarea(struct fb_i
 					pval[0] = dst32[0] & mask;
 				}
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = w; j > 0; j--) {
 					v = *src32++;
 					v1 = v & mask;
 					*dst32++ = pval[0] | (v1 >> 8);
 					pval[0] = (v ^ v1) << 8;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				if (f & 2) {
@@ -143,6 +181,12 @@ void atafb_iplan2p2_copyarea(struct fb_i
 
 				src += next_line;
 				dst += next_line;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
 			u32 *src32, *dst32;
@@ -162,6 +206,11 @@ void atafb_iplan2p2_copyarea(struct fb_i
 				w += 8;
 			}
 			w >>= 4;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = height; i; i--) {
 				src32 = (u32 *)src;
 				dst32 = (u32 *)dst;
@@ -172,11 +221,22 @@ void atafb_iplan2p2_copyarea(struct fb_i
 					pval[0] = (*--src32 >> 8) & mask;
 				}
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = w; j > 0; j--) {
 					v = *--src32;
 					v1 = v & mask;
 					*--dst32 = pval[0] | (v1 << 8);
 					pval[0] = (v ^ v1) >> 8;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				if (!(f & 2)) {
@@ -185,6 +245,12 @@ void atafb_iplan2p2_copyarea(struct fb_i
 
 				src -= next_line;
 				dst -= next_line;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -203,9 +269,20 @@ void atafb_iplan2p2_fillrect(struct fb_i
 
 		expand8_col2mask(color, cval);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = height; i; i--) {
 			fill8_col(dest8, cval);
 			dest8 += next_line;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dest += BPL / 2;
 		width -= 8;
@@ -216,9 +293,20 @@ void atafb_iplan2p2_fillrect(struct fb_i
 	if (rows) {
 		u32 *d = dest;
 		u32 off = next_line - rows * BPL * 2;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = height; i; i--) {
 			d = fill16_col(d, rows, cval);
 			d = (u32 *)((long)d + off);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dest += rows * BPL / 2;
 		width &= 15;
@@ -229,9 +317,20 @@ void atafb_iplan2p2_fillrect(struct fb_i
 
 		expand8_col2mask(color, cval);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = height; i; i--) {
 			fill8_col(dest8, cval);
 			dest8 += next_line;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -256,10 +355,21 @@ void atafb_iplan2p2_linefill(struct fb_i
 		data16 = (const u16 *)data;
 		expand16_2col2mask(fgcolor, bgcolor, fgm, bgm);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (rows = width / 16; rows; rows--) {
 			u16 d = *data16++;
 			m = d | ((u32)d << 16);
 			*dest++ = (m & fgm[0]) ^ bgm[0];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		data = (const u8 *)data16;
diff -u -p a/video/cg3.c b/video/cg3.c
--- a/video/cg3.c
+++ b/video/cg3.c
@@ -331,10 +331,26 @@ static int __devinit cg3_do_default_mode
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = cg3_regvals[type]; *p; p += 2) {
 		u8 __iomem *regp = &((u8 __iomem *)par->regs)[p[0]];
 		sbus_writeb(p[1], regp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = cg3_dacvals; *p; p += 2) {
 		u8 __iomem *regp;
 
@@ -342,6 +358,12 @@ static int __devinit cg3_do_default_mode
 		sbus_writeb(p[0], regp);
 		regp = (u8 __iomem *)&par->regs->cmap.control;
 		sbus_writeb(p[1], regp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/video/mb862xx/mb862xxfb_accel.c b/video/mb862xx/mb862xxfb_accel.c
--- a/video/mb862xx/mb862xxfb_accel.c
+++ b/video/mb862xx/mb862xxfb_accel.c
@@ -141,7 +141,12 @@ static void mb86290fb_imageblit8(u32 *cm
 
 	while (i < height) {
 		ptr = line;
-		for (j = 0; j < step; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (j = 0; j < step; j++) {
 			cmd[3 + i * step + j] =
 			    (((u32 *) (info->pseudo_palette))[*ptr]) & 0xffff;
 			ptr++;
@@ -149,6 +154,12 @@ static void mb86290fb_imageblit8(u32 *cm
 			    ((((u32 *) (info->
 					pseudo_palette))[*ptr]) & 0xffff) << 16;
 			ptr++;
+			if (_cur < timeout) {
+			    rdstcll(_cur);
+			}
+			else {
+			    break;
+			}
 		}
 
 		line += bytes;
diff -u -p a/video/s1d13xxxfb.c b/video/s1d13xxxfb.c
--- a/video/s1d13xxxfb.c
+++ b/video/s1d13xxxfb.c
@@ -119,14 +119,25 @@ s1d13xxxfb_runinit(struct s1d13xxxfb_par
 {
 	int i;
 
-	for (i = 0; i < size; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (i = 0; i < size; i++) {
         	if ((initregs[i].addr == S1DREG_DELAYOFF) ||
 				(initregs[i].addr == S1DREG_DELAYON))
 			mdelay((int)initregs[i].value);
         	else {
 			s1d13xxxfb_writereg(par, initregs[i].addr, initregs[i].value);
 		}
-        }
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* make sure the hardware can cope with us */
 	mdelay(1);
diff -u -p a/video/hecubafb.c b/video/hecubafb.c
--- a/video/hecubafb.c
+++ b/video/hecubafb.c
@@ -106,8 +106,19 @@ static void hecubafb_dpy_update(struct h
 
 	apollo_send_command(par, APOLLO_START_NEW_IMG);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i < (DPY_W*DPY_H/8); i++) {
 		apollo_send_data(par, *(buf++));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	apollo_send_command(par, APOLLO_STOP_IMG_DATA);
diff -u -p a/video/w100fb.c b/video/w100fb.c
--- a/video/w100fb.c
+++ b/video/w100fb.c
@@ -260,11 +260,22 @@ static void w100_fifo_wait(int entries)
 	union rbbm_status_u status;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2000000; i++) {
 		status.val = readl(remapped_regs + mmRBBM_STATUS);
 		if (status.f.cmdfifo_avail >= entries)
 			return;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "w100fb: FIFO Timeout!\n");
 }
@@ -275,11 +286,22 @@ static int w100fb_sync(struct fb_info *i
 	union rbbm_status_u status;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2000000; i++) {
 		status.val = readl(remapped_regs + mmRBBM_STATUS);
 		if (!status.f.gui_active)
 			return 0;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "w100fb: Graphic engine timeout!\n");
 	return -EBUSY;
@@ -438,6 +460,11 @@ static struct w100_mode *w100fb_get_mode
 	unsigned int best_x = 0xffffffff, best_y = 0xffffffff;
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0 ; i < par->mach->num_modes ; i++) {
 		if (modelist[i].xres >= *x && modelist[i].yres >= *y &&
 				modelist[i].xres < best_x && modelist[i].yres < best_y) {
@@ -450,6 +477,12 @@ static struct w100_mode *w100fb_get_mode
 			best_y = modelist[i].xres;
 			mode = &modelist[i];
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (mode && saveval) {
diff -u -p a/video/vga16fb.c b/video/vga16fb.c
--- a/video/vga16fb.c
+++ b/video/vga16fb.c
@@ -263,6 +263,11 @@ static void vga16fb_clock_chip(struct vg
 	best = vgaclocks;
 	err = pixclock - best->pixclock;
 	if (err < 0) err = -err;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = vgaclocks + 1; ptr->pixclock; ptr++) {
 		int tmp;
 
@@ -272,6 +277,12 @@ static void vga16fb_clock_chip(struct vg
 			err = tmp;
 			best = ptr;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	par->misc |= best->misc;
 	par->clkdiv = best->seq_clock_mode;
@@ -595,8 +606,19 @@ static int vga16fb_set_par(struct fb_inf
 
 	/* write sequencer registers */
 	vga_io_wseq(VGA_SEQ_CLOCK_MODE, seq[VGA_SEQ_CLOCK_MODE] | 0x20);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 2; i < VGA_SEQ_C; i++) {
 		vga_io_wseq(i, seq[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	
 	/* synchronous reset off */
@@ -606,19 +628,52 @@ static int vga16fb_set_par(struct fb_inf
 	vga_io_wcrt(VGA_CRTC_V_SYNC_END, par->crtc[VGA_CRTC_V_SYNC_END]);
 
 	/* write CRT registers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < VGA_CRTC_REGS; i++) {
 		vga_io_wcrt(i, par->crtc[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	
 	/* write graphics controller registers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < VGA_GFX_C; i++) {
 		vga_io_wgfx(i, gdc[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	
 	/* write attribute controller registers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < VGA_ATT_C; i++) {
 		vga_io_r(VGA_IS1_RC);		/* reset flip-flop */
 		vga_io_wattr(i, atc[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Wait for screen to stabilize. */
@@ -789,11 +844,22 @@ static void vga_pal_blank(void)
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i<16; i++) {
 		outb_p(i, VGA_PEL_IW);
 		outb_p(0, VGA_PEL_D);
 		outb_p(0, VGA_PEL_D);
 		outb_p(0, VGA_PEL_D);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -851,9 +917,20 @@ static void vga_8planes_fillrect(struct
                         int x;
 
                         /* we can do memset... */
+                        unsigned long long delta = (cpu / khz / HZ) * 2;
+                        unsigned long long _start = 0;
+                        unsigned long long _cur = 0;
+                        unsigned long long timeout;
+                        timeout = rdstcll(start) + delta;
                         for (x = width; x > 0; --x) {
                                 writeb(rect->color, where);
                                 where++;
+                                if (_cur < timeout) {
+                                        rdstcll(_cur);
+                                }
+                                else {
+                                        break;
+                                }
                         }
                         where += line_ofs;
                 }
@@ -864,10 +941,21 @@ static void vga_8planes_fillrect(struct
                 oldop = setop(0x18);
                 oldsr = setsr(0xf);
                 setmask(0x0F);
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                timeout = rdstcll(start) + delta;
                 for (y = 0; y < rect->height; y++) {
                         rmw(where);
                         rmw(where+1);
                         where += info->fix.line_length;
+                        if (_cur < timeout) {
+                                rdstcll(_cur);
+                        }
+                        else {
+                                break;
+                        }
                 }
                 setcolor(oldcolor);
         }
@@ -919,9 +1007,20 @@ static void vga16fb_fillrect(struct fb_i
 				setmask(0xff);
 
 				while (height--) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					for (x = 0; x < width; x++) {
 						writeb(0, dst);
 						dst++;
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
 					}
 					dst += line_ofs;
 				}
@@ -935,9 +1034,20 @@ static void vga16fb_fillrect(struct fb_i
 
 				setmask(0xff);
 				while (height--) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					for (x = 0; x < width; x++) {
 						rmw(dst);
 						dst++;
+						if (_cur < timeout) {
+						rdstcll(_cur);
+						}
+						else {
+						break;
+						}
 					}
 					dst += line_ofs;
 				}
@@ -975,11 +1085,22 @@ static void vga_8planes_copyarea(struct
                 dest = info->screen_base + dx + area->dy * info->fix.line_length;
                 src = info->screen_base + sx + area->sy * info->fix.line_length;
                 while (height--) {
+                        unsigned long long delta = (cpu / khz / HZ) * 2;
+                        unsigned long long _start = 0;
+                        unsigned long long _cur = 0;
+                        unsigned long long timeout;
+                        timeout = rdstcll(start) + delta;
                         for (x = 0; x < width; x++) {
                                 readb(src);
                                 writeb(0, dest);
                                 src++;
                                 dest++;
+                                if (_cur < timeout) {
+                                        rdstcll(_cur);
+                                }
+                                else {
+                                        break;
+                                }
                         }
                         src += line_ofs;
                         dest += line_ofs;
@@ -991,11 +1112,22 @@ static void vga_8planes_copyarea(struct
                 src = info->screen_base + sx + width +
 			(area->sy + height - 1) * info->fix.line_length;
                 while (height--) {
+                        unsigned long long delta = (cpu / khz / HZ) * 2;
+                        unsigned long long _start = 0;
+                        unsigned long long _cur = 0;
+                        unsigned long long timeout;
+                        timeout = rdstcll(start) + delta;
                         for (x = 0; x < width; x++) {
                                 --src;
                                 --dest;
                                 readb(src);
                                 writeb(0, dest);
+                                if (_cur < timeout) {
+                        rdstcll(_cur);
+                                }
+                                else {
+                        break;
+                                }
                         }
                         src -= line_ofs;
                         dest -= line_ofs;
@@ -1066,11 +1198,22 @@ static void vga16fb_copyarea(struct fb_i
 				dst = info->screen_base + (dx/8) + dy * info->fix.line_length;
 				src = info->screen_base + (sx/8) + sy * info->fix.line_length;
 				while (height--) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					for (x = 0; x < width; x++) {
 						readb(src);
 						writeb(0, dst);
 						dst++;
 						src++;
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
 					}
 					src += line_ofs;
 					dst += line_ofs;
@@ -1081,11 +1224,22 @@ static void vga16fb_copyarea(struct fb_i
 				src = info->screen_base + (sx/8) + width + 
 					(sy + height  - 1) * info->fix.line_length;
 				while (height--) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					for (x = 0; x < width; x++) {
 						dst--;
 						src--;
 						readb(src);
 						writeb(0, dst);
+						if (_cur < timeout) {
+					rdstcll(_cur);
+						}
+						else {
+					break;
+						}
 					}
 					src -= line_ofs;
 					dst -= line_ofs;
@@ -1171,11 +1325,22 @@ static void vga_imageblit_expand(struct
 				readb(where); /* fill latches */
 				setmode(3);
 				wmb();
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (y = 0; y < image->height; y++) {
 					dst = where;
 					for (x = image->width/8; x--;) 
 						writeb(*cdat++, dst++);
 					where += info->fix.line_length;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				wmb();
 			} else {
@@ -1186,6 +1351,11 @@ static void vga_imageblit_expand(struct
 				selectmask();
 				
 				setmask(0xff);
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (y = 0; y < image->height; y++) {
 					dst = where;
 					for (x=image->width/8; x--;){
@@ -1198,6 +1368,12 @@ static void vga_imageblit_expand(struct
 						}
 					}
 					where += info->fix.line_length;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 		} else 
@@ -1231,7 +1407,17 @@ static void vga_imageblit_color(struct f
 			setop(0);
 			setmode(0);
 			
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (y = 0; y < image->height; y++) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (x = 0; x < image->width; x++) {
 					dst = where + x/8;
 
@@ -1242,8 +1428,20 @@ static void vga_imageblit_color(struct f
 					fb_writeb(0, dst);
 
 					cdat++;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				where += info->fix.line_length;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		break;
diff -u -p a/video/efifb.c b/video/efifb.c
--- a/video/efifb.c
+++ b/video/efifb.c
@@ -309,6 +309,11 @@ static int __init efifb_setup(char *opti
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt) continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < M_UNKNOWN; i++) {
 			if (!strcmp(this_opt, dmi_list[i].optname) &&
 					dmi_list[i].base != 0) {
@@ -317,6 +322,12 @@ static int __init efifb_setup(char *opti
 				screen_info.lfb_width = dmi_list[i].width;
 				screen_info.lfb_height = dmi_list[i].height;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!strncmp(this_opt, "base:", 5))
 			screen_info.lfb_base = simple_strtoul(this_opt+5, NULL, 0);
diff -u -p a/video/fbmon.c b/video/fbmon.c
--- a/video/fbmon.c
+++ b/video/fbmon.c
@@ -263,9 +263,20 @@ static int edid_checksum(unsigned char *
 	if (fix)
 		fix_edid(edid, fix);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < EDID_LENGTH; i++) {
 		csum += edid[i];
 		all_null |= edid[i];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (csum == 0x00 && all_null) {
@@ -283,9 +294,20 @@ static int edid_check_header(unsigned ch
 	if (fix)
 		fix_edid(edid, fix);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		if (edid[i] != edid_v1_header[i])
 			err = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return err;
@@ -524,6 +546,11 @@ static int get_std_timing(unsigned char
 	refresh = (block[1] & 0x3f) + 60;
 
 	DPRINTK("      %dx%d@%dHz\n", xres, yres, refresh);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < VESA_MODEDB_SIZE; i++) {
 		if (vesa_modes[i].xres == xres &&
 		    vesa_modes[i].yres == yres &&
@@ -532,6 +559,12 @@ static int get_std_timing(unsigned char
 			mode->flag |= FB_MODE_IS_STANDARD;
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	calc_mode_timings(xres, yres, refresh, mode);
 	return 1;
@@ -623,6 +656,11 @@ static struct fb_videomode *fb_create_mo
 
 	DPRINTK("   Detailed Timings\n");
 	block = edid + DETAILED_TIMING_DESCRIPTIONS_START;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++, block+= DETAILED_TIMING_DESCRIPTION_SIZE) {
 		if (!(block[0] == 0x00 && block[1] == 0x00)) {
 			get_detailed_timing(block, &mode[num]);
@@ -632,6 +670,12 @@ static struct fb_videomode *fb_create_mo
 			}
 			num++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DPRINTK("   Supported VESA Modes\n");
@@ -644,9 +688,20 @@ static struct fb_videomode *fb_create_mo
 		num += get_std_timing(block, &mode[num], ver, rev);
 
 	block = edid + DETAILED_TIMING_DESCRIPTIONS_START;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++, block+= DETAILED_TIMING_DESCRIPTION_SIZE) {
 		if (block[0] == 0x00 && block[1] == 0x00 && block[3] == 0xfa)
 			num += get_dst_timing(block + 5, &mode[num], ver, rev);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/* Yikes, EDID data is totally useless */
@@ -712,6 +767,11 @@ static int fb_get_monitor_limits(unsigne
 		}
 
 		retval = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < num_modes; i++) {
 			mode = &modes[i];
 			pixclock = PICOS2KHZ(modes[i].pixclock) * 1000;
@@ -747,6 +807,12 @@ static int fb_get_monitor_limits(unsigne
 
 			if (specs->vfmin == 0 || specs->vfmin > hz)
 				specs->vfmin = hz;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		DPRINTK("Extrapolated\n");
 		fb_destroy_modedb(modes);
@@ -891,6 +957,11 @@ int fb_parse_edid(unsigned char *edid, s
 
 	block = edid + DETAILED_TIMING_DESCRIPTIONS_START;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++, block += DETAILED_TIMING_DESCRIPTION_SIZE) {
 		if (edid_is_timing_block(block)) {
 			var->xres = var->xres_virtual = H_ACTIVE;
@@ -914,6 +985,12 @@ int fb_parse_edid(unsigned char *edid, s
 				var->sync |= FB_SYNC_VERT_HIGH_ACT;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 1;
 }
@@ -946,6 +1023,11 @@ void fb_edid_to_monspecs(unsigned char *
 	parse_vendor_block(edid + ID_MANUFACTURER_NAME, specs);
 
 	block = edid + DETAILED_TIMING_DESCRIPTIONS_START;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++, block += DETAILED_TIMING_DESCRIPTION_SIZE) {
 		if (edid_is_serial_block(block)) {
 			copy_string(block, specs->serial_no);
@@ -957,6 +1039,12 @@ void fb_edid_to_monspecs(unsigned char *
 			copy_string(block, specs->monitor);
 			DPRINTK("   Monitor Name: %s\n", specs->monitor);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DPRINTK("   Display Characteristics:\n");
@@ -1010,12 +1098,24 @@ void fb_edid_add_monspecs(unsigned char
 	while (pos < edid[2]) {
 		u8 len = edid[pos] & 0x1f, type = (edid[pos] >> 5) & 7;
 		pr_debug("Data block %u of %u bytes\n", type, len);
-		if (type == 2)
-			for (i = pos; i < pos + len; i++) {
-				u8 idx = edid[pos + i] & 0x7f;
-				svd[svd_n++] = idx;
-				pr_debug("N%sative mode #%d\n",
-					 edid[pos + i] & 0x80 ? "" : "on-n", idx);
+		if (type == 2) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (i = pos; i < pos + len; i++) {
+					u8 idx = edid[pos + i] & 0x7f;
+					svd[svd_n++] = idx;
+					pr_debug("N%sative mode #%d\n",
+					edid[pos + i] & 0x80 ? "" : "on-n", idx);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 			}
 		pos += len + 1;
 	}
@@ -1041,13 +1141,29 @@ void fb_edid_add_monspecs(unsigned char
 
 	memcpy(m, specs->modedb, specs->modedb_len * sizeof(struct fb_videomode));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = specs->modedb_len; i < specs->modedb_len + num; i++) {
 		get_detailed_timing(edid + edt[i - specs->modedb_len], &m[i]);
 		if (i == specs->modedb_len)
 			m[i].flag |= FB_MODE_IS_FIRST;
 		pr_debug("Adding %ux%u@%u\n", m[i].xres, m[i].yres, m[i].refresh);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = specs->modedb_len + num; i < specs->modedb_len + num + svd_n; i++) {
 		int idx = svd[i - specs->modedb_len - num];
 		if (!idx || idx > 63) {
@@ -1059,6 +1175,12 @@ void fb_edid_add_monspecs(unsigned char
 			pr_debug("Adding SVD #%d: %ux%u@%u\n", idx,
 				 m[i].xres, m[i].yres, m[i].refresh);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(specs->modedb);
diff -u -p a/video/cobalt_lcdfb.c b/video/cobalt_lcdfb.c
--- a/video/cobalt_lcdfb.c
+++ b/video/cobalt_lcdfb.c
@@ -109,10 +109,21 @@ static void lcd_clear(struct fb_info *in
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		udelay(150);
 
 		lcd_write_control(info, LCD_PRERESET);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	udelay(150);
diff -u -p a/video/asiliantfb.c b/video/asiliantfb.c
--- a/video/asiliantfb.c
+++ b/video/asiliantfb.c
@@ -134,6 +134,11 @@ static void asiliant_calc_dclk2(u32 *ppi
 
 	/* This expresses the constraint that 150kHz <= Fref/n <= 5Mhz,
 	 * together with 3 <= n <= 257. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 3; n <= 257; n++) {
 		unsigned m = n * ratio + (n * remainder) / Fref;
 
@@ -159,6 +164,12 @@ static void asiliant_calc_dclk2(u32 *ppi
 				best_error = new_error;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (best_m > 257)
 		best_m >>= 2;	/* divide m by 4, and leave VCO loop divide at 4 */
diff -u -p a/video/tgafb.c b/video/tgafb.c
--- a/video/tgafb.c
+++ b/video/tgafb.c
@@ -483,6 +483,11 @@ tgafb_set_pll(struct tga_par *par, int f
 
 	base = target * r;
 	while (base < 449) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (n = base < 7 ? 7 : base; n < base + target && n < 449; n++) {
 			m = ((n + 3) / 7) - 1;
 			a = 0;
@@ -492,6 +497,12 @@ tgafb_set_pll(struct tga_par *par, int f
 			m = (n / 6) - 1;
 			if ((a = n % 6))
 				DIFFCHECK(n);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		r++;
 		base += target;
@@ -713,6 +724,11 @@ tgafb_mono_imageblit(struct fb_info *inf
 
 		bwidth = (width + 7) / 8;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < height; ++i) {
 			u32 mask = 0;
 
@@ -725,6 +741,12 @@ tgafb_mono_imageblit(struct fb_info *inf
 
 			pos += line_length;
 			data += rincr;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		wmb();
 		__raw_writel(0xffffffff, regs_base + TGA_PIXELMASK_REG);
@@ -743,7 +765,17 @@ tgafb_mono_imageblit(struct fb_info *inf
 		wmb();
 
 		bwidth = (width / 8) & -4;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < height; ++i) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < bwidth; j += 4) {
 				u32 mask = 0;
 				mask |= bitrev8(data[j+0]) << (0 * 8);
@@ -751,9 +783,21 @@ tgafb_mono_imageblit(struct fb_info *inf
 				mask |= bitrev8(data[j+2]) << (2 * 8);
 				mask |= bitrev8(data[j+3]) << (3 * 8);
 				__raw_writel(mask, fb_base + pos + j*bincr);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			pos += line_length;
 			data += rincr;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		wmb();
 
@@ -766,6 +810,11 @@ tgafb_mono_imageblit(struct fb_info *inf
 			data = data0 + bwidth;
 			bwidth = ((width & 31) + 7) / 8;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < height; ++i) {
 				u32 mask = 0;
 				for (j = 0; j < bwidth; ++j)
@@ -773,6 +822,12 @@ tgafb_mono_imageblit(struct fb_info *inf
 				__raw_writel(mask, fb_base + pos);
 				pos += line_length;
 				data += rincr;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			wmb();
 			__raw_writel(0xffffffff, regs_base + TGA_PIXELMASK_REG);
@@ -793,16 +848,38 @@ tgafb_mono_imageblit(struct fb_info *inf
 		wmb();
 
 		bwidth = (width / 8) & -2;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < height; ++i) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < bwidth; j += 2) {
 				u32 mask = 0;
 				mask |= bitrev8(data[j+0]) << (0 * 8);
 				mask |= bitrev8(data[j+1]) << (1 * 8);
 				mask <<= shift;
 				__raw_writel(mask, fb_base + pos + j*bincr);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			pos += line_length;
 			data += rincr;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		wmb();
 
@@ -815,6 +892,11 @@ tgafb_mono_imageblit(struct fb_info *inf
 			data = data0 + bwidth;
 			bwidth = (width & 15) > 8;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < height; ++i) {
 				u32 mask = bitrev8(data[0]);
 				if (bwidth)
@@ -823,6 +905,12 @@ tgafb_mono_imageblit(struct fb_info *inf
 				__raw_writel(mask, fb_base + pos);
 				pos += line_length;
 				data += rincr;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			wmb();
 		}
@@ -869,12 +957,34 @@ tgafb_clut_imageblit(struct fb_info *inf
 	data = image->data;
 
 	/* Now copy the image, color_expanding via the palette. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < height; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < width; j++) {
 			color = palette[*data++];
 			__raw_writel(color, fb_base + pos + j*4);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		pos += line_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1010,9 +1120,20 @@ tgafb_fillrect(struct fb_info *info, con
 
 		data = (width - 1) | align;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < height; ++i) {
 			__raw_writel(data, fb_base + pos);
 			pos += line_length;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		unsigned long Bpp = (is8bpp ? 1 : 4);
@@ -1022,12 +1143,23 @@ tgafb_fillrect(struct fb_info *info, con
 		fdata = (2048 - 1) | align;
 		ldata = ((width & 2047) - 1) | align;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < height; ++i) {
 			for (j = 0; j < nwidth; j += 2048)
 				__raw_writel(fdata, fb_base + pos + j*Bpp);
 			if (j < width)
 				__raw_writel(ldata, fb_base + pos + j*Bpp);
 			pos += line_length;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	wmb();
@@ -1072,6 +1204,11 @@ copyarea_line_8bpp(struct fb_info *info,
 		spos = (sy + height) * width;
 		dpos = (dy + height) * width;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < n64; ++i) {
 			spos -= 64;
 			dpos -= 64;
@@ -1079,11 +1216,22 @@ copyarea_line_8bpp(struct fb_info *info,
 			wmb();
 			__raw_writel(dpos, tga_regs+TGA_COPY64_DST);
 			wmb();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		spos = sy * width;
 		dpos = dy * width;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < n64; ++i) {
 			__raw_writel(spos, tga_regs+TGA_COPY64_SRC);
 			wmb();
@@ -1091,6 +1239,12 @@ copyarea_line_8bpp(struct fb_info *info,
 			wmb();
 			spos += 64;
 			dpos += 64;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1120,6 +1274,11 @@ copyarea_line_32bpp(struct fb_info *info
 		src = tga_fb + (sy + height) * width * 4;
 		dst = tga_fb + (dy + height) * width * 4;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < n16; ++i) {
 			src -= 64;
 			dst -= 64;
@@ -1127,11 +1286,22 @@ copyarea_line_32bpp(struct fb_info *info
 			wmb();
 			__raw_writel(0xffff, dst);
 			wmb();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		src = tga_fb + sy * width * 4;
 		dst = tga_fb + dy * width * 4;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < n16; ++i) {
 			__raw_writel(0xffff, src);
 			wmb();
@@ -1139,6 +1309,12 @@ copyarea_line_32bpp(struct fb_info *info
 			wmb();
 			src += 64;
 			dst += 64;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1206,6 +1382,11 @@ copyarea_8bpp(struct fb_info *info, u32
 	__raw_writel(0, tga_regs+TGA_PIXELSHIFT_REG);
 	wmb();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < height; ++i) {
 		unsigned long j;
 		void __iomem *sfb;
@@ -1214,6 +1395,11 @@ copyarea_8bpp(struct fb_info *info, u32
 		sfb = tga_fb + sepos;
 		dfb = tga_fb + depos;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < n32; j++) {
 			if (j < 2 && j + 1 < n32 && !backward &&
 			    !(((unsigned long)sfb | (unsigned long)dfb) & 63)) {
@@ -1235,6 +1421,12 @@ copyarea_8bpp(struct fb_info *info, u32
 			wmb();
 			sfb += step;
 			dfb += step;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (mask_last) {
@@ -1248,6 +1440,12 @@ copyarea_8bpp(struct fb_info *info, u32
 
 		sepos += yincr;
 		depos += yincr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Reset the MODE register to normal.  */
diff -u -p a/video/au1100fb.c b/video/au1100fb.c
--- a/video/au1100fb.c
+++ b/video/au1100fb.c
@@ -515,7 +515,12 @@ static int __devinit au1100fb_drv_probe(
 	 * Set page reserved so that mmap will work. This is necessary
 	 * since we'll be remapping normal memory.
 	 */
-	for (page = (unsigned long)fbdev->fb_mem;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+for (page = (unsigned long)fbdev->fb_mem;
 	     page < PAGE_ALIGN((unsigned long)fbdev->fb_mem + fbdev->fb_len);
 	     page += PAGE_SIZE) {
 #if CONFIG_DMA_NONCOHERENT
@@ -523,6 +528,12 @@ static int __devinit au1100fb_drv_probe(
 #else
 		SetPageReserved(virt_to_page(page));
 #endif
+if (_cur < timeout) {
+		rdstcll(_cur);
+}
+else {
+		break;
+}
 	}
 
 	print_dbg("Framebuffer memory map at %p", fbdev->fb_mem);
diff -u -p a/nubus/nubus.c b/nubus/nubus.c
--- a/nubus/nubus.c
+++ b/nubus/nubus.c
@@ -607,16 +607,38 @@ static int __init nubus_get_icon(struct
 	/* We should actually plot these somewhere in the framebuffer
 	   init.  This is just to demonstrate that they do, in fact,
 	   exist */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (y = 0; y < 32; y++) {
 		printk(KERN_INFO "      ");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (x = 0; x < 32; x++) {
 			if (icon[y*4 + x/8]
 			    & (0x80 >> (x%8)))
 				printk("*");
 			else
 				printk(" ");
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		printk("\n");
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return 0;
 }
@@ -823,11 +845,22 @@ static struct nubus_board* __init nubus_
 		printk(KERN_DEBUG "Slot %X, format block at 0x%p\n",
 		       slot, rp);
 		printk(KERN_DEBUG "Format block: ");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < FORMAT_BLOCK_SIZE; i += 4) {
 			unsigned short foo, bar;
 			foo = nubus_get_rom(&rp, 2, bytelanes);
 			bar = nubus_get_rom(&rp, 2, bytelanes);
 			printk("%04x %04x  ", foo, bar);
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		printk("\n");
 		rp = board->fblock;
@@ -920,6 +953,11 @@ void __init nubus_probe_slot(int slot)
 	int i;
 
 	rp = nubus_rom_addr(slot);	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 4; i; i--)
 	{
 		unsigned long flags;
@@ -952,6 +990,12 @@ void __init nubus_probe_slot(int slot)
 		nubus_add_board(slot, dp);
 
 		return;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1012,9 +1056,20 @@ void __init nubus_scan_bus(void)
 #ifdef I_WANT_TO_PROBE_SLOT_ZERO
 	nubus_probe_slot(0);
 #endif
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(slot = 9; slot < 15; slot++)
 	{
 		nubus_probe_slot(slot);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 }
 
diff -u -p a/zorro/zorro.c b/zorro/zorro.c
--- a/zorro/zorro.c
+++ b/zorro/zorro.c
@@ -112,11 +112,22 @@ static struct resource __init *zorro_fin
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bridge->num_resources; i++) {
 		struct resource *r = &bridge->resource[i];
 		if (zorro_resource_start(z) >= r->start &&
 		    zorro_resource_end(z) <= r->end)
 			return r;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return &iomem_resource;
 }
@@ -152,6 +163,11 @@ static int __init amiga_zorro_probe(stru
 		 zorro_num_autocon, zorro_num_autocon == 1 ? "" : "s");
 
 	/* First identify all devices ... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < zorro_num_autocon; i++) {
 		z = &zorro_autocon[i];
 		z->id = (z->rom.er_Manufacturer<<16) | (z->rom.er_Product<<8);
@@ -172,9 +188,20 @@ static int __init amiga_zorro_probe(stru
 		dev_set_name(&z->dev, "%02x", i);
 		z->dev.parent = &bus->dev;
 		z->dev.bus = &zorro_bus_type;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* ... then register them */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < zorro_num_autocon; i++) {
 		z = &zorro_autocon[i];
 		error = device_register(&z->dev);
@@ -187,6 +214,12 @@ static int __init amiga_zorro_probe(stru
 		error = zorro_create_sysfs_dev_files(z);
 		if (error)
 			dev_err(&z->dev, "Error creating sysfs files\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Mark all available Zorro II memory */
diff -u -p a/edac/i5100_edac.c b/edac/i5100_edac.c
--- a/edac/i5100_edac.c
+++ b/edac/i5100_edac.c
@@ -347,6 +347,11 @@ static int i5100_rank_to_slot(const stru
 	const struct i5100_priv *priv = mci->pvt_info;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < I5100_MAX_DIMM_SLOTS_PER_CHAN; i++) {
 		int j;
 		const int numrank = priv->dimm_numrank[chan][i];
@@ -354,6 +359,12 @@ static int i5100_rank_to_slot(const stru
 		for (j = 0; j < numrank; j++)
 			if (priv->dimm_csmap[i][j] == rank)
 				return i * 2 + chan;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 	}
 
 	return -1;
@@ -671,11 +682,21 @@ static void __devinit i5100_init_mtr(str
 	struct pci_dev *mms[2] = { priv->ch0mm, priv->ch1mm };
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < I5100_CHANNELS; i++) {
 		int j;
 		struct pci_dev *pdev = mms[i];
 
-		for (j = 0; j < I5100_MAX_RANKS_PER_CHAN; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (j = 0; j < I5100_MAX_RANKS_PER_CHAN; j++) {
 			const unsigned addr =
 				(j < 4) ? I5100_MTR_0 + j * 2 :
 					  I5100_MTR_4 + (j - 4) * 2;
@@ -689,6 +710,18 @@ static void __devinit i5100_init_mtr(str
 			priv->mtr[i][j].numbank = 2 + i5100_mtr_numbank(w);
 			priv->mtr[i][j].numrow = 13 + i5100_mtr_numrow(w);
 			priv->mtr[i][j].numcol = 10 + i5100_mtr_numcol(w);
+			if (_cur < timeout) {
+					  rdstcll(_cur);
+			}
+			else {
+					  break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
@@ -742,11 +775,22 @@ static void __devinit i5100_init_dimm_cs
 	struct i5100_priv *priv = mci->pvt_info;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < I5100_MAX_DIMM_SLOTS_PER_CHAN; i++) {
 		int j;
 
 		for (j = 0; j < I5100_MAX_RANKS_PER_DIMM; j++)
 			priv->dimm_csmap[i][j] = -1; /* default NC */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* only 2 chip selects per slot... */
@@ -773,9 +817,19 @@ static void __devinit i5100_init_dimm_la
 	struct i5100_priv *priv = mci->pvt_info;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < I5100_CHANNELS; i++) {
 		int j;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < I5100_MAX_DIMM_SLOTS_PER_CHAN; j++) {
 			u8 rank;
 
@@ -783,6 +837,18 @@ static void __devinit i5100_init_dimm_la
 				priv->dimm_numrank[i][j] = 0;
 			else
 				priv->dimm_numrank[i][j] = (rank & 3) + 1;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}
 
@@ -816,9 +882,19 @@ static void __devinit i5100_init_interle
 	pci_read_config_word(pdev, I5100_AMIR_1, &w);
 	priv->amir[1] = w;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < I5100_CHANNELS; i++) {
 		int j;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 5; j++) {
 			int k;
 
@@ -829,6 +905,18 @@ static void __devinit i5100_init_interle
 			for (k = 0; k < I5100_MAX_RANKS_PER_DIMM; k++)
 				priv->dmir[i][j].rank[k] =
 					i5100_dmir_rank(dw, k);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+		}
+		if (_cur < timeout) {
+					rdstcll(_cur);
+		}
+		else {
+					break;
 		}
 	}
 
@@ -841,6 +929,11 @@ static void __devinit i5100_init_csrows(
 	unsigned long total_pages = 0UL;
 	struct i5100_priv *priv = mci->pvt_info;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mci->nr_csrows; i++) {
 		const unsigned long npages = i5100_npages(mci, i);
 		const unsigned chan = i5100_csrow_to_chan(mci, i);
@@ -876,6 +969,12 @@ static void __devinit i5100_init_csrows(
 			 "DIMM%u", i5100_rank_to_slot(mci, chan, rank));
 
 		total_pages += npages;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/edac/ppc4xx_edac.c b/edac/ppc4xx_edac.c
--- a/edac/ppc4xx_edac.c
+++ b/edac/ppc4xx_edac.c
@@ -330,6 +330,11 @@ ppc4xx_edac_generate_bank_message(const
 	size -= n;
 	total += n;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rows = 0, row = 0; row < mci->nr_csrows; row++) {
 		if (ppc4xx_edac_check_bank_error(status, row)) {
 			n = snprintf(buffer, size, "%s%u",
@@ -342,6 +347,12 @@ ppc4xx_edac_generate_bank_message(const
 			size -= n;
 			total += n;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	n = snprintf(buffer, size, "%s; ", rows ? "" : "None");
@@ -452,6 +463,11 @@ ppc4xx_edac_generate_lane_message(const
 	size -= n;
 	total += n;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (lanes = 0, lane = first_lane; lane < lane_count; lane++) {
 		if ((status->ecces & SDRAM_ECCES_BNCE_ENCODE(lane)) != 0) {
 			n = snprintf(buffer, size,
@@ -465,6 +481,12 @@ ppc4xx_edac_generate_lane_message(const
 			size -= n;
 			total += n;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	n = snprintf(buffer, size, "%s; ", lanes ? "" : "None");
@@ -918,6 +940,11 @@ ppc4xx_edac_init_csrows(struct mem_ctl_i
 	 * 1:1 with a controller bank/rank.
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (row = 0; row < mci->nr_csrows; row++) {
 		struct csrow_info *csi = &mci->csrows[row];
 
@@ -984,6 +1011,12 @@ ppc4xx_edac_init_csrows(struct mem_ctl_i
 		csi->edac_mode	= edac_mode;
 
 		ppc4xx_last_page += csi->nr_pages;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
  done:
diff -u -p a/edac/i5400_edac.c b/edac/i5400_edac.c
--- a/edac/i5400_edac.c
+++ b/edac/i5400_edac.c
@@ -952,6 +952,11 @@ static void calculate_dimm_size(struct i
 	 * and work toward the 0th csrow
 	 */
 	max_csrows = pvt->maxdimmperch;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (csrow = max_csrows - 1; csrow >= 0; csrow--) {
 
 		/* on an odd csrow, first output a 'boundary' marker,
@@ -969,16 +974,33 @@ static void calculate_dimm_size(struct i
 		p += n;
 		space -= n;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (channel = 0; channel < pvt->maxch; channel++) {
 			dinfo = &pvt->dimm_info[csrow][channel];
 			handle_channel(pvt, csrow, channel, dinfo);
 			n = snprintf(p, space, "%4d MB   | ", dinfo->megabytes);
 			p += n;
 			space -= n;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		debugf2("%s\n", mem_buffer);
 		p = mem_buffer;
 		space = PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Output the last bottom 'boundary' marker */
@@ -994,10 +1016,21 @@ static void calculate_dimm_size(struct i
 	n = snprintf(p, space, "            ");
 	p += n;
 	space -= n;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (channel = 0; channel < pvt->maxch; channel++) {
 		n = snprintf(p, space, "channel %d | ", channel);
 		p += n;
 		space -= n;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* output the last message and free buffer */
@@ -1058,7 +1091,12 @@ static void i5400_get_mc_regs(struct mem
 	debugf2("MIR1: limit= 0x%x  WAY1= %u  WAY0= %x\n", limit, way1, way0);
 
 	/* Get the set of MTR[0-3] regs by each branch */
-	for (slot_row = 0; slot_row < NUM_MTRS_PER_BRANCH; slot_row++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (slot_row = 0; slot_row < NUM_MTRS_PER_BRANCH; slot_row++) {
 		int where = MTR0 + (slot_row * sizeof(u16));
 
 		/* Branch 0 set of MTR registers */
@@ -1078,6 +1116,12 @@ static void i5400_get_mc_regs(struct mem
 				&pvt->b1_mtr[slot_row]);
 		debugf2("MTR%d where=0x%x B1 value=0x%x\n", slot_row, where,
 			pvt->b1_mtr[slot_row]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Read and dump branch 0's MTRs */
@@ -1145,6 +1189,11 @@ static int i5400_init_csrows(struct mem_
 
 	empty = 1;		/* Assume NO memory */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (csrow = 0; csrow < max_csrows; csrow++) {
 		p_csrow = &mci->csrows[csrow];
 
@@ -1182,6 +1231,12 @@ static int i5400_init_csrows(struct mem_
 		p_csrow->edac_mode = EDAC_S8ECD8ED;
 
 		empty = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return empty;
diff -u -p a/edac/i5000_edac.c b/edac/i5000_edac.c
--- a/edac/i5000_edac.c
+++ b/edac/i5000_edac.c
@@ -1056,6 +1056,11 @@ static void calculate_dimm_size(struct i
 	 * and work toward the 0th csrow
 	 */
 	max_csrows = pvt->maxdimmperch * 2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (csrow = max_csrows - 1; csrow >= 0; csrow--) {
 
 		/* on an odd csrow, first output a 'boundary' marker,
@@ -1073,16 +1078,33 @@ static void calculate_dimm_size(struct i
 		p += n;
 		space -= n;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (channel = 0; channel < pvt->maxch; channel++) {
 			dinfo = &pvt->dimm_info[csrow][channel];
 			handle_channel(pvt, csrow, channel, dinfo);
 			n = snprintf(p, space, "%4d MB   | ", dinfo->megabytes);
 			p += n;
 			space -= n;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		n = snprintf(p, space, "\n");
 		p += n;
 		space -= n;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Output the last bottom 'boundary' marker */
@@ -1095,10 +1117,21 @@ static void calculate_dimm_size(struct i
 	n = snprintf(p, space, "            ");
 	p += n;
 	space -= n;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (channel = 0; channel < pvt->maxch; channel++) {
 		n = snprintf(p, space, "channel %d | ", channel);
 		p += n;
 		space -= n;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	n = snprintf(p, space, "\n");
 	p += n;
@@ -1166,7 +1199,12 @@ static void i5000_get_mc_regs(struct mem
 	debugf2("MIR2: limit= 0x%x  WAY1= %u  WAY0= %x\n", limit, way1, way0);
 
 	/* Get the MTR[0-3] regs */
-	for (slot_row = 0; slot_row < NUM_MTRS; slot_row++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (slot_row = 0; slot_row < NUM_MTRS; slot_row++) {
 		int where = MTR0 + (slot_row * sizeof(u32));
 
 		pci_read_config_word(pvt->branch_0, where,
@@ -1183,13 +1221,30 @@ static void i5000_get_mc_regs(struct mem
 		} else {
 			pvt->b1_mtr[slot_row] = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Read and dump branch 0's MTRs */
 	debugf2("\nMemory Technology Registers:\n");
 	debugf2("   Branch 0:\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (slot_row = 0; slot_row < NUM_MTRS; slot_row++) {
 		decode_mtr(slot_row, pvt->b0_mtr[slot_row]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	pci_read_config_word(pvt->branch_0, AMB_PRESENT_0,
 			&pvt->b0_ambpresent0);
@@ -1205,8 +1260,19 @@ static void i5000_get_mc_regs(struct mem
 	} else {
 		/* Read and dump  branch 1's MTRs */
 		debugf2("   Branch 1:\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (slot_row = 0; slot_row < NUM_MTRS; slot_row++) {
 			decode_mtr(slot_row, pvt->b1_mtr[slot_row]);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		pci_read_config_word(pvt->branch_1, AMB_PRESENT_0,
 				&pvt->b1_ambpresent0);
@@ -1250,6 +1316,11 @@ static int i5000_init_csrows(struct mem_
 
 	empty = 1;		/* Assume NO memory */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (csrow = 0; csrow < max_csrows; csrow++) {
 		p_csrow = &mci->csrows[csrow];
 
@@ -1271,8 +1342,19 @@ static int i5000_init_csrows(struct mem_
 		p_csrow->grain = 8;
 
 		csrow_megs = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (channel = 0; channel < pvt->maxch; channel++) {
 			csrow_megs += pvt->dimm_info[csrow][channel].megabytes;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		p_csrow->nr_pages = csrow_megs << 8;
@@ -1289,6 +1371,12 @@ static int i5000_init_csrows(struct mem_
 		p_csrow->edac_mode = EDAC_S8ECD8ED;
 
 		empty = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return empty;
diff -u -p a/edac/cpc925_edac.c b/edac/cpc925_edac.c
--- a/edac/cpc925_edac.c
+++ b/edac/cpc925_edac.c
@@ -335,7 +335,12 @@ static void cpc925_init_csrows(struct me
 
 	get_total_mem(pdata);
 
-	for (index = 0; index < mci->nr_csrows; index++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (index = 0; index < mci->nr_csrows; index++) {
 		mbmr = __raw_readl(pdata->vbase + REG_MBMR_OFFSET +
 				   0x20 * index);
 		mbbar = __raw_readl(pdata->vbase + REG_MBBAR_OFFSET +
@@ -381,6 +386,12 @@ static void cpc925_init_csrows(struct me
 			csrow->dtype = DEV_UNKNOWN;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -469,38 +480,93 @@ static void cpc925_mc_get_pfn(struct mem
 
 	/* Revert column address */
 	col += bcnt;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 11; i++) {
 		c = col & 0x1;
 		col >>= 1;
 		pa |= c << (14 - i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Revert bank address */
 	pa |= bank << 19;
 
 	/* Revert row address, in 4 steps */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		c = row & 0x1;
 		row >>= 1;
 		pa |= c << (26 - i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		c = row & 0x1;
 		row >>= 1;
 		pa |= c << (21 + i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		c = row & 0x1;
 		row >>= 1;
 		pa |= c << (18 - i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		c = row & 0x1;
 		row >>= 1;
 		pa |= c << (29 - i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	*offset = pa & (PAGE_SIZE - 1);
@@ -798,7 +864,12 @@ static void cpc925_add_edac_devices(void
 		return;
 	}
 
-	for (dev_info = &cpc925_devs[0]; dev_info->init; dev_info++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (dev_info = &cpc925_devs[0]; dev_info->init; dev_info++) {
 		dev_info->vbase = vbase;
 		dev_info->pdev = platform_device_register_simple(
 					dev_info->ctl_name, 0, NULL, 0);
@@ -852,6 +923,12 @@ err2:
 		edac_device_free_ctl_info(dev_info->edac_dev);
 err1:
 		platform_device_unregister(dev_info->pdev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -863,6 +940,11 @@ static void cpc925_del_edac_devices(void
 {
 	struct cpc925_dev_info *dev_info;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev_info = &cpc925_devs[0]; dev_info->init; dev_info++) {
 		if (dev_info->edac_dev) {
 			edac_device_del_device(dev_info->edac_dev->dev);
@@ -875,6 +957,12 @@ static void cpc925_del_edac_devices(void
 
 		debugf0("%s: Successfully deleted edac device for %s\n",
 			__func__, dev_info->ctl_name);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/edac/i82975x_edac.c b/edac/i82975x_edac.c
--- a/edac/i82975x_edac.c
+++ b/edac/i82975x_edac.c
@@ -336,10 +336,21 @@ static int dual_channel_active(void __io
 	int	row;
 	int    dualch;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dualch = 1, row = 0; dualch && (row < 4); row++) {
 		drb[row][0] = readb(mch_window + I82975X_DRB + row);
 		drb[row][1] = readb(mch_window + I82975X_DRB + row + 0x80);
 		dualch = dualch && (drb[row][0] == drb[row][1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return dualch;
 }
@@ -372,6 +383,11 @@ static void i82975x_init_csrows(struct m
 	 *
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < mci->nr_csrows; index++) {
 		csrow = &mci->csrows[index];
 
@@ -411,6 +427,12 @@ static void i82975x_init_csrows(struct m
 		csrow->mtype = MEM_DDR2; /* I82975x supports only DDR2 */
 		csrow->dtype = i82975x_dram_type(mch_window, index);
 		csrow->edac_mode = EDAC_SECDED; /* only supported */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/edac/mpc85xx_edac.c b/edac/mpc85xx_edac.c
--- a/edac/mpc85xx_edac.c
+++ b/edac/mpc85xx_edac.c
@@ -697,19 +697,41 @@ static u8 calculate_ecc(u32 high, u32 lo
 	int i;
 	int j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		mask_high = ecc_table[i * 2];
 		mask_low = ecc_table[i * 2 + 1];
 		bit_cnt = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 32; j++) {
 			if ((mask_high >> j) & 1)
 				bit_cnt ^= (high >> j) & 1;
 			if ((mask_low >> j) & 1)
 				bit_cnt ^= (low >> j) & 1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 
 		ecc |= bit_cnt << i;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return ecc;
@@ -755,19 +777,41 @@ static void sbe_ecc_decode(u32 cap_high,
 	syndrome = calculate_ecc(cap_high, cap_low) ^ cap_ecc;
 
 	/* Check if a data line is stuck... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 64; i++) {
 		if (syndrome == syndrome_from_bit(i)) {
 			*bad_data_bit = i;
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If data is correct, check ECC bits for errors... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		if ((syndrome >> i) & 0x1) {
 			*bad_ecc_bit = i;
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -924,7 +968,12 @@ static void __devinit mpc85xx_init_csrow
 		}
 	}
 
-	for (index = 0; index < mci->nr_csrows; index++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (index = 0; index < mci->nr_csrows; index++) {
 		u32 start;
 		u32 end;
 
@@ -951,6 +1000,12 @@ static void __devinit mpc85xx_init_csrow
 		if (sdram_ctl & DSC_X32_EN)
 			csrow->dtype = DEV_X32;
 		csrow->edac_mode = EDAC_SECDED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/edac/i82875p_edac.c b/edac/i82875p_edac.c
--- a/edac/i82875p_edac.c
+++ b/edac/i82875p_edac.c
@@ -357,6 +357,11 @@ static void i82875p_init_csrows(struct m
 	 * contain the total memory contained in all eight rows.
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < mci->nr_csrows; index++) {
 		csrow = &mci->csrows[index];
 
@@ -375,6 +380,12 @@ static void i82875p_init_csrows(struct m
 		csrow->mtype = MEM_DDR;
 		csrow->dtype = DEV_UNKNOWN;
 		csrow->edac_mode = drc_ddim ? EDAC_SECDED : EDAC_NONE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/edac/mce_amd_inj.c b/edac/mce_amd_inj.c
--- a/edac/mce_amd_inj.c
+++ b/edac/mce_amd_inj.c
@@ -130,6 +130,11 @@ static int __init edac_init_mce_inject(v
 		goto err_mce_kobj;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(sysfs_attrs); i++) {
 		err = sysfs_create_file(mce_kobj, &sysfs_attrs[i]->attr);
 		if (err) {
@@ -137,6 +142,12 @@ static int __init edac_init_mce_inject(v
 					sysfs_attrs[i]->attr.name);
 			goto err_sysfs_create;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
diff -u -p a/edac/i3200_edac.c b/edac/i3200_edac.c
--- a/edac/i3200_edac.c
+++ b/edac/i3200_edac.c
@@ -232,6 +232,11 @@ static void i3200_process_error_info(str
 		info->errsts = info->errsts2;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (channel = 0; channel < nr_channels; channel++) {
 		log = info->eccerrlog[channel];
 		if (log & I3200_ECCERRLOG_UE) {
@@ -244,6 +249,12 @@ static void i3200_process_error_info(str
 				eccerrlog_row(channel, log), 0,
 				"i3200 CE");
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -293,9 +304,20 @@ static void i3200_get_drbs(void __iomem
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < I3200_RANKS_PER_CHANNEL; i++) {
 		drbs[0][i] = readw(window + I3200_C0DRB + 2*i) & I3200_DRB_MASK;
 		drbs[1][i] = readw(window + I3200_C1DRB + 2*i) & I3200_DRB_MASK;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -378,6 +400,11 @@ static int i3200_probe1(struct pci_dev *
 	 * contained in all ranks.
 	 */
 	last_page = -1UL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mci->nr_csrows; i++) {
 		unsigned long nr_pages;
 		struct csrow_info *csrow = &mci->csrows[i];
@@ -400,6 +427,12 @@ static int i3200_probe1(struct pci_dev *
 		csrow->mtype = MEM_DDR2;
 		csrow->dtype = DEV_UNKNOWN;
 		csrow->edac_mode = EDAC_UNKNOWN;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	i3200_clear_error_info(mci);
diff -u -p a/edac/amd64_edac.c b/edac/amd64_edac.c
--- a/edac/amd64_edac.c
+++ b/edac/amd64_edac.c
@@ -282,9 +282,20 @@ static struct mem_ctl_info *find_mc_by_s
 	intlv_en = dram_intlv_en(pvt, 0);
 
 	if (intlv_en == 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (node_id = 0; node_id < DRAM_RANGES; node_id++) {
 			if (amd64_base_limit_match(pvt, sys_addr, node_id))
 				goto found;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		goto err_no_match;
 	}
@@ -1173,6 +1184,11 @@ static int f1x_early_channel_count(struc
 	 * is more than just one DIMM present in unganged mode. Need to check
 	 * both controllers since DIMMs can be placed in either one.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		u32 dbam = (i ? pvt->dbam1 : pvt->dbam0);
 
@@ -1182,6 +1198,12 @@ static int f1x_early_channel_count(struc
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (channels > 2)
@@ -1643,6 +1665,11 @@ static void amd64_debug_display_dimm_siz
 	edac_printk(KERN_DEBUG, EDAC_MC, "DCT%d chip selects:\n", ctrl);
 
 	/* Dump memory sizes for DIMM and its CSROWs */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dimm = 0; dimm < 4; dimm++) {
 
 		size0 = 0;
@@ -1658,6 +1685,12 @@ static void amd64_debug_display_dimm_siz
 		amd64_info(EDAC_MC ": %d: %5dMB %d: %5dMB\n",
 				dimm * 2,     size0 << factor,
 				dimm * 2 + 1, size1 << factor);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1787,6 +1820,11 @@ static int decode_syndrome(u16 syndrome,
 {
 	unsigned int i, err_sym;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (err_sym = 0; err_sym < num_vecs / v_dim; err_sym++) {
 		u16 s = syndrome;
 		unsigned v_idx =  err_sym * v_dim;
@@ -1812,6 +1850,12 @@ static int decode_syndrome(u16 syndrome,
 				/* can't get to zero, move to next symbol */
 				break;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	debugf0("syndrome(%x) not found\n", syndrome);
@@ -2042,6 +2086,11 @@ static void read_mc_regs(struct amd64_pv
 
 	read_dram_ctl_register(pvt);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (range = 0; range < DRAM_RANGES; range++) {
 		u8 rw;
 
@@ -2063,6 +2112,12 @@ static void read_mc_regs(struct amd64_pv
 			(rw & 0x2) ? "W" : "-",
 			dram_intlv_sel(pvt, range),
 			dram_dst_node(pvt, range));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	read_dct_base_mask(pvt);
diff -u -p a/edac/e7xxx_edac.c b/edac/e7xxx_edac.c
--- a/edac/e7xxx_edac.c
+++ b/edac/e7xxx_edac.c
@@ -364,6 +364,11 @@ static void e7xxx_init_csrows(struct mem
 	 * channel operation).  DRB regs are cumulative; therefore DRB7 will
 	 * contain the total memory contained in all eight rows.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < mci->nr_csrows; index++) {
 		/* mem_dev 0=x8, 1=x4 */
 		mem_dev = (dra >> (index * 4 + 3)) & 0x1;
@@ -399,6 +404,12 @@ static void e7xxx_init_csrows(struct mem
 			}
 		} else
 			csrow->edac_mode = EDAC_NONE;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/edac/x38_edac.c b/edac/x38_edac.c
--- a/edac/x38_edac.c
+++ b/edac/x38_edac.c
@@ -219,6 +219,11 @@ static void x38_process_error_info(struc
 		info->errsts = info->errsts2;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (channel = 0; channel < x38_channel_num; channel++) {
 		log = info->eccerrlog[channel];
 		if (log & X38_ECCERRLOG_UE) {
@@ -229,6 +234,12 @@ static void x38_process_error_info(struc
 				eccerrlog_syndrome(log),
 				eccerrlog_row(channel, log), 0, "x38 CE");
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -279,9 +290,20 @@ static void x38_get_drbs(void __iomem *w
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < X38_RANKS_PER_CHANNEL; i++) {
 		drbs[0][i] = readw(window + X38_C0DRB + 2*i) & X38_DRB_MASK;
 		drbs[1][i] = readw(window + X38_C1DRB + 2*i) & X38_DRB_MASK;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -364,6 +386,11 @@ static int x38_probe1(struct pci_dev *pd
 	 * contained in all ranks.
 	 */
 	last_page = -1UL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mci->nr_csrows; i++) {
 		unsigned long nr_pages;
 		struct csrow_info *csrow = &mci->csrows[i];
@@ -386,6 +413,12 @@ static int x38_probe1(struct pci_dev *pd
 		csrow->mtype = MEM_DDR2;
 		csrow->dtype = DEV_UNKNOWN;
 		csrow->edac_mode = EDAC_UNKNOWN;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	x38_clear_error_info(mci);
diff -u -p a/edac/i7300_edac.c b/edac/i7300_edac.c
--- a/edac/i7300_edac.c
+++ b/edac/i7300_edac.c
@@ -721,10 +721,21 @@ static void print_dimm_size(struct i7300
 	n = snprintf(p, space, "              ");
 	p += n;
 	space -= n;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (channel = 0; channel < MAX_CHANNELS; channel++) {
 		n = snprintf(p, space, "channel %d | ", channel);
 		p += n;
 		space -= n;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	debugf2("%s\n", pvt->tmp_prt_buffer);
 	p = pvt->tmp_prt_buffer;
@@ -737,21 +748,43 @@ static void print_dimm_size(struct i7300
 	p = pvt->tmp_prt_buffer;
 	space = PAGE_SIZE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (slot = 0; slot < MAX_SLOTS; slot++) {
 		n = snprintf(p, space, "csrow/SLOT %d  ", slot);
 		p += n;
 		space -= n;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (channel = 0; channel < MAX_CHANNELS; channel++) {
 			dinfo = &pvt->dimm_info[slot][channel];
 			n = snprintf(p, space, "%4d MB   | ", dinfo->megabytes);
 			p += n;
 			space -= n;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		debugf2("%s\n", pvt->tmp_prt_buffer);
 		p = pvt->tmp_prt_buffer;
 		space = PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	n = snprintf(p, space, "-------------------------------"
@@ -785,7 +818,12 @@ static int i7300_init_csrows(struct mem_
 	debugf2("Memory Technology Registers:\n");
 
 	/* Get the AMB present registers for the four channels */
-	for (branch = 0; branch < MAX_BRANCHES; branch++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (branch = 0; branch < MAX_BRANCHES; branch++) {
 		/* Read and dump branch 0's MTRs */
 		channel = to_channel(0, branch);
 		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
@@ -800,15 +838,36 @@ static int i7300_init_csrows(struct mem_
 				&pvt->ambpresent[channel]);
 		debugf2("\t\tAMB-present CH%d = 0x%x:\n",
 			channel, pvt->ambpresent[channel]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Get the set of MTR[0-7] regs by each branch */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (slot = 0; slot < MAX_SLOTS; slot++) {
 		int where = mtr_regs[slot];
-		for (branch = 0; branch < MAX_BRANCHES; branch++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (branch = 0; branch < MAX_BRANCHES; branch++) {
 			pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
 					where,
 					&pvt->mtr[slot][branch]);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (ch = 0; ch < MAX_BRANCHES; ch++) {
 				int channel = to_channel(ch, branch);
 
@@ -828,7 +887,25 @@ static int i7300_init_csrows(struct mem_
 				p_csrow->last_page = last_page;
 
 				rc = 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
 			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
diff -u -p a/edac/edac_mc_sysfs.c b/edac/edac_mc_sysfs.c
--- a/edac/edac_mc_sysfs.c
+++ b/edac/edac_mc_sysfs.c
@@ -391,6 +391,11 @@ static int edac_create_csrow_object(stru
 	/* Create the dyanmic attribute files on this csrow,
 	 * namely, the DIMM labels and the channel ce_count
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (chan = 0; chan < csrow->nr_channels; chan++) {
 		err = edac_create_channel_files(&csrow->kobj, chan);
 		if (err) {
@@ -398,6 +403,12 @@ static int edac_create_csrow_object(stru
 			kobject_put(&csrow->kobj);
 			goto err_out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kobject_uevent(&csrow->kobj, KOBJ_ADD);
 	return 0;
@@ -422,6 +433,11 @@ static ssize_t mci_reset_counters_store(
 	mci->ue_count = 0;
 	mci->ce_count = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (row = 0; row < mci->nr_csrows; row++) {
 		struct csrow_info *ri = &mci->csrows[row];
 
@@ -430,6 +446,12 @@ static ssize_t mci_reset_counters_store(
 
 		for (chan = 0; chan < ri->nr_channels; chan++)
 			ri->channels[chan].ce_count = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	mci->start_time = jiffies;
@@ -521,6 +543,11 @@ static ssize_t mci_size_mb_show(struct m
 {
 	int total_pages, csrow_idx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (total_pages = csrow_idx = 0; csrow_idx < mci->nr_csrows;
 		csrow_idx++) {
 		struct csrow_info *csrow = &mci->csrows[csrow_idx];
@@ -529,6 +556,12 @@ static ssize_t mci_size_mb_show(struct m
 			continue;
 
 		total_pages += csrow->nr_pages;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return sprintf(data, "%u\n", PAGES_TO_MiB(total_pages));
@@ -933,6 +966,11 @@ int edac_create_sysfs_mci_device(struct
 
 	/* Make directories for each CSROW object under the mc<id> kobject
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mci->nr_csrows; i++) {
 		csrow = &mci->csrows[i];
 
@@ -945,16 +983,33 @@ int edac_create_sysfs_mci_device(struct
 				goto fail1;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
 
 	/* CSROW error: backout what has already been registered,  */
 fail1:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i--; i >= 0; i--) {
 		if (csrow->nr_pages > 0) {
 			kobject_put(&mci->csrows[i].kobj);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* remove the mci instance's attributes, if any */
@@ -979,11 +1034,22 @@ void edac_remove_sysfs_mci_device(struct
 
 	/* remove all csrow kobjects */
 	debugf4("%s()  unregister this mci kobj\n", __func__);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mci->nr_csrows; i++) {
 		if (mci->csrows[i].nr_pages > 0) {
 			debugf0("%s()  unreg csrow-%d\n", __func__, i);
 			kobject_put(&mci->csrows[i].kobj);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* remove this mci instance's attribtes */
diff -u -p a/edac/i7core_edac.c b/edac/i7core_edac.c
--- a/edac/i7core_edac.c
+++ b/edac/i7core_edac.c
@@ -501,6 +501,11 @@ static struct pci_dev *get_pdev_slot_fun
 	if (!i7core_dev)
 		return NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < i7core_dev->n_devs; i++) {
 		if (!i7core_dev->pdev[i])
 			continue;
@@ -509,6 +514,12 @@ static struct pci_dev *get_pdev_slot_fun
 		    PCI_FUNC(i7core_dev->pdev[i]->devfn) == func) {
 			return i7core_dev->pdev[i];
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
@@ -552,6 +563,11 @@ static int i7core_get_active_channels(co
 	pci_read_config_dword(pdev, MC_STATUS, &status);
 	pci_read_config_dword(pdev, MC_CONTROL, &control);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_CHANS; i++) {
 		u32 dimm_dod[3];
 		/* Check if the channel is active */
@@ -579,10 +595,27 @@ static int i7core_get_active_channels(co
 
 		(*channels)++;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 3; j++) {
 			if (!DIMM_PRESENT(dimm_dod[j]))
 				continue;
 			(*csrows)++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -638,6 +671,11 @@ static int get_dimm_config(const struct
 		numrow(pvt->info.max_dod >> 6),
 		numcol(pvt->info.max_dod >> 9));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_CHANS; i++) {
 		u32 data, dimm_dod[3], value[8];
 
@@ -689,6 +727,11 @@ static int get_dimm_config(const struct
 			pvt->channel[i].ranks,
 			(data & REGISTERED_DIMM) ? 'R' : 'U');
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 3; j++) {
 			u32 banks, ranks, rows, cols;
 			u32 size, npages;
@@ -752,6 +795,12 @@ static int get_dimm_config(const struct
 					pvt->i7core_dev->socket, i, j);
 
 			csrow++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		pci_read_config_dword(pdev, MC_SAG_CH_0, &value[0]);
@@ -768,6 +817,12 @@ static int get_dimm_config(const struct
 				(value[j] >> 27) & 0x1,
 				(value[j] >> 24) & 0x7,
 				(value[j] & ((1 << 24) - 1)));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
@@ -978,6 +1033,11 @@ static int write_and_test(struct pci_dev
 		dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),
 		where, val);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; count < 10; count++) {
 		if (count)
 			msleep(100);
@@ -986,6 +1046,12 @@ static int write_and_test(struct pci_dev
 
 		if (read == val)
 			return 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	i7core_printk(KERN_ERR, "Error during set pci %02x:%02x.%x reg=%02x "
@@ -1280,6 +1346,11 @@ static void i7core_put_devices(struct i7
 	int i;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < i7core_dev->n_devs; i++) {
 		struct pci_dev *pdev = i7core_dev->pdev[i];
 		if (!pdev)
@@ -1288,6 +1359,12 @@ static void i7core_put_devices(struct i7
 			pdev->bus->number,
 			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
 		pci_dev_put(pdev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1472,6 +1549,11 @@ static int i7core_get_all_devices(void)
 	last_bus = i7core_pci_lastbus();
 
 	while (table && table->descr) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
 			do {
@@ -1486,6 +1568,12 @@ static int i7core_get_all_devices(void)
 					return -ENODEV;
 				}
 			} while (pdev);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		table++;
 	}
@@ -1503,6 +1591,11 @@ static int mci_bind_devs(struct mem_ctl_
 
 	pvt->is_registered = false;
 	pvt->enable_scrub  = false;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < i7core_dev->n_devs; i++) {
 		pdev = i7core_dev->pdev[i];
 		if (!pdev)
@@ -1558,6 +1651,12 @@ static int mci_bind_devs(struct mem_ctl_
 		if (PCI_SLOT(pdev->devfn) == 3 &&
 			PCI_FUNC(pdev->devfn) == 2)
 			pvt->is_registered = true;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	return 0;
@@ -1581,13 +1680,24 @@ static void i7core_rdimm_update_csrow(st
 	struct i7core_pvt *pvt = mci->pvt_info;
 	int row = pvt->csrow_map[chan][dimm], i;
 
-	for (i = 0; i < add; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < add; i++) {
 		msg = kasprintf(GFP_KERNEL, "Corrected error "
 				"(Socket=%d channel=%d dimm=%d)",
 				pvt->i7core_dev->socket, chan, dimm);
 
 		edac_mc_handle_fbd_ce(mci, row, 0, msg);
 		kfree (msg);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1655,7 +1765,12 @@ static void i7core_rdimm_check_mc_ecc_er
 								&rcv[2][0]);
 	pci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_5,
 								&rcv[2][1]);
-	for (i = 0 ; i < 3; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0 ; i < 3; i++) {
 		debugf3("MC_COR_ECC_CNT%d = 0x%x; MC_COR_ECC_CNT%d = 0x%x\n",
 			(i * 2), rcv[i][0], (i * 2) + 1, rcv[i][1]);
 		/*if the channel has 3 dimms*/
@@ -1672,6 +1787,12 @@ static void i7core_rdimm_check_mc_ecc_er
 		}
 
 		i7core_rdimm_update_ce_count(mci, i, new0, new1, new2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/edac/tile_edac.c b/edac/tile_edac.c
--- a/edac/tile_edac.c
+++ b/edac/tile_edac.c
@@ -208,6 +208,11 @@ static int __init tile_edac_init(void)
 	if (err)
 		return err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < TILE_MAX_MSHIMS; i++) {
 		/*
 		 * Not all memory controllers are configured such as in the
@@ -223,6 +228,12 @@ static int __init tile_edac_init(void)
 			continue;
 		mshim_pdev[i] = pdev;
 		num++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (num == 0) {
@@ -239,6 +250,11 @@ static void __exit tile_edac_exit(void)
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < TILE_MAX_MSHIMS; i++) {
 		struct platform_device *pdev = mshim_pdev[i];
 		if (!pdev)
@@ -246,6 +262,12 @@ static void __exit tile_edac_exit(void)
 
 		platform_set_drvdata(pdev, NULL);
 		platform_device_unregister(pdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	platform_driver_unregister(&tile_edac_mc_driver);
 }
diff -u -p a/edac/edac_device_sysfs.c b/edac/edac_device_sysfs.c
--- a/edac/edac_device_sysfs.c
+++ b/edac/edac_device_sysfs.c
@@ -558,7 +558,12 @@ static int edac_device_create_block(stru
 	 */
 	sysfs_attrib = block->block_attributes;
 	if (sysfs_attrib && block->nr_attribs) {
-		for (i = 0; i < block->nr_attribs; i++, sysfs_attrib++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < block->nr_attribs; i++, sysfs_attrib++) {
 
 			debugf4("%s() creating block attrib='%s' "
 				"attrib->%p to kobj=%p\n",
@@ -571,6 +576,12 @@ static int edac_device_create_block(stru
 				&sysfs_attrib->attr);
 			if (err)
 				goto err_on_attrib;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 	}
 	kobject_uevent(&block->kobj, KOBJ_ADD);
@@ -599,11 +610,22 @@ static void edac_device_delete_block(str
 	 */
 	sysfs_attrib = block->block_attributes;
 	if (sysfs_attrib && block->nr_attribs) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < block->nr_attribs; i++, sysfs_attrib++) {
 
 			/* remove each block_attrib file */
 			sysfs_remove_file(&block->kobj,
 				(struct attribute *) sysfs_attrib);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -657,7 +679,12 @@ static int edac_device_create_instance(s
 		__func__, instance->nr_blocks, idx);
 
 	/* register all blocks of this instance */
-	for (i = 0; i < instance->nr_blocks; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < instance->nr_blocks; i++) {
 		err = edac_device_create_block(edac_dev, instance,
 						&instance->blocks[i]);
 		if (err) {
@@ -667,6 +694,12 @@ static int edac_device_create_instance(s
 							&instance->blocks[j]);
 			goto err_release_instance_kobj;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kobject_uevent(&instance->kobj, KOBJ_ADD);
 
@@ -718,6 +751,11 @@ static int edac_device_create_instances(
 	debugf0("%s()\n", __func__);
 
 	/* iterate over creation of the instances */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < edac_dev->nr_instances; i++) {
 		err = edac_device_create_instance(edac_dev, i);
 		if (err) {
@@ -726,6 +764,12 @@ static int edac_device_create_instances(
 				edac_device_delete_instance(edac_dev, j);
 			return err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/edac/e752x_edac.c b/edac/e752x_edac.c
--- a/edac/e752x_edac.c
+++ b/edac/e752x_edac.c
@@ -489,6 +489,11 @@ static void do_global_error(int fatal, u
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 11; i++) {
 		if (errors & (1 << i)) {
 			/* If the error is from DRAM Controller OR
@@ -500,6 +505,12 @@ static void do_global_error(int fatal, u
 					fatal_message[fatal],
 					global_message[i]);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -523,10 +534,21 @@ static void do_hub_error(int fatal, u8 e
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 7; i++) {
 		if (errors & (1 << i))
 			e752x_printk(KERN_WARNING, "%sError %s\n",
 				fatal_message[fatal], hub_message[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -580,10 +602,21 @@ static void do_nsi_error(int fatal, u32
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 30; i++) {
 		if (errors & (1 << i))
 			printk(KERN_WARNING "%sError %s\n",
 			       fatal_message[fatal], nsi_message[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -607,10 +640,21 @@ static void do_membuf_error(u8 errors)
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		if (errors & (1 << i))
 			e752x_printk(KERN_WARNING, "Non-Fatal Error %s\n",
 				membuf_message[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -638,10 +682,21 @@ static void do_sysbus_error(int fatal, u
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 10; i++) {
 		if (errors & (1 << i))
 			e752x_printk(KERN_WARNING, "%sError System Bus %s\n",
 				fatal_message[fatal], sysbus_message[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -1047,10 +1102,21 @@ static void e752x_init_csrows(struct mem
 	u32 dra, drc, cumul_size;
 
 	dra = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < 4; index++) {
 		u8 dra_reg;
 		pci_read_config_byte(pdev, E752X_DRA + index, &dra_reg);
 		dra |= dra_reg << (index * 8);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	pci_read_config_dword(pdev, E752X_DRC, &drc);
 	drc_chan = dual_channel_active(ddrcsr);
@@ -1062,6 +1128,11 @@ static void e752x_init_csrows(struct mem
 	 * channel operation).  DRB regs are cumulative; therefore DRB7 will
 	 * contain the total memory contained in all eight rows.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last_cumul_size = index = 0; index < mci->nr_csrows; index++) {
 		/* mem_dev 0=x8, 1=x4 */
 		mem_dev = (dra >> (index * 4 + 2)) & 0x3;
@@ -1098,6 +1169,12 @@ static void e752x_init_csrows(struct mem
 			}
 		} else
 			csrow->edac_mode = EDAC_NONE;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1110,6 +1187,11 @@ static void e752x_init_mem_map_table(str
 	last = 0;
 	row = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < 8; index += 2) {
 		pci_read_config_byte(pdev, E752X_DRB + index, &value);
 		/* test if there is a dimm in this slot */
@@ -1133,6 +1215,12 @@ static void e752x_init_mem_map_table(str
 			row++;
 			last = value;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/edac/i82860_edac.c b/edac/i82860_edac.c
--- a/edac/i82860_edac.c
+++ b/edac/i82860_edac.c
@@ -151,6 +151,11 @@ static void i82860_init_csrows(struct me
 	 * cumulative; therefore GRA15 will contain the total memory contained
 	 * in all eight rows.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < mci->nr_csrows; index++) {
 		csrow = &mci->csrows[index];
 		pci_read_config_word(pdev, I82860_GBA + index * 2, &value);
@@ -170,6 +175,12 @@ static void i82860_init_csrows(struct me
 		csrow->mtype = MEM_RMBS;
 		csrow->dtype = DEV_UNKNOWN;
 		csrow->edac_mode = mchcfg_ddim ? EDAC_SECDED : EDAC_NONE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/edac/pasemi_edac.c b/edac/pasemi_edac.c
--- a/edac/pasemi_edac.c
+++ b/edac/pasemi_edac.c
@@ -138,7 +138,12 @@ static int pasemi_edac_init_csrows(struc
 	u32 rankcfg;
 	int index;
 
-	for (index = 0; index < mci->nr_csrows; index++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (index = 0; index < mci->nr_csrows; index++) {
 		csrow = &mci->csrows[index];
 
 		pci_read_config_dword(pdev,
@@ -181,6 +186,12 @@ static int pasemi_edac_init_csrows(struc
 		csrow->mtype = MEM_DDR;
 		csrow->dtype = DEV_UNKNOWN;
 		csrow->edac_mode = edac_mode;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/edac/edac_mc.c b/edac/edac_mc.c
--- a/edac/edac_mc.c
+++ b/edac/edac_mc.c
@@ -191,6 +191,11 @@ struct mem_ctl_info *edac_mc_alloc(unsig
 	mci->pvt_info = pvt;
 	mci->nr_csrows = nr_csrows;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (row = 0; row < nr_csrows; row++) {
 		csrow = &csi[row];
 		csrow->csrow_idx = row;
@@ -199,10 +204,27 @@ struct mem_ctl_info *edac_mc_alloc(unsig
 		chp = &chi[row * nr_chans];
 		csrow->channels = chp;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (chn = 0; chn < nr_chans; chn++) {
 			chan = &chp[chn];
 			chan->chan_idx = chn;
 			chan->csrow = csrow;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -513,6 +535,11 @@ int edac_mc_add_mc(struct mem_ctl_info *
 	if (edac_debug_level >= 4) {
 		int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < mci->nr_csrows; i++) {
 			int j;
 
@@ -520,6 +547,12 @@ int edac_mc_add_mc(struct mem_ctl_info *
 			for (j = 0; j < mci->csrows[i].nr_channels; j++)
 				edac_mc_dump_channel(&mci->csrows[i].
 						channels[j]);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 #endif
@@ -776,12 +809,23 @@ void edac_mc_handle_ue(struct mem_ctl_in
 	len -= chars;
 	pos += chars;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (chan = 1; (chan < mci->csrows[row].nr_channels) && (len > 0);
 		chan++) {
 		chars = snprintf(pos, len + 1, ":%s",
 				 mci->csrows[row].channels[chan].label);
 		len -= chars;
 		pos += chars;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (edac_mc_get_log_ue())
diff -u -p a/edac/i82443bxgx_edac.c b/edac/i82443bxgx_edac.c
--- a/edac/i82443bxgx_edac.c
+++ b/edac/i82443bxgx_edac.c
@@ -195,6 +195,11 @@ static void i82443bxgx_init_csrows(struc
 
 	pci_read_config_byte(pdev, I82443BXGX_DRAMC, &dramc);
 	row_high_limit_last = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < mci->nr_csrows; index++) {
 		csrow = &mci->csrows[index];
 		pci_read_config_byte(pdev, I82443BXGX_DRB + index, &drbar);
@@ -226,6 +231,12 @@ static void i82443bxgx_init_csrows(struc
 		/* Mode is global to all rows on 440BX */
 		csrow->edac_mode = edac_mode;
 		row_high_limit_last = row_high_limit;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/edac/sb_edac.c b/edac/sb_edac.c
--- a/edac/sb_edac.c
+++ b/edac/sb_edac.c
@@ -470,6 +470,11 @@ static struct pci_dev *get_pdev_slot_fun
 	if (!sbridge_dev)
 		return NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sbridge_dev->n_devs; i++) {
 		if (!sbridge_dev->pdev[i])
 			continue;
@@ -480,6 +485,12 @@ static struct pci_dev *get_pdev_slot_fun
 				bus, slot, func, sbridge_dev->pdev[i]);
 			return sbridge_dev->pdev[i];
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
@@ -523,6 +534,11 @@ static int sbridge_get_active_channels(c
 		return -ENODEV;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_CHANNELS; i++) {
 		u32 mtr;
 
@@ -536,11 +552,28 @@ static int sbridge_get_active_channels(c
 		}
 		(*channels)++;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < ARRAY_SIZE(mtr_regs); j++) {
 			pci_read_config_dword(pdev, mtr_regs[j], &mtr);
 			debugf1("Bus#%02x channel #%d  MTR%d = %x\n", bus, i, j, mtr);
 			if (IS_DIMM_PRESENT(mtr))
 				(*csrows)++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}
 
@@ -612,10 +645,20 @@ static int get_dimm_config(const struct
 	/* On all supported DDR3 DIMM types, there are 8 banks available */
 	banks = 8;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_CHANNELS; i++) {
 		u32 mtr;
 
-		for (j = 0; j < ARRAY_SIZE(mtr_regs); j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; j < ARRAY_SIZE(mtr_regs); j++) {
 			pci_read_config_dword(pvt->pci_tad[i],
 					      mtr_regs[j], &mtr);
 			debugf4("Channel #%d  MTR%d = %x\n", i, j, mtr);
@@ -658,6 +701,18 @@ static int get_dimm_config(const struct
 				last_page += npages;
 				csrow++;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -764,10 +819,20 @@ static void get_memory_layout(const stru
 	/*
 	 * Step 4) Get TAD offsets, per each channel
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_CHANNELS; i++) {
 		if (!pvt->channel[i].dimms)
 			continue;
-		for (j = 0; j < n_tads; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; j < n_tads; j++) {
 			pci_read_config_dword(pvt->pci_tad[i],
 					      tad_ch_nilv_offset[j],
 					      &reg);
@@ -777,16 +842,38 @@ static void get_memory_layout(const stru
 				tmp_mb / 1000, tmp_mb % 1000,
 				((u64)tmp_mb) << 20L,
 				reg);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
 	/*
 	 * Step 6) Get RIR Wayness/Limit, per each channel
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_CHANNELS; i++) {
 		if (!pvt->channel[i].dimms)
 			continue;
-		for (j = 0; j < MAX_RIR_RANGES; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; j < MAX_RIR_RANGES; j++) {
 			pci_read_config_dword(pvt->pci_tad[i],
 					      rir_way_limit[j],
 					      &reg);
@@ -803,7 +890,12 @@ static void get_memory_layout(const stru
 				rir_way,
 				reg);
 
-			for (k = 0; k < rir_way; k++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (k = 0; k < rir_way; k++) {
 				pci_read_config_dword(pvt->pci_tad[i],
 						      rir_offset[j][k],
 						      &reg);
@@ -815,8 +907,26 @@ static void get_memory_layout(const stru
 					((u64)tmp_mb) << 20L,
 					(u32)RIR_RNK_TGT(reg),
 					reg);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1124,6 +1234,11 @@ static void sbridge_put_devices(struct s
 	int i;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sbridge_dev->n_devs; i++) {
 		struct pci_dev *pdev = sbridge_dev->pdev[i];
 		if (!pdev)
@@ -1132,6 +1247,12 @@ static void sbridge_put_devices(struct s
 			pdev->bus->number,
 			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
 		pci_dev_put(pdev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1260,6 +1381,11 @@ static int sbridge_get_all_devices(u8 *n
 	const struct pci_id_table *table = pci_dev_descr_sbridge_table;
 
 	while (table && table->descr) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
 			do {
@@ -1274,6 +1400,12 @@ static int sbridge_get_all_devices(u8 *n
 					return -ENODEV;
 				}
 			} while (pdev);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		table++;
 	}
@@ -1288,6 +1420,11 @@ static int mci_bind_devs(struct mem_ctl_
 	struct pci_dev *pdev;
 	int i, func, slot;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sbridge_dev->n_devs; i++) {
 		pdev = sbridge_dev->pdev[i];
 		if (!pdev)
@@ -1360,6 +1497,12 @@ static int mci_bind_devs(struct mem_ctl_
 			sbridge_dev->bus,
 			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
 			pdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Check if everything were registered */
@@ -1368,9 +1511,20 @@ static int mci_bind_devs(struct mem_ctl_
 	    !pvt->pci_ddrio)
 		goto enodev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_CHANNELS; i++) {
 		if (!pvt->pci_tad[i])
 			goto enodev;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return 0;
 
diff -u -p a/edac/r82600_edac.c b/edac/r82600_edac.c
--- a/edac/r82600_edac.c
+++ b/edac/r82600_edac.c
@@ -225,6 +225,11 @@ static void r82600_init_csrows(struct me
 	reg_sdram = dramcr & BIT(4);
 	row_high_limit_last = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < mci->nr_csrows; index++) {
 		csrow = &mci->csrows[index];
 
@@ -258,6 +263,12 @@ static void r82600_init_csrows(struct me
 		/* Mode is global on 82600 */
 		csrow->edac_mode = ecc_on ? EDAC_SECDED : EDAC_NONE;
 		row_high_limit_last = row_high_limit;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/edac/edac_device.c b/edac/edac_device.c
--- a/edac/edac_device.c
+++ b/edac/edac_device.c
@@ -166,6 +166,11 @@ struct edac_device_ctl_info *edac_device
 		__func__, dev_ctl, pvt + sz_private );
 
 	/* Initialize every Instance */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (instance = 0; instance < nr_instances; instance++) {
 		inst = &dev_inst[instance];
 		inst->ctl = dev_ctl;
@@ -178,7 +183,12 @@ struct edac_device_ctl_info *edac_device
 			 "%s%u", edac_device_name, instance);
 
 		/* Initialize every block in each instance */
-		for (block = 0; block < nr_blocks; block++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (block = 0; block < nr_blocks; block++) {
 			blk = &blk_p[block];
 			blk->instance = inst;
 			snprintf(blk->name, sizeof(blk->name),
@@ -208,6 +218,11 @@ struct edac_device_ctl_info *edac_device
 			 * Each block gets its own copy of pointers,
 			 * and its unique 'value'
 			 */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (attr = 0; attr < nr_attrib; attr++) {
 				attrib = &attrib_p[attr];
 
@@ -226,7 +241,25 @@ struct edac_device_ctl_info *edac_device
 					&attrib_spec[attr],
 					attrib_spec[attr].attr.name
 					);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
diff -u -p a/edac/amd76x_edac.c b/edac/amd76x_edac.c
--- a/edac/amd76x_edac.c
+++ b/edac/amd76x_edac.c
@@ -189,7 +189,12 @@ static void amd76x_init_csrows(struct me
 	u32 mba, mba_base, mba_mask, dms;
 	int index;
 
-	for (index = 0; index < mci->nr_csrows; index++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (index = 0; index < mci->nr_csrows; index++) {
 		csrow = &mci->csrows[index];
 
 		/* find the DRAM Chip Select Base address and mask */
@@ -210,6 +215,12 @@ static void amd76x_init_csrows(struct me
 		csrow->mtype = MEM_RDDR;
 		csrow->dtype = ((dms >> index) & 0x1) ? DEV_X4 : DEV_UNKNOWN;
 		csrow->edac_mode = edac_mode;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/edac/i3000_edac.c b/edac/i3000_edac.c
--- a/edac/i3000_edac.c
+++ b/edac/i3000_edac.c
@@ -330,9 +330,20 @@ static int i3000_probe1(struct pci_dev *
 	c1dra[0] = readb(window + I3000_C1DRA + 0);	/* ranks 0,1 */
 	c1dra[1] = readb(window + I3000_C1DRA + 1);	/* ranks 2,3 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < I3000_RANKS_PER_CHANNEL; i++) {
 		c0drb[i] = readb(window + I3000_C0DRB + i);
 		c1drb[i] = readb(window + I3000_C1DRB + i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	iounmap(window);
@@ -375,6 +386,11 @@ static int i3000_probe1(struct pci_dev *
 	 * If we're in interleaved mode then we're only walking through
 	 * the ranks of controller 0, so we double all the values we see.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last_cumul_size = i = 0; i < mci->nr_csrows; i++) {
 		u8 value;
 		u32 cumul_size;
@@ -399,6 +415,12 @@ static int i3000_probe1(struct pci_dev *
 		csrow->mtype = MEM_DDR2;
 		csrow->dtype = DEV_UNKNOWN;
 		csrow->edac_mode = EDAC_UNKNOWN;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/firmware/iscsi_ibft_find.c b/firmware/iscsi_ibft_find.c
--- a/firmware/iscsi_ibft_find.c
+++ b/firmware/iscsi_ibft_find.c
@@ -62,6 +62,11 @@ static int __init find_ibft_in_mem(void)
 	void *virt;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pos = IBFT_START; pos < IBFT_END; pos += 16) {
 		/* The table can't be inside the VGA BIOS reserved space,
 		 * so skip that area */
@@ -69,6 +74,11 @@ static int __init find_ibft_in_mem(void)
 			pos += VGA_SIZE;
 		virt = isa_bus_to_virt(pos);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ARRAY_SIZE(ibft_signs); i++) {
 			if (memcmp(virt, ibft_signs[i].sign, IBFT_SIGN_LEN) ==
 			    0) {
@@ -83,6 +93,18 @@ static int __init find_ibft_in_mem(void)
 					goto done;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 done:
diff -u -p a/firmware/efivars.c b/firmware/efivars.c
--- a/firmware/efivars.c
+++ b/firmware/efivars.c
@@ -260,10 +260,21 @@ validate_load_option(struct efi_variable
 	namelen = utf16_strnlen(var->VariableName, sizeof(var->VariableName));
 
 	/* Either "Boot" or "Driver" followed by four digits of hex */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = match; i < match+4; i++) {
 		if (var->VariableName[i] > 127 ||
 		    hex_to_bin(var->VariableName[i] & 0xff) < 0)
 			return true;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	/* Reject it if there's 4 digits of hex and then further content */
@@ -318,12 +329,23 @@ validate_ascii_string(struct efi_variabl
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i++) {
 		if (buffer[i] > 127)
 			return false;
 
 		if (buffer[i] == 0)
 			return true;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return false;
@@ -359,6 +381,11 @@ validate_var(struct efi_variable *var, u
 	int i;
 	u16 *unicode_name = var->VariableName;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; variable_validate[i].validate != NULL; i++) {
 		const char *name = variable_validate[i].name;
 		int match;
@@ -385,6 +412,12 @@ validate_var(struct efi_variable *var, u
 				return variable_validate[i].validate(var,
 							     match, data, len);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return true;
@@ -732,8 +765,19 @@ static ssize_t efi_pstore_read(u64 *id,
 	while (&efivars->walk_entry->list != &efivars->list) {
 		if (!efi_guidcmp(efivars->walk_entry->var.VendorGuid,
 				 vendor)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < DUMP_NAME_LEN; i++) {
 				name[i] = efivars->walk_entry->var.VariableName[i];
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if (sscanf(name, "dump-type%u-%u-%lu", type, &part, &time) == 3) {
 				*id = part;
@@ -1189,8 +1233,19 @@ efivar_create_sysfs_entry(struct efivars
 
 	/* Convert Unicode to normal chars (assume top bits are 0),
 	   ala UTF-8 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i < (int)(variable_name_size / sizeof(efi_char16_t)); i++) {
 		short_name[i] = variable_name[i] & 0xFF;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* This is ugly, but necessary to separate one vendor's
 	   private variables from another's.         */
diff -u -p a/firmware/google/memconsole.c b/firmware/google/memconsole.c
--- a/firmware/google/memconsole.c
+++ b/firmware/google/memconsole.c
@@ -106,6 +106,11 @@ static bool found_memconsole(void)
 	 * Search through EBDA for BIOS memory console structure
 	 * note: signature is not necessarily dword-aligned
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur = 0; cur < length; cur++) {
 		struct biosmemcon_ebda *hdr = phys_to_virt(address + cur);
 
@@ -120,6 +125,12 @@ static bool found_memconsole(void)
 			found_v2_header(hdr);
 			return true;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_INFO "BIOS console EBDA structure not found!\n");
diff -u -p a/firmware/edd.c b/firmware/edd.c
--- a/firmware/edd.c
+++ b/firmware/edd.c
@@ -139,12 +139,23 @@ edd_show_host_bus(struct edd_device *ede
 	if (!info || !buf)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		if (isprint(info->params.host_bus_type[i])) {
 			p += scnprintf(p, left, "%c", info->params.host_bus_type[i]);
 		} else {
 			p += scnprintf(p, left, " ");
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!strncmp(info->params.host_bus_type, "ISA", 3)) {
@@ -185,12 +196,23 @@ edd_show_interface(struct edd_device *ed
 	if (!info || !buf)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		if (isprint(info->params.interface_type[i])) {
 			p += scnprintf(p, left, "%c", info->params.interface_type[i]);
 		} else {
 			p += scnprintf(p, left, " ");
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!strncmp(info->params.interface_type, "ATAPI", 5)) {
 		p += scnprintf(p, left, "\tdevice: %u  lun: %u\n",
@@ -702,10 +724,21 @@ static void edd_populate_dir(struct edd_
 	int error = 0;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; (attr = edd_attrs[i]) && !error; i++) {
 		if (!attr->test ||
 		    (attr->test && attr->test(edev)))
 			error = sysfs_create_file(&edev->kobj,&attr->attr);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!error) {
@@ -760,6 +793,11 @@ edd_init(void)
 	if (!edd_kset)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < edd_num_devices(); i++) {
 		edev = kzalloc(sizeof (*edev), GFP_KERNEL);
 		if (!edev) {
@@ -773,6 +811,12 @@ edd_init(void)
 			goto out;
 		}
 		edd_devices[i] = edev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -790,9 +834,20 @@ edd_exit(void)
 	int i;
 	struct edd_device *edev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < edd_num_devices(); i++) {
 		if ((edev = edd_devices[i]))
 			edd_device_unregister(edev);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	kset_unregister(edd_kset);
 }
diff -u -p a/firmware/pcdp.c b/firmware/pcdp.c
--- a/firmware/pcdp.c
+++ b/firmware/pcdp.c
@@ -109,6 +109,11 @@ efi_setup_pcdp_console(char *cmdline)
 	if (pcdp->rev < 3 && efi_uart_console_only())
 		serial = 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, uart = pcdp->uart; i < pcdp->num_uarts; i++, uart++) {
 		if (uart->flags & PCDP_UART_PRIMARY_CONSOLE || serial) {
 			if (uart->type == PCDP_CONSOLE_UART) {
@@ -116,9 +121,20 @@ efi_setup_pcdp_console(char *cmdline)
 				goto out;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	end = (struct pcdp_device *) ((u8 *) pcdp + pcdp->length);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = (struct pcdp_device *) (pcdp->uart + pcdp->num_uarts);
 	     dev < end;
 	     dev = (struct pcdp_device *) ((u8 *) dev + dev->length)) {
@@ -128,6 +144,12 @@ efi_setup_pcdp_console(char *cmdline)
 				goto out;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
diff -u -p a/firmware/dmi_scan.c b/firmware/dmi_scan.c
--- a/firmware/dmi_scan.c
+++ b/firmware/dmi_scan.c
@@ -161,11 +161,22 @@ static void __init dmi_save_uuid(const s
 	if (dmi_ident[slot])
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16 && (is_ff || is_00); i++) {
 		if (d[i] != 0x00)
 			is_00 = 0;
 		if (d[i] != 0xFF)
 			is_ff = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (is_ff || is_00)
@@ -229,6 +240,11 @@ static void __init dmi_save_devices(cons
 {
 	int i, count = (dm->length - sizeof(struct dmi_header)) / 2;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i++) {
 		const char *d = (char *)(dm + 1) + (i * 2);
 
@@ -237,6 +253,12 @@ static void __init dmi_save_devices(cons
 			continue;
 
 		dmi_save_one_device(*d & 0x7f, dmi_string_nosave(dm, *(d + 1)));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -499,6 +521,11 @@ void __init dmi_scan_machine(void)
 		if (p == NULL)
 			goto error;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (q = p; q < p + 0x10000; q += 16) {
 			if (memcmp(q, "_SM_", 4) == 0 && q - p <= 0xFFE0)
 				rc = smbios_present(q);
@@ -511,6 +538,12 @@ void __init dmi_scan_machine(void)
 				dmi_iounmap(p, 0x10000);
 				goto out;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dmi_iounmap(p, 0x10000);
 	}
@@ -644,10 +677,21 @@ int dmi_name_in_vendors(const char *str)
 {
 	static int fields[] = { DMI_SYS_VENDOR, DMI_BOARD_VENDOR, DMI_NONE };
 	int i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; fields[i] != DMI_NONE; i++) {
 		int f = fields[i];
 		if (dmi_ident[f] && strstr(dmi_ident[f], str))
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
@@ -671,13 +715,24 @@ const struct dmi_device * dmi_find_devic
 	const struct list_head *head = from ? &from->list : &dmi_devices;
 	struct list_head *d;
 
-	for(d = head->next; d != &dmi_devices; d = d->next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for(d = head->next; d != &dmi_devices; d = d->next) {
 		const struct dmi_device *dev =
 			list_entry(d, struct dmi_device, list);
 
 		if (((type == DMI_DEV_TYPE_ANY) || (dev->type == type)) &&
 		    ((name == NULL) || (strcmp(dev->name, name) == 0)))
 			return dev;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NULL;
diff -u -p a/firmware/iscsi_ibft.c b/firmware/iscsi_ibft.c
--- a/firmware/iscsi_ibft.c
+++ b/firmware/iscsi_ibft.c
@@ -766,9 +766,20 @@ static void __init acpi_find_ibft_region
 	if (acpi_disabled)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(ibft_signs) && !ibft_addr; i++) {
 		acpi_get_table(ibft_signs[i].sign, 0, &table);
 		ibft_addr = (struct acpi_table_ibft *)table;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 #else
diff -u -p a/firmware/dcdbas.c b/firmware/dcdbas.c
--- a/firmware/dcdbas.c
+++ b/firmware/dcdbas.c
@@ -364,13 +364,24 @@ static int host_control_smi(void)
 		spin_lock_irqsave(&rtc_lock, flags);
 		/* write SMI data buffer physical address */
 		data = (u8 *)&smi_data_buf_phys_addr;
-		for (index = PE1300_CMOS_CMD_STRUCT_PTR;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (index = PE1300_CMOS_CMD_STRUCT_PTR;
 		     index < (PE1300_CMOS_CMD_STRUCT_PTR + 4);
 		     index++, data++) {
 			outb(index,
 			     (CMOS_BASE_PORT + CMOS_PAGE2_INDEX_PORT_PIIX4));
 			outb(*data,
 			     (CMOS_BASE_PORT + CMOS_PAGE2_DATA_PORT_PIIX4));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		/* first set status to -1 as called by spec */
@@ -396,11 +407,22 @@ static int host_control_smi(void)
 		spin_lock_irqsave(&rtc_lock, flags);
 		/* write SMI data buffer physical address */
 		data = (u8 *)&smi_data_buf_phys_addr;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (index = PE1400_CMOS_CMD_STRUCT_PTR;
 		     index < (PE1400_CMOS_CMD_STRUCT_PTR + 4);
 		     index++, data++) {
 			outb(index, (CMOS_BASE_PORT + CMOS_PAGE1_INDEX_PORT));
 			outb(*data, (CMOS_BASE_PORT + CMOS_PAGE1_DATA_PORT));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* generate SMM call */
@@ -555,7 +577,12 @@ static int __devinit dcdbas_probe(struct
 	if (error)
 		return error;
 
-	for (i = 0; dcdbas_bin_attrs[i]; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; dcdbas_bin_attrs[i]; i++) {
 		error = sysfs_create_bin_file(&dev->dev.kobj,
 					      dcdbas_bin_attrs[i]);
 		if (error) {
@@ -565,6 +592,12 @@ static int __devinit dcdbas_probe(struct
 			sysfs_remove_group(&dev->dev.kobj, &dcdbas_attr_group);
 			return error;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	register_reboot_notifier(&dcdbas_reboot_nb);
diff -u -p a/regulator/lp3972.c b/regulator/lp3972.c
--- a/regulator/lp3972.c
+++ b/regulator/lp3972.c
@@ -552,6 +552,11 @@ static int __devinit setup_regulators(st
 	}
 
 	/* Instantiate the regulators */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_regulators; i++) {
 		struct lp3972_regulator_subdev *reg = &pdata->regulators[i];
 		lp3972->rdev[i] = regulator_register(&regulators[reg->id],
@@ -563,6 +568,12 @@ static int __devinit setup_regulators(st
 				err);
 			goto error;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/regulator/ab8500.c b/regulator/ab8500.c
--- a/regulator/ab8500.c
+++ b/regulator/ab8500.c
@@ -243,10 +243,21 @@ static int ab8500_get_best_voltage_index
 	int i;
 
 	/* check the supported voltage */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < info->voltages_len; i++) {
 		if ((info->voltages[i] >= min_uV) &&
 		    (info->voltages[i] <= max_uV))
 			return i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return -EINVAL;
@@ -760,6 +771,11 @@ static __devinit int ab8500_regulator_pr
 	}
 
 	/* initialize registers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_regulator_reg_init; i++) {
 		int id;
 		u8 value;
@@ -798,9 +814,20 @@ static __devinit int ab8500_regulator_pr
 			ab8500_reg_init[id].addr,
 			ab8500_reg_init[id].mask,
 			value);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* register all regulators */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(ab8500_regulator_info); i++) {
 		struct ab8500_regulator_info *info = NULL;
 
@@ -837,6 +864,12 @@ static __devinit int ab8500_regulator_pr
 
 		dev_vdbg(rdev_get_dev(info->regulator),
 			"%s-probed\n", info->desc.name);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -846,7 +879,12 @@ static __devexit int ab8500_regulator_re
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(ab8500_regulator_info); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(ab8500_regulator_info); i++) {
 		struct ab8500_regulator_info *info = NULL;
 		info = &ab8500_regulator_info[i];
 
@@ -854,6 +892,12 @@ static __devexit int ab8500_regulator_re
 			"%s-remove\n", info->desc.name);
 
 		regulator_unregister(info->regulator);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
diff -u -p a/regulator/db8500-prcmu.c b/regulator/db8500-prcmu.c
--- a/regulator/db8500-prcmu.c
+++ b/regulator/db8500-prcmu.c
@@ -476,6 +476,11 @@ static int __devinit db8500_regulator_pr
 	int i, err;
 
 	/* register all regulators */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(db8500_regulator_info); i++) {
 		struct db8500_regulator_info *info;
 		struct regulator_init_data *init_data = &db8500_init_data[i];
@@ -502,6 +507,12 @@ static int __devinit db8500_regulator_pr
 
 		dev_dbg(rdev_get_dev(info->rdev),
 			"regulator-%s-probed\n", info->desc.name);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -511,7 +522,12 @@ static int __exit db8500_regulator_remov
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(db8500_regulator_info); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(db8500_regulator_info); i++) {
 		struct db8500_regulator_info *info;
 		info = &db8500_regulator_info[i];
 
@@ -519,6 +535,12 @@ static int __exit db8500_regulator_remov
 			"regulator-%s-remove\n", info->desc.name);
 
 		regulator_unregister(info->rdev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
diff -u -p a/regulator/tps65910-regulator.c b/regulator/tps65910-regulator.c
--- a/regulator/tps65910-regulator.c
+++ b/regulator/tps65910-regulator.c
@@ -937,6 +937,11 @@ static __devinit int tps65910_probe(stru
 		goto err_free_info;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pmic->num_regulators; i++, info++, reg_data++) {
 		/* Register the regulators */
 		pmic->info[i] = info;
@@ -976,6 +981,12 @@ static __devinit int tps65910_probe(stru
 
 		/* Save regulator for cleanup */
 		pmic->rdev[i] = rdev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
diff -u -p a/regulator/mc13783-regulator.c b/regulator/mc13783-regulator.c
--- a/regulator/mc13783-regulator.c
+++ b/regulator/mc13783-regulator.c
@@ -353,6 +353,11 @@ static int __devinit mc13783_regulator_p
 	priv->mc13xxx_regulators = mc13783_regulators;
 	priv->mc13xxx = mc13783;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_regulators; i++) {
 		init_data = &pdata->regulators[i];
 		priv->regulators[i] = regulator_register(
@@ -365,6 +370,12 @@ static int __devinit mc13783_regulator_p
 			ret = PTR_ERR(priv->regulators[i]);
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	platform_set_drvdata(pdev, priv);
diff -u -p a/regulator/max8925-regulator.c b/regulator/max8925-regulator.c
--- a/regulator/max8925-regulator.c
+++ b/regulator/max8925-regulator.c
@@ -242,10 +242,21 @@ static struct max8925_regulator_info * _
 	struct max8925_regulator_info *ri;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(max8925_regulator_info); i++) {
 		ri = &max8925_regulator_info[i];
 		if (ri->desc.id == id)
 			return ri;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NULL;
 }
diff -u -p a/regulator/mc13xxx-regulator-core.c b/regulator/mc13xxx-regulator-core.c
--- a/regulator/mc13xxx-regulator-core.c
+++ b/regulator/mc13xxx-regulator-core.c
@@ -110,12 +110,23 @@ int mc13xxx_get_best_voltage_index(struc
 	 */
 	bestmatch = INT_MAX;
 	bestindex = -1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mc13xxx_regulators[reg_id].desc.n_voltages; i++) {
 		if (mc13xxx_regulators[reg_id].voltages[i] >= min_uV &&
 		    mc13xxx_regulators[reg_id].voltages[i] < bestmatch) {
 			bestmatch = mc13xxx_regulators[reg_id].voltages[i];
 			bestindex = i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (bestindex < 0 || bestmatch > max_uV) {
diff -u -p a/regulator/max8660.c b/regulator/max8660.c
--- a/regulator/max8660.c
+++ b/regulator/max8660.c
@@ -399,6 +399,11 @@ static int __devinit max8660_probe(struc
 	max8660->shadow_regs[MAX8660_MDTV1] =
 		max8660->shadow_regs[MAX8660_MDTV2] = 0x04;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_subdevs; i++) {
 
 		if (!pdata->subdevs[i].platform_data)
@@ -440,9 +445,20 @@ static int __devinit max8660_probe(struc
 				 pdata->subdevs[i].name);
 			goto err_free;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Finally register devices */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_subdevs; i++) {
 
 		id = pdata->subdevs[i].id;
@@ -456,6 +472,12 @@ static int __devinit max8660_probe(struc
 				max8660_reg[id].name);
 			goto err_unregister;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	i2c_set_clientdata(client, max8660);
diff -u -p a/regulator/isl6271a-regulator.c b/regulator/isl6271a-regulator.c
--- a/regulator/isl6271a-regulator.c
+++ b/regulator/isl6271a-regulator.c
@@ -168,7 +168,12 @@ static int __devinit isl6271a_probe(stru
 
 	mutex_init(&pmic->mtx);
 
-	for (i = 0; i < 3; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 3; i++) {
 		pmic->rdev[i] = regulator_register(&isl_rd[i], &i2c->dev,
 						init_data, pmic);
 		if (IS_ERR(pmic->rdev[i])) {
@@ -176,6 +181,12 @@ static int __devinit isl6271a_probe(stru
 			err = PTR_ERR(pmic->rdev[i]);
 			goto error;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	i2c_set_clientdata(i2c, pmic);
diff -u -p a/regulator/mc13892-regulator.c b/regulator/mc13892-regulator.c
--- a/regulator/mc13892-regulator.c
+++ b/regulator/mc13892-regulator.c
@@ -569,6 +569,11 @@ static int __devinit mc13892_regulator_p
 		= mc13892_vcam_set_mode;
 	mc13892_regulators[MC13892_VCAM].desc.ops->get_mode
 		= mc13892_vcam_get_mode;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_regulators; i++) {
 		init_data = &pdata->regulators[i];
 		priv->regulators[i] = regulator_register(
@@ -581,6 +586,12 @@ static int __devinit mc13892_regulator_p
 			ret = PTR_ERR(priv->regulators[i]);
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	platform_set_drvdata(pdev, priv);
diff -u -p a/regulator/tps65023-regulator.c b/regulator/tps65023-regulator.c
--- a/regulator/tps65023-regulator.c
+++ b/regulator/tps65023-regulator.c
@@ -482,6 +482,11 @@ static int __devinit tps_65023_probe(str
 	tps->client = client;
 	tps->core_regulator = drv_data->core_regulator;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < TPS65023_NUM_REGULATOR; i++, info++, init_data++) {
 		/* Store regulator specific information */
 		tps->info[i] = info;
@@ -506,6 +511,12 @@ static int __devinit tps_65023_probe(str
 
 		/* Save regulator for cleanup */
 		tps->rdev[i] = rdev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	i2c_set_clientdata(client, tps);
diff -u -p a/regulator/da903x.c b/regulator/da903x.c
--- a/regulator/da903x.c
+++ b/regulator/da903x.c
@@ -505,10 +505,21 @@ static inline struct da903x_regulator_in
 	struct da903x_regulator_info *ri;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(da903x_regulator_info); i++) {
 		ri = &da903x_regulator_info[i];
 		if (ri->desc.id == id)
 			return ri;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NULL;
 }
diff -u -p a/regulator/tps65912-regulator.c b/regulator/tps65912-regulator.c
--- a/regulator/tps65912-regulator.c
+++ b/regulator/tps65912-regulator.c
@@ -713,6 +713,11 @@ static __devinit int tps65912_probe(stru
 	pmic->get_ctrl_reg = &tps65912_get_ctrl_register;
 	info = tps65912_regs;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < TPS65912_NUM_REGULATOR; i++, info++, reg_data++) {
 		int range = 0;
 		/* Register the regulators */
@@ -738,6 +743,12 @@ static __devinit int tps65912_probe(stru
 
 		/* Save regulator for cleanup */
 		pmic->rdev[i] = rdev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
diff -u -p a/regulator/twl-regulator.c b/regulator/twl-regulator.c
--- a/regulator/twl-regulator.c
+++ b/regulator/twl-regulator.c
@@ -466,6 +466,11 @@ twl4030ldo_set_voltage(struct regulator_
 	struct twlreg_info	*info = rdev_get_drvdata(rdev);
 	int			vsel;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vsel = 0; vsel < info->table_len; vsel++) {
 		int mV = info->table[vsel];
 		int uV;
@@ -482,6 +487,12 @@ twl4030ldo_set_voltage(struct regulator_
 			return twlreg_write(info, TWL_MODULE_PM_RECEIVER,
 							VREG_VOLTAGE, vsel);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -EDOM;
@@ -1053,11 +1064,22 @@ static int __devinit twlreg_probe(struct
 	struct regulation_constraints	*c;
 	struct regulator_dev		*rdev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, info = NULL; i < ARRAY_SIZE(twl_regs); i++) {
 		if (twl_regs[i].desc.id != pdev->id)
 			continue;
 		info = twl_regs + i;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!info)
 		return -ENODEV;
diff -u -p a/regulator/max8952.c b/regulator/max8952.c
--- a/regulator/max8952.c
+++ b/regulator/max8952.c
@@ -142,6 +142,11 @@ static int max8952_set_voltage(struct re
 		return -EPERM;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX8952_NUM_DVS_MODE; i++) {
 		int volt = max8952_voltage(max8952, i);
 
@@ -149,6 +154,12 @@ static int max8952_set_voltage(struct re
 		if (volt <= max_uV && volt >= min_uV)
 			if (vid == -1 || max8952_voltage(max8952, vid) > volt)
 				vid = i;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+			break;
+		}
 	}
 
 	if (vid >= 0 && vid < MAX8952_NUM_DVS_MODE) {
diff -u -p a/regulator/ab3100.c b/regulator/ab3100.c
--- a/regulator/ab3100.c
+++ b/regulator/ab3100.c
@@ -321,6 +321,11 @@ static int ab3100_get_best_voltage_index
 	 */
 	bestmatch = INT_MAX;
 	bestindex = -1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < abreg->voltages_len; i++) {
 		if (abreg->typ_voltages[i] <= max_uV &&
 		    abreg->typ_voltages[i] >= min_uV &&
@@ -328,6 +333,12 @@ static int ab3100_get_best_voltage_index
 			bestmatch = abreg->typ_voltages[i];
 			bestindex = i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (bestindex < 0) {
@@ -601,7 +612,12 @@ static int __devinit ab3100_regulators_p
 			   "chip is in inactive mode (Cold start)\n");
 
 	/* Set up regulators */
-	for (i = 0; i < ARRAY_SIZE(ab3100_reg_init_order); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(ab3100_reg_init_order); i++) {
 		err = abx500_set_register_interruptible(&pdev->dev, 0,
 					ab3100_reg_init_order[i],
 					plfdata->reg_initvals[i]);
@@ -610,9 +626,20 @@ static int __devinit ab3100_regulators_p
 				err);
 			return err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Register the regulators */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < AB3100_NUM_REGULATORS; i++) {
 		struct ab3100_regulator *reg = &ab3100_regulators[i];
 		struct regulator_dev *rdev;
@@ -650,6 +677,12 @@ static int __devinit ab3100_regulators_p
 
 		/* Then set a pointer back to the registered regulator */
 		reg->rdev = rdev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -659,10 +692,21 @@ static int __devexit ab3100_regulators_r
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < AB3100_NUM_REGULATORS; i++) {
 		struct ab3100_regulator *reg = &ab3100_regulators[i];
 
 		regulator_unregister(reg->rdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/regulator/tps6524x-regulator.c b/regulator/tps6524x-regulator.c
--- a/regulator/tps6524x-regulator.c
+++ b/regulator/tps6524x-regulator.c
@@ -603,10 +603,21 @@ static int pmic_remove(struct spi_device
 
 	if (!hw)
 		return 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < N_REGULATORS; i++) {
 		if (hw->rdev[i])
 			regulator_unregister(hw->rdev[i]);
 		hw->rdev[i] = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spi_set_drvdata(spi, NULL);
 	kfree(hw);
@@ -639,6 +650,11 @@ static int __devinit pmic_probe(struct s
 	hw->spi = spi_dev_get(spi);
 	mutex_init(&hw->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < N_REGULATORS; i++, info++, init_data++) {
 		hw->desc[i].name	= info->name;
 		hw->desc[i].id		= i;
@@ -657,6 +673,12 @@ static int __devinit pmic_probe(struct s
 			hw->rdev[i] = NULL;
 			goto fail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/regulator/max1586.c b/regulator/max1586.c
--- a/regulator/max1586.c
+++ b/regulator/max1586.c
@@ -204,6 +204,11 @@ static int __devinit max1586_pmic_probe(
 	max1586->max_uV = MAX1586_V3_MAX_UV / 1000 * pdata->v3_gain / 1000;
 
 	rdev = max1586->rdev;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_subdevs && i <= MAX1586_V6; i++) {
 		id = pdata->subdevs[i].id;
 		if (!pdata->subdevs[i].platform_data)
@@ -221,6 +226,12 @@ static int __devinit max1586_pmic_probe(
 				max1586_reg[id].name);
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	i2c_set_clientdata(client, max1586);
diff -u -p a/regulator/pcap-regulator.c b/regulator/pcap-regulator.c
--- a/regulator/pcap-regulator.c
+++ b/regulator/pcap-regulator.c
@@ -163,6 +163,11 @@ static int pcap_regulator_set_voltage(st
 	if (vreg->n_voltages == 1)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < vreg->n_voltages; i++) {
 		/* For V1 the first is not the best match */
 		if (i == 0 && rdev_get_id(rdev) == V1)
@@ -180,6 +185,12 @@ static int pcap_regulator_set_voltage(st
 
 		if (i == 0 && rdev_get_id(rdev) == V1)
 			i = vreg->n_voltages - 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* the requested voltage range is not supported by this regulator */
diff -u -p a/regulator/max8998.c b/regulator/max8998.c
--- a/regulator/max8998.c
+++ b/regulator/max8998.c
@@ -415,6 +415,11 @@ static int max8998_set_voltage_buck(stru
 
 			/* check if requested voltage */
 			/* value is already defined */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < ARRAY_SIZE(max8998->buck1_vol); j++) {
 				if (max8998->buck1_vol[j] == i) {
 					max8998->buck1_idx = j;
@@ -422,6 +427,12 @@ static int max8998_set_voltage_buck(stru
 						       pdata->buck1_set2, j);
 					goto buck1_exit;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			if (pdata->buck_voltage_lock)
@@ -457,12 +468,23 @@ buck1_exit:
 
 			/* check if requested voltage */
 			/* value is already defined */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < ARRAY_SIZE(max8998->buck2_vol); j++) {
 				if (max8998->buck2_vol[j] == i) {
 					max8998->buck2_idx = j;
 					buck2_gpio_set(pdata->buck2_set3, j);
 					goto buck2_exit;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			if (pdata->buck_voltage_lock)
@@ -836,6 +858,11 @@ static __devinit int max8998_pmic_probe(
 			goto err_free_mem;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_regulators; i++) {
 		const struct voltage_map_desc *desc;
 		int id = pdata->regulators[i].id;
@@ -854,6 +881,12 @@ static __devinit int max8998_pmic_probe(
 			rdev[i] = NULL;
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 
diff -u -p a/regulator/lp3971.c b/regulator/lp3971.c
--- a/regulator/lp3971.c
+++ b/regulator/lp3971.c
@@ -448,6 +448,11 @@ static int __devinit setup_regulators(st
 	}
 
 	/* Instantiate the regulators */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_regulators; i++) {
 		struct lp3971_regulator_subdev *reg = &pdata->regulators[i];
 		lp3971->rdev[i] = regulator_register(&regulators[reg->id],
@@ -459,6 +464,12 @@ static int __devinit setup_regulators(st
 				err);
 			goto error;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/regulator/wm8350-regulator.c b/regulator/wm8350-regulator.c
--- a/regulator/wm8350-regulator.c
+++ b/regulator/wm8350-regulator.c
@@ -99,11 +99,22 @@ static int get_isink_val(int min_uA, int
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ARRAY_SIZE(isink_cur) - 1; i >= 0; i--) {
 		if (min_uA <= isink_cur[i] && max_uA >= isink_cur[i]) {
 			*setting = i;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EINVAL;
 }
diff -u -p a/regulator/wm831x-isink.c b/regulator/wm831x-isink.c
--- a/regulator/wm831x-isink.c
+++ b/regulator/wm831x-isink.c
@@ -99,6 +99,11 @@ static int wm831x_isink_set_current(stru
 	struct wm831x *wm831x = isink->wm831x;
 	int ret, i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(wm831x_isinkv_values); i++) {
 		int val = wm831x_isinkv_values[i];
 		if (min_uA >= val && val <= max_uA) {
@@ -106,6 +111,12 @@ static int wm831x_isink_set_current(stru
 					      WM831X_CS1_ISEL_MASK, i);
 			return ret;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -EINVAL;
diff -u -p a/regulator/tps6586x-regulator.c b/regulator/tps6586x-regulator.c
--- a/regulator/tps6586x-regulator.c
+++ b/regulator/tps6586x-regulator.c
@@ -92,6 +92,11 @@ static int __tps6586x_ldo_set_voltage(st
 	int val, uV;
 	uint8_t mask;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (val = 0; val < ri->desc.n_voltages; val++) {
 		uV = ri->voltages[val] * 1000;
 
@@ -109,6 +114,12 @@ static int __tps6586x_ldo_set_voltage(st
 
 			return tps6586x_update(parent, ri->volt_reg, val, mask);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -EINVAL;
@@ -368,10 +379,21 @@ static inline struct tps6586x_regulator
 	struct tps6586x_regulator *ri;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(tps6586x_regulator); i++) {
 		ri = &tps6586x_regulator[i];
 		if (ri->desc.id == id)
 			return ri;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NULL;
 }
diff -u -p a/regulator/core.c b/regulator/core.c
--- a/regulator/core.c
+++ b/regulator/core.c
@@ -830,6 +830,11 @@ static int machine_constraints_voltage(s
 		}
 
 		/* initial: [cmin..cmax] valid, [min_uV..max_uV] not */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; i++) {
 			int	value;
 
@@ -842,6 +847,12 @@ static int machine_constraints_voltage(s
 				min_uV = value;
 			if (value <= cmax && value > max_uV)
 				max_uV = value;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		/* final: [min_uV..max_uV] valid iff constraints valid */
@@ -1566,21 +1577,43 @@ static void regulator_disable_work(struc
 	count = rdev->deferred_disables;
 	rdev->deferred_disables = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i++) {
 		ret = _regulator_disable(rdev);
 		if (ret != 0)
 			rdev_err(rdev, "Deferred disable failed: %d\n", ret);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&rdev->mutex);
 
 	if (rdev->supply) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; i++) {
 			ret = regulator_disable(rdev->supply);
 			if (ret != 0) {
 				rdev_err(rdev,
 					 "Supply disable failed: %d\n", ret);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -1717,11 +1750,22 @@ int regulator_is_supported_voltage(struc
 		return ret;
 	voltages = ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < voltages; i++) {
 		ret = regulator_list_voltage(regulator, i);
 
 		if (ret >= min_uV && ret <= max_uV)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -1757,6 +1801,11 @@ static int _regulator_do_set_voltage(str
 		/* Find the smallest voltage that falls within the specified
 		 * range.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < rdev->desc->n_voltages; i++) {
 			ret = rdev->desc->ops->list_voltage(rdev, i);
 			if (ret < 0)
@@ -1766,6 +1815,12 @@ static int _regulator_do_set_voltage(str
 				best_val = ret;
 				selector = i;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/*
@@ -1894,6 +1949,11 @@ int regulator_set_voltage_time(struct re
 	    || !rdev->desc->n_voltages)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < rdev->desc->n_voltages; i++) {
 		/* We only look for exact voltage matches here */
 		voltage = regulator_list_voltage(regulator, i);
@@ -1905,6 +1965,12 @@ int regulator_set_voltage_time(struct re
 			old_sel = i;
 		if (voltage == new_uV)
 			new_sel = i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	if (old_sel < 0 || new_sel < 0)
@@ -2317,7 +2383,12 @@ int regulator_bulk_get(struct device *de
 	for (i = 0; i < num_consumers; i++)
 		consumers[i].consumer = NULL;
 
-	for (i = 0; i < num_consumers; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < num_consumers; i++) {
 		consumers[i].consumer = regulator_get(dev,
 						      consumers[i].supply);
 		if (IS_ERR(consumers[i].consumer)) {
@@ -2327,6 +2398,12 @@ int regulator_bulk_get(struct device *de
 			consumers[i].consumer = NULL;
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -2372,11 +2449,22 @@ int regulator_bulk_enable(int num_consum
 	async_synchronize_full_domain(&async_domain);
 
 	/* If any consumer failed we need to unwind any that succeeded */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_consumers; i++) {
 		if (consumers[i].ret != 0) {
 			ret = consumers[i].ret;
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -2411,10 +2499,21 @@ int regulator_bulk_disable(int num_consu
 	int i;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_consumers; i++) {
 		ret = regulator_disable(consumers[i].consumer);
 		if (ret != 0)
 			goto err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -2442,9 +2541,20 @@ void regulator_bulk_free(int num_consume
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_consumers; i++) {
 		regulator_put(consumers[i].consumer);
 		consumers[i].consumer = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(regulator_bulk_free);
@@ -2742,7 +2852,12 @@ struct regulator_dev *regulator_register
 	}
 
 	/* add consumers devices */
-	for (i = 0; i < init_data->num_consumer_supplies; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < init_data->num_consumer_supplies; i++) {
 		ret = set_consumer_device_supply(rdev,
 			init_data->consumer_supplies[i].dev,
 			init_data->consumer_supplies[i].dev_name,
@@ -2752,6 +2867,12 @@ struct regulator_dev *regulator_register
 				init_data->consumer_supplies[i].supply);
 			goto unset_supplies;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	list_add(&rdev->list, &regulator_list);
diff -u -p a/regulator/gpio-regulator.c b/regulator/gpio-regulator.c
--- a/regulator/gpio-regulator.c
+++ b/regulator/gpio-regulator.c
@@ -116,9 +116,20 @@ static int gpio_regulator_set_value(stru
 	if (target < 0)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = 0; ptr < data->nr_gpios; ptr++) {
 		state = (target & (1 << ptr)) >> ptr;
 		gpio_set_value(data->gpios[ptr].gpio, state);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	data->state = target;
 
@@ -277,9 +288,20 @@ static int __devinit gpio_regulator_prob
 
 	/* build initial state from gpio init data. */
 	state = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = 0; ptr < drvdata->nr_gpios; ptr++) {
 		if (config->gpios[ptr].flags & GPIOF_OUT_INIT_HIGH)
 			state |= (1 << ptr);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	drvdata->state = state;
 
diff -u -p a/regulator/max8997.c b/regulator/max8997.c
--- a/regulator/max8997.c
+++ b/regulator/max8997.c
@@ -593,6 +593,11 @@ static int max8997_assess_side_effect(st
 	buckx_gpiodvs[1] = max8997->buck2_gpiodvs;
 	buckx_gpiodvs[2] = max8997->buck5_gpiodvs;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		int others;
 
@@ -602,6 +607,11 @@ static int max8997_assess_side_effect(st
 		}
 
 		side_effect[i] = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (others = 0; others < 3; others++) {
 			int diff;
 
@@ -615,6 +625,12 @@ static int max8997_assess_side_effect(st
 				side_effect[i] += diff;
 			else if (diff < 0)
 				side_effect[i] -= diff;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (side_effect[i] == 0) {
 			*best = i;
@@ -624,6 +640,12 @@ static int max8997_assess_side_effect(st
 			min_side_effect = side_effect[i];
 			*best = i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (*best == -1)
@@ -996,7 +1018,12 @@ static __devinit int max8997_pmic_probe(
 	memcpy(max8997->buck125_gpios, pdata->buck125_gpios, sizeof(int) * 3);
 	max8997->ignore_gpiodvs_side_effect = pdata->ignore_gpiodvs_side_effect;
 
-	for (i = 0; i < 8; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 8; i++) {
 		max8997->buck1_vol[i] = ret =
 			max8997_get_voltage_proper_val(
 					&buck1245_voltage_map_desc,
@@ -1030,16 +1057,33 @@ static __devinit int max8997_pmic_probe(
 			max_buck2 = max8997->buck2_vol[i];
 		if (max_buck5 < max8997->buck5_vol[i])
 			max_buck5 = max8997->buck5_vol[i];
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* For the safety, set max voltage before setting up */
-	for (i = 0; i < 8; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < 8; i++) {
 		max8997_update_reg(i2c, MAX8997_REG_BUCK1DVS1 + i,
 				max_buck1, 0x3f);
 		max8997_update_reg(i2c, MAX8997_REG_BUCK2DVS1 + i,
 				max_buck2, 0x3f);
 		max8997_update_reg(i2c, MAX8997_REG_BUCK5DVS1 + i,
 				max_buck5, 0x3f);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/*
@@ -1114,7 +1158,12 @@ static __devinit int max8997_pmic_probe(
 			(1 << 1) : (0 << 1), 1 << 1);
 
 	/* Initialize all the DVS related BUCK registers */
-	for (i = 0; i < 8; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 8; i++) {
 		max8997_update_reg(i2c, MAX8997_REG_BUCK1DVS1 + i,
 				max8997->buck1_vol[i],
 				0x3f);
@@ -1124,12 +1173,23 @@ static __devinit int max8997_pmic_probe(
 		max8997_update_reg(i2c, MAX8997_REG_BUCK5DVS1 + i,
 				max8997->buck5_vol[i],
 				0x3f);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Misc Settings */
 	max8997->ramp_delay = 10; /* set 10mV/us, which is the default */
 	max8997_write_reg(i2c, MAX8997_REG_BUCKRAMP, (0xf << 4) | 0x9);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pdata->num_regulators; i++) {
 		const struct voltage_map_desc *desc;
 		int id = pdata->regulators[i].id;
@@ -1152,6 +1212,12 @@ static __devinit int max8997_pmic_probe(
 			rdev[i] = NULL;
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/regulator/tps6507x-regulator.c b/regulator/tps6507x-regulator.c
--- a/regulator/tps6507x-regulator.c
+++ b/regulator/tps6507x-regulator.c
@@ -581,6 +581,11 @@ int tps6507x_pmic_probe(struct platform_
 	/* common for all regulators */
 	tps->mfd = tps6507x_dev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < TPS6507X_NUM_REGULATOR; i++, info++, init_data++) {
 		/* Register the regulators */
 		tps->info[i] = info;
@@ -610,6 +615,12 @@ int tps6507x_pmic_probe(struct platform_
 
 		/* Save regulator for cleanup */
 		tps->rdev[i] = rdev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tps6507x_dev->pmic = tps;
diff -u -p a/hwspinlock/hwspinlock_core.c b/hwspinlock/hwspinlock_core.c
--- a/hwspinlock/hwspinlock_core.c
+++ b/hwspinlock/hwspinlock_core.c
@@ -339,6 +339,11 @@ int hwspin_lock_register(struct hwspinlo
 	bank->base_id = base_id;
 	bank->num_locks = num_locks;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_locks; i++) {
 		hwlock = &bank->lock[i];
 
@@ -348,6 +353,12 @@ int hwspin_lock_register(struct hwspinlo
 		ret = hwspin_lock_register_single(hwlock, base_id + i);
 		if (ret)
 			goto reg_failed;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
@@ -375,6 +386,11 @@ int hwspin_lock_unregister(struct hwspin
 	struct hwspinlock *hwlock, *tmp;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bank->num_locks; i++) {
 		hwlock = &bank->lock[i];
 
@@ -384,6 +400,12 @@ int hwspin_lock_unregister(struct hwspin
 
 		/* self-sanity check that should never fail */
 		WARN_ON(tmp != hwlock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/virt/fsl_hypervisor.c b/virt/fsl_hypervisor.c
--- a/virt/fsl_hypervisor.c
+++ b/virt/fsl_hypervisor.c
@@ -272,6 +272,11 @@ static long ioctl_memcpy(struct fsl_hv_i
 	remote_paddr = param.remote_paddr + sg_list[0].size;
 	count = param.count - sg_list[0].size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < num_pages; i++) {
 		if (param.source == -1) {
 			/* local to remote */
@@ -286,6 +291,12 @@ static long ioctl_memcpy(struct fsl_hv_i
 
 		remote_paddr += sg_list[i].size;
 		count -= sg_list[i].size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	param.ret = fh_partition_memcpy(param.source, param.target,
diff -u -p a/of/base.c b/of/base.c
--- a/of/base.c
+++ b/of/base.c
@@ -497,11 +497,22 @@ struct device_node *of_find_node_with_pr
 	read_lock(&devtree_lock);
 	np = from ? from->allnext : allnodes;
 	for (; np; np = np->allnext) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (pp = np->properties; pp != 0; pp = pp->next) {
 			if (of_prop_cmp(pp->name, prop_name) == 0) {
 				of_node_get(np);
 				goto out;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 out:
@@ -750,12 +761,23 @@ int of_property_read_string_index(struct
 
 	p = prop->value;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; total < prop->length; total += l, p += l) {
 		l = strlen(p) + 1;
 		if ((*p != 0) && (i++ == index)) {
 			*output = p;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -ENODATA;
 }
@@ -790,10 +812,21 @@ int of_property_count_strings(struct dev
 
 	p = prop->value;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; total < prop->length; total += l, p += l) {
 		l = strlen(p) + 1;
 		if (*p != 0)
 			i++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return i;
 }
diff -u -p a/of/device.c b/of/device.c
--- a/of/device.c
+++ b/of/device.c
@@ -114,12 +114,23 @@ ssize_t of_device_get_modalias(struct de
 
 	/* Copy and do char replacement */
 	memcpy(&str[csize + 1], compat, cplen);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = csize; i < repend; i++) {
 		char c = str[i];
 		if (c == '\0')
 			str[i] = 'C';
 		else if (c == ' ')
 			str[i] = '_';
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return tsize;
diff -u -p a/of/platform.c b/of/platform.c
--- a/of/platform.c
+++ b/of/platform.c
@@ -154,9 +154,20 @@ struct platform_device *of_device_alloc(
 
 		dev->num_resources = num_reg + num_irq;
 		dev->resource = res;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < num_reg; i++, res++) {
 			rc = of_address_to_resource(np, i, res);
 			WARN_ON(rc);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		WARN_ON(of_irq_to_resource_table(np, res, num_irq) != num_irq);
 	}
diff -u -p a/of/address.c b/of/address.c
--- a/of/address.c
+++ b/of/address.c
@@ -196,6 +196,11 @@ const __be32 *of_get_pci_address(struct
 	psize /= 4;
 
 	onesize = na + ns;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; psize >= onesize; psize -= onesize, prop += onesize, i++) {
 		u32 val = be32_to_cpu(prop[0]);
 		if ((val & 0xff) == ((bar_no * 4) + PCI_BASE_ADDRESS_0)) {
@@ -205,6 +210,12 @@ const __be32 *of_get_pci_address(struct
 				*flags = bus->get_flags(prop);
 			return prop;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/of/irq.c b/of/irq.c
--- a/of/irq.c
+++ b/of/irq.c
@@ -191,9 +191,20 @@ int of_irq_map_raw(struct device_node *p
 		while (imaplen > (addrsize + intsize + 1) && !match) {
 			/* Compare specifiers */
 			match = 1;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < addrsize && match; ++i) {
 				u32 mask = imask ? imask[i] : 0xffffffffu;
 				match = ((addr[i] ^ imap[i]) & mask) == 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			for (; i < (addrsize + intsize) && match; ++i) {
 				u32 mask = imask ? imask[i] : 0xffffffffu;
diff -u -p a/pps/generators/pps_gen_parport.c b/pps/generators/pps_gen_parport.c
--- a/pps/generators/pps_gen_parport.c
+++ b/pps/generators/pps_gen_parport.c
@@ -160,6 +160,11 @@ static void calibrate_port(struct pps_ge
 	int i;
 	long acc = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (1 << PORT_NTESTS_SHIFT); i++) {
 		struct timespec a, b;
 		unsigned long irq_flags;
@@ -172,6 +177,12 @@ static void calibrate_port(struct pps_ge
 
 		b = timespec_sub(b, a);
 		acc += timespec_to_ns(&b);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev->port_write_time = acc >> PORT_NTESTS_SHIFT;
diff -u -p a/ssb/scan.c b/ssb/scan.c
--- a/ssb/scan.c
+++ b/ssb/scan.c
@@ -339,6 +339,11 @@ int ssb_bus_scan(struct ssb_bus *bus,
 	}
 
 	/* Fetch basic information about each core/device */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, dev_i = 0; i < bus->nr_devices; i++) {
 		err = scan_switchcore(bus, i);
 		if (err)
@@ -437,6 +442,12 @@ int ssb_bus_scan(struct ssb_bus *bus,
 		}
 
 		dev_i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	bus->nr_devices = dev_i;
 
diff -u -p a/ssb/driver_mipscore.c b/ssb/driver_mipscore.c
--- a/ssb/driver_mipscore.c
+++ b/ssb/driver_mipscore.c
@@ -61,11 +61,22 @@ static struct ssb_device *find_device(st
 {
 	struct ssb_bus *bus = rdev->bus;
 	int i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bus->nr_devices; i++) {
 		struct ssb_device *dev;
 		dev = &(bus->devices[i]);
 		if (ssb_irqflag(dev) == irqflag)
 			return dev;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NULL;
 }
@@ -158,8 +169,19 @@ static void print_irq(struct ssb_device
 	static const char *irq_name[] = {"2(S)", "3", "4", "5", "6", "D", "I"};
 	ssb_dprintk(KERN_INFO PFX
 		"core 0x%04x, irq :", dev->id.coreid);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= 6; i++) {
 		ssb_dprintk(" %s%s", irq_name[i], i==irq?"*":" ");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ssb_dprintk("\n");
 }
@@ -167,10 +189,21 @@ static void print_irq(struct ssb_device
 static void dump_irq(struct ssb_bus *bus)
 {
 	int i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bus->nr_devices; i++) {
 		struct ssb_device *dev;
 		dev = &(bus->devices[i]);
 		print_irq(dev, ssb_mips_irq(dev));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -252,6 +285,11 @@ void ssb_mipscore_init(struct ssb_mipsco
 		ssb_chipco_timing_init(&bus->chipco, ns);
 
 	/* Assign IRQs to all cores on the bus, start with irq line 2, because serial usually takes 1 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (irq = 2, i = 0; i < bus->nr_devices; i++) {
 		int mips_irq;
 		dev = &(bus->devices[i]);
@@ -285,6 +323,12 @@ void ssb_mipscore_init(struct ssb_mipsco
 			set_irq(dev, 0);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ssb_dprintk(KERN_INFO PFX "after irq reconfiguration\n");
 	dump_irq(bus);
diff -u -p a/ssb/driver_extif.c b/ssb/driver_extif.c
--- a/ssb/driver_extif.c
+++ b/ssb/driver_extif.c
@@ -60,6 +60,11 @@ int ssb_extif_serial_init(struct ssb_ext
 	extif_write32(extif, SSB_EXTIF_GPIO_INTPOL, 0);
 	extif_write32(extif, SSB_EXTIF_GPIO_INTMASK, 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		void __iomem *uart_regs;
 
@@ -78,6 +83,12 @@ int ssb_extif_serial_init(struct ssb_ext
 			}
 			iounmap(uart_regs);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return nr_ports;
 }
diff -u -p a/ssb/driver_chipcommon.c b/ssb/driver_chipcommon.c
--- a/ssb/driver_chipcommon.c
+++ b/ssb/driver_chipcommon.c
@@ -523,6 +523,11 @@ int ssb_chipco_serial_init(struct ssb_ch
 
 	/* Determine the registers of the UARTs */
 	n = (cc->capabilities & SSB_CHIPCO_CAP_NRUART);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n; i++) {
 		void __iomem *cc_mmio;
 		void __iomem *uart_regs;
@@ -540,6 +545,12 @@ int ssb_chipco_serial_init(struct ssb_ch
 		ports[i].irq = irq;
 		ports[i].baud_base = baud_base;
 		ports[i].reg_shift = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return nr_ports;
diff -u -p a/ssb/embedded.c b/ssb/embedded.c
--- a/ssb/embedded.c
+++ b/ssb/embedded.c
@@ -144,6 +144,11 @@ static int gige_pci_init_callback(struct
 	unsigned int i;
 	int res;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bus->nr_devices; i++) {
 		dev = &(bus->devices[i]);
 		if (dev->id.coreid != SSB_DEV_ETHERNET_GBIT)
@@ -155,6 +160,12 @@ static int gige_pci_init_callback(struct
 		res = ssb_gige_pcibios_plat_dev_init(dev, pdev);
 		if (res >= 0)
 			return res;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return -ENODEV;
@@ -186,6 +197,11 @@ static int gige_map_irq_callback(struct
 	unsigned int i;
 	int res;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bus->nr_devices; i++) {
 		dev = &(bus->devices[i]);
 		if (dev->id.coreid != SSB_DEV_ETHERNET_GBIT)
@@ -197,6 +213,12 @@ static int gige_map_irq_callback(struct
 		res = ssb_gige_map_irq(dev, pdev);
 		if (res >= 0)
 			return res;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return -ENODEV;
diff -u -p a/ssb/main.c b/ssb/main.c
--- a/ssb/main.c
+++ b/ssb/main.c
@@ -242,6 +242,11 @@ int ssb_devices_freeze(struct ssb_bus *b
 	ctx->bus = bus;
 	SSB_WARN_ON(bus->nr_devices > ARRAY_SIZE(ctx->device_frozen));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bus->nr_devices; i++) {
 		sdev = ssb_device_get(&bus->devices[i]);
 
@@ -257,6 +262,12 @@ int ssb_devices_freeze(struct ssb_bus *b
 		}
 		sdrv->remove(sdev);
 		ctx->device_frozen[i] = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -276,6 +287,11 @@ int ssb_devices_thaw(struct ssb_freeze_c
 	unsigned int i;
 	int err, result = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bus->nr_devices; i++) {
 		if (!ctx->device_frozen[i])
 			continue;
@@ -295,6 +311,12 @@ int ssb_devices_thaw(struct ssb_freeze_c
 		}
 		ssb_driver_put(sdrv);
 		ssb_device_put(sdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return result;
@@ -361,11 +383,22 @@ static int ssb_bus_match(struct device *
 	struct ssb_driver *ssb_drv = drv_to_ssb_drv(drv);
 	const struct ssb_device_id *id;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (id = ssb_drv->id_table;
 	     id->vendor || id->coreid || id->revision;
 	     id++) {
 		if (ssb_match_devid(id, &ssb_dev->id))
 			return 1; /* found */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -444,10 +477,21 @@ static void ssb_devices_unregister(struc
 	struct ssb_device *sdev;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = bus->nr_devices - 1; i >= 0; i--) {
 		sdev = &(bus->devices[i]);
 		if (sdev->dev)
 			device_unregister(sdev->dev);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -480,6 +524,11 @@ static int ssb_devices_register(struct s
 	int i, err = 0;
 	int dev_idx = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bus->nr_devices; i++) {
 		sdev = &(bus->devices[i]);
 
@@ -548,6 +597,12 @@ static int ssb_devices_register(struct s
 			goto error;
 		}
 		dev_idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -960,6 +1015,11 @@ void ssb_set_devtypedata(struct ssb_devi
 	struct ssb_device *ent;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bus->nr_devices; i++) {
 		ent = &(bus->devices[i]);
 		if (ent->id.vendor != dev->id.vendor)
@@ -968,6 +1028,12 @@ void ssb_set_devtypedata(struct ssb_devi
 			continue;
 
 		ent->devtypedata = data;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL(ssb_set_devtypedata);
@@ -1201,6 +1267,11 @@ static int ssb_wait_bits(struct ssb_devi
 	int i;
 	u32 val;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < timeout; i++) {
 		val = ssb_read32(dev, reg);
 		if (set) {
@@ -1211,6 +1282,12 @@ static int ssb_wait_bits(struct ssb_devi
 				return 0;
 		}
 		udelay(10);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	printk(KERN_ERR PFX "Timeout waiting for bitmask %08X on "
 			    "register %04X to %s.\n",
diff -u -p a/ssb/pcmcia.c b/ssb/pcmcia.c
--- a/ssb/pcmcia.c
+++ b/ssb/pcmcia.c
@@ -455,6 +455,11 @@ static int ssb_pcmcia_sprom_command(stru
 	err = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROMCTL, command);
 	if (err)
 		return err;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 1000; i++) {
 		err = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_SPROMCTL, &value);
 		if (err)
@@ -462,6 +467,12 @@ static int ssb_pcmcia_sprom_command(stru
 		if (value & SSB_PCMCIA_SPROMCTL_DONE)
 			return 0;
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -ETIMEDOUT;
@@ -533,10 +544,21 @@ static int ssb_pcmcia_sprom_read_all(str
 {
 	int err, i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < SSB_PCMCIA_SPROM_SIZE; i++) {
 		err = ssb_pcmcia_sprom_read(bus, i, &sprom[i]);
 		if (err)
 			return err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/ssb/driver_chipcommon_pmu.c b/ssb/driver_chipcommon_pmu.c
--- a/ssb/driver_chipcommon_pmu.c
+++ b/ssb/driver_chipcommon_pmu.c
@@ -74,10 +74,21 @@ static const struct pmu0_plltab_entry *
 	const struct pmu0_plltab_entry *e;
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(pmu0_plltab); i++) {
 		e = &pmu0_plltab[i];
 		if (e->freq == crystalfreq)
 			return e;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NULL;
@@ -209,10 +220,21 @@ static const struct pmu1_plltab_entry *
 	const struct pmu1_plltab_entry *e;
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(pmu1_plltab); i++) {
 		e = &pmu1_plltab[i];
 		if (e->freq == crystalfreq)
 			return e;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NULL;
@@ -468,15 +490,31 @@ static void ssb_pmu_resources_init(struc
 	}
 
 	if (updown_tab) {
-		for (i = 0; i < updown_tab_size; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < updown_tab_size; i++) {
 			chipco_write32(cc, SSB_CHIPCO_PMU_RES_TABSEL,
 				       updown_tab[i].resource);
 			chipco_write32(cc, SSB_CHIPCO_PMU_RES_UPDNTM,
 				       updown_tab[i].updown);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 	if (depend_tab) {
-		for (i = 0; i < depend_tab_size; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < depend_tab_size; i++) {
 			chipco_write32(cc, SSB_CHIPCO_PMU_RES_TABSEL,
 				       depend_tab[i].resource);
 			switch (depend_tab[i].task) {
@@ -495,6 +533,12 @@ static void ssb_pmu_resources_init(struc
 			default:
 				SSB_WARN_ON(1);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/ssb/pci.c b/ssb/pci.c
--- a/ssb/pci.c
+++ b/ssb/pci.c
@@ -224,9 +224,20 @@ static u8 ssb_sprom_crc(const u16 *sprom
 	int word;
 	u8 crc = 0xFF;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (word = 0; word < size - 1; word++) {
 		crc = ssb_crc8(crc, sprom[word] & 0x00FF);
 		crc = ssb_crc8(crc, (sprom[word] & 0xFF00) >> 8);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	crc = ssb_crc8(crc, sprom[size - 1] & 0x00FF);
 	crc ^= 0xFF;
@@ -276,6 +287,11 @@ static int sprom_do_write(struct ssb_bus
 		goto err_ctlreg;
 	ssb_printk(KERN_NOTICE PFX "[ 0%%");
 	msleep(500);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < size; i++) {
 		if (i == size / 4)
 			ssb_printk("25%%");
@@ -288,6 +304,12 @@ static int sprom_do_write(struct ssb_bus
 		writew(sprom[i], bus->mmio + bus->sprom_offset + (i * 2));
 		mmiowb();
 		msleep(20);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	err = pci_read_config_dword(pdev, SSB_SPROMCTL, &spromctl);
 	if (err)
@@ -341,18 +363,51 @@ static void sprom_extract_r123(struct ss
 		loc[1] = SSB_SPROM1_ET0MAC;
 		loc[2] = SSB_SPROM1_ET1MAC;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		v = in[SPOFF(loc[0]) + i];
 		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (out->revision < 3) { 	/* only rev 1-2 have et0, et1 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 3; i++) {
 			v = in[SPOFF(loc[1]) + i];
 			*(((__be16 *)out->et0mac) + i) = cpu_to_be16(v);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 3; i++) {
 			v = in[SPOFF(loc[2]) + i];
 			*(((__be16 *)out->et1mac) + i) = cpu_to_be16(v);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	SPEX(et0phyaddr, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0A, 0);
@@ -457,9 +512,20 @@ static void sprom_extract_r45(struct ssb
 	else
 		il0mac_offset = SSB_SPROM5_IL0MAC;
 	/* extract the MAC address */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		v = in[SPOFF(il0mac_offset) + i];
 		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	SPEX(et0phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET0A, 0);
 	SPEX(et1phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET1A,
@@ -526,9 +592,20 @@ static void sprom_extract_r8(struct ssb_
 	u16 v;
 
 	/* extract the MAC address */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 3; i++) {
 		v = in[SPOFF(SSB_SPROM8_IL0MAC) + i];
 		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	SPEX(country_code, SSB_SPROM8_CCODE, 0xFFFF, 0);
 	SPEX(boardflags_lo, SSB_SPROM8_BFLLO, 0xFFFF, 0);
diff -u -p a/hid/hid-roccat-pyra.c b/hid/hid-roccat-pyra.c
--- a/hid/hid-roccat-pyra.c
+++ b/hid/hid-roccat-pyra.c
@@ -469,7 +469,12 @@ static int pyra_init_pyra_device_struct(
 	if (retval)
 		return retval;
 
-	for (i = 0; i < 5; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < 5; ++i) {
 		retval = pyra_get_profile_settings(usb_dev,
 				&pyra->profile_settings[i], i);
 		if (retval)
@@ -479,6 +484,12 @@ static int pyra_init_pyra_device_struct(
 				&pyra->profile_buttons[i], i);
 		if (retval)
 			return retval;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	profile_activated(pyra, pyra->settings.startup_profile);
diff -u -p a/hid/hid-lg4ff.c b/hid/hid-lg4ff.c
--- a/hid/hid-lg4ff.c
+++ b/hid/hid-lg4ff.c
@@ -377,11 +377,22 @@ int lg4ff_init(struct hid_device *hid)
 		dbg_hid("Generic wheel detected, can it do native?\n");
 		dbg_hid("USB revision: %2x.%02x\n", rev_maj, rev_min);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < ARRAY_SIZE(lg4ff_revs); j++) {
 			if (lg4ff_revs[j].rev_maj == rev_maj && lg4ff_revs[j].rev_min == rev_min) {
 				hid_lg4ff_switch_native(hid, lg4ff_revs[j].command);
 				hid_info(hid, "Switched to native mode\n");
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/hid/hid-logitech-dj.c b/hid/hid-logitech-dj.c
--- a/hid/hid-logitech-dj.c
+++ b/hid/hid-logitech-dj.c
@@ -399,6 +399,11 @@ static void logi_dj_recv_forward_null_re
 
 	memset(reportbuffer, 0, sizeof(reportbuffer));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUMBER_OF_HID_REPORTS; i++) {
 		if (djdev->reports_supported & (1 << i)) {
 			reportbuffer[0] = i;
@@ -410,6 +415,12 @@ static void logi_dj_recv_forward_null_re
 					"report\n");
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -882,6 +893,11 @@ static void logi_dj_remove(struct hid_de
 	 * have finished and no more raw_event callbacks should arrive after
 	 * the remove callback was triggered so no locks are put around the
 	 * code below */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (DJ_MAX_PAIRED_DEVICES + DJ_DEVICE_INDEX_MIN); i++) {
 		dj_dev = djrcv_dev->paired_dj_devices[i];
 		if (dj_dev != NULL) {
@@ -889,6 +905,12 @@ static void logi_dj_remove(struct hid_de
 			kfree(dj_dev);
 			djrcv_dev->paired_dj_devices[i] = NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfifo_free(&djrcv_dev->notif_fifo);
diff -u -p a/hid/hidraw.c b/hid/hidraw.c
--- a/hid/hidraw.c
+++ b/hid/hidraw.c
@@ -484,12 +484,23 @@ int hidraw_connect(struct hid_device *hi
 
 	mutex_lock(&minors_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (minor = 0; minor < HIDRAW_MAX_DEVICES; minor++) {
 		if (hidraw_table[minor])
 			continue;
 		hidraw_table[minor] = dev;
 		result = 0;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (result) {
diff -u -p a/hid/hid-tmff.c b/hid/hid-tmff.c
--- a/hid/hid-tmff.c
+++ b/hid/hid-tmff.c
@@ -143,6 +143,11 @@ static int tmff_init(struct hid_device *
 	list_for_each_entry(report, report_list, list) {
 		int fieldnum;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (fieldnum = 0; fieldnum < report->maxfield; ++fieldnum) {
 			struct hid_field *field = report->field[fieldnum];
 
@@ -185,6 +190,12 @@ static int tmff_init(struct hid_device *
 					 field->usage[0].hid);
 				continue;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/hid/hid-picolcd.c b/hid/hid-picolcd.c
--- a/hid/hid-picolcd.c
+++ b/hid/hid-picolcd.c
@@ -294,10 +294,22 @@ static struct picolcd_pending *picolcd_s
 
 	mutex_lock(&data->mutex);
 	spin_lock_irqsave(&data->lock, flags);
-	for (i = k = 0; i < report->maxfield; i++)
-		for (j = 0; j < report->field[i]->report_count; j++) {
-			hid_set_field(report->field[i], j, k < size ? raw_data[k] : 0);
-			k++;
+	for (i = k = 0; i < report->maxfield; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; j < report->field[i]->report_count; j++) {
+				hid_set_field(report->field[i], j, k < size ? raw_data[k] : 0);
+				k++;
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
+			}
 		}
 	data->pending = work;
 	usbhid_submit_report(data->hdev, report, USB_DIR_OUT);
@@ -364,19 +376,63 @@ static int picolcd_fb_update_tile(u8 *vb
 	u8 *vdata = vbitmap + (tile * 4 + chip) * 64;
 
 	if (bpp == 1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (b = 7; b >= 0; b--) {
 			const u8 *bdata = bitmap + tile * 256 + chip * 8 + b * 32;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 64; i++) {
 				tdata[i] <<= 1;
 				tdata[i] |= (bdata[i/8] >> (i % 8)) & 0x01;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 	} else if (bpp == 8) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (b = 7; b >= 0; b--) {
 			const u8 *bdata = bitmap + (tile * 256 + chip * 8 + b * 32) * 8;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 64; i++) {
 				tdata[i] <<= 1;
 				tdata[i] |= (bdata[i] & 0x80) ? 0x01 : 0x00;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 	} else {
@@ -405,6 +461,11 @@ static int picolcd_fb_reset(struct picol
 		return -ENODEV;
 
 	spin_lock_irqsave(&data->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		for (j = 0; j < report->field[0]->maxusage; j++)
 			if (j == 0)
@@ -414,6 +475,12 @@ static int picolcd_fb_reset(struct picol
 			else
 				hid_set_field(report->field[0], j, 0);
 		usbhid_submit_report(data->hdev, report, USB_DIR_OUT);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	data->status |= PICOLCD_READY_FB;
@@ -598,13 +665,35 @@ static int picolcd_set_par(struct fb_inf
 	/* translate FB content to new bits-per-pixel */
 	if (info->var.bits_per_pixel == 1) {
 		int i, b;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < PICOLCDFB_SIZE; i++) {
 			u8 p = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (b = 0; b < 8; b++) {
 				p <<= 1;
 				p |= o_fb[i*8+b] ? 0x01 : 0x00;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			tmp_fb[i] = p;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		memcpy(o_fb, tmp_fb, PICOLCDFB_SIZE);
 		info->fix.visual = FB_VISUAL_MONO01;
@@ -1131,6 +1220,11 @@ static void picolcd_led_set_brightness(s
 	dev  = led_cdev->dev->parent;
 	hdev = container_of(dev, struct hid_device, dev);
 	data = hid_get_drvdata(hdev);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		if (led_cdev != data->led[i])
 			continue;
@@ -1143,6 +1237,12 @@ static void picolcd_led_set_brightness(s
 			picolcd_leds_set(data);
 		}
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1180,6 +1280,11 @@ static int picolcd_init_leds(struct pico
 		return -EINVAL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		led = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);
 		if (!led) {
@@ -1203,6 +1308,12 @@ static int picolcd_init_leds(struct pico
 			dev_err(dev, "can't register LED %d\n", i);
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 err:
@@ -1221,6 +1332,11 @@ static void picolcd_exit_leds(struct pic
 	struct led_classdev *led;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		led = data->led[i];
 		data->led[i] = NULL;
@@ -1228,6 +1344,12 @@ static void picolcd_exit_leds(struct pic
 			continue;
 		led_classdev_unregister(led);
 		kfree(led);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1260,6 +1382,11 @@ static int picolcd_raw_keypad(struct pic
 	int i, j;
 
 	/* determine newly pressed keys */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < size; i++) {
 		unsigned int key_code;
 		if (raw_data[i] == 0)
@@ -1285,9 +1412,20 @@ static int picolcd_raw_keypad(struct pic
 		input_sync(data->input_keys);
 key_already_down:
 		continue;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* determine newly released keys */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < sizeof(data->pressed_keys); j++) {
 		unsigned int key_code;
 		if (data->pressed_keys[j] == 0)
@@ -1309,6 +1447,12 @@ key_already_down:
 		data->pressed_keys[j] = 0;
 key_still_down:
 		continue;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return 1;
 }
@@ -1837,10 +1981,21 @@ static void dump_buff_as_hex(char *dst,
 		const size_t data_len)
 {
 	int i, j;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = j = 0; i < data_len && j + 3 < dst_sz; i++) {
 		dst[j++] = hex_asc[(data[i] >> 4) & 0x0f];
 		dst[j++] = hex_asc[data[i] & 0x0f];
 		dst[j++] = ' ';
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (j < dst_sz) {
 		dst[j--] = '\0';
diff -u -p a/hid/hid-debug.c b/hid/hid-debug.c
--- a/hid/hid-debug.c
+++ b/hid/hid-debug.c
@@ -457,8 +457,19 @@ void hid_dump_field(struct hid_field *fi
 		hid_resolv_usage(field->application, f); seq_printf(f, ")\n");
 	}
 	tab(n, f); seq_printf(f, "Usage(%d)\n", field->maxusage);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < field->maxusage; j++) {
 		tab(n+2, f); hid_resolv_usage(field->usage[j].hid, f); seq_printf(f, "\n");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (field->logical_minimum != field->logical_maximum) {
 		tab(n, f); seq_printf(f, "Logical Minimum(%d)\n", field->logical_minimum);
@@ -497,6 +508,11 @@ void hid_dump_field(struct hid_field *fi
 
 			tab(n, f); seq_printf(f, "Unit(%s : ", systems[sys]);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i=1 ; i<sizeof(__u32)*2 ; i++) {
 				char nibble = data & 0xf;
 				data >>= 4;
@@ -513,6 +529,12 @@ void hid_dump_field(struct hid_field *fi
 						seq_printf(f, "^%d", val);
 					}
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			seq_printf(f, ")\n");
 		}
@@ -544,6 +566,11 @@ void hid_dump_device(struct hid_device *
 	unsigned i,k;
 	static const char *table[] = {"INPUT", "OUTPUT", "FEATURE"};
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < HID_REPORT_TYPES; i++) {
 		report_enum = device->report_enum + i;
 		list = report_enum->report_list.next;
@@ -555,13 +582,30 @@ void hid_dump_device(struct hid_device *
 				seq_printf(f, "(%d)", report->id);
 			seq_printf(f, "[%s]", table[report->type]);
 			seq_printf(f, "\n");
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (k = 0; k < report->maxfield; k++) {
 				tab(4, f);
 				seq_printf(f, "Field(%d)\n", k);
 				hid_dump_field(report->field[k], 6, f);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			list = list->next;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(hid_dump_device);
@@ -887,18 +931,51 @@ static void hid_dump_input_mapping(struc
 	struct hid_report *report;
 	struct hid_usage *usage;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
 		list_for_each_entry(report, &hid->report_enum[k].report_list, list) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < report->maxfield; i++) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for ( j = 0; j < report->field[i]->maxusage; j++) {
 					usage = report->field[i]->usage + j;
 					hid_resolv_usage(usage->hid, f);
 					seq_printf(f, " ---> ");
 					hid_resolv_event(usage->type, usage->code, f);
 					seq_printf(f, "\n");
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
diff -u -p a/hid/hid-holtekff.c b/hid/hid-holtekff.c
--- a/hid/hid-holtekff.c
+++ b/hid/hid-holtekff.c
@@ -96,8 +96,19 @@ static void holtekff_send(struct holtekf
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < HOLTEKFF_MSG_LENGTH; i++) {
 		holtekff->field->value[i] = data[i];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dbg_hid("sending %02x %02x %02x %02x %02x %02x %02x\n", data[0],
diff -u -p a/hid/hid-roccat-kovaplus.c b/hid/hid-roccat-kovaplus.c
--- a/hid/hid-roccat-kovaplus.c
+++ b/hid/hid-roccat-kovaplus.c
@@ -491,7 +491,12 @@ static int kovaplus_init_kovaplus_device
 	if (retval)
 		return retval;
 
-	for (i = 0; i < 5; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 5; ++i) {
 		msleep(wait);
 		retval = kovaplus_get_profile_settings(usb_dev,
 				&kovaplus->profile_settings[i], i);
@@ -503,6 +508,12 @@ static int kovaplus_init_kovaplus_device
 				&kovaplus->profile_buttons[i], i);
 		if (retval)
 			return retval;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	msleep(wait);
diff -u -p a/hid/hid-prodikeys.c b/hid/hid-prodikeys.c
--- a/hid/hid-prodikeys.c
+++ b/hid/hid-prodikeys.c
@@ -253,12 +253,23 @@ static void init_sustain_timers(struct p
 	struct pcmidi_sustain *pms;
 	unsigned i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < PCMIDI_SUSTAINED_MAX; i++) {
 		pms = &pm->sustained_notes[i];
 		pms->in_use = 0;
 		pms->pm = pm;
 		setup_timer(&pms->timer, pcmidi_sustained_note_release,
 			(unsigned long)pms);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -267,10 +278,21 @@ static void stop_sustain_timers(struct p
 	struct pcmidi_sustain *pms;
 	unsigned i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < PCMIDI_SUSTAINED_MAX; i++) {
 		pms = &pm->sustained_notes[i];
 		pms->in_use = 1;
 		del_timer_sync(&pms->timer);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -346,6 +368,11 @@ static int pcmidi_handle_report3(struct
 	unsigned char status, note, velocity;
 
 	unsigned num_notes = (size-1)/2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < num_notes; j++)	{
 		note = data[j*2+1];
 		velocity = data[j*2+2];
@@ -362,6 +389,11 @@ static int pcmidi_handle_report3(struct
 				(pm->midi_octave*12);
 
 			if (pm->midi_sustain_mode) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (i = 0; i < PCMIDI_SUSTAINED_MAX; i++) {
 					pms = &pm->sustained_notes[i];
 					if (!pms->in_use) {
@@ -375,10 +407,22 @@ static int pcmidi_handle_report3(struct
 					msecs_to_jiffies(pm->midi_sustain));
 						return 1;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 		}
 		pcmidi_send_note(pm, status, note, velocity);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 1;
@@ -395,6 +439,11 @@ static int pcmidi_handle_report4(struct
 	bit_mask = (bit_mask << 8) | data[3];
 
 	/* break keys */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit_index = 0; bit_index < 24; bit_index++) {
 		key = pm->last_key[bit_index];
 		if (!((0x01 << bit_index) & bit_mask)) {
@@ -402,9 +451,20 @@ static int pcmidi_handle_report4(struct
 				pm->last_key[bit_index], 0);
 				pm->last_key[bit_index] = 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/* make keys */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit_index = 0; bit_index < 24; bit_index++) {
 		key = 0;
 		switch ((0x01 << bit_index) & bit_mask) {
@@ -492,6 +552,12 @@ static int pcmidi_handle_report4(struct
 			input_event(pm->input_ep82, EV_KEY, key, 1);
 			pm->last_key[bit_index] = key;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 1;
diff -u -p a/hid/usbhid/usbkbd.c b/hid/usbhid/usbkbd.c
--- a/hid/usbhid/usbkbd.c
+++ b/hid/usbhid/usbkbd.c
@@ -100,6 +100,11 @@ static void usb_kbd_irq(struct urb *urb)
 	for (i = 0; i < 8; i++)
 		input_report_key(kbd->dev, usb_kbd_keycode[i + 224], (kbd->new[0] >> i) & 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 2; i < 8; i++) {
 
 		if (kbd->old[i] > 3 && memscan(kbd->new + 2, kbd->old[i], 6) == kbd->new + 8) {
@@ -119,6 +124,12 @@ static void usb_kbd_irq(struct urb *urb)
 					 "Unknown key (scancode %#x) released.\n",
 					 kbd->new[i]);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	input_sync(kbd->dev);
diff -u -p a/hid/usbhid/hiddev.c b/hid/usbhid/hiddev.c
--- a/hid/usbhid/hiddev.c
+++ b/hid/usbhid/hiddev.c
@@ -141,8 +141,18 @@ hiddev_lookup_usage(struct hid_device *h
 		(uref->report_type - HID_REPORT_TYPE_MIN);
 
 	list_for_each_entry(report, &report_enum->report_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < report->maxfield; i++) {
 			field = report->field[i];
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < field->maxusage; j++) {
 				if (field->usage[j].hid == uref->usage_code) {
 					uref->report_id = report->id;
@@ -150,6 +160,18 @@ hiddev_lookup_usage(struct hid_device *h
 					uref->usage_index = j;
 					return field;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 	}
diff -u -p a/hid/usbhid/hid-pidff.c b/hid/usbhid/hid-pidff.c
--- a/hid/usbhid/hid-pidff.c
+++ b/hid/usbhid/hid-pidff.c
@@ -385,7 +385,12 @@ static void pidff_set_condition_report(s
 	pidff->set_condition[PID_EFFECT_BLOCK_INDEX].value[0] =
 		pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];
 
-	for (i = 0; i < 2; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 2; i++) {
 		pidff->set_condition[PID_PARAM_BLOCK_OFFSET].value[0] = i;
 		pidff_set_signed(&pidff->set_condition[PID_CP_OFFSET],
 				 effect->u.condition[i].center);
@@ -401,6 +406,12 @@ static void pidff_set_condition_report(s
 			  effect->u.condition[i].deadband);
 		usbhid_submit_report(pidff->hid, pidff->reports[PID_SET_CONDITION],
 				  USB_DIR_OUT);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -413,6 +424,11 @@ static int pidff_needs_set_condition(str
 	int i;
 	int ret = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		struct ff_condition_effect *cond = &effect->u.condition[i];
 		struct ff_condition_effect *old_cond = &old->u.condition[i];
@@ -423,6 +439,12 @@ static int pidff_needs_set_condition(str
 		       cond->right_saturation != old_cond->right_saturation ||
 		       cond->left_saturation != old_cond->left_saturation ||
 		       cond->deadband != old_cond->deadband;
+		       if (_cur < timeout) {
+		       	rdstcll(_cur);
+		       }
+		       else {
+		       	break;
+		       }
 	}
 
 	return ret;
@@ -473,7 +495,12 @@ static int pidff_request_effect_upload(s
 	pidff->block_load_status->value[0] = 0;
 	usbhid_wait_io(pidff->hid);
 
-	for (j = 0; j < 60; j++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (j = 0; j < 60; j++) {
 		hid_dbg(pidff->hid, "pid_block_load requested\n");
 		usbhid_submit_report(pidff->hid, pidff->reports[PID_BLOCK_LOAD],
 				  USB_DIR_IN);
@@ -492,6 +519,12 @@ static int pidff_request_effect_upload(s
 				pidff->block_load[PID_RAM_POOL_AVAILABLE].value[0] : -1);
 			return -ENOSPC;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	hid_err(pidff->hid, "pid_block_load failed 60 times\n");
 	return -EIO;
@@ -766,6 +799,11 @@ static int pidff_find_fields(struct pidf
 {
 	int i, j, k, found;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < count; k++) {
 		found = 0;
 		for (i = 0; i < report->maxfield; i++) {
@@ -793,6 +831,12 @@ static int pidff_find_fields(struct pidf
 			pr_debug("failed to locate %d\n", k);
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -861,11 +905,22 @@ static int pidff_reports_ok(struct pidff
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= PID_REQUIRED_REPORTS; i++) {
 		if (!pidff->reports[i]) {
 			hid_dbg(pidff->hid, "%d missing\n", i);
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 1;
@@ -879,6 +934,11 @@ static struct hid_field *pidff_find_spec
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < report->maxfield; i++) {
 		if (report->field[i]->logical == (HID_UP_PID | usage) &&
 		    report->field[i]->report_count > 0) {
@@ -890,6 +950,12 @@ static struct hid_field *pidff_find_spec
 				return NULL;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -904,6 +970,11 @@ static int pidff_find_special_keys(int *
 	int i, j;
 	int found = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i++) {
 		for (j = 0; j < fld->maxusage; j++) {
 			if (fld->usage[j].hid == (HID_UP_PID | usagetable[i])) {
@@ -912,6 +983,12 @@ static int pidff_find_special_keys(int *
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return found;
 }
@@ -1011,6 +1088,11 @@ static int pidff_find_effects(struct pid
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sizeof(pidff_effect_types); i++) {
 		int pidff_type = pidff->type_id[i];
 		if (pidff->set_effect_type->usage[pidff_type].hid !=
@@ -1019,6 +1101,12 @@ static int pidff_find_effects(struct pid
 				"effect type number %d is invalid\n", i);
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (pidff->type_id[PID_CONSTANT])
diff -u -p a/hid/usbhid/hid-core.c b/hid/usbhid/hid-core.c
--- a/hid/usbhid/hid-core.c
+++ b/hid/usbhid/hid-core.c
@@ -738,8 +738,18 @@ static int hid_find_field_early(struct h
 	int i, j;
 
 	list_for_each_entry(report, &hid->report_enum[HID_OUTPUT_REPORT].report_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < report->maxfield; i++) {
 			field = report->field[i];
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < field->maxusage; j++) {
 				usage = &field->usage[j];
 				if ((usage->hid & HID_USAGE_PAGE) == page &&
@@ -747,6 +757,18 @@ static int hid_find_field_early(struct h
 					*pfield = field;
 					return j;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 	}
@@ -1004,6 +1026,11 @@ static int usbhid_start(struct hid_devic
 		goto fail;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 0; n < interface->desc.bNumEndpoints; n++) {
 		struct usb_endpoint_descriptor *endpoint;
 		int pipe;
@@ -1049,6 +1076,12 @@ static int usbhid_start(struct hid_devic
 			usbhid->urbout->transfer_dma = usbhid->outbuf_dma;
 			usbhid->urbout->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	usbhid->urbctrl = usb_alloc_urb(0, GFP_KERNEL);
diff -u -p a/hid/hid-wiimote.c b/hid/hid-wiimote.c
--- a/hid/hid-wiimote.c
+++ b/hid/hid-wiimote.c
@@ -1013,12 +1013,23 @@ static int wiimote_hid_event(struct hid_
 
 	spin_lock_irqsave(&wdata->state.lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; handlers[i].id; ++i) {
 		h = &handlers[i];
 		if (h->id == raw_data[0] && h->size < size) {
 			h->func(wdata, &raw_data[1]);
 			handled = true;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!handled)
@@ -1035,6 +1046,11 @@ static void wiimote_leds_destroy(struct
 	int i;
 	struct led_classdev *led;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; ++i) {
 		if (wdata->leds[i]) {
 			led = wdata->leds[i];
@@ -1042,6 +1058,12 @@ static void wiimote_leds_destroy(struct
 			led_classdev_unregister(led);
 			kfree(led);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1053,6 +1075,11 @@ static int wiimote_leds_create(struct wi
 	struct led_classdev *led;
 	char *name;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; ++i) {
 		led = kzalloc(sizeof(struct led_classdev) + namesz, GFP_KERNEL);
 		if (!led) {
@@ -1073,6 +1100,12 @@ static int wiimote_leds_create(struct wi
 			goto err;
 		}
 		wdata->leds[i] = led;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/hid/hid-roccat-kone.c b/hid/hid-roccat-kone.c
--- a/hid/hid-roccat-kone.c
+++ b/hid/hid-roccat-kone.c
@@ -667,10 +667,21 @@ static int kone_init_kone_device_struct(
 
 	mutex_init(&kone->kone_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 5; ++i) {
 		retval = kone_get_profile(usb_dev, &kone->profiles[i], i + 1);
 		if (retval)
 			return retval;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	retval = kone_get_settings(usb_dev, &kone->settings);
diff -u -p a/hid/hid-axff.c b/hid/hid-axff.c
--- a/hid/hid-axff.c
+++ b/hid/hid-axff.c
@@ -59,11 +59,33 @@ static int axff_play(struct input_dev *d
 	left = left * 0xff / 0xffff;
 	right = right * 0xff / 0xffff;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < report->maxfield; i++) {
-		for (j = 0; j < report->field[i]->report_count; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (j = 0; j < report->field[i]->report_count; j++) {
 			report->field[i]->value[j] =
 				field_count % 2 ? right : left;
 			field_count++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -90,10 +112,32 @@ static int axff_init(struct hid_device *
 	}
 
 	report = list_first_entry(report_list, struct hid_report, list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < report->maxfield; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < report->field[i]->report_count; j++) {
 			report->field[i]->value[j] = 0x00;
 			field_count++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
diff -u -p a/hid/hid-multitouch.c b/hid/hid-multitouch.c
--- a/hid/hid-multitouch.c
+++ b/hid/hid-multitouch.c
@@ -118,15 +118,37 @@ static int cypress_compute_slot(struct m
 static int find_slot_from_contactid(struct mt_device *td)
 {
 	int i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < td->maxcontacts; ++i) {
 		if (td->slots[i].contactid == td->curdata.contactid &&
 			td->slots[i].touch_state)
 			return i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < td->maxcontacts; ++i) {
 		if (!td->slots[i].seen_in_this_frame &&
 			!td->slots[i].touch_state)
 			return i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	/* should not occurs. If this happens that means
 	 * that the device sent more touches that it says
@@ -409,6 +431,11 @@ static void mt_emit_event(struct mt_devi
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < td->maxcontacts; ++i) {
 		struct mt_slot *s = &(td->slots[i]);
 		if ((td->mtclass->quirks & MT_QUIRK_NOT_SEEN_MEANS_UP) &&
@@ -435,6 +462,12 @@ static void mt_emit_event(struct mt_devi
 		}
 		s->seen_in_this_frame = false;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_mt_report_pointer_emulation(input, true);
diff -u -p a/hid/hid-roccat.c b/hid/hid-roccat.c
--- a/hid/hid-roccat.c
+++ b/hid/hid-roccat.c
@@ -306,10 +306,21 @@ int roccat_connect(struct class *klass,
 
 	mutex_lock(&devices_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (minor = 0; minor < ROCCAT_MAX_DEVICES; ++minor) {
 		if (devices[minor])
 			continue;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (minor < ROCCAT_MAX_DEVICES) {
diff -u -p a/hid/hid-roccat-koneplus.c b/hid/hid-roccat-koneplus.c
--- a/hid/hid-roccat-koneplus.c
+++ b/hid/hid-roccat-koneplus.c
@@ -588,7 +588,12 @@ static int koneplus_init_koneplus_device
 	if (retval)
 		return retval;
 
-	for (i = 0; i < 5; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 5; ++i) {
 		msleep(wait);
 		retval = koneplus_get_profile_settings(usb_dev,
 				&koneplus->profile_settings[i], i);
@@ -600,6 +605,12 @@ static int koneplus_init_koneplus_device
 				&koneplus->profile_buttons[i], i);
 		if (retval)
 			return retval;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	msleep(wait);
diff -u -p a/hid/hid-magicmouse.c b/hid/hid-magicmouse.c
--- a/hid/hid-magicmouse.c
+++ b/hid/hid-magicmouse.c
@@ -140,6 +140,11 @@ static int magicmouse_firm_touch(struct
 	/* If there is only one "firm" touch, set touch to its
 	 * tracking ID.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ii = 0; ii < msc->ntouches; ii++) {
 		int idx = msc->tracking_ids[ii];
 		if (msc->touches[idx].size < 8) {
@@ -150,6 +155,12 @@ static int magicmouse_firm_touch(struct
 		} else {
 			touch = idx;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return touch;
diff -u -p a/hid/hid-zydacron.c b/hid/hid-zydacron.c
--- a/hid/hid-zydacron.c
+++ b/hid/hid-zydacron.c
@@ -120,12 +120,23 @@ static int zc_raw_event(struct hid_devic
 	if (report->id == data[0]) {
 
 		/* break keys */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (index = 0; index < 4; index++) {
 			key = zc->last_key[index];
 			if (key) {
 				input_event(zc->input_ep81, EV_KEY, key, 0);
 				zc->last_key[index] = 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+		}
 		}
 
 		key = 0;
diff -u -p a/hid/hid-input.c b/hid/hid-input.c
--- a/hid/hid-input.c
+++ b/hid/hid-input.c
@@ -101,9 +101,24 @@ static struct hid_usage *hidinput_find_k
 	struct hid_report *report;
 	struct hid_usage *usage;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
 		list_for_each_entry(report, &hid->report_enum[k].report_list, list) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < report->maxfield; i++) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (j = 0; j < report->field[i]->maxusage; j++) {
 					usage = report->field[i]->usage + j;
 					if (usage->type == EV_KEY || usage->type == 0) {
@@ -114,9 +129,27 @@ static struct hid_usage *hidinput_find_k
 						}
 						cur_idx++;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -726,9 +759,20 @@ mapped:
 	if (usage->type == EV_ABS &&
 	    (usage->hat_min < usage->hat_max || usage->hat_dir)) {
 		int i;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = usage->code; i < usage->code + 2 && i <= max; i++) {
 			input_set_abs_params(input, i, -1, 1, 0, 0);
 			set_bit(i, input->absbit);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 		}
 		if (usage->hat_dir && !field->dpad)
 			field->dpad = usage->code;
@@ -817,11 +861,22 @@ void hidinput_hid_event(struct hid_devic
 		int direction = value > 0 ? KEY_VOLUMEUP : KEY_VOLUMEDOWN;
 		int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; i++) {
 			input_event(input, EV_KEY, direction, 1);
 			input_sync(input);
 			input_event(input, EV_KEY, direction, 0);
 			input_sync(input);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		return;
 	}
@@ -854,11 +909,22 @@ int hidinput_find_field(struct hid_devic
 	int i, j;
 
 	list_for_each_entry(report, &hid->report_enum[HID_OUTPUT_REPORT].report_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < report->maxfield; i++) {
 			*field = report->field[i];
 			for (j = 0; j < (*field)->maxusage; j++)
 				if ((*field)->usage[j].type == type && (*field)->usage[j].code == code)
 					return j;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 		}
 	}
 	return -1;
@@ -890,15 +956,27 @@ static void report_features(struct hid_d
 		return;
 
 	rep_enum = &hid->report_enum[HID_FEATURE_REPORT];
-	list_for_each_entry(rep, &rep_enum->report_list, list)
-		for (i = 0; i < rep->maxfield; i++) {
+	list_for_each_entry(rep, &rep_enum->report_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < rep->maxfield; i++) {
 			/* Ignore if report count is out of bounds. */
-			if (rep->field[i]->report_count < 1)
-				continue;
+				if (rep->field[i]->report_count < 1)
+					continue;
 
-			for (j = 0; j < rep->field[i]->maxusage; j++)
-				drv->feature_mapping(hid, rep->field[i],
-						     rep->field[i]->usage + j);
+				for (j = 0; j < rep->field[i]->maxusage; j++)
+					drv->feature_mapping(hid, rep->field[i],
+					rep->field[i]->usage + j);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 		}
 }
 
@@ -932,7 +1010,12 @@ int hidinput_connect(struct hid_device *
 
 	report_features(hid);
 
-	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
 		if (k == HID_OUTPUT_REPORT &&
 			hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)
 			continue;
@@ -989,6 +1072,12 @@ int hidinput_connect(struct hid_device *
 				hidinput = NULL;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (hid->quirks & HID_QUIRK_MULTITOUCH) {
diff -u -p a/hid/hid-zpff.c b/hid/hid-zpff.c
--- a/hid/hid-zpff.c
+++ b/hid/hid-zpff.c
@@ -73,10 +73,21 @@ static int zpff_init(struct hid_device *
 	struct input_dev *dev = hidinput->input;
 	int i, error;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		report = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, i, 1);
 		if (!report)
 			return -ENODEV;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	zpff = kzalloc(sizeof(struct zpff_device), GFP_KERNEL);
diff -u -p a/hid/hid-core.c b/hid/hid-core.c
--- a/hid/hid-core.c
+++ b/hid/hid-core.c
@@ -184,10 +184,21 @@ static unsigned hid_lookup_collection(st
 	struct hid_collection *collection = parser->device->collection;
 	int n;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = parser->collection_stack_ptr - 1; n >= 0; n--) {
 		unsigned index = parser->collection_stack[n];
 		if (collection[index].type == type)
 			return collection[index].usage;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0; /* we know nothing about this usage type */
 }
@@ -250,6 +261,11 @@ static int hid_add_field(struct hid_pars
 	field->logical = hid_lookup_collection(parser, HID_COLLECTION_LOGICAL);
 	field->application = hid_lookup_collection(parser, HID_COLLECTION_APPLICATION);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < usages; i++) {
 		unsigned j = i;
 		/* Duplicate the last usage we parsed if we have excess values */
@@ -258,6 +274,12 @@ static int hid_add_field(struct hid_pars
 		field->usage[i].hid = parser->local.usage[j];
 		field->usage[i].collection_index =
 			parser->local.collection_index[j];
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	field->maxusage = usages;
@@ -554,13 +576,35 @@ static void hid_device_release(struct de
 	struct hid_device *device = container_of(dev, struct hid_device, dev);
 	unsigned i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < HID_REPORT_TYPES; i++) {
 		struct hid_report_enum *report_enum = device->report_enum + i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < HID_MAX_IDS; j++) {
 			struct hid_report *report = report_enum->report_id_hash[j];
 			if (report)
 				hid_free_report(report);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}
 
@@ -969,7 +1013,12 @@ static void hid_input_field(struct hid_d
 	if (!value)
 		return;
 
-	for (n = 0; n < count; n++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (n = 0; n < count; n++) {
 
 		value[n] = min < 0 ?
 			snto32(extract(hid, data, offset + n * size, size),
@@ -981,8 +1030,19 @@ static void hid_input_field(struct hid_d
 		    value[n] >= min && value[n] <= max &&
 		    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)
 			goto exit;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 0; n < count; n++) {
 
 		if (HID_MAIN_ITEM_VARIABLE & field->flags) {
@@ -999,6 +1059,12 @@ static void hid_input_field(struct hid_d
 			&& field->usage[value[n] - min].hid
 			&& search(field->value, value[n], count))
 				hid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 	}
 
 	memcpy(field->value, value, count * sizeof(__s32));
@@ -1018,6 +1084,11 @@ static void hid_output_field(const struc
 	unsigned size = field->report_size;
 	unsigned n;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 0; n < count; n++) {
 		if (field->logical_minimum < 0)	/* signed values */
 			implement(hid, data, offset + n * size, size,
@@ -1025,6 +1096,12 @@ static void hid_output_field(const struc
 		else				/* unsigned values */
 			implement(hid, data, offset + n * size, size,
 				  field->value[n]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1191,10 +1268,21 @@ int hid_input_report(struct hid_device *
 			"\nreport (size %u) (%snumbered) = ", size, report_enum->numbered ? "" : "un");
 	hid_debug_event(hid, buf);
 
-	for (i = 0; i < size; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < size; i++) {
 		snprintf(buf, HID_DEBUG_BUFSIZE - 1,
 				" %02x", data[i]);
 		hid_debug_event(hid, buf);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	hid_debug_event(hid, "\n");
 	kfree(buf);
diff -u -p a/accessibility/braille/braille_console.c b/accessibility/braille/braille_console.c
--- a/accessibility/braille/braille_console.c
+++ b/accessibility/braille/braille_console.c
@@ -95,6 +95,11 @@ static void braille_write(u16 *buf)
 	data[1] = '>';
 	csum ^= '>';
 	c = &data[2];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < WIDTH; i++) {
 		out = buf[i];
 		if (out >= 0x100)
@@ -107,6 +112,12 @@ static void braille_write(u16 *buf)
 			out |= 0x40;
 		}
 		*c++ = out;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (csum <= 0x05) {
@@ -141,10 +152,21 @@ static void vc_refresh(struct vc_data *v
 	u16 buf[WIDTH];
 	int i;
 
-	for (i = 0; i < WIDTH; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < WIDTH; i++) {
 		u16 glyph = screen_glyph(vc,
 				2 * (vc_x + i) + vc_y * vc->vc_size_row);
 		buf[i] = inverse_translate(vc, glyph, 1);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	braille_write(buf);
 }
diff -u -p a/bluetooth/btuart_cs.c b/bluetooth/btuart_cs.c
--- a/bluetooth/btuart_cs.c
+++ b/bluetooth/btuart_cs.c
@@ -630,11 +630,22 @@ static int btuart_check_config_notpicky(
 	p_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;
 	p_dev->resource[0]->end = 8;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < 5; j++) {
 		p_dev->resource[0]->start = base[j];
 		p_dev->io_lines = base[j] ? 16 : 3;
 		if (!pcmcia_request_io(p_dev))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return -ENODEV;
 }
diff -u -p a/bluetooth/hci_bcsp.c b/bluetooth/hci_bcsp.c
--- a/bluetooth/hci_bcsp.c
+++ b/bluetooth/hci_bcsp.c
@@ -255,19 +255,41 @@ static struct sk_buff *bcsp_prepare_pkt(
 	hdr[3] = ~(hdr[0] + hdr[1] + hdr[2]);
 
 	/* Put BCSP header */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		bcsp_slip_one_byte(nskb, hdr[i]);
 
 		if (bcsp->use_crc)
 			bcsp_crc_update(&bcsp_txmsg_crc, hdr[i]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* Put payload */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i++) {
 		bcsp_slip_one_byte(nskb, data[i]);
 
 		if (bcsp->use_crc)
 			bcsp_crc_update(&bcsp_txmsg_crc, data[i]);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Put CRC */
diff -u -p a/bluetooth/dtl1_cs.c b/bluetooth/dtl1_cs.c
--- a/bluetooth/dtl1_cs.c
+++ b/bluetooth/dtl1_cs.c
@@ -185,8 +185,19 @@ static void dtl1_control(dtl1_info_t *in
 	int i;
 
 	printk(KERN_INFO "Bluetooth: Nokia control data =");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < skb->len; i++) {
 		printk(" %02x", skb->data[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("\n");
 
diff -u -p a/bluetooth/btmrvl_sdio.c b/bluetooth/btmrvl_sdio.c
--- a/bluetooth/btmrvl_sdio.c
+++ b/bluetooth/btmrvl_sdio.c
@@ -204,6 +204,11 @@ static int btmrvl_sdio_poll_card_status(
 	u8 status;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tries = 0; tries < MAX_POLL_TRIES * 1000; tries++) {
 		status = sdio_readb(card->func, card->reg->card_status,	&ret);
 		if (ret)
@@ -212,6 +217,12 @@ static int btmrvl_sdio_poll_card_status(
 			return ret;
 
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = -ETIMEDOUT;
@@ -230,6 +241,11 @@ static int btmrvl_sdio_verify_fw_downloa
 	unsigned int tries;
 
 	 /* Wait for firmware to become ready */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tries = 0; tries < pollnum; tries++) {
 		if (btmrvl_sdio_read_fw_status(card, &firmwarestat) < 0)
 			continue;
@@ -240,6 +256,12 @@ static int btmrvl_sdio_verify_fw_downloa
 		} else {
 			msleep(10);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
diff -u -p a/bluetooth/btusb.c b/bluetooth/btusb.c
--- a/bluetooth/btusb.c
+++ b/bluetooth/btusb.c
@@ -468,6 +468,11 @@ static void btusb_isoc_complete(struct u
 		return;
 
 	if (urb->status == 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < urb->number_of_packets; i++) {
 			unsigned int offset = urb->iso_frame_desc[i].offset;
 			unsigned int length = urb->iso_frame_desc[i].actual_length;
@@ -483,6 +488,12 @@ static void btusb_isoc_complete(struct u
 				BT_ERR("%s corrupted SCO packet", hdev->name);
 				hdev->stat.err_rx++;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -508,10 +519,21 @@ static inline void __fill_isoc_descripto
 
 	BT_DBG("len %d mtu %d", len, mtu);
 
-	for (i = 0; i < BTUSB_MAX_ISOC_FRAMES && len >= mtu;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < BTUSB_MAX_ISOC_FRAMES && len >= mtu;
 					i++, offset += mtu, len -= mtu) {
 		urb->iso_frame_desc[i].offset = offset;
 		urb->iso_frame_desc[i].length = mtu;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (len && i < BTUSB_MAX_ISOC_FRAMES) {
@@ -864,6 +886,11 @@ static inline int __set_isoc_interface(s
 	data->isoc_tx_ep = NULL;
 	data->isoc_rx_ep = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {
 		ep_desc = &intf->cur_altsetting->endpoint[i].desc;
 
@@ -876,6 +903,12 @@ static inline int __set_isoc_interface(s
 			data->isoc_rx_ep = ep_desc;
 			continue;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!data->isoc_tx_ep || !data->isoc_rx_ep) {
@@ -985,6 +1018,11 @@ static int btusb_probe(struct usb_interf
 	if (!data)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {
 		ep_desc = &intf->cur_altsetting->endpoint[i].desc;
 
@@ -1002,6 +1040,12 @@ static int btusb_probe(struct usb_interf
 			data->bulk_rx_ep = ep_desc;
 			continue;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!data->intr_ep || !data->bulk_tx_ep || !data->bulk_rx_ep) {
diff -u -p a/bluetooth/bt3c_cs.c b/bluetooth/bt3c_cs.c
--- a/bluetooth/bt3c_cs.c
+++ b/bluetooth/bt3c_cs.c
@@ -512,9 +512,20 @@ static int bt3c_load_firmware(bt3c_info_
 		fcs = simple_strtoul(b, NULL, 16);
 
 		memset(b, 0, sizeof(b));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (tmp = 0, i = 0; i < size; i++) {
 			memcpy(b, ptr + (i * 2) + 2, 2);
 			tmp += simple_strtol(b, NULL, 16);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (((tmp + fcs) & 0xff) != 0xff) {
@@ -527,10 +538,21 @@ static int bt3c_load_firmware(bt3c_info_
 			bt3c_address(iobase, addr);
 
 			memset(b, 0, sizeof(b));
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < (size - 4) / 2; i++) {
 				memcpy(b, ptr + (i * 4) + 12, 4);
 				tmp = simple_strtoul(b, NULL, 16);
 				bt3c_put(iobase, tmp);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
@@ -701,11 +723,22 @@ static int bt3c_check_config_notpicky(st
 	p_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;
 	p_dev->resource[0]->end = 8;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < 5; j++) {
 		p_dev->resource[0]->start = base[j];
 		p_dev->io_lines = base[j] ? 16 : 3;
 		if (!pcmcia_request_io(p_dev))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return -ENODEV;
 }
diff -u -p a/bluetooth/btwilink.c b/bluetooth/btwilink.c
--- a/bluetooth/btwilink.c
+++ b/bluetooth/btwilink.c
@@ -163,6 +163,11 @@ static int ti_st_open(struct hci_dev *hd
 	/* provide contexts for callbacks from ST */
 	hst = hdev->driver_data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_BT_CHNL_IDS; i++) {
 		ti_st_proto[i].priv_data = hst;
 		ti_st_proto[i].max_frame_size = HCI_MAX_FRAME_SIZE;
@@ -218,6 +223,11 @@ done:
 		if (!hst->st_write) {
 			BT_ERR("undefined ST write function");
 			clear_bit(HCI_RUNNING, &hdev->flags);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < MAX_BT_CHNL_IDS; i++) {
 				/* Undo registration with ST */
 				err = st_unregister(&ti_st_proto[i]);
@@ -225,9 +235,21 @@ done:
 					BT_ERR("st_unregister() failed with "
 							"error %d", err);
 				hst->st_write = NULL;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			return -EIO;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -241,11 +263,22 @@ static int ti_st_close(struct hci_dev *h
 	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = MAX_BT_CHNL_IDS-1; i >= 0; i--) {
 		err = st_unregister(&ti_st_proto[i]);
 		if (err)
 			BT_ERR("st_unregister(%d) failed with error %d",
 					ti_st_proto[i].chnl_id, err);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	hst->st_write = NULL;
diff -u -p a/bluetooth/bluecard_cs.c b/bluetooth/bluecard_cs.c
--- a/bluetooth/bluecard_cs.c
+++ b/bluetooth/bluecard_cs.c
@@ -385,6 +385,11 @@ static void bluecard_receive(bluecard_in
 
 	len = bluecard_read(iobase, offset, buf, sizeof(buf));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i++) {
 
 		/* Allocate packet */
@@ -488,6 +493,12 @@ static void bluecard_receive(bluecard_in
 		}
 
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	info->hdev->stat.byte_rx += len;
diff -u -p a/infiniband/ulp/ipoib/ipoib_main.c b/infiniband/ulp/ipoib/ipoib_main.c
--- a/infiniband/ulp/ipoib/ipoib_main.c
+++ b/infiniband/ulp/ipoib/ipoib_main.c
@@ -1313,6 +1313,11 @@ static void ipoib_add_one(struct ib_devi
 		e = device->phys_port_cnt;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = s; p <= e; ++p) {
 		if (rdma_port_get_link_layer(device, p) != IB_LINK_LAYER_INFINIBAND)
 			continue;
@@ -1321,6 +1326,12 @@ static void ipoib_add_one(struct ib_devi
 			priv = netdev_priv(dev);
 			list_add_tail(&priv->list, dev_list);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ib_set_client_data(device, &ipoib_client, dev_list);
diff -u -p a/infiniband/ulp/ipoib/ipoib_cm.c b/infiniband/ulp/ipoib/ipoib_cm.c
--- a/infiniband/ulp/ipoib/ipoib_cm.c
+++ b/infiniband/ulp/ipoib/ipoib_cm.c
@@ -163,6 +163,11 @@ static struct sk_buff *ipoib_cm_alloc_rx
 		return NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < frags; i++) {
 		struct page *page = alloc_page(GFP_ATOMIC);
 
@@ -174,6 +179,12 @@ static struct sk_buff *ipoib_cm_alloc_rx
 						 0, PAGE_SIZE, DMA_FROM_DEVICE);
 		if (unlikely(ib_dma_mapping_error(priv->ca, mapping[i + 1])))
 			goto partial_error;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	rx_ring[id].skb = skb;
@@ -380,6 +391,11 @@ static int ipoib_cm_nonsrq_init_rx(struc
 
 	spin_unlock_irq(&priv->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ipoib_recvq_size; ++i) {
 		if (!ipoib_cm_alloc_rx_skb(dev, rx->rx_ring, i, IPOIB_CM_RX_SG - 1,
 					   rx->rx_ring[i].mapping)) {
@@ -394,6 +410,12 @@ static int ipoib_cm_nonsrq_init_rx(struc
 			ret = -EIO;
 			goto err_count;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rx->recv_count = ipoib_recvq_size;
@@ -533,6 +555,11 @@ static void skb_put_frags(struct sk_buff
 	length -= size;
 
 	num_frags = skb_shinfo(skb)->nr_frags;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_frags; i++) {
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
@@ -550,6 +577,12 @@ static void skb_put_frags(struct sk_buff
 			skb->len += size;
 			length -= size;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1573,6 +1606,11 @@ int ipoib_cm_dev_init(struct net_device
 	ipoib_cm_init_rx_wr(dev, &priv->cm.rx_wr, priv->cm.rx_sge);
 
 	if (ipoib_cm_has_srq(dev)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < ipoib_recvq_size; ++i) {
 			if (!ipoib_cm_alloc_rx_skb(dev, priv->cm.srq_ring, i,
 						   priv->cm.num_frags - 1,
@@ -1589,6 +1627,12 @@ int ipoib_cm_dev_init(struct net_device
 				ipoib_cm_dev_cleanup(dev);
 				return -EIO;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/infiniband/ulp/ipoib/ipoib_fs.c b/infiniband/ulp/ipoib/ipoib_fs.c
--- a/infiniband/ulp/ipoib/ipoib_fs.c
+++ b/infiniband/ulp/ipoib/ipoib_fs.c
@@ -47,11 +47,22 @@ static void format_gid(union ib_gid *gid
 {
 	int i, n;
 
-	for (n = 0, i = 0; i < 8; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (n = 0, i = 0; i < 8; ++i) {
 		n += sprintf(buf + n, "%x",
 			     be16_to_cpu(((__be16 *) gid->raw)[i]));
 		if (i < 7)
 			buf[n++] = ':';
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/infiniband/ulp/ipoib/ipoib_ib.c b/infiniband/ulp/ipoib/ipoib_ib.c
--- a/infiniband/ulp/ipoib/ipoib_ib.c
+++ b/infiniband/ulp/ipoib/ipoib_ib.c
@@ -207,6 +207,11 @@ static int ipoib_ib_post_receives(struct
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ipoib_recvq_size; ++i) {
 		if (!ipoib_alloc_rx_skb(dev, i)) {
 			ipoib_warn(priv, "failed to allocate receive buffer %d\n", i);
@@ -216,6 +221,12 @@ static int ipoib_ib_post_receives(struct
 			ipoib_warn(priv, "ipoib_ib_post_receive failed for buf %d\n", i);
 			return -EIO;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -325,6 +336,11 @@ static int ipoib_dma_map_tx(struct ib_de
 	} else
 		off = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; ++i) {
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 		mapping[i + off] = ib_dma_map_page(ca,
@@ -333,6 +349,12 @@ static int ipoib_dma_map_tx(struct ib_de
 						 DMA_TO_DEVICE);
 		if (unlikely(ib_dma_mapping_error(ca, mapping[i + off])))
 			goto partial_error;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	return 0;
 
@@ -363,11 +385,22 @@ static void ipoib_dma_unmap_tx(struct ib
 	} else
 		off = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; ++i) {
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
 		ib_dma_unmap_page(ca, mapping[i + off], skb_frag_size(frag),
 				  DMA_TO_DEVICE);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -436,6 +469,11 @@ poll_more:
 		t = min(IPOIB_NUM_WC, max);
 		n = ib_poll_cq(priv->recv_cq, t, priv->ibwc);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < n; i++) {
 			struct ib_wc *wc = priv->ibwc + i;
 
@@ -447,6 +485,12 @@ poll_more:
 					ipoib_ib_handle_rx_wc(dev, wc);
 			} else
 				ipoib_cm_handle_tx_wc(priv->dev, wc);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 
 		if (n != t)
@@ -514,9 +558,20 @@ static inline int post_send(struct ipoib
 	} else
 		off = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nr_frags; ++i) {
 		priv->tx_sge[i + off].addr = mapping[i + off];
 		priv->tx_sge[i + off].length = skb_frag_size(&frags[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	priv->tx_wr.num_sge	     = nr_frags + off;
 	priv->tx_wr.wr_id 	     = wr_id;
@@ -781,6 +836,11 @@ void ipoib_drain_cq(struct net_device *d
 
 	do {
 		n = ib_poll_cq(priv->recv_cq, IPOIB_NUM_WC, priv->ibwc);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < n; ++i) {
 			/*
 			 * Convert any successful completions to flush
@@ -797,6 +857,12 @@ void ipoib_drain_cq(struct net_device *d
 					ipoib_ib_handle_rx_wc(dev, priv->ibwc + i);
 			} else
 				ipoib_cm_handle_tx_wc(dev, priv->ibwc + i);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	} while (n == IPOIB_NUM_WC);
 
@@ -848,7 +914,12 @@ int ipoib_ib_dev_stop(struct net_device
 				--priv->tx_outstanding;
 			}
 
-			for (i = 0; i < ipoib_recvq_size; ++i) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (i = 0; i < ipoib_recvq_size; ++i) {
 				struct ipoib_rx_buf *rx_req;
 
 				rx_req = &priv->rx_ring[i];
@@ -858,6 +929,12 @@ int ipoib_ib_dev_stop(struct net_device
 						      priv->rx_ring[i].mapping);
 				dev_kfree_skb_any(rx_req->skb);
 				rx_req->skb = NULL;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 
 			goto timeout;
diff -u -p a/infiniband/ulp/iser/iser_initiator.c b/infiniband/ulp/iser/iser_initiator.c
--- a/infiniband/ulp/iser/iser_initiator.c
+++ b/infiniband/ulp/iser/iser_initiator.c
@@ -185,7 +185,12 @@ int iser_alloc_rx_descriptors(struct ise
 
 	rx_desc = ib_conn->rx_descs;
 
-	for (i = 0; i < ISER_QP_MAX_RECV_DTOS; i++, rx_desc++)  {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < ISER_QP_MAX_RECV_DTOS; i++, rx_desc++)  {
 		dma_addr = ib_dma_map_single(device->ib_device, (void *)rx_desc,
 					ISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);
 		if (ib_dma_mapping_error(device->ib_device, dma_addr))
@@ -197,6 +202,12 @@ int iser_alloc_rx_descriptors(struct ise
 		rx_sg->addr   = rx_desc->dma_addr;
 		rx_sg->length = ISER_RX_PAYLOAD_SIZE;
 		rx_sg->lkey   = device->mr->lkey;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ib_conn->rx_desc_head = 0;
diff -u -p a/infiniband/ulp/iser/iser_verbs.c b/infiniband/ulp/iser/iser_verbs.c
--- a/infiniband/ulp/iser/iser_verbs.c
+++ b/infiniband/ulp/iser/iser_verbs.c
@@ -702,6 +702,11 @@ int iser_post_recvm(struct iser_conn *ib
 	unsigned int my_rx_head = ib_conn->rx_desc_head;
 	struct iser_rx_desc *rx_desc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rx_wr = ib_conn->rx_wr, i = 0; i < count; i++, rx_wr++) {
 		rx_desc		= &ib_conn->rx_descs[my_rx_head];
 		rx_wr->wr_id	= (unsigned long)rx_desc;
@@ -709,6 +714,12 @@ int iser_post_recvm(struct iser_conn *ib
 		rx_wr->num_sge	= 1;
 		rx_wr->next	= rx_wr + 1;
 		my_rx_head = (my_rx_head + 1) & (ISER_QP_MAX_RECV_DTOS - 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rx_wr--;
diff -u -p a/infiniband/ulp/srp/ib_srp.c b/infiniband/ulp/srp/ib_srp.c
--- a/infiniband/ulp/srp/ib_srp.c
+++ b/infiniband/ulp/srp/ib_srp.c
@@ -460,6 +460,11 @@ static void srp_free_req_data(struct srp
 	struct srp_request *req;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, req = target->req_ring; i < SRP_CMD_SQ_SIZE; ++i, ++req) {
 		kfree(req->fmr_list);
 		kfree(req->map_page);
@@ -469,6 +474,12 @@ static void srp_free_req_data(struct srp
 					    DMA_TO_DEVICE);
 		}
 		kfree(req->indirect_desc);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -658,10 +669,21 @@ static int srp_reconnect_target(struct s
 	while (ib_poll_cq(target->send_cq, 1, &wc) > 0)
 		; /* nothing */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < SRP_CMD_SQ_SIZE; ++i) {
 		struct srp_request *req = &target->req_ring[i];
 		if (req->scmnd)
 			srp_reset_req(target, req);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+		}
 	}
 
 	INIT_LIST_HEAD(&target->free_tx);
@@ -1367,15 +1389,31 @@ static int srp_alloc_iu_bufs(struct srp_
 {
 	int i;
 
-	for (i = 0; i < SRP_RQ_SIZE; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < SRP_RQ_SIZE; ++i) {
 		target->rx_ring[i] = srp_alloc_iu(target->srp_host,
 						  target->max_ti_iu_len,
 						  GFP_KERNEL, DMA_FROM_DEVICE);
 		if (!target->rx_ring[i])
 			goto err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
-	for (i = 0; i < SRP_SQ_SIZE; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < SRP_SQ_SIZE; ++i) {
 		target->tx_ring[i] = srp_alloc_iu(target->srp_host,
 						  target->max_iu_len,
 						  GFP_KERNEL, DMA_TO_DEVICE);
@@ -1383,19 +1421,47 @@ static int srp_alloc_iu_bufs(struct srp_
 			goto err;
 
 		list_add(&target->tx_ring[i]->list, &target->free_tx);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
 
 err:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < SRP_RQ_SIZE; ++i) {
 		srp_free_iu(target->srp_host, target->rx_ring[i]);
 		target->rx_ring[i] = NULL;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < SRP_SQ_SIZE; ++i) {
 		srp_free_iu(target->srp_host, target->tx_ring[i]);
 		target->tx_ring[i] = NULL;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return -ENOMEM;
@@ -1448,11 +1514,22 @@ static void srp_cm_rep_handler(struct ib
 	if (ret)
 		goto error_free;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < SRP_RQ_SIZE; i++) {
 		struct srp_iu *iu = target->rx_ring[i];
 		ret = srp_post_recv(target, iu);
 		if (ret)
 			goto error_free;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	qp_attr->qp_state = IB_QPS_RTS;
@@ -1689,10 +1766,21 @@ static int srp_reset_device(struct scsi_
 	if (target->tsk_mgmt_status)
 		return FAILED;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < SRP_CMD_SQ_SIZE; ++i) {
 		struct srp_request *req = &target->req_ring[i];
 		if (req->scmnd && req->scmnd->device == scmnd->device)
 			srp_reset_req(target, req);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	return SUCCESS;
@@ -2034,9 +2122,20 @@ static int srp_parse_options(const char
 				goto out;
 			}
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 16; ++i) {
 				strlcpy(dgid, p + i * 2, 3);
 				target->path.dgid.raw[i] = simple_strtoul(dgid, NULL, 16);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			kfree(p);
 			memcpy(target->orig_dgid, target->path.dgid.raw, 16);
@@ -2203,7 +2302,12 @@ static ssize_t srp_create_target(struct
 	spin_lock_init(&target->lock);
 	INIT_LIST_HEAD(&target->free_tx);
 	INIT_LIST_HEAD(&target->free_reqs);
-	for (i = 0; i < SRP_CMD_SQ_SIZE; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < SRP_CMD_SQ_SIZE; ++i) {
 		struct srp_request *req = &target->req_ring[i];
 
 		req->fmr_list = kmalloc(target->cmd_sg_cnt * sizeof (void *),
@@ -2223,6 +2327,12 @@ static ssize_t srp_create_target(struct
 		req->indirect_dma_addr = dma_addr;
 		req->index = i;
 		list_add_tail(&req->list, &target->free_reqs);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ib_query_gid(ibdev, host->port, 0, &target->path.sgid);
@@ -2411,10 +2521,21 @@ static void srp_add_one(struct ib_device
 		e = device->phys_port_cnt;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = s; p <= e; ++p) {
 		host = srp_add_port(srp_dev, p);
 		if (host)
 			list_add_tail(&host->list, &srp_dev->dev_list);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	ib_set_client_data(device, &srp_client, srp_dev);
diff -u -p a/infiniband/hw/mlx4/qp.c b/infiniband/hw/mlx4/qp.c
--- a/infiniband/hw/mlx4/qp.c
+++ b/infiniband/hw/mlx4/qp.c
@@ -153,20 +153,42 @@ static void stamp_send_wqe(struct mlx4_i
 
 	if (qp->sq_max_wqes_per_wr > 1) {
 		s = roundup(size, 1U << qp->sq.wqe_shift);
-		for (i = 0; i < s; i += 64) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < s; i += 64) {
 			ind = (i >> qp->sq.wqe_shift) + n;
 			stamp = ind & qp->sq.wqe_cnt ? cpu_to_be32(0x7fffffff) :
 						       cpu_to_be32(0xffffffff);
 			buf = get_send_wqe(qp, ind & (qp->sq.wqe_cnt - 1));
 			wqe = buf + (i & ((1 << qp->sq.wqe_shift) - 1));
 			*wqe = stamp;
+			if (_cur < timeout) {
+						       rdstcll(_cur);
+			}
+			else {
+						       break;
+			}
 		}
 	} else {
 		ctrl = buf = get_send_wqe(qp, n & (qp->sq.wqe_cnt - 1));
 		s = (ctrl->fence_size & 0x3f) << 4;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 64; i < s; i += 64) {
 			wqe = buf + i;
 			*wqe = cpu_to_be32(0xffffffff);
+			if (_cur < timeout) {
+						       rdstcll(_cur);
+			}
+			else {
+						       break;
+			}
 		}
 	}
 }
@@ -1227,6 +1249,11 @@ static int __mlx4_ib_modify_qp(struct ib
 		struct mlx4_wqe_ctrl_seg *ctrl;
 		int i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < qp->sq.wqe_cnt; ++i) {
 			ctrl = get_send_wqe(qp, i);
 			ctrl->owner_opcode = cpu_to_be32(1 << 31);
@@ -1234,6 +1261,12 @@ static int __mlx4_ib_modify_qp(struct ib
 				ctrl->fence_size = 1 << (qp->sq.wqe_shift - 4);
 
 			stamp_send_wqe(qp, i, 1 << qp->sq.wqe_shift);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1461,6 +1494,11 @@ static int build_mlx_header(struct mlx4_
 
 	if (0) {
 		printk(KERN_ERR "built UD header of size %d:\n", header_size);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < header_size / 4; ++i) {
 			if (i % 8 == 0)
 				printk("  [%02x] ", i * 4);
@@ -1468,6 +1506,12 @@ static int build_mlx_header(struct mlx4_
 			       be32_to_cpu(((__be32 *) sqp->header_buf)[i]));
 			if ((i + 1) % 8 == 0)
 				printk("\n");
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		printk("\n");
 	}
@@ -1715,6 +1759,11 @@ int mlx4_ib_post_send(struct ib_qp *ibqp
 
 	ind = qp->sq_next_wqe;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nreq = 0; wr; ++nreq, wr = wr->next) {
 		lso_wqe = &dummy;
 		blh = 0;
@@ -1907,7 +1956,13 @@ int mlx4_ib_post_send(struct ib_qp *ibqp
 			stamp_send_wqe(qp, stamp, size * 16);
 			ind = pad_wraparound(qp, ind);
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 out:
 	if (likely(nreq)) {
@@ -1954,6 +2009,11 @@ int mlx4_ib_post_recv(struct ib_qp *ibqp
 
 	ind = qp->rq.head & (qp->rq.wqe_cnt - 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nreq = 0; wr; ++nreq, wr = wr->next) {
 		if (mlx4_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {
 			err = -ENOMEM;
@@ -1981,7 +2041,13 @@ int mlx4_ib_post_recv(struct ib_qp *ibqp
 		qp->rq.wrid[ind] = wr->wr_id;
 
 		ind = (ind + 1) & (qp->rq.wqe_cnt - 1);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 out:
 	if (likely(nreq)) {
diff -u -p a/infiniband/hw/mlx4/srq.c b/infiniband/hw/mlx4/srq.c
--- a/infiniband/hw/mlx4/srq.c
+++ b/infiniband/hw/mlx4/srq.c
@@ -149,7 +149,12 @@ struct ib_srq *mlx4_ib_create_srq(struct
 		srq->tail    = srq->msrq.max - 1;
 		srq->wqe_ctr = 0;
 
-		for (i = 0; i < srq->msrq.max; ++i) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < srq->msrq.max; ++i) {
 			next = get_wqe(srq, i);
 			next->next_wqe_index =
 				cpu_to_be16((i + 1) & (srq->msrq.max - 1));
@@ -158,6 +163,12 @@ struct ib_srq *mlx4_ib_create_srq(struct
 			     (void *) scatter < (void *) next + desc_size;
 			     ++scatter)
 				scatter->lkey = cpu_to_be32(MLX4_INVALID_LKEY);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 
 		err = mlx4_mtt_init(dev->dev, srq->buf.npages, srq->buf.page_shift,
@@ -337,10 +348,21 @@ int mlx4_ib_post_srq_recv(struct ib_srq
 		srq->head = be16_to_cpu(next->next_wqe_index);
 		scat      = (struct mlx4_wqe_data_seg *) (next + 1);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wr->num_sge; ++i) {
 			scat[i].byte_count = cpu_to_be32(wr->sg_list[i].length);
 			scat[i].lkey       = cpu_to_be32(wr->sg_list[i].lkey);
 			scat[i].addr       = cpu_to_be64(wr->sg_list[i].addr);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (i < srq->msrq.max_gs) {
diff -u -p a/infiniband/hw/mlx4/main.c b/infiniband/hw/mlx4/main.c
--- a/infiniband/hw/mlx4/main.c
+++ b/infiniband/hw/mlx4/main.c
@@ -1198,6 +1198,11 @@ static void *mlx4_ib_add(struct mlx4_dev
 	if (init_node_data(ibdev))
 		goto err_map;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ibdev->num_ports; ++i) {
 		if (mlx4_ib_port_link_layer(&ibdev->ib_dev, i + 1) ==
 						IB_LINK_LAYER_ETHERNET) {
@@ -1206,6 +1211,12 @@ static void *mlx4_ib_add(struct mlx4_dev
 				ibdev->counters[i] = -1;
 		} else
 				ibdev->counters[i] = -1;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+		}
 	}
 
 	spin_lock_init(&ibdev->sm_lock);
@@ -1224,10 +1235,21 @@ static void *mlx4_ib_add(struct mlx4_dev
 			goto err_reg;
 	}
 
-	for (i = 0; i < ARRAY_SIZE(mlx4_class_attributes); ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < ARRAY_SIZE(mlx4_class_attributes); ++i) {
 		if (device_create_file(&ibdev->ib_dev.dev,
 				       mlx4_class_attributes[i]))
 			goto err_notif;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	ibdev->ib_active = true;
diff -u -p a/infiniband/hw/mlx4/mad.c b/infiniband/hw/mlx4/mad.c
--- a/infiniband/hw/mlx4/mad.c
+++ b/infiniband/hw/mlx4/mad.c
@@ -378,8 +378,18 @@ int mlx4_ib_mad_init(struct mlx4_ib_dev
 	int ret;
 	enum rdma_link_layer ll;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = 0; p < dev->num_ports; ++p) {
 		ll = rdma_port_get_link_layer(&dev->ib_dev, p + 1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (q = 0; q <= 1; ++q) {
 			if (ll == IB_LINK_LAYER_INFINIBAND) {
 				agent = ib_register_mad_agent(&dev->ib_dev, p + 1,
@@ -393,7 +403,19 @@ int mlx4_ib_mad_init(struct mlx4_ib_dev
 				dev->send_agent[p][q] = agent;
 			} else
 				dev->send_agent[p][q] = NULL;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+			}
 	}
 
 	return 0;
@@ -412,16 +434,38 @@ void mlx4_ib_mad_cleanup(struct mlx4_ib_
 	struct ib_mad_agent *agent;
 	int p, q;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = 0; p < dev->num_ports; ++p) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (q = 0; q <= 1; ++q) {
 			agent = dev->send_agent[p][q];
 			if (agent) {
 				dev->send_agent[p][q] = NULL;
 				ib_unregister_mad_agent(agent);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (dev->sm_ah[p])
 			ib_destroy_ah(dev->sm_ah[p]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
diff -u -p a/infiniband/hw/mlx4/mr.c b/infiniband/hw/mlx4/mr.c
--- a/infiniband/hw/mlx4/mr.c
+++ b/infiniband/hw/mlx4/mr.c
@@ -92,23 +92,46 @@ int mlx4_ib_umem_write_mtt(struct mlx4_i
 
 	i = n = 0;
 
-	list_for_each_entry(chunk, &umem->chunk_list, list)
-		for (j = 0; j < chunk->nmap; ++j) {
-			len = sg_dma_len(&chunk->page_list[j]) >> mtt->page_shift;
-			for (k = 0; k < len; ++k) {
-				pages[i++] = sg_dma_address(&chunk->page_list[j]) +
-					umem->page_size * k;
+	list_for_each_entry(chunk, &umem->chunk_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; j < chunk->nmap; ++j) {
+				len = sg_dma_len(&chunk->page_list[j]) >> mtt->page_shift;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (k = 0; k < len; ++k) {
+					pages[i++] = sg_dma_address(&chunk->page_list[j]) +
+						umem->page_size * k;
 				/*
 				 * Be friendly to mlx4_write_mtt() and
 				 * pass it chunks of appropriate size.
 				 */
-				if (i == PAGE_SIZE / sizeof (u64)) {
-					err = mlx4_write_mtt(dev->dev, mtt, n,
-							     i, pages);
-					if (err)
-						goto out;
-					n += i;
-					i = 0;
+					if (i == PAGE_SIZE / sizeof (u64)) {
+						err = mlx4_write_mtt(dev->dev, mtt, n,
+							i, pages);
+						if (err)
+							goto out;
+						n += i;
+						i = 0;
+					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
 				}
 			}
 		}
diff -u -p a/infiniband/hw/ipath/ipath_file_ops.c b/infiniband/hw/ipath/ipath_file_ops.c
--- a/infiniband/hw/ipath/ipath_file_ops.c
+++ b/infiniband/hw/ipath/ipath_file_ops.c
@@ -548,6 +548,11 @@ static int ipath_tid_free(struct ipath_p
 	ipath_cdbg(VERBOSE, "Port%u free %u tids; first bit (max=%d) "
 		   "set is %d, porttid %u\n", pd->port_port, ti->tidcnt,
 		   limit, tid, porttid);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; tid < limit; tid++) {
 		/*
 		 * small optimization; if we detect a run of 3 or so without
@@ -575,6 +580,12 @@ static int ipath_tid_free(struct ipath_p
 			ipath_stats.sps_pageunlocks++;
 		} else
 			ipath_dbg("Unused tid %u, ignoring\n", tid);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (cnt != ti->tidcnt)
 		ipath_dbg("passed in tidcnt %d, only %d bits set in map\n",
@@ -638,6 +649,11 @@ static int ipath_set_part_key(struct ipa
 	 */
 	key |= 0x8000;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(pd->port_pkeys); i++) {
 		if (!pd->port_pkeys[i] && pidx == -1)
 			pidx = i;
@@ -648,6 +664,12 @@ static int ipath_set_part_key(struct ipa
 			ret = -EEXIST;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (pidx == -1) {
 		ipath_dbg("All pkeys for port %u already in use, "
@@ -655,6 +677,11 @@ static int ipath_set_part_key(struct ipa
 		ret = -EBUSY;
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (any = i = 0; i < ARRAY_SIZE(dd->ipath_pkeys); i++) {
 		if (!dd->ipath_pkeys[i]) {
 			any++;
@@ -691,6 +718,12 @@ static int ipath_set_part_key(struct ipa
 			ret = -EEXIST;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!any) {
 		ipath_dbg("port %u, all pkeys already in use, "
@@ -698,6 +731,11 @@ static int ipath_set_part_key(struct ipa
 		ret = -EBUSY;
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (any = i = 0; i < ARRAY_SIZE(dd->ipath_pkeys); i++) {
 		if (!dd->ipath_pkeys[i] &&
 		    atomic_inc_return(&dd->ipath_pkeyrefs[i]) == 1) {
@@ -721,6 +759,12 @@ static int ipath_set_part_key(struct ipa
 			ret = 0;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ipath_dbg("port %u, all pkeys already in use 2nd pass, "
 		  "can't set %x\n", pd->port_port, key);
@@ -802,11 +846,21 @@ static void ipath_clean_part_key(struct
 		((u64) dd->ipath_pkeys[2] << 32) |
 		((u64) dd->ipath_pkeys[3] << 48);
 
-	for (i = 0; i < ARRAY_SIZE(pd->port_pkeys); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(pd->port_pkeys); i++) {
 		if (!pd->port_pkeys[i])
 			continue;
 		ipath_cdbg(VERBOSE, "look for key[%d] %hx in pkeys\n", i,
 			   pd->port_pkeys[i]);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < ARRAY_SIZE(dd->ipath_pkeys); j++) {
 			/* check for match independent of the global bit */
 			if ((dd->ipath_pkeys[j] & 0x7fff) !=
@@ -827,8 +881,20 @@ static void ipath_clean_part_key(struct
 				pd->port_pkeys[i], j,
 				atomic_read(&dd->ipath_pkeyrefs[j]));
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		pd->port_pkeys[i] = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (pchanged) {
 		u64 pkey = (u64) dd->ipath_pkeys[0] |
@@ -925,7 +991,12 @@ static int ipath_create_user_egr(struct
 		ret = -ENOMEM;
 		goto bail_rcvegrbuf;
 	}
-	for (e = 0; e < pd->port_rcvegrbuf_chunks; e++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (e = 0; e < pd->port_rcvegrbuf_chunks; e++) {
 
 		pd->port_rcvegrbuf[e] = dma_alloc_coherent(
 			&dd->pcidev->dev, size, &pd->port_rcvegrbuf_phys[e],
@@ -935,14 +1006,30 @@ static int ipath_create_user_egr(struct
 			ret = -ENOMEM;
 			goto bail_rcvegrbuf_phys;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pd->port_rcvegr_phys = pd->port_rcvegrbuf_phys[0];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (e = chunk = 0; chunk < pd->port_rcvegrbuf_chunks; chunk++) {
 		dma_addr_t pa = pd->port_rcvegrbuf_phys[chunk];
 		unsigned i;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; e < egrcnt && i < egrperchunk; e++, i++) {
 			dd->ipath_f_put_tid(dd, e + egroff +
 					    (u64 __iomem *)
@@ -951,20 +1038,43 @@ static int ipath_create_user_egr(struct
 					     dd->ipath_rcvegrbase),
 					    RCVHQ_RCV_TYPE_EAGER, pa);
 			pa += egrsize;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		cond_resched();	/* don't hog the cpu */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = 0;
 	goto bail;
 
 bail_rcvegrbuf_phys:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (e = 0; e < pd->port_rcvegrbuf_chunks &&
 		pd->port_rcvegrbuf[e]; e++) {
 		dma_free_coherent(&dd->pcidev->dev, size,
 				  pd->port_rcvegrbuf[e],
 				  pd->port_rcvegrbuf_phys[e]);
 
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	kfree(pd->port_rcvegrbuf_phys);
 	pd->port_rcvegrbuf_phys = NULL;
@@ -1124,12 +1234,23 @@ static int mmap_rcvegrbufs(struct vm_are
 
 	start = vma->vm_start;
 
-	for (i = 0; i < pd->port_rcvegrbuf_chunks; i++, start += size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < pd->port_rcvegrbuf_chunks; i++, start += size) {
 		pfn = virt_to_phys(pd->port_rcvegrbuf[i]) >> PAGE_SHIFT;
 		ret = remap_pfn_range(vma, start, pfn, size,
 				      vma->vm_page_prot);
 		if (ret < 0)
 			goto bail;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	ret = 0;
 
@@ -1650,10 +1771,21 @@ static int find_free_port(int unit, stru
 		goto bail;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < dd->ipath_cfgports; i++) {
 		ret = try_alloc_port(dd, i, fp, uinfo);
 		if (ret != -EBUSY)
 			goto bail;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	ret = -EBUSY;
 
@@ -1719,7 +1851,17 @@ static int find_best_unit(struct file *f
 	if (prefunit != -1)
 		devmax = prefunit + 1;
 recheck:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < maxofallports; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (ndev = prefunit != -1 ? prefunit : 0; ndev < devmax;
 		     ndev++) {
 			struct ipath_devdata *dd = ipath_lookup(ndev);
@@ -1735,6 +1877,18 @@ recheck:
 			ret = try_alloc_port(dd, i, fp, uinfo);
 			if (!ret)
 				goto done;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -1776,11 +1930,21 @@ static int find_shared_port(struct file
 
 	devmax = ipath_count_units(NULL, NULL, NULL);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ndev = 0; ndev < devmax; ndev++) {
 		struct ipath_devdata *dd = ipath_lookup(ndev);
 
 		if (!usable(dd))
 			continue;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 1; i < dd->ipath_cfgports; i++) {
 			struct ipath_portdata *pd = dd->ipath_pd[i];
 
@@ -1811,6 +1975,18 @@ static int find_shared_port(struct file
 				   dd->ipath_unit, pd->port_port);
 			ret = 1;
 			goto done;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -2015,6 +2191,11 @@ static void unlock_expected_tids(struct
 
 	ipath_cdbg(VERBOSE, "Port %u unlocking any locked expTID pages\n",
 		   pd->port_port);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = port_tidbase; i < maxtid; i++) {
 		struct page *ps = dd->ipath_pageshadow[i];
 
@@ -2027,6 +2208,12 @@ static void unlock_expected_tids(struct
 		ipath_release_user_pages_on_close(&ps, 1);
 		cnt++;
 		ipath_stats.sps_pageunlocks++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (cnt)
 		ipath_cdbg(VERBOSE, "Port %u locked %u expTID entries\n",
diff -u -p a/infiniband/hw/ipath/ipath_driver.c b/infiniband/hw/ipath/ipath_driver.c
--- a/infiniband/hw/ipath/ipath_driver.c
+++ b/infiniband/hw/ipath/ipath_driver.c
@@ -365,9 +365,20 @@ static void ipath_verify_pioperf(struct
 	 * >= 5 msec seems to get us "close enough" to accurate values
 	 */
 	msecs = jiffies_to_msecs(jiffies);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (emsecs = lcnt = 0; emsecs <= 5UL; lcnt++) {
 		__iowrite32_copy(piobuf + 64, addr, cnt >> 2);
 		emsecs = jiffies_to_msecs(jiffies) - msecs;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* 1 GiB/sec, slightly over IB SDR line rate */
@@ -526,12 +537,23 @@ static int __devinit ipath_init_one(stru
 		return -ENODEV;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < 6; j++) {
 		if (!pdev->resource[j].start)
 			continue;
 		ipath_cdbg(VERBOSE, "BAR %d %pR, len %llx\n",
 			   j, &pdev->resource[j],
 			   (unsigned long long)pci_resource_len(pdev, j));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!addr) {
@@ -682,10 +704,20 @@ static void cleanup_device(struct ipath_
 
 		ipath_cdbg(VERBOSE, "Unlocking any expTID pages still "
 			   "locked\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (port = 0; port < dd->ipath_cfgports; port++) {
 			int port_tidbase = port * dd->ipath_rcvtidcnt;
 			int maxtid = port_tidbase + dd->ipath_rcvtidcnt;
-			for (i = port_tidbase; i < maxtid; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (i = port_tidbase; i < maxtid; i++) {
 				if (!tmpp[i])
 					continue;
 				pci_unmap_page(dd->pcidev, tmpd[i],
@@ -693,6 +725,18 @@ static void cleanup_device(struct ipath_
 				ipath_release_user_pages(&tmpp[i], 1);
 				tmpp[i] = NULL;
 				cnt++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 		if (cnt) {
@@ -729,10 +773,21 @@ static void cleanup_device(struct ipath_
 	tmp = dd->ipath_pd;
 	dd->ipath_pd = NULL;
 	spin_unlock_irqrestore(&dd->ipath_uctxt_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (port = 0; port < dd->ipath_portcnt; port++) {
 		struct ipath_portdata *pd = tmp[port];
 		tmp[port] = NULL; /* debugging paranoia */
 		ipath_free_pddata(dd, pd);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	kfree(tmp);
 }
@@ -819,7 +874,12 @@ void ipath_disarm_piobufs(struct ipath_d
 	unsigned long flags;
 
 	ipath_cdbg(PKT, "disarm %u PIObufs first=%u\n", cnt, first);
-	for (i = first; i < last; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = first; i < last; i++) {
 		spin_lock_irqsave(&dd->ipath_sendctrl_lock, flags);
 		/*
 		 * The disarm-related bits are write-only, so it
@@ -832,6 +892,12 @@ void ipath_disarm_piobufs(struct ipath_d
 		/* can't disarm bufs back-to-back per iba7220 spec */
 		ipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);
 		spin_unlock_irqrestore(&dd->ipath_sendctrl_lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* on some older chips, update may not happen after cancel */
 	ipath_force_pio_avail_update(dd);
@@ -900,12 +966,23 @@ static void decode_sdma_errs(struct ipat
 	int expected;
 	size_t bidx = 0;
 
-	for (i = 0; i < ARRAY_SIZE(errs); i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(errs); i++) {
 		expected = (errs[i].err != INFINIPATH_E_SDMADISABLED) ? 0 :
 			test_bit(IPATH_SDMA_ABORTING, &dd->ipath_sdma_status);
 		if ((err & errs[i].err) && !expected)
 			bidx += snprintf(buf + bidx, blen - bidx,
 					 "%s ", errs[i].msg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -1176,6 +1253,11 @@ void ipath_kreceive(struct ipath_portdat
 	}
 
 reloop:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last = 0, i = 1; !last; i += !last) {
 		hdr = dd->ipath_f_get_msgheader(dd, rhf_addr);
 		eflags = ipath_hdrget_err_flags(rhf_addr);
@@ -1286,6 +1368,12 @@ reloop:
 				updegr = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!dd->ipath_rhdrhead_intr_off && !reloop &&
@@ -1386,6 +1474,11 @@ static void ipath_update_pio_bufs(struct
 				shadow[7]);
 	}
 	spin_lock_irqsave(&ipath_pioavail_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < piobregs; i++) {
 		u64 pchbusy, pchg, piov, pnew;
 		/*
@@ -1403,6 +1496,12 @@ static void ipath_update_pio_bufs(struct
 			pnew |= piov & pchbusy;
 			dd->ipath_pioavailshadow[i] = pnew;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&ipath_pioavail_lock, flags);
 }
@@ -1419,7 +1518,12 @@ static void ipath_reset_availshadow(stru
 	unsigned long flags;
 
 	spin_lock_irqsave(&ipath_pioavail_lock, flags);
-	for (i = 0; i < dd->ipath_pioavregs; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < dd->ipath_pioavregs; i++) {
 		u64 val, oldval;
 		/* deal with 6110 chip bug on high register #s */
 		im = (i > 3 && (dd->ipath_flags & IPATH_SWAP_PIOBUFS)) ?
@@ -1438,6 +1542,12 @@ static void ipath_reset_availshadow(stru
 			ipath_dbg("shadow[%d] was %Lx, now %lx\n",
 				i, (unsigned long long) oldval,
 				dd->ipath_pioavailshadow[i]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	spin_unlock_irqrestore(&ipath_pioavail_lock, flags);
 }
@@ -1562,6 +1672,11 @@ rescan:
 	 * of the remaining armlaunch errors.
 	 */
 	spin_lock_irqsave(&ipath_pioavail_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < piobcnt; j++, i++) {
 		if (i >= last)
 			i = first;
@@ -1570,6 +1685,12 @@ rescan:
 		/* flip generation bit */
 		__change_bit(2 * i, shadow);
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&ipath_pioavail_lock, flags);
 
@@ -2453,6 +2574,11 @@ void ipath_free_pddata(struct ipath_devd
 	if (pd->port_port && pd->port_rcvegrbuf) {
 		unsigned e;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (e = 0; e < pd->port_rcvegrbuf_chunks; e++) {
 			void *base = pd->port_rcvegrbuf[e];
 			size_t size = pd->port_rcvegrbuf_size;
@@ -2463,6 +2589,12 @@ void ipath_free_pddata(struct ipath_devd
 				   e, pd->port_rcvegrbuf_chunks);
 			dma_free_coherent(&dd->pcidev->dev, size,
 				base, pd->port_rcvegrbuf_phys[e]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		kfree(pd->port_rcvegrbuf);
 		pd->port_rcvegrbuf = NULL;
@@ -2587,18 +2719,30 @@ int ipath_reset_device(int unit)
 	}
 
 	spin_lock_irqsave(&dd->ipath_uctxt_lock, flags);
-	if (dd->ipath_pd)
-		for (i = 1; i < dd->ipath_cfgports; i++) {
-			if (!dd->ipath_pd[i] || !dd->ipath_pd[i]->port_cnt)
-				continue;
-			spin_unlock_irqrestore(&dd->ipath_uctxt_lock, flags);
-			ipath_dbg("unit %u port %d is in use "
-				  "(PID %u cmd %s), can't reset\n",
-				  unit, i,
-				  pid_nr(dd->ipath_pd[i]->port_pid),
-				  dd->ipath_pd[i]->port_comm);
+	if (dd->ipath_pd) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 1; i < dd->ipath_cfgports; i++) {
+				if (!dd->ipath_pd[i] || !dd->ipath_pd[i]->port_cnt)
+						continue;
+				spin_unlock_irqrestore(&dd->ipath_uctxt_lock, flags);
+				ipath_dbg("unit %u port %d is in use "
+				"(PID %u cmd %s), can't reset\n",
+				unit, i,
+				pid_nr(dd->ipath_pd[i]->port_pid),
+				dd->ipath_pd[i]->port_comm);
 			ret = -EBUSY;
 			goto bail;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+			}
 		}
 	spin_unlock_irqrestore(&dd->ipath_uctxt_lock, flags);
 
@@ -2640,6 +2784,11 @@ static int ipath_signal_procs(struct ipa
 		return 0;
 
 	spin_lock_irqsave(&dd->ipath_uctxt_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < dd->ipath_cfgports; i++) {
 		if (!dd->ipath_pd[i] || !dd->ipath_pd[i]->port_cnt)
 			continue;
@@ -2652,6 +2801,11 @@ static int ipath_signal_procs(struct ipa
 			  i, pid_nr(pid), sig);
 		kill_pid(pid, sig, 1);
 		any++;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (sub = 0; sub < INFINIPATH_MAX_SUBPORT; sub++) {
 			pid = dd->ipath_pd[i]->port_subpid[sub];
 			if (!pid)
@@ -2661,6 +2815,18 @@ static int ipath_signal_procs(struct ipa
 				"signal %d\n", i, sub, pid_nr(pid), sig);
 			kill_pid(pid, sig, 1);
 			any++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 	spin_unlock_irqrestore(&dd->ipath_uctxt_lock, flags);
diff -u -p a/infiniband/hw/ipath/ipath_user_pages.c b/infiniband/hw/ipath/ipath_user_pages.c
--- a/infiniband/hw/ipath/ipath_user_pages.c
+++ b/infiniband/hw/ipath/ipath_user_pages.c
@@ -43,12 +43,23 @@ static void __ipath_release_user_pages(s
 {
 	size_t i;
 
-	for (i = 0; i < num_pages; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < num_pages; i++) {
 		ipath_cdbg(MM, "%lu/%lu put_page %p\n", (unsigned long) i,
 			   (unsigned long) num_pages, p[i]);
 		if (dirty)
 			set_page_dirty_lock(p[i]);
 		put_page(p[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -70,13 +81,24 @@ static int __ipath_get_user_pages(unsign
 	ipath_cdbg(VERBOSE, "pin %lx pages from vaddr %lx\n",
 		   (unsigned long) num_pages, start_page);
 
-	for (got = 0; got < num_pages; got += ret) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (got = 0; got < num_pages; got += ret) {
 		ret = get_user_pages(current, current->mm,
 				     start_page + got * PAGE_SIZE,
 				     num_pages - got, 1, 1,
 				     p + got, vma);
 		if (ret < 0)
 			goto bail_release;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	current->mm->pinned_vm += num_pages;
diff -u -p a/infiniband/hw/ipath/ipath_init_chip.c b/infiniband/hw/ipath/ipath_init_chip.c
--- a/infiniband/hw/ipath/ipath_init_chip.c
+++ b/infiniband/hw/ipath/ipath_init_chip.c
@@ -99,6 +99,11 @@ static int create_port0_egr(struct ipath
 		ret = -ENOMEM;
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (e = 0; e < egrcnt; e++) {
 		/*
 		 * This is a bit tricky in that we allocate extra
@@ -118,6 +123,12 @@ static int create_port0_egr(struct ipath
 			ret = -ENOMEM;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * After loop above, so we can test non-NULL to see if ready
@@ -125,7 +136,12 @@ static int create_port0_egr(struct ipath
 	 */
 	dd->ipath_port0_skbinfo = skbinfo;
 
-	for (e = 0; e < egrcnt; e++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (e = 0; e < egrcnt; e++) {
 		dd->ipath_port0_skbinfo[e].phys =
 		  ipath_map_single(dd->pcidev,
 				   dd->ipath_port0_skbinfo[e].skb->data,
@@ -135,6 +151,12 @@ static int create_port0_egr(struct ipath
 				     dd->ipath_rcvegrbase),
 				    RCVHQ_RCV_TYPE_EAGER,
 				    dd->ipath_port0_skbinfo[e].phys);
+		if (_cur < timeout) {
+		  rdstcll(_cur);
+		}
+		else {
+		  break;
+		}
 	}
 
 	ret = 0;
@@ -351,11 +373,22 @@ static int init_chip_reset(struct ipath_
 	 * pioavail updates while we re-initialize
 	 */
 	dd->ipath_rcvctrl &= ~(1ULL << dd->ipath_r_tailupd_shift);
-	for (i = 0; i < dd->ipath_portcnt; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < dd->ipath_portcnt; i++) {
 		clear_bit(dd->ipath_r_portenable_shift + i,
 			  &dd->ipath_rcvctrl);
 		clear_bit(dd->ipath_r_intravail_shift + i,
 			  &dd->ipath_rcvctrl);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	ipath_write_kreg(dd, dd->ipath_kregs->kr_rcvctrl,
 		dd->ipath_rcvctrl);
@@ -533,6 +566,11 @@ static void enable_chip(struct ipath_dev
 	 * case something went wrong with abort, but mostly to get the
 	 * initial values of the generation bit correct.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dd->ipath_pioavregs; i++) {
 		__le64 pioavail;
 
@@ -549,6 +587,12 @@ static void enable_chip(struct ipath_dev
 		 * in initialization, to busy out buffers as needed
 		 */
 		dd->ipath_pioavailshadow[i] = le64_to_cpu(pioavail);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* can get counters, stats, etc. */
 	dd->ipath_flags |= IPATH_PRESENT;
diff -u -p a/infiniband/hw/ipath/ipath_eeprom.c b/infiniband/hw/ipath/ipath_eeprom.c
--- a/infiniband/hw/ipath/ipath_eeprom.c
+++ b/infiniband/hw/ipath/ipath_eeprom.c
@@ -272,11 +272,22 @@ static int rd_byte(struct ipath_devdata
 
 	data = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit_cntr = 7; bit_cntr >= 0; --bit_cntr) {
 		data <<= 1;
 		scl_out(dd, i2c_line_high);
 		data |= sda_in(dd, 0);
 		scl_out(dd, i2c_line_low);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return data;
 }
@@ -293,11 +304,22 @@ static int wr_byte(struct ipath_devdata
 	int bit_cntr;
 	u8 bit;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit_cntr = 7; bit_cntr >= 0; bit_cntr--) {
 		bit = (data >> bit_cntr) & 1;
 		sda_out(dd, bit);
 		scl_out(dd, i2c_line_high);
 		scl_out(dd, i2c_line_low);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (!i2c_ackrcv(dd)) ? 1 : 0;
 }
@@ -584,13 +606,24 @@ static int ipath_eeprom_internal_write(s
 		eeprom_offset += sub_len;
 		len -= sub_len;
 
-		for (i = 0; i < sub_len; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < sub_len; i++) {
 			if (wr_byte(dd, *bp++)) {
 				ipath_dbg("no ack after byte %u/%u (%u "
 					  "total remain)\n", i, sub_len,
 					  len + sub_len - i);
 				goto failed_write;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		stop_cmd(dd);
@@ -926,6 +959,11 @@ int ipath_update_eeprom_log(struct ipath
 	}
 	hi_water = 0;
 	spin_lock_irqsave(&dd->ipath_eep_st_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < IPATH_EEP_LOG_CNT; ++idx) {
 		int new_val = dd->ipath_eep_st_new_errs[idx];
 		if (new_val) {
@@ -952,6 +990,12 @@ int ipath_update_eeprom_log(struct ipath
 			dd->ipath_eep_st_errs[idx] = new_val;
 			dd->ipath_eep_st_new_errs[idx] = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * now update active-time. We would like to round to the nearest hour
diff -u -p a/infiniband/hw/ipath/ipath_intr.c b/infiniband/hw/ipath/ipath_intr.c
--- a/infiniband/hw/ipath/ipath_intr.c
+++ b/infiniband/hw/ipath/ipath_intr.c
@@ -212,17 +212,39 @@ void ipath_format_hwerrors(u64 hwerrs,
 	    sizeof(ipath_generic_hwerror_msgs) /
 	    sizeof(ipath_generic_hwerror_msgs[0]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i<glen; i++) {
 		if (hwerrs & ipath_generic_hwerror_msgs[i].mask) {
 			ipath_format_hwmsg(msg, msgl,
 					   ipath_generic_hwerror_msgs[i].msg);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i<nhwerrmsgs; i++) {
 		if (hwerrs & hwerrmsgs[i].mask) {
 			ipath_format_hwmsg(msg, msgl, hwerrmsgs[i].msg);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -590,6 +612,11 @@ static int handle_hdrq_full(struct ipath
 	u32 i;
 
 	ipath_stats.sps_hdrqfull++;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dd->ipath_cfgports; i++) {
 		struct ipath_portdata *pd = dd->ipath_pd[i];
 
@@ -624,6 +651,12 @@ static int handle_hdrq_full(struct ipath
 			wmb();
 			wake_up_interruptible(&pd->port_wait);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return chkerrpkts;
@@ -654,10 +687,21 @@ static int handle_errors(struct ipath_de
 		dd->ipath_f_handle_hwerrors(dd, msg, sizeof msg);
 	} else {
 		u64 mask;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (log_idx = 0; log_idx < IPATH_EEP_LOG_CNT; ++log_idx) {
 			mask = dd->ipath_eep_st_masks[log_idx].errs_to_log;
 			if (errs & mask)
 				ipath_inc_eeprom_err(dd, log_idx, 1);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
@@ -1036,6 +1080,11 @@ static void handle_urcv(struct ipath_dev
 		 dd->ipath_i_rcvavail_mask) |
 		((istat >> dd->ipath_i_rcvurg_shift) &
 		 dd->ipath_i_rcvurg_mask);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < dd->ipath_cfgports; i++) {
 		struct ipath_portdata *pd = dd->ipath_pd[i];
 
@@ -1052,6 +1101,12 @@ static void handle_urcv(struct ipath_dev
 				wake_up_interruptible(&pd->port_wait);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (rcvdint) {
 		/* only want to take one interrupt, so turn off the rcv
diff -u -p a/infiniband/hw/ipath/ipath_verbs.c b/infiniband/hw/ipath/ipath_verbs.c
--- a/infiniband/hw/ipath/ipath_verbs.c
+++ b/infiniband/hw/ipath/ipath_verbs.c
@@ -400,6 +400,11 @@ static int ipath_post_one_send(struct ip
 	if (wr->num_sge) {
 		acc = wr->opcode >= IB_WR_RDMA_READ ?
 			IB_ACCESS_LOCAL_WRITE : 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0, j = 0; i < wr->num_sge; i++) {
 			u32 length = wr->sg_list[i].length;
 			int ok;
@@ -412,6 +417,12 @@ static int ipath_post_one_send(struct ip
 				goto bail_inval;
 			wqe->length += length;
 			j++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		wqe->wr.num_sge = j;
 	}
@@ -2298,6 +2309,11 @@ static ssize_t show_stats(struct device
 		      dev->n_other_naks, dev->n_timeouts,
 		      dev->n_rdma_dup_busy, dev->n_piowait, dev->n_unaligned,
 		      dev->n_pkt_drops, dev->n_wqe_errs);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(dev->opstats); i++) {
 		const struct ipath_opcode_stats *si = &dev->opstats[i];
 
@@ -2306,6 +2322,12 @@ static ssize_t show_stats(struct device
 		len += sprintf(buf + len, "%02x %llu/%llu\n", i,
 			       (unsigned long long) si->n_packets,
 			       (unsigned long long) si->n_bytes);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return len;
 }
diff -u -p a/infiniband/hw/ipath/ipath_iba6110.c b/infiniband/hw/ipath/ipath_iba6110.c
--- a/infiniband/hw/ipath/ipath_iba6110.c
+++ b/infiniband/hw/ipath/ipath_iba6110.c
@@ -764,6 +764,11 @@ static void ipath_check_htlink(struct ip
 {
 	u8 linkerr, link_off, i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		link_off = dd->ipath_ht_slave_off + i * 4 + 0xd;
 		if (pci_read_config_byte(dd->pcidev, link_off, &linkerr))
@@ -792,6 +797,12 @@ static void ipath_check_htlink(struct ip
 					 "couldn't be cleared\n",
 					 i, linkerr >> 4);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -836,6 +847,11 @@ static void slave_or_pri_blk(struct ipat
 	 * check both link control registers; clear both HT CRC sets if
 	 * necessary.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		link_off = pos + i * 4 + 0x4;
 		if (pci_read_config_word(pdev, link_off, &linkctrl))
@@ -850,12 +866,23 @@ static void slave_or_pri_blk(struct ipat
 			pci_write_config_word(pdev, link_off,
 					      linkctrl & (0xf << 8));
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
 	 * As with HT CRC bits, same for protocol errors that might occur
 	 * during boot.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		link_off = pos + i * 4 + 0xd;
 		if (pci_read_config_byte(pdev, link_off, &linkerr))
@@ -881,6 +908,12 @@ static void slave_or_pri_blk(struct ipat
 					 "0x%x couldn't be cleared\n",
 					 i, linkerr >> 4);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/*
@@ -1627,12 +1660,23 @@ static int ipath_ht_early_init(struct ip
 	piobuf = (u32 __iomem *) (((char __iomem *)(dd->ipath_kregbase)) +
 				  dd->ipath_piobufbase);
 	pioincr = dd->ipath_palign / sizeof(*piobuf);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dd->ipath_piobcnt2k; i++) {
 		/*
 		 * reasonable word count, just to init pbc
 		 */
 		writel(16, piobuf);
 		piobuf += pioincr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ipath_get_eeprom_info(dd);
diff -u -p a/infiniband/hw/ipath/ipath_qp.c b/infiniband/hw/ipath/ipath_qp.c
--- a/infiniband/hw/ipath/ipath_qp.c
+++ b/infiniband/hw/ipath/ipath_qp.c
@@ -275,12 +275,23 @@ unsigned ipath_free_all_qps(struct ipath
 	u32 n, qp_inuse = 0;
 
 	spin_lock_irqsave(&qpt->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 0; n < qpt->max; n++) {
 		qp = qpt->table[n];
 		qpt->table[n] = NULL;
 
 		for (; qp; qp = qp->next)
 			qp_inuse++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	spin_unlock_irqrestore(&qpt->lock, flags);
 
@@ -1034,9 +1045,20 @@ int ipath_init_qp_table(struct ipath_ibd
 		goto bail;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(idev->qp_table.map); i++) {
 		atomic_set(&idev->qp_table.map[i].n_free, BITS_PER_PAGE);
 		idev->qp_table.map[i].page = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = 0;
diff -u -p a/infiniband/hw/ipath/ipath_user_sdma.c b/infiniband/hw/ipath/ipath_user_sdma.c
--- a/infiniband/hw/ipath/ipath_user_sdma.c
+++ b/infiniband/hw/ipath/ipath_user_sdma.c
@@ -191,7 +191,12 @@ static int ipath_user_sdma_coalesce(cons
 
 	mpage = kmap(page);
 	mpage_save = mpage;
-	for (i = 0; i < niov; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < niov; i++) {
 		int cfur;
 
 		cfur = copy_from_user(mpage,
@@ -203,6 +208,12 @@ static int ipath_user_sdma_coalesce(cons
 
 		mpage += iov[i].iov_len;
 		len += iov[i].iov_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dma_addr = dma_map_page(&dd->pcidev->dev, page, 0, len,
@@ -291,7 +302,12 @@ static int ipath_user_sdma_pin_pages(con
 		goto done;
 	}
 
-	for (j = 0; j < npages; j++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (j = 0; j < npages; j++) {
 		/* map the pages... */
 		const int flen =
 			ipath_user_sdma_page_length(addr, tlen);
@@ -312,6 +328,12 @@ static int ipath_user_sdma_pin_pages(con
 		pkt->naddr++;
 		addr += flen;
 		tlen -= flen;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 done:
@@ -327,6 +349,11 @@ static int ipath_user_sdma_pin_pkt(const
 	int ret = 0;
 	unsigned long idx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < niov; idx++) {
 		const int npages = ipath_user_sdma_num_pages(iov + idx);
 		const unsigned long addr = (unsigned long) iov[idx].iov_base;
@@ -336,6 +363,12 @@ static int ipath_user_sdma_pin_pkt(const
 						npages);
 		if (ret < 0)
 			goto free_pkt;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	goto done;
@@ -737,6 +770,11 @@ static int ipath_user_sdma_push_pkts(str
 		if (pkt->naddr > ipath_sdma_descq_freecnt(dd))
 			goto unlock_check_tail;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < pkt->naddr; i++) {
 			ipath_user_sdma_send_frag(dd, pkt, i, ofs, tail);
 			ofs += pkt->addr[i].length >> 2;
@@ -745,6 +783,12 @@ static int ipath_user_sdma_push_pkts(str
 				tail = 0;
 				++dd->ipath_sdma_generation;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if ((ofs<<2) > dd->ipath_ibmaxlen) {
@@ -760,11 +804,22 @@ static int ipath_user_sdma_push_pkts(str
 		 * part of a large buffer packet.
 		 */
 		if (ofs >= IPATH_SMALLBUF_DWORDS) {
-			for (i = 0; i < pkt->naddr; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (i = 0; i < pkt->naddr; i++) {
 				dd->ipath_sdma_descq[dtail].qw[0] |=
 					cpu_to_le64(1ULL << 14);
 				if (++dtail == dd->ipath_sdma_descq_cnt)
 					dtail = 0;
+					if (_cur < timeout) {
+				rdstcll(_cur);
+					}
+					else {
+				break;
+					}
 			}
 		}
 
diff -u -p a/infiniband/hw/ipath/ipath_cq.c b/infiniband/hw/ipath/ipath_cq.c
--- a/infiniband/hw/ipath/ipath_cq.c
+++ b/infiniband/hw/ipath/ipath_cq.c
@@ -425,7 +425,12 @@ int ipath_resize_cq(struct ib_cq *ibcq,
 		ret = -EINVAL;
 		goto bail_unlock;
 	}
-	for (n = 0; tail != head; n++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (n = 0; tail != head; n++) {
 		if (cq->ip)
 			wc->uqueue[n] = old_wc->uqueue[tail];
 		else
@@ -434,6 +439,12 @@ int ipath_resize_cq(struct ib_cq *ibcq,
 			tail = 0;
 		else
 			tail++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	cq->ibcq.cqe = cqe;
 	wc->head = n;
diff -u -p a/infiniband/hw/ipath/ipath_mad.c b/infiniband/hw/ipath/ipath_mad.c
--- a/infiniband/hw/ipath/ipath_mad.c
+++ b/infiniband/hw/ipath/ipath_mad.c
@@ -638,6 +638,11 @@ static int rm_pkey(struct ipath_devdata
 	int i;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(dd->ipath_pkeys); i++) {
 		if (dd->ipath_pkeys[i] != key)
 			continue;
@@ -647,6 +652,12 @@ static int rm_pkey(struct ipath_devdata
 			goto bail;
 		}
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = 0;
@@ -676,6 +687,11 @@ static int add_pkey(struct ipath_devdata
 	}
 
 	/* Look for an empty slot or a matching PKEY. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(dd->ipath_pkeys); i++) {
 		if (!dd->ipath_pkeys[i]) {
 			any++;
@@ -700,11 +716,22 @@ static int add_pkey(struct ipath_devdata
 			ret = -EEXIST;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!any) {
 		ret = -EBUSY;
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(dd->ipath_pkeys); i++) {
 		if (!dd->ipath_pkeys[i] &&
 		    atomic_inc_return(&dd->ipath_pkeyrefs[i]) == 1) {
@@ -714,6 +741,12 @@ static int add_pkey(struct ipath_devdata
 			ret = 1;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = -EBUSY;
 
@@ -735,6 +768,11 @@ static int set_pkeys(struct ipath_devdat
 	/* always a kernel port, no locking needed */
 	pd = dd->ipath_pd[0];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(pd->port_pkeys); i++) {
 		u16 key = pkeys[i];
 		u16 okey = pd->port_pkeys[i];
@@ -756,6 +794,12 @@ static int set_pkeys(struct ipath_devdat
 				changed |= ret;
 		}
 		pd->port_pkeys[i] = key;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (changed) {
 		u64 pkey;
diff -u -p a/infiniband/hw/ipath/ipath_mr.c b/infiniband/hw/ipath/ipath_mr.c
--- a/infiniband/hw/ipath/ipath_mr.c
+++ b/infiniband/hw/ipath/ipath_mr.c
@@ -154,6 +154,11 @@ struct ib_mr *ipath_reg_phys_mr(struct i
 
 	m = 0;
 	n = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_phys_buf; i++) {
 		mr->mr.map[m]->segs[n].vaddr = (void *) buffer_list[i].addr;
 		mr->mr.map[m]->segs[n].length = buffer_list[i].size;
@@ -163,6 +168,12 @@ struct ib_mr *ipath_reg_phys_mr(struct i
 			m++;
 			n = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = &mr->ibmr;
@@ -225,6 +236,11 @@ struct ib_mr *ipath_reg_user_mr(struct i
 	m = 0;
 	n = 0;
 	list_for_each_entry(chunk, &umem->chunk_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < chunk->nents; i++) {
 			void *vaddr;
 
@@ -240,6 +256,12 @@ struct ib_mr *ipath_reg_user_mr(struct i
 				m++;
 				n = 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	ret = &mr->ibmr;
@@ -372,6 +394,11 @@ int ipath_map_phys_fmr(struct ib_fmr *ib
 	m = 0;
 	n = 0;
 	ps = 1 << fmr->page_shift;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < list_len; i++) {
 		fmr->mr.map[m]->segs[n].vaddr = (void *) page_list[i];
 		fmr->mr.map[m]->segs[n].length = ps;
@@ -379,6 +406,12 @@ int ipath_map_phys_fmr(struct ib_fmr *ib
 			m++;
 			n = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&rkt->lock, flags);
 	ret = 0;
diff -u -p a/infiniband/hw/ipath/ipath_ruc.c b/infiniband/hw/ipath/ipath_ruc.c
--- a/infiniband/hw/ipath/ipath_ruc.c
+++ b/infiniband/hw/ipath/ipath_ruc.c
@@ -127,6 +127,11 @@ int ipath_init_sge(struct ipath_qp *qp,
 	struct ib_wc wc;
 
 	*lengthp = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = j = 0; i < wqe->num_sge; i++) {
 		if (wqe->sg_list[i].length == 0)
 			continue;
@@ -136,6 +141,12 @@ int ipath_init_sge(struct ipath_qp *qp,
 			goto bad_lkey;
 		*lengthp += wqe->sg_list[i].length;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ss->num_sge = j;
 	ret = 1;
diff -u -p a/infiniband/hw/ipath/ipath_sysfs.c b/infiniband/hw/ipath/ipath_sysfs.c
--- a/infiniband/hw/ipath/ipath_sysfs.c
+++ b/infiniband/hw/ipath/ipath_sysfs.c
@@ -311,10 +311,21 @@ static ssize_t store_guid(struct device
 
 	ng = (u8 *) &new_guid;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		if (guid[i] > 0xff)
 			goto invalid;
 		ng[i] = guid[i];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (new_guid == 0)
@@ -729,10 +740,21 @@ static ssize_t show_logged_errs(struct d
 		return -ENXIO;
 
 	count = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < IPATH_EEP_LOG_CNT; ++idx) {
 		count += scnprintf(buf + count, PAGE_SIZE - count, "%d%c",
 			dd->ipath_eep_st_errs[idx],
 			idx == (IPATH_EEP_LOG_CNT - 1) ? '\n' : ' ');
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return count;
diff -u -p a/infiniband/hw/qib/qib_user_pages.c b/infiniband/hw/qib/qib_user_pages.c
--- a/infiniband/hw/qib/qib_user_pages.c
+++ b/infiniband/hw/qib/qib_user_pages.c
@@ -41,10 +41,21 @@ static void __qib_release_user_pages(str
 {
 	size_t i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_pages; i++) {
 		if (dirty)
 			set_page_dirty_lock(p[i]);
 		put_page(p[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -65,13 +76,24 @@ static int __qib_get_user_pages(unsigned
 		goto bail;
 	}
 
-	for (got = 0; got < num_pages; got += ret) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (got = 0; got < num_pages; got += ret) {
 		ret = get_user_pages(current, current->mm,
 				     start_page + got * PAGE_SIZE,
 				     num_pages - got, 1, 1,
 				     p + got, vma);
 		if (ret < 0)
 			goto bail_release;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	current->mm->pinned_vm += num_pages;
diff -u -p a/infiniband/hw/qib/qib_ruc.c b/infiniband/hw/qib/qib_ruc.c
--- a/infiniband/hw/qib/qib_ruc.c
+++ b/infiniband/hw/qib/qib_ruc.c
@@ -91,6 +91,11 @@ static int qib_init_sge(struct qib_qp *q
 	ss = &qp->r_sge;
 	ss->sg_list = qp->r_sg_list;
 	qp->r_len = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = j = 0; i < wqe->num_sge; i++) {
 		if (wqe->sg_list[i].length == 0)
 			continue;
@@ -100,6 +105,12 @@ static int qib_init_sge(struct qib_qp *q
 			goto bad_lkey;
 		qp->r_len += wqe->sg_list[i].length;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ss->num_sge = j;
 	ss->total_len = qp->r_len;
@@ -779,10 +790,21 @@ void qib_send_complete(struct qib_qp *qp
 	if (!(ib_qib_state_ops[qp->state] & QIB_PROCESS_OR_FLUSH_SEND))
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < wqe->wr.num_sge; i++) {
 		struct qib_sge *sge = &wqe->sg_list[i];
 
 		atomic_dec(&sge->mr->refcount);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (qp->ibqp.qp_type == IB_QPT_UD ||
 	    qp->ibqp.qp_type == IB_QPT_SMI ||
diff -u -p a/infiniband/hw/qib/qib_iba7220.c b/infiniband/hw/qib/qib_iba7220.c
--- a/infiniband/hw/qib/qib_iba7220.c
+++ b/infiniband/hw/qib/qib_iba7220.c
@@ -842,10 +842,21 @@ static void qib_decode_7220_sdma_errs(st
 	int i;
 	size_t bidx = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(errs); i++) {
 		if (err & errs[i].err)
 			bidx += scnprintf(buf + bidx, blen - bidx,
 					 "%s ", errs[i].msg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -1985,12 +1996,23 @@ static irqreturn_t qib_7220intr(int irq,
 	if (ctxtrbits) {
 		rmask = (1ULL << QLOGIC_IB_I_RCVAVAIL_SHIFT) |
 			(1ULL << QLOGIC_IB_I_RCVURG_SHIFT);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dd->first_user_ctxt; i++) {
 			if (ctxtrbits & rmask) {
 				ctxtrbits &= ~rmask;
 				qib_kreceive(dd->rcd[i], NULL, NULL);
 			}
 			rmask <<= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (ctxtrbits) {
 			ctxtrbits =
@@ -2120,6 +2142,11 @@ static int qib_setup_7220_reset(struct q
 	writeq(val, &dd->kregbase[kr_control]);
 	mb(); /* prevent compiler reordering around actual reset */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i <= 5; i++) {
 		/*
 		 * Allow MBIST, etc. to complete; longer on each retry.
@@ -2140,6 +2167,12 @@ static int qib_setup_7220_reset(struct q
 			ret = qib_reinit_intr(dd);
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0; /* failed */
 
@@ -2820,10 +2853,21 @@ static void rcvctrl_7220_mod(struct qib_
 		} else {
 			unsigned i;
 
-			for (i = 0; i < dd->cfgctxts; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (i = 0; i < dd->cfgctxts; i++) {
 				qib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr,
 						    i, 0);
 				qib_write_kreg_ctxt(dd, kr_rcvhdraddr, i, 0);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
@@ -2874,11 +2918,22 @@ static void sendctrl_7220_mod(struct qib
 		tmp_dd_sendctrl &=
 			~(SYM_MASK(SendCtrl, SPioEnable) |
 			  SYM_MASK(SendCtrl, SendBufAvailUpd));
-		for (i = 0; i < last; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < last; i++) {
 			qib_write_kreg(dd, kr_sendctrl,
 				       tmp_dd_sendctrl |
 				       SYM_MASK(SendCtrl, Disarm) | i);
 			qib_write_kreg(dd, kr_scratch, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -3155,6 +3210,11 @@ static void init_7220_cntrnames(struct q
 	int i, j = 0;
 	char *s;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, s = (char *)cntr7220names; s && j <= dd->cfgctxts;
 	     i++) {
 		/* we always have at least one counter before the egrovfl */
@@ -3163,6 +3223,12 @@ static void init_7220_cntrnames(struct q
 		s = strchr(s + 1, '\n');
 		if (s && j)
 			j++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	dd->cspec->ncntrs = i;
 	if (!s)
@@ -3245,6 +3311,11 @@ static u32 qib_read_7220portcntrs(struct
 			goto done;
 		}
 		*cntrp = cntr;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dd->cspec->nportcntrs; i++) {
 			if (portcntr7220indices[i] & _PORT_VIRT_FLAG)
 				*cntr++ = qib_portcntr_7220(ppd,
@@ -3253,6 +3324,12 @@ static u32 qib_read_7220portcntrs(struct
 			else
 				*cntr++ = read_7220_creg32(dd,
 					   portcntr7220indices[i]);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 done:
@@ -3459,15 +3536,37 @@ static void autoneg_7220_send(struct qib
 	hcnt = ARRAY_SIZE(hdr);
 	if (!swapped) {
 		/* for maintainability, do it at runtime */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < hcnt; i++) {
 			dw = (__force u32) cpu_to_be32(hdr[i]);
 			hdr[i] = dw;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dcnt; i++) {
 			dw = (__force u32) cpu_to_be32(madpayload_start[i]);
 			madpayload_start[i] = dw;
 			dw = (__force u32) cpu_to_be32(madpayload_done[i]);
 			madpayload_done[i] = dw;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		swapped = 1;
 	}
diff -u -p a/infiniband/hw/qib/qib_cq.c b/infiniband/hw/qib/qib_cq.c
--- a/infiniband/hw/qib/qib_cq.c
+++ b/infiniband/hw/qib/qib_cq.c
@@ -432,7 +432,12 @@ int qib_resize_cq(struct ib_cq *ibcq, in
 		ret = -EINVAL;
 		goto bail_unlock;
 	}
-	for (n = 0; tail != head; n++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (n = 0; tail != head; n++) {
 		if (cq->ip)
 			wc->uqueue[n] = old_wc->uqueue[tail];
 		else
@@ -441,6 +446,12 @@ int qib_resize_cq(struct ib_cq *ibcq, in
 			tail = 0;
 		else
 			tail++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	cq->ibcq.cqe = cqe;
 	wc->head = n;
diff -u -p a/infiniband/hw/qib/qib_user_sdma.c b/infiniband/hw/qib/qib_user_sdma.c
--- a/infiniband/hw/qib/qib_user_sdma.c
+++ b/infiniband/hw/qib/qib_user_sdma.c
@@ -191,7 +191,12 @@ static int qib_user_sdma_coalesce(const
 
 	mpage = kmap(page);
 	mpage_save = mpage;
-	for (i = 0; i < niov; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < niov; i++) {
 		int cfur;
 
 		cfur = copy_from_user(mpage,
@@ -203,6 +208,12 @@ static int qib_user_sdma_coalesce(const
 
 		mpage += iov[i].iov_len;
 		len += iov[i].iov_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dma_addr = dma_map_page(&dd->pcidev->dev, page, 0, len,
@@ -296,7 +307,12 @@ static int qib_user_sdma_pin_pages(const
 		goto done;
 	}
 
-	for (j = 0; j < npages; j++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (j = 0; j < npages; j++) {
 		/* map the pages... */
 		const int flen = qib_user_sdma_page_length(addr, tlen);
 		dma_addr_t dma_addr =
@@ -315,6 +331,12 @@ static int qib_user_sdma_pin_pages(const
 		pkt->naddr++;
 		addr += flen;
 		tlen -= flen;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 done:
@@ -330,6 +352,11 @@ static int qib_user_sdma_pin_pkt(const s
 	int ret = 0;
 	unsigned long idx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < niov; idx++) {
 		const int npages = qib_user_sdma_num_pages(iov + idx);
 		const unsigned long addr = (unsigned long) iov[idx].iov_base;
@@ -338,6 +365,12 @@ static int qib_user_sdma_pin_pkt(const s
 					      iov[idx].iov_len, npages);
 		if (ret < 0)
 			goto free_pkt;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	goto done;
@@ -752,6 +785,11 @@ static int qib_user_sdma_push_pkts(struc
 		if (pkt->naddr > qib_sdma_descq_freecnt(ppd))
 			goto unlock_check_tail;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < pkt->naddr; i++) {
 			qib_user_sdma_send_frag(ppd, pkt, i, ofs, tail);
 			ofs += pkt->addr[i].length >> 2;
@@ -760,6 +798,12 @@ static int qib_user_sdma_push_pkts(struc
 				tail = 0;
 				++ppd->sdma_generation;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if ((ofs << 2) > ppd->ibmaxlen) {
@@ -773,11 +817,22 @@ static int qib_user_sdma_push_pkts(struc
 		 * part of a large buffer packet.
 		 */
 		if (ofs > dd->piosize2kmax_dwords) {
-			for (i = 0; i < pkt->naddr; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (i = 0; i < pkt->naddr; i++) {
 				ppd->sdma_descq[dtail].qw[0] |=
 					cpu_to_le64(1ULL << 14);
 				if (++dtail == ppd->sdma_descq_cnt)
 					dtail = 0;
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
 			}
 		}
 
diff -u -p a/infiniband/hw/qib/qib_eeprom.c b/infiniband/hw/qib/qib_eeprom.c
--- a/infiniband/hw/qib/qib_eeprom.c
+++ b/infiniband/hw/qib/qib_eeprom.c
@@ -354,6 +354,11 @@ int qib_update_eeprom_log(struct qib_dev
 	}
 	hi_water = 0;
 	spin_lock_irqsave(&dd->eep_st_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < QIB_EEP_LOG_CNT; ++idx) {
 		int new_val = dd->eep_st_new_errs[idx];
 		if (new_val) {
@@ -380,6 +385,12 @@ int qib_update_eeprom_log(struct qib_dev
 			dd->eep_st_errs[idx] = new_val;
 			dd->eep_st_new_errs[idx] = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * Now update active-time. We would like to round to the nearest hour
diff -u -p a/infiniband/hw/qib/qib_sysfs.c b/infiniband/hw/qib/qib_sysfs.c
--- a/infiniband/hw/qib/qib_sysfs.c
+++ b/infiniband/hw/qib/qib_sysfs.c
@@ -563,10 +563,21 @@ static ssize_t show_logged_errs(struct d
 		return -ENXIO;
 
 	count = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < QIB_EEP_LOG_CNT; ++idx) {
 		count += scnprintf(buf + count, PAGE_SIZE - count, "%d%c",
 				   dd->eep_st_errs[idx],
 				   idx == (QIB_EEP_LOG_CNT - 1) ? '\n' : ' ');
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return count;
@@ -698,10 +709,21 @@ int qib_verbs_register_sysfs(struct qib_
 	struct ib_device *dev = &dd->verbs_dev.ibdev;
 	int i, ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(qib_attributes); ++i) {
 		ret = device_create_file(&dev->dev, qib_attributes[i]);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -715,9 +737,20 @@ void qib_verbs_unregister_sysfs(struct q
 	struct qib_pportdata *ppd;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dd->num_pports; i++) {
 		ppd = &dd->pport[i];
 		kobject_put(&ppd->pport_kobj);
 		kobject_put(&ppd->sl2vl_kobj);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
diff -u -p a/infiniband/hw/qib/qib_mad.c b/infiniband/hw/qib/qib_mad.c
--- a/infiniband/hw/qib/qib_mad.c
+++ b/infiniband/hw/qib/qib_mad.c
@@ -874,6 +874,11 @@ static int rm_pkey(struct qib_pportdata
 	int i;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {
 		if (ppd->pkeys[i] != key)
 			continue;
@@ -883,6 +888,12 @@ static int rm_pkey(struct qib_pportdata
 			goto bail;
 		}
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = 0;
@@ -912,6 +923,11 @@ static int add_pkey(struct qib_pportdata
 	}
 
 	/* Look for an empty slot or a matching PKEY. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {
 		if (!ppd->pkeys[i]) {
 			any++;
@@ -936,11 +952,22 @@ static int add_pkey(struct qib_pportdata
 			ret = -EEXIST;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!any) {
 		ret = -EBUSY;
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {
 		if (!ppd->pkeys[i] &&
 		    atomic_inc_return(&ppd->pkeyrefs[i]) == 1) {
@@ -949,6 +976,12 @@ static int add_pkey(struct qib_pportdata
 			ret = 1;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = -EBUSY;
 
@@ -978,6 +1011,11 @@ static int set_pkeys(struct qib_devdata
 	ppd = dd->pport + (port - 1);
 	rcd = dd->rcd[ppd->hw_pidx];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(rcd->pkeys); i++) {
 		u16 key = pkeys[i];
 		u16 okey = rcd->pkeys[i];
@@ -999,6 +1037,12 @@ static int set_pkeys(struct qib_devdata
 				changed |= ret;
 		}
 		rcd->pkeys[i] = key;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (changed) {
 		struct ib_event event;
@@ -1061,9 +1105,20 @@ static int subn_set_sl_to_vl(struct ib_s
 		return reply(smp);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(ibp->sl_to_vl); i += 2, p++) {
 		ibp->sl_to_vl[i] = *p >> 4;
 		ibp->sl_to_vl[i + 1] = *p & 0xF;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	qib_set_uevent_bits(ppd_from_ibp(to_iport(ibdev, port)),
 			    _QIB_EVENT_SL2VL_CHANGE_BIT);
@@ -2119,6 +2174,11 @@ int qib_create_agents(struct qib_ibdev *
 	int p;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = 0; p < dd->num_pports; p++) {
 		ibp = &dd->pport[p].ibport_data;
 		agent = ib_register_mad_agent(&dev->ibdev, p + 1, IB_QPT_SMI,
@@ -2139,11 +2199,22 @@ int qib_create_agents(struct qib_ibdev *
 		add_timer(&dd->pport[p].cong_stats.timer);
 
 		ibp->send_agent = agent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
 
 err:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = 0; p < dd->num_pports; p++) {
 		ibp = &dd->pport[p].ibport_data;
 		if (ibp->send_agent) {
@@ -2151,6 +2222,12 @@ err:
 			ibp->send_agent = NULL;
 			ib_unregister_mad_agent(agent);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
@@ -2163,6 +2240,11 @@ void qib_free_agents(struct qib_ibdev *d
 	struct qib_ibport *ibp;
 	int p;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = 0; p < dd->num_pports; p++) {
 		ibp = &dd->pport[p].ibport_data;
 		if (ibp->send_agent) {
@@ -2176,5 +2258,11 @@ void qib_free_agents(struct qib_ibdev *d
 		}
 		if (dd->pport[p].cong_stats.timer.data)
 			del_timer_sync(&dd->pport[p].cong_stats.timer);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
diff -u -p a/infiniband/hw/qib/qib_driver.c b/infiniband/hw/qib/qib_driver.c
--- a/infiniband/hw/qib/qib_driver.c
+++ b/infiniband/hw/qib/qib_driver.c
@@ -133,11 +133,22 @@ int qib_count_units(int *npresentp, int
 		nunits++;
 		if ((dd->flags & QIB_PRESENT) && dd->kregbase)
 			npresent++;
-		for (pidx = 0; pidx < dd->num_pports; ++pidx) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 			ppd = dd->pport + pidx;
 			if (ppd->lid && (ppd->lflags & (QIBL_LINKINIT |
 					 QIBL_LINKARMED | QIBL_LINKACTIVE)))
 				nup++;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 	}
 
@@ -469,6 +480,11 @@ u32 qib_kreceive(struct qib_ctxtdata *rc
 		smp_rmb();  /* prevent speculative reads of dma'ed hdrq */
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last = 0, i = 1; !last; i += !last) {
 		hdr = dd->f_get_msgheader(dd, rhf_addr);
 		eflags = qib_hdrget_err_flags(rhf_addr);
@@ -542,6 +558,12 @@ move_along:
 			dd->f_update_usrhead(rcd, lval, updegr, etail, i);
 			updegr = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * Notify qib_destroy_qp() if it is waiting
@@ -769,16 +791,33 @@ int qib_reset_device(int unit)
 	}
 
 	spin_lock_irqsave(&dd->uctxt_lock, flags);
-	if (dd->rcd)
-		for (i = dd->first_user_ctxt; i < dd->cfgctxts; i++) {
-			if (!dd->rcd[i] || !dd->rcd[i]->cnt)
-				continue;
-			spin_unlock_irqrestore(&dd->uctxt_lock, flags);
-			ret = -EBUSY;
-			goto bail;
+	if (dd->rcd) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = dd->first_user_ctxt; i < dd->cfgctxts; i++) {
+				if (!dd->rcd[i] || !dd->rcd[i]->cnt)
+						continue;
+				spin_unlock_irqrestore(&dd->uctxt_lock, flags);
+				ret = -EBUSY;
+				goto bail;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
+			}
 		}
 	spin_unlock_irqrestore(&dd->uctxt_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		ppd = dd->pport + pidx;
 		if (atomic_read(&ppd->led_override_timer_active)) {
@@ -792,6 +831,12 @@ int qib_reset_device(int unit)
 		dd->f_setextled(ppd, 0);
 		if (dd->flags & QIB_HAS_SEND_DMA)
 			qib_teardown_sdma(ppd);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+		}
 	}
 
 	ret = dd->f_reset(dd);
diff -u -p a/infiniband/hw/qib/qib_keys.c b/infiniband/hw/qib/qib_keys.c
--- a/infiniband/hw/qib/qib_keys.c
+++ b/infiniband/hw/qib/qib_keys.c
@@ -344,6 +344,11 @@ int qib_fast_reg_mr(struct qib_qp *qp, s
 	page_list = wr->wr.fast_reg.page_list->page_list;
 	m = 0;
 	n = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < wr->wr.fast_reg.page_list_len; i++) {
 		mr->map[m]->segs[n].vaddr = (void *) page_list[i];
 		mr->map[m]->segs[n].length = ps;
@@ -351,6 +356,12 @@ int qib_fast_reg_mr(struct qib_qp *qp, s
 			m++;
 			n = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = 0;
diff -u -p a/infiniband/hw/qib/qib_sd7220.c b/infiniband/hw/qib/qib_sd7220.c
--- a/infiniband/hw/qib/qib_sd7220.c
+++ b/infiniband/hw/qib/qib_sd7220.c
@@ -337,7 +337,12 @@ static void qib_sd_trimdone_monitor(stru
 
 	baduns = 0;
 
-	for (chn = 3; chn >= 0; --chn) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (chn = 3; chn >= 0; --chn) {
 		/* Read CTRL reg for each channel to check TRIMDONE */
 		ret = qib_sd7220_reg_mod(dd, IB_7220_SERDES,
 			IB_CTRL2(chn), 0, 0);
@@ -365,7 +370,18 @@ static void qib_sd_trimdone_monitor(stru
 				qib_dev_err(dd,
 					"Err on TRIMDONE rewrite1\n");
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (chn = 3; chn >= 0; --chn) {
 		/* Read CTRL reg for each channel to check TRIMDONE */
 		if (baduns & (1 << chn)) {
@@ -379,6 +395,12 @@ static void qib_sd_trimdone_monitor(stru
 					"TRIMDONE, chn %d (%s)\n",
 					chn, where);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -895,9 +917,20 @@ static int qib_sd7220_prog_vfy(struct qi
 			sofar = -1;
 			break;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (idx = 0; idx < cnt; ++idx) {
 			if (readback[idx] != img[idx+sofar])
 				++errors;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 		}
 		sofar += cnt;
 	}
@@ -1061,19 +1094,41 @@ static int qib_sd_setvals(struct qib_dev
 	 * Iterate down table within loop for each register to store.
 	 */
 	dds_reg_map = DDS_REG_MAP;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < NUM_DDS_REGS; ++idx) {
 		data = ((dds_reg_map & 0xF) << 4) | TX_FAST_ELT;
 		writeq(data, iaddr + idx);
 		mmiowb();
 		qib_read_kreg32(dd, kr_scratch);
 		dds_reg_map >>= 4;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (midx = 0; midx < DDS_ROWS; ++midx) {
 			u64 __iomem *daddr = taddr + ((midx << 4) + idx);
 			data = dds_init_vals[midx].reg_vals[idx];
 			writeq(data, daddr);
 			mmiowb();
 			qib_read_kreg32(dd, kr_scratch);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		} /* End inner for (vals for this reg, each row) */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} /* end outer for (regs to be stored) */
 
 	/*
@@ -1085,6 +1140,11 @@ static int qib_sd_setvals(struct qib_dev
 	min_idx = idx; /* RXEQ indices pick up where DDS left off */
 	taddr += 0x100; /* RXEQ data is in second half of table */
 	/* Iterate through RXEQ register addresses */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < RXEQ_ROWS; ++idx) {
 		int didx; /* "destination" */
 		int vidx;
@@ -1096,11 +1156,28 @@ static int qib_sd_setvals(struct qib_dev
 		mmiowb();
 		qib_read_kreg32(dd, kr_scratch);
 		/* Iterate through RXEQ values */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (vidx = 0; vidx < 4; vidx++) {
 			data = rxeq_init_vals[idx].rdata[vidx];
 			writeq(data, taddr + (vidx << 6) + idx);
 			mmiowb();
 			qib_read_kreg32(dd, kr_scratch);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	} /* end outer for (Reg-writes for RXEQ) */
 	return 0;
diff -u -p a/infiniband/hw/qib/qib_qsfp.c b/infiniband/hw/qib/qib_qsfp.c
--- a/infiniband/hw/qib/qib_qsfp.c
+++ b/infiniband/hw/qib/qib_qsfp.c
@@ -543,9 +543,20 @@ int qib_qsfp_dump(struct qib_pportdata *
 		ret = qsfp_read(ppd, bidx, bin_buff, QSFP_DUMP_CHUNK);
 		if (ret < 0)
 			goto bail;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (iidx = 0; iidx < ret; ++iidx) {
 			sofar += scnprintf(buf + sofar, len-sofar, " %02X",
 				bin_buff[iidx]);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 		}
 		sofar += scnprintf(buf + sofar, len - sofar, "\n");
 		bidx += QSFP_DUMP_CHUNK;
diff -u -p a/infiniband/hw/qib/qib_twsi.c b/infiniband/hw/qib/qib_twsi.c
--- a/infiniband/hw/qib/qib_twsi.c
+++ b/infiniband/hw/qib/qib_twsi.c
@@ -175,11 +175,22 @@ static int rd_byte(struct qib_devdata *d
 
 	data = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit_cntr = 7; bit_cntr >= 0; --bit_cntr) {
 		data <<= 1;
 		scl_out(dd, 1);
 		data |= sda_in(dd, 0);
 		scl_out(dd, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (last) {
 		scl_out(dd, 1);
@@ -205,11 +216,22 @@ static int wr_byte(struct qib_devdata *d
 	int bit_cntr;
 	u8 bit;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit_cntr = 7; bit_cntr >= 0; bit_cntr--) {
 		bit = (data >> bit_cntr) & 1;
 		sda_out(dd, bit);
 		scl_out(dd, 1);
 		scl_out(dd, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (!i2c_ackrcv(dd)) ? 1 : 0;
 }
diff -u -p a/infiniband/hw/qib/qib_file_ops.c b/infiniband/hw/qib/qib_file_ops.c
--- a/infiniband/hw/qib/qib_file_ops.c
+++ b/infiniband/hw/qib/qib_file_ops.c
@@ -505,6 +505,11 @@ static int qib_tid_free(struct qib_ctxtd
 		/* just in case size changes in future */
 		limit = tidcnt;
 	tid = find_first_bit(tidmap, limit);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; tid < limit; tid++) {
 		/*
 		 * small optimization; if we detect a run of 3 or so without
@@ -533,6 +538,12 @@ static int qib_tid_free(struct qib_ctxtd
 				       PCI_DMA_FROMDEVICE);
 			qib_release_user_pages(&p, 1);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 done:
 	return ret;
@@ -580,6 +591,11 @@ static int qib_set_part_key(struct qib_c
 	 */
 	key |= 0x8000;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(rcd->pkeys); i++) {
 		if (!rcd->pkeys[i] && pidx == -1)
 			pidx = i;
@@ -587,11 +603,22 @@ static int qib_set_part_key(struct qib_c
 			ret = -EEXIST;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (pidx == -1) {
 		ret = -EBUSY;
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (any = i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {
 		if (!ppd->pkeys[i]) {
 			any++;
@@ -621,11 +648,22 @@ static int qib_set_part_key(struct qib_c
 			ret = -EEXIST;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!any) {
 		ret = -EBUSY;
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (any = i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {
 		if (!ppd->pkeys[i] &&
 		    atomic_inc_return(&ppd->pkeyrefs[i]) == 1) {
@@ -635,6 +673,12 @@ static int qib_set_part_key(struct qib_c
 			ret = 0;
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = -EBUSY;
 
@@ -694,9 +738,19 @@ static void qib_clean_part_key(struct qi
 		((u64) ppd->pkeys[2] << 32) |
 		((u64) ppd->pkeys[3] << 48);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(rcd->pkeys); i++) {
 		if (!rcd->pkeys[i])
 			continue;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < ARRAY_SIZE(ppd->pkeys); j++) {
 			/* check for match independent of the global bit */
 			if ((ppd->pkeys[j] & 0x7fff) !=
@@ -707,8 +761,20 @@ static void qib_clean_part_key(struct qi
 				pchanged++;
 			}
 			break;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		rcd->pkeys[i] = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (pchanged)
 		(void) ppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_PKEYS, 0);
@@ -866,12 +932,23 @@ static int mmap_rcvegrbufs(struct vm_are
 
 	start = vma->vm_start;
 
-	for (i = 0; i < rcd->rcvegrbuf_chunks; i++, start += size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < rcd->rcvegrbuf_chunks; i++, start += size) {
 		pfn = virt_to_phys(rcd->rcvegrbuf[i]) >> PAGE_SHIFT;
 		ret = remap_pfn_range(vma, start, pfn, size,
 				      vma->vm_page_prot);
 		if (ret < 0)
 			goto bail;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	ret = 0;
 
@@ -1379,6 +1456,11 @@ static int get_a_ctxt(struct file *fp, c
 	if (alg == QIB_PORT_ALG_ACROSS) {
 		unsigned inuse = ~0U;
 		/* find device (with ACTIVE ports) with fewest ctxts in use */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (ndev = 0; ndev < devmax; ndev++) {
 			struct qib_devdata *dd = qib_lookup(ndev);
 			unsigned cused = 0, cfree = 0, pusable = 0;
@@ -1403,12 +1485,23 @@ static int get_a_ctxt(struct file *fp, c
 				udd = dd;
 				inuse = cused;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (udd) {
 			ret = choose_port_ctxt(fp, udd, port, uinfo);
 			goto done;
 		}
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (ndev = 0; ndev < devmax; ndev++) {
 			struct qib_devdata *dd = qib_lookup(ndev);
 			if (dd) {
@@ -1418,6 +1511,12 @@ static int get_a_ctxt(struct file *fp, c
 				if (ret == -EBUSY)
 					dusable++;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 	ret = dusable ? -EBUSY : -ENETDOWN;
@@ -1434,12 +1533,22 @@ static int find_shared_ctxt(struct file
 
 	devmax = qib_count_units(NULL, NULL);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ndev = 0; ndev < devmax; ndev++) {
 		struct qib_devdata *dd = qib_lookup(ndev);
 
 		/* device portion of usable() */
 		if (!(dd && (dd->flags & QIB_PRESENT) && dd->kregbase))
 			continue;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = dd->first_user_ctxt; i < dd->cfgctxts; i++) {
 			struct qib_ctxtdata *rcd = dd->rcd[i];
 
@@ -1463,6 +1572,18 @@ static int find_shared_ctxt(struct file
 			rcd->active_slaves |= 1 << subctxt_fp(fp);
 			ret = 1;
 			goto done;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -1697,6 +1818,11 @@ static void unlock_expected_tids(struct
 	int ctxt_tidbase = rcd->ctxt * dd->rcvtidcnt;
 	int i, cnt = 0, maxtid = ctxt_tidbase + dd->rcvtidcnt;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ctxt_tidbase; i < maxtid; i++) {
 		struct page *p = dd->pageshadow[i];
 		dma_addr_t phys;
@@ -1711,6 +1837,12 @@ static void unlock_expected_tids(struct
 			       PCI_DMA_FROMDEVICE);
 		qib_release_user_pages(&p, 1);
 		cnt++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1911,6 +2043,11 @@ int qib_set_uevent_bits(struct qib_pport
 	unsigned long flags;
 
 	spin_lock_irqsave(&ppd->dd->uctxt_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ctxt = ppd->dd->first_user_ctxt; ctxt < ppd->dd->cfgctxts;
 	     ctxt++) {
 		rcd = ppd->dd->rcd[ctxt];
@@ -1928,6 +2065,12 @@ int qib_set_uevent_bits(struct qib_pport
 		}
 		ret = 1;
 		break;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	spin_unlock_irqrestore(&ppd->dd->uctxt_lock, flags);
 
@@ -1948,6 +2091,11 @@ static int qib_user_event_ack(struct qib
 {
 	int ret = 0, i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= _QIB_MAX_EVENT_BIT; i++) {
 		if (!test_bit(i, &events))
 			continue;
@@ -1956,6 +2104,12 @@ static int qib_user_event_ack(struct qib
 			ret = disarm_req_delay(rcd);
 		} else
 			clear_bit(i, &rcd->user_event_mask[subctxt]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return ret;
 }
diff -u -p a/infiniband/hw/qib/qib_intr.c b/infiniband/hw/qib/qib_intr.c
--- a/infiniband/hw/qib/qib_intr.c
+++ b/infiniband/hw/qib/qib_intr.c
@@ -194,6 +194,11 @@ void qib_handle_urcv(struct qib_devdata
 	int i;
 
 	spin_lock_irqsave(&dd->uctxt_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = dd->first_user_ctxt; dd->rcd && i < dd->cfgctxts; i++) {
 		if (!(ctxtr & (1ULL << i)))
 			continue;
@@ -210,6 +215,12 @@ void qib_handle_urcv(struct qib_devdata
 			rcd->urgent++;
 			wake_up_interruptible(&rcd->wait);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&dd->uctxt_lock, flags);
 }
diff -u -p a/infiniband/hw/qib/qib_iba6120.c b/infiniband/hw/qib/qib_iba6120.c
--- a/infiniband/hw/qib/qib_iba6120.c
+++ b/infiniband/hw/qib/qib_iba6120.c
@@ -1656,6 +1656,11 @@ static irqreturn_t qib_6120intr(int irq,
 	if (ctxtrbits) {
 		rmask = (1U << QLOGIC_IB_I_RCVAVAIL_SHIFT) |
 			(1U << QLOGIC_IB_I_RCVURG_SHIFT);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dd->first_user_ctxt; i++) {
 			if (ctxtrbits & rmask) {
 				ctxtrbits &= ~rmask;
@@ -1664,6 +1669,12 @@ static irqreturn_t qib_6120intr(int irq,
 						     NULL);
 			}
 			rmask <<= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (crcs) {
 			u32 cntr = dd->cspec->lli_counter;
@@ -1807,6 +1818,11 @@ static int qib_6120_setup_reset(struct q
 	writeq(val, &dd->kregbase[kr_control]);
 	mb(); /* prevent compiler re-ordering around actual reset */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i <= 5; i++) {
 		/*
 		 * Allow MBIST, etc. to complete; longer on each retry.
@@ -1827,6 +1843,12 @@ static int qib_6120_setup_reset(struct q
 			ret = qib_reinit_intr(dd);
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0; /* failed */
 
@@ -2203,11 +2225,22 @@ static void rcvctrl_6120_mod(struct qib_
 		} else {
 			unsigned i;
 
-			for (i = 0; i < dd->cfgctxts; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (i = 0; i < dd->cfgctxts; i++) {
 				qib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr,
 					    i, dd->cspec->dummy_hdrq_phys);
 				qib_write_kreg_ctxt(dd, kr_rcvhdraddr,
 					    i, dd->cspec->dummy_hdrq_phys);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
@@ -2254,10 +2287,21 @@ static void sendctrl_6120_mod(struct qib
 		tmp_dd_sendctrl &=
 			~(SYM_MASK(SendCtrl, PIOEnable) |
 			  SYM_MASK(SendCtrl, PIOBufAvailUpd));
-		for (i = 0; i < last; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < last; i++) {
 			qib_write_kreg(dd, kr_sendctrl, tmp_dd_sendctrl |
 				       SYM_MASK(SendCtrl, Disarm) | i);
 			qib_write_kreg(dd, kr_scratch, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -2506,6 +2550,11 @@ static void init_6120_cntrnames(struct q
 	int i, j = 0;
 	char *s;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, s = (char *)cntr6120names; s && j <= dd->cfgctxts;
 	     i++) {
 		/* we always have at least one counter before the egrovfl */
@@ -2514,6 +2563,12 @@ static void init_6120_cntrnames(struct q
 		s = strchr(s + 1, '\n');
 		if (s && j)
 			j++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	dd->cspec->ncntrs = i;
 	if (!s)
@@ -2592,6 +2647,11 @@ static u32 qib_read_6120portcntrs(struct
 			goto done;
 		}
 		*cntrp = cntr;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dd->cspec->nportcntrs; i++) {
 			if (portcntr6120indices[i] & _PORT_VIRT_FLAG)
 				*cntr++ = qib_portcntr_6120(ppd,
@@ -2600,6 +2660,12 @@ static u32 qib_read_6120portcntrs(struct
 			else
 				*cntr++ = read_6120_creg32(dd,
 					   portcntr6120indices[i]);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 done:
diff -u -p a/infiniband/hw/qib/qib_rc.c b/infiniband/hw/qib/qib_rc.c
--- a/infiniband/hw/qib/qib_rc.c
+++ b/infiniband/hw/qib/qib_rc.c
@@ -1009,10 +1009,21 @@ void qib_rc_send_complete(struct qib_qp
 		if (qib_cmp24(wqe->lpsn, qp->s_sending_psn) >= 0 &&
 		    qib_cmp24(qp->s_sending_psn, qp->s_sending_hpsn) <= 0)
 			break;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wqe->wr.num_sge; i++) {
 			struct qib_sge *sge = &wqe->sg_list[i];
 
 			atomic_dec(&sge->mr->refcount);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* Post a send completion queue entry if requested. */
 		if (!(qp->s_flags & QIB_S_SIGNAL_REQ_WR) ||
@@ -1065,10 +1076,21 @@ static struct qib_swqe *do_rc_completion
 	 */
 	if (qib_cmp24(wqe->lpsn, qp->s_sending_psn) < 0 ||
 	    qib_cmp24(qp->s_sending_psn, qp->s_sending_hpsn) > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wqe->wr.num_sge; i++) {
 			struct qib_sge *sge = &wqe->sg_list[i];
 
 			atomic_dec(&sge->mr->refcount);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* Post a send completion queue entry if requested. */
 		if (!(qp->s_flags & QIB_S_SIGNAL_REQ_WR) ||
diff -u -p a/infiniband/hw/qib/qib_tx.c b/infiniband/hw/qib/qib_tx.c
--- a/infiniband/hw/qib/qib_tx.c
+++ b/infiniband/hw/qib/qib_tx.c
@@ -66,9 +66,20 @@ void qib_disarm_piobufs(struct qib_devda
 
 	last = first + cnt;
 	spin_lock_irqsave(&dd->pioavail_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = first; i < last; i++) {
 		__clear_bit(i, dd->pio_need_disarm);
 		dd->f_sendctrl(dd->pport, QIB_SENDCTRL_DISARM_BUF(i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&dd->pioavail_lock, flags);
 }
@@ -101,11 +112,22 @@ int qib_disarm_piobufs_ifneeded(struct q
 				  &rcd->user_event_mask[i]);
 	}
 	spin_lock_irq(&dd->pioavail_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = rcd->pio_base; i < last; i++) {
 		if (__test_and_clear_bit(i, dd->pio_need_disarm)) {
 			n++;
 			dd->f_sendctrl(rcd->ppd, QIB_SENDCTRL_DISARM_BUF(i));
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irq(&dd->pioavail_lock);
 	return 0;
@@ -116,11 +138,22 @@ static struct qib_pportdata *is_sdma_buf
 	struct qib_pportdata *ppd;
 	unsigned pidx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < dd->num_pports; pidx++) {
 		ppd = dd->pport + pidx;
 		if (i >= ppd->sdma_state.first_sendbuf &&
 		    i < ppd->sdma_state.last_sendbuf)
 			return ppd;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NULL;
 }
@@ -136,6 +169,11 @@ static int find_ctxt(struct qib_devdata
 	int ret = 0;
 
 	spin_lock(&dd->uctxt_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ctxt = dd->first_user_ctxt; ctxt < dd->cfgctxts; ctxt++) {
 		rcd = dd->rcd[ctxt];
 		if (!rcd || bufn < rcd->pio_base ||
@@ -155,6 +193,12 @@ static int find_ctxt(struct qib_devdata
 		}
 		ret = 1;
 		break;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	spin_unlock(&dd->uctxt_lock);
 
@@ -178,6 +222,11 @@ void qib_disarm_piobufs_set(struct qib_d
 	for (i = 0; i < dd->num_pports; i++)
 		pppd[i] = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < cnt; i++) {
 		int which;
 		if (!test_bit(i, mask))
@@ -206,6 +255,12 @@ void qib_disarm_piobufs_set(struct qib_d
 			dd->f_sendctrl(dd->pport, QIB_SENDCTRL_DISARM_BUF(i));
 		}
 		spin_unlock_irqrestore(&dd->pioavail_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* do cancel_sends once per port that had sdma piobufs in error */
@@ -247,6 +302,11 @@ static void update_send_bufs(struct qib_
 	if (!dd->pioavailregs_dma)
 		return;
 	spin_lock_irqsave(&dd->pioavail_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < piobregs; i++) {
 		u64 pchbusy, pchg, piov, pnew;
 
@@ -259,6 +319,12 @@ static void update_send_bufs(struct qib_
 			pnew |= piov & pchbusy;
 			dd->pioavailshadow[i] = pnew;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&dd->pioavail_lock, flags);
 }
@@ -311,6 +377,11 @@ rescan:
 	 * of the remaining armlaunch errors.
 	 */
 	spin_lock_irqsave(&dd->pioavail_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < nbufs; j++, i++) {
 		if (i > last)
 			i = first;
@@ -321,6 +392,12 @@ rescan:
 		/* remember that the buffer can be written to now */
 		__set_bit(i, dd->pio_writing);
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&dd->pioavail_lock, flags);
 
@@ -461,6 +538,11 @@ void qib_cancel_sends(struct qib_pportda
 	 * context is closed after we release the uctxt_lock, but that's
 	 * fairly benign, and safer than nesting the locks.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ctxt = dd->first_user_ctxt; ctxt < dd->cfgctxts; ctxt++) {
 		spin_lock_irqsave(&dd->uctxt_lock, flags);
 		rcd = dd->rcd[ctxt];
@@ -486,6 +568,12 @@ void qib_cancel_sends(struct qib_pportda
 			spin_unlock_irqrestore(&dd->pioavail_lock, flags);
 		} else
 			spin_unlock_irqrestore(&dd->uctxt_lock, flags);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!(dd->flags & QIB_HAS_SEND_DMA))
diff -u -p a/infiniband/hw/qib/qib_mr.c b/infiniband/hw/qib/qib_mr.c
--- a/infiniband/hw/qib/qib_mr.c
+++ b/infiniband/hw/qib/qib_mr.c
@@ -164,6 +164,11 @@ struct ib_mr *qib_reg_phys_mr(struct ib_
 
 	m = 0;
 	n = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_phys_buf; i++) {
 		mr->mr.map[m]->segs[n].vaddr = (void *) buffer_list[i].addr;
 		mr->mr.map[m]->segs[n].length = buffer_list[i].size;
@@ -173,6 +178,12 @@ struct ib_mr *qib_reg_phys_mr(struct ib_
 			m++;
 			n = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = &mr->ibmr;
@@ -236,6 +247,11 @@ struct ib_mr *qib_reg_user_mr(struct ib_
 	m = 0;
 	n = 0;
 	list_for_each_entry(chunk, &umem->chunk_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < chunk->nents; i++) {
 			void *vaddr;
 
@@ -251,6 +267,12 @@ struct ib_mr *qib_reg_user_mr(struct ib_
 				m++;
 				n = 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	ret = &mr->ibmr;
@@ -443,6 +465,11 @@ int qib_map_phys_fmr(struct ib_fmr *ibfm
 	fmr->mr.length = list_len * ps;
 	m = 0;
 	n = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < list_len; i++) {
 		fmr->mr.map[m]->segs[n].vaddr = (void *) page_list[i];
 		fmr->mr.map[m]->segs[n].length = ps;
@@ -450,6 +477,12 @@ int qib_map_phys_fmr(struct ib_fmr *ibfm
 			m++;
 			n = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&rkt->lock, flags);
 	ret = 0;
diff -u -p a/infiniband/hw/qib/qib_verbs.c b/infiniband/hw/qib/qib_verbs.c
--- a/infiniband/hw/qib/qib_verbs.c
+++ b/infiniband/hw/qib/qib_verbs.c
@@ -401,6 +401,11 @@ static int qib_post_one_send(struct qib_
 	if (wr->num_sge) {
 		acc = wr->opcode >= IB_WR_RDMA_READ ?
 			IB_ACCESS_LOCAL_WRITE : 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wr->num_sge; i++) {
 			u32 length = wr->sg_list[i].length;
 			int ok;
@@ -413,6 +418,12 @@ static int qib_post_one_send(struct qib_
 				goto bail_inval_free;
 			wqe->length += length;
 			j++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		wqe->wr.num_sge = j;
 	}
@@ -1027,6 +1038,11 @@ void qib_verbs_sdma_desc_avail(struct qi
 
 	spin_unlock(&dev->pending_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n; i++) {
 		qp = qps[i];
 		spin_lock(&qp->s_lock);
@@ -1037,6 +1053,12 @@ void qib_verbs_sdma_desc_avail(struct qi
 		spin_unlock(&qp->s_lock);
 		if (atomic_dec_and_test(&qp->refcount))
 			wake_up(&qp->wait);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -1499,6 +1521,11 @@ void qib_ib_piobufavail(struct qib_devda
 full:
 	spin_unlock_irqrestore(&dev->pending_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n; i++) {
 		qp = qps[i];
 
@@ -1512,6 +1539,12 @@ full:
 		/* Notify qib_destroy_qp() if it is waiting. */
 		if (atomic_dec_and_test(&qp->refcount))
 			wake_up(&qp->wait);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1631,20 +1664,42 @@ static int qib_modify_device(struct ib_d
 
 	if (device_modify_mask & IB_DEVICE_MODIFY_NODE_DESC) {
 		memcpy(device->node_desc, device_modify->node_desc, 64);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dd->num_pports; i++) {
 			struct qib_ibport *ibp = &dd->pport[i].ibport_data;
 
 			qib_node_desc_chg(ibp);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
 	if (device_modify_mask & IB_DEVICE_MODIFY_SYS_IMAGE_GUID) {
 		ib_qib_sys_image_guid =
 			cpu_to_be64(device_modify->sys_image_guid);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dd->num_pports; i++) {
 			struct qib_ibport *ibp = &dd->pport[i].ibport_data;
 
 			qib_sys_guid_chg(ibp);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -2066,6 +2121,11 @@ int qib_register_ib_device(struct qib_de
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ppd->sdma_descq_cnt; i++) {
 		struct qib_verbs_txreq *tx;
 
@@ -2076,6 +2136,12 @@ int qib_register_ib_device(struct qib_de
 		}
 		tx->hdr_inx = i;
 		list_add(&tx->txreq.list, &dev->txreq_free);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/infiniband/hw/qib/qib_iba7322.c b/infiniband/hw/qib/qib_iba7322.c
--- a/infiniband/hw/qib/qib_iba7322.c
+++ b/infiniband/hw/qib/qib_iba7322.c
@@ -1278,12 +1278,23 @@ static void qib_disarm_7322_senderrbufs(
 	 * have already done this as a result of hardware error handling.
 	 */
 	any = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < regcnt; ++i) {
 		sbuf[i] = qib_read_kreg64(dd, kr_sendbuffererror + i);
 		if (sbuf[i]) {
 			any = 1;
 			qib_write_kreg(dd, kr_sendbuffererror + i, sbuf[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (any)
@@ -1992,11 +2003,22 @@ static void qib_7322_clear_freeze(struct
 	qib_write_kreg(dd, kr_errclear, E_SPKT_ERRS_IGNORE);
 	qib_write_kreg(dd, kr_errmask, dd->cspec->errormask);
 	/* We need to purge per-port errs and reset mask, too */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		if (!dd->pport[pidx].link_speed_supported)
 			continue;
 		qib_write_kreg_port(dd->pport + pidx, krp_errclear, ~0Ull);
 		qib_write_kreg_port(dd->pport + pidx, krp_errmask, ~0Ull);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	qib_7322_set_intr_state(dd, 1);
 }
@@ -2602,7 +2624,12 @@ static void qib_setup_7322_cleanup(struc
 	kfree(dd->cspec->sendibchk);
 	kfree(dd->cspec->msix_entries);
 	kfree(dd->cspec->msix_arg);
-	for (i = 0; i < dd->num_pports; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < dd->num_pports; i++) {
 		unsigned long flags;
 		u32 mask = QSFP_GPIO_MOD_PRS_N |
 			(QSFP_GPIO_MOD_PRS_N << QSFP_GPIO_PORT2_SHIFT);
@@ -2617,6 +2644,12 @@ static void qib_setup_7322_cleanup(struc
 		}
 		if (dd->pport[i].ibport_data.smi_ah)
 			ib_destroy_ah(&dd->pport[i].ibport_data.smi_ah->ibah);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -2701,6 +2734,11 @@ static noinline void unknown_7322_gpio_i
 	 * Check for QSFP MOD_PRS changes
 	 * only works for single port if IB1 != pidx1
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < dd->num_pports && (dd->flags & QIB_HAS_QSFP);
 	     ++pidx) {
 		struct qib_pportdata *ppd;
@@ -2723,6 +2761,12 @@ static noinline void unknown_7322_gpio_i
 				queue_work(ib_wq, &qd->work);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (gpiostatus && !handled) {
@@ -2854,6 +2898,11 @@ static irqreturn_t qib_7322intr(int irq,
 	if (ctxtrbits) {
 		rmask = (1ULL << QIB_I_RCVAVAIL_LSB) |
 			(1ULL << QIB_I_RCVURG_LSB);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dd->first_user_ctxt; i++) {
 			if (ctxtrbits & rmask) {
 				ctxtrbits &= ~rmask;
@@ -2861,6 +2910,12 @@ static irqreturn_t qib_7322intr(int irq,
 					qib_kreceive(dd->rcd[i], NULL, &npkts);
 			}
 			rmask <<= 1;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		if (ctxtrbits) {
 			ctxtrbits = (ctxtrbits >> QIB_I_RCVAVAIL_LSB) |
@@ -3122,6 +3177,11 @@ try_intx:
 	memset(redirect, 0, sizeof redirect);
 	mask = ~0ULL;
 	msixnum = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; msixnum < dd->cspec->num_msix_entries; i++) {
 		irq_handler_t handler;
 		const char *name;
@@ -3179,6 +3239,12 @@ try_intx:
 		val = qib_read_kreg64(dd, 2 * msixnum + 1 +
 			(QIB_7322_MsixTable_OFFS / sizeof(u64)));
 		msixnum++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* Initialize the vector mapping */
 	for (i = 0; i < ARRAY_SIZE(redirect); i++)
@@ -3310,7 +3376,12 @@ static int qib_do_7322_reset(struct qib_
 	 * after we save it, but since we have disabled the MSIx, it
 	 * shouldn't be touched...
 	 */
-	for (i = 0; i < msix_entries; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < msix_entries; i++) {
 		u64 vecaddr, vecdata;
 		vecaddr = qib_read_kreg64(dd, 2 * i +
 				  (QIB_7322_MsixTable_OFFS / sizeof(u64)));
@@ -3321,6 +3392,12 @@ static int qib_do_7322_reset(struct qib_
 			/* save it without the masked bit set */
 			msix_vecsave[1 + 2 * i] = vecdata & ~0x100000000ULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dd->pport->cpspec->ibdeltainprog = 0;
@@ -3368,6 +3445,11 @@ static int qib_do_7322_reset(struct qib_
 
 	if (msix_entries) {
 		/* restore the MSIx vector address and data if saved above */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < msix_entries; i++) {
 			dd->cspec->msix_entries[i].entry = i;
 			if (!msix_vecsave || !msix_vecsave[2 * i])
@@ -3378,6 +3460,12 @@ static int qib_do_7322_reset(struct qib_
 			qib_write_kreg(dd, 1 + 2 * i +
 				(QIB_7322_MsixTable_OFFS / sizeof(u64)),
 				msix_vecsave[1 + 2 * i]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -3394,6 +3482,11 @@ static int qib_do_7322_reset(struct qib_
 
 	qib_setup_7322_interrupt(dd, 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dd->num_pports; ++i) {
 		struct qib_pportdata *ppd = &dd->pport[i];
 
@@ -3401,6 +3494,12 @@ static int qib_do_7322_reset(struct qib_
 		ppd->lflags |= QIBL_IB_FORCE_NOTIFY;
 		ppd->lflags &= ~QIBL_IB_AUTONEG_FAILED;
 		spin_unlock_irqrestore(&ppd->lflags_lock, flags);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 bail:
@@ -4008,6 +4107,11 @@ static void get_vl_weights(struct qib_pp
 {
 	unsigned i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i++, regno++, vl++) {
 		u32 val = qib_read_kreg_port(ppd, regno);
 
@@ -4015,6 +4119,12 @@ static void get_vl_weights(struct qib_pp
 			SYM_RMASK(LowPriority0_0, VirtualLane);
 		vl->weight = (val >> SYM_LSB(LowPriority0_0, Weight)) &
 			SYM_RMASK(LowPriority0_0, Weight);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -4023,7 +4133,12 @@ static void set_vl_weights(struct qib_pp
 {
 	unsigned i;
 
-	for (i = 0; i < 16; i++, regno++, vl++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		      for (i = 0; i < 16; i++, regno++, vl++) {
 		u64 val;
 
 		val = ((vl->vl & SYM_RMASK(LowPriority0_0, VirtualLane)) <<
@@ -4031,6 +4146,12 @@ static void set_vl_weights(struct qib_pp
 		      ((vl->weight & SYM_RMASK(LowPriority0_0, Weight)) <<
 			SYM_LSB(LowPriority0_0, Weight));
 		qib_write_kreg_port(ppd, regno, val);
+		if (_cur < timeout) {
+		      rdstcll(_cur);
+		}
+		else {
+		      break;
+		}
 	}
 	if (!(ppd->p_sendctrl & SYM_MASK(SendCtrl_0, IBVLArbiterEn))) {
 		struct qib_devdata *dd = ppd->dd;
@@ -4230,13 +4351,24 @@ static void rcvctrl_7322_mod(struct qib_
 		} else {
 			unsigned i;
 
-			for (i = 0; i < dd->cfgctxts; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (i = 0; i < dd->cfgctxts; i++) {
 				qib_write_kreg_ctxt(dd, krc_rcvhdrtailaddr,
 						    i, 0);
 				qib_write_kreg_ctxt(dd, krc_rcvhdraddr, i, 0);
 				for (f = 0; f < NUM_TIDFLOWS_CTXT; f++)
 					qib_write_ureg(dd, ur_rcvflowtable + f,
 						       TIDFLOW_ERRBITS, i);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 			}
 		}
 	}
@@ -4305,11 +4437,22 @@ static void sendctrl_7322_mod(struct qib
 		 * disabling updates until done.
 		 */
 		tmp_dd_sendctrl &= ~SYM_MASK(SendCtrl, SendBufAvailUpd);
-		for (i = 0; i < last; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < last; i++) {
 			qib_write_kreg(dd, kr_sendctrl,
 				       tmp_dd_sendctrl |
 				       SYM_MASK(SendCtrl, Disarm) | i);
 			qib_write_kreg(dd, kr_scratch, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -4441,12 +4584,23 @@ static u64 qib_portcntr_7322(struct qib_
 		int i;
 
 		/* sum over all kernel contexts (skip if mini_init) */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; dd->rcd && i < dd->first_user_ctxt; i++) {
 			struct qib_ctxtdata *rcd = dd->rcd[i];
 
 			if (!rcd || rcd->ppd != ppd)
 				continue;
 			ret += read_7322_creg32(dd, cr_base_egrovfl + i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		goto done;
 	} else if (reg == QIBPORTCNTR_RXDROPPKT) {
@@ -4643,6 +4797,11 @@ static void init_7322_cntrnames(struct q
 	int i, j = 0;
 	char *s;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, s = (char *)cntr7322names; s && j <= dd->cfgctxts;
 	     i++) {
 		/* we always have at least one counter before the egrovfl */
@@ -4651,6 +4810,12 @@ static void init_7322_cntrnames(struct q
 		s = strchr(s + 1, '\n');
 		if (s && j)
 			j++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	dd->cspec->ncntrs = i;
 	if (!s)
@@ -4667,12 +4832,23 @@ static void init_7322_cntrnames(struct q
 		s = strchr(s + 1, '\n');
 	dd->cspec->nportcntrs = i - 1;
 	dd->cspec->portcntrnamelen = sizeof(portcntr7322names) - 1;
-	for (i = 0; i < dd->num_pports; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < dd->num_pports; ++i) {
 		dd->pport[i].cpspec->portcntrs = kmalloc(dd->cspec->nportcntrs
 			* sizeof(u64), GFP_KERNEL);
 		if (!dd->pport[i].cpspec->portcntrs)
 			qib_dev_err(dd, "Failed allocation for"
 				    " portcounters\n");
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 }
 
@@ -4734,6 +4910,11 @@ static u32 qib_read_7322portcntrs(struct
 			goto done;
 		}
 		*cntrp = cntr;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dd->cspec->nportcntrs; i++) {
 			if (portcntr7322indices[i] & _PORT_VIRT_FLAG)
 				*cntr++ = qib_portcntr_7322(ppd,
@@ -4746,6 +4927,12 @@ static u32 qib_read_7322portcntrs(struct
 			else
 				*cntr++ = read_7322_creg32_port(ppd,
 					   portcntr7322indices[i]);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 done:
@@ -4771,6 +4958,11 @@ static void qib_get_7322_faststats(unsig
 	u64 traffic_wds;
 	int pidx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		ppd = dd->pport + pidx;
 
@@ -4810,6 +5002,12 @@ static void qib_get_7322_faststats(unsig
 					    QDR_STATIC_ADAPT_INIT);
 			force_h1(ppd);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mod_timer(&dd->stats_timer, jiffies + HZ * ACTIVITY_TIMER);
 }
@@ -4932,15 +5130,37 @@ static void qib_autoneg_7322_send(struct
 	hcnt = ARRAY_SIZE(hdr);
 	if (!swapped) {
 		/* for maintainability, do it at runtime */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < hcnt; i++) {
 			dw = (__force u32) cpu_to_be32(hdr[i]);
 			hdr[i] = dw;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < dcnt; i++) {
 			dw = (__force u32) cpu_to_be32(madpayload_start[i]);
 			madpayload_start[i] = dw;
 			dw = (__force u32) cpu_to_be32(madpayload_done[i]);
 			madpayload_done[i] = dw;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		swapped = 1;
 	}
@@ -5764,6 +5984,11 @@ static void set_no_qsfp_atten(struct qib
 			else
 				seth1 = 1;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (pidx = 0; dd->unit == unit && pidx < dd->num_pports;
 		     ++pidx) {
 			struct qib_pportdata *ppd = &dd->pport[pidx];
@@ -5782,6 +6007,12 @@ static void set_no_qsfp_atten(struct qib
 				qib_set_ib_7322_lstate(ppd, 0,
 					    QLOGIC_IB_IBCC_LINKINITCMD_SLEEP);
 			any++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (*nxt == '\n')
 			break; /* done */
@@ -5865,7 +6096,12 @@ static int qib_late_7322_initreg(struct
 	 * don't have valid attenuation.
 	 */
 	set_no_qsfp_atten(dd, 0);
-	for (n = 0; n < dd->num_pports; ++n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (n = 0; n < dd->num_pports; ++n) {
 		struct qib_pportdata *ppd = dd->pport + n;
 
 		qib_write_kreg_port(ppd, krp_senddmaprioritythld,
@@ -5873,6 +6109,12 @@ static int qib_late_7322_initreg(struct
 		/* Initialize qsfp if present on board. */
 		if (dd->flags & QIB_HAS_QSFP)
 			qib_init_7322_qsfp(ppd);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	dd->control |= QLOGIC_IB_C_SDMAFETCHPRIOEN;
 	qib_write_kreg(dd, kr_control, dd->control);
@@ -5955,7 +6197,12 @@ static void write_7322_initregs(struct q
 	/* Set Multicast QPs received by port 2 to map to context one. */
 	qib_write_kreg(dd, KREG_IDX(RcvQPMulticastContext_1), 1);
 
-	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		unsigned n, regno;
 		unsigned long flags;
 
@@ -5995,6 +6242,12 @@ static void write_7322_initregs(struct q
 			}
 		}
 		qib_write_kreg_port(ppd, regno, val);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -6003,9 +6256,20 @@ static void write_7322_initregs(struct q
 	 * stalled waiting for any packet, so want those interrupts
 	 * right away).
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dd->first_user_ctxt; i++) {
 		dd->cspec->rcvavail_timeout[i] = rcv_int_timeout;
 		qib_write_kreg(dd, kr_rcvavailtimeout + i, rcv_int_timeout);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -6014,10 +6278,21 @@ static void write_7322_initregs(struct q
 	 * Doesn't clear any of the error bits that might be set.
 	 */
 	val = TIDFLOW_ERRBITS; /* these are W1C */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dd->cfgctxts; i++) {
 		int flow;
 		for (flow = 0; flow < NUM_TIDFLOWS_CTXT; flow++)
 			qib_write_ureg(dd, ur_rcvflowtable+flow, val, i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/*
@@ -6124,6 +6399,11 @@ static int qib_init_7322_variables(struc
 		  SYM_MASK(HwErrMask, IBSerdesPClkNotDetectMask_1) |
 		  HWE_MASK(LATriggered));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < NUM_IB_PORTS; ++pidx) {
 		struct qib_chippport_specific *cp = ppd->cpspec;
 		ppd->link_speed_supported = features & PORT_SPD_CAP;
@@ -6245,6 +6525,12 @@ static int qib_init_7322_variables(struc
 		cp->chase_timer.data = (unsigned long)ppd;
 
 		ppd++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dd->rcvhdrentsize = qib_rcvhdrentsize ?
@@ -6676,9 +6962,20 @@ static void qib_7322_txchk_change(struct
 
 	case TXCHK_CHG_TYPE_KERN:
 		/* usable by kernel */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = start; i <= last; i++) {
 			set_bit(i, dd->cspec->sendibchk);
 			clear_bit(i, dd->cspec->sendgrhchk);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		spin_lock_irqsave(&dd->uctxt_lock, flags);
 		/* see if we need to raise avail update threshold */
@@ -6704,9 +7001,20 @@ static void qib_7322_txchk_change(struct
 
 	case TXCHK_CHG_TYPE_USER:
 		/* for user process */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = start; i <= last; i++) {
 			clear_bit(i, dd->cspec->sendibchk);
 			set_bit(i, dd->cspec->sendgrhchk);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		spin_lock_irqsave(&dd->sendctrl_lock, flags);
 		if (rcd && rcd->subctxt_cnt && ((rcd->piocnt
@@ -6731,11 +7039,22 @@ static void qib_7322_txchk_change(struct
 		qib_write_kreg(dd, kr_sendcheckmask + i,
 			       dd->cspec->sendchkenable[i]);
 
-	for (i = start / BITS_PER_LONG; which < 2 && i <= lastr; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = start / BITS_PER_LONG; which < 2 && i <= lastr; ++i) {
 		qib_write_kreg(dd, kr_sendgrhcheckmask + i,
 			       dd->cspec->sendgrhchk[i]);
 		qib_write_kreg(dd, kr_sendibpktmask + i,
 			       dd->cspec->sendibchk[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/*
@@ -7186,6 +7505,11 @@ static void find_best_ent(struct qib_ppo
 	int idx;
 
 	/* Search table of known cables */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; !override && idx < ARRAY_SIZE(vendor_txdds); ++idx) {
 		const struct vendor_txdds_ent *v = vendor_txdds + idx;
 
@@ -7197,6 +7521,12 @@ static void find_best_ent(struct qib_ppo
 			*qdr_dds = &v->qdr;
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Active cables don't have attenuation so we only set SERDES
@@ -7276,12 +7606,23 @@ static void init_txdds_table(struct qib_
 	}
 
 	/* Fill in the remaining entries with the default table values. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 1; idx < ARRAY_SIZE(txdds_sdr); ++idx) {
 		set_txdds(ppd, idx, single_ent ? sdr_dds : txdds_sdr + idx);
 		set_txdds(ppd, idx + TXDDS_TABLE_SZ,
 			  single_ent ? ddr_dds : txdds_ddr + idx);
 		set_txdds(ppd, idx + 2 * TXDDS_TABLE_SZ,
 			  single_ent ? qdr_dds : txdds_qdr + idx);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -7377,11 +7718,22 @@ static void ibsd_wr_allchans(struct qib_
 	int chan;
 	u32 rbc;
 
-	for (chan = 0; chan < SERDES_CHANS; ++chan) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (chan = 0; chan < SERDES_CHANS; ++chan) {
 		ahb_mod(dd, IBSD(ppd->hw_pidx), (chan + (chan >> 1)), addr,
 			data, mask);
 		rbc = ahb_mod(dd, IBSD(ppd->hw_pidx), (chan + (chan >> 1)),
 			      addr, 0, 0);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -7623,13 +7975,24 @@ static int serdes_7322_init_new(struct q
 	       !time_after64(get_jiffies_64(),
 			tstart + msecs_to_jiffies(500))) {
 		msleep(20);
-		for (chan = 0; chan < SERDES_CHANS; ++chan) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (chan = 0; chan < SERDES_CHANS; ++chan) {
 			rxcaldone = ahb_mod(ppd->dd, IBSD(ppd->hw_pidx),
 					    (chan + (chan >> 1)),
 					    25, 0, 0);
 			if ((~rxcaldone & (u32)BMASK(9, 9)) == 0 &&
 			    (~chan_done & (1 << chan)) == 0)
 				chan_done &= ~(1 << chan);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 	if (chan_done) {
@@ -7637,7 +8000,12 @@ static int serdes_7322_init_new(struct q
 			 " Serdes %d calibration not done after .5 sec: 0x%x\n",
 			 IBSD(ppd->hw_pidx), chan_done);
 	} else {
-		for (chan = 0; chan < SERDES_CHANS; ++chan) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (chan = 0; chan < SERDES_CHANS; ++chan) {
 			rxcaldone = ahb_mod(ppd->dd, IBSD(ppd->hw_pidx),
 					    (chan + (chan >> 1)),
 					    25, 0, 0);
@@ -7645,6 +8013,12 @@ static int serdes_7322_init_new(struct q
 				printk(KERN_INFO QIB_DRV_NAME
 					 " Serdes %d chan %d calibration "
 					 "failed\n", IBSD(ppd->hw_pidx), chan);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
@@ -7803,11 +8177,22 @@ static void force_h1(struct qib_pportdat
 	if (!ppd->dd->cspec->r1)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (chan = 0; chan < SERDES_CHANS; chan++) {
 		set_man_mode_h1(ppd, chan, 1, 0);
 		set_man_code(ppd, chan, ppd->cpspec->h1_val);
 		clock_man(ppd, chan);
 		set_man_mode_h1(ppd, chan, 0, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -7838,10 +8223,21 @@ static int qib_r_wait_for_rdy(struct qib
 {
 	u64 val;
 	int timeout;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (timeout = 0; timeout < 100 ; ++timeout) {
 		val = qib_read_kreg32(dd, kr_r_access);
 		if (val & R_RDY)
 			return (val >> R_TDO_LSB) & 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return -1;
 }
diff -u -p a/infiniband/hw/qib/qib_init.c b/infiniband/hw/qib/qib_init.c
--- a/infiniband/hw/qib/qib_init.c
+++ b/infiniband/hw/qib/qib_init.c
@@ -125,6 +125,11 @@ int qib_create_ctxts(struct qib_devdata
 	}
 
 	/* create (one or more) kctxt */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dd->first_user_ctxt; ++i) {
 		struct qib_pportdata *ppd;
 		struct qib_ctxtdata *rcd;
@@ -142,6 +147,12 @@ int qib_create_ctxts(struct qib_devdata
 		}
 		rcd->pkeys[0] = QIB_DEFAULT_P_KEY;
 		rcd->seq_cnt = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0;
 done:
@@ -236,9 +247,20 @@ static int init_pioavailregs(struct qib_
 	/* device status comes first, for backwards compatibility */
 	dd->devstatusp = status_page;
 	*status_page++ = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		dd->pport[pidx].statusp = status_page;
 		*status_page++ = 0;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/*
@@ -362,7 +384,12 @@ static int init_after_reset(struct qib_d
 	 * pioavail updates while we re-initialize.  This is mostly
 	 * for the driver data structures, not chip registers.
 	 */
-	for (i = 0; i < dd->num_pports; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < dd->num_pports; ++i) {
 		/*
 		 * ctxt == -1 means "all contexts". Only really safe for
 		 * _dis_abling things, as here.
@@ -373,6 +400,12 @@ static int init_after_reset(struct qib_d
 		/* Redundant across ports for some, but no big deal.  */
 		dd->f_sendctrl(dd->pport + i, QIB_SENDCTRL_SEND_DIS |
 			QIB_SENDCTRL_AVAIL_DIS);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
@@ -396,11 +429,22 @@ static void enable_chip(struct qib_devda
 	rcvmask = QIB_RCVCTRL_CTXT_ENB | QIB_RCVCTRL_INTRAVAIL_ENB;
 	rcvmask |= (dd->flags & QIB_NODMA_RTAIL) ?
 		  QIB_RCVCTRL_TAILUPD_DIS : QIB_RCVCTRL_TAILUPD_ENB;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; dd->rcd && i < dd->first_user_ctxt; ++i) {
 		struct qib_ctxtdata *rcd = dd->rcd[i];
 
 		if (rcd)
 			dd->f_rcvctrl(rcd->ppd, rcvmask, i);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	dd->freectxts = dd->cfgctxts - dd->first_user_ctxt;
 }
@@ -461,6 +505,11 @@ static void init_piobuf_state(struct qib
 	 * case something went wrong with abort, but mostly to get the
 	 * initial values of the generation bit correct.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dd->pioavregs; i++) {
 		__le64 tmp;
 
@@ -471,6 +520,12 @@ static void init_piobuf_state(struct qib
 		 * in initialization, to busy out buffers as needed.
 		 */
 		dd->pioavailshadow[i] = le64_to_cpu(tmp);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	while (i < ARRAY_SIZE(dd->pioavailshadow))
 		dd->pioavailshadow[i++] = 0; /* for debugging sanity */
@@ -506,6 +561,11 @@ int qib_init(struct qib_devdata *dd, int
 	unsigned long flags;
 
 	/* Set linkstate to unknown, so we can watch for a transition. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		ppd = dd->pport + pidx;
 		spin_lock_irqsave(&ppd->lflags_lock, flags);
@@ -513,6 +573,12 @@ int qib_init(struct qib_devdata *dd, int
 				 QIBL_LINKDOWN | QIBL_LINKINIT |
 				 QIBL_LINKV);
 		spin_unlock_irqrestore(&ppd->lflags_lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (reinit)
@@ -531,6 +597,11 @@ int qib_init(struct qib_devdata *dd, int
 		goto done;
 
 	/* dd->rcd can be NULL if early init failed */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; dd->rcd && i < dd->first_user_ctxt; ++i) {
 		/*
 		 * Set up the (kernel) rcvhdr queue and egr TIDs.  If doing
@@ -550,8 +621,19 @@ int qib_init(struct qib_devdata *dd, int
 				    "rcvhdrq and/or egr bufs\n");
 			continue;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		int mtu;
 		if (lastfail)
@@ -587,6 +669,12 @@ int qib_init(struct qib_devdata *dd, int
 		}
 
 		portok++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!portok) {
@@ -605,7 +693,12 @@ int qib_init(struct qib_devdata *dd, int
 done:
 	if (!ret) {
 		/* chip is OK for user apps; mark it as initialized */
-		for (pidx = 0; pidx < dd->num_pports; ++pidx) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 			ppd = dd->pport + pidx;
 			/*
 			 * Set status even if port serdes is not initialized
@@ -621,6 +714,12 @@ done:
 			ppd->hol_timer.function = qib_hol_event;
 			ppd->hol_timer.data = (unsigned long)ppd;
 			ppd->hol_state = QIB_HOL_UP;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* now we can enable all interrupts from the chip */
@@ -688,6 +787,11 @@ static void qib_stop_timers(struct qib_d
 		del_timer_sync(&dd->intrchk_timer);
 		dd->intrchk_timer.data = 0;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		ppd = dd->pport + pidx;
 		if (ppd->hol_timer.data)
@@ -698,6 +802,12 @@ static void qib_stop_timers(struct qib_d
 		}
 		if (ppd->symerr_clear_timer.data)
 			del_timer_sync(&ppd->symerr_clear_timer);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -715,7 +825,12 @@ static void qib_shutdown_device(struct q
 	struct qib_pportdata *ppd;
 	unsigned pidx;
 
-	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		ppd = dd->pport + pidx;
 
 		spin_lock_irq(&ppd->lflags_lock);
@@ -724,13 +839,24 @@ static void qib_shutdown_device(struct q
 				 QIBL_LINKV);
 		spin_unlock_irq(&ppd->lflags_lock);
 		*ppd->statusp &= ~(QIB_STATUS_IB_CONF | QIB_STATUS_IB_READY);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	dd->flags &= ~QIB_INITTED;
 
 	/* mask interrupts, but not errors */
 	dd->f_set_intr_state(dd, 0);
 
-	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		ppd = dd->pport + pidx;
 		dd->f_rcvctrl(ppd, QIB_RCVCTRL_TAILUPD_DIS |
 				   QIB_RCVCTRL_CTXT_DIS |
@@ -741,6 +867,12 @@ static void qib_shutdown_device(struct q
 		 * trickle out first.
 		 */
 		dd->f_sendctrl(ppd, QIB_SENDCTRL_CLEAR);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/*
@@ -749,6 +881,11 @@ static void qib_shutdown_device(struct q
 	 */
 	udelay(20);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 		ppd = dd->pport + pidx;
 		dd->f_setextled(ppd, 0); /* make sure LEDs are off */
@@ -763,6 +900,12 @@ static void qib_shutdown_device(struct q
 		 * We can't count on interrupts since we are stopping.
 		 */
 		dd->f_quiet_serdes(ppd);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	qib_update_eeprom_log(dd);
@@ -798,12 +941,23 @@ void qib_free_ctxtdata(struct qib_devdat
 	if (rcd->rcvegrbuf) {
 		unsigned e;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (e = 0; e < rcd->rcvegrbuf_chunks; e++) {
 			void *base = rcd->rcvegrbuf[e];
 			size_t size = rcd->rcvegrbuf_size;
 
 			dma_free_coherent(&dd->pcidev->dev, size,
 					  base, rcd->rcvegrbuf_phys[e]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		kfree(rcd->rcvegrbuf);
 		rcd->rcvegrbuf = NULL;
@@ -884,9 +1038,20 @@ static void qib_verify_pioperf(struct qi
 	 * >= 5 msec seems to get us "close enough" to accurate values.
 	 */
 	msecs = jiffies_to_msecs(jiffies);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (emsecs = lcnt = 0; emsecs <= 5UL; lcnt++) {
 		qib_pio_copy(piobuf + 64, addr, cnt >> 2);
 		emsecs = jiffies_to_msecs(jiffies) - msecs;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* 1 GiB/sec, slightly over IB SDR line rate */
@@ -985,18 +1150,30 @@ void qib_disable_after_error(struct qib_
 		u32 pidx;
 
 		dd->flags &= ~QIB_INITTED;
-		if (dd->pport)
-			for (pidx = 0; pidx < dd->num_pports; ++pidx) {
-				struct qib_pportdata *ppd;
-
-				ppd = dd->pport + pidx;
-				if (dd->flags & QIB_PRESENT) {
-					qib_set_linkstate(ppd,
+		if (dd->pport) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (pidx = 0; pidx < dd->num_pports; ++pidx) {
+					struct qib_pportdata *ppd;
+
+					ppd = dd->pport + pidx;
+					if (dd->flags & QIB_PRESENT) {
+						qib_set_linkstate(ppd,
 						QIB_IB_LINKDOWN_DISABLE);
 					dd->f_setextled(ppd, 0);
+					}
+					*ppd->statusp &= ~QIB_STATUS_IB_READY;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 				}
-				*ppd->statusp &= ~QIB_STATUS_IB_READY;
-			}
+		}
 	}
 
 	/*
@@ -1139,11 +1316,21 @@ static void cleanup_device_data(struct q
 		dma_addr_t *tmpd = dd->physshadow;
 		int i, cnt = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (ctxt = 0; ctxt < dd->cfgctxts; ctxt++) {
 			int ctxt_tidbase = ctxt * dd->rcvtidcnt;
 			int maxtid = ctxt_tidbase + dd->rcvtidcnt;
 
-			for (i = ctxt_tidbase; i < maxtid; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (i = ctxt_tidbase; i < maxtid; i++) {
 				if (!tmpp[i])
 					continue;
 				pci_unmap_page(dd->pcidev, tmpd[i],
@@ -1151,6 +1338,18 @@ static void cleanup_device_data(struct q
 				qib_release_user_pages(&tmpp[i], 1);
 				tmpp[i] = NULL;
 				cnt++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 
@@ -1170,11 +1369,22 @@ static void cleanup_device_data(struct q
 	tmp = dd->rcd;
 	dd->rcd = NULL;
 	spin_unlock_irqrestore(&dd->uctxt_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ctxt = 0; tmp && ctxt < dd->ctxtcnt; ctxt++) {
 		struct qib_ctxtdata *rcd = tmp[ctxt];
 
 		tmp[ctxt] = NULL; /* debugging paranoia */
 		qib_free_ctxtdata(dd, rcd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(tmp);
 	kfree(dd->boardname);
@@ -1448,7 +1658,12 @@ int qib_setup_eagerbufs(struct qib_ctxtd
 		if (!rcd->rcvegrbuf_phys)
 			goto bail_rcvegrbuf;
 	}
-	for (e = 0; e < rcd->rcvegrbuf_chunks; e++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (e = 0; e < rcd->rcvegrbuf_chunks; e++) {
 		if (rcd->rcvegrbuf[e])
 			continue;
 		rcd->rcvegrbuf[e] =
@@ -1457,10 +1672,21 @@ int qib_setup_eagerbufs(struct qib_ctxtd
 					   gfp_flags);
 		if (!rcd->rcvegrbuf[e])
 			goto bail_rcvegrbuf_phys;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	rcd->rcvegr_phys = rcd->rcvegrbuf_phys[0];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (e = chunk = 0; chunk < rcd->rcvegrbuf_chunks; chunk++) {
 		dma_addr_t pa = rcd->rcvegrbuf_phys[chunk];
 		unsigned i;
@@ -1468,6 +1694,11 @@ int qib_setup_eagerbufs(struct qib_ctxtd
 		/* clear for security and sanity on each use */
 		memset(rcd->rcvegrbuf[chunk], 0, size);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; e < egrcnt && i < egrperchunk; e++, i++) {
 			dd->f_put_tid(dd, e + egroff +
 					  (u64 __iomem *)
@@ -1476,8 +1707,20 @@ int qib_setup_eagerbufs(struct qib_ctxtd
 					   dd->rcvegrbase),
 					  RCVHQ_RCV_TYPE_EAGER, pa);
 			pa += egrsize;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		cond_resched(); /* don't hog the cpu */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/infiniband/hw/qib/qib_qp.c b/infiniband/hw/qib/qib_qp.c
--- a/infiniband/hw/qib/qib_qp.c
+++ b/infiniband/hw/qib/qib_qp.c
@@ -287,6 +287,11 @@ unsigned qib_free_all_qps(struct qib_dev
 	struct qib_qp *qp;
 	unsigned n, qp_inuse = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 0; n < dd->num_pports; n++) {
 		struct qib_ibport *ibp = &dd->pport[n].ibport_data;
 
@@ -298,15 +303,32 @@ unsigned qib_free_all_qps(struct qib_dev
 		if (rcu_dereference(ibp->qp1))
 			qp_inuse++;
 		rcu_read_unlock();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_lock_irqsave(&dev->qpt_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 0; n < dev->qp_table_size; n++) {
 		qp = dev->qp_table[n];
 		rcu_assign_pointer(dev->qp_table[n], NULL);
 
 		for (; qp; qp = qp->next)
 			qp_inuse++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	spin_unlock_irqrestore(&dev->qpt_lock, flags);
 	synchronize_rcu();
@@ -424,10 +446,21 @@ static void clear_mr_refs(struct qib_qp
 			struct qib_swqe *wqe = get_swqe_ptr(qp, qp->s_last);
 			unsigned i;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < wqe->wr.num_sge; i++) {
 				struct qib_sge *sge = &wqe->sg_list[i];
 
 				atomic_dec(&sge->mr->refcount);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if (qp->ibqp.qp_type == IB_QPT_UD ||
 			    qp->ibqp.qp_type == IB_QPT_SMI ||
@@ -445,6 +478,11 @@ static void clear_mr_refs(struct qib_qp
 	if (qp->ibqp.qp_type != IB_QPT_RC)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = 0; n < ARRAY_SIZE(qp->s_ack_queue); n++) {
 		struct qib_ack_entry *e = &qp->s_ack_queue[n];
 
@@ -453,6 +491,12 @@ static void clear_mr_refs(struct qib_qp
 			atomic_dec(&e->rdma_sge.mr->refcount);
 			e->rdma_sge.mr = NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/infiniband/hw/qib/qib_fs.c b/infiniband/hw/qib/qib_fs.c
--- a/infiniband/hw/qib/qib_fs.c
+++ b/infiniband/hw/qib/qib_fs.c
@@ -408,6 +408,11 @@ static int add_cntr_files(struct super_b
 		       unit, "portcounter_names", ret);
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i <= dd->num_pports; i++) {
 		char fname[24];
 
@@ -430,6 +435,12 @@ static int add_cntr_files(struct super_b
 				unit, fname, ret);
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = create_file("flash", S_IFREG|S_IWUSR|S_IRUGO, dir, &tmp,
@@ -493,6 +504,11 @@ static int remove_device_files(struct su
 	remove_file(dir, "counters");
 	remove_file(dir, "counter_names");
 	remove_file(dir, "portcounter_names");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dd->num_pports; i++) {
 		char fname[24];
 
@@ -502,6 +518,12 @@ static int remove_device_files(struct su
 			sprintf(fname, "qsfp%d", i + 1);
 			remove_file(dir, fname);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	remove_file(dir, "flash");
 	d_delete(dir);
diff -u -p a/infiniband/hw/amso1100/c2_provider.c b/infiniband/hw/amso1100/c2_provider.c
--- a/infiniband/hw/amso1100/c2_provider.c
+++ b/infiniband/hw/amso1100/c2_provider.c
@@ -349,7 +349,12 @@ static struct ib_mr *c2_reg_phys_mr(stru
 	if (num_phys_buf == 1)
 		page_shift += 3;
 
-	for (i = 0; i < num_phys_buf; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < num_phys_buf; i++) {
 
 		if (buffer_list[i].addr & ~PAGE_MASK) {
 			pr_debug("Unaligned Memory Buffer: 0x%x\n",
@@ -365,6 +370,12 @@ static struct ib_mr *c2_reg_phys_mr(stru
 		total_len += buffer_list[i].size;
 		pbl_depth += ALIGN(buffer_list[i].size,
 				   (1 << page_shift)) >> page_shift;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	page_list = vmalloc(sizeof(u64) * pbl_depth);
@@ -374,7 +385,12 @@ static struct ib_mr *c2_reg_phys_mr(stru
 		return ERR_PTR(-ENOMEM);
 	}
 
-	for (i = 0, j = 0; i < num_phys_buf; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0, j = 0; i < num_phys_buf; i++) {
 
 		int naddrs;
 
@@ -383,6 +399,12 @@ static struct ib_mr *c2_reg_phys_mr(stru
 		for (k = 0; k < naddrs; k++)
 			page_list[j++] = (buffer_list[i].addr +
 						     (k << page_shift));
+			if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	mr = kmalloc(sizeof(*mr), GFP_KERNEL);
@@ -465,12 +487,34 @@ static struct ib_mr *c2_reg_user_mr(stru
 
 	i = 0;
 	list_for_each_entry(chunk, &c2mr->umem->chunk_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < chunk->nmap; ++j) {
 			len = sg_dma_len(&chunk->page_list[j]) >> shift;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (k = 0; k < len; ++k) {
 				pages[i++] =
 					sg_dma_address(&chunk->page_list[j]) +
 					(c2mr->umem->page_size * k);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
 			}
 		}
 	}
@@ -857,11 +901,22 @@ int c2_register_device(struct c2_dev *de
 	if (ret)
 		goto out_free_iwcm;
 
-	for (i = 0; i < ARRAY_SIZE(c2_dev_attributes); ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(c2_dev_attributes); ++i) {
 		ret = device_create_file(&dev->ibdev.dev,
 					       c2_dev_attributes[i]);
 		if (ret)
 			goto out_unregister_ibdev;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	goto out;
 
diff -u -p a/infiniband/hw/amso1100/c2_mm.c b/infiniband/hw/amso1100/c2_mm.c
--- a/infiniband/hw/amso1100/c2_mm.c
+++ b/infiniband/hw/amso1100/c2_mm.c
@@ -121,6 +121,11 @@ send_pbl_messages(struct c2_dev *c2dev,
 		 * of physical addresses and there is no conversion to do.
 		 * Just fill in the wr with what is in the array.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < count; i++) {
 			if (pbl_virt) {
 				va += PAGE_SIZE;
@@ -128,6 +133,12 @@ send_pbl_messages(struct c2_dev *c2dev,
  				wr->paddrs[i] =
 				    cpu_to_be64(((u64 *)va)[pbl_index + i]);
 			}
+			if (_cur < timeout) {
+				    rdstcll(_cur);
+			}
+			else {
+				    break;
+			}
 		}
 
 		/*
@@ -238,8 +249,19 @@ c2_nsmr_register_phys_kern(struct c2_dev
 	/*
 	 * fill out the PBL for this message
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i++) {
 		wr->paddrs[i] = cpu_to_be64(addr_list[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/*
diff -u -p a/infiniband/hw/amso1100/c2_alloc.c b/infiniband/hw/amso1100/c2_alloc.c
--- a/infiniband/hw/amso1100/c2_alloc.c
+++ b/infiniband/hw/amso1100/c2_alloc.c
@@ -55,11 +55,22 @@ static int c2_alloc_mqsp_chunk(struct c2
 	new_head->head = 0;
 
 	/* build list where each index is the next free slot */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0;
 	     i < (PAGE_SIZE - sizeof(struct sp_chunk) -
 		  sizeof(u16)) / sizeof(u16) - 1;
 	     i++) {
 		new_head->shared_ptr[i] = i + 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* terminate list */
 	new_head->shared_ptr[i] = 0xFFFF;
diff -u -p a/infiniband/hw/amso1100/c2.c b/infiniband/hw/amso1100/c2.c
--- a/infiniband/hw/amso1100/c2.c
+++ b/infiniband/hw/amso1100/c2.c
@@ -123,6 +123,11 @@ static int c2_tx_ring_alloc(struct c2_ri
 	elem = tx_ring->start;
 	tx_desc = vaddr;
 	txp_desc = mmio_txp_ring;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < tx_ring->count; i++, elem++, tx_desc++, txp_desc++) {
 		tx_desc->len = 0;
 		tx_desc->status = 0;
@@ -146,6 +151,12 @@ static int c2_tx_ring_alloc(struct c2_ri
 			tx_desc->next_offset =
 			    base + (i + 1) * sizeof(*tx_desc);
 		}
+		if (_cur < timeout) {
+			    rdstcll(_cur);
+		}
+		else {
+			    break;
+		}
 	}
 
 	tx_ring->to_use = tx_ring->to_clean = tx_ring->start;
@@ -172,6 +183,11 @@ static int c2_rx_ring_alloc(struct c2_ri
 	elem = rx_ring->start;
 	rx_desc = vaddr;
 	rxp_desc = mmio_rxp_ring;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < rx_ring->count; i++, elem++, rx_desc++, rxp_desc++) {
 		rx_desc->len = 0;
 		rx_desc->status = 0;
@@ -198,6 +214,12 @@ static int c2_rx_ring_alloc(struct c2_ri
 			rx_desc->next_offset =
 			    base + (i + 1) * sizeof(*rx_desc);
 		}
+		if (_cur < timeout) {
+			    rdstcll(_cur);
+		}
+		else {
+			    break;
+		}
 	}
 
 	rx_ring->to_use = rx_ring->to_clean = rx_ring->start;
@@ -649,12 +671,23 @@ static int c2_up(struct net_device *netd
 	c2_reset(c2_port);
 
 	/* Reset the READY bit in the sk_buff RXP headers & adapter HRXDQ */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, elem = c2_port->rx_ring.start; i < c2_port->rx_ring.count;
 	     i++, elem++) {
 		rxp_hdr = (struct c2_rxp_hdr *) elem->skb->data;
 		rxp_hdr->flags = 0;
 		__raw_writew((__force u16) cpu_to_be16(RXP_HRXD_READY),
 			     elem->hw_desc + C2_RXP_FLAGS);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Enable network packets */
@@ -799,6 +832,11 @@ static int c2_xmit_frame(struct sk_buff
 
 	/* Loop thru additional data fragments and queue them */
 	if (skb_shinfo(skb)->nr_frags) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 			const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 			maplen = skb_frag_size(frag);
@@ -819,6 +857,12 @@ static int c2_xmit_frame(struct sk_buff
 
 			netdev->stats.tx_packets++;
 			netdev->stats.tx_bytes += maplen;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -1011,6 +1055,11 @@ static int __devinit c2_probe(struct pci
 	}
 
 	/* Validate PCI regs magic */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sizeof(c2_magic); i++) {
 		if (c2_magic[i] != readb(mmio_regs + C2_REGS_MAGIC + i)) {
 			printk(KERN_ERR PFX "Downlevel Firmware boot loader "
@@ -1024,6 +1073,12 @@ static int __devinit c2_probe(struct pci
 			ret = -EIO;
 			goto bail2;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Validate the adapter version */
diff -u -p a/infiniband/hw/nes/nes_hw.c b/infiniband/hw/nes/nes_hw.c
--- a/infiniband/hw/nes/nes_hw.c
+++ b/infiniband/hw/nes/nes_hw.c
@@ -446,9 +446,20 @@ struct nes_adapter *nes_init_adapter(str
 
 
 	/* mark the usual suspect QPs, MR and CQs as in use */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (u32temp = 0; u32temp < NES_FIRST_QPN; u32temp++) {
 		set_bit(u32temp, nesadapter->allocated_qps);
 		set_bit(u32temp, nesadapter->allocated_cqs);
+		if (_cur < timeout) {
+				       rdstcll(_cur);
+		}
+		else {
+				       break;
+		}
 	}
 	set_bit(0, nesadapter->allocated_mrs);
 
@@ -551,7 +562,12 @@ struct nes_adapter *nes_init_adapter(str
 		pcs_control_status1 = nes_read_indexed(nesdev,
 			NES_IDX_PHY_PCS_CONTROL_STATUS0 + 0x200);
 
-		for (i = 0; i < NES_MAX_LINK_CHECK; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < NES_MAX_LINK_CHECK; i++) {
 			pcs_control_status0 = nes_read_indexed(nesdev,
 					NES_IDX_PHY_PCS_CONTROL_STATUS0);
 			pcs_control_status1 = nes_read_indexed(nesdev,
@@ -560,6 +576,12 @@ struct nes_adapter *nes_init_adapter(str
 			    || (0x0F000100 == (pcs_control_status1 & 0x0F000100)))
 				int_cnt++;
 			msleep(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (int_cnt > 1) {
 			spin_lock_irqsave(&nesadapter->phy_lock, flags);
@@ -1107,9 +1129,20 @@ int nes_init_cqp(struct nes_device *nesd
 	INIT_LIST_HEAD(&nesdev->cqp_avail_reqs);
 	INIT_LIST_HEAD(&nesdev->cqp_pending_reqs);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; count < 2*NES_CQP_SQ_SIZE; count++) {
 		init_waitqueue_head(&nesdev->nes_cqp_requests[count].waitq);
 		list_add_tail(&nesdev->nes_cqp_requests[count].list, &nesdev->cqp_avail_reqs);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Write Create CCQ WQE */
@@ -1709,9 +1742,20 @@ int nes_init_nic_qp(struct nes_device *n
 	/* Setup the first Fragment buffers */
 	nesvnic->nic.first_frag_vbase = vmem;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (counter = 0; counter < NES_NIC_WQ_SIZE; counter++) {
 		nesvnic->nic.frag_paddr[counter] = pmem;
 		pmem += sizeof(struct nes_first_frag);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	/* setup the SQ */
@@ -1722,7 +1766,12 @@ int nes_init_nic_qp(struct nes_device *n
 	nesvnic->nic.sq_head = 0;
 	nesvnic->nic.sq_tail = 0;
 	nesvnic->nic.sq_size = NES_NIC_WQ_SIZE;
-	for (counter = 0; counter < NES_NIC_WQ_SIZE; counter++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (counter = 0; counter < NES_NIC_WQ_SIZE; counter++) {
 		nic_sqe = &nesvnic->nic.sq_vbase[counter];
 		nic_sqe->wqe_words[NES_NIC_SQ_WQE_MISC_IDX] =
 				cpu_to_le32(NES_NIC_SQ_WQE_DISABLE_CHKSUM |
@@ -1733,6 +1782,12 @@ int nes_init_nic_qp(struct nes_device *n
 				cpu_to_le32((u32)nesvnic->nic.frag_paddr[counter]);
 		nic_sqe->wqe_words[NES_NIC_SQ_WQE_FRAG0_HIGH_IDX] =
 				cpu_to_le32((u32)((u64)nesvnic->nic.frag_paddr[counter] >> 32));
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 	}
 
 	nesvnic->get_cqp_request = nes_get_cqp_request;
@@ -1844,6 +1899,11 @@ int nes_init_nic_qp(struct nes_device *n
 	}
 
 	/* Populate the RQ */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (counter = 0; counter < (NES_NIC_WQ_SIZE - 1); counter++) {
 		skb = dev_alloc_skb(nesvnic->max_frame_size);
 		if (!skb) {
@@ -1867,6 +1927,12 @@ int nes_init_nic_qp(struct nes_device *n
 		nic_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_LOW_IDX]  = cpu_to_le32((u32)pmem);
 		nic_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_HIGH_IDX] = cpu_to_le32((u32)((u64)pmem >> 32));
 		nesvnic->nic.rx_skb[counter] = skb;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	wqe_count = NES_NIC_WQ_SIZE - 1;
@@ -2431,6 +2497,11 @@ static void nes_reset_link(struct nes_de
 	if (0x0000003d == (reset_value & 0x0000003d)) {
 		u32 pcs_control_status0, pcs_control_status1;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 10; i++) {
 			pcs_control_status0 = nes_read_indexed(nesdev, NES_IDX_PHY_PCS_CONTROL_STATUS0);
 			pcs_control_status1 = nes_read_indexed(nesdev, NES_IDX_PHY_PCS_CONTROL_STATUS0 + 0x200);
@@ -2441,6 +2512,12 @@ static void nes_reset_link(struct nes_de
 				continue;
 			else
 				break;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+			else {
+				break;
+			}
 		}
 		if (10 == i) {
 			u32temp = nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1);
diff -u -p a/infiniband/hw/nes/nes_mgt.c b/infiniband/hw/nes/nes_mgt.c
--- a/infiniband/hw/nes/nes_mgt.c
+++ b/infiniband/hw/nes/nes_mgt.c
@@ -154,12 +154,23 @@ static void nes_download_callback(struct
 	struct sk_buff *skb;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fpdu_info->frag_cnt; i++) {
 		skb = fpdu_info->frags[i].skb;
 		if (fpdu_info->frags[i].cmplt) {
 			nes_mgt_free_skb(nesdev, skb, PCI_DMA_TODEVICE);
 			nes_rem_ref_cm_node(nesqp->cm_node);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (fpdu_info->hdr_vbase)
@@ -377,6 +388,11 @@ static int get_fpdu_info(struct nes_devi
 	*pau_fpdu_info = fpdu_info;
 
 	/* Update skb's for next pass */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < frag_cnt; i++) {
 		cb = (struct nes_rskb_cb *)&frags[i].skb->cb[0];
 		skb_pull(frags[i].skb, frags[i].frag_len);
@@ -392,7 +408,13 @@ static int get_fpdu_info(struct nes_devi
 			tcph = (struct tcphdr *)(((char *)iph) + (4 * iph->ihl));
 			tcph->seq = cpu_to_be32(nesqp->pau_rcv_nxt);
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+				break;
+			}
+		}
 
 out:
 	if (rc) {
@@ -909,6 +931,11 @@ int nes_init_mgt_qp(struct nes_device *n
 	init_waitqueue_head(&nesvnic->mgt_wait_queue);
 	nesvnic->mgt_thread = kthread_run(mgt_thread, nesvnic, "nes_mgt_thread");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NES_MGT_QP_COUNT; i++) {
 		mgtvnic->nesvnic = nesvnic;
 		mgtvnic->mgt.qp_id = nesdev->mac_index + NES_MGT_QP_OFFSET + i;
@@ -1023,6 +1050,11 @@ int nes_init_mgt_qp(struct nes_device *n
 		}
 
 		/* Populate the RQ */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (counter = 0; counter < (NES_MGT_WQ_COUNT - 1); counter++) {
 			skb = dev_alloc_skb(nesvnic->max_frame_size);
 			if (!skb) {
@@ -1044,6 +1076,12 @@ int nes_init_mgt_qp(struct nes_device *n
 			mgt_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_LOW_IDX] = cpu_to_le32((u32)pmem);
 			mgt_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_HIGH_IDX] = cpu_to_le32((u32)((u64)pmem >> 32));
 			mgtvnic->mgt.rx_skb[counter] = skb;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		init_timer(&mgtvnic->rq_wqes_timer);
@@ -1066,6 +1104,12 @@ int nes_init_mgt_qp(struct nes_device *n
 		mgt_vbase += mgt_mem_size;
 		mgt_pbase += mgt_mem_size;
 		nesvnic->mgtvnic[i] = mgtvnic++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return 0;
 }
@@ -1087,6 +1131,11 @@ void nes_destroy_mgt(struct nes_vnic *ne
 
 	/* Free remaining NIC receive buffers */
 	first_mgtvnic = nesvnic->mgtvnic[0];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NES_MGT_QP_COUNT; i++) {
 		mgtvnic = nesvnic->mgtvnic[i];
 		if (mgtvnic == NULL)
@@ -1149,6 +1198,12 @@ void nes_destroy_mgt(struct nes_vnic *ne
 				  mgtvnic->mgt.qp_id);
 
 		nesvnic->mgtvnic[i] = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nesvnic->mgt_vbase) {
diff -u -p a/infiniband/hw/nes/nes_nic.c b/infiniband/hw/nes/nes_nic.c
--- a/infiniband/hw/nes/nes_nic.c
+++ b/infiniband/hw/nes/nes_nic.c
@@ -439,7 +439,12 @@ static int nes_nic_send(struct sk_buff *
 	} else {
 		/* Deal with Fragments */
 		nesnic->tx_skb[nesnic->sq_head] = skb;
-		for (skb_fragment_index = 0; skb_fragment_index < skb_shinfo(skb)->nr_frags;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (skb_fragment_index = 0; skb_fragment_index < skb_shinfo(skb)->nr_frags;
 				skb_fragment_index++) {
 			skb_frag_t *frag =
 				&skb_shinfo(skb)->frags[skb_fragment_index];
@@ -453,6 +458,12 @@ static int nes_nic_send(struct sk_buff *
 			wqe_fragment_index++;
 			if (wqe_fragment_index < 5)
 				wqe_fragment_length[wqe_fragment_index] = 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
@@ -559,7 +570,12 @@ sq_no_longer_full:
 			}
 tso_sq_no_longer_full:
 			/* Map all the buffers */
-			for (tso_frag_count=0; tso_frag_count < skb_shinfo(skb)->nr_frags;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (tso_frag_count=0; tso_frag_count < skb_shinfo(skb)->nr_frags;
 					tso_frag_count++) {
 				skb_frag_t *frag =
 					&skb_shinfo(skb)->frags[tso_frag_count];
@@ -567,6 +583,12 @@ tso_sq_no_longer_full:
 					skb_frag_dma_map(&nesdev->pcidev->dev,
 							 frag, 0, skb_frag_size(frag),
 							 DMA_TO_DEVICE);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 
 			tso_frag_index = 0;
@@ -575,7 +597,12 @@ tso_sq_no_longer_full:
 			nhoffset = skb_network_header(skb) - skb->data;
 			original_first_length = hoffset + ((((struct tcphdr *)skb_transport_header(skb))->doff)<<2);
 
-			for (wqe_count=0; wqe_count<((u32)wqes_needed); wqe_count++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (wqe_count=0; wqe_count<((u32)wqes_needed); wqe_count++) {
 				tso_wqe_length = 0;
 				nic_sqe = &nesnic->sq_vbase[nesnic->sq_head];
 				wqe_fragment_length =
@@ -669,6 +696,12 @@ tso_sq_no_longer_full:
 				curr_tcp_seq += tso_wqe_length;
 				nesnic->sq_head++;
 				nesnic->sq_head &= nesnic->sq_size-1;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		} else {
 			nesvnic->linearized_skbs++;
diff -u -p a/infiniband/hw/nes/nes_utils.c b/infiniband/hw/nes/nes_utils.c
--- a/infiniband/hw/nes/nes_utils.c
+++ b/infiniband/hw/nes/nes_utils.c
@@ -787,6 +787,11 @@ void nes_mh_fix(unsigned long parm)
 			break;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i=0; i<4; i++) {
 			used_chunks_mask <<= 8;
 			if (nesvnic->qp_nic_index[i] != 0xff) {
@@ -797,6 +802,12 @@ void nes_mh_fix(unsigned long parm)
 			}
 			temp_used_chunks_tx >>= 8;
 			temp_last_used_chunks_tx >>= 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if ((mac_tx_frames_low) || (mac_tx_frames_high) ||
 			(!(used_chunks_tx&used_chunks_mask)) ||
@@ -928,6 +939,11 @@ void nes_dump_mem(unsigned int dump_debu
 
 	num_ascii = 0;
 	num_hex = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (num_char = 0; num_char < length; num_char++) {
 		if (num_ascii == 8) {
 			ascii_buf[num_ascii++] = ' ';
@@ -952,6 +968,12 @@ void nes_dump_mem(unsigned int dump_debu
 			num_ascii = 0;
 			num_hex = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* output the rest */
diff -u -p a/infiniband/hw/nes/nes_verbs.c b/infiniband/hw/nes/nes_verbs.c
--- a/infiniband/hw/nes/nes_verbs.c
+++ b/infiniband/hw/nes/nes_verbs.c
@@ -1886,26 +1886,59 @@ static u32 root_256(struct nes_device *n
 			return 0;
 
 		leaf_pbl = (u64)root_vpbl->pbl_pbase;
-		for (i = 0; i < 16; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < 16; i++) {
 			new_root->pbl_vbase[i].pa_low =
 				cpu_to_le32((u32)leaf_pbl);
 			new_root->pbl_vbase[i].pa_high =
 				cpu_to_le32((u32)((((u64)leaf_pbl) >> 32)));
 			leaf_pbl += 256;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 3; i >= 0; i--) {
 			j = i * 16;
 			root_vpbl->pbl_vbase[j] = root_vpbl->pbl_vbase[i];
 			leaf_pbl = le32_to_cpu(root_vpbl->pbl_vbase[j].pa_low) +
 			    (((u64)le32_to_cpu(root_vpbl->pbl_vbase[j].pa_high))
 				<< 32);
-			for (k = 1; k < 16; k++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (k = 1; k < 16; k++) {
 				leaf_pbl += 256;
 				root_vpbl->pbl_vbase[j + k].pa_low =
 						cpu_to_le32((u32)leaf_pbl);
 				root_vpbl->pbl_vbase[j + k].pa_high =
 				    cpu_to_le32((u32)((((u64)leaf_pbl) >> 32)));
+				    if (_cur < timeout) {
+						rdstcll(_cur);
+				    }
+				    else {
+						break;
+				    }
+			}
+			if (_cur < timeout) {
+				    rdstcll(_cur);
+			}
+			else {
+				    break;
 			}
 		}
 	}
@@ -2142,6 +2175,11 @@ static struct ib_mr *nes_reg_phys_mr(str
 		return ERR_PTR(-ENOMEM);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_phys_buf; i++) {
 
 		if ((i & 0x01FF) == 0) {
@@ -2218,6 +2256,12 @@ static struct ib_mr *nes_reg_phys_mr(str
 		vpbl.pbl_vbase[cur_pbl_index].pa_low = cpu_to_le32((u32)buffer_list[i].addr & PAGE_MASK);
 		vpbl.pbl_vbase[cur_pbl_index++].pa_high =
 				cpu_to_le32((u32)((((u64)buffer_list[i].addr) >> 32)));
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 	}
 
 	stag = stag_index << 8;
@@ -2258,9 +2302,20 @@ static struct ib_mr *nes_reg_phys_mr(str
 		/* single PBL case */
 		pci_free_consistent(nesdev->pcidev, 4096, vpbl.pbl_vbase, vpbl.pbl_pbase);
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i=0; i<root_pbl_index; i++) {
 			pci_free_consistent(nesdev->pcidev, 4096, root_vpbl.leaf_vpbl[i].pbl_vbase,
 					root_vpbl.leaf_vpbl[i].pbl_pbase);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		kfree(root_vpbl.leaf_vpbl);
 		pci_free_consistent(nesdev->pcidev, 8192, root_vpbl.pbl_vbase,
@@ -2379,6 +2434,11 @@ static struct ib_mr *nes_reg_user_mr(str
 			list_for_each_entry(chunk, &region->chunk_list, list) {
 				nes_debug(NES_DBG_MR, "Chunk: nents = %u, nmap = %u .\n",
 						chunk->nents, chunk->nmap);
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (nmap_index = 0; nmap_index < chunk->nmap; ++nmap_index) {
 					if (sg_dma_address(&chunk->page_list[nmap_index]) & ~PAGE_MASK) {
 						ib_umem_release(region);
@@ -2403,6 +2463,11 @@ static struct ib_mr *nes_reg_user_mr(str
 					region_length += sg_dma_len(&chunk->page_list[nmap_index]);
 					chunk_pages = sg_dma_len(&chunk->page_list[nmap_index]) >> 12;
 					region_length -= skip_pages << 12;
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					for (page_index=skip_pages; page_index < chunk_pages; page_index++) {
 						skip_pages = 0;
 						if ((page_count!=0)&&(page_count<<12)-(region->offset&(4096-1))>=region->length)
@@ -2495,6 +2560,18 @@ static struct ib_mr *nes_reg_user_mr(str
 								(page_index*4096))) >> 32)));
 						cur_pbl_index++;
 						page_count++;
+						if (_cur < timeout) {
+								rdstcll(_cur);
+						}
+						else {
+								break;
+						}
+					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
 					}
 				}
 			}
@@ -2546,10 +2623,21 @@ static struct ib_mr *nes_reg_user_mr(str
 				pci_free_consistent(nesdev->pcidev, 4096, vpbl.pbl_vbase,
 						vpbl.pbl_pbase);
 			} else {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (page_index=0; page_index<root_pbl_index; page_index++) {
 					pci_free_consistent(nesdev->pcidev, 4096,
 							root_vpbl.leaf_vpbl[page_index].pbl_vbase,
 							root_vpbl.leaf_vpbl[page_index].pbl_pbase);
+					if (_cur < timeout) {
+				rdstcll(_cur);
+					}
+					else {
+				break;
+					}
 				}
 				kfree(root_vpbl.leaf_vpbl);
 				pci_free_consistent(nesdev->pcidev, 8192, root_vpbl.pbl_vbase,
@@ -2610,11 +2698,21 @@ static struct ib_mr *nes_reg_user_mr(str
 				  (void *) nespbl->pbl_vbase, nespbl->user_base);
 
 			list_for_each_entry(chunk, &region->chunk_list, list) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (nmap_index = 0; nmap_index < chunk->nmap; ++nmap_index) {
 					chunk_pages = sg_dma_len(&chunk->page_list[nmap_index]) >> 12;
 					chunk_pages += (sg_dma_len(&chunk->page_list[nmap_index]) & (4096-1)) ? 1 : 0;
 					nespbl->page = sg_page(&chunk->page_list[0]);
-					for (page_index=0; page_index<chunk_pages; page_index++) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+						for (page_index=0; page_index<chunk_pages; page_index++) {
 						((__le32 *)pbl)[0] = cpu_to_le32((u32)
 								(sg_dma_address(&chunk->page_list[nmap_index])+
 								(page_index*4096)));
@@ -2625,6 +2723,18 @@ static struct ib_mr *nes_reg_user_mr(str
 								(unsigned long long)*pbl,
 								le32_to_cpu(((__le32 *)pbl)[1]), le32_to_cpu(((__le32 *)pbl)[0]));
 						pbl++;
+						if (_cur < timeout) {
+						rdstcll(_cur);
+						}
+						else {
+						break;
+						}
+					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
 					}
 				}
 			}
@@ -3238,7 +3348,12 @@ fill_wqe_sg_send(struct nes_hw_qp_wqe *w
 {
 	int sge_index;
 	int total_payload_length = 0;
-	for (sge_index = 0; sge_index < ib_wr->num_sge; sge_index++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (sge_index = 0; sge_index < ib_wr->num_sge; sge_index++) {
 		set_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_FRAG0_LOW_IDX+(sge_index*4),
 			ib_wr->sg_list[sge_index].addr);
 		set_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_LENGTH0_IDX + (sge_index*4),
@@ -3250,6 +3365,12 @@ fill_wqe_sg_send(struct nes_hw_qp_wqe *w
 			set_wqe_32bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_STAG0_IDX + (sge_index*4), 0);
 
 		total_payload_length += ib_wr->sg_list[sge_index].length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	nes_debug(NES_DBG_IW_TX, "UC UC UC, sending total_payload_length=%u \n",
 			total_payload_length);
@@ -3591,7 +3712,12 @@ static int nes_post_recv(struct ib_qp *i
 		set_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_COMP_SCRATCH_LOW_IDX,
 					u64temp);
 		total_payload_length = 0;
-		for (sge_index=0; sge_index < ib_wr->num_sge; sge_index++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (sge_index=0; sge_index < ib_wr->num_sge; sge_index++) {
 			set_wqe_64bit_value(wqe->wqe_words, NES_IWARP_RQ_WQE_FRAG0_LOW_IDX+(sge_index*4),
 					ib_wr->sg_list[sge_index].addr);
 			set_wqe_32bit_value(wqe->wqe_words, NES_IWARP_RQ_WQE_LENGTH0_IDX+(sge_index*4),
@@ -3600,6 +3726,12 @@ static int nes_post_recv(struct ib_qp *i
 					ib_wr->sg_list[sge_index].lkey);
 
 			total_payload_length += ib_wr->sg_list[sge_index].length;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		set_wqe_32bit_value(wqe->wqe_words, NES_IWARP_RQ_WQE_TOTAL_PAYLOAD_IDX,
 					total_payload_length);
@@ -4017,6 +4149,11 @@ int nes_register_ofa_device(struct nes_i
 	nesibdev->max_qp = (nesadapter->max_qp-NES_FIRST_QPN) / nesadapter->port_count;
 	nesibdev->max_pd = nesadapter->max_pd / nesadapter->port_count;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(nes_dev_attributes); ++i) {
 		ret = device_create_file(&nesibdev->ibdev.dev, nes_dev_attributes[i]);
 		if (ret) {
@@ -4028,6 +4165,12 @@ int nes_register_ofa_device(struct nes_i
 			ib_unregister_device(&nesibdev->ibdev);
 			return ret;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	nesvnic->of_device_registered = 1;
@@ -4044,8 +4187,19 @@ static void nes_unregister_ofa_device(st
 	struct nes_vnic *nesvnic = nesibdev->nesvnic;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(nes_dev_attributes); ++i) {
 		device_remove_file(&nesibdev->ibdev.dev, nes_dev_attributes[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nesvnic->of_device_registered) {
diff -u -p a/infiniband/hw/cxgb3/cxio_resource.c b/infiniband/hw/cxgb3/cxio_resource.c
--- a/infiniband/hw/cxgb3/cxio_resource.c
+++ b/infiniband/hw/cxgb3/cxio_resource.c
@@ -65,6 +65,11 @@ static int __cxio_init_resource_fifo(str
 		random_bytes = random32();
 		for (i = 0; i < RANDOM_SIZE; i++)
 			rarray[i] = i + skip_low;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = skip_low + RANDOM_SIZE; i < nr - skip_high; i++) {
 			if (j >= RANDOM_SIZE) {
 				j = 0;
@@ -76,6 +81,12 @@ static int __cxio_init_resource_fifo(str
 				sizeof(u32));
 			rarray[idx] = i;
 			j++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		for (i = 0; i < RANDOM_SIZE; i++)
 			kfifo_in(fifo,
diff -u -p a/infiniband/hw/cxgb3/iwch_provider.c b/infiniband/hw/cxgb3/iwch_provider.c
--- a/infiniband/hw/cxgb3/iwch_provider.c
+++ b/infiniband/hw/cxgb3/iwch_provider.c
@@ -660,19 +660,42 @@ static struct ib_mr *iwch_reg_user_mr(st
 
 	i = n = 0;
 
-	list_for_each_entry(chunk, &mhp->umem->chunk_list, list)
-		for (j = 0; j < chunk->nmap; ++j) {
-			len = sg_dma_len(&chunk->page_list[j]) >> shift;
-			for (k = 0; k < len; ++k) {
-				pages[i++] = cpu_to_be64(sg_dma_address(
+	list_for_each_entry(chunk, &mhp->umem->chunk_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; j < chunk->nmap; ++j) {
+				len = sg_dma_len(&chunk->page_list[j]) >> shift;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (k = 0; k < len; ++k) {
+						pages[i++] = cpu_to_be64(sg_dma_address(
 					&chunk->page_list[j]) +
 					mhp->umem->page_size * k);
-				if (i == PAGE_SIZE / sizeof *pages) {
-					err = iwch_write_pbl(mhp, pages, i, n);
-					if (err)
-						goto pbl_done;
-					n += i;
-					i = 0;
+					if (i == PAGE_SIZE / sizeof *pages) {
+						err = iwch_write_pbl(mhp, pages, i, n);
+						if (err)
+							goto pbl_done;
+						n += i;
+						i = 0;
+					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
 				}
 			}
 		}
@@ -1439,12 +1462,23 @@ int iwch_register_device(struct iwch_dev
 	if (ret)
 		goto bail1;
 
-	for (i = 0; i < ARRAY_SIZE(iwch_class_attributes); ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(iwch_class_attributes); ++i) {
 		ret = device_create_file(&dev->ibdev.dev,
 					 iwch_class_attributes[i]);
 		if (ret) {
 			goto bail2;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 bail2:
diff -u -p a/infiniband/hw/cxgb3/iwch_qp.c b/infiniband/hw/cxgb3/iwch_qp.c
--- a/infiniband/hw/cxgb3/iwch_qp.c
+++ b/infiniband/hw/cxgb3/iwch_qp.c
@@ -69,6 +69,11 @@ static int build_rdma_send(union t3_wr *
 	wqe->send.reserved[1] = 0;
 	wqe->send.reserved[2] = 0;
 	plen = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < wr->num_sge; i++) {
 		if ((plen + wr->sg_list[i].length) < plen)
 			return -EMSGSIZE;
@@ -77,6 +82,12 @@ static int build_rdma_send(union t3_wr *
 		wqe->send.sgl[i].stag = cpu_to_be32(wr->sg_list[i].lkey);
 		wqe->send.sgl[i].len = cpu_to_be32(wr->sg_list[i].length);
 		wqe->send.sgl[i].to = cpu_to_be64(wr->sg_list[i].addr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	wqe->send.num_sgle = cpu_to_be32(wr->num_sge);
 	*flit_cnt = 4 + ((wr->num_sge) << 1);
@@ -106,6 +117,11 @@ static int build_rdma_write(union t3_wr
 		*flit_cnt = 6;
 	} else {
 		plen = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wr->num_sge; i++) {
 			if ((plen + wr->sg_list[i].length) < plen) {
 				return -EMSGSIZE;
@@ -117,6 +133,12 @@ static int build_rdma_write(union t3_wr
 			    cpu_to_be32(wr->sg_list[i].length);
 			wqe->write.sgl[i].to =
 			    cpu_to_be64(wr->sg_list[i].addr);
+			    if (_cur < timeout) {
+			    rdstcll(_cur);
+			    }
+			    else {
+			    break;
+			    }
 		}
 		wqe->write.num_sgle = cpu_to_be32(wr->num_sge);
 		*flit_cnt = 5 + ((wr->num_sge) << 1);
@@ -166,6 +188,11 @@ static int build_fastreg(union t3_wr *wq
 		V_FR_TYPE(TPT_VATO) |
 		V_FR_PERMS(iwch_ib_to_tpt_access(wr->wr.fast_reg.access_flags)));
 	p = &wqe->fastreg.pbl_addrs[0];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < wr->wr.fast_reg.page_list_len; i++, p++) {
 
 		/* If we need a 2nd WR, then set it up */
@@ -181,6 +208,12 @@ static int build_fastreg(union t3_wr *wq
 			p = &wqe->pbl_frag.pbl_addrs[0];
 		}
 		*p = cpu_to_be64((u64)wr->wr.fast_reg.page_list->page_list[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*flit_cnt = 5 + wr->wr.fast_reg.page_list_len;
 	if (*flit_cnt > 15)
@@ -203,6 +236,11 @@ static int iwch_sgl2pbl_map(struct iwch_
 	int i;
 	struct iwch_mr *mhp;
 	u64 offset;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_sgle; i++) {
 
 		mhp = get_mhp(rhp, (sg_list[i].lkey) >> 8);
@@ -240,6 +278,12 @@ static int iwch_sgl2pbl_map(struct iwch_
 			        rhp->rdev.rnic_info.pbl_base) >> 3) +
 			      (offset >> (12 + mhp->attr.page_size));
 		page_size[i] = mhp->attr.page_size;
+		if (_cur < timeout) {
+			      rdstcll(_cur);
+		}
+		else {
+			      break;
+		}
 	}
 	return 0;
 }
@@ -260,6 +304,11 @@ static int build_rdma_recv(struct iwch_q
 	wqe->recv.pagesz[2] = page_size[2];
 	wqe->recv.pagesz[3] = page_size[3];
 	wqe->recv.num_sgle = cpu_to_be32(wr->num_sge);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < wr->num_sge; i++) {
 		wqe->recv.sgl[i].stag = cpu_to_be32(wr->sg_list[i].lkey);
 		wqe->recv.sgl[i].len = cpu_to_be32(wr->sg_list[i].length);
@@ -270,6 +319,12 @@ static int build_rdma_recv(struct iwch_q
 
 		/* pbl_addr is the adapters address in the PBL */
 		wqe->recv.pbl_addr[i] = cpu_to_be32(pbl_addr[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	for (; i < T3_MAX_SGE; i++) {
 		wqe->recv.sgl[i].stag = 0;
@@ -309,6 +364,11 @@ static int build_zero_stag_recv(struct i
 
 	wqe->recv.num_sgle = cpu_to_be32(wr->num_sge);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < wr->num_sge; i++) {
 
 		/*
@@ -332,6 +392,12 @@ static int build_zero_stag_recv(struct i
 		wqe->recv.sgl[i].to = cpu_to_be64(wr->sg_list[i].addr);
 		wqe->recv.pbl_addr[i] = cpu_to_be32(pbl_offset);
 		pbl_offset += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	for (; i < T3_MAX_SGE; i++) {
 		wqe->recv.pagesz[i] = 0;
diff -u -p a/infiniband/hw/cxgb3/cxio_hal.c b/infiniband/hw/cxgb3/cxio_hal.c
--- a/infiniband/hw/cxgb3/cxio_hal.c
+++ b/infiniband/hw/cxgb3/cxio_hal.c
@@ -609,6 +609,11 @@ static int cxio_hal_ctrl_qp_write_mem(st
 	     __func__, rdev_p->ctrl_qp.wptr, rdev_p->ctrl_qp.rptr, len,
 	     nr_wqe, data, addr);
 	utx_len = 3;		/* in 32B unit */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nr_wqe; i++) {
 		if (Q_FULL(rdev_p->ctrl_qp.rptr, rdev_p->ctrl_qp.wptr,
 		           T3_CTRL_QP_SIZE_LOG2)) {
@@ -686,6 +691,12 @@ static int cxio_hal_ctrl_qp_write_mem(st
 			ring_doorbell(rdev_p->ctrl_qp.doorbell, T3_CTRL_QP_ID);
 		len -= 96;
 		rdev_p->ctrl_qp.wptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/infiniband/hw/cxgb3/iwch_mem.c b/infiniband/hw/cxgb3/iwch_mem.c
--- a/infiniband/hw/cxgb3/iwch_mem.c
+++ b/infiniband/hw/cxgb3/iwch_mem.c
@@ -144,6 +144,11 @@ int build_phys_page_list(struct ib_phys_
 
 	mask = 0;
 	*total_size = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_phys_buf; ++i) {
 		if (i != 0 && buffer_list[i].addr & ~PAGE_MASK)
 			return -EINVAL;
@@ -160,6 +165,12 @@ int build_phys_page_list(struct ib_phys_
 		else
 			mask |= (buffer_list[i].addr + buffer_list[i].size +
 				PAGE_SIZE - 1) & PAGE_MASK;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (*total_size > 0xFFFFFFFFULL)
diff -u -p a/infiniband/hw/cxgb4/qp.c b/infiniband/hw/cxgb4/qp.c
--- a/infiniband/hw/cxgb4/qp.c
+++ b/infiniband/hw/cxgb4/qp.c
@@ -295,6 +295,11 @@ static int build_immd(struct t4_sq *sq,
 	int rem, len;
 
 	dstp = (u8 *)immdp->data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < wr->num_sge; i++) {
 		if ((plen + wr->sg_list[i].length) > max)
 			return -EMSGSIZE;
@@ -313,6 +318,12 @@ static int build_immd(struct t4_sq *sq,
 			srcp += len;
 			rem -= len;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	len = roundup(plen + sizeof *immdp, 16) - (plen + sizeof *immdp);
 	if (len)
@@ -334,6 +345,11 @@ static int build_isgl(__be64 *queue_star
 	u32 plen = 0;
 	__be64 *flitp = (__be64 *)isglp->sge;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_sge; i++) {
 		if ((plen + sg_list[i].length) < plen)
 			return -EMSGSIZE;
@@ -345,6 +361,12 @@ static int build_isgl(__be64 *queue_star
 		*flitp = cpu_to_be64(sg_list[i].addr);
 		if (++flitp == queue_end)
 			flitp = queue_start;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	*flitp = (__force __be64)0;
 	isglp->op = FW_RI_DATA_ISGL;
@@ -539,11 +561,22 @@ static int build_fastreg(struct t4_sq *s
 	imdp->immdlen = cpu_to_be32(pbllen);
 	p = (__be64 *)(imdp + 1);
 	rem = pbllen;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < wr->wr.fast_reg.page_list_len; i++) {
 		*p = cpu_to_be64((u64)wr->wr.fast_reg.page_list->page_list[i]);
 		rem -= sizeof *p;
 		if (++p == (__be64 *)&sq->queue[sq->size])
 			p = (__be64 *)sq->queue;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	BUG_ON(rem < 0);
 	while (rem) {
diff -u -p a/infiniband/hw/cxgb4/resource.c b/infiniband/hw/cxgb4/resource.c
--- a/infiniband/hw/cxgb4/resource.c
+++ b/infiniband/hw/cxgb4/resource.c
@@ -63,6 +63,11 @@ static int __c4iw_init_resource_fifo(str
 		random_bytes = random32();
 		for (i = 0; i < RANDOM_SIZE; i++)
 			rarray[i] = i + skip_low;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = skip_low + RANDOM_SIZE; i < nr - skip_high; i++) {
 			if (j >= RANDOM_SIZE) {
 				j = 0;
@@ -74,6 +79,12 @@ static int __c4iw_init_resource_fifo(str
 				sizeof(u32));
 			rarray[idx] = i;
 			j++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		for (i = 0; i < RANDOM_SIZE; i++)
 			kfifo_in(fifo,
@@ -185,12 +196,23 @@ u32 c4iw_get_cqid(struct c4iw_rdev *rdev
 					&rdev->resource.qid_fifo_lock);
 		if (!qid)
 			goto out;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = qid+1; i & rdev->qpmask; i++) {
 			entry = kmalloc(sizeof *entry, GFP_KERNEL);
 			if (!entry)
 				goto out;
 			entry->qid = i;
 			list_add_tail(&entry->entry, &uctx->cqids);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/*
@@ -202,12 +224,23 @@ u32 c4iw_get_cqid(struct c4iw_rdev *rdev
 			goto out;
 		entry->qid = qid;
 		list_add_tail(&entry->entry, &uctx->qpids);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = qid+1; i & rdev->qpmask; i++) {
 			entry = kmalloc(sizeof *entry, GFP_KERNEL);
 			if (!entry)
 				goto out;
 			entry->qid = i;
 			list_add_tail(&entry->entry, &uctx->qpids);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 out:
@@ -249,12 +282,23 @@ u32 c4iw_get_qpid(struct c4iw_rdev *rdev
 					&rdev->resource.qid_fifo_lock);
 		if (!qid)
 			goto out;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = qid+1; i & rdev->qpmask; i++) {
 			entry = kmalloc(sizeof *entry, GFP_KERNEL);
 			if (!entry)
 				goto out;
 			entry->qid = i;
 			list_add_tail(&entry->entry, &uctx->qpids);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/*
@@ -266,12 +310,23 @@ u32 c4iw_get_qpid(struct c4iw_rdev *rdev
 			goto out;
 		entry->qid = qid;
 		list_add_tail(&entry->entry, &uctx->cqids);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = qid; i & rdev->qpmask; i++) {
 			entry = kmalloc(sizeof *entry, GFP_KERNEL);
 			if (!entry)
 				goto out;
 			entry->qid = i;
 			list_add_tail(&entry->entry, &uctx->cqids);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 out:
diff -u -p a/infiniband/hw/cxgb4/provider.c b/infiniband/hw/cxgb4/provider.c
--- a/infiniband/hw/cxgb4/provider.c
+++ b/infiniband/hw/cxgb4/provider.c
@@ -502,11 +502,22 @@ int c4iw_register_device(struct c4iw_dev
 	if (ret)
 		goto bail1;
 
-	for (i = 0; i < ARRAY_SIZE(c4iw_class_attributes); ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(c4iw_class_attributes); ++i) {
 		ret = device_create_file(&dev->ibdev.dev,
 					 c4iw_class_attributes[i]);
 		if (ret)
 			goto bail2;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	return 0;
 bail2:
diff -u -p a/infiniband/hw/cxgb4/cm.c b/infiniband/hw/cxgb4/cm.c
--- a/infiniband/hw/cxgb4/cm.c
+++ b/infiniband/hw/cxgb4/cm.c
@@ -388,10 +388,21 @@ static void send_flowc(struct c4iw_ep *e
 	/* Pad WR to 16 byte boundary */
 	flowc->mnemval[8].mnemonic = 0;
 	flowc->mnemval[8].val = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 9; i++) {
 		flowc->mnemval[i].r4[0] = 0;
 		flowc->mnemval[i].r4[1] = 0;
 		flowc->mnemval[i].r4[2] = 0;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	set_wr_txq(skb, CPL_PRIORITY_DATA, ep->txq_idx);
diff -u -p a/infiniband/hw/cxgb4/mem.c b/infiniband/hw/cxgb4/mem.c
--- a/infiniband/hw/cxgb4/mem.c
+++ b/infiniband/hw/cxgb4/mem.c
@@ -52,7 +52,12 @@ static int write_adapter_mem(struct c4iw
 	PDBG("%s addr 0x%x len %u\n", __func__, addr, len);
 	num_wqe = DIV_ROUND_UP(len, C4IW_MAX_INLINE_SIZE);
 	c4iw_init_wr_wait(&wr_wait);
-	for (i = 0; i < num_wqe; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < num_wqe; i++) {
 
 		copy_len = len > C4IW_MAX_INLINE_SIZE ? C4IW_MAX_INLINE_SIZE :
 			   len;
@@ -101,6 +106,12 @@ static int write_adapter_mem(struct c4iw
 		if (ret)
 			return ret;
 		len -= C4IW_MAX_INLINE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = c4iw_wait_for_reply(rdev, &wr_wait, 0, 0, __func__);
@@ -294,6 +305,11 @@ static int build_phys_page_list(struct i
 
 	mask = 0;
 	*total_size = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_phys_buf; ++i) {
 		if (i != 0 && buffer_list[i].addr & ~PAGE_MASK)
 			return -EINVAL;
@@ -310,6 +326,12 @@ static int build_phys_page_list(struct i
 		else
 			mask |= (buffer_list[i].addr + buffer_list[i].size +
 				PAGE_SIZE - 1) & PAGE_MASK;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (*total_size > 0xFFFFFFFFULL)
@@ -592,21 +614,44 @@ struct ib_mr *c4iw_reg_user_mr(struct ib
 
 	i = n = 0;
 
-	list_for_each_entry(chunk, &mhp->umem->chunk_list, list)
-		for (j = 0; j < chunk->nmap; ++j) {
-			len = sg_dma_len(&chunk->page_list[j]) >> shift;
-			for (k = 0; k < len; ++k) {
-				pages[i++] = cpu_to_be64(sg_dma_address(
+	list_for_each_entry(chunk, &mhp->umem->chunk_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; j < chunk->nmap; ++j) {
+				len = sg_dma_len(&chunk->page_list[j]) >> shift;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (k = 0; k < len; ++k) {
+					pages[i++] = cpu_to_be64(sg_dma_address(
 					&chunk->page_list[j]) +
 					mhp->umem->page_size * k);
-				if (i == PAGE_SIZE / sizeof *pages) {
-					err = write_pbl(&mhp->rhp->rdev,
-					      pages,
-					      mhp->attr.pbl_addr + (n << 3), i);
-					if (err)
-						goto pbl_done;
-					n += i;
-					i = 0;
+					if (i == PAGE_SIZE / sizeof *pages) {
+						err = write_pbl(&mhp->rhp->rdev,
+						pages,
+						mhp->attr.pbl_addr + (n << 3), i);
+						if (err)
+							goto pbl_done;
+						n += i;
+						i = 0;
+					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
 				}
 			}
 		}
diff -u -p a/infiniband/hw/mthca/mthca_allocator.c b/infiniband/hw/mthca/mthca_allocator.c
--- a/infiniband/hw/mthca/mthca_allocator.c
+++ b/infiniband/hw/mthca/mthca_allocator.c
@@ -166,9 +166,20 @@ int mthca_array_init(struct mthca_array
 	if (!array->page_list)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < npage; ++i) {
 		array->page_list[i].page = NULL;
 		array->page_list[i].used = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -243,7 +254,12 @@ int mthca_buf_alloc(struct mthca_dev *de
 		for (i = 0; i < npages; ++i)
 			buf->page_list[i].buf = NULL;
 
-		for (i = 0; i < npages; ++i) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < npages; ++i) {
 			buf->page_list[i].buf =
 				dma_alloc_coherent(&dev->pdev->dev, PAGE_SIZE,
 						   &t, GFP_KERNEL);
@@ -254,6 +270,12 @@ int mthca_buf_alloc(struct mthca_dev *de
 			dma_unmap_addr_set(&buf->page_list[i], mapping, t);
 
 			clear_page(buf->page_list[i].buf);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/infiniband/hw/mthca/mthca_reset.c b/infiniband/hw/mthca/mthca_reset.c
--- a/infiniband/hw/mthca/mthca_reset.c
+++ b/infiniband/hw/mthca/mthca_reset.c
@@ -101,6 +101,11 @@ int mthca_reset(struct mthca_dev *mdev)
 		goto out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 64; ++i) {
 		if (i == 22 || i == 23)
 			continue;
@@ -110,6 +115,12 @@ int mthca_reset(struct mthca_dev *mdev)
 				  "PCI header, aborting.\n");
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	hca_pcix_cap = pci_find_capability(mdev->pdev, PCI_CAP_ID_PCIX);
@@ -124,6 +135,11 @@ int mthca_reset(struct mthca_dev *mdev)
 			goto out;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 64; ++i) {
 			if (i == 22 || i == 23)
 				continue;
@@ -133,6 +149,12 @@ int mthca_reset(struct mthca_dev *mdev)
 					  "PCI header, aborting.\n");
 				goto out;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+				}
 		}
 		bridge_pcix_cap = pci_find_capability(bridge, PCI_CAP_ID_PCIX);
 		if (!bridge_pcix_cap) {
@@ -167,7 +189,12 @@ int mthca_reset(struct mthca_dev *mdev)
 		u32 v;
 		int c = 0;
 
-		for (c = 0; c < 100; ++c) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (c = 0; c < 100; ++c) {
 			if (pci_read_config_dword(bridge ? bridge : mdev->pdev, 0, &v)) {
 				err = -ENODEV;
 				mthca_err(mdev, "Couldn't access HCA after reset, "
@@ -179,6 +206,12 @@ int mthca_reset(struct mthca_dev *mdev)
 				goto good;
 
 			msleep(100);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		err = -ENODEV;
@@ -208,6 +241,11 @@ good:
 		 * Bridge control register is at 0x3e, so we'll
 		 * naturally restore it last in this loop.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 16; ++i) {
 			if (i * 4 == PCI_COMMAND)
 				continue;
@@ -218,6 +256,12 @@ good:
 					  "aborting.\n", i);
 				goto out;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (pci_write_config_dword(bridge, PCI_COMMAND,
@@ -258,6 +302,11 @@ good:
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; ++i) {
 		if (i * 4 == PCI_COMMAND)
 			continue;
@@ -268,6 +317,12 @@ good:
 				  "aborting.\n", i);
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (pci_write_config_dword(mdev->pdev, PCI_COMMAND,
diff -u -p a/infiniband/hw/mthca/mthca_mr.c b/infiniband/hw/mthca/mthca_mr.c
--- a/infiniband/hw/mthca/mthca_mr.c
+++ b/infiniband/hw/mthca/mthca_mr.c
@@ -151,6 +151,11 @@ static int mthca_buddy_init(struct mthca
 	if (!buddy->bits || !buddy->num_free)
 		goto err_out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= buddy->max_order; ++i) {
 		s = BITS_TO_LONGS(1 << (buddy->max_order - i));
 		buddy->bits[i] = kmalloc(s * sizeof (long), GFP_KERNEL);
@@ -158,6 +163,12 @@ static int mthca_buddy_init(struct mthca
 			goto err_out_free;
 		bitmap_zero(buddy->bits[i],
 			    1 << (buddy->max_order - i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	set_bit(0, buddy->bits[buddy->max_order]);
@@ -479,12 +490,23 @@ int mthca_mr_alloc(struct mthca_dev *dev
 
 	if (0) {
 		mthca_dbg(dev, "Dumping MPT entry %08x:\n", mr->ibmr.lkey);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < sizeof (struct mthca_mpt_entry) / 4; ++i) {
 			if (i % 4 == 0)
 				printk("[%02x] ", i * 4);
 			printk(" %08x", be32_to_cpu(((__be32 *) mpt_entry)[i]));
 			if ((i + 1) % 4 == 0)
 				printk("\n");
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
@@ -642,12 +664,23 @@ int mthca_fmr_alloc(struct mthca_dev *de
 
 	if (0) {
 		mthca_dbg(dev, "Dumping MPT entry %08x:\n", mr->ibmr.lkey);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < sizeof (struct mthca_mpt_entry) / 4; ++i) {
 			if (i % 4 == 0)
 				printk("[%02x] ", i * 4);
 			printk(" %08x", be32_to_cpu(((__be32 *) mpt_entry)[i]));
 			if ((i + 1) % 4 == 0)
 				printk("\n");
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
+		break;
+				}
 		}
 	}
 
@@ -701,10 +734,22 @@ static inline int mthca_check_fmr(struct
 		return -EINVAL;
 
 	/* Trust the user not to pass misaligned data in page_list */
-	if (0)
-		for (i = 0; i < list_len; ++i) {
-			if (page_list[i] & ~page_mask)
-				return -EINVAL;
+	if (0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < list_len; ++i) {
+				if (page_list[i] & ~page_mask)
+					return -EINVAL;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 		}
 
 	if (fmr->maps >= fmr->attr.max_maps)
@@ -735,10 +780,21 @@ int mthca_tavor_map_phys_fmr(struct ib_f
 
 	writeb(MTHCA_MPT_STATUS_SW, fmr->mem.tavor.mpt);
 
-	for (i = 0; i < list_len; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < list_len; ++i) {
 		__be64 mtt_entry = cpu_to_be64(page_list[i] |
 					       MTHCA_MTT_FLAG_PRESENT);
 		mthca_write64_raw(mtt_entry, fmr->mem.tavor.mtts + i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	mpt_entry.lkey   = cpu_to_be32(key);
diff -u -p a/infiniband/hw/mthca/mthca_eq.c b/infiniband/hw/mthca/mthca_eq.c
--- a/infiniband/hw/mthca/mthca_eq.c
+++ b/infiniband/hw/mthca/mthca_eq.c
@@ -496,7 +496,12 @@ static int mthca_create_eq(struct mthca_
 		goto err_out_free;
 	eq_context = mailbox->buf;
 
-	for (i = 0; i < npages; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < npages; ++i) {
 		eq->page_list[i].buf = dma_alloc_coherent(&dev->pdev->dev,
 							  PAGE_SIZE, &t, GFP_KERNEL);
 		if (!eq->page_list[i].buf)
@@ -506,6 +511,12 @@ static int mthca_create_eq(struct mthca_
 		dma_unmap_addr_set(&eq->page_list[i], mapping, t);
 
 		clear_page(eq->page_list[i].buf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i < eq->nent; ++i)
@@ -606,12 +617,23 @@ static void mthca_free_eq(struct mthca_d
 
 	if (0) {
 		mthca_dbg(dev, "Dumping EQ context %02x:\n", eq->eqn);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < sizeof (struct mthca_eq_context) / 4; ++i) {
 			if (i % 4 == 0)
 				printk("[%02x] ", i * 4);
 			printk(" %08x", be32_to_cpup(mailbox->buf + i * 4));
 			if ((i + 1) % 4 == 0)
 				printk("\n");
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
@@ -819,7 +841,12 @@ int mthca_init_eq_table(struct mthca_dev
 			[MTHCA_EQ_CMD]   = DRV_NAME "-cmd"
 		};
 
-		for (i = 0; i < MTHCA_NUM_EQ; ++i) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < MTHCA_NUM_EQ; ++i) {
 			snprintf(dev->eq_table.eq[i].irq_name,
 				 IB_DEVICE_NAME_MAX,
 				 "%s@pci:%s", eq_name[i],
@@ -833,6 +860,12 @@ int mthca_init_eq_table(struct mthca_dev
 			if (err)
 				goto err_out_cmd;
 			dev->eq_table.eq[i].have_irq = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		snprintf(dev->eq_table.eq[0].irq_name, IB_DEVICE_NAME_MAX,
diff -u -p a/infiniband/hw/mthca/mthca_provider.c b/infiniband/hw/mthca/mthca_provider.c
--- a/infiniband/hw/mthca/mthca_provider.c
+++ b/infiniband/hw/mthca/mthca_provider.c
@@ -907,6 +907,11 @@ static struct ib_mr *mthca_reg_phys_mr(s
 
 	mask = buffer_list[0].addr ^ *iova_start;
 	total_size = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_phys_buf; ++i) {
 		if (i != 0)
 			mask |= buffer_list[i].addr;
@@ -914,6 +919,12 @@ static struct ib_mr *mthca_reg_phys_mr(s
 			mask |= buffer_list[i].addr + buffer_list[i].size;
 
 		total_size += buffer_list[i].size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (mask & ~PAGE_MASK)
@@ -1031,22 +1042,45 @@ static struct ib_mr *mthca_reg_user_mr(s
 
 	write_mtt_size = min(mthca_write_mtt_size(dev), (int) (PAGE_SIZE / sizeof *pages));
 
-	list_for_each_entry(chunk, &mr->umem->chunk_list, list)
-		for (j = 0; j < chunk->nmap; ++j) {
-			len = sg_dma_len(&chunk->page_list[j]) >> shift;
-			for (k = 0; k < len; ++k) {
-				pages[i++] = sg_dma_address(&chunk->page_list[j]) +
-					mr->umem->page_size * k;
+	list_for_each_entry(chunk, &mr->umem->chunk_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; j < chunk->nmap; ++j) {
+				len = sg_dma_len(&chunk->page_list[j]) >> shift;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (k = 0; k < len; ++k) {
+						pages[i++] = sg_dma_address(&chunk->page_list[j]) +
+						mr->umem->page_size * k;
 				/*
 				 * Be friendly to write_mtt and pass it chunks
 				 * of appropriate size.
 				 */
-				if (i == write_mtt_size) {
-					err = mthca_write_mtt(dev, mr->mtt, n, pages, i);
-					if (err)
-						goto mtt_done;
-					n += i;
-					i = 0;
+					if (i == write_mtt_size) {
+						err = mthca_write_mtt(dev, mr->mtt, n, pages, i);
+						if (err)
+			goto mtt_done;
+						n += i;
+						i = 0;
+					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
 				}
 			}
 		}
@@ -1358,13 +1392,24 @@ int mthca_register_device(struct mthca_d
 	if (ret)
 		return ret;
 
-	for (i = 0; i < ARRAY_SIZE(mthca_dev_attributes); ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(mthca_dev_attributes); ++i) {
 		ret = device_create_file(&dev->ib_dev.dev,
 					 mthca_dev_attributes[i]);
 		if (ret) {
 			ib_unregister_device(&dev->ib_dev);
 			return ret;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mthca_start_catas_poll(dev);
diff -u -p a/infiniband/hw/mthca/mthca_qp.c b/infiniband/hw/mthca/mthca_qp.c
--- a/infiniband/hw/mthca/mthca_qp.c
+++ b/infiniband/hw/mthca/mthca_qp.c
@@ -1191,6 +1191,11 @@ static int mthca_alloc_qp_common(struct
 		int size = (sizeof (struct mthca_next_seg) +
 			    qp->rq.max_gs * sizeof (struct mthca_data_seg)) / 16;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < qp->rq.max; ++i) {
 			next = get_recv_wqe(qp, i);
 			next->nda_op = cpu_to_be32(((i + 1) & (qp->rq.max - 1)) <<
@@ -1201,19 +1206,47 @@ static int mthca_alloc_qp_common(struct
 			     (void *) scatter < (void *) next + (1 << qp->rq.wqe_shift);
 			     ++scatter)
 				scatter->lkey = cpu_to_be32(MTHCA_INVAL_LKEY);
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < qp->sq.max; ++i) {
 			next = get_send_wqe(qp, i);
 			next->nda_op = cpu_to_be32((((i + 1) & (qp->sq.max - 1)) <<
 						    qp->sq.wqe_shift) +
 						   qp->send_wqe_offset);
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < qp->rq.max; ++i) {
 			next = get_recv_wqe(qp, i);
 			next->nda_op = htonl((((i + 1) % qp->rq.max) <<
 					      qp->rq.wqe_shift) | 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	}
@@ -1626,6 +1659,11 @@ int mthca_tavor_post_send(struct ib_qp *
 
 	ind = qp->sq.next_ind;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nreq = 0; wr; ++nreq, wr = wr->next) {
 		if (mthca_wq_overflow(&qp->sq, nreq, qp->ibqp.send_cq)) {
 			mthca_err(dev, "SQ %06x full (%u head, %u tail,"
@@ -1730,10 +1768,21 @@ int mthca_tavor_post_send(struct ib_qp *
 			goto out;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wr->num_sge; ++i) {
 			mthca_set_data_seg(wqe, wr->sg_list + i);
 			wqe  += sizeof (struct mthca_data_seg);
 			size += sizeof (struct mthca_data_seg) / 16;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Add one more inline data segment for ICRC */
@@ -1774,7 +1823,13 @@ int mthca_tavor_post_send(struct ib_qp *
 		++ind;
 		if (unlikely(ind >= qp->sq.max))
 			ind -= qp->sq.max;
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
 
 out:
 	if (likely(nreq)) {
@@ -1827,6 +1882,11 @@ int mthca_tavor_post_receive(struct ib_q
 
 	ind = qp->rq.next_ind;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nreq = 0; wr; wr = wr->next) {
 		if (mthca_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {
 			mthca_err(dev, "RQ %06x full (%u head, %u tail,"
@@ -1855,10 +1915,21 @@ int mthca_tavor_post_receive(struct ib_q
 			goto out;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wr->num_sge; ++i) {
 			mthca_set_data_seg(wqe, wr->sg_list + i);
 			wqe  += sizeof (struct mthca_data_seg);
 			size += sizeof (struct mthca_data_seg) / 16;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		qp->wrid[ind] = wr->wr_id;
@@ -1886,7 +1957,13 @@ int mthca_tavor_post_receive(struct ib_q
 			qp->rq.next_ind = ind;
 			qp->rq.head += MTHCA_TAVOR_MAX_WQES_PER_RECV_DB;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 out:
 	if (likely(nreq)) {
@@ -1941,6 +2018,11 @@ int mthca_arbel_post_send(struct ib_qp *
 
 	ind = qp->sq.head & (qp->sq.max - 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nreq = 0; wr; ++nreq, wr = wr->next) {
 		if (unlikely(nreq == MTHCA_ARBEL_MAX_WQES_PER_SEND_DB)) {
 			nreq = 0;
@@ -2071,10 +2153,21 @@ int mthca_arbel_post_send(struct ib_qp *
 			goto out;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wr->num_sge; ++i) {
 			mthca_set_data_seg(wqe, wr->sg_list + i);
 			wqe  += sizeof (struct mthca_data_seg);
 			size += sizeof (struct mthca_data_seg) / 16;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Add one more inline data segment for ICRC */
@@ -2115,7 +2208,13 @@ int mthca_arbel_post_send(struct ib_qp *
 		++ind;
 		if (unlikely(ind >= qp->sq.max))
 			ind -= qp->sq.max;
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
 
 out:
 	if (likely(nreq)) {
@@ -2168,6 +2267,11 @@ int mthca_arbel_post_receive(struct ib_q
 
 	ind = qp->rq.head & (qp->rq.max - 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nreq = 0; wr; ++nreq, wr = wr->next) {
 		if (mthca_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {
 			mthca_err(dev, "RQ %06x full (%u head, %u tail,"
@@ -2191,9 +2295,20 @@ int mthca_arbel_post_receive(struct ib_q
 			goto out;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wr->num_sge; ++i) {
 			mthca_set_data_seg(wqe, wr->sg_list + i);
 			wqe += sizeof (struct mthca_data_seg);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		if (i < qp->rq.max_gs)
@@ -2204,7 +2319,13 @@ int mthca_arbel_post_receive(struct ib_q
 		++ind;
 		if (unlikely(ind >= qp->rq.max))
 			ind -= qp->rq.max;
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
 out:
 	if (likely(nreq)) {
 		qp->rq.head += nreq;
@@ -2275,7 +2396,12 @@ int mthca_init_qp_table(struct mthca_dev
 		return err;
 	}
 
-	for (i = 0; i < 2; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 2; ++i) {
 		err = mthca_CONF_SPECIAL_QP(dev, i ? IB_QPT_GSI : IB_QPT_SMI,
 				    dev->qp_table.sqp_start + i * 2);
 		if (err) {
@@ -2283,6 +2409,12 @@ int mthca_init_qp_table(struct mthca_dev
 				   "%d, aborting.\n", err);
 			goto err_out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
diff -u -p a/infiniband/hw/mthca/mthca_profile.c b/infiniband/hw/mthca/mthca_profile.c
--- a/infiniband/hw/mthca/mthca_profile.c
+++ b/infiniband/hw/mthca/mthca_profile.c
@@ -112,12 +112,23 @@ s64 mthca_make_profile(struct mthca_dev
 	profile[MTHCA_RES_UARC].num  = request->num_uar;
 	profile[MTHCA_RES_UDAV].num  = request->num_udav;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MTHCA_RES_NUM; ++i) {
 		profile[i].type     = i;
 		profile[i].log_num  = max(ffs(profile[i].num) - 1, 0);
 		profile[i].size    *= profile[i].num;
 		if (mthca_is_memfree(dev))
 			profile[i].size = max(profile[i].size, (u64) PAGE_SIZE);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (mthca_is_memfree(dev)) {
@@ -134,15 +145,32 @@ s64 mthca_make_profile(struct mthca_dev
 	 * resources aligned to their size and pack them without gaps
 	 * using the sorted order.
 	 */
-	for (i = MTHCA_RES_NUM; i > 0; --i)
-		for (j = 1; j < i; ++j) {
-			if (profile[j].size > profile[j - 1].size) {
-				tmp            = profile[j];
-				profile[j]     = profile[j - 1];
-				profile[j - 1] = tmp;
+	for (i = MTHCA_RES_NUM; i > 0; --i) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 1; j < i; ++j) {
+				if (profile[j].size > profile[j - 1].size) {
+					tmp            = profile[j];
+					profile[j]     = profile[j - 1];
+					profile[j - 1] = tmp;
+				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MTHCA_RES_NUM; ++i) {
 		if (profile[i].size) {
 			profile[i].start = mem_base + total_size;
@@ -163,6 +191,12 @@ s64 mthca_make_profile(struct mthca_dev
 				  i, profile[i].type, profile[i].log_num,
 				  (unsigned long long) profile[i].start,
 				  (unsigned long long) profile[i].size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (mthca_is_memfree(dev))
@@ -173,6 +207,11 @@ s64 mthca_make_profile(struct mthca_dev
 			  (int) (total_size >> 10), (int) (mem_avail >> 10),
 			  (int) ((mem_avail - total_size) >> 10));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MTHCA_RES_NUM; ++i) {
 		switch (profile[i].type) {
 		case MTHCA_RES_QP:
@@ -252,6 +291,12 @@ s64 mthca_make_profile(struct mthca_dev
 		default:
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/infiniband/hw/mthca/mthca_mad.c b/infiniband/hw/mthca/mthca_mad.c
--- a/infiniband/hw/mthca/mthca_mad.c
+++ b/infiniband/hw/mthca/mthca_mad.c
@@ -289,27 +289,50 @@ int mthca_create_agents(struct mthca_dev
 
 	spin_lock_init(&dev->sm_lock);
 
-	for (p = 0; p < dev->limits.num_ports; ++p)
-		for (q = 0; q <= 1; ++q) {
-			agent = ib_register_mad_agent(&dev->ib_dev, p + 1,
-						      q ? IB_QPT_GSI : IB_QPT_SMI,
-						      NULL, 0, send_handler,
-						      NULL, NULL);
-			if (IS_ERR(agent)) {
-				ret = PTR_ERR(agent);
-				goto err;
+	for (p = 0; p < dev->limits.num_ports; ++p) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (q = 0; q <= 1; ++q) {
+				agent = ib_register_mad_agent(&dev->ib_dev, p + 1,
+				q ? IB_QPT_GSI : IB_QPT_SMI,
+					NULL, 0, send_handler,
+					NULL, NULL);
+				if (IS_ERR(agent)) {
+							ret = PTR_ERR(agent);
+							goto err;
+				}
+				dev->send_agent[p][q] = agent;
+				if (_cur < timeout) {
+							rdstcll(_cur);
+				}
+				else {
+							break;
+				}
 			}
-			dev->send_agent[p][q] = agent;
 		}
 
 
-	for (p = 1; p <= dev->limits.num_ports; ++p) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (p = 1; p <= dev->limits.num_ports; ++p) {
 		ret = mthca_update_rate(dev, p);
 		if (ret) {
 			mthca_err(dev, "Failed to obtain port %d rate."
 				  " aborting.\n", p);
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -328,14 +351,36 @@ void mthca_free_agents(struct mthca_dev
 	struct ib_mad_agent *agent;
 	int p, q;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = 0; p < dev->limits.num_ports; ++p) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (q = 0; q <= 1; ++q) {
 			agent = dev->send_agent[p][q];
 			dev->send_agent[p][q] = NULL;
 			ib_unregister_mad_agent(agent);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (dev->sm_ah[p])
 			ib_destroy_ah(dev->sm_ah[p]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
diff -u -p a/infiniband/hw/mthca/mthca_cmd.c b/infiniband/hw/mthca/mthca_cmd.c
--- a/infiniband/hw/mthca/mthca_cmd.c
+++ b/infiniband/hw/mthca/mthca_cmd.c
@@ -563,9 +563,20 @@ int mthca_cmd_use_events(struct mthca_de
 	if (!dev->cmd.context)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dev->cmd.max_cmds; ++i) {
 		dev->cmd.context[i].token = i;
 		dev->cmd.context[i].next = i + 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev->cmd.context[dev->cmd.max_cmds - 1].next = -1;
@@ -670,6 +681,11 @@ static int mthca_map_cmd(struct mthca_de
 	memset(mailbox->buf, 0, MTHCA_MAILBOX_SIZE);
 	pages = mailbox->buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mthca_icm_first(icm, &iter);
 	     !mthca_icm_last(&iter);
 	     mthca_icm_next(&iter)) {
@@ -687,6 +703,11 @@ static int mthca_map_cmd(struct mthca_de
 			err = -EINVAL;
 			goto out;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < mthca_icm_size(&iter) >> lg; ++i) {
 			if (virt != -1) {
 				pages[nent * 2] = cpu_to_be64(virt);
@@ -706,6 +727,18 @@ static int mthca_map_cmd(struct mthca_de
 					goto out;
 				nent = 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -1791,6 +1824,11 @@ int mthca_MODIFY_QP(struct mthca_dev *de
 			int i;
 			mthca_dbg(dev, "Dumping QP context:\n");
 			printk(" %08x\n", be32_to_cpup(mailbox->buf));
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 0x100 / 4; ++i) {
 				if (i % 8 == 0)
 					printk("[%02x] ", i * 4);
@@ -1798,6 +1836,12 @@ int mthca_MODIFY_QP(struct mthca_dev *de
 				       be32_to_cpu(((__be32 *) mailbox->buf)[i + 2]));
 				if ((i + 1) % 8 == 0)
 					printk("\n");
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 		}
 
@@ -1808,6 +1852,11 @@ int mthca_MODIFY_QP(struct mthca_dev *de
 			int i;
 			mthca_dbg(dev, "Dumping QP context:\n");
 			printk("  opt param mask: %08x\n", be32_to_cpup(mailbox->buf));
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 0x100 / 4; ++i) {
 				if (i % 8 == 0)
 					printk("  [%02x] ", i * 4);
@@ -1815,6 +1864,12 @@ int mthca_MODIFY_QP(struct mthca_dev *de
 				       be32_to_cpu(((__be32 *) mailbox->buf)[i + 2]));
 				if ((i + 1) % 8 == 0)
 					printk("\n");
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 		}
 
diff -u -p a/infiniband/hw/mthca/mthca_memfree.c b/infiniband/hw/mthca/mthca_memfree.c
--- a/infiniband/hw/mthca/mthca_memfree.c
+++ b/infiniband/hw/mthca/mthca_memfree.c
@@ -78,10 +78,21 @@ static void mthca_free_icm_coherent(stru
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < chunk->npages; ++i) {
 		dma_free_coherent(&dev->pdev->dev, chunk->mem[i].length,
 				  lowmem_page_address(sg_page(&chunk->mem[i])),
 				  sg_dma_address(&chunk->mem[i]));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -295,6 +306,11 @@ void *mthca_table_find(struct mthca_icm_
 		goto out;
 
 	list_for_each_entry(chunk, &icm->chunk_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < chunk->npages; ++i) {
 			if (dma_handle && dma_offset >= 0) {
 				if (sg_dma_len(&chunk->mem[i]) > dma_offset)
@@ -310,6 +326,12 @@ void *mthca_table_find(struct mthca_icm_
 				goto out;
 			}
 			offset -= chunk->mem[i].length;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -324,10 +346,21 @@ int mthca_table_get_range(struct mthca_d
 	int inc = MTHCA_TABLE_CHUNK_SIZE / table->obj_size;
 	int i, err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i <= end; i += inc) {
 		err = mthca_table_get(dev, table, i);
 		if (err)
 			goto fail;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -382,6 +415,11 @@ struct mthca_icm_table *mthca_alloc_icm_
 	for (i = 0; i < num_icm; ++i)
 		table->icm[i] = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i * MTHCA_TABLE_CHUNK_SIZE < reserved * obj_size; ++i) {
 		chunk_size = MTHCA_TABLE_CHUNK_SIZE;
 		if ((i + 1) * MTHCA_TABLE_CHUNK_SIZE > nobj * obj_size)
@@ -404,6 +442,12 @@ struct mthca_icm_table *mthca_alloc_icm_
 		 * gets freed (since it contains reserved firmware objects).
 		 */
 		++table->icm[i]->refcount;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return table;
@@ -535,10 +579,21 @@ struct mthca_user_db_table *mthca_init_u
 		return ERR_PTR(-ENOMEM);
 
 	mutex_init(&db_tab->mutex);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < npages; ++i) {
 		db_tab->page[i].refcount = 0;
 		db_tab->page[i].uvirt    = 0;
 		sg_init_table(&db_tab->page[i].mem, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return db_tab;
@@ -552,12 +607,23 @@ void mthca_cleanup_user_db_tab(struct mt
 	if (!mthca_is_memfree(dev))
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dev->uar_table.uarc_size / MTHCA_ICM_PAGE_SIZE; ++i) {
 		if (db_tab->page[i].uvirt) {
 			mthca_UNMAP_ICM(dev, mthca_uarc_virt(dev, uar, i), 1);
 			pci_unmap_sg(dev->pdev, &db_tab->page[i].mem, 1, PCI_DMA_TODEVICE);
 			put_page(sg_page(&db_tab->page[i].mem));
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(db_tab);
@@ -741,6 +807,11 @@ void mthca_cleanup_db_tab(struct mthca_d
 	 * make a sweep through the doorbell pages and free any
 	 * leftover pages now.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < dev->db_tab->npages; ++i) {
 		if (!dev->db_tab->page[i].db_rec)
 			continue;
@@ -753,6 +824,12 @@ void mthca_cleanup_db_tab(struct mthca_d
 		dma_free_coherent(&dev->pdev->dev, MTHCA_ICM_PAGE_SIZE,
 				  dev->db_tab->page[i].db_rec,
 				  dev->db_tab->page[i].mapping);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(dev->db_tab->page);
diff -u -p a/infiniband/hw/mthca/mthca_srq.c b/infiniband/hw/mthca/mthca_srq.c
--- a/infiniband/hw/mthca/mthca_srq.c
+++ b/infiniband/hw/mthca/mthca_srq.c
@@ -172,6 +172,11 @@ static int mthca_alloc_srq_buf(struct mt
 	 * linked into the list of free WQEs.  In addition, set the
 	 * scatter list L_Keys to the sentry value of 0x100.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < srq->max; ++i) {
 		struct mthca_next_seg *next;
 
@@ -189,6 +194,12 @@ static int mthca_alloc_srq_buf(struct mt
 		     (void *) scatter < wqe + (1 << srq->wqe_shift);
 		     ++scatter)
 			scatter->lkey = cpu_to_be32(MTHCA_INVAL_LKEY);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	srq->last = get_wqe(srq, srq->max - 1);
@@ -518,9 +529,20 @@ int mthca_tavor_post_srq_recv(struct ib_
 			break;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wr->num_sge; ++i) {
 			mthca_set_data_seg(wqe, wr->sg_list + i);
 			wqe += sizeof (struct mthca_data_seg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (i < srq->max_gs)
@@ -610,9 +632,20 @@ int mthca_arbel_post_srq_recv(struct ib_
 			break;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < wr->num_sge; ++i) {
 			mthca_set_data_seg(wqe, wr->sg_list + i);
 			wqe += sizeof (struct mthca_data_seg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (i < srq->max_gs)
diff -u -p a/infiniband/hw/ehca/ehca_reqs.c b/infiniband/hw/ehca/ehca_reqs.c
--- a/infiniband/hw/ehca/ehca_reqs.c
+++ b/infiniband/hw/ehca/ehca_reqs.c
@@ -88,13 +88,24 @@ static inline int ehca_write_rwqe(struct
 	wqe_p->work_request_id = replace_wr_id(recv_wr->wr_id, rq_map_idx);
 	wqe_p->nr_of_data_seg = recv_wr->num_sge;
 
-	for (cnt_ds = 0; cnt_ds < recv_wr->num_sge; cnt_ds++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (cnt_ds = 0; cnt_ds < recv_wr->num_sge; cnt_ds++) {
 		wqe_p->u.all_rcv.sg_list[cnt_ds].vaddr =
 			recv_wr->sg_list[cnt_ds].addr;
 		wqe_p->u.all_rcv.sg_list[cnt_ds].lkey =
 			recv_wr->sg_list[cnt_ds].lkey;
 		wqe_p->u.all_rcv.sg_list[cnt_ds].length =
 			recv_wr->sg_list[cnt_ds].length;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ehca_debug_level >= 3) {
@@ -135,7 +146,12 @@ static void trace_send_wr_ud(const struc
 				     mad_hdr->resv,
 				     mad_hdr->attr_mod);
 		}
-		for (j = 0; j < send_wr->num_sge; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (j = 0; j < send_wr->num_sge; j++) {
 			u8 *data = (u8 *)abs_to_virt(sge->addr);
 			ehca_gen_dbg("send_wr#%x sge#%x addr=%p length=%x "
 				     "lkey=%x",
@@ -144,6 +160,12 @@ static void trace_send_wr_ud(const struc
 			ehca_dmp(data, sge->length, "send_wr#%x sge#%x",
 				 idx, j);
 			sge++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		} /* eof for j */
 		idx++;
 		send_wr = send_wr->next;
@@ -244,13 +266,24 @@ static inline int ehca_write_swqe(struct
 		 * omitted check of IB_SEND_INLINE
 		 * since HW does not support it
 		 */
-		for (idx = 0; idx < send_wr->num_sge; idx++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (idx = 0; idx < send_wr->num_sge; idx++) {
 			wqe_p->u.ud_av.sg_list[idx].vaddr =
 				send_wr->sg_list[idx].addr;
 			wqe_p->u.ud_av.sg_list[idx].lkey =
 				send_wr->sg_list[idx].lkey;
 			wqe_p->u.ud_av.sg_list[idx].length =
 				send_wr->sg_list[idx].length;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+			}
 		} /* eof for idx */
 		if (qp->qp_type == IB_QPT_SMI ||
 		    qp->qp_type == IB_QPT_GSI)
@@ -278,7 +311,12 @@ static inline int ehca_write_swqe(struct
 		 * since HW does not support it
 		 */
 		dma_length = 0;
-		for (idx = 0; idx < send_wr->num_sge; idx++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (idx = 0; idx < send_wr->num_sge; idx++) {
 			wqe_p->u.nud.sg_list[idx].vaddr =
 				send_wr->sg_list[idx].addr;
 			wqe_p->u.nud.sg_list[idx].lkey =
@@ -286,6 +324,12 @@ static inline int ehca_write_swqe(struct
 			wqe_p->u.nud.sg_list[idx].length =
 				send_wr->sg_list[idx].length;
 			dma_length += send_wr->sg_list[idx].length;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		} /* eof idx */
 		wqe_p->u.nud.atomic_1st_op_dma_len = dma_length;
 
diff -u -p a/infiniband/hw/ehca/ipz_pt_fn.c b/infiniband/hw/ehca/ipz_pt_fn.c
--- a/infiniband/hw/ehca/ipz_pt_fn.c
+++ b/infiniband/hw/ehca/ipz_pt_fn.c
@@ -80,12 +80,23 @@ void *ipz_qeit_eq_get_inc(struct ipz_que
 int ipz_queue_abs_to_offset(struct ipz_queue *queue, u64 addr, u64 *q_offset)
 {
 	int i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < queue->queue_length / queue->pagesize; i++) {
 		u64 page = (u64)virt_to_abs(queue->queue_pages[i]);
 		if (addr >= page && addr < page + queue->pagesize) {
 			*q_offset = addr - page + i * queue->pagesize;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EINVAL;
 }
@@ -109,10 +120,21 @@ static int alloc_queue_pages(struct ipz_
 		if (!kpage)
 			goto out;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (k = 0; k < PAGES_PER_KPAGE && f < nr_of_pages; k++) {
 			queue->queue_pages[f] = (struct ipz_page *)kpage;
 			kpage += EHCA_PAGESIZE;
 			f++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 1;
diff -u -p a/infiniband/hw/ehca/ehca_irq.c b/infiniband/hw/ehca/ehca_irq.c
--- a/infiniband/hw/ehca/ehca_irq.c
+++ b/infiniband/hw/ehca/ehca_irq.c
@@ -609,9 +609,20 @@ void ehca_process_eq(struct ehca_shca *s
 	if (unlikely(eqe_cnt == EHCA_EQE_CACHE_SIZE))
 		ehca_dbg(&shca->ib_device, "too many eqes for one irq event");
 	/* enable irq for new packets */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < eqe_cnt; i++) {
 		if (eq->eqe_cache[i].cq)
 			reset_eq_pending(eq->eqe_cache[i].cq);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	/* check eq */
 	spin_lock(&eq->spinlock);
diff -u -p a/infiniband/hw/ehca/ehca_cq.c b/infiniband/hw/ehca/ehca_cq.c
--- a/infiniband/hw/ehca/ehca_cq.c
+++ b/infiniband/hw/ehca/ehca_cq.c
@@ -212,6 +212,11 @@ struct ib_cq *ehca_create_cq(struct ib_d
 		goto create_cq_exit3;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (counter = 0; counter < param.act_pages; counter++) {
 		vpage = ipz_qpageit_get_inc(&my_cq->ipz_queue);
 		if (!vpage) {
@@ -262,6 +267,12 @@ struct ib_cq *ehca_create_cq(struct ib_d
 				goto create_cq_exit4;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ipz_qeit_reset(&my_cq->ipz_queue);
diff -u -p a/infiniband/hw/ehca/ehca_main.c b/infiniband/hw/ehca/ehca_main.c
--- a/infiniband/hw/ehca/ehca_main.c
+++ b/infiniband/hw/ehca/ehca_main.c
@@ -889,12 +889,23 @@ static int __devexit ehca_remove(struct
 
 	if (ehca_open_aqp1 == 1) {
 		int i;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < shca->num_ports; i++) {
 			ret = ehca_destroy_aqp1(&shca->sport[i]);
 			if (ret)
 				ehca_err(&shca->ib_device,
 					 "Cannot destroy AQP1 for port %x "
 					 "ret=%i", ret, i);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
diff -u -p a/infiniband/hw/ehca/ehca_qp.c b/infiniband/hw/ehca/ehca_qp.c
--- a/infiniband/hw/ehca/ehca_qp.c
+++ b/infiniband/hw/ehca/ehca_qp.c
@@ -313,7 +313,12 @@ static inline int init_qp_queue(struct e
 	}
 
 	/* register queue pages */
-	for (cnt = 0; cnt < nr_q_pages; cnt++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (cnt = 0; cnt < nr_q_pages; cnt++) {
 		vpage = ipz_qpageit_get_inc(queue);
 		if (!vpage) {
 			ehca_err(ib_dev, "ipz_qpageit_get_inc() "
@@ -350,6 +355,12 @@ static inline int init_qp_queue(struct e
 				goto init_qp_queue1;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ipz_qeit_reset(queue);
@@ -438,9 +449,20 @@ static void reset_queue_map(struct ehca_
 	qmap->tail = qmap->entries - 1;
 	qmap->left_to_poll = 0;
 	qmap->next_wqe_idx = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < qmap->entries; i++) {
 		qmap->map[i].reported = 1;
 		qmap->map[i].cqe_req = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1859,6 +1881,11 @@ void ehca_recover_sqp(struct ib_qp *sqp)
 
 	qp_parm = my_sqp->mod_qp_parm;
 	qp_parm_idx = my_sqp->mod_qp_parm_idx;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < qp_parm_idx; i++) {
 		attr = qp_parm[i].attr;
 		ret = internal_modify_qp(sqp, &attr, qp_parm[i].mask, 0);
@@ -1869,6 +1896,12 @@ void ehca_recover_sqp(struct ib_qp *sqp)
 		}
 		ehca_dbg(sqp->device, "SQP port=%x qp_num=%x in state=%x",
 			 port, sqp->qp_num, attr.qp_state);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* re-trigger posted recv wrs */
diff -u -p a/infiniband/hw/ehca/ehca_pd.c b/infiniband/hw/ehca/ehca_pd.c
--- a/infiniband/hw/ehca/ehca_pd.c
+++ b/infiniband/hw/ehca/ehca_pd.c
@@ -58,9 +58,20 @@ struct ib_pd *ehca_alloc_pd(struct ib_de
 		return ERR_PTR(-ENOMEM);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		INIT_LIST_HEAD(&pd->free[i]);
 		INIT_LIST_HEAD(&pd->full[i]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	mutex_init(&pd->lock);
 
@@ -88,6 +99,11 @@ int ehca_dealloc_pd(struct ib_pd *pd)
 	int i, leftovers = 0;
 	struct ipz_small_queue_page *page, *tmp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 2; i++) {
 		list_splice(&my_pd->full[i], &my_pd->free[i]);
 		list_for_each_entry_safe(page, tmp, &my_pd->free[i], list) {
@@ -95,6 +111,12 @@ int ehca_dealloc_pd(struct ib_pd *pd)
 			free_page(page->page);
 			kmem_cache_free(small_qp_cache, page);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (leftovers)
diff -u -p a/infiniband/hw/ehca/ehca_mrmw.c b/infiniband/hw/ehca/ehca_mrmw.c
--- a/infiniband/hw/ehca/ehca_mrmw.c
+++ b/infiniband/hw/ehca/ehca_mrmw.c
@@ -1118,6 +1118,11 @@ int ehca_reg_mr_rpages(struct ehca_shca
 	}
 
 	/* max MAX_RPAGES ehca mr pages per register call */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < NUM_CHUNKS(pginfo->num_hwpages, MAX_RPAGES); i++) {
 
 		if (i == NUM_CHUNKS(pginfo->num_hwpages, MAX_RPAGES) - 1) {
@@ -1179,6 +1184,12 @@ int ehca_reg_mr_rpages(struct ehca_shca
 			break;
 		} else
 			ret = 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	} /* end for(i) */
 
 
@@ -1550,10 +1561,21 @@ static u64 ehca_reg_mr_section(int top,
 
 	while (page < page_count) {
 		u64 rnum;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (rnum = 0; (rnum < MAX_RPAGES) && (page < page_count);
 		     rnum++) {
 			void *pg = sectbase + ((page++) * pginfo->hwpage_size);
 			kpage[rnum] = virt_to_abs(pg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		h_ret = hipz_h_register_rpage_mr(shca->ipz_hca_handle, mr,
@@ -1575,6 +1597,11 @@ static u64 ehca_reg_mr_sections(int top,
 	u64 hret = H_SUCCESS;
 	int idx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = 0; idx < EHCA_MAP_ENTRIES; idx++) {
 		if (!ehca_bmap_valid(ehca_bmap->top[top]->dir[dir]->ent[idx]))
 			continue;
@@ -1583,6 +1610,12 @@ static u64 ehca_reg_mr_sections(int top,
 					   pginfo);
 		if ((hret != H_SUCCESS) && (hret != H_PAGE_REGISTERED))
 				return hret;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 	}
 	return hret;
 }
@@ -1594,6 +1627,11 @@ static u64 ehca_reg_mr_dir_sections(int
 	u64 hret = H_SUCCESS;
 	int dir;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dir = 0; dir < EHCA_MAP_ENTRIES; dir++) {
 		if (!ehca_bmap_valid(ehca_bmap->top[top]->dir[dir]))
 			continue;
@@ -1601,6 +1639,12 @@ static u64 ehca_reg_mr_dir_sections(int
 		hret = ehca_reg_mr_sections(top, dir, kpage, shca, mr, pginfo);
 		if ((hret != H_SUCCESS) && (hret != H_PAGE_REGISTERED))
 				return hret;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 	}
 	return hret;
 }
@@ -1793,6 +1837,11 @@ int ehca_mr_chk_buf_and_calc_size(struct
 		return -EINVAL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_phys_buf; i++) {
 		if ((i > 0) && (pbuf->addr % PAGE_SIZE)) {
 			ehca_gen_err("bad address, i=%x pbuf->addr=%llx "
@@ -1809,6 +1858,12 @@ int ehca_mr_chk_buf_and_calc_size(struct
 		}
 		size_count += pbuf->size;
 		pbuf++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*size = size_count;
@@ -1834,7 +1889,12 @@ int ehca_fmr_check_page_list(struct ehca
 
 	/* each page must be aligned */
 	page = page_list;
-	for (i = 0; i < list_len; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < list_len; i++) {
 		if (*page % e_fmr->fmr_page_size) {
 			ehca_gen_err("bad page, i=%x *page=%llx page=%p fmr=%p "
 				     "fmr_page_size=%x", i, *page, page, e_fmr,
@@ -1842,6 +1902,12 @@ int ehca_fmr_check_page_list(struct ehca
 			return -EINVAL;
 		}
 		page++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1923,6 +1989,11 @@ static int ehca_check_kpages_per_ate(str
 				     u64 *prev_pgaddr)
 {
 	int t;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (t = start_idx; t <= end_idx; t++) {
 		u64 pgaddr = page_to_pfn(sg_page(&page_list[t])) << PAGE_SHIFT;
 		if (ehca_debug_level >= 3)
@@ -1935,6 +2006,12 @@ static int ehca_check_kpages_per_ate(str
 			return -EINVAL;
 		}
 		*prev_pgaddr = pgaddr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -2123,7 +2200,12 @@ static int ehca_set_pagebuf_fmr(struct e
 
 	/* loop over desired page_list entries */
 	fmrlist = pginfo->u.fmr.page_list + pginfo->u.fmr.next_listelem;
-	for (i = 0; i < number; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < number; i++) {
 		*kpage = phys_to_abs((*fmrlist & ~(pginfo->hwpage_size - 1)) +
 				     pginfo->next_hwpage * pginfo->hwpage_size);
 		if ( !(*kpage) ) {
@@ -2151,7 +2233,12 @@ static int ehca_set_pagebuf_fmr(struct e
 			unsigned int j;
 			u64 prev = *kpage;
 			/* check if adrs are contiguous */
-			for (j = 1; j < cnt_per_hwpage; j++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (j = 1; j < cnt_per_hwpage; j++) {
 				u64 p = phys_to_abs(fmrlist[j] &
 						    ~(pginfo->hwpage_size - 1));
 				if (prev + pginfo->u.fmr.fmr_pgsize != p) {
@@ -2161,12 +2248,24 @@ static int ehca_set_pagebuf_fmr(struct e
 					return -EINVAL;
 				}
 				prev = p;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			pginfo->kpage_cnt += cnt_per_hwpage;
 			pginfo->u.fmr.next_listelem += cnt_per_hwpage;
 			fmrlist += cnt_per_hwpage;
 		}
 		kpage++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return ret;
 }
@@ -2355,17 +2454,39 @@ void ehca_destroy_busmap(void)
 	if (!ehca_bmap)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (top = 0; top < EHCA_MAP_ENTRIES; top++) {
 		if (!ehca_bmap_valid(ehca_bmap->top[top]))
 			continue;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (dir = 0; dir < EHCA_MAP_ENTRIES; dir++) {
 			if (!ehca_bmap_valid(ehca_bmap->top[top]->dir[dir]))
 				continue;
 
 			kfree(ehca_bmap->top[top]->dir[dir]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kfree(ehca_bmap->top[top]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(ehca_bmap);
@@ -2390,6 +2511,11 @@ static int ehca_update_busmap(unsigned l
 
 	start_section = phys_to_abs(pfn * PAGE_SIZE) / EHCA_SECTSIZE;
 	end_section = phys_to_abs((pfn + nr_pages) * PAGE_SIZE) / EHCA_SECTSIZE;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start_section; i < end_section; i++) {
 		int ret;
 		top = ehca_calc_index(i, EHCA_TOP_INDEX_SHIFT);
@@ -2403,6 +2529,12 @@ static int ehca_update_busmap(unsigned l
 		}
 		ehca_bmap->top[top]->dir[dir]->ent[idx] = ehca_mr_len;
 		ehca_mr_len += EHCA_SECTSIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/infiniband/hw/ehca/hcp_if.c b/infiniband/hw/ehca/hcp_if.c
--- a/infiniband/hw/ehca/hcp_if.c
+++ b/infiniband/hw/ehca/hcp_if.c
@@ -127,7 +127,12 @@ static long ehca_plpar_hcall_norets(unsi
 		ehca_gen_dbg("opcode=%lx " HCALL7_REGS_FORMAT,
 			     opcode, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
 
-	for (i = 0; i < 5; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < 5; i++) {
 		/* serialize hCalls to work around firmware issue */
 		if (ehca_lock_hcalls)
 			spin_lock_irqsave(&hcall_lock, flags);
@@ -153,6 +158,12 @@ static long ehca_plpar_hcall_norets(unsi
 				ehca_gen_dbg("opcode=%lx ret=%li", opcode, ret);
 
 		return ret;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return H_BUSY;
@@ -179,6 +190,11 @@ static long ehca_plpar_hcall9(unsigned l
 			     arg1, arg2, arg3, arg4, arg5,
 			     arg6, arg7, arg8, arg9);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 5; i++) {
 		/* serialize hCalls to work around firmware issue */
 		if (ehca_lock_hcalls)
@@ -211,6 +227,12 @@ static long ehca_plpar_hcall9(unsigned l
 				     outs[4], outs[5], outs[6], outs[7],
 				     outs[8]);
 		return ret;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return H_BUSY;
diff -u -p a/infiniband/hw/ehca/ehca_uverbs.c b/infiniband/hw/ehca/ehca_uverbs.c
--- a/infiniband/hw/ehca/ehca_uverbs.c
+++ b/infiniband/hw/ehca/ehca_uverbs.c
@@ -141,6 +141,11 @@ static int ehca_mmap_queue(struct vm_are
 
 	vma->vm_flags |= VM_RESERVED;
 	start = vma->vm_start;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ofs = 0; ofs < queue->queue_length; ofs += PAGE_SIZE) {
 		u64 virt_addr = (u64)ipz_qeit_calc(queue, ofs);
 		page = virt_to_page(virt_addr);
@@ -150,6 +155,12 @@ static int ehca_mmap_queue(struct vm_are
 			return ret;
 		}
 		start += PAGE_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	vma->vm_private_data = mm_count;
 	(*mm_count)++;
diff -u -p a/infiniband/hw/ehca/ehca_eq.c b/infiniband/hw/ehca/ehca_eq.c
--- a/infiniband/hw/ehca/ehca_eq.c
+++ b/infiniband/hw/ehca/ehca_eq.c
@@ -94,6 +94,11 @@ int ehca_create_eq(struct ehca_shca *shc
 		goto create_eq_exit1;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nr_pages; i++) {
 		u64 rpage;
 
@@ -116,6 +121,12 @@ int ehca_create_eq(struct ehca_shca *shc
 			if (h_ret != H_PAGE_REGISTERED)
 				goto create_eq_exit2;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	ipz_qeit_reset(&eq->ipz_queue);
diff -u -p a/infiniband/hw/ehca/ehca_sqp.c b/infiniband/hw/ehca/ehca_sqp.c
--- a/infiniband/hw/ehca/ehca_sqp.c
+++ b/infiniband/hw/ehca/ehca_sqp.c
@@ -102,13 +102,24 @@ u64 ehca_define_sqp(struct ehca_shca *sh
 	if (ehca_nr_ports < 0) /* autodetect mode */
 		return H_SUCCESS;
 
-	for (counter = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (counter = 0;
 	     shca->sport[port - 1].port_state != IB_PORT_ACTIVE &&
 		     counter < ehca_port_act_time;
 	     counter++) {
 		ehca_dbg(&shca->ib_device, "... wait until port %x is active",
 			 port);
 		msleep_interruptible(1000);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (counter == ehca_port_act_time) {
diff -u -p a/infiniband/core/user_mad.c b/infiniband/core/user_mad.c
--- a/infiniband/core/user_mad.c
+++ b/infiniband/core/user_mad.c
@@ -289,7 +289,12 @@ static ssize_t copy_recv_mad(struct ib_u
 		offset = ib_get_mad_data_offset(recv_buf->mad->mad_hdr.mgmt_class);
 		max_seg_payload = sizeof (struct ib_mad) - offset;
 
-		for (left = packet->length - seg_payload, buf += seg_payload;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (left = packet->length - seg_payload, buf += seg_payload;
 		     left; left -= seg_payload, buf += seg_payload) {
 			recv_buf = container_of(recv_buf->list.next,
 						struct ib_mad_recv_buf, list);
@@ -297,6 +302,12 @@ static ssize_t copy_recv_mad(struct ib_u
 			if (copy_to_user(buf, ((void *) recv_buf->mad) + offset,
 					 seg_payload))
 				return -EFAULT;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 	}
 	return hdr_size(file) + packet->length;
@@ -380,11 +391,22 @@ static int copy_rmpp_mad(struct ib_mad_s
 		return -EFAULT;
 
 	/* All headers are in place.  Copy data segments. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (seg = 1, left = msg->data_len, buf += msg->hdr_len; left > 0;
 	     seg++, left -= msg->seg_size, buf += msg->seg_size) {
 		if (copy_from_user(ib_get_rmpp_segment(msg, seg), buf,
 				   min(left, msg->seg_size)))
 			return -EFAULT;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	return 0;
 }
@@ -1143,11 +1165,22 @@ static void ib_umad_add_one(struct ib_de
 	umad_dev->start_port = s;
 	umad_dev->end_port   = e;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = s; i <= e; ++i) {
 		umad_dev->port[i - s].umad_dev = umad_dev;
 
 		if (ib_umad_init_port(device, i, &umad_dev->port[i - s]))
 			goto err;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	ib_set_client_data(device, &umad_client, umad_dev);
diff -u -p a/infiniband/core/fmr_pool.c b/infiniband/core/fmr_pool.c
--- a/infiniband/core/fmr_pool.c
+++ b/infiniband/core/fmr_pool.c
@@ -309,7 +309,12 @@ struct ib_fmr_pool *ib_create_fmr_pool(s
 		if (pool->cache_bucket)
 			bytes_per_fmr += params->max_pages_per_fmr * sizeof (u64);
 
-		for (i = 0; i < params->pool_size; ++i) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < params->pool_size; ++i) {
 			fmr = kmalloc(bytes_per_fmr, GFP_KERNEL);
 			if (!fmr) {
 				printk(KERN_WARNING PFX "failed to allocate fmr "
@@ -332,6 +337,12 @@ struct ib_fmr_pool *ib_create_fmr_pool(s
 
 			list_add_tail(&fmr->list, &pool->free_list);
 			++pool->pool_size;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/infiniband/core/packer.c b/infiniband/core/packer.c
--- a/infiniband/core/packer.c
+++ b/infiniband/core/packer.c
@@ -66,6 +66,11 @@ void ib_pack(const struct ib_field
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < desc_len; ++i) {
 		if (desc[i].size_bits <= 32) {
 			int shift;
@@ -120,6 +125,12 @@ void ib_pack(const struct ib_field
 				       0,
 				       desc[i].size_bits / 8);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 EXPORT_SYMBOL(ib_pack);
@@ -153,6 +164,11 @@ void ib_unpack(const struct ib_field
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < desc_len; ++i) {
 		if (!desc[i].struct_size_bytes)
 			continue;
@@ -198,6 +214,12 @@ void ib_unpack(const struct ib_field
 			       desc[i].offset_bits / 8,
 			       desc[i].size_bits / 8);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL(ib_unpack);
diff -u -p a/infiniband/core/sysfs.c b/infiniband/core/sysfs.c
--- a/infiniband/core/sysfs.c
+++ b/infiniband/core/sysfs.c
@@ -479,7 +479,12 @@ alloc_group_attrs(ssize_t (*show)(struct
 	if (!tab_attr)
 		return NULL;
 
-	for (i = 0; i < len; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < len; i++) {
 		element = kzalloc(sizeof(struct port_table_attribute),
 				  GFP_KERNEL);
 		if (!element)
@@ -498,6 +503,12 @@ alloc_group_attrs(ssize_t (*show)(struct
 		sysfs_attr_init(&element->attr.attr);
 
 		tab_attr[i] = &element->attr.attr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return tab_attr;
@@ -818,10 +829,21 @@ int ib_device_register_sysfs(struct ib_d
 	if (ret)
 		goto err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(ib_class_attributes); ++i) {
 		ret = device_create_file(class_dev, ib_class_attributes[i]);
 		if (ret)
 			goto err_unregister;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	device->ports_parent = kobject_create_and_add("ports",
@@ -836,10 +858,21 @@ int ib_device_register_sysfs(struct ib_d
 		if (ret)
 			goto err_put;
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 1; i <= device->phys_port_cnt; ++i) {
 			ret = add_port(device, i, port_callback);
 			if (ret)
 				goto err_put;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
diff -u -p a/infiniband/core/device.c b/infiniband/core/device.c
--- a/infiniband/core/device.c
+++ b/infiniband/core/device.c
@@ -96,12 +96,23 @@ static int ib_device_check_mandatory(str
 	};
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(mandatory_table); ++i) {
 		if (!*(void **) ((void *) device + mandatory_table[i].offset)) {
 			printk(KERN_WARNING "Device %s is missing mandatory function %s\n",
 			       device->name, mandatory_table[i].name);
 			return -EINVAL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -241,13 +252,24 @@ static int read_port_table_lengths(struc
 	if (!device->pkey_tbl_len || !device->gid_tbl_len)
 		goto err;
 
-	for (port_index = 0; port_index < num_ports; ++port_index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (port_index = 0; port_index < num_ports; ++port_index) {
 		ret = ib_query_port(device, port_index + start_port(device),
 					tprops);
 		if (ret)
 			goto err;
 		device->pkey_tbl_len[port_index] = tprops->pkey_tbl_len;
 		device->gid_tbl_len[port_index]  = tprops->gid_tbl_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = 0;
@@ -676,7 +698,17 @@ int ib_find_gid(struct ib_device *device
 	union ib_gid tmp_gid;
 	int ret, port, i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (port = start_port(device); port <= end_port(device); ++port) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < device->gid_tbl_len[port - start_port(device)]; ++i) {
 			ret = ib_query_gid(device, port, i, &tmp_gid);
 			if (ret)
@@ -687,6 +719,18 @@ int ib_find_gid(struct ib_device *device
 					*index = i;
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -708,6 +752,11 @@ int ib_find_pkey(struct ib_device *devic
 	int ret, i;
 	u16 tmp_pkey;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < device->pkey_tbl_len[port_num - start_port(device)]; ++i) {
 		ret = ib_query_pkey(device, port_num, i, &tmp_pkey);
 		if (ret)
@@ -717,6 +766,12 @@ int ib_find_pkey(struct ib_device *devic
 			*index = i;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -ENOENT;
diff -u -p a/infiniband/core/sa_query.c b/infiniband/core/sa_query.c
--- a/infiniband/core/sa_query.c
+++ b/infiniband/core/sa_query.c
@@ -1022,6 +1022,11 @@ static void ib_sa_add_one(struct ib_devi
 	sa_dev->start_port = s;
 	sa_dev->end_port   = e;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= e - s; ++i) {
 		spin_lock_init(&sa_dev->port[i].ah_lock);
 		if (rdma_port_get_link_layer(device, i + 1) != IB_LINK_LAYER_INFINIBAND)
@@ -1038,6 +1043,12 @@ static void ib_sa_add_one(struct ib_devi
 			goto err;
 
 		INIT_WORK(&sa_dev->port[i].update_task, update_sm_ah);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ib_set_client_data(device, &sa_client, sa_dev);
@@ -1081,6 +1092,11 @@ static void ib_sa_remove_one(struct ib_d
 
 	flush_workqueue(ib_wq);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= sa_dev->end_port - sa_dev->start_port; ++i) {
 		if (rdma_port_get_link_layer(device, i + 1) == IB_LINK_LAYER_INFINIBAND) {
 			ib_unregister_mad_agent(sa_dev->port[i].agent);
@@ -1088,6 +1104,12 @@ static void ib_sa_remove_one(struct ib_d
 				kref_put(&sa_dev->port[i].sm_ah->ref, free_sm_ah);
 		}
 
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	kfree(sa_dev);
diff -u -p a/infiniband/core/multicast.c b/infiniband/core/multicast.c
--- a/infiniband/core/multicast.c
+++ b/infiniband/core/multicast.c
@@ -754,6 +754,11 @@ static void mcast_groups_event(struct mc
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&port->table); node; node = rb_next(node)) {
 		group = rb_entry(node, struct mcast_group, node);
 		spin_lock(&group->lock);
@@ -764,6 +769,12 @@ static void mcast_groups_event(struct mc
 		if (group->state != MCAST_GROUP_ERROR)
 			group->state = state;
 		spin_unlock(&group->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&port->lock, flags);
 }
@@ -818,6 +829,11 @@ static void mcast_add_one(struct ib_devi
 		dev->end_port = device->phys_port_cnt;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= dev->end_port - dev->start_port; i++) {
 		if (rdma_port_get_link_layer(device, dev->start_port + i) !=
 		    IB_LINK_LAYER_INFINIBAND)
@@ -830,6 +846,12 @@ static void mcast_add_one(struct ib_devi
 		init_completion(&port->comp);
 		atomic_set(&port->refcount, 1);
 		++count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!count) {
@@ -857,6 +879,11 @@ static void mcast_remove_one(struct ib_d
 	ib_unregister_event_handler(&dev->event_handler);
 	flush_workqueue(mcast_wq);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= dev->end_port - dev->start_port; i++) {
 		if (rdma_port_get_link_layer(device, dev->start_port + i) ==
 		    IB_LINK_LAYER_INFINIBAND) {
@@ -864,6 +891,12 @@ static void mcast_remove_one(struct ib_d
 			deref_port(port);
 			wait_for_completion(&port->comp);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(dev);
diff -u -p a/infiniband/core/uverbs_cmd.c b/infiniband/core/uverbs_cmd.c
--- a/infiniband/core/uverbs_cmd.c
+++ b/infiniband/core/uverbs_cmd.c
@@ -1945,7 +1945,12 @@ ssize_t ib_uverbs_post_send(struct ib_uv
 	is_ud = qp->qp_type == IB_QPT_UD;
 	sg_ind = 0;
 	last = NULL;
-	for (i = 0; i < cmd.wr_count; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < cmd.wr_count; ++i) {
 		if (copy_from_user(user_wr,
 				   buf + sizeof cmd + i * cmd.wqe_size,
 				   cmd.wqe_size)) {
@@ -2035,6 +2040,12 @@ ssize_t ib_uverbs_post_send(struct ib_uv
 			sg_ind += next->num_sge;
 		} else
 			next->sg_list = NULL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	resp.bad_wr = 0;
@@ -2092,7 +2103,12 @@ static struct ib_recv_wr *ib_uverbs_unma
 
 	sg_ind = 0;
 	last = NULL;
-	for (i = 0; i < wr_count; ++i) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < wr_count; ++i) {
 		if (copy_from_user(user_wr, buf + i * wqe_size,
 				   wqe_size)) {
 			ret = -EFAULT;
@@ -2135,6 +2151,12 @@ static struct ib_recv_wr *ib_uverbs_unma
 			sg_ind += next->num_sge;
 		} else
 			next->sg_list = NULL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	kfree(user_wr);
diff -u -p a/infiniband/core/cma.c b/infiniband/core/cma.c
--- a/infiniband/core/cma.c
+++ b/infiniband/core/cma.c
@@ -340,12 +340,23 @@ static int find_gid_port(struct ib_devic
 	if (err)
 		return 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < props.gid_tbl_len; ++i) {
 		err = ib_query_gid(device, port_num, i, &tmp);
 		if (err)
 			return 1;
 		if (!memcmp(&tmp, gid, sizeof tmp))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return -EAGAIN;
diff -u -p a/infiniband/core/umem.c b/infiniband/core/umem.c
--- a/infiniband/core/umem.c
+++ b/infiniband/core/umem.c
@@ -55,12 +55,23 @@ static void __ib_umem_release(struct ib_
 	list_for_each_entry_safe(chunk, tmp, &umem->chunk_list, list) {
 		ib_dma_unmap_sg(dev, chunk->page_list,
 				chunk->nents, DMA_BIDIRECTIONAL);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < chunk->nents; ++i) {
 			struct page *page = sg_page(&chunk->page_list[i]);
 
 			if (umem->writable && dirty)
 				set_page_dirty_lock(page);
 			put_page(page);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kfree(chunk);
@@ -173,11 +184,22 @@ struct ib_umem *ib_umem_get(struct ib_uc
 
 			chunk->nents = min_t(int, ret, IB_UMEM_MAX_PAGE_CHUNK);
 			sg_init_table(chunk->page_list, chunk->nents);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < chunk->nents; ++i) {
 				if (vma_list &&
 				    !is_vm_hugetlb_page(vma_list[i + off]))
 					umem->hugetlb = 0;
 				sg_set_page(&chunk->page_list[i], page_list[i + off], PAGE_SIZE, 0);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			chunk->nmap = ib_dma_map_sg_attrs(context->device,
diff -u -p a/infiniband/core/cm.c b/infiniband/core/cm.c
--- a/infiniband/core/cm.c
+++ b/infiniband/core/cm.c
@@ -3685,13 +3685,24 @@ static int cm_create_port_fs(struct cm_p
 		return ret;
 	}
 
-	for (i = 0; i < CM_COUNTER_GROUPS; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < CM_COUNTER_GROUPS; i++) {
 		ret = kobject_init_and_add(&port->counter_group[i].obj,
 					   &cm_counter_obj_type,
 					   &port->port_obj,
 					   "%s", counter_group_names[i]);
 		if (ret)
 			goto error;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -3749,6 +3760,11 @@ static void cm_add_one(struct ib_device
 	}
 
 	set_bit(IB_MGMT_METHOD_SEND, reg_req.method_mask);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i <= ib_device->phys_port_cnt; i++) {
 		port = kzalloc(sizeof *port, GFP_KERNEL);
 		if (!port)
@@ -3775,6 +3791,12 @@ static void cm_add_one(struct ib_device
 		ret = ib_modify_port(ib_device, i, 0, &port_modify);
 		if (ret)
 			goto error3;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	ib_set_client_data(ib_device, &cm_client, cm_dev);
 
@@ -3818,12 +3840,23 @@ static void cm_remove_one(struct ib_devi
 	list_del(&cm_dev->list);
 	write_unlock_irqrestore(&cm.device_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i <= ib_device->phys_port_cnt; i++) {
 		port = cm_dev->port[i-1];
 		ib_modify_port(ib_device, port->port_num, 0, &port_modify);
 		ib_unregister_mad_agent(port->mad_agent);
 		flush_workqueue(cm.wq);
 		cm_remove_port_fs(port);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	device_unregister(cm_dev->device);
 	kfree(cm_dev);
diff -u -p a/infiniband/core/mad.c b/infiniband/core/mad.c
--- a/infiniband/core/mad.c
+++ b/infiniband/core/mad.c
@@ -610,6 +610,11 @@ static void snoop_send(struct ib_mad_qp_
 	int i;
 
 	spin_lock_irqsave(&qp_info->snoop_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < qp_info->snoop_table_size; i++) {
 		mad_snoop_priv = qp_info->snoop_table[i];
 		if (!mad_snoop_priv ||
@@ -622,6 +627,12 @@ static void snoop_send(struct ib_mad_qp_
 						    send_buf, mad_send_wc);
 		deref_snoop_agent(mad_snoop_priv);
 		spin_lock_irqsave(&qp_info->snoop_lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irqrestore(&qp_info->snoop_lock, flags);
 }
@@ -635,6 +646,11 @@ static void snoop_recv(struct ib_mad_qp_
 	int i;
 
 	spin_lock_irqsave(&qp_info->snoop_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < qp_info->snoop_table_size; i++) {
 		mad_snoop_priv = qp_info->snoop_table[i];
 		if (!mad_snoop_priv ||
@@ -647,6 +663,12 @@ static void snoop_recv(struct ib_mad_qp_
 						   mad_recv_wc);
 		deref_snoop_agent(mad_snoop_priv);
 		spin_lock_irqsave(&qp_info->snoop_lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irqrestore(&qp_info->snoop_lock, flags);
 }
@@ -834,6 +856,11 @@ static int alloc_send_rmpp_list(struct i
 	pad = send_wr->pad;
 
 	/* Allocate data segments. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (left = send_buf->data_len + pad; left > 0; left -= seg_size) {
 		seg = kmalloc(sizeof (*seg) + seg_size, gfp_mask);
 		if (!seg) {
@@ -845,6 +872,12 @@ static int alloc_send_rmpp_list(struct i
 		}
 		seg->num = ++send_buf->seg_count;
 		list_add_tail(&seg->list, &send_wr->rmpp_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Zero any padding */
@@ -1288,10 +1321,21 @@ static void remove_methods_mad_agent(str
 	int i;
 
 	/* Remove any methods for this mad agent */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < IB_MGMT_MAX_METHODS; i++) {
 		if (method->agent[i] == agent) {
 			method->agent[i] = NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1395,6 +1439,11 @@ static int add_oui_reg_req(struct ib_mad
 
 		(*vendor_table)->vendor_class[vclass] = vendor_class;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_MGMT_OUI; i++) {
 		/* Is there matching OUI for this vendor class ? */
 		if (!memcmp((*vendor_table)->vendor_class[vclass]->oui[i],
@@ -1404,8 +1453,19 @@ static int add_oui_reg_req(struct ib_mad
 			BUG_ON(!*method);
 			goto check_in_use;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
-	for (i = 0; i < MAX_MGMT_OUI; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (i = 0; i < MAX_MGMT_OUI; i++) {
 		/* OUI slot available ? */
 		if (!is_vendor_oui((*vendor_table)->vendor_class[
 				vclass]->oui[i])) {
@@ -1419,6 +1479,12 @@ static int add_oui_reg_req(struct ib_mad
 			       mad_reg_req->oui, 3);
 			goto check_in_use;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR PFX "All OUI slots in use\n");
 	goto error3;
@@ -2651,6 +2717,11 @@ static int ib_mad_port_start(struct ib_m
 		return -ENOMEM;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < IB_MAD_QPS_CORE; i++) {
 		qp = port_priv->qp_info[i].qp;
 		if (!qp)
@@ -2687,6 +2758,12 @@ static int ib_mad_port_start(struct ib_m
 			       "RTS: %d\n", i, ret);
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = ib_req_notify_cq(port_priv->cq, IB_CQ_NEXT_COMP);
@@ -2696,6 +2773,11 @@ static int ib_mad_port_start(struct ib_m
 		goto out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < IB_MAD_QPS_CORE; i++) {
 		if (!port_priv->qp_info[i].qp)
 			continue;
@@ -2705,6 +2787,12 @@ static int ib_mad_port_start(struct ib_m
 			printk(KERN_ERR PFX "Couldn't post receive WRs\n");
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 out:
 	kfree(attr);
@@ -2943,7 +3031,12 @@ static void ib_mad_init_device(struct ib
 		end   = device->phys_port_cnt;
 	}
 
-	for (i = start; i <= end; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = start; i <= end; i++) {
 		if (ib_mad_port_open(device, i)) {
 			printk(KERN_ERR PFX "Couldn't open %s port %d\n",
 			       device->name, i);
@@ -2955,6 +3048,12 @@ static void ib_mad_init_device(struct ib
 			       device->name, i);
 			goto error_agent;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return;
 
@@ -2992,6 +3091,11 @@ static void ib_mad_remove_device(struct
 		num_ports = device->phys_port_cnt;
 		cur_port = 1;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_ports; i++, cur_port++) {
 		if (ib_agent_port_close(device, cur_port))
 			printk(KERN_ERR PFX "Couldn't close %s port %d "
@@ -3000,6 +3104,12 @@ static void ib_mad_remove_device(struct
 		if (ib_mad_port_close(device, cur_port))
 			printk(KERN_ERR PFX "Couldn't close %s port %d\n",
 			       device->name, cur_port);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/infiniband/core/cache.c b/infiniband/core/cache.c
--- a/infiniband/core/cache.c
+++ b/infiniband/core/cache.c
@@ -112,8 +112,18 @@ int ib_find_cached_gid(struct ib_device
 
 	read_lock_irqsave(&device->cache.lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = 0; p <= end_port(device) - start_port(device); ++p) {
 		cache = device->cache.gid_cache[p];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < cache->table_len; ++i) {
 			if (!memcmp(gid, &cache->table[i], sizeof *gid)) {
 				*port_num = p + start_port(device);
@@ -122,6 +132,18 @@ int ib_find_cached_gid(struct ib_device
 				ret = 0;
 				goto found;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 found:
@@ -242,6 +264,11 @@ static void ib_cache_update(struct ib_de
 
 	gid_cache->table_len = tprops->gid_tbl_len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pkey_cache->table_len; ++i) {
 		ret = ib_query_pkey(device, port, i, pkey_cache->table + i);
 		if (ret) {
@@ -249,8 +276,19 @@ static void ib_cache_update(struct ib_de
 			       ret, device->name, i);
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < gid_cache->table_len; ++i) {
 		ret = ib_query_gid(device, port, i, gid_cache->table + i);
 		if (ret) {
@@ -258,6 +296,12 @@ static void ib_cache_update(struct ib_de
 			       ret, device->name, i);
 			goto err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	write_lock_irq(&device->cache.lock);
@@ -339,10 +383,21 @@ static void ib_cache_setup_one(struct ib
 		goto err;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = 0; p <= end_port(device) - start_port(device); ++p) {
 		device->cache.pkey_cache[p] = NULL;
 		device->cache.gid_cache [p] = NULL;
 		ib_cache_update(device, p + start_port(device));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	INIT_IB_EVENT_HANDLER(&device->cache.event_handler,
@@ -353,9 +408,20 @@ static void ib_cache_setup_one(struct ib
 	return;
 
 err_cache:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = 0; p <= end_port(device) - start_port(device); ++p) {
 		kfree(device->cache.pkey_cache[p]);
 		kfree(device->cache.gid_cache[p]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 err:
@@ -371,9 +437,20 @@ static void ib_cache_cleanup_one(struct
 	ib_unregister_event_handler(&device->cache.event_handler);
 	flush_workqueue(ib_wq);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = 0; p <= end_port(device) - start_port(device); ++p) {
 		kfree(device->cache.pkey_cache[p]);
 		kfree(device->cache.gid_cache[p]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(device->cache.pkey_cache);
diff -u -p a/ptp/ptp_chardev.c b/ptp/ptp_chardev.c
--- a/ptp/ptp_chardev.c
+++ b/ptp/ptp_chardev.c
@@ -142,9 +142,20 @@ ssize_t ptp_read(struct posix_clock *pc,
 	if (cnt > qcnt)
 		cnt = qcnt;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < cnt; i++) {
 		event[i] = queue->buf[queue->head];
 		queue->head = (queue->head + 1) % PTP_MAX_TIMESTAMPS;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock_irqrestore(&queue->lock, flags);
diff -u -p a/parisc/iosapic.c b/parisc/iosapic.c
--- a/parisc/iosapic.c
+++ b/parisc/iosapic.c
@@ -356,6 +356,11 @@ iosapic_load_irt(unsigned long cell_num,
 		num_entries,
 		(int) sizeof(struct irt_entry));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0 ; i < num_entries ; i++, p++) {
 		printk(MODULE_NAME " %02x %02x %02x %02x %02x %02x %02x %02x %08x%08x\n",
 		p->entry_type, p->entry_length, p->interrupt_type,
@@ -364,6 +369,12 @@ iosapic_load_irt(unsigned long cell_num,
 		((u32 *) p)[2],
 		((u32 *) p)[3]
 		);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 #endif /* DEBUG_IOSAPIC_IRT */
@@ -410,6 +421,11 @@ irt_find_irqline(struct iosapic_info *is
 
 	DBG_IRT("irt_find_irqline() SLOT %d pin %d\n", slot, intr_pin);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt=0; cnt < irt_num_entry; cnt++, i++) {
 
 		/*
@@ -449,6 +465,12 @@ irt_find_irqline(struct iosapic_info *is
 
 		/* Found it! */
 		return i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_WARNING MODULE_NAME ": 0x%lx : no IRT entry for slot %d, pin %d\n",
@@ -652,9 +674,20 @@ printk("iosapic_enable_irq(): sel ");
 {
 	struct iosapic_info *isp = vi->iosapic;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (d0=0x10; d0<0x1e; d0++) {
 		d1 = iosapic_read(isp->addr, d0);
 		printk(" %x", d1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 printk("\n");
@@ -874,9 +907,20 @@ void *iosapic_register(unsigned long hpa
 		return NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt=0; cnt < isi->isi_num_vectors; cnt++, vip++) {
 		vip->irqline = (unsigned char) cnt;
 		vip->iosapic = isi;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return isi;
 }
@@ -892,9 +936,20 @@ iosapic_prt_irt(void *irt, long num_entr
 
 	printk(KERN_DEBUG MODULE_NAME ": Interrupt Routing Table (%lx entries)\n", num_entry);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i<num_entry; i++, irp += 4) {
 		printk(KERN_DEBUG "%p : %2d %.8x %.8x %.8x %.8x\n",
 					irp, i, irp[0], irp[1], irp[2], irp[3]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/parisc/ccio-dma.c b/parisc/ccio-dma.c
--- a/parisc/ccio-dma.c
+++ b/parisc/ccio-dma.c
@@ -1050,12 +1050,23 @@ static int ccio_proc_info(struct seq_fil
 
 #ifdef CCIO_COLLECT_STATS
 		min = max = ioc->avg_search[0];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(j = 0; j < CCIO_SEARCH_SAMPLE; ++j) {
 			avg += ioc->avg_search[j];
 			if(ioc->avg_search[j] > max) 
 				max = ioc->avg_search[j];
 			if(ioc->avg_search[j] < min) 
 				min = ioc->avg_search[j];
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
+		break;
+				}
 		}
 		avg /= CCIO_SEARCH_SAMPLE;
 		len += seq_printf(m, "  Bitmap search : %ld/%ld/%ld (min/avg/max CPU Cycles)\n",
@@ -1108,11 +1119,22 @@ static int ccio_proc_bitmap_info(struct
 		u32 *res_ptr = (u32 *)ioc->res_map;
 		int j;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < (ioc->res_size / sizeof(u32)); j++) {
 			if ((j & 7) == 0)
 				len += seq_puts(m, "\n   ");
 			len += seq_printf(m, "%08x", *res_ptr);
 			res_ptr++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		len += seq_puts(m, "\n\n");
 		ioc = ioc->next;
@@ -1149,11 +1171,22 @@ static struct ioc * ccio_find_ioc(int hw
 	struct ioc *ioc;
 
 	ioc = ioc_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ioc_count; i++) {
 		if (ioc->hw_path == hw_path)
 			return ioc;
 
 		ioc = ioc->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
@@ -1364,9 +1397,20 @@ ccio_ioc_init(struct ioc *ioc)
 	WRITE_U32(0, &ioc->ioc_regs->io_tlb_entry_m);
 	WRITE_U32(0, &ioc->ioc_regs->io_tlb_entry_l);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 1 << CCIO_CHAINID_SHIFT; i ; i--) {
 		WRITE_U32((CMD_TLB_DIRECT_WRITE | (i << ioc->chainid_shift)),
 			  &ioc->ioc_regs->io_command);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 }
 
@@ -1553,8 +1597,19 @@ static int __init ccio_probe(struct pari
 	printk(KERN_INFO "Found %s at 0x%lx\n", ioc->name,
 		(unsigned long)dev->hpa.start);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ioc_count; i++) {
 		ioc_p = &(*ioc_p)->next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	*ioc_p = ioc;
 
diff -u -p a/parisc/eisa.c b/parisc/eisa.c
--- a/parisc/eisa.c
+++ b/parisc/eisa.c
@@ -339,9 +339,20 @@ static int __init eisa_probe(struct pari
 	
 	/* Reserve IRQ2 */
 	setup_irq(2, &irq2_action);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i++) {
 		irq_set_chip_and_handler(i, &eisa_interrupt_type,
 					 handle_simple_irq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	EISA_bus = 1;
diff -u -p a/parisc/pdc_stable.c b/parisc/pdc_stable.c
--- a/parisc/pdc_stable.c
+++ b/parisc/pdc_stable.c
@@ -250,10 +250,21 @@ pdcspath_hwpath_read(struct pdcspath_ent
 	if (!i)	/* entry is not ready */
 		return -ENODATA;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 6; i++) {
 		if (devpath->bc[i] >= 128)
 			continue;
 		out += sprintf(out, "%u/", (unsigned char)devpath->bc[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	out += sprintf(out, "%u\n", (unsigned char)devpath->mod);
 	
@@ -307,10 +318,21 @@ pdcspath_hwpath_write(struct pdcspath_en
 	   before writing the last field. If there are too many fields anyway,
 	   then the user is a moron and it'll be caught up later when we'll
 	   check the consistency of the given hwpath. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=5; ((temp = strrchr(in, '/'))) && (temp-in > 0) && (likely(i)); i--) {
 		hwpath.bc[i] = simple_strtoul(temp+1, NULL, 10);
 		in[temp-in] = '\0';
 		DPRINTK("%s: bc[%d]: %d\n", __func__, i, hwpath.bc[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	/* Store the final field */		
@@ -414,11 +436,22 @@ pdcspath_layer_write(struct pdcspath_ent
 	DPRINTK("%s: layer[0]: %d\n", __func__, layers[0]);
 	
 	temp = in;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=1; ((temp = strchr(temp, '.'))) && (likely(i<6)); i++) {
 		if (unlikely(!isdigit(*(++temp))))
 			return -EINVAL;
 		layers[i] = simple_strtoul(temp, NULL, 10);
 		DPRINTK("%s: layer[%d]: %d\n", __func__, i, layers[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 		
 	/* So far so good, let's get in deep */
@@ -731,11 +764,22 @@ static ssize_t pdcs_osdep2_read(struct k
 	if (!buf)
 		return -EINVAL;
 
-	for (i=0; i<size; i+=4) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (i=0; i<size; i+=4) {
 		if (unlikely(pdc_stable_read(PDCS_ADDR_OSD2 + i, &result,
 					sizeof(result)) != PDC_OK))
 			return -EIO;
 		out += sprintf(out, "0x%.8x\n", result);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return out - buf;
@@ -918,12 +962,23 @@ static ssize_t pdcs_osdep2_write(struct
 
 	/* We'll use a local copy of buf */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i<count; i+=4) {
 		memset(in, 0, 4);
 		memcpy(in, buf+i, (count-i < 4) ? count-i : 4);
 		if (unlikely(pdc_stable_write(PDCS_ADDR_OSD2 + i, &in,
 					sizeof(in)) != PDC_OK))
 			return -EIO;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	return count;
@@ -980,6 +1035,11 @@ pdcs_register_pathentries(void)
 	for (i = 0; (entry = pdcspath_entries[i]); i++)
 		rwlock_init(&entry->rw_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; (entry = pdcspath_entries[i]); i++) {
 		write_lock(&entry->rw_lock);
 		err = pdcspath_fetch(entry);
@@ -1006,6 +1066,12 @@ pdcs_register_pathentries(void)
 
 		write_unlock(&entry->rw_lock);
 		kobject_uevent(&entry->kobj, KOBJ_ADD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	return 0;
@@ -1020,11 +1086,22 @@ pdcs_unregister_pathentries(void)
 	unsigned short i;
 	struct pdcspath_entry *entry;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; (entry = pdcspath_entries[i]); i++) {
 		read_lock(&entry->rw_lock);
 		if (entry->ready >= 2)
 			kobject_put(&entry->kobj);
 		read_unlock(&entry->rw_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/parisc/led.c b/parisc/led.c
--- a/parisc/led.c
+++ b/parisc/led.c
@@ -283,12 +283,23 @@ static void led_ASP_driver(unsigned char
 	int i;
 
 	leds = ~leds;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		unsigned char value;
 		value = (leds & 0x80) >> 7;
 		gsc_writeb( value,		 LED_DATA_REG );
 		gsc_writeb( value | LED_STROBE,	 LED_DATA_REG );
 		leds <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -326,6 +337,11 @@ static void led_LCD_driver(unsigned char
 	/* Convert min_cmd_delay to milliseconds */
 	unsigned int msec_cmd_delay = 1 + (lcd_info.min_cmd_delay / 1000);
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i<4; ++i) 
 	{
 		if ((leds & mask[i]) != (lastleds & mask[i])) 
@@ -337,6 +353,12 @@ static void led_LCD_driver(unsigned char
 					blockp[i]->off, LCD_DATA_REG );
 			msleep(msec_cmd_delay);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -655,12 +677,23 @@ int lcd_print( const char *str )
 	udelay(lcd_info.min_cmd_delay);
 
 	/* Print the string */
-	for (i=0; i < lcd_info.lcd_width; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	    for (i=0; i < lcd_info.lcd_width; i++) {
 	    if (str && *str)
 		gsc_writeb(*str++, LCD_DATA_REG);
 	    else
 		gsc_writeb(' ', LCD_DATA_REG);
 	    udelay(lcd_info.min_cmd_delay);
+	    if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	
 	/* re-queue the work */
diff -u -p a/parisc/superio.c b/parisc/superio.c
--- a/parisc/superio.c
+++ b/parisc/superio.c
@@ -354,9 +354,20 @@ int superio_fixup_irq(struct pci_dev *pc
 		__builtin_return_address(0));
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i++) {
 		irq_set_chip_and_handler(i, &superio_interrupt_type,
 					 handle_simple_irq);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
 	}
 
 	/*
diff -u -p a/parisc/sba_iommu.c b/parisc/sba_iommu.c
--- a/parisc/sba_iommu.c
+++ b/parisc/sba_iommu.c
@@ -1605,10 +1605,20 @@ printk("sba_hw_init(): mem_boot 0x%x 0x%
 	/* XXX: What about Reo Grande? */
 
 	sba_dev->num_ioc = num_ioc;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_ioc; i++) {
 		void __iomem *ioc_hpa = sba_dev->ioc[i].ioc_hpa;
 		unsigned int j;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j=0; j < sizeof(u64) * ROPES_PER_IOC; j+=sizeof(u64)) {
 
 			/*
@@ -1631,6 +1641,12 @@ printk("sba_hw_init(): mem_boot 0x%x 0x%
 			** Make sure the box crashes on rope errors.
 			*/
 			WRITE_REG(HF_ENABLE, ioc_hpa + ROPE0_CTL + j);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* flush out the last writes */
@@ -1651,6 +1667,12 @@ printk("sba_hw_init(): mem_boot 0x%x 0x%
 		} else {
 			sba_ioc_init(sba_dev->dev, &(sba_dev->ioc[i]), i);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1665,7 +1687,12 @@ sba_common_init(struct sba_device *sba_d
 	sba_dev->next = sba_list;
 	sba_list = sba_dev;
 
-	for(i=0; i< sba_dev->num_ioc; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for(i=0; i< sba_dev->num_ioc; i++) {
 		int res_size;
 #ifdef DEBUG_DMB_TRAP
 		extern void iterate_pages(unsigned long , unsigned long ,
@@ -1734,6 +1761,12 @@ sba_common_init(struct sba_device *sba_d
 
 		DBG_INIT("%s() %d res_map %x %p\n",
 			__func__, i, res_size, sba_dev->ioc[i].res_map);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_lock_init(&sba_dev->sba_lock);
@@ -1795,10 +1828,21 @@ static int sba_proc_info(struct seq_file
 		(int) (ioc->used_pages * 100 / total_pages));
 
 	min = max = ioc->avg_search[0];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < SBA_SEARCH_SAMPLE; i++) {
 		avg += ioc->avg_search[i];
 		if (ioc->avg_search[i] > max) max = ioc->avg_search[i];
 		if (ioc->avg_search[i] < min) min = ioc->avg_search[i];
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	avg /= SBA_SEARCH_SAMPLE;
 	len += seq_printf(m, "  Bitmap search : %ld/%ld/%ld (min/avg/max CPU Cycles)\n",
@@ -1848,10 +1892,21 @@ sba_proc_bitmap_info(struct seq_file *m,
 	unsigned int *res_ptr = (unsigned int *)ioc->res_map;
 	int i, len = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (ioc->res_size/sizeof(unsigned int)); ++i, ++res_ptr) {
 		if ((i & 7) == 0)
 			len += seq_printf(m, "\n   ");
 		len += seq_printf(m, " %08x", *res_ptr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	len += seq_printf(m, "\n");
 
@@ -2042,6 +2097,11 @@ void sba_directed_lmmio(struct parisc_de
 	r->start = r->end = 0;
 
 	/* Astro has 4 directed ranges. Not sure about Ike/Pluto/et al */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i<4; i++) {
 		int base, size;
 		void __iomem *reg = sba->sba_hpa + i*0x18;
@@ -2059,6 +2119,12 @@ void sba_directed_lmmio(struct parisc_de
 		size = ~ READ_REG32(reg + LMMIO_DIRECT0_MASK);
 		r->end = r->start + size;
 		r->flags = IORESOURCE_MEM;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/parisc/gsc.c b/parisc/gsc.c
--- a/parisc/gsc.c
+++ b/parisc/gsc.c
@@ -97,9 +97,20 @@ int gsc_find_local_irq(unsigned int irq,
 {
 	int local_irq;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (local_irq = 0; local_irq < limit; local_irq++) {
 		if (global_irqs[local_irq] == irq)
 			return local_irq;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NO_IRQ;
@@ -210,8 +221,19 @@ int gsc_common_setup(struct parisc_devic
 	gsc_asic->gsc = parent;
 
 	/* Initialise local irq -> global irq mapping */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 32; i++) {
 		gsc_asic->global_irq[i] = NO_IRQ;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* allocate resource region */
diff -u -p a/parisc/lba_pci.c b/parisc/lba_pci.c
--- a/parisc/lba_pci.c
+++ b/parisc/lba_pci.c
@@ -648,8 +648,19 @@ lba_fixup_bus(struct pci_bus *bus)
 		int i;
 		/* PCI-PCI Bridge */
 		pci_read_bridge_bases(bus);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {
 			pci_claim_resource(bus->self, i);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 		}
 	} else {
 		/* Host-PCI Bridge */
@@ -741,6 +752,11 @@ lba_fixup_bus(struct pci_bus *bus)
 		DBG("lba_fixup_bus() %s\n", pci_name(dev));
 
 		/* Virtualize Device/Bridge Resources. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < PCI_BRIDGE_RESOURCES; i++) {
 			struct resource *res = &dev->resource[i];
 
@@ -775,6 +791,12 @@ lba_fixup_bus(struct pci_bus *bus)
 			** isn't harmful.
 			*/
 			pci_claim_resource(dev, i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 #ifdef FBB_SUPPORT
@@ -1018,6 +1040,11 @@ lba_pat_resources(struct parisc_device *
 	/*
 	** Inspect the resources PAT tells us about
 	*/
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pa_count; i++) {
 		struct {
 			unsigned long type;
@@ -1105,6 +1132,12 @@ lba_pat_resources(struct parisc_device *
 				i, p->type & 0xff);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(pa_pdc_cell);
diff -u -p a/parisc/dino.c b/parisc/dino.c
--- a/parisc/dino.c
+++ b/parisc/dino.c
@@ -581,6 +581,11 @@ dino_fixup_bus(struct pci_bus *bus)
 		pci_read_bridge_bases(bus);
 
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {
 			if((bus->self->resource[i].flags & 
 			    (IORESOURCE_IO | IORESOURCE_MEM)) == 0)
@@ -607,6 +612,12 @@ dino_fixup_bus(struct pci_bus *bus)
 			    dev_name(&bus->self->dev), i,
 			    bus->self->resource[i].start,
 			    bus->self->resource[i].end);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -626,6 +637,11 @@ dino_fixup_bus(struct pci_bus *bus)
 			continue;
 
 		/* Adjust the I/O Port space addresses */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 			struct resource *res = &dev->resource[i];
 			if (res->flags & IORESOURCE_IO) {
@@ -639,6 +655,12 @@ dino_fixup_bus(struct pci_bus *bus)
 				res->end   |= F_EXTEND(0UL);
 			}
 #endif
+if (_cur < timeout) {
+			rdstcll(_cur);
+}
+else {
+			break;
+}
 		}
 		/* null out the ROM resource if there is one (we don't
 		 * care about an expansion rom on parisc, since it
diff -u -p a/parisc/eisa_enumerator.c b/parisc/eisa_enumerator.c
--- a/parisc/eisa_enumerator.c
+++ b/parisc/eisa_enumerator.c
@@ -489,13 +489,29 @@ int eisa_enumerator(unsigned long eeprom
 	struct eeprom_header *eh;
 	static char eeprom_buf[HPEE_MAX_LENGTH];
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i < HPEE_MAX_LENGTH; i++) {
 		eeprom_buf[i] = gsc_readb(eeprom_addr+i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	printk(KERN_INFO "Enumerating EISA bus\n");
 		    	
 	eh = (struct eeprom_header*)(eeprom_buf);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0;i<eh->num_slots;i++) {
 		struct eeprom_eisa_slot_info *es;
 		
@@ -515,6 +531,12 @@ int eisa_enumerator(unsigned long eeprom
 			printk (KERN_WARNING "EISA EEPROM offset 0x%x out of range\n",es->config_data_offset);
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return eh->num_slots;
 }
diff -u -p a/memstick/host/jmb38x_ms.c b/memstick/host/jmb38x_ms.c
--- a/memstick/host/jmb38x_ms.c
+++ b/memstick/host/jmb38x_ms.c
@@ -645,12 +645,23 @@ static int jmb38x_ms_reset(struct jmb38x
 	       host->addr + HOST_CONTROL);
 	mmiowb();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < 20; ++cnt) {
 		if (!(HOST_CONTROL_RESET_REQ
 		      & readl(host->addr + HOST_CONTROL)))
 			goto reset_next;
 
 		ndelay(20);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_dbg(&host->chip->pdev->dev, "reset_req timeout\n");
 
@@ -660,12 +671,23 @@ reset_next:
 	       host->addr + HOST_CONTROL);
 	mmiowb();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < 20; ++cnt) {
 		if (!(HOST_CONTROL_RESET
 		      & readl(host->addr + HOST_CONTROL)))
 			goto reset_ok;
 
 		ndelay(20);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_dbg(&host->chip->pdev->dev, "reset timeout\n");
 	return -EIO;
diff -u -p a/memstick/core/mspro_block.c b/memstick/core/mspro_block.c
--- a/memstick/core/mspro_block.c
+++ b/memstick/core/mspro_block.c
@@ -299,6 +299,11 @@ static ssize_t mspro_block_attr_show_def
 
 	ssize_t cnt, rc = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < s_attr->size; cnt++) {
 		if (cnt && !(cnt % 16)) {
 			if (PAGE_SIZE - rc)
@@ -307,6 +312,12 @@ static ssize_t mspro_block_attr_show_def
 
 		rc += scnprintf(buffer + rc, PAGE_SIZE - rc, "%02x ",
 				((unsigned char *)s_attr->data)[cnt]);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return rc;
 }
@@ -1041,6 +1052,11 @@ static int mspro_block_read_attributes(s
 	}
 	memcpy(buffer, (char *)attr, attr_len);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < attr_count; ++cnt) {
 		s_attr = kzalloc(sizeof(struct mspro_sys_attr), GFP_KERNEL);
 		if (!s_attr) {
@@ -1117,6 +1133,12 @@ static int mspro_block_read_attributes(s
 
 		memcpy(s_attr->data, buffer + addr % msb->page_size,
 		       s_attr->size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rc = 0;
@@ -1194,6 +1216,11 @@ static int mspro_block_init_disk(struct
 	if (host->dev.dma_mask && *(host->dev.dma_mask))
 		limit = *(host->dev.dma_mask);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rc = 0; msb->attr_group.attrs[rc]; ++rc) {
 		s_attr = mspro_from_sysfs_attr(msb->attr_group.attrs[rc]);
 
@@ -1201,6 +1228,12 @@ static int mspro_block_init_disk(struct
 			dev_info = s_attr->data;
 		else if (s_attr->id == MSPRO_BLOCK_ID_SYSINFO)
 			sys_info = s_attr->data;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!dev_info || !sys_info)
@@ -1287,11 +1320,22 @@ static void mspro_block_data_clear(struc
 	struct mspro_sys_attr *s_attr;
 
 	if (msb->attr_group.attrs) {
-		for (cnt = 0; msb->attr_group.attrs[cnt]; ++cnt) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (cnt = 0; msb->attr_group.attrs[cnt]; ++cnt) {
 			s_attr = mspro_from_sysfs_attr(msb->attr_group
 							   .attrs[cnt]);
 			kfree(s_attr->data);
 			kfree(s_attr);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		kfree(msb->attr_group.attrs);
 	}
diff -u -p a/scsi/atari_scsi.c b/scsi/atari_scsi.c
--- a/scsi/atari_scsi.c
+++ b/scsi/atari_scsi.c
@@ -263,10 +263,21 @@ static int scsi_dma_is_ignored_buserr(un
 		 * Check for this case:
 		 */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < m68k_num_memory; ++i) {
 			end_addr = m68k_memory[i].addr + m68k_memory[i].size;
 			if (end_addr <= addr && addr <= end_addr + 4)
 				return 1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 	return 0;
diff -u -p a/scsi/device_handler/scsi_dh.c b/scsi/device_handler/scsi_dh.c
--- a/scsi/device_handler/scsi_dh.c
+++ b/scsi/device_handler/scsi_dh.c
@@ -371,6 +371,11 @@ int scsi_register_device_handler(struct
 	list_add(&scsi_dh->list, &scsi_dh_list);
 	spin_unlock(&list_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; scsi_dh->devlist && scsi_dh->devlist[i].vendor; i++) {
 		scsi_dev_info_list_add_keyed(0,
 					scsi_dh->devlist[i].vendor,
@@ -378,6 +383,12 @@ int scsi_register_device_handler(struct
 					NULL,
 					scsi_dh->idx,
 					SCSI_DEVINFO_DH);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bus_for_each_dev(&scsi_bus_type, NULL, scsi_dh, scsi_dh_notifier_add);
@@ -404,10 +415,21 @@ int scsi_unregister_device_handler(struc
 	bus_for_each_dev(&scsi_bus_type, NULL, scsi_dh,
 			 scsi_dh_notifier_remove);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; scsi_dh->devlist && scsi_dh->devlist[i].vendor; i++) {
 		scsi_dev_info_list_del_keyed(scsi_dh->devlist[i].vendor,
 					     scsi_dh->devlist[i].model,
 					     SCSI_DEVINFO_DH);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_lock(&list_lock);
diff -u -p a/scsi/device_handler/scsi_dh_alua.c b/scsi/device_handler/scsi_dh_alua.c
--- a/scsi/device_handler/scsi_dh_alua.c
+++ b/scsi/device_handler/scsi_dh_alua.c
@@ -546,12 +546,23 @@ static int alua_rtpg(struct scsi_device
 		goto retry;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 4, ucp = h->buff + 4; k < len; k += off, ucp += off) {
 		if (h->group_id == (ucp[2] << 8) + ucp[3]) {
 			h->state = ucp[0] & 0x0f;
 			valid_states = ucp[1];
 		}
 		off = 8 + (ucp[7] * 4);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sdev_printk(KERN_INFO, sdev,
diff -u -p a/scsi/lpfc/lpfc_attr.c b/scsi/lpfc/lpfc_attr.c
--- a/scsi/lpfc/lpfc_attr.c
+++ b/scsi/lpfc/lpfc_attr.c
@@ -79,6 +79,11 @@ static void
 lpfc_jedec_to_ascii(int incr, char hdw[])
 {
 	int i, j;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 8; i++) {
 		j = (incr & 0xf);
 		if (j <= 9)
@@ -86,6 +91,12 @@ lpfc_jedec_to_ascii(int incr, char hdw[]
 		 else
 			hdw[7 - i] = 0x61 + j - 10;
 		incr = (incr >> 4);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	hdw[8] = 0;
 	return;
@@ -649,6 +660,11 @@ lpfc_do_offline(struct lpfc_hba *phba, u
 	/* Wait a little for things to settle down, but not
 	 * long enough for dev loss timeout to expire.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < psli->num_rings; i++) {
 		pring = &psli->ring[i];
 		while (pring->txcmplq_cnt) {
@@ -661,6 +677,12 @@ lpfc_do_offline(struct lpfc_hba *phba, u
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	init_completion(&online_compl);
@@ -791,7 +813,12 @@ lpfc_sli4_pdev_status_reg_wait(struct lp
 		return -EPERM;
 
 	/* wait for the SLI port firmware ready after firmware reset */
-	for (i = 0; i < LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT; i++) {
 		msleep(10);
 		lpfc_readl(phba->sli4_hba.u.if_type2.STATUSregaddr,
 			   &portstat_reg.word0);
@@ -802,6 +829,12 @@ lpfc_sli4_pdev_status_reg_wait(struct lp
 		if (!bf_get(lpfc_sliport_status_rdy, &portstat_reg))
 			continue;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (i < LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT)
@@ -2060,6 +2093,11 @@ lpfc_soft_wwpn_store(struct device *dev,
 	memset(wwpn, 0, sizeof(wwpn));
 
 	/* Validate and store the new name */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0, j=0; i < 16; i++) {
 		int value;
 
@@ -2072,6 +2110,12 @@ lpfc_soft_wwpn_store(struct device *dev,
 			wwpn[i/2] = j & 0xff;
 			j = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	phba->cfg_soft_wwpn = wwn_to_u64(wwpn);
 	fc_host_port_name(shost) = phba->cfg_soft_wwpn;
@@ -2156,6 +2200,11 @@ lpfc_soft_wwnn_store(struct device *dev,
 	memset(wwnn, 0, sizeof(wwnn));
 
 	/* Validate and store the new name */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0, j=0; i < 16; i++) {
 		int value;
 
@@ -2168,6 +2217,12 @@ lpfc_soft_wwnn_store(struct device *dev,
 			wwnn[i/2] = j & 0xff;
 			j = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	phba->cfg_soft_wwnn = wwn_to_u64(wwnn);
 
@@ -2819,6 +2874,11 @@ lpfc_stat_data_ctrl_store(struct device
 		if (vports == NULL)
 			return -ENOMEM;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 			v_shost = lpfc_shost_from_vport(vports[i]);
 			spin_lock_irq(v_shost->host_lock);
@@ -2827,6 +2887,12 @@ lpfc_stat_data_ctrl_store(struct device
 			if (vports[i]->stat_data_enabled)
 				lpfc_vport_reset_stat_data(vports[i]);
 			spin_unlock_irq(v_shost->host_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Set the bucket attributes */
@@ -2834,6 +2900,11 @@ lpfc_stat_data_ctrl_store(struct device
 		phba->bucket_base = base;
 		phba->bucket_step = step;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 			v_shost = lpfc_shost_from_vport(vports[i]);
 
@@ -2841,6 +2912,12 @@ lpfc_stat_data_ctrl_store(struct device
 			spin_lock_irq(v_shost->host_lock);
 			vports[i]->stat_data_blocked = 0;
 			spin_unlock_irq(v_shost->host_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		lpfc_destroy_vport_work_array(phba, vports);
 		return strlen(buf);
@@ -2851,6 +2928,11 @@ lpfc_stat_data_ctrl_store(struct device
 		if (vports == NULL)
 			return -ENOMEM;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 			v_shost = lpfc_shost_from_vport(vports[i]);
 			spin_lock_irq(shost->host_lock);
@@ -2859,6 +2941,12 @@ lpfc_stat_data_ctrl_store(struct device
 			vport->stat_data_enabled = 0;
 			vports[i]->stat_data_blocked = 0;
 			spin_unlock_irq(shost->host_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		lpfc_destroy_vport_work_array(phba, vports);
 		phba->bucket_type = LPFC_NO_BUCKET;
@@ -3049,10 +3137,21 @@ sysfs_drvr_stat_data_read(struct file *f
 
 		index = strlen(buf);
 
-		for (i = 0; i < LPFC_MAX_BUCKET_COUNT; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < LPFC_MAX_BUCKET_COUNT; i++) {
 			sprintf(&buf[index], "%010u,",
 				ndlp->lat_data[i].cmd_count);
 			index = strlen(buf);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		sprintf(&buf[index], "\n");
 		index = strlen(buf);
@@ -3967,9 +4066,20 @@ sysfs_ctlreg_read(struct file *filp, str
 
 	spin_lock_irq(&phba->hbalock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (buf_off = 0; buf_off < count; buf_off += sizeof(uint32_t)) {
 		tmp_ptr = (uint32_t *)(buf + buf_off);
 		*tmp_ptr = readl(phba->ctrl_regs_memmap_p + off + buf_off);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irq(&phba->hbalock);
diff -u -p a/scsi/lpfc/lpfc_sli.c b/scsi/lpfc/lpfc_sli.c
--- a/scsi/lpfc/lpfc_sli.c
+++ b/scsi/lpfc/lpfc_sli.c
@@ -1618,6 +1618,11 @@ lpfc_sli_hbqbuf_free_all(struct lpfc_hba
 	hbq_count = lpfc_sli_hbq_count();
 	/* Return all memory used by all HBQs */
 	spin_lock_irqsave(&phba->hbalock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < hbq_count; ++i) {
 		list_for_each_entry_safe(dmabuf, next_dmabuf,
 				&phba->hbqs[i].hbq_buffer_list, list) {
@@ -1626,6 +1631,12 @@ lpfc_sli_hbqbuf_free_all(struct lpfc_hba
 			(phba->hbqs[i].hbq_free_buffer)(phba, hbq_buf);
 		}
 		phba->hbqs[i].buffer_count = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Return all HBQ buffer that are in-fly */
 	list_for_each_entry_safe(dmabuf, next_dmabuf, &phba->rb_pend_list,
@@ -2319,6 +2330,11 @@ lpfc_complete_unsol_iocb(struct lpfc_hba
 	}
 	/* We must search, based on rctl / type
 	   for the right routine */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pring->num_mask; i++) {
 		if ((pring->prt[i].rctl == fch_r_ctl) &&
 		    (pring->prt[i].type == fch_type)) {
@@ -2327,6 +2343,12 @@ lpfc_complete_unsol_iocb(struct lpfc_hba
 						(phba, pring, saveq);
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -3622,6 +3644,11 @@ void lpfc_reset_barrier(struct lpfc_hba
 	mbox_buf = phba->MBslimaddr;
 	writel(mbox, mbox_buf);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 50; i++) {
 		if (lpfc_readl((resp_buf + 1), &resp_data))
 			return;
@@ -3629,6 +3656,12 @@ void lpfc_reset_barrier(struct lpfc_hba
 			mdelay(1);
 		else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	resp_data = 0;
 	if (lpfc_readl((resp_buf + 1), &resp_data))
@@ -3643,6 +3676,11 @@ void lpfc_reset_barrier(struct lpfc_hba
 
 	((MAILBOX_t *)&mbox)->mbxOwner = OWN_HOST;
 	resp_data = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 500; i++) {
 		if (lpfc_readl(resp_buf, &resp_data))
 			return;
@@ -3650,7 +3688,13 @@ void lpfc_reset_barrier(struct lpfc_hba
 			mdelay(1);
 		else
 			break;
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
 
 clear_errat:
 
@@ -3822,6 +3866,11 @@ lpfc_sli_brdreset(struct lpfc_hba *phba)
 	pci_write_config_word(phba->pcidev, PCI_COMMAND, cfg_value);
 
 	/* Initialize relevant SLI info */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < psli->num_rings; i++) {
 		pring = &psli->ring[i];
 		pring->flag = 0;
@@ -3830,6 +3879,12 @@ lpfc_sli_brdreset(struct lpfc_hba *phba)
 		pring->local_getidx = 0;
 		pring->cmdidx = 0;
 		pring->missbufcnt = 0;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	phba->link_state = LPFC_WARM_START;
@@ -4207,6 +4262,11 @@ lpfc_sli_hbq_setup(struct lpfc_hba *phba
 	phba->hbq_in_use = 1;
 
 	hbq_entry_index = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hbqno = 0; hbqno < hbq_count; ++hbqno) {
 		phba->hbqs[hbqno].next_hbqPutIdx = 0;
 		phba->hbqs[hbqno].hbqPutIdx      = 0;
@@ -4232,6 +4292,12 @@ lpfc_sli_hbq_setup(struct lpfc_hba *phba
 			mempool_free(pmb, phba->mbox_mem_pool);
 			return -ENXIO;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	phba->hbq_count = hbq_count;
 
@@ -5289,6 +5355,11 @@ lpfc_sli4_alloc_extent(struct lpfc_hba *
 	 * as an index into the array and manages the available ids.  The
 	 * array just stores the ids communicated to the port via the wqes.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 0, k = 0; i < rsrc_cnt; i++) {
 		if ((i % 2) == 0)
 			rsrc_id = bf_get(lpfc_mbx_rsrc_id_word4_0,
@@ -5320,6 +5391,12 @@ lpfc_sli4_alloc_extent(struct lpfc_hba *
 		/* Entire word processed.  Get next word.*/
 		if ((i % 2) == 1)
 			k++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
  err_exit:
 	lpfc_sli4_mbox_cmd_free(phba, mbox);
@@ -7511,6 +7588,11 @@ lpfc_sli4_bpl2sgl(struct lpfc_hba *phba,
 		if (!bpl)
 			return xritag;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < numBdes; i++) {
 			/* Should already be byte swapped. */
 			sgl->addr_hi = bpl->addrHigh;
@@ -7545,7 +7627,13 @@ lpfc_sli4_bpl2sgl(struct lpfc_hba *phba,
 			sgl->word2 = cpu_to_le32(sgl->word2);
 			bpl++;
 			sgl++;
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+			}
 	} else if (icmd->un.genreq64.bdl.bdeFlags == BUFF_TYPE_BDE_64) {
 			/* The addrHigh and addrLow fields of the BDE have not
 			 * been byteswapped yet so they need to be swapped
@@ -7649,9 +7737,20 @@ lpfc_sli4_iocb2wqe(struct lpfc_hba *phba
 		wqe->generic.bde.tus.w  = le32_to_cpu(bpl->tus.w);
 		xmit_len = wqe->generic.bde.tus.f.bdeSize;
 		total_len = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < numBdes; i++) {
 			bde.tus.w  = le32_to_cpu(bpl[i].tus.w);
 			total_len += bde.tus.f.bdeSize;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 	} else
 		xmit_len = iocbq->iocb.un.fcpi64.bdl.bdeSize;
@@ -8280,6 +8379,11 @@ lpfc_sli_setup(struct lpfc_hba *phba)
 	psli->iocbq_lookup_len = 0;
 	psli->last_iotag = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < psli->num_rings; i++) {
 		pring = &psli->ring[i];
 		switch (i) {
@@ -8366,6 +8470,12 @@ lpfc_sli_setup(struct lpfc_hba *phba)
 		}
 		totiocbsize += (pring->numCiocb * pring->sizeCiocb) +
 				(pring->numRiocb * pring->sizeRiocb);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (totiocbsize > MAX_SLIM_IOCB_SIZE) {
 		/* Too many cmd / rsp ring entries in SLI2 SLIM */
@@ -8403,6 +8513,11 @@ lpfc_sli_queue_setup(struct lpfc_hba *ph
 	INIT_LIST_HEAD(&psli->mboxq);
 	INIT_LIST_HEAD(&psli->mboxq_cmpl);
 	/* Initialize list headers for txq and txcmplq as double linked lists */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < psli->num_rings; i++) {
 		pring = &psli->ring[i];
 		pring->ringno = i;
@@ -8414,6 +8529,12 @@ lpfc_sli_queue_setup(struct lpfc_hba *ph
 		INIT_LIST_HEAD(&pring->iocb_continueq);
 		INIT_LIST_HEAD(&pring->iocb_continue_saveq);
 		INIT_LIST_HEAD(&pring->postbufq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irq(&phba->hbalock);
 	return 1;
@@ -8497,6 +8618,11 @@ lpfc_sli_host_down(struct lpfc_vport *vp
 	lpfc_cleanup_discovery_resources(vport);
 
 	spin_lock_irqsave(&phba->hbalock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < psli->num_rings; i++) {
 		pring = &psli->ring[i];
 		prev_pring_flag = pring->flag;
@@ -8526,6 +8652,12 @@ lpfc_sli_host_down(struct lpfc_vport *vp
 		}
 
 		pring->flag = prev_pring_flag;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&phba->hbalock, flags);
@@ -8569,6 +8701,11 @@ lpfc_sli_hba_down(struct lpfc_hba *phba)
 	lpfc_fabric_abort_hba(phba);
 
 	spin_lock_irqsave(&phba->hbalock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < psli->num_rings; i++) {
 		pring = &psli->ring[i];
 		/* Only slow rings */
@@ -8585,6 +8722,12 @@ lpfc_sli_hba_down(struct lpfc_hba *phba)
 		list_splice_init(&pring->txq, &completions);
 		pring->txq_cnt = 0;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&phba->hbalock, flags);
 
@@ -8635,12 +8778,23 @@ lpfc_sli_pcimem_bcopy(void *srcp, void *
 	uint32_t ldata;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (int)cnt; i += sizeof (uint32_t)) {
 		ldata = *src;
 		ldata = le32_to_cpu(ldata);
 		*dest = ldata;
 		src++;
 		dest++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -8663,12 +8817,23 @@ lpfc_sli_bemem_bcopy(void *srcp, void *d
 	uint32_t ldata;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (int)cnt; i += sizeof(uint32_t)) {
 		ldata = *src;
 		ldata = be32_to_cpu(ldata);
 		*dest = ldata;
 		src++;
 		dest++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -9135,9 +9300,20 @@ lpfc_sli_hba_iocb_abort(struct lpfc_hba
 	struct lpfc_sli_ring *pring;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < psli->num_rings; i++) {
 		pring = &psli->ring[i];
 		lpfc_sli_iocb_ring_abort(phba, pring);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -9233,12 +9409,23 @@ lpfc_sli_sum_iocb(struct lpfc_vport *vpo
 	struct lpfc_iocbq *iocbq;
 	int sum, i;
 
-	for (i = 1, sum = 0; i <= phba->sli.last_iotag; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (i = 1, sum = 0; i <= phba->sli.last_iotag; i++) {
 		iocbq = phba->sli.iocbq_lookup[i];
 
 		if (lpfc_sli_validate_fcp_iocb (iocbq, vport, tgt_id, lun_id,
 						ctx_cmd) == 0)
 			sum++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	return sum;
@@ -9294,7 +9481,12 @@ lpfc_sli_abort_iocb(struct lpfc_vport *v
 	int errcnt = 0, ret_val = 0;
 	int i;
 
-	for (i = 1; i <= phba->sli.last_iotag; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (i = 1; i <= phba->sli.last_iotag; i++) {
 		iocbq = phba->sli.iocbq_lookup[i];
 
 		if (lpfc_sli_validate_fcp_iocb(iocbq, vport, tgt_id, lun_id,
@@ -9338,6 +9530,12 @@ lpfc_sli_abort_iocb(struct lpfc_vport *v
 			errcnt++;
 			continue;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return errcnt;
@@ -11493,11 +11691,22 @@ lpfc_sli4_intr_handler(int irq, void *de
 	/*
 	 * Invoke fast-path host attention interrupt handling as appropriate.
 	 */
-	for (fcp_eqidx = 0; fcp_eqidx < phba->cfg_fcp_eq_count; fcp_eqidx++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (fcp_eqidx = 0; fcp_eqidx < phba->cfg_fcp_eq_count; fcp_eqidx++) {
 		fp_irq_rc = lpfc_sli4_fp_intr_handler(irq,
 					&phba->sli4_hba.fcp_eq_hdl[fcp_eqidx]);
 		if (fp_irq_rc == IRQ_HANDLED)
 			fp_handled |= true;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return (fp_handled == true) ? IRQ_HANDLED : sp_irq_rc;
@@ -11562,6 +11771,11 @@ lpfc_sli4_queue_alloc(struct lpfc_hba *p
 	INIT_LIST_HEAD(&queue->list);
 	INIT_LIST_HEAD(&queue->page_list);
 	INIT_LIST_HEAD(&queue->child_list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (x = 0, total_qe_count = 0; x < queue->page_count; x++) {
 		dmabuf = kzalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);
 		if (!dmabuf)
@@ -11583,6 +11797,12 @@ lpfc_sli4_queue_alloc(struct lpfc_hba *p
 		     total_qe_count++, dma_pointer += entry_size) {
 			queue->qe[total_qe_count].address = dma_pointer;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	queue->entry_size = entry_size;
 	queue->entry_count = entry_count;
@@ -12923,6 +13143,11 @@ lpfc_sli4_post_els_sgl_list(struct lpfc_
 	sgl = (struct lpfc_mbx_post_uembed_sgl_page1 *)viraddr;
 	sgl_pg_pairs = &sgl->sgl_pg_pairs;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pg_pairs = 0; pg_pairs < els_xri_cnt; pg_pairs++) {
 		sglq_entry = phba->sli4_hba.lpfc_els_sgl_array[pg_pairs];
 
@@ -12956,6 +13181,12 @@ lpfc_sli4_post_els_sgl_list(struct lpfc_
 		if (pg_pairs == 0)
 			xritag_start = sglq_entry->sli4_xritag;
 		sgl_pg_pairs++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Complete initialization and perform endian conversion. */
@@ -13074,6 +13305,11 @@ lpfc_sli4_post_els_sgl_list_ext(struct l
 		 * but handle the sge pointers with a zero-based index
 		 * that doesn't get reset per loop pass.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (index = rsrc_start;
 		     index < rsrc_start + loop_cnt;
 		     index++) {
@@ -13113,6 +13349,12 @@ lpfc_sli4_post_els_sgl_list_ext(struct l
 				xritag_start = sglq_entry->sli4_xritag;
 			sgl_pg_pairs++;
 			cnt++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Complete initialization and perform endian conversion. */
@@ -13837,9 +14079,20 @@ lpfc_sli4_xri_inrange(struct lpfc_hba *p
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < phba->sli4_hba.max_cfg_param.max_xri; i++) {
 		if (xri == phba->sli4_hba.xri_ids[i])
 			return i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NO_XRI;
 }
diff -u -p a/scsi/lpfc/lpfc_debugfs.c b/scsi/lpfc/lpfc_debugfs.c
--- a/scsi/lpfc/lpfc_debugfs.c
+++ b/scsi/lpfc/lpfc_debugfs.c
@@ -149,6 +149,11 @@ lpfc_debugfs_disc_trc_data(struct lpfc_v
 	len = 0;
 	index = (atomic_read(&vport->disc_trc_cnt) + 1) &
 		(lpfc_debugfs_max_disc_trc - 1);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = index; i < lpfc_debugfs_max_disc_trc; i++) {
 		dtp = vport->disc_trc + i;
 		if (!dtp->fmt)
@@ -159,7 +164,18 @@ lpfc_debugfs_disc_trc_data(struct lpfc_v
 			dtp->seq_cnt, ms, dtp->fmt);
 		len +=  snprintf(buf+len, size-len, buffer,
 			dtp->data1, dtp->data2, dtp->data3);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < index; i++) {
 		dtp = vport->disc_trc + i;
 		if (!dtp->fmt)
@@ -170,6 +186,12 @@ lpfc_debugfs_disc_trc_data(struct lpfc_v
 			dtp->seq_cnt, ms, dtp->fmt);
 		len +=  snprintf(buf+len, size-len, buffer,
 			dtp->data1, dtp->data2, dtp->data3);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	lpfc_debugfs_enable = enable;
@@ -215,6 +237,11 @@ lpfc_debugfs_slow_ring_trc_data(struct l
 	len = 0;
 	index = (atomic_read(&phba->slow_ring_trc_cnt) + 1) &
 		(lpfc_debugfs_max_slow_ring_trc - 1);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = index; i < lpfc_debugfs_max_slow_ring_trc; i++) {
 		dtp = phba->slow_ring_trc + i;
 		if (!dtp->fmt)
@@ -225,7 +252,18 @@ lpfc_debugfs_slow_ring_trc_data(struct l
 			dtp->seq_cnt, ms, dtp->fmt);
 		len +=  snprintf(buf+len, size-len, buffer,
 			dtp->data1, dtp->data2, dtp->data3);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < index; i++) {
 		dtp = phba->slow_ring_trc + i;
 		if (!dtp->fmt)
@@ -236,6 +274,12 @@ lpfc_debugfs_slow_ring_trc_data(struct l
 			dtp->seq_cnt, ms, dtp->fmt);
 		len +=  snprintf(buf+len, size-len, buffer,
 			dtp->data1, dtp->data2, dtp->data3);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	lpfc_debugfs_enable = enable;
@@ -484,6 +528,11 @@ lpfc_debugfs_dumpHostSlim_data(struct lp
 		off += (8 * sizeof(uint32_t));
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++) {
 		pgpp = &phba->port_gp[i];
 		pring = &psli->ring[i];
@@ -493,6 +542,12 @@ lpfc_debugfs_dumpHostSlim_data(struct lp
 				 i, pgpp->cmdGetInx, pring->numCiocb,
 				 pring->next_cmdidx, pring->local_getidx,
 				 pring->flag, pgpp->rspPutInx, pring->numRiocb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (phba->sli_rev <= LPFC_SLI_REV3) {
@@ -1269,11 +1324,22 @@ static int lpfc_idiag_cmd_get(const char
 	if (idiag_cmd->opcode == 0)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < LPFC_IDIAG_CMD_DATA_SIZE; i++) {
 		step_str = strsep(&pbuf, "\t ");
 		if (!step_str)
 			return i;
 		idiag_cmd->data[i] = simple_strtol(step_str, NULL, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return i;
 }
@@ -2010,6 +2076,11 @@ lpfc_idiag_queinfo_read(struct file *fil
 	/* Get fast-path event queue information */
 	len += snprintf(pbuffer+len, LPFC_QUE_INFO_GET_BUF_SIZE-len,
 			"Fast-path EQ information:\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (fcp_qidx = 0; fcp_qidx < phba->cfg_fcp_eq_count; fcp_qidx++) {
 		len += snprintf(pbuffer+len, LPFC_QUE_INFO_GET_BUF_SIZE-len,
 				"\tEQID[%02d], "
@@ -2020,6 +2091,12 @@ lpfc_idiag_queinfo_read(struct file *fil
 				phba->sli4_hba.fp_eq[fcp_qidx]->entry_size,
 				phba->sli4_hba.fp_eq[fcp_qidx]->host_index,
 				phba->sli4_hba.fp_eq[fcp_qidx]->hba_index);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	len += snprintf(pbuffer+len, LPFC_QUE_INFO_GET_BUF_SIZE-len, "\n");
 
@@ -2110,7 +2187,12 @@ lpfc_idiag_queinfo_read(struct file *fil
 	/* Get fast-path work queue information */
 	len += snprintf(pbuffer+len, LPFC_QUE_INFO_GET_BUF_SIZE-len,
 			"Fast-path FCP WQ information:\n");
-	for (fcp_qidx = 0; fcp_qidx < phba->cfg_fcp_wq_count; fcp_qidx++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (fcp_qidx = 0; fcp_qidx < phba->cfg_fcp_wq_count; fcp_qidx++) {
 		len += snprintf(pbuffer+len, LPFC_QUE_INFO_GET_BUF_SIZE-len,
 				"Associated CQID[%02d]:\n",
 				phba->sli4_hba.fcp_wq[fcp_qidx]->assoc_qid);
@@ -2123,6 +2205,12 @@ lpfc_idiag_queinfo_read(struct file *fil
 				phba->sli4_hba.fcp_wq[fcp_qidx]->entry_size,
 				phba->sli4_hba.fcp_wq[fcp_qidx]->host_index,
 				phba->sli4_hba.fcp_wq[fcp_qidx]->hba_index);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	len += snprintf(pbuffer+len, LPFC_QUE_INFO_GET_BUF_SIZE-len, "\n");
 
@@ -2370,6 +2458,11 @@ lpfc_idiag_queacc_write(struct file *fil
 			goto pass_check;
 		}
 		/* Fast-path event queue */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (qidx = 0; qidx < phba->cfg_fcp_eq_count; qidx++) {
 			if (phba->sli4_hba.fp_eq[qidx]->queue_id == queid) {
 				/* Sanity check */
@@ -2381,6 +2474,12 @@ lpfc_idiag_queacc_write(struct file *fil
 				idiag.ptr_private = phba->sli4_hba.fp_eq[qidx];
 				goto pass_check;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		goto error_out;
 		break;
@@ -2446,6 +2545,11 @@ lpfc_idiag_queacc_write(struct file *fil
 			goto pass_check;
 		}
 		/* FCP work queue */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (qidx = 0; qidx < phba->cfg_fcp_wq_count; qidx++) {
 			if (phba->sli4_hba.fcp_wq[qidx]->queue_id == queid) {
 				/* Sanity check */
@@ -2458,6 +2562,12 @@ lpfc_idiag_queacc_write(struct file *fil
 					phba->sli4_hba.fcp_wq[qidx];
 				goto pass_check;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		goto error_out;
 		break;
@@ -3639,6 +3749,11 @@ lpfc_idiag_mbxacc_dump_bsg_mbox(struct l
 	/* dump buffer content */
 	if (do_dump) {
 		pword = (uint32_t *)dmabuf->virt;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < *mbx_word_cnt; i++) {
 			if (!(i % 8)) {
 				if (i != 0)
@@ -3651,6 +3766,12 @@ lpfc_idiag_mbxacc_dump_bsg_mbox(struct l
 			len += snprintf(line_buf+len, LPFC_MBX_ACC_LBUF_SZ-len,
 					"%08x ", (uint32_t)*pword);
 			pword++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if ((i - 1) % 8)
 			printk(KERN_ERR "%s\n", line_buf);
@@ -3705,6 +3826,11 @@ lpfc_idiag_mbxacc_dump_issue_mbox(struct
 		printk(KERN_ERR "Mailbox command:0x%x dump by word:\n",
 		       pmbox->mbxCommand);
 		pword = (uint32_t *)pmbox;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < *mbx_word_cnt; i++) {
 			if (!(i % 8)) {
 				if (i != 0)
@@ -3719,6 +3845,12 @@ lpfc_idiag_mbxacc_dump_issue_mbox(struct
 					"%08x ",
 					((uint32_t)*pword) & 0xffffffff);
 			pword++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if ((i - 1) % 8)
 			printk(KERN_ERR "%s\n", line_buf);
@@ -3728,6 +3860,11 @@ lpfc_idiag_mbxacc_dump_issue_mbox(struct
 		printk(KERN_ERR "Mailbox command:0x%x dump by byte:\n",
 		       pmbox->mbxCommand);
 		pbyte = (uint8_t *)pmbox;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < *mbx_word_cnt; i++) {
 			if (!(i % 8)) {
 				if (i != 0)
@@ -3738,15 +3875,32 @@ lpfc_idiag_mbxacc_dump_issue_mbox(struct
 						LPFC_MBX_ACC_LBUF_SZ-len,
 						"%03d: ", i);
 			}
-			for (j = 0; j < 4; j++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (j = 0; j < 4; j++) {
 				len += snprintf(line_buf+len,
 						LPFC_MBX_ACC_LBUF_SZ-len,
 						"%02x",
 						((uint8_t)*pbyte) & 0xff);
 				pbyte++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			len += snprintf(line_buf+len,
 					LPFC_MBX_ACC_LBUF_SZ-len, " ");
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if ((i - 1) % 8)
 			printk(KERN_ERR "%s\n", line_buf);
diff -u -p a/scsi/lpfc/lpfc_init.c b/scsi/lpfc/lpfc_init.c
--- a/scsi/lpfc/lpfc_init.c
+++ b/scsi/lpfc/lpfc_init.c
@@ -429,6 +429,11 @@ lpfc_config_port_post(struct lpfc_hba *p
 		uint8_t *outptr;
 
 		outptr = &vport->fc_nodename.u.s.IEEE[0];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 12; i++) {
 			status = *outptr++;
 			j = ((status & 0xf0) >> 4);
@@ -446,6 +451,12 @@ lpfc_config_port_post(struct lpfc_hba *p
 			else
 				phba->SerialNumber[i] =
 				    (char)((uint8_t) 0x61 + (uint8_t) (j - 10));
+				    if (_cur < timeout) {
+				    rdstcll(_cur);
+				    }
+				    else {
+				    break;
+				    }
 		}
 	}
 
@@ -826,6 +837,11 @@ lpfc_hba_down_post_s3(struct lpfc_hba *p
 	}
 
 	spin_lock_irq(&phba->hbalock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < psli->num_rings; i++) {
 		pring = &psli->ring[i];
 
@@ -842,6 +858,12 @@ lpfc_hba_down_post_s3(struct lpfc_hba *p
 
 		lpfc_sli_abort_iocb_ring(phba, pring);
 		spin_lock_irq(&phba->hbalock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irq(&phba->hbalock);
 
@@ -2526,17 +2548,29 @@ lpfc_online(struct lpfc_hba *phba)
 	}
 
 	vports = lpfc_create_vport_work_array(phba);
-	if (vports != NULL)
-		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
-			struct Scsi_Host *shost;
-			shost = lpfc_shost_from_vport(vports[i]);
-			spin_lock_irq(shost->host_lock);
-			vports[i]->fc_flag &= ~FC_OFFLINE_MODE;
-			if (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED)
-				vports[i]->fc_flag |= FC_VPORT_NEEDS_REG_VPI;
-			if (phba->sli_rev == LPFC_SLI_REV4)
-				vports[i]->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;
-			spin_unlock_irq(shost->host_lock);
+	if (vports != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
+				struct Scsi_Host *shost;
+				shost = lpfc_shost_from_vport(vports[i]);
+				spin_lock_irq(shost->host_lock);
+				vports[i]->fc_flag &= ~FC_OFFLINE_MODE;
+				if (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED)
+						vports[i]->fc_flag |= FC_VPORT_NEEDS_REG_VPI;
+				if (phba->sli_rev == LPFC_SLI_REV4)
+						vports[i]->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;
+				spin_unlock_irq(shost->host_lock);
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
+			}
 		}
 		lpfc_destroy_vport_work_array(phba, vports);
 
@@ -2592,6 +2626,11 @@ lpfc_offline_prep(struct lpfc_hba * phba
 	/* Issue an unreg_login to all nodes on all vports */
 	vports = lpfc_create_vport_work_array(phba);
 	if (vports != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 			if (vports[i]->load_flag & FC_UNLOADING)
 				continue;
@@ -2621,6 +2660,12 @@ lpfc_offline_prep(struct lpfc_hba * phba
 				spin_unlock_irq(shost->host_lock);
 				lpfc_unreg_rpi(vports[i], ndlp);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	lpfc_destroy_vport_work_array(phba, vports);
@@ -2662,13 +2707,25 @@ lpfc_offline(struct lpfc_hba *phba)
 	phba->work_ha = 0;
 	spin_unlock_irq(&phba->hbalock);
 	vports = lpfc_create_vport_work_array(phba);
-	if (vports != NULL)
-		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
+	if (vports != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 			shost = lpfc_shost_from_vport(vports[i]);
 			spin_lock_irq(shost->host_lock);
 			vports[i]->work_port_events = 0;
 			vports[i]->fc_flag |= FC_OFFLINE_MODE;
 			spin_unlock_irq(shost->host_lock);
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
+			}
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
 }
@@ -4459,7 +4516,12 @@ lpfc_sli4_driver_resource_setup(struct l
 		mqe = &mboxq->u.mqe;
 		memcpy(&pn_page[0], ((uint8_t *)&mqe->un.supp_pages.word3),
 		       LPFC_MAX_SUPPORTED_PAGES);
-		for (i = 0; i < LPFC_MAX_SUPPORTED_PAGES; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < LPFC_MAX_SUPPORTED_PAGES; i++) {
 			switch (pn_page[i]) {
 			case LPFC_SLI4_PARAMETERS:
 				phba->sli4_hba.pc_sli4_params.supported = 1;
@@ -4467,6 +4529,12 @@ lpfc_sli4_driver_resource_setup(struct l
 			default:
 				break;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* Read the port's SLI4 Parameters capabilities if supported. */
 		if (phba->sli4_hba.pc_sli4_params.supported)
@@ -4823,6 +4891,11 @@ lpfc_init_iocb_list(struct lpfc_hba *phb
 
 	/* Initialize and populate the iocb list per host.  */
 	INIT_LIST_HEAD(&phba->lpfc_iocb_list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < iocb_count; i++) {
 		iocbq_entry = kzalloc(sizeof(struct lpfc_iocbq), GFP_KERNEL);
 		if (iocbq_entry == NULL) {
@@ -4846,6 +4919,12 @@ lpfc_init_iocb_list(struct lpfc_hba *phb
 		list_add(&iocbq_entry->list, &phba->lpfc_iocb_list);
 		phba->total_iocbq_bufs++;
 		spin_unlock_irq(&phba->hbalock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -4983,6 +5062,11 @@ lpfc_init_sgl_list(struct lpfc_hba *phba
 		return -ENOMEM;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < els_xri_cnt; i++) {
 		sglq_entry = kzalloc(sizeof(struct lpfc_sglq), GFP_KERNEL);
 		if (sglq_entry == NULL) {
@@ -5010,6 +5094,12 @@ lpfc_init_sgl_list(struct lpfc_hba *phba
 		phba->sli4_hba.lpfc_els_sgl_array[i] = sglq_entry;
 		phba->sli4_hba.total_sglq_bufs++;
 		spin_unlock_irq(&phba->hbalock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
@@ -5515,11 +5605,22 @@ lpfc_sli_pci_mem_setup(struct lpfc_hba *
 
 	hbq_count = lpfc_sli_hbq_count();
 	ptr = phba->hbqslimp.virt;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < hbq_count; ++i) {
 		phba->hbqs[i].hbq_virt = ptr;
 		INIT_LIST_HEAD(&phba->hbqs[i].hbq_buffer_list);
 		ptr += (lpfc_hbq_defs[i]->entry_count *
 			sizeof(struct lpfc_hbq_entry));
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	phba->hbqs[LPFC_ELS_HBQ].hbq_alloc_buffer = lpfc_els_hbq_alloc;
 	phba->hbqs[LPFC_ELS_HBQ].hbq_free_buffer = lpfc_els_hbq_free;
@@ -6309,7 +6410,12 @@ lpfc_sli4_queue_create(struct lpfc_hba *
 			goto out_free_sp_eq;
 		}
 	}
-	for (fcp_eqidx = 0; fcp_eqidx < phba->cfg_fcp_eq_count; fcp_eqidx++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (fcp_eqidx = 0; fcp_eqidx < phba->cfg_fcp_eq_count; fcp_eqidx++) {
 		qdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.eq_esize,
 					      phba->sli4_hba.eq_ecount);
 		if (!qdesc) {
@@ -6318,6 +6424,12 @@ lpfc_sli4_queue_create(struct lpfc_hba *
 			goto out_free_fp_eq;
 		}
 		phba->sli4_hba.fp_eq[fcp_eqidx] = qdesc;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -6413,7 +6525,12 @@ lpfc_sli4_queue_create(struct lpfc_hba *
 				"WQ record array\n");
 		goto out_free_els_wq;
 	}
-	for (fcp_wqidx = 0; fcp_wqidx < phba->cfg_fcp_wq_count; fcp_wqidx++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (fcp_wqidx = 0; fcp_wqidx < phba->cfg_fcp_wq_count; fcp_wqidx++) {
 		qdesc = lpfc_sli4_queue_alloc(phba, phba->sli4_hba.wq_esize,
 					      phba->sli4_hba.wq_ecount);
 		if (!qdesc) {
@@ -6423,6 +6540,12 @@ lpfc_sli4_queue_create(struct lpfc_hba *
 			goto out_free_fcp_wq;
 		}
 		phba->sli4_hba.fcp_wq[fcp_wqidx] = qdesc;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -6457,9 +6580,20 @@ out_free_hdr_rq:
 	lpfc_sli4_queue_free(phba->sli4_hba.hdr_rq);
 	phba->sli4_hba.hdr_rq = NULL;
 out_free_fcp_wq:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (--fcp_wqidx; fcp_wqidx >= 0; fcp_wqidx--) {
 		lpfc_sli4_queue_free(phba->sli4_hba.fcp_wq[fcp_wqidx]);
 		phba->sli4_hba.fcp_wq[fcp_wqidx] = NULL;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	kfree(phba->sli4_hba.fcp_wq);
 out_free_els_wq:
@@ -6469,9 +6603,20 @@ out_free_mbx_wq:
 	lpfc_sli4_queue_free(phba->sli4_hba.mbx_wq);
 	phba->sli4_hba.mbx_wq = NULL;
 out_free_fcp_cq:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (--fcp_cqidx; fcp_cqidx >= 0; fcp_cqidx--) {
 		lpfc_sli4_queue_free(phba->sli4_hba.fcp_cq[fcp_cqidx]);
 		phba->sli4_hba.fcp_cq[fcp_cqidx] = NULL;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	kfree(phba->sli4_hba.fcp_cq);
 out_free_els_cq:
@@ -6481,9 +6626,20 @@ out_free_mbx_cq:
 	lpfc_sli4_queue_free(phba->sli4_hba.mbx_cq);
 	phba->sli4_hba.mbx_cq = NULL;
 out_free_fp_eq:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (--fcp_eqidx; fcp_eqidx >= 0; fcp_eqidx--) {
 		lpfc_sli4_queue_free(phba->sli4_hba.fp_eq[fcp_eqidx]);
 		phba->sli4_hba.fp_eq[fcp_eqidx] = NULL;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	kfree(phba->sli4_hba.fp_eq);
 out_free_sp_eq:
@@ -6601,7 +6757,12 @@ lpfc_sli4_queue_setup(struct lpfc_hba *p
 			phba->sli4_hba.sp_eq->queue_id);
 
 	/* Set up fast-path event queue */
-	for (fcp_eqidx = 0; fcp_eqidx < phba->cfg_fcp_eq_count; fcp_eqidx++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (fcp_eqidx = 0; fcp_eqidx < phba->cfg_fcp_eq_count; fcp_eqidx++) {
 		if (!phba->sli4_hba.fp_eq[fcp_eqidx]) {
 			lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
 					"0522 Fast-path EQ (%d) not "
@@ -6620,6 +6781,12 @@ lpfc_sli4_queue_setup(struct lpfc_hba *p
 				"2584 Fast-path EQ setup: "
 				"queue[%d]-id=%d\n", fcp_eqidx,
 				phba->sli4_hba.fp_eq[fcp_eqidx]->queue_id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -6744,7 +6911,12 @@ lpfc_sli4_queue_setup(struct lpfc_hba *p
 			phba->sli4_hba.els_cq->queue_id);
 
 	/* Set up fast-path FCP Work Queue */
-	for (fcp_wqidx = 0; fcp_wqidx < phba->cfg_fcp_wq_count; fcp_wqidx++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (fcp_wqidx = 0; fcp_wqidx < phba->cfg_fcp_wq_count; fcp_wqidx++) {
 		if (!phba->sli4_hba.fcp_wq[fcp_wqidx]) {
 			lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
 					"0534 Fast-path FCP WQ (%d) not "
@@ -6771,6 +6943,12 @@ lpfc_sli4_queue_setup(struct lpfc_hba *p
 		if (phba->cfg_fcp_eq_count)
 			fcp_cq_index = ((fcp_cq_index + 1) %
 					phba->cfg_fcp_eq_count);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -6886,12 +7064,23 @@ lpfc_sli4_cq_event_pool_create(struct lp
 	struct lpfc_cq_event *cq_event;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (4 * phba->sli4_hba.cq_ecount); i++) {
 		cq_event = kmalloc(sizeof(struct lpfc_cq_event), GFP_KERNEL);
 		if (!cq_event)
 			goto out_pool_create_fail;
 		list_add_tail(&cq_event->list,
 			      &phba->sli4_hba.sp_cqe_event_pool);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
@@ -7767,6 +7956,11 @@ enable_msix_vectors:
 	}
 
 	/* The rest of the vector(s) are associated to fast-path handler(s) */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 1; index < vectors; index++) {
 		phba->sli4_hba.fcp_eq_hdl[index - 1].idx = index - 1;
 		phba->sli4_hba.fcp_eq_hdl[index - 1].phba = phba;
@@ -7780,6 +7974,12 @@ enable_msix_vectors:
 					"request_irq failed (%d)\n", index, rc);
 			goto cfg_fail_out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	phba->sli4_hba.msix_vec_nr = vectors;
 
@@ -7863,9 +8063,20 @@ lpfc_sli4_enable_msi(struct lpfc_hba *ph
 		return rc;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < phba->cfg_fcp_eq_count; index++) {
 		phba->sli4_hba.fcp_eq_hdl[index].idx = index;
 		phba->sli4_hba.fcp_eq_hdl[index].phba = phba;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
@@ -7943,10 +8154,21 @@ lpfc_sli4_enable_intr(struct lpfc_hba *p
 			/* Indicate initialization to INTx mode */
 			phba->intr_type = INTx;
 			intr_mode = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (index = 0; index < phba->cfg_fcp_eq_count;
 			     index++) {
 				phba->sli4_hba.fcp_eq_hdl[index].idx = index;
 				phba->sli4_hba.fcp_eq_hdl[index].phba = phba;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
@@ -8970,7 +9192,12 @@ lpfc_write_firmware(struct lpfc_hba *phb
 				"3023 Updating Firmware. Current Version:%s "
 				"New Version:%s\n",
 				fwrev, image->revision);
-		for (i = 0; i < LPFC_MBX_WR_CONFIG_MAX_BDE; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < LPFC_MBX_WR_CONFIG_MAX_BDE; i++) {
 			dmabuf = kzalloc(sizeof(struct lpfc_dmabuf),
 					 GFP_KERNEL);
 			if (!dmabuf) {
@@ -8987,6 +9214,12 @@ lpfc_write_firmware(struct lpfc_hba *phb
 				goto out;
 			}
 			list_add_tail(&dmabuf->list, &dma_buffer_list);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		while (offset < fw->size) {
 			temp_offset = offset;
diff -u -p a/scsi/lpfc/lpfc_els.c b/scsi/lpfc/lpfc_els.c
--- a/scsi/lpfc/lpfc_els.c
+++ b/scsi/lpfc/lpfc_els.c
@@ -4350,9 +4350,20 @@ lpfc_els_flush_rscn(struct lpfc_vport *v
 	vport->fc_rscn_flush = 1;
 	spin_unlock_irq(shost->host_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < vport->fc_rscn_id_cnt; i++) {
 		lpfc_in_buf_free(phba, vport->fc_rscn_id_list[i]);
 		vport->fc_rscn_id_list[i] = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_lock_irq(shost->host_lock);
 	vport->fc_rscn_id_cnt = 0;
@@ -4403,6 +4414,11 @@ lpfc_rscn_payload_check(struct lpfc_vpor
 	/* Indicate we are walking fc_rscn_id_list on this vport */
 	vport->fc_rscn_flush = 1;
 	spin_unlock_irq(shost->host_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < vport->fc_rscn_id_cnt; i++) {
 		lp = vport->fc_rscn_id_list[i]->virt;
 		payload_len = be32_to_cpu(*lp++ & ~ELS_CMD_MASK);
@@ -4430,6 +4446,12 @@ lpfc_rscn_payload_check(struct lpfc_vpor
 				goto return_did_out;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Indicate we are done with walking fc_rscn_id_list on this vport */
 	vport->fc_rscn_flush = 0;
@@ -7012,11 +7034,22 @@ lpfc_cancel_all_vport_retry_delay_timer(
 	vports = lpfc_create_vport_work_array(phba);
 
 	if (vports) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 			ndlp = lpfc_findnode_did(vports[i], Fabric_DID);
 			if (ndlp)
 				lpfc_cancel_retry_delay_tmo(vports[i], ndlp);
 			lpfc_els_flush_cmd(vports[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		lpfc_destroy_vport_work_array(phba, vports);
 	}
diff -u -p a/scsi/lpfc/lpfc_mbox.c b/scsi/lpfc/lpfc_mbox.c
--- a/scsi/lpfc/lpfc_mbox.c
+++ b/scsi/lpfc/lpfc_mbox.c
@@ -947,7 +947,12 @@ lpfc_config_pcb_setup(struct lpfc_hba *
 
 	pcbp->maxRing = (psli->num_rings - 1);
 
-	for (i = 0; i < psli->num_rings; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < psli->num_rings; i++) {
 		pring = &psli->ring[i];
 
 		pring->sizeCiocb = phba->sli_rev == 3 ? SLI3_IOCB_CMD_SIZE:
@@ -988,6 +993,12 @@ lpfc_config_pcb_setup(struct lpfc_hba *
 		pcbp->rdsc[i].rspAddrHigh = putPaddrHigh(pdma_addr);
 		pcbp->rdsc[i].rspAddrLow = putPaddrLow(pdma_addr);
 		iocbCnt += pring->numRiocb;
+		if (_cur < timeout) {
+			 rdstcll(_cur);
+		}
+		else {
+			 break;
+		}
 	}
 }
 
@@ -1165,11 +1176,22 @@ lpfc_config_hbq(struct lpfc_hba *phba, u
 		return;
 
 	/* Otherwise we setup specific rctl / type masks for this HBQ */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < hbq_desc->mask_count; i++) {
 		hbqmb->hbqMasks[i].tmatch = hbq_desc->hbqMasks[i].tmatch;
 		hbqmb->hbqMasks[i].tmask  = hbq_desc->hbqMasks[i].tmask;
 		hbqmb->hbqMasks[i].rctlmatch = hbq_desc->hbqMasks[i].rctlmatch;
 		hbqmb->hbqMasks[i].rctlmask  = hbq_desc->hbqMasks[i].rctlmask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return;
@@ -1220,6 +1242,11 @@ lpfc_config_ring(struct lpfc_hba * phba,
 	}
 
 	/* Otherwise we setup specific rctl / type masks for this ring */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pring->num_mask; i++) {
 		mb->un.varCfgRing.rrRegs[i].rval = pring->prt[i].rctl;
 		if (mb->un.varCfgRing.rrRegs[i].rval != FC_RCTL_ELS_REQ)
@@ -1228,6 +1255,12 @@ lpfc_config_ring(struct lpfc_hba * phba,
 			mb->un.varCfgRing.rrRegs[i].rmask = 0xfe;
 		mb->un.varCfgRing.rrRegs[i].tval = pring->prt[i].type;
 		mb->un.varCfgRing.rrRegs[i].tmask = 0xff;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return;
@@ -1385,9 +1418,20 @@ lpfc_config_port(struct lpfc_hba *phba,
 		/* write HGP data to SLIM at the required longword offset */
 		memset(&hgp, 0, sizeof(struct lpfc_hgp));
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < phba->sli.num_rings; i++) {
 			lpfc_memcpy_to_slim(phba->host_gp + i, &hgp,
 				    sizeof(*phba->host_gp));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -1715,11 +1759,22 @@ lpfc_sli4_mbox_cmd_free(struct lpfc_hba
 		return;
 	}
 	/* Each non-embedded DMA memory was allocated in the length of a page */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sgentry = 0; sgentry < sgecount; sgentry++) {
 		lpfc_sli4_mbx_sge_get(mbox, sgentry, &sge);
 		phyaddr = getPaddr(sge.pa_hi, sge.pa_lo);
 		dma_free_coherent(&phba->pcidev->dev, SLI4_PAGE_SIZE,
 				  mbox->sge_array->addr[sgentry], phyaddr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Free the sge address array memory */
 	kfree(mbox->sge_array);
diff -u -p a/scsi/lpfc/lpfc_bsg.c b/scsi/lpfc/lpfc_bsg.c
--- a/scsi/lpfc/lpfc_bsg.c
+++ b/scsi/lpfc/lpfc_bsg.c
@@ -865,6 +865,11 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba
 				bdeBuf1 = iocbq->context2;
 				bdeBuf2 = iocbq->context3;
 			}
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < iocbq->iocb.ulpBdeCount; i++) {
 				if (phba->sli3_options &
 				    LPFC_SLI3_HBQ_ENABLED) {
@@ -943,6 +948,12 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba
 						break;
 					}
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
@@ -1501,9 +1512,20 @@ lpfc_bsg_diag_mode_enter(struct lpfc_hba
 
 	vports = lpfc_create_vport_work_array(phba);
 	if (vports) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i <= phba->max_vpi && vports[i] != NULL; i++) {
 			shost = lpfc_shost_from_vport(vports[i]);
 			scsi_block_requests(shost);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		lpfc_destroy_vport_work_array(phba, vports);
 	} else {
@@ -1535,9 +1557,20 @@ lpfc_bsg_diag_mode_exit(struct lpfc_hba
 
 	vports = lpfc_create_vport_work_array(phba);
 	if (vports) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i <= phba->max_vpi && vports[i] != NULL; i++) {
 			shost = lpfc_shost_from_vport(vports[i]);
 			scsi_unblock_requests(shost);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		lpfc_destroy_vport_work_array(phba, vports);
 	} else {
@@ -3445,6 +3478,11 @@ lpfc_bsg_sli_cfg_read_cmd_ext(struct lpf
 		goto job_error;
 	} else if (ext_buf_cnt > 1) {
 		/* additional external read buffers */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 1; i < ext_buf_cnt; i++) {
 			ext_dmabuf = lpfc_bsg_dma_page_alloc(phba);
 			if (!ext_dmabuf) {
@@ -3453,6 +3491,12 @@ lpfc_bsg_sli_cfg_read_cmd_ext(struct lpf
 			}
 			list_add_tail(&ext_dmabuf->list,
 				      &phba->mbox_ext_buf_ctx.ext_dmabuf_list);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -3619,6 +3663,11 @@ lpfc_bsg_sli_cfg_write_cmd_ext(struct lp
 					sta_pos_addr, dmabuf, ext_buf_cnt);
 
 	/* log for looking forward */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < ext_buf_cnt; i++) {
 		if (nemb_tp == nemb_mse)
 			lpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,
@@ -3631,6 +3680,12 @@ lpfc_bsg_sli_cfg_write_cmd_ext(struct lp
 				i, bsg_bf_get(lpfc_mbox_sli_config_ecmn_hbd_len,
 				&sli_cfg_mbx->un.sli_config_emb1_subsys.
 				hbd[i]));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* multi-buffer handling context */
diff -u -p a/scsi/lpfc/lpfc_ct.c b/scsi/lpfc/lpfc_ct.c
--- a/scsi/lpfc/lpfc_ct.c
+++ b/scsi/lpfc/lpfc_ct.c
@@ -147,7 +147,12 @@ lpfc_ct_unsol_event(struct lpfc_hba *phb
 			icmd = &iocbq->iocb;
 			if (icmd->ulpBdeCount == 0)
 				lpfc_ct_unsol_buffer(phba, iocbq, NULL, 0);
-			for (i = 0; i < icmd->ulpBdeCount; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (i = 0; i < icmd->ulpBdeCount; i++) {
 				paddr = getPaddr(icmd->un.cont64[i].addrHigh,
 						 icmd->un.cont64[i].addrLow);
 				mp = lpfc_sli_ringpostbuf_get(phba, pring,
@@ -155,6 +160,12 @@ lpfc_ct_unsol_event(struct lpfc_hba *phb
 				size = icmd->un.cont64[i].tus.f.bdeSize;
 				lpfc_ct_unsol_buffer(phba, iocbq, mp, size);
 				lpfc_in_buf_free(phba, mp);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			lpfc_post_buffer(phba, pring, i);
 		}
@@ -1489,6 +1500,11 @@ lpfc_fdmi_cmd(struct lpfc_vport *vport,
 			ae->ad.bits.AttrLen = be16_to_cpu(FOURBYTES + 8);
 			/* Convert JEDEC ID to ascii for hardware version */
 			incr = vp->rev.biuRev;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 0; i < 8; i++) {
 				j = (incr & 0xf);
 				if (j <= 9)
@@ -1500,6 +1516,12 @@ lpfc_fdmi_cmd(struct lpfc_vport *vport,
 					    (char)((uint8_t) 0x61 +
 						   (uint8_t) (j - 10));
 				incr = (incr >> 4);
+				if (_cur < timeout) {
+					    rdstcll(_cur);
+				}
+				else {
+					    break;
+				}
 			}
 			ab->EntryCnt++;
 			size += FOURBYTES + 8;
diff -u -p a/scsi/lpfc/lpfc_scsi.c b/scsi/lpfc/lpfc_scsi.c
--- a/scsi/lpfc/lpfc_scsi.c
+++ b/scsi/lpfc/lpfc_scsi.c
@@ -394,20 +394,32 @@ lpfc_ramp_down_queue_handler(struct lpfc
 	num_cmd_success = atomic_read(&phba->num_cmd_success);
 
 	vports = lpfc_create_vport_work_array(phba);
-	if (vports != NULL)
-		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
-			shost = lpfc_shost_from_vport(vports[i]);
-			shost_for_each_device(sdev, shost) {
-				new_queue_depth =
-					sdev->queue_depth * num_rsrc_err /
-					(num_rsrc_err + num_cmd_success);
-				if (!new_queue_depth)
-					new_queue_depth = sdev->queue_depth - 1;
-				else
+	if (vports != NULL) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
+				shost = lpfc_shost_from_vport(vports[i]);
+				shost_for_each_device(sdev, shost) {
+					new_queue_depth =
+						sdev->queue_depth * num_rsrc_err /
+						(num_rsrc_err + num_cmd_success);
+					if (!new_queue_depth)
+						new_queue_depth = sdev->queue_depth - 1;
+					else
 					new_queue_depth = sdev->queue_depth -
-								new_queue_depth;
-				lpfc_change_queue_depth(sdev, new_queue_depth,
-							SCSI_QDEPTH_DEFAULT);
+					new_queue_depth;
+								lpfc_change_queue_depth(sdev, new_queue_depth,
+					SCSI_QDEPTH_DEFAULT);
+				}
+				if (_cur < timeout) {
+								rdstcll(_cur);
+				}
+				else {
+								break;
+				}
 			}
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
@@ -433,16 +445,28 @@ lpfc_ramp_up_queue_handler(struct lpfc_h
 	int i;
 
 	vports = lpfc_create_vport_work_array(phba);
-	if (vports != NULL)
-		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
-			shost = lpfc_shost_from_vport(vports[i]);
-			shost_for_each_device(sdev, shost) {
-				if (vports[i]->cfg_lun_queue_depth <=
-				    sdev->queue_depth)
-					continue;
-				lpfc_change_queue_depth(sdev,
-							sdev->queue_depth+1,
-							SCSI_QDEPTH_RAMP_UP);
+	if (vports != NULL) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
+				shost = lpfc_shost_from_vport(vports[i]);
+				shost_for_each_device(sdev, shost) {
+					if (vports[i]->cfg_lun_queue_depth <=
+					sdev->queue_depth)
+						continue;
+					lpfc_change_queue_depth(sdev,
+					sdev->queue_depth+1,
+					SCSI_QDEPTH_RAMP_UP);
+				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
@@ -468,12 +492,24 @@ lpfc_scsi_dev_block(struct lpfc_hba *phb
 	int i;
 
 	vports = lpfc_create_vport_work_array(phba);
-	if (vports != NULL)
-		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
-			shost = lpfc_shost_from_vport(vports[i]);
-			shost_for_each_device(sdev, shost) {
-				rport = starget_to_rport(scsi_target(sdev));
-				fc_remote_port_delete(rport);
+	if (vports != NULL) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
+				shost = lpfc_shost_from_vport(vports[i]);
+				shost_for_each_device(sdev, shost) {
+					rport = starget_to_rport(scsi_target(sdev));
+					fc_remote_port_delete(rport);
+				}
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
@@ -690,7 +726,12 @@ lpfc_sli4_fcp_xri_aborted(struct lpfc_hb
 		}
 	}
 	spin_unlock(&phba->sli4_hba.abts_scsi_buf_list_lock);
-	for (i = 1; i <= phba->sli.last_iotag; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 1; i <= phba->sli.last_iotag; i++) {
 		iocbq = phba->sli.iocbq_lookup[i];
 
 		if (!(iocbq->iocb_flag &  LPFC_IO_FCP) ||
@@ -705,6 +746,12 @@ lpfc_sli4_fcp_xri_aborted(struct lpfc_hb
 			lpfc_worker_wake_up(phba);
 		return;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&phba->hbalock, iflag);
 }
@@ -728,6 +775,11 @@ lpfc_sli4_repost_scsi_sgl_list(struct lp
 	int index, status, bcnt = 0, rcnt = 0, rc = 0;
 	LIST_HEAD(sblist);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < phba->sli4_hba.scsi_xri_cnt; index++) {
 		psb = phba->sli4_hba.lpfc_scsi_psb_array[index];
 		if (psb) {
@@ -775,6 +827,12 @@ lpfc_sli4_repost_scsi_sgl_list(struct lp
 			/* Put it back into the SCSI buffer list */
 			lpfc_release_scsi_buf_s4(phba, psb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return rc;
 }
@@ -2874,9 +2932,20 @@ static void
 lpfc_fcpcmd_to_iocb(uint8_t *data, struct fcp_cmnd *fcp_cmnd)
 {
 	int i, j;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 0; i < sizeof(struct fcp_cmnd);
 	     i += sizeof(uint32_t), j++) {
 		((uint32_t *)data)[j] = cpu_to_be32(((uint32_t *)fcp_cmnd)[j]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -3883,6 +3952,11 @@ lpfc_bus_reset_handler(struct scsi_cmnd
 	 * targets known to the driver.  Should any target reset
 	 * fail, this routine returns failure to the midlayer.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < LPFC_MAX_TARGET; i++) {
 		/* Search for mapped node by target ID */
 		match = 0;
@@ -3910,6 +3984,12 @@ lpfc_bus_reset_handler(struct scsi_cmnd
 					 i);
 			ret = FAILED;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * We have to clean up i/o as : they may be orphaned by the TMFs
diff -u -p a/scsi/lpfc/lpfc_hbadisc.c b/scsi/lpfc/lpfc_hbadisc.c
--- a/scsi/lpfc/lpfc_hbadisc.c
+++ b/scsi/lpfc/lpfc_hbadisc.c
@@ -872,10 +872,22 @@ lpfc_linkdown(struct lpfc_hba *phba)
 		spin_unlock_irq(shost->host_lock);
 	}
 	vports = lpfc_create_vport_work_array(phba);
-	if (vports != NULL)
-		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
+	if (vports != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 			/* Issue a LINK DOWN event to all nodes */
-			lpfc_linkdown_port(vports[i]);
+				lpfc_linkdown_port(vports[i]);
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
+			}
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
 	/* Clean up any firmware default rpi's */
@@ -2792,6 +2804,11 @@ lpfc_start_fdiscs(struct lpfc_hba *phba)
 
 	vports = lpfc_create_vport_work_array(phba);
 	if (vports != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 			if (vports[i]->port_type == LPFC_PHYSICAL_PORT)
 				continue;
@@ -2820,6 +2837,12 @@ lpfc_start_fdiscs(struct lpfc_hba *phba)
 						 "0259 No NPIV "
 						 "Fabric support\n");
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	lpfc_destroy_vport_work_array(phba, vports);
@@ -3544,6 +3567,11 @@ lpfc_create_static_vport(struct lpfc_hba
 
 	shost = lpfc_shost_from_vport(phba->pport);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_STATIC_VPORT_COUNT; i++) {
 		memset(&vport_id, 0, sizeof(vport_id));
 		vport_id.port_name = wwn_to_u64(vport_info->vport_list[i].wwpn);
@@ -3565,7 +3593,13 @@ lpfc_create_static_vport(struct lpfc_hba
 
 		vport = *(struct lpfc_vport **)new_fc_vport->dd_data;
 		vport->vport_flag |= STATIC_VPORT;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+			}
+		}
 
 out:
 	kfree(vport_info);
@@ -4260,6 +4294,11 @@ lpfc_no_rpi(struct lpfc_hba *phba, struc
 	psli = &phba->sli;
 	if (ndlp->nlp_flag & NLP_RPI_REGISTERED) {
 		/* Now process each ring */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < psli->num_rings; i++) {
 			pring = &psli->ring[i];
 
@@ -4280,6 +4319,12 @@ lpfc_no_rpi(struct lpfc_hba *phba, struc
 				}
 			}
 			spin_unlock_irq(&phba->hbalock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -4353,6 +4398,11 @@ lpfc_unreg_hba_rpis(struct lpfc_hba *phb
 			"2884 Vport array allocation failed \n");
 		return;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 		shost = lpfc_shost_from_vport(vports[i]);
 		spin_lock_irq(shost->host_lock);
@@ -4365,6 +4415,12 @@ lpfc_unreg_hba_rpis(struct lpfc_hba *phb
 			}
 		}
 		spin_unlock_irq(shost->host_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	lpfc_destroy_vport_work_array(phba, vports);
 }
@@ -4735,15 +4791,31 @@ lpfc_disc_list_loopmap(struct lpfc_vport
 
 	/* Check for loop map present or not */
 	if (phba->alpa_map[0]) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 1; j <= phba->alpa_map[0]; j++) {
 			alpa = phba->alpa_map[j];
 			if (((vport->fc_myDID & 0xff) == alpa) || (alpa == 0))
 				continue;
 			lpfc_setup_disc_node(vport, alpa);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		/* No alpamap, so try all alpa's */
-		for (j = 0; j < FC_MAXLOOP; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (j = 0; j < FC_MAXLOOP; j++) {
 			/* If cfg_scan_down is set, start from highest
 			 * ALPA (0xef) to lowest (0x1).
 			 */
@@ -4755,6 +4827,12 @@ lpfc_disc_list_loopmap(struct lpfc_vport
 			if ((vport->fc_myDID & 0xff) == alpa)
 				continue;
 			lpfc_setup_disc_node(vport, alpa);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return;
@@ -5555,6 +5633,11 @@ lpfc_fcf_inuse(struct lpfc_hba *phba)
 	if (!vports)
 		return 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 		shost = lpfc_shost_from_vport(vports[i]);
 		spin_lock_irq(shost->host_lock);
@@ -5586,6 +5669,12 @@ lpfc_fcf_inuse(struct lpfc_hba *phba)
 			}
 		}
 		spin_unlock_irq(shost->host_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 out:
 	lpfc_destroy_vport_work_array(phba, vports);
@@ -5666,21 +5755,33 @@ lpfc_unregister_fcf_prep(struct lpfc_hba
 
 	/* Unregister VPIs */
 	vports = lpfc_create_vport_work_array(phba);
-	if (vports && (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED))
-		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
+	if (vports && (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 			/* Stop FLOGI/FDISC retries */
-			ndlp = lpfc_findnode_did(vports[i], Fabric_DID);
-			if (ndlp)
-				lpfc_cancel_retry_delay_tmo(vports[i], ndlp);
-			lpfc_cleanup_pending_mbox(vports[i]);
-			if (phba->sli_rev == LPFC_SLI_REV4)
-				lpfc_sli4_unreg_all_rpis(vports[i]);
-			lpfc_mbx_unreg_vpi(vports[i]);
-			shost = lpfc_shost_from_vport(vports[i]);
-			spin_lock_irq(shost->host_lock);
-			vports[i]->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;
-			vports[i]->vpi_state &= ~LPFC_VPI_REGISTERED;
-			spin_unlock_irq(shost->host_lock);
+				ndlp = lpfc_findnode_did(vports[i], Fabric_DID);
+				if (ndlp)
+					lpfc_cancel_retry_delay_tmo(vports[i], ndlp);
+				lpfc_cleanup_pending_mbox(vports[i]);
+				if (phba->sli_rev == LPFC_SLI_REV4)
+					lpfc_sli4_unreg_all_rpis(vports[i]);
+				lpfc_mbx_unreg_vpi(vports[i]);
+				shost = lpfc_shost_from_vport(vports[i]);
+				spin_lock_irq(shost->host_lock);
+				vports[i]->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;
+				vports[i]->vpi_state &= ~LPFC_VPI_REGISTERED;
+				spin_unlock_irq(shost->host_lock);
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
+			}
 		}
 	lpfc_destroy_vport_work_array(phba, vports);
 
@@ -5910,7 +6011,12 @@ lpfc_read_fcf_conn_tbl(struct lpfc_hba *
 	conn_rec = (struct lpfc_fcf_conn_rec *)
 		(buff + sizeof(struct lpfc_fcf_conn_hdr));
 
-	for (i = 0; i < record_count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < record_count; i++) {
 		if (!(conn_rec[i].flags & FCFCNCT_VALID))
 			continue;
 		conn_entry = kzalloc(sizeof(struct lpfc_fcf_conn_entry),
@@ -5930,6 +6036,12 @@ lpfc_read_fcf_conn_tbl(struct lpfc_hba *
 			le16_to_cpu(conn_entry->conn_rec.flags);
 		list_add_tail(&conn_entry->list,
 			&phba->fcf_conn_rec_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/lpfc/lpfc_mem.c b/scsi/lpfc/lpfc_mem.c
--- a/scsi/lpfc/lpfc_mem.c
+++ b/scsi/lpfc/lpfc_mem.c
@@ -92,13 +92,24 @@ lpfc_mem_alloc(struct lpfc_hba *phba, in
 
 	pool->max_count = 0;
 	pool->current_count = 0;
-	for ( i = 0; i < LPFC_MBUF_POOL_SIZE; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for ( i = 0; i < LPFC_MBUF_POOL_SIZE; i++) {
 		pool->elements[i].virt = pci_pool_alloc(phba->lpfc_mbuf_pool,
 				       GFP_KERNEL, &pool->elements[i].phys);
 		if (!pool->elements[i].virt)
 			goto fail_free_mbuf_pool;
 		pool->max_count++;
 		pool->current_count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	phba->mbox_mem_pool = mempool_create_kmalloc_pool(LPFC_MEM_POOL_SIZE,
diff -u -p a/scsi/fnic/fnic_fcs.c b/scsi/fnic/fnic_fcs.c
--- a/scsi/fnic/fnic_fcs.c
+++ b/scsi/fnic/fnic_fcs.c
@@ -403,7 +403,12 @@ int fnic_rq_cmpl_handler(struct fnic *fn
 	unsigned int i;
 	int err;
 
-	for (i = 0; i < fnic->rq_count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < fnic->rq_count; i++) {
 		cur_work_done = vnic_cq_service(&fnic->cq[i], rq_work_to_do,
 						fnic_rq_cmpl_handler_cont,
 						NULL);
@@ -415,6 +420,12 @@ int fnic_rq_cmpl_handler(struct fnic *fn
 					     " frame\n");
 		}
 		tot_rq_work_done += cur_work_done;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return tot_rq_work_done;
@@ -696,11 +707,22 @@ int fnic_wq_cmpl_handler(struct fnic *fn
 	unsigned int wq_work_done = 0;
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->raw_wq_count; i++) {
 		wq_work_done  += vnic_cq_service(&fnic->cq[fnic->rq_count+i],
 						 work_to_do,
 						 fnic_wq_cmpl_handler_cont,
 						 NULL);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return wq_work_done;
diff -u -p a/scsi/fnic/vnic_wq_copy.c b/scsi/fnic/vnic_wq_copy.c
--- a/scsi/fnic/vnic_wq_copy.c
+++ b/scsi/fnic/vnic_wq_copy.c
@@ -34,10 +34,21 @@ int vnic_wq_copy_disable(struct vnic_wq_
 	iowrite32(0, &wq->ctrl->enable);
 
 	/* Wait for HW to ACK disable request */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (wait = 0; wait < 100; wait++) {
 		if (!(ioread32(&wq->ctrl->running)))
 			return 0;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_ERR "Failed to disable Copy WQ[%d],"
diff -u -p a/scsi/fnic/fnic_res.c b/scsi/fnic/fnic_res.c
--- a/scsi/fnic/fnic_res.c
+++ b/scsi/fnic/fnic_res.c
@@ -252,35 +252,73 @@ int fnic_alloc_vnic_resources(struct fni
 		     fnic->rq_count, fnic->cq_count, fnic->intr_count);
 
 	/* Allocate Raw WQ used for FCS frames */
-	for (i = 0; i < fnic->raw_wq_count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < fnic->raw_wq_count; i++) {
 		err = vnic_wq_alloc(fnic->vdev, &fnic->wq[i], i,
 			fnic->config.wq_enet_desc_count,
 			sizeof(struct wq_enet_desc));
 		if (err)
 			goto err_out_cleanup;
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 	}
 
 	/* Allocate Copy WQs used for SCSI IOs */
-	for (i = 0; i < fnic->wq_copy_count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < fnic->wq_copy_count; i++) {
 		err = vnic_wq_copy_alloc(fnic->vdev, &fnic->wq_copy[i],
 			(fnic->raw_wq_count + i),
 			fnic->config.wq_copy_desc_count,
 			sizeof(struct fcpio_host_req));
 		if (err)
 			goto err_out_cleanup;
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 	}
 
 	/* RQ for receiving FCS frames */
-	for (i = 0; i < fnic->rq_count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < fnic->rq_count; i++) {
 		err = vnic_rq_alloc(fnic->vdev, &fnic->rq[i], i,
 			fnic->config.rq_desc_count,
 			sizeof(struct rq_enet_desc));
 		if (err)
 			goto err_out_cleanup;
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 	}
 
 	/* CQ for each RQ */
-	for (i = 0; i < fnic->rq_count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < fnic->rq_count; i++) {
 		cq_index = i;
 		err = vnic_cq_alloc(fnic->vdev,
 			&fnic->cq[cq_index], cq_index,
@@ -288,9 +326,20 @@ int fnic_alloc_vnic_resources(struct fni
 			sizeof(struct cq_enet_rq_desc));
 		if (err)
 			goto err_out_cleanup;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* CQ for each WQ */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->raw_wq_count; i++) {
 		cq_index = fnic->rq_count + i;
 		err = vnic_cq_alloc(fnic->vdev, &fnic->cq[cq_index], cq_index,
@@ -298,10 +347,21 @@ int fnic_alloc_vnic_resources(struct fni
 			sizeof(struct cq_enet_wq_desc));
 		if (err)
 			goto err_out_cleanup;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* CQ for each COPY WQ */
 	wq_copy_cq_desc_count = (fnic->config.wq_copy_desc_count * 3);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->wq_copy_count; i++) {
 		cq_index = fnic->raw_wq_count + fnic->rq_count + i;
 		err = vnic_cq_alloc(fnic->vdev, &fnic->cq[cq_index],
@@ -310,12 +370,29 @@ int fnic_alloc_vnic_resources(struct fni
 			sizeof(struct fcpio_fw_req));
 		if (err)
 			goto err_out_cleanup;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->intr_count; i++) {
 		err = vnic_intr_alloc(fnic->vdev, &fnic->intr[i], i);
 		if (err)
 			goto err_out_cleanup;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	fnic->legacy_pba = vnic_dev_get_res(fnic->vdev,
@@ -352,30 +429,68 @@ int fnic_alloc_vnic_resources(struct fni
 		break;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->rq_count; i++) {
 		cq_index = i;
 		vnic_rq_init(&fnic->rq[i],
 			     cq_index,
 			     error_interrupt_enable,
 			     error_interrupt_offset);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->raw_wq_count; i++) {
 		cq_index = i + fnic->rq_count;
 		vnic_wq_init(&fnic->wq[i],
 			     cq_index,
 			     error_interrupt_enable,
 			     error_interrupt_offset);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->wq_copy_count; i++) {
 		vnic_wq_copy_init(&fnic->wq_copy[i],
 				  0 /* cq_index 0 - always */,
 				  error_interrupt_enable,
 				  error_interrupt_offset);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
-	for (i = 0; i < fnic->cq_count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < fnic->cq_count; i++) {
 
 		switch (intr_mode) {
 		case VNIC_DEV_INTR_MODE_MSIX:
@@ -397,6 +512,12 @@ int fnic_alloc_vnic_resources(struct fni
 			0 /* cq_message_enable */,
 			interrupt_offset,
 			0 /* cq_message_addr */);
+	if (_cur < timeout) {
+			rdstcll(_cur);
+	}
+	else {
+			break;
+	}
 	}
 
 	/*
@@ -416,11 +537,22 @@ int fnic_alloc_vnic_resources(struct fni
 		break;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->intr_count; i++) {
 		vnic_intr_init(&fnic->intr[i],
 			fnic->config.intr_timer,
 			fnic->config.intr_timer_type,
 			mask_on_assertion);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* init the stats memory by making the first call here */
diff -u -p a/scsi/fnic/fnic_main.c b/scsi/fnic/fnic_main.c
--- a/scsi/fnic/fnic_main.c
+++ b/scsi/fnic/fnic_main.c
@@ -213,28 +213,61 @@ void fnic_log_q_error(struct fnic *fnic)
 	unsigned int i;
 	u32 error_status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->raw_wq_count; i++) {
 		error_status = ioread32(&fnic->wq[i].ctrl->error_status);
 		if (error_status)
 			shost_printk(KERN_ERR, fnic->lport->host,
 				     "WQ[%d] error_status"
 				     " %d\n", i, error_status);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->rq_count; i++) {
 		error_status = ioread32(&fnic->rq[i].ctrl->error_status);
 		if (error_status)
 			shost_printk(KERN_ERR, fnic->lport->host,
 				     "RQ[%d] error_status"
 				     " %d\n", i, error_status);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->wq_copy_count; i++) {
 		error_status = ioread32(&fnic->wq_copy[i].ctrl->error_status);
 		if (error_status)
 			shost_printk(KERN_ERR, fnic->lport->host,
 				     "CWQ[%d] error_status"
 				     " %d\n", i, error_status);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -340,20 +373,53 @@ static int fnic_cleanup(struct fnic *fni
 	for (i = 0; i < fnic->intr_count; i++)
 		vnic_intr_mask(&fnic->intr[i]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->rq_count; i++) {
 		err = vnic_rq_disable(&fnic->rq[i]);
 		if (err)
 			return err;
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->raw_wq_count; i++) {
 		err = vnic_wq_disable(&fnic->wq[i]);
 		if (err)
 			return err;
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->wq_copy_count; i++) {
 		err = vnic_wq_copy_disable(&fnic->wq_copy[i]);
 		if (err)
 			return err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* Clean up completed IOs and FCS frames */
@@ -578,11 +644,22 @@ static int __devinit fnic_probe(struct p
 	for (i = 0; i < FNIC_WQ_MAX; i++)
 		spin_lock_init(&fnic->wq_lock[i]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < FNIC_WQ_COPY_MAX; i++) {
 		spin_lock_init(&fnic->wq_copy_lock[i]);
 		fnic->wq_copy_desc_low[i] = DESC_CLEAN_LOW_WATERMARK;
 		fnic->fw_ack_recd[i] = 0;
 		fnic->fw_ack_index[i] = -1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	for (i = 0; i < FNIC_IO_LOCKS; i++)
@@ -642,6 +719,11 @@ static int __devinit fnic_probe(struct p
 			    fnic_notify_timer, (unsigned long)fnic);
 
 	/* allocate RQ buffers and post them to RQ*/
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fnic->rq_count; i++) {
 		err = vnic_rq_fill(&fnic->rq[i], fnic_alloc_rq_frame);
 		if (err) {
@@ -650,6 +732,12 @@ static int __devinit fnic_probe(struct p
 				     "frame\n");
 			goto err_out_free_rq_buf;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/scsi/fnic/vnic_dev.c b/scsi/fnic/vnic_dev.c
--- a/scsi/fnic/vnic_dev.c
+++ b/scsi/fnic/vnic_dev.c
@@ -262,6 +262,11 @@ int vnic_dev_cmd(struct vnic_dev *vdev,
 	if ((_CMD_FLAGS(cmd) & _CMD_FLAGS_NOWAIT))
 			return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (delay = 0; delay < wait; delay++) {
 
 		udelay(100);
@@ -284,6 +289,12 @@ int vnic_dev_cmd(struct vnic_dev *vdev,
 
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_ERR "Timedout devcmd %d\n", _CMD_N(cmd));
diff -u -p a/scsi/fnic/vnic_rq.c b/scsi/fnic/vnic_rq.c
--- a/scsi/fnic/vnic_rq.c
+++ b/scsi/fnic/vnic_rq.c
@@ -33,17 +33,38 @@ static int vnic_rq_alloc_bufs(struct vni
 
 	vdev = rq->vdev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < blks; i++) {
 		rq->bufs[i] = kzalloc(VNIC_RQ_BUF_BLK_SZ, GFP_ATOMIC);
 		if (!rq->bufs[i]) {
 			printk(KERN_ERR "Failed to alloc rq_bufs\n");
 			return -ENOMEM;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < blks; i++) {
 		buf = rq->bufs[i];
-		for (j = 0; j < VNIC_RQ_BUF_BLK_ENTRIES; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (j = 0; j < VNIC_RQ_BUF_BLK_ENTRIES; j++) {
 			buf->index = i * VNIC_RQ_BUF_BLK_ENTRIES + j;
 			buf->desc = (u8 *)rq->ring.descs +
 				rq->ring.desc_size * buf->index;
@@ -56,6 +77,18 @@ static int vnic_rq_alloc_bufs(struct vni
 				buf->next = buf + 1;
 				buf++;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -74,9 +107,20 @@ void vnic_rq_free(struct vnic_rq *rq)
 
 	vnic_dev_free_desc_ring(vdev, &rq->ring);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < VNIC_RQ_BUF_BLKS_MAX; i++) {
 		kfree(rq->bufs[i]);
 		rq->bufs[i] = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rq->ctrl = NULL;
@@ -154,10 +198,21 @@ int vnic_rq_disable(struct vnic_rq *rq)
 	iowrite32(0, &rq->ctrl->enable);
 
 	/* Wait for HW to ACK disable request */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (wait = 0; wait < 100; wait++) {
 		if (!(ioread32(&rq->ctrl->running)))
 			return 0;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_ERR "Failed to disable RQ[%d]\n", rq->index);
diff -u -p a/scsi/fnic/vnic_wq.c b/scsi/fnic/vnic_wq.c
--- a/scsi/fnic/vnic_wq.c
+++ b/scsi/fnic/vnic_wq.c
@@ -33,17 +33,38 @@ static int vnic_wq_alloc_bufs(struct vni
 
 	vdev = wq->vdev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < blks; i++) {
 		wq->bufs[i] = kzalloc(VNIC_WQ_BUF_BLK_SZ, GFP_ATOMIC);
 		if (!wq->bufs[i]) {
 			printk(KERN_ERR "Failed to alloc wq_bufs\n");
 			return -ENOMEM;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < blks; i++) {
 		buf = wq->bufs[i];
-		for (j = 0; j < VNIC_WQ_BUF_BLK_ENTRIES; j++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (j = 0; j < VNIC_WQ_BUF_BLK_ENTRIES; j++) {
 			buf->index = i * VNIC_WQ_BUF_BLK_ENTRIES + j;
 			buf->desc = (u8 *)wq->ring.descs +
 				wq->ring.desc_size * buf->index;
@@ -56,6 +77,18 @@ static int vnic_wq_alloc_bufs(struct vni
 				buf->next = buf + 1;
 				buf++;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -73,9 +106,20 @@ void vnic_wq_free(struct vnic_wq *wq)
 
 	vnic_dev_free_desc_ring(vdev, &wq->ring);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < VNIC_WQ_BUF_BLKS_MAX; i++) {
 		kfree(wq->bufs[i]);
 		wq->bufs[i] = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	wq->ctrl = NULL;
@@ -145,10 +189,21 @@ int vnic_wq_disable(struct vnic_wq *wq)
 	iowrite32(0, &wq->ctrl->enable);
 
 	/* Wait for HW to ACK disable request */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (wait = 0; wait < 100; wait++) {
 		if (!(ioread32(&wq->ctrl->running)))
 			return 0;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_ERR "Failed to disable WQ[%d]\n", wq->index);
diff -u -p a/scsi/fnic/fnic_scsi.c b/scsi/fnic/fnic_scsi.c
--- a/scsi/fnic/fnic_scsi.c
+++ b/scsi/fnic/fnic_scsi.c
@@ -933,12 +933,23 @@ int fnic_wq_copy_cmpl_handler(struct fni
 	unsigned int i, cq_index;
 	unsigned int cur_work_done;
 
-	for (i = 0; i < fnic->wq_copy_count; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < fnic->wq_copy_count; i++) {
 		cq_index = i + fnic->raw_wq_count + fnic->rq_count;
 		cur_work_done = vnic_cq_copy_service(&fnic->cq[cq_index],
 						     fnic_fcpio_cmpl_handler,
 						     copy_work_to_do);
 		wq_work_done += cur_work_done;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return wq_work_done;
 }
@@ -951,6 +962,11 @@ static void fnic_cleanup_io(struct fnic
 	struct scsi_cmnd *sc;
 	spinlock_t *io_lock;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < FNIC_MAX_IO_REQ; i++) {
 		if (i == exclude_id)
 			continue;
@@ -986,6 +1002,12 @@ cleanup_scsi_cmd:
 		/* Complete the command to SCSI */
 		if (sc->scsi_done)
 			sc->scsi_done(sc);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 }
 
@@ -1081,6 +1103,11 @@ void fnic_rport_exch_reset(struct fnic *
 	if (fnic->in_remove)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tag = 0; tag < FNIC_MAX_IO_REQ; tag++) {
 		sc = scsi_host_find_tag(fnic->lport->host, tag);
 		if (!sc)
@@ -1134,6 +1161,12 @@ void fnic_rport_exch_reset(struct fnic *
 				CMD_STATE(sc) = old_ioreq_state;
 			spin_unlock_irqrestore(io_lock, flags);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -1161,6 +1194,11 @@ void fnic_terminate_rport_io(struct fc_r
 	if (fnic->in_remove)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tag = 0; tag < FNIC_MAX_IO_REQ; tag++) {
 		sc = scsi_host_find_tag(fnic->lport->host, tag);
 		if (!sc)
@@ -1219,6 +1257,12 @@ void fnic_terminate_rport_io(struct fc_r
 				CMD_STATE(sc) = old_ioreq_state;
 			spin_unlock_irqrestore(io_lock, flags);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -1422,6 +1466,11 @@ static int fnic_clean_pending_aborts(str
 	struct scsi_device *lun_dev = lr_sc->device;
 	DECLARE_COMPLETION_ONSTACK(tm_done);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tag = 0; tag < FNIC_MAX_IO_REQ; tag++) {
 		sc = scsi_host_find_tag(fnic->lport->host, tag);
 		/*
@@ -1496,6 +1545,12 @@ static int fnic_clean_pending_aborts(str
 
 		fnic_release_ioreq_buf(fnic, io_req, sc);
 		mempool_free(io_req, fnic->io_req_pool);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 clean_pending_aborts_end:
diff -u -p a/scsi/sym53c416.c b/scsi/sym53c416.c
--- a/scsi/sym53c416.c
+++ b/scsi/sym53c416.c
@@ -648,6 +648,11 @@ int __init sym53c416_detect(struct scsi_
 #endif
 	printk(KERN_INFO "sym53c416.c: %s\n", VERSION_STRING);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; id_table[i].vendor != 0; i++) {
 		while((idev=pnp_find_dev(NULL, id_table[i].vendor,
 					id_table[i].function, idev))!=NULL)
@@ -675,10 +680,21 @@ int __init sym53c416_detect(struct scsi_
 				i[1], i[2]);
  			sym53c416_setup(NULL, i);
  		}
+ 		if (_cur < timeout) {
+ 			rdstcll(_cur);
+ 		}
+ 		else {
+ 			break;
+ 		}
 	}
 	sym53c416_probe();
 
 	/* Now we register and set up each host adapter found... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(count = 0, i = 0; i < host_index; i++) {
 		if (!request_region(hosts[i].base, IO_RANGE, ID))
 			continue;
@@ -715,6 +731,12 @@ int __init sym53c416_detect(struct scsi_
 		scsi_unregister(shpnt);
  fail_release_region:
 		release_region(hosts[i].base, IO_RANGE);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return count;
 }
diff -u -p a/scsi/libiscsi_tcp.c b/scsi/libiscsi_tcp.c
--- a/scsi/libiscsi_tcp.c
+++ b/scsi/libiscsi_tcp.c
@@ -1117,6 +1117,11 @@ int iscsi_tcp_r2tpool_alloc(struct iscsi
 	/*
 	 * initialize per-task: R2T pool and xmit queue
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cmd_i = 0; cmd_i < session->cmds_max; cmd_i++) {
 	        struct iscsi_task *task = session->cmds[cmd_i];
 		struct iscsi_tcp_task *tcp_task = task->dd_data;
@@ -1140,17 +1145,34 @@ int iscsi_tcp_r2tpool_alloc(struct iscsi
 			iscsi_pool_free(&tcp_task->r2tpool);
 			goto r2t_alloc_fail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
 
 r2t_alloc_fail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < cmd_i; i++) {
 		struct iscsi_task *task = session->cmds[i];
 		struct iscsi_tcp_task *tcp_task = task->dd_data;
 
 		kfifo_free(&tcp_task->r2tqueue);
 		iscsi_pool_free(&tcp_task->r2tpool);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return -ENOMEM;
 }
@@ -1160,12 +1182,23 @@ void iscsi_tcp_r2tpool_free(struct iscsi
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < session->cmds_max; i++) {
 		struct iscsi_task *task = session->cmds[i];
 		struct iscsi_tcp_task *tcp_task = task->dd_data;
 
 		kfifo_free(&tcp_task->r2tqueue);
 		iscsi_pool_free(&tcp_task->r2tpool);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(iscsi_tcp_r2tpool_free);
diff -u -p a/scsi/bfa/bfa_svc.c b/scsi/bfa/bfa_svc.c
--- a/scsi/bfa/bfa_svc.c
+++ b/scsi/bfa/bfa_svc.c
@@ -446,6 +446,11 @@ claim_fcxps_mem(struct bfa_fcxp_mod_s *m
 
 	mod->fcxp_list = fcxp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mod->num_fcxps; i++) {
 		fcxp->fcxp_mod = mod;
 		fcxp->fcxp_tag = i;
@@ -455,6 +460,12 @@ claim_fcxps_mem(struct bfa_fcxp_mod_s *m
 		fcxp->reqq_waiting = BFA_FALSE;
 
 		fcxp = fcxp + 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bfa_mem_kva_curp(mod) = (void *)fcxp;
@@ -1152,9 +1163,20 @@ bfa_fcxp_res_recfg(struct bfa_s *bfa, u1
 	struct list_head	*qe;
 	int	i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (mod->num_fcxps - num_fcxp_fw); i++) {
 		bfa_q_deq_tail(&mod->fcxp_free_q, &qe);
 		list_add_tail(qe, &mod->fcxp_unused_q);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1490,12 +1512,23 @@ bfa_lps_attach(struct bfa_s *bfa, void *
 	INIT_LIST_HEAD(&mod->lps_active_q);
 	INIT_LIST_HEAD(&mod->lps_login_q);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mod->num_lps; i++, lps++) {
 		lps->bfa	= bfa;
 		lps->bfa_tag	= (u8) i;
 		lps->reqq	= BFA_REQQ_LPS;
 		bfa_reqq_winit(&lps->wqe, bfa_lps_reqq_resume, lps);
 		list_add_tail(&lps->qe, &mod->lps_free_q);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1944,9 +1977,20 @@ bfa_lps_get_tag_from_pid(struct bfa_s *b
 	struct bfa_lps_s	*lps;
 	int			i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, lps = mod->lps_arr; i < mod->num_lps; i++, lps++) {
 		if (lps->lp_pid == pid)
 			return lps->bfa_tag;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* Return base port tag anyway */
@@ -3131,7 +3175,12 @@ bfa_fcport_fcoe_stats_swap(struct bfa_fc
 	__be32	*sip = (__be32 *) s;
 	int		i;
 
-	for (i = 0; i < ((sizeof(struct bfa_fcoe_stats_s))/sizeof(u32));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (i = 0; i < ((sizeof(struct bfa_fcoe_stats_s))/sizeof(u32));
 	     i = i + 2) {
 #ifdef __BIG_ENDIAN
 		dip[i] = be32_to_cpu(sip[i]);
@@ -3140,6 +3189,12 @@ bfa_fcport_fcoe_stats_swap(struct bfa_fc
 		dip[i] = be32_to_cpu(sip[i + 1]);
 		dip[i + 1] = be32_to_cpu(sip[i]);
 #endif
+if (_cur < timeout) {
+		rdstcll(_cur);
+}
+else {
+		break;
+}
 	}
 }
 
@@ -3318,6 +3373,11 @@ bfa_trunk_scn(struct bfa_fcport_s *fcpor
 	if (fcport->cfg.trunked && (trunk->attr.state != BFA_TRUNK_DISABLED))
 		trunk->attr.state = scn->trunk_state;
 	trunk->attr.speed = scn->trunk_speed;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < BFA_TRUNK_MAX_PORTS; i++) {
 		lattr = &trunk->attr.link_attr[i];
 		tlink = &scn->tlink[i];
@@ -3339,6 +3399,12 @@ bfa_trunk_scn(struct bfa_fcport_s *fcpor
 		bfa_trc(fcport->bfa, lattr->fctl);
 		bfa_trc(fcport->bfa, lattr->speed);
 		bfa_trc(fcport->bfa, lattr->deskew);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+	}
+	else {
+			break;
+	}
 	}
 
 	switch (link_bm) {
@@ -3384,7 +3450,12 @@ bfa_trunk_iocdisable(struct bfa_s *bfa)
 
 		fcport->trunk.attr.state = BFA_TRUNK_OFFLINE;
 		fcport->trunk.attr.speed = BFA_PORT_SPEED_UNKNOWN;
-		for (i = 0; i < BFA_TRUNK_MAX_PORTS; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < BFA_TRUNK_MAX_PORTS; i++) {
 			fcport->trunk.attr.link_attr[i].trunk_wwn = 0;
 			fcport->trunk.attr.link_attr[i].fctl =
 						BFA_TRUNK_LINK_FCTL_NORMAL;
@@ -3393,6 +3464,12 @@ bfa_trunk_iocdisable(struct bfa_s *bfa)
 			fcport->trunk.attr.link_attr[i].speed =
 						BFA_PORT_SPEED_UNKNOWN;
 			fcport->trunk.attr.link_attr[i].deskew = 0;
+			if (_cur < timeout) {
+						rdstcll(_cur);
+			}
+			else {
+						break;
+			}
 		}
 	}
 }
@@ -4495,6 +4572,11 @@ bfa_rport_attach(struct bfa_s *bfa, void
 	WARN_ON(!mod->num_rports ||
 		   (mod->num_rports & (mod->num_rports - 1)));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < mod->num_rports; i++, rp++) {
 		memset(rp, 0, sizeof(struct bfa_rport_s));
 		rp->bfa = bfa;
@@ -4508,6 +4590,12 @@ bfa_rport_attach(struct bfa_s *bfa, void
 			list_add_tail(&rp->qe, &mod->rp_free_q);
 
 		bfa_reqq_winit(&rp->reqq_wait, bfa_rport_qresume, rp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -4708,9 +4796,20 @@ bfa_rport_res_recfg(struct bfa_s *bfa, u
 	struct list_head	*qe;
 	int	i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (mod->num_rports - num_rport_fw); i++) {
 		bfa_q_deq_tail(&mod->rp_free_q, &qe);
 		list_add_tail(qe, &mod->rp_unused_q);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4933,10 +5032,21 @@ bfa_sgpg_malloc(struct bfa_s *bfa, struc
 	if (mod->free_sgpgs < nsgpgs)
 		return BFA_STATUS_ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nsgpgs; i++) {
 		bfa_q_deq(&mod->sgpg_q, &hsgpg);
 		WARN_ON(!hsgpg);
 		list_add_tail(&hsgpg->qe, sgpg_q);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mod->free_sgpgs -= nsgpgs;
@@ -5051,6 +5161,11 @@ claim_uf_post_msgs(struct bfa_uf_mod_s *
 	ufm->uf_buf_posts = (struct bfi_uf_buf_post_s *) bfa_mem_kva_curp(ufm);
 	uf_bp_msg = ufm->uf_buf_posts;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, uf_bp_msg = ufm->uf_buf_posts; i < ufm->num_ufs;
 	     i++, uf_bp_msg++) {
 		memset(uf_bp_msg, 0, sizeof(struct bfi_uf_buf_post_s));
@@ -5061,6 +5176,12 @@ claim_uf_post_msgs(struct bfa_uf_mod_s *
 		bfi_h2i_set(uf_bp_msg->mh, BFI_MC_UF, BFI_UF_H2I_BUF_POST,
 			    bfa_fn_lpu(ufm->bfa));
 		bfa_alen_set(&uf_bp_msg->alen, buf_len, ufm_pbs_pa(ufm, i));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/*
@@ -5083,6 +5204,11 @@ claim_ufs(struct bfa_uf_mod_s *ufm)
 	/*
 	 * Initialize UFs and queue it in UF free queue
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, uf = ufm->uf_list; i < ufm->num_ufs; i++, uf++) {
 		memset(uf, 0, sizeof(struct bfa_uf_s));
 		uf->bfa = ufm->bfa;
@@ -5091,6 +5217,12 @@ claim_ufs(struct bfa_uf_mod_s *ufm)
 		uf->buf_kva = bfa_mem_get_dmabuf_kva(ufm, i, BFA_PER_UF_DMA_SZ);
 		uf->buf_pa = ufm_pbs_pa(ufm, i);
 		list_add_tail(&uf->qe, &ufm->uf_free_q);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -5327,9 +5459,20 @@ bfa_uf_res_recfg(struct bfa_s *bfa, u16
 	struct list_head	*qe;
 	int	i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (mod->num_ufs - num_uf_fw); i++) {
 		bfa_q_deq_tail(&mod->uf_free_q, &qe);
 		list_add_tail(qe, &mod->uf_unused_q);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/bfa/bfa_fcs_lport.c b/scsi/bfa/bfa_fcs_lport.c
--- a/scsi/bfa/bfa_fcs_lport.c
+++ b/scsi/bfa/bfa_fcs_lport.c
@@ -4266,6 +4266,11 @@ bfa_fcs_lport_ns_process_gidft_pids(stru
 	struct bfa_fcs_rport_s *rport;
 	u32        ii;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ii = 0; ii < n_pids; ii++) {
 		gidft_entry = (struct fcgs_gidft_resp_s *) &pid_buf[ii];
 
@@ -4295,6 +4300,12 @@ bfa_fcs_lport_ns_process_gidft_pids(stru
 		 */
 		if (gidft_entry->last)
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -4353,9 +4364,20 @@ bfa_fcs_lport_ns_boot_target_disc(bfa_fc
 
 	bfa_iocfc_get_bootwwns(port->fcs->bfa, &nwwns, wwns);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ii = 0 ; ii < nwwns; ++ii) {
 		rport = bfa_fcs_rport_create_by_wwn(port, wwns[ii]);
 		WARN_ON(!rport);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4765,6 +4787,11 @@ bfa_fcs_lport_scn_process_rscn(struct bf
 
 	bfa_fcs_lport_scn_send_ls_acc(port, fchs);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_entries; i++) {
 		rscn_pid = rscn->event[i].portid;
 
@@ -4821,6 +4848,12 @@ bfa_fcs_lport_scn_process_rscn(struct bf
 			WARN_ON(1);
 			nsquery = BFA_TRUE;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/scsi/bfa/bfad_bsg.c b/scsi/bfa/bfad_bsg.c
--- a/scsi/bfa/bfad_bsg.c
+++ b/scsi/bfa/bfad_bsg.c
@@ -2946,11 +2946,22 @@ bfad_fcxp_free_mem(struct bfad_s *bfad,
 	struct bfad_buf_info *buf_info = buf_base;
 
 	if (buf_base) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < num_sgles; buf_info++, i++) {
 			if (buf_info->virt != NULL)
 				dma_free_coherent(&bfad->pcidev->dev,
 					buf_info->size, buf_info->virt,
 					buf_info->phys);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		kfree(buf_base);
 	}
diff -u -p a/scsi/bfa/bfad_im.c b/scsi/bfa/bfad_im.c
--- a/scsi/bfa/bfad_im.c
+++ b/scsi/bfa/bfad_im.c
@@ -357,6 +357,11 @@ bfad_im_reset_bus_handler(struct scsi_cm
 	enum bfi_tskim_status task_status;
 
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_FCP_TARGET; i++) {
 		itnim = bfad_get_itnim(im_port, i);
 		if (itnim) {
@@ -381,6 +386,12 @@ bfad_im_reset_bus_handler(struct scsi_cm
 				err_cnt++;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 
diff -u -p a/scsi/bfa/bfad_debugfs.c b/scsi/bfa/bfad_debugfs.c
--- a/scsi/bfa/bfad_debugfs.c
+++ b/scsi/bfa/bfad_debugfs.c
@@ -334,10 +334,21 @@ bfad_debugfs_write_regrd(struct file *fi
 	reg_addr = rb + addr;
 	regbuf =  (u32 *)bfad->regdata;
 	spin_lock_irqsave(&bfad->bfad_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i++) {
 		*regbuf = readl(reg_addr);
 		regbuf++;
 		reg_addr += sizeof(u32);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 
@@ -523,7 +534,12 @@ bfad_debugfs_init(struct bfad_port_s *po
 
 		atomic_inc(&bfa_debugfs_port_count);
 
-		for (i = 0; i < ARRAY_SIZE(bfad_debugfs_files); i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < ARRAY_SIZE(bfad_debugfs_files); i++) {
 			file = &bfad_debugfs_files[i];
 			bfad->bfad_dentry_files[i] =
 					debugfs_create_file(file->name,
@@ -537,6 +553,12 @@ bfad_debugfs_init(struct bfad_port_s *po
 					bfad->pci_name, file->name);
 				goto err;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -550,11 +572,22 @@ bfad_debugfs_exit(struct bfad_port_s *po
 	struct bfad_s *bfad = port->bfad;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ARRAY_SIZE(bfad_debugfs_files); i++) {
 		if (bfad->bfad_dentry_files[i]) {
 			debugfs_remove(bfad->bfad_dentry_files[i]);
 			bfad->bfad_dentry_files[i] = NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/scsi/bfa/bfa_fcbuild.c b/scsi/bfa/bfa_fcbuild.c
--- a/scsi/bfa/bfa_fcbuild.c
+++ b/scsi/bfa/bfa_fcbuild.c
@@ -696,12 +696,23 @@ fc_tprlo_acc_build(struct fchs_s *fchs,
 	tprlo_acc->page_len = 0x10;
 	tprlo_acc->payload_len = cpu_to_be16((num_pages * 16) + 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (page = 0; page < num_pages; page++) {
 		tprlo_acc->tprlo_acc_params[page].opa_valid = 0;
 		tprlo_acc->tprlo_acc_params[page].rpa_valid = 0;
 		tprlo_acc->tprlo_acc_params[page].fc4type_csp = FC_TYPE_FCP;
 		tprlo_acc->tprlo_acc_params[page].orig_process_assc = 0;
 		tprlo_acc->tprlo_acc_params[page].resp_process_assc = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return be16_to_cpu(tprlo_acc->payload_len);
 }
@@ -719,12 +730,23 @@ fc_prlo_acc_build(struct fchs_s *fchs, s
 	prlo_acc->page_len = 0x10;
 	prlo_acc->payload_len = cpu_to_be16((num_pages * 16) + 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (page = 0; page < num_pages; page++) {
 		prlo_acc->prlo_acc_params[page].opa_valid = 0;
 		prlo_acc->prlo_acc_params[page].rpa_valid = 0;
 		prlo_acc->prlo_acc_params[page].fc4type_csp = FC_TYPE_FCP;
 		prlo_acc->prlo_acc_params[page].orig_process_assc = 0;
 		prlo_acc->prlo_acc_params[page].resp_process_assc = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return be16_to_cpu(prlo_acc->payload_len);
@@ -891,12 +913,23 @@ fc_prlo_build(struct fchs_s *fchs, u32 d
 	prlo->page_len = 0x10;
 	prlo->payload_len = cpu_to_be16((num_pages * 16) + 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (page = 0; page < num_pages; page++) {
 		prlo->prlo_params[page].type = FC_TYPE_FCP;
 		prlo->prlo_params[page].opa_valid = 0;
 		prlo->prlo_params[page].rpa_valid = 0;
 		prlo->prlo_params[page].orig_process_assc = 0;
 		prlo->prlo_params[page].resp_process_assc = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return be16_to_cpu(prlo->payload_len);
@@ -916,6 +949,11 @@ fc_prlo_rsp_parse(struct fchs_s *fchs, i
 
 	num_pages = ((be16_to_cpu(prlo->payload_len)) - 4) / 16;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (page = 0; page < num_pages; page++) {
 		if (prlo->prlo_acc_params[page].type != FC_TYPE_FCP)
 			return FC_PARSE_FAILURE;
@@ -931,6 +969,12 @@ fc_prlo_rsp_parse(struct fchs_s *fchs, i
 
 		if (prlo->prlo_acc_params[page].resp_process_assc != 0)
 			return FC_PARSE_FAILURE;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return FC_PARSE_OK;
 
@@ -949,6 +993,11 @@ fc_tprlo_build(struct fchs_s *fchs, u32
 	tprlo->page_len = 0x10;
 	tprlo->payload_len = cpu_to_be16((num_pages * 16) + 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (page = 0; page < num_pages; page++) {
 		tprlo->tprlo_params[page].type = FC_TYPE_FCP;
 		tprlo->tprlo_params[page].opa_valid = 0;
@@ -961,6 +1010,12 @@ fc_tprlo_build(struct fchs_s *fchs, u32
 			tprlo->tprlo_params[page].tpo_nport_valid = 1;
 			tprlo->tprlo_params[page].tpo_nport_id = (tpr_id);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return be16_to_cpu(tprlo->payload_len);
@@ -980,6 +1035,11 @@ fc_tprlo_rsp_parse(struct fchs_s *fchs,
 
 	num_pages = (be16_to_cpu(tprlo->payload_len) - 4) / 16;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (page = 0; page < num_pages; page++) {
 		if (tprlo->tprlo_acc_params[page].type != FC_TYPE_FCP)
 			return FC_PARSE_NOT_FCP;
@@ -991,6 +1051,12 @@ fc_tprlo_rsp_parse(struct fchs_s *fchs,
 			return FC_PARSE_OPA_INVAL;
 		if (tprlo->tprlo_acc_params[page].resp_process_assc != 0)
 			return FC_PARSE_RPA_INVAL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return FC_PARSE_OK;
 }
diff -u -p a/scsi/bfa/bfa_ioc.c b/scsi/bfa/bfa_ioc.c
--- a/scsi/bfa/bfa_ioc.c
+++ b/scsi/bfa/bfa_ioc.c
@@ -1457,11 +1457,22 @@ bfa_ioc_fwver_get(struct bfa_ioc_s *ioc,
 	pgoff = PSS_SMEM_PGOFF(loff);
 	writel(pgnum, ioc->ioc_regs.host_page_num_fn);
 
-	for (i = 0; i < (sizeof(struct bfi_ioc_image_hdr_s) / sizeof(u32));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < (sizeof(struct bfi_ioc_image_hdr_s) / sizeof(u32));
 	     i++) {
 		fwsig[i] =
 			bfa_mem_read(ioc->ioc_regs.smem_page_start, loff);
 		loff += sizeof(u32);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1477,6 +1488,11 @@ bfa_ioc_fwver_cmp(struct bfa_ioc_s *ioc,
 	drv_fwhdr = (struct bfi_ioc_image_hdr_s *)
 		bfa_cb_image_get_chunk(bfa_ioc_asic_gen(ioc), 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < BFI_IOC_MD5SUM_SZ; i++) {
 		if (fwhdr->md5sum[i] != drv_fwhdr->md5sum[i]) {
 			bfa_trc(ioc, i);
@@ -1484,6 +1500,12 @@ bfa_ioc_fwver_cmp(struct bfa_ioc_s *ioc,
 			bfa_trc(ioc, drv_fwhdr->md5sum[i]);
 			return BFA_FALSE;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bfa_trc(ioc, fwhdr->md5sum[0]);
@@ -1720,6 +1742,11 @@ bfa_ioc_download_fw(struct bfa_ioc_s *io
 
 	writel(pgnum, ioc->ioc_regs.host_page_num_fn);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < bfa_cb_image_get_size(bfa_ioc_asic_gen(ioc)); i++) {
 
 		if (BFA_IOC_FLASH_CHUNK_NO(i) != chunkno) {
@@ -1744,6 +1771,12 @@ bfa_ioc_download_fw(struct bfa_ioc_s *io
 			pgnum++;
 			writel(pgnum, ioc->ioc_regs.host_page_num_fn);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	writel(PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, 0),
@@ -1789,9 +1822,20 @@ bfa_ioc_mbox_attach(struct bfa_ioc_s *io
 	int	mc;
 
 	INIT_LIST_HEAD(&mod->cmd_q);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mc = 0; mc < BFI_MC_MAX; mc++) {
 		mod->mbhdlr[mc].cbfn = NULL;
 		mod->mbhdlr[mc].cbarg = ioc->bfa;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1872,6 +1916,11 @@ bfa_ioc_smem_read(struct bfa_ioc_s *ioc,
 
 	len = sz/sizeof(u32);
 	bfa_trc(ioc, len);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i++) {
 		r32 = bfa_mem_read(ioc->ioc_regs.smem_page_start, loff);
 		buf[i] = be32_to_cpu(r32);
@@ -1885,6 +1934,12 @@ bfa_ioc_smem_read(struct bfa_ioc_s *ioc,
 			pgnum++;
 			writel(pgnum, ioc->ioc_regs.host_page_num_fn);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	writel(PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, 0),
 			ioc->ioc_regs.host_page_num_fn);
@@ -1929,6 +1984,11 @@ bfa_ioc_smem_clr(struct bfa_ioc_s *ioc,
 
 	len = sz/sizeof(u32); /* len in words */
 	bfa_trc(ioc, len);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i++) {
 		bfa_mem_write(ioc->ioc_regs.smem_page_start, loff, 0);
 		loff += sizeof(u32);
@@ -1941,6 +2001,12 @@ bfa_ioc_smem_clr(struct bfa_ioc_s *ioc,
 			pgnum++;
 			writel(pgnum, ioc->ioc_regs.host_page_num_fn);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	writel(PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, 0),
 			ioc->ioc_regs.host_page_num_fn);
@@ -2077,11 +2143,22 @@ bfa_ioc_msgget(struct bfa_ioc_s *ioc, vo
 	/*
 	 * read the MBOX msg
 	 */
-	for (i = 0; i < (sizeof(union bfi_ioc_i2h_msg_u) / sizeof(u32));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < (sizeof(union bfi_ioc_i2h_msg_u) / sizeof(u32));
 	     i++) {
 		r32 = readl(ioc->ioc_regs.lpu_mbox +
 				   i * sizeof(u32));
 		msgp[i] = cpu_to_be32(r32);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/*
@@ -3054,8 +3131,18 @@ bfa_ablk_config_swap(struct bfa_ablk_cfg
 	u16	be16;
 	u32	be32;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < BFA_ABLK_MAX; i++) {
 		cfg_inst = &cfg->inst[i];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < BFA_ABLK_MAX_PFS; j++) {
 			be16 = cfg_inst->pf_cfg[j].pers;
 			cfg_inst->pf_cfg[j].pers = be16_to_cpu(be16);
@@ -3065,6 +3152,18 @@ bfa_ablk_config_swap(struct bfa_ablk_cfg
 			cfg_inst->pf_cfg[j].num_vectors = be16_to_cpu(be16);
 			be32 = cfg_inst->pf_cfg[j].bw;
 			cfg_inst->pf_cfg[j].bw = be16_to_cpu(be32);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
@@ -4163,7 +4262,12 @@ bfa_flash_intr(void *flasharg, struct bf
 			attr->npart = be32_to_cpu(f->npart);
 			bfa_trc(flash, attr->status);
 			bfa_trc(flash, attr->npart);
-			for (i = 0; i < attr->npart; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (i = 0; i < attr->npart; i++) {
 				attr->part[i].part_type =
 					be32_to_cpu(f->part[i].part_type);
 				attr->part[i].part_instance =
@@ -4176,6 +4280,12 @@ bfa_flash_intr(void *flasharg, struct bf
 					be32_to_cpu(f->part[i].part_len);
 				attr->part[i].part_status =
 					be32_to_cpu(f->part[i].part_status);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 		}
 		flash->status = status;
@@ -4556,12 +4666,23 @@ bfa_diag_memtest_done(void *cbarg)
 
 	writel(pgnum, ioc->ioc_regs.host_page_num_fn);
 
-	for (i = 0; i < (sizeof(struct bfa_diag_memtest_result) /
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < (sizeof(struct bfa_diag_memtest_result) /
 			 sizeof(u32)); i++) {
 		/* read test result from smem */
 		*((u32 *) res + i) =
 			bfa_mem_read(ioc->ioc_regs.smem_page_start, loff);
 		loff += sizeof(u32);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Reset IOC fwstates to BFI_IOC_UNINIT */
@@ -4656,6 +4777,11 @@ diag_fwping_comp(struct bfa_diag_s *diag
 			return;
 		}
 		/* Check dma pattern */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < (BFI_DIAG_DMA_BUF_SZ >> 2); i++) {
 			if (*((u32 *)diag->fwping.dbuf_kva + i) != pat) {
 				bfa_trc(diag, i);
@@ -4670,6 +4796,12 @@ diag_fwping_comp(struct bfa_diag_s *diag
 				diag->fwping.lock = 0;
 				return;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		diag->fwping.result->dmastatus = BFA_STATUS_OK;
 		diag->fwping.status = BFA_STATUS_OK;
diff -u -p a/scsi/bfa/bfad.c b/scsi/bfa/bfad.c
--- a/scsi/bfa/bfad.c
+++ b/scsi/bfa/bfad.c
@@ -1205,6 +1205,11 @@ bfad_init_msix_entry(struct bfad_s *bfad
 	int	i;
 	int	match = 0x00000001;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, bfad->nvec = 0; i < MAX_MSIX_ENTRY; i++) {
 		if (mask & match) {
 			bfad->msix_tab[bfad->nvec].msix.entry = i;
@@ -1214,6 +1219,12 @@ bfad_init_msix_entry(struct bfad_s *bfad
 		}
 
 		match <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -1223,7 +1234,12 @@ bfad_install_msix_handler(struct bfad_s
 {
 	int i, error = 0;
 
-	for (i = 0; i < bfad->nvec; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < bfad->nvec; i++) {
 		sprintf(bfad->msix_tab[i].name, "bfa-%s-%s",
 				bfad->pci_name,
 				((bfa_asic_id_cb(bfad->hal_pcidev.device_id)) ?
@@ -1246,6 +1262,12 @@ bfad_install_msix_handler(struct bfad_s
 
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1299,9 +1321,20 @@ bfad_setup_intr(struct bfad_s *bfad)
 				reg | PCI_COMMAND_INTX_DISABLE);
 
 		/* Save the vectors */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < bfad->nvec; i++) {
 			bfa_trc(bfad, msix_entries[i].vector);
 			bfad->msix_tab[i].msix.vector = msix_entries[i].vector;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		bfa_msix_init(&bfad->bfa, bfad->nvec);
diff -u -p a/scsi/bfa/bfa_core.c b/scsi/bfa/bfa_core.c
--- a/scsi/bfa/bfa_core.c
+++ b/scsi/bfa/bfa_core.c
@@ -505,7 +505,12 @@ bfa_iocfc_send_cfg(void *bfa_arg)
 	/*
 	 * dma map REQ and RSP circular queues and shadow pointers
 	 */
-	for (i = 0; i < cfg->fwcfg.num_cqs; i++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < cfg->fwcfg.num_cqs; i++) {
 		bfa_dma_be_addr_set(cfg_info->req_cq_ba[i],
 				    iocfc->req_cq_ba[i].pa);
 		bfa_dma_be_addr_set(cfg_info->req_shadow_ci[i],
@@ -519,6 +524,12 @@ bfa_iocfc_send_cfg(void *bfa_arg)
 				    iocfc->rsp_cq_shadow_pi[i].pa);
 		cfg_info->rsp_cq_elems[i] =
 			cpu_to_be16(cfg->drvcfg.num_rspq_elems);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/*
@@ -617,6 +628,11 @@ bfa_iocfc_mem_claim(struct bfa_s *bfa, s
 	per_rspq_sz = BFA_ROUNDUP((cfg->drvcfg.num_rspq_elems * BFI_LMSG_SZ),
 				BFA_DMA_ALIGN_SZ);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < cfg->fwcfg.num_cqs; i++) {
 		reqq_dma = BFA_MEM_REQQ_DMA(bfa, i);
 		iocfc->req_cq_ba[i].kva = bfa_mem_dma_virt(reqq_dma);
@@ -627,12 +643,23 @@ bfa_iocfc_mem_claim(struct bfa_s *bfa, s
 		iocfc->rsp_cq_ba[i].kva = bfa_mem_dma_virt(rspq_dma);
 		iocfc->rsp_cq_ba[i].pa = bfa_mem_dma_phys(rspq_dma);
 		memset(iocfc->rsp_cq_ba[i].kva, 0, per_rspq_sz);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	/* Claim IOCFC dma memory - for shadow CI/PI */
 	dm_kva = bfa_mem_dma_virt(iocfc_dma);
 	dm_pa  = bfa_mem_dma_phys(iocfc_dma);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < cfg->fwcfg.num_cqs; i++) {
 		iocfc->req_cq_shadow_ci[i].kva = dm_kva;
 		iocfc->req_cq_shadow_ci[i].pa = dm_pa;
@@ -643,6 +670,12 @@ bfa_iocfc_mem_claim(struct bfa_s *bfa, s
 		iocfc->rsp_cq_shadow_pi[i].pa = dm_pa;
 		dm_kva += BFA_CACHELINE_SZ;
 		dm_pa += BFA_CACHELINE_SZ;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	/* Claim IOCFC dma memory - for the config info page */
@@ -755,6 +788,11 @@ bfa_iocfc_qreg(struct bfa_s *bfa, struct
 	struct bfa_iocfc_regs_s *r = &bfa->iocfc.bfa_regs;
 	void __iomem *kva = bfa_ioc_bar0(&bfa->ioc);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < BFI_IOC_MAX_CQS; i++) {
 		bfa->iocfc.hw_qid[i] = qreg->hw_qid[i];
 		r->cpe_q_ci[i] = kva + be32_to_cpu(qreg->cpe_q_ci_off[i]);
@@ -763,6 +801,12 @@ bfa_iocfc_qreg(struct bfa_s *bfa, struct
 		r->rme_q_ci[i] = kva + be32_to_cpu(qreg->rme_q_ci_off[i]);
 		r->rme_q_pi[i] = kva + be32_to_cpu(qreg->rme_q_pi_off[i]);
 		r->rme_q_ctrl[i] = kva + be32_to_cpu(qreg->rme_qctl_off[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -832,11 +876,22 @@ bfa_iocfc_reset_queues(struct bfa_s *bfa
 {
 	int		q;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (q = 0; q < BFI_IOC_MAX_CQS; q++) {
 		bfa_reqq_ci(bfa, q) = 0;
 		bfa_reqq_pi(bfa, q) = 0;
 		bfa_rspq_ci(bfa, q) = 0;
 		bfa_rspq_pi(bfa, q) = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1119,11 +1174,22 @@ bfa_iocfc_meminfo(struct bfa_iocfc_cfg_s
 	per_rspq_sz = BFA_ROUNDUP((cfg->drvcfg.num_rspq_elems * BFI_LMSG_SZ),
 				BFA_DMA_ALIGN_SZ);
 
-	for (q = 0; q < cfg->fwcfg.num_cqs; q++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (q = 0; q < cfg->fwcfg.num_cqs; q++) {
 		bfa_mem_dma_setup(meminfo, BFA_MEM_REQQ_DMA(bfa, q),
 				per_reqq_sz);
 		bfa_mem_dma_setup(meminfo, BFA_MEM_RSPQ_DMA(bfa, q),
 				per_rspq_sz);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* IOCFC dma memory - calculate Shadow CI/PI size */
diff -u -p a/scsi/bfa/bfa_fcpim.c b/scsi/bfa/bfa_fcpim.c
--- a/scsi/bfa/bfa_fcpim.c
+++ b/scsi/bfa/bfa_fcpim.c
@@ -1151,6 +1151,11 @@ bfa_itnim_attach(struct bfa_fcpim_s *fcp
 	itnim = (struct bfa_itnim_s *) bfa_mem_kva_curp(fcp);
 	fcpim->itnim_arr = itnim;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fcpim->num_itnims; i++, itnim++) {
 		memset(itnim, 0, sizeof(struct bfa_itnim_s));
 		itnim->bfa = bfa;
@@ -1168,6 +1173,12 @@ bfa_itnim_attach(struct bfa_fcpim_s *fcp
 		for (j = 0; j < BFA_IOBUCKET_MAX; j++)
 			itnim->ioprofile.io_latency.min[j] = ~0;
 		bfa_sm_set_state(itnim, bfa_itnim_sm_uninit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bfa_mem_kva_curp(fcp) = (u8 *) itnim;
@@ -2153,10 +2164,21 @@ bfa_ioim_lm_init(struct bfa_s *bfa)
 		return;
 
 	lunm_list = bfa_get_lun_mask_list(bfa);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_LUN_MASK_CFG; i++) {
 		lunm_list[i].ua = BFA_IOIM_LM_UA_RESET;
 		lunm_list[i].lp_tag = BFA_LP_TAG_INVALID;
 		lunm_list[i].rp_tag = BFA_RPORT_TAG_INVALID;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2178,6 +2200,11 @@ bfa_ioim_lm_check(struct bfa_ioim_s *ioi
 		return BFA_IOIM_LM_PRESENT;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_LUN_MASK_CFG; i++) {
 
 		if (lun_list[i].state != BFA_IOIM_LUN_MASK_ACTIVE)
@@ -2205,6 +2232,12 @@ bfa_ioim_lm_check(struct bfa_ioim_s *ioi
 
 			return BFA_IOIM_LM_PRESENT;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if ((cdb->scsi_cdb[0] == INQUIRY) &&
@@ -2235,6 +2268,11 @@ bfa_ioim_lm_fetch_lun(struct bfa_ioim_s
 	int i, j;
 
 	bfa_trc(ioim->bfa, buf_lun_cnt);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (j = 0; j < buf_lun_cnt; j++) {
 		lun = *((struct scsi_lun *)(lun_data + j));
 		for (i = 0; i < MAX_LUN_MASK_CFG; i++) {
@@ -2248,6 +2286,12 @@ bfa_ioim_lm_fetch_lun(struct bfa_ioim_s
 				break;
 			}
 		} /* next lun in mask DB */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} /* next lun in buf */
 }
 
@@ -2314,6 +2358,11 @@ bfa_ioim_lm_update_lun_sg(struct bfa_ioi
 	sg = scsi_sglist(cmnd);
 	base_rl_data = (struct scsi_lun *)rl->lun;
 	base_count = (sg_dma_len(sg) / sizeof(struct scsi_lun)) - 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 0; i < MAX_LUN_MASK_CFG; i++) {
 		if (lun_list[i].state == BFA_IOIM_LUN_MASK_FETCHED) {
 			base_rl_data[j] = lun_list[i].lun;
@@ -2329,6 +2378,12 @@ bfa_ioim_lm_update_lun_sg(struct bfa_ioi
 					phys_to_virt(sg_dma_address(sg));
 			base_count = sg_dma_len(sg) / sizeof(struct scsi_lun);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bfa_trc(ioim->bfa, lun_fetched_cnt);
@@ -2542,6 +2597,11 @@ bfa_fcpim_lunmask_rp_update(struct bfa_s
 		return;
 
 	lun_list = bfa_get_lun_mask_list(bfa);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_LUN_MASK_CFG; i++) {
 		if (lun_list[i].state == BFA_IOIM_LUN_MASK_ACTIVE) {
 			if ((lun_list[i].lp_wwn == lp_wwn) &&
@@ -2550,6 +2610,12 @@ bfa_fcpim_lunmask_rp_update(struct bfa_s
 				lun_list[i].lp_tag = lp_tag;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2563,10 +2629,21 @@ bfa_ioim_lm_set_ua(struct bfa_s *bfa)
 	int	i;
 
 	lunm_list = bfa_get_lun_mask_list(bfa);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_LUN_MASK_CFG; i++) {
 		if (lunm_list[i].state != BFA_IOIM_LUN_MASK_ACTIVE)
 			continue;
 		lunm_list[i].ua = BFA_IOIM_LM_UA_SET;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2602,12 +2679,23 @@ bfa_fcpim_lunmask_clear(struct bfa_s *bf
 		return BFA_STATUS_FAILED;
 
 	lunm_list = bfa_get_lun_mask_list(bfa);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_LUN_MASK_CFG; i++) {
 		if (lunm_list[i].state == BFA_IOIM_LUN_MASK_ACTIVE) {
 			if (lunm_list[i].rp_tag != BFA_RPORT_TAG_INVALID)
 				bfa_rport_unset_lunmask(bfa,
 				  BFA_RPORT_FROM_TAG(bfa, lunm_list[i].rp_tag));
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	memset(lunm_list, 0, sizeof(struct bfa_lun_mask_s) * MAX_LUN_MASK_CFG);
@@ -2652,6 +2740,11 @@ bfa_fcpim_lunmask_add(struct bfa_s *bfa,
 
 	lunm_list = bfa_get_lun_mask_list(bfa);
 	/* if entry exists */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_LUN_MASK_CFG; i++) {
 		if (lunm_list[i].state != BFA_IOIM_LUN_MASK_ACTIVE)
 			free_index = i;
@@ -2660,6 +2753,12 @@ bfa_fcpim_lunmask_add(struct bfa_s *bfa,
 		    (scsilun_to_int((struct scsi_lun *)&lunm_list[i].lun) ==
 		     scsilun_to_int((struct scsi_lun *)&lun)))
 			return  BFA_STATUS_ENTRY_EXISTS;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (free_index > MAX_LUN_MASK_CFG)
@@ -2680,10 +2779,21 @@ bfa_fcpim_lunmask_add(struct bfa_s *bfa,
 	lunm_list[free_index].state = BFA_IOIM_LUN_MASK_ACTIVE;
 
 	/* set for all luns in this rp */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_LUN_MASK_CFG; i++) {
 		if ((lunm_list[i].lp_wwn == *pwwn) &&
 		    (lunm_list[i].rp_wwn == rpwwn))
 			lunm_list[i].ua = BFA_IOIM_LM_UA_SET;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return bfa_dconf_update(bfa);
@@ -2720,6 +2830,11 @@ bfa_fcpim_lunmask_delete(struct bfa_s *b
 	}
 
 	lunm_list = bfa_get_lun_mask_list(bfa);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_LUN_MASK_CFG; i++) {
 		if ((lunm_list[i].lp_wwn == *pwwn) &&
 		    (lunm_list[i].rp_wwn == rpwwn) &&
@@ -2735,13 +2850,30 @@ bfa_fcpim_lunmask_delete(struct bfa_s *b
 			}
 			return bfa_dconf_update(bfa);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* set for all luns in this rp */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < MAX_LUN_MASK_CFG; i++) {
 		if ((lunm_list[i].lp_wwn == *pwwn) &&
 		    (lunm_list[i].rp_wwn == rpwwn))
 			lunm_list[i].ua = BFA_IOIM_LM_UA_SET;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return BFA_STATUS_ENTRY_NOT_EXISTS;
@@ -3122,6 +3254,11 @@ bfa_ioim_attach(struct bfa_fcpim_s *fcpi
 	INIT_LIST_HEAD(&fcpim->ioim_resfree_q);
 	INIT_LIST_HEAD(&fcpim->ioim_comp_q);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fcpim->fcp->num_ioim_reqs;
 	     i++, ioim++, iosp++) {
 		/*
@@ -3139,6 +3276,12 @@ bfa_ioim_attach(struct bfa_fcpim_s *fcpi
 		bfa_sgpg_winit(&ioim->iosp->sgpg_wqe,
 				   bfa_ioim_sgpg_alloced, ioim);
 		bfa_sm_set_state(ioim, bfa_ioim_sm_uninit);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -3917,6 +4060,11 @@ bfa_tskim_attach(struct bfa_fcpim_s *fcp
 	tskim = (struct bfa_tskim_s *) bfa_mem_kva_curp(fcp);
 	fcpim->tskim_arr = tskim;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fcpim->num_tskim_reqs; i++, tskim++) {
 		/*
 		 * initialize TSKIM
@@ -3931,6 +4079,12 @@ bfa_tskim_attach(struct bfa_fcpim_s *fcp
 		bfa_sm_set_state(tskim, bfa_tskim_sm_uninit);
 
 		list_add_tail(&tskim->qe, &fcpim->tskim_free_q);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	bfa_mem_kva_curp(fcp) = (u8 *) tskim;
@@ -4019,9 +4173,20 @@ bfa_tskim_res_recfg(struct bfa_s *bfa, u
 	struct list_head	*qe;
 	int	i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (fcpim->num_tskim_reqs - num_tskim_fw); i++) {
 		bfa_q_deq_tail(&fcpim->tskim_free_q, &qe);
 		list_add_tail(qe, &fcpim->tskim_unused_q);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4168,9 +4333,20 @@ bfa_fcp_res_recfg(struct bfa_s *bfa, u16
 	struct list_head	*qe;
 	int	i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (mod->num_ioim_reqs - num_ioim_fw); i++) {
 		bfa_q_deq_tail(&mod->iotag_ioim_free_q, &qe);
 		list_add_tail(qe, &mod->iotag_unused_q);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4218,6 +4394,11 @@ bfa_iotag_attach(struct bfa_fcp_mod_s *f
 	INIT_LIST_HEAD(&fcp->iotag_unused_q);
 
 	num_io_req = fcp->num_ioim_reqs + fcp->num_fwtio_reqs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_io_req; i++, iotag++) {
 		memset(iotag, 0, sizeof(struct bfa_iotag_s));
 		iotag->tag = i;
@@ -4225,6 +4406,12 @@ bfa_iotag_attach(struct bfa_fcp_mod_s *f
 			list_add_tail(&iotag->qe, &fcp->iotag_ioim_free_q);
 		else
 			list_add_tail(&iotag->qe, &fcp->iotag_tio_free_q);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	bfa_mem_kva_curp(fcp) = (u8 *) iotag;
diff -u -p a/scsi/bfa/bfa_fcs.c b/scsi/bfa/bfa_fcs.c
--- a/scsi/bfa/bfa_fcs.c
+++ b/scsi/bfa/bfa_fcs.c
@@ -80,10 +80,21 @@ bfa_fcs_attach(struct bfa_fcs_s *fcs, st
 	bfa->fcs = BFA_TRUE;
 	fcbuild_init();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sizeof(fcs_modules) / sizeof(fcs_modules[0]); i++) {
 		mod = &fcs_modules[i];
 		if (mod->attach)
 			mod->attach(fcs);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -96,10 +107,21 @@ bfa_fcs_init(struct bfa_fcs_s *fcs)
 	int	i;
 	struct bfa_fcs_mod_s  *mod;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < sizeof(fcs_modules) / sizeof(fcs_modules[0]); i++) {
 		mod = &fcs_modules[i];
 		if (mod->modinit)
 			mod->modinit(fcs);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -172,6 +194,11 @@ bfa_fcs_exit(struct bfa_fcs_s *fcs)
 
 	nmods = sizeof(fcs_modules) / sizeof(fcs_modules[0]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nmods; i++) {
 
 		mod = &fcs_modules[i];
@@ -179,6 +206,12 @@ bfa_fcs_exit(struct bfa_fcs_s *fcs)
 			bfa_wc_up(&fcs->wc);
 			mod->modexit(fcs);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bfa_wc_wait(&fcs->wc);
diff -u -p a/scsi/bfa/bfa_port.c b/scsi/bfa/bfa_port.c
--- a/scsi/bfa/bfa_port.c
+++ b/scsi/bfa/bfa_port.c
@@ -31,7 +31,12 @@ bfa_port_stats_swap(struct bfa_port_s *p
 	__be32    t0, t1;
 	int	    i;
 
-	for (i = 0; i < sizeof(union bfa_port_stats_u)/sizeof(u32);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+for (i = 0; i < sizeof(union bfa_port_stats_u)/sizeof(u32);
 		i += 2) {
 		t0 = dip[i];
 		t1 = dip[i + 1];
@@ -42,6 +47,12 @@ bfa_port_stats_swap(struct bfa_port_s *p
 		dip[i] = be32_to_cpu(t1);
 		dip[i + 1] = be32_to_cpu(t0);
 #endif
+if (_cur < timeout) {
+		rdstcll(_cur);
+}
+else {
+		break;
+}
 	}
 }
 
diff -u -p a/scsi/ses.c b/scsi/ses.c
--- a/scsi/ses.c
+++ b/scsi/ses.c
@@ -117,7 +117,17 @@ static int ses_set_page2_descriptor(stru
 
 	/* Clear everything */
 	memset(desc_ptr, 0, ses_dev->page2_len - 8);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ses_dev->page1_num_types; i++, type_ptr += 4) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < type_ptr[1]; j++) {
 			desc_ptr += 4;
 			if (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&
@@ -130,6 +140,18 @@ static int ses_set_page2_descriptor(stru
 				/* clear reserved, just in case */
 				desc_ptr[0] &= 0xf0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -147,7 +169,17 @@ static unsigned char *ses_get_page2_desc
 
 	ses_recv_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ses_dev->page1_num_types; i++, type_ptr += 4) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < type_ptr[1]; j++) {
 			desc_ptr += 4;
 			if (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&
@@ -155,6 +187,18 @@ static unsigned char *ses_get_page2_desc
 				continue;
 			if (count++ == descriptor)
 				return desc_ptr;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}
 	return NULL;
@@ -343,6 +387,11 @@ static int ses_enclosure_find_by_addr(st
 	if (!edev->component[0].scratch)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < edev->components; i++) {
 		scomp = edev->component[i].scratch;
 		if (scomp->addr != efd->addr)
@@ -350,6 +399,12 @@ static int ses_enclosure_find_by_addr(st
 
 		enclosure_add_device(edev, i, efd->dev);
 		return 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -401,7 +456,17 @@ static void ses_enclosure_data_process(s
 		addl_desc_ptr = ses_dev->page10 + 8;
 	type_ptr = ses_dev->page1_types;
 	components = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < types; i++, type_ptr += 4) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < type_ptr[1]; j++) {
 			char *name = NULL;
 			struct enclosure_component *ecomp;
@@ -439,6 +504,18 @@ static void ses_enclosure_data_process(s
 			if (addl_desc_ptr)
 				addl_desc_ptr += addl_desc_ptr[1] + 2;
 
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}
 	kfree(buf);
@@ -555,18 +632,40 @@ static int ses_intf_add(struct device *c
 	/* begin at the enclosure descriptor */
 	type_ptr = buf + 8;
 	/* skip all the enclosure descriptors */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_enclosures && type_ptr < buf + len; i++) {
 		types += type_ptr[2];
 		type_ptr += type_ptr[3] + 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ses_dev->page1_types = type_ptr;
 	ses_dev->page1_num_types = types;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < types && type_ptr < buf + len; i++, type_ptr += 4) {
 		if (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||
 		    type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE)
 			components += type_ptr[1];
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	ses_dev->page1 = buf;
 	ses_dev->page1_len = len;
