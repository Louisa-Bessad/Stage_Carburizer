diff -u -p a/oprofile/buffer_sync.c b/oprofile/buffer_sync.c
--- a/oprofile/buffer_sync.c
+++ b/oprofile/buffer_sync.c
@@ -229,6 +229,11 @@ static unsigned long get_exec_dcookie(st
 	if (!mm)
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
 		if (!vma->vm_file)
 			continue;
@@ -236,6 +241,12 @@ static unsigned long get_exec_dcookie(st
 			continue;
 		cookie = fast_get_dcookie(&vma->vm_file->f_path);
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
@@ -254,6 +265,11 @@ lookup_dcookie(struct mm_struct *mm, uns
 	unsigned long cookie = NO_COOKIE;
 	struct vm_area_struct *vma;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vma = find_vma(mm, addr); vma; vma = vma->vm_next) {
 
 		if (addr < vma->vm_start || addr >= vma->vm_end)
@@ -269,6 +285,12 @@ lookup_dcookie(struct mm_struct *mm, uns
 		}
 
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!vma)
diff -u -p a/virtio/virtio_ring.c b/virtio/virtio_ring.c
--- a/virtio/virtio_ring.c
+++ b/virtio/virtio_ring.c
@@ -209,12 +209,23 @@ int virtqueue_add_buf_gfp(struct virtque
 	vq->num_free -= out + in;
 
 	head = vq->free_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
 		vq->vring.desc[i].flags = VRING_DESC_F_NEXT;
 		vq->vring.desc[i].addr = sg_phys(sg);
 		vq->vring.desc[i].len = sg->length;
 		prev = i;
 		sg++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	for (; in; i = vq->vring.desc[i].next, in--) {
 		vq->vring.desc[i].flags = VRING_DESC_F_NEXT|VRING_DESC_F_WRITE;
diff -u -p a/base/map.c b/base/map.c
--- a/base/map.c
+++ b/base/map.c
@@ -55,12 +55,23 @@ int kobj_map(struct kobj_map *domain, de
 		p->data = data;
 	}
 	mutex_lock(domain->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, p -= n; i < n; i++, p++, index++) {
 		struct probe **s = &domain->probes[index % 255];
 		while (*s && (*s)->range < range)
 			s = &(*s)->next;
 		p->next = *s;
 		*s = p;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(domain->lock);
 	return 0;
diff -u -p a/base/regmap/regcache-rbtree.c b/base/regmap/regcache-rbtree.c
--- a/base/regmap/regcache-rbtree.c
+++ b/base/regmap/regcache-rbtree.c
@@ -253,6 +253,11 @@ static int regcache_rbtree_write(struct
 					     map->cache_word_size);
 	} else {
 		/* look for an adjacent register to the one we are about to add */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (node = rb_first(&rbtree_ctx->root); node;
 		     node = rb_next(node)) {
 			rbnode_tmp = rb_entry(node, struct regcache_rbtree_node, node);
@@ -273,6 +278,12 @@ static int regcache_rbtree_write(struct
 				rbtree_ctx->cached_rbnode = rbnode_tmp;
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* we did not manage to find a place to insert it in an existing
 		 * block so create a new rbnode with a single register in its block.
@@ -309,6 +320,11 @@ static int regcache_rbtree_sync(struct r
 	int i;
 
 	rbtree_ctx = map->cache;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&rbtree_ctx->root); node; node = rb_next(node)) {
 		rbnode = rb_entry(node, struct regcache_rbtree_node, node);
 		for (i = 0; i < rbnode->blklen; i++) {
@@ -329,6 +345,12 @@ static int regcache_rbtree_sync(struct r
 			dev_dbg(map->dev, "Synced register %#x, value %#x\n",
 				regtmp, val);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/input/joystick/joydump.c b/input/joystick/joydump.c
--- a/input/joystick/joydump.c
+++ b/input/joystick/joydump.c
@@ -130,12 +130,23 @@ static int joydump_connect(struct gamepo
 	printk(" |\n");
 	dump++;
 
-	for (i = 1; i < t; i++, dump++, prev++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 1; i < t; i++, dump++, prev++) {
 		printk(KERN_INFO "joydump: | index: %3d delta: %3d us data: ",
 			i, dump->time - prev->time);
 		for (j = 7; j >= 0; j--)
 			printk("%d", (dump->data >> j) & 1);
 		printk(" |\n");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(buf);
 
diff -u -p a/input/joystick/adi.c b/input/joystick/adi.c
--- a/input/joystick/adi.c
+++ b/input/joystick/adi.c
@@ -158,6 +158,11 @@ static void adi_read_packet(struct adi_p
 	do {
 		u = v;
 		w = u ^ (v = x = gameport_read(gameport));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 2; i++, w >>= 2, x >>= 2) {
 			t[i]--;
 			if ((w & 0x30) && s[i]) {
@@ -166,6 +171,12 @@ static void adi_read_packet(struct adi_p
 					t[i] = gameport_time(gameport, ADI_MAX_STROBE);
 				} else t[i] = 0;
 			} else if (!(x & 0x30)) s[i] = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} while (t[0] > 0 || t[1] > 0);
 
diff -u -p a/input/joystick/tmdc.c b/input/joystick/tmdc.c
--- a/input/joystick/tmdc.c
+++ b/input/joystick/tmdc.c
@@ -166,6 +166,11 @@ static int tmdc_read_packet(struct gamep
 		x = w;
 		w = gameport_read(gameport) >> 4;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (k = 0, v = w, u = x; k < 2; k++, v >>= 2, u >>= 2) {
 			if (~v & u & 2) {
 				if (t[k] <= 0 || i[k] >= TMDC_MAX_LENGTH) continue;
@@ -181,6 +186,12 @@ static int tmdc_read_packet(struct gamep
 				data[k][i[k]] |= (~v & 1) << (j[k]++ - 1);	/* Data bit */
 			}
 			t[k]--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} while (t[0] > 0 || t[1] > 0);
 
diff -u -p a/uwb/allocator.c b/uwb/allocator.c
--- a/uwb/allocator.c
+++ b/uwb/allocator.c
@@ -349,11 +349,22 @@ int uwb_rsv_find_best_allocation(struct
 
 	get_column_descriptors(ai);
         
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (interval = 16; interval >= 2; interval>>=1) {
 		if (interval > ai->max_interval)
 			continue;
 		if (uwb_rsv_find_best_col_alloc(ai, interval) == UWB_RSV_ALLOC_FOUND)
 			goto alloc_found;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	/* try row reservation if no column is found */
diff -u -p a/video/matrox/matroxfb_base.c b/video/matrox/matroxfb_base.c
--- a/video/matrox/matroxfb_base.c
+++ b/video/matrox/matroxfb_base.c
@@ -1931,6 +1931,11 @@ int matroxfb_register_driver(struct matr
 	struct matrox_fb_info* minfo;
 
 	list_add(&drv->node, &matroxfb_driver_list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (minfo = matroxfb_l(matroxfb_list.next);
 	     minfo != matroxfb_l(&matroxfb_list);
 	     minfo = matroxfb_l(minfo->next_fb.next)) {
@@ -1943,6 +1948,12 @@ int matroxfb_register_driver(struct matr
 			minfo->drivers_data[minfo->drivers_count] = p;
 			minfo->drivers[minfo->drivers_count++] = drv;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1951,6 +1962,11 @@ void matroxfb_unregister_driver(struct m
 	struct matrox_fb_info* minfo;
 
 	list_del(&drv->node);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (minfo = matroxfb_l(matroxfb_list.next);
 	     minfo != matroxfb_l(&matroxfb_list);
 	     minfo = matroxfb_l(minfo->next_fb.next)) {
@@ -1965,6 +1981,12 @@ void matroxfb_unregister_driver(struct m
 			} else
 				i++;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
diff -u -p a/video/matrox/g450_pll.c b/video/matrox/g450_pll.c
--- a/video/matrox/g450_pll.c
+++ b/video/matrox/g450_pll.c
@@ -435,6 +435,11 @@ static int __g450_setclk(struct matrox_f
 		unsigned int mnp;
 		unsigned int xvco;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (mnp = g450_firstpll(minfo, pi, &xvco, fout); mnp != NO_MORE_MNP; mnp = g450_nextpll(minfo, pi, &xvco, mnp)) {
 			unsigned int idx;
 			unsigned int vco;
@@ -485,6 +490,12 @@ static int __g450_setclk(struct matrox_f
 			mnparray[idx] = mnp;
 			deltaarray[idx] = delta;
 			mnpcount++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	/* VideoPLL and PixelPLL matched: do nothing... In all other cases we should get at least one frequency */
diff -u -p a/video/omap2/vrfb.c b/video/omap2/vrfb.c
--- a/video/omap2/vrfb.c
+++ b/video/omap2/vrfb.c
@@ -104,11 +104,22 @@ void omap_vrfb_restore_context(void)
 	int i;
 	unsigned long map = ctx_map;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ffs(map); i; i = ffs(map)) {
 		/* i=1..32 */
 		i--;
 		map &= ~(1 << i);
 		restore_hw_context(i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/riva/riva_hw.c b/video/riva/riva_hw.c
--- a/video/riva/riva_hw.c
+++ b/video/riva/riva_hw.c
@@ -538,8 +538,18 @@ static char nv3_get_param(nv3_fifo_info
     done = 0;
     for (p=0; p < 2; p++)
     {
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for (g=128 ; g > 32; g= g>> 1)
         {
+            unsigned long long delta = (cpu / khz / HZ) * 2;
+            unsigned long long _start = 0;
+            unsigned long long _cur = 0;
+            unsigned long long timeout;
+            timeout = rdstcll(start) + delta;
             for (v=128; v >=32; v = v>> 1)
             {
                 ainfo->priority = p;
@@ -551,6 +561,18 @@ static char nv3_get_param(nv3_fifo_info
                         done = 0;
                 if (done)
                     goto Done;
+                    if (_cur < timeout) {
+                        rdstcll(_cur);
+                    }
+                    else {
+                        break;
+                    }
+            }
+            if (_cur < timeout) {
+                    rdstcll(_cur);
+            }
+            else {
+                    break;
             }
         }
     }
diff -u -p a/video/aty/atyfb_base.c b/video/aty/atyfb_base.c
--- a/video/aty/atyfb_base.c
+++ b/video/aty/atyfb_base.c
@@ -1475,10 +1475,21 @@ static int atyfb_set_par(struct fb_info
 	/* CRTC registers */
 	base = 0x2000;
 	printk("debug atyfb: Mach64 non-shadow register values:");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 256; i = i+4) {
 		if (i % 16 == 0)
 			printk("\ndebug atyfb: 0x%04X: ", base + i);
 		printk(" %08X", aty_ld_le32(i, par));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("\n\n");
 
diff -u -p a/video/atafb.c b/video/atafb.c
--- a/video/atafb.c
+++ b/video/atafb.c
@@ -1135,6 +1135,11 @@ static int falcon_decode_var(struct fb_v
 			int i;
 			unsigned long pcl = ULONG_MAX;
 			pclock = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (i = 1; i <= 4; i *= 2) {
 				if (f25.t * i >= var->pixclock &&
 				    f25.t * i < pcl) {
@@ -1151,6 +1156,12 @@ static int falcon_decode_var(struct fb_v
 					pcl = fext.t * i;
 					pclock = &fext;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if (!pclock)
 				return -EINVAL;
diff -u -p a/video/console/sticore.c b/video/console/sticore.c
--- a/video/console/sticore.c
+++ b/video/console/sticore.c
@@ -626,10 +626,21 @@ sti_search_font(struct sti_cooked_rom *r
 	struct sti_cooked_font *font;
 	int i = 0;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (font = rom->font_start; font; font = font->next_font, i++) {
 		if ((font->raw->width == width) &&
 		    (font->raw->height == height))
 			return i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/firmware/pcdp.c b/firmware/pcdp.c
--- a/firmware/pcdp.c
+++ b/firmware/pcdp.c
@@ -119,6 +119,11 @@ efi_setup_pcdp_console(char *cmdline)
 	}
 
 	end = (struct pcdp_device *) ((u8 *) pcdp + pcdp->length);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = (struct pcdp_device *) (pcdp->uart + pcdp->num_uarts);
 	     dev < end;
 	     dev = (struct pcdp_device *) ((u8 *) dev + dev->length)) {
@@ -128,6 +133,12 @@ efi_setup_pcdp_console(char *cmdline)
 				goto out;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
diff -u -p a/firmware/dmi_scan.c b/firmware/dmi_scan.c
--- a/firmware/dmi_scan.c
+++ b/firmware/dmi_scan.c
@@ -671,13 +671,24 @@ const struct dmi_device * dmi_find_devic
 	const struct list_head *head = from ? &from->list : &dmi_devices;
 	struct list_head *d;
 
-	for(d = head->next; d != &dmi_devices; d = d->next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for(d = head->next; d != &dmi_devices; d = d->next) {
 		const struct dmi_device *dev =
 			list_entry(d, struct dmi_device, list);
 
 		if (((type == DMI_DEV_TYPE_ANY) || (dev->type == type)) &&
 		    ((name == NULL) || (strcmp(dev->name, name) == 0)))
 			return dev;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NULL;
diff -u -p a/regulator/tps65910-regulator.c b/regulator/tps65910-regulator.c
--- a/regulator/tps65910-regulator.c
+++ b/regulator/tps65910-regulator.c
@@ -937,6 +937,11 @@ static __devinit int tps65910_probe(stru
 		goto err_free_info;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < pmic->num_regulators; i++, info++, reg_data++) {
 		/* Register the regulators */
 		pmic->info[i] = info;
@@ -976,6 +981,12 @@ static __devinit int tps65910_probe(stru
 
 		/* Save regulator for cleanup */
 		pmic->rdev[i] = rdev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
diff -u -p a/regulator/tps65023-regulator.c b/regulator/tps65023-regulator.c
--- a/regulator/tps65023-regulator.c
+++ b/regulator/tps65023-regulator.c
@@ -482,6 +482,11 @@ static int __devinit tps_65023_probe(str
 	tps->client = client;
 	tps->core_regulator = drv_data->core_regulator;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < TPS65023_NUM_REGULATOR; i++, info++, init_data++) {
 		/* Store regulator specific information */
 		tps->info[i] = info;
@@ -506,6 +511,12 @@ static int __devinit tps_65023_probe(str
 
 		/* Save regulator for cleanup */
 		tps->rdev[i] = rdev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	i2c_set_clientdata(client, tps);
diff -u -p a/regulator/tps65912-regulator.c b/regulator/tps65912-regulator.c
--- a/regulator/tps65912-regulator.c
+++ b/regulator/tps65912-regulator.c
@@ -713,6 +713,11 @@ static __devinit int tps65912_probe(stru
 	pmic->get_ctrl_reg = &tps65912_get_ctrl_register;
 	info = tps65912_regs;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < TPS65912_NUM_REGULATOR; i++, info++, reg_data++) {
 		int range = 0;
 		/* Register the regulators */
@@ -738,6 +743,12 @@ static __devinit int tps65912_probe(stru
 
 		/* Save regulator for cleanup */
 		pmic->rdev[i] = rdev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
diff -u -p a/regulator/tps6524x-regulator.c b/regulator/tps6524x-regulator.c
--- a/regulator/tps6524x-regulator.c
+++ b/regulator/tps6524x-regulator.c
@@ -639,6 +639,11 @@ static int __devinit pmic_probe(struct s
 	hw->spi = spi_dev_get(spi);
 	mutex_init(&hw->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < N_REGULATORS; i++, info++, init_data++) {
 		hw->desc[i].name	= info->name;
 		hw->desc[i].id		= i;
@@ -657,6 +662,12 @@ static int __devinit pmic_probe(struct s
 			hw->rdev[i] = NULL;
 			goto fail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/regulator/tps6507x-regulator.c b/regulator/tps6507x-regulator.c
--- a/regulator/tps6507x-regulator.c
+++ b/regulator/tps6507x-regulator.c
@@ -581,6 +581,11 @@ int tps6507x_pmic_probe(struct platform_
 	/* common for all regulators */
 	tps->mfd = tps6507x_dev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < TPS6507X_NUM_REGULATOR; i++, info++, init_data++) {
 		/* Register the regulators */
 		tps->info[i] = info;
@@ -610,6 +615,12 @@ int tps6507x_pmic_probe(struct platform_
 
 		/* Save regulator for cleanup */
 		tps->rdev[i] = rdev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tps6507x_dev->pmic = tps;
diff -u -p a/of/base.c b/of/base.c
--- a/of/base.c
+++ b/of/base.c
@@ -497,11 +497,22 @@ struct device_node *of_find_node_with_pr
 	read_lock(&devtree_lock);
 	np = from ? from->allnext : allnodes;
 	for (; np; np = np->allnext) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (pp = np->properties; pp != 0; pp = pp->next) {
 			if (of_prop_cmp(pp->name, prop_name) == 0) {
 				of_node_get(np);
 				goto out;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 out:
diff -u -p a/of/address.c b/of/address.c
--- a/of/address.c
+++ b/of/address.c
@@ -196,6 +196,11 @@ const __be32 *of_get_pci_address(struct
 	psize /= 4;
 
 	onesize = na + ns;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; psize >= onesize; psize -= onesize, prop += onesize, i++) {
 		u32 val = be32_to_cpu(prop[0]);
 		if ((val & 0xff) == ((bar_no * 4) + PCI_BASE_ADDRESS_0)) {
@@ -205,6 +210,12 @@ const __be32 *of_get_pci_address(struct
 				*flags = bus->get_flags(prop);
 			return prop;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/bluetooth/btusb.c b/bluetooth/btusb.c
--- a/bluetooth/btusb.c
+++ b/bluetooth/btusb.c
@@ -508,10 +508,21 @@ static inline void __fill_isoc_descripto
 
 	BT_DBG("len %d mtu %d", len, mtu);
 
-	for (i = 0; i < BTUSB_MAX_ISOC_FRAMES && len >= mtu;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < BTUSB_MAX_ISOC_FRAMES && len >= mtu;
 					i++, offset += mtu, len -= mtu) {
 		urb->iso_frame_desc[i].offset = offset;
 		urb->iso_frame_desc[i].length = mtu;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (len && i < BTUSB_MAX_ISOC_FRAMES) {
diff -u -p a/infiniband/hw/qib/qib_iba7322.c b/infiniband/hw/qib/qib_iba7322.c
--- a/infiniband/hw/qib/qib_iba7322.c
+++ b/infiniband/hw/qib/qib_iba7322.c
@@ -4008,6 +4008,11 @@ static void get_vl_weights(struct qib_pp
 {
 	unsigned i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i++, regno++, vl++) {
 		u32 val = qib_read_kreg_port(ppd, regno);
 
@@ -4015,6 +4020,12 @@ static void get_vl_weights(struct qib_pp
 			SYM_RMASK(LowPriority0_0, VirtualLane);
 		vl->weight = (val >> SYM_LSB(LowPriority0_0, Weight)) &
 			SYM_RMASK(LowPriority0_0, Weight);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -4023,7 +4034,12 @@ static void set_vl_weights(struct qib_pp
 {
 	unsigned i;
 
-	for (i = 0; i < 16; i++, regno++, vl++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		      for (i = 0; i < 16; i++, regno++, vl++) {
 		u64 val;
 
 		val = ((vl->vl & SYM_RMASK(LowPriority0_0, VirtualLane)) <<
@@ -4031,6 +4047,12 @@ static void set_vl_weights(struct qib_pp
 		      ((vl->weight & SYM_RMASK(LowPriority0_0, Weight)) <<
 			SYM_LSB(LowPriority0_0, Weight));
 		qib_write_kreg_port(ppd, regno, val);
+		if (_cur < timeout) {
+		      rdstcll(_cur);
+		}
+		else {
+		      break;
+		}
 	}
 	if (!(ppd->p_sendctrl & SYM_MASK(SendCtrl_0, IBVLArbiterEn))) {
 		struct qib_devdata *dd = ppd->dd;
diff -u -p a/infiniband/hw/amso1100/c2.c b/infiniband/hw/amso1100/c2.c
--- a/infiniband/hw/amso1100/c2.c
+++ b/infiniband/hw/amso1100/c2.c
@@ -123,6 +123,11 @@ static int c2_tx_ring_alloc(struct c2_ri
 	elem = tx_ring->start;
 	tx_desc = vaddr;
 	txp_desc = mmio_txp_ring;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < tx_ring->count; i++, elem++, tx_desc++, txp_desc++) {
 		tx_desc->len = 0;
 		tx_desc->status = 0;
@@ -146,6 +151,12 @@ static int c2_tx_ring_alloc(struct c2_ri
 			tx_desc->next_offset =
 			    base + (i + 1) * sizeof(*tx_desc);
 		}
+		if (_cur < timeout) {
+			    rdstcll(_cur);
+		}
+		else {
+			    break;
+		}
 	}
 
 	tx_ring->to_use = tx_ring->to_clean = tx_ring->start;
@@ -172,6 +183,11 @@ static int c2_rx_ring_alloc(struct c2_ri
 	elem = rx_ring->start;
 	rx_desc = vaddr;
 	rxp_desc = mmio_rxp_ring;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < rx_ring->count; i++, elem++, rx_desc++, rxp_desc++) {
 		rx_desc->len = 0;
 		rx_desc->status = 0;
@@ -198,6 +214,12 @@ static int c2_rx_ring_alloc(struct c2_ri
 			rx_desc->next_offset =
 			    base + (i + 1) * sizeof(*rx_desc);
 		}
+		if (_cur < timeout) {
+			    rdstcll(_cur);
+		}
+		else {
+			    break;
+		}
 	}
 
 	rx_ring->to_use = rx_ring->to_clean = rx_ring->start;
diff -u -p a/infiniband/hw/mthca/mthca_qp.c b/infiniband/hw/mthca/mthca_qp.c
--- a/infiniband/hw/mthca/mthca_qp.c
+++ b/infiniband/hw/mthca/mthca_qp.c
@@ -1827,6 +1827,11 @@ int mthca_tavor_post_receive(struct ib_q
 
 	ind = qp->rq.next_ind;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nreq = 0; wr; wr = wr->next) {
 		if (mthca_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {
 			mthca_err(dev, "RQ %06x full (%u head, %u tail,"
@@ -1886,7 +1891,13 @@ int mthca_tavor_post_receive(struct ib_q
 			qp->rq.next_ind = ind;
 			qp->rq.head += MTHCA_TAVOR_MAX_WQES_PER_RECV_DB;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 out:
 	if (likely(nreq)) {
diff -u -p a/infiniband/hw/mthca/mthca_cmd.c b/infiniband/hw/mthca/mthca_cmd.c
--- a/infiniband/hw/mthca/mthca_cmd.c
+++ b/infiniband/hw/mthca/mthca_cmd.c
@@ -670,6 +670,11 @@ static int mthca_map_cmd(struct mthca_de
 	memset(mailbox->buf, 0, MTHCA_MAILBOX_SIZE);
 	pages = mailbox->buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mthca_icm_first(icm, &iter);
 	     !mthca_icm_last(&iter);
 	     mthca_icm_next(&iter)) {
@@ -707,6 +712,12 @@ static int mthca_map_cmd(struct mthca_de
 				nent = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nent)
diff -u -p a/infiniband/core/user_mad.c b/infiniband/core/user_mad.c
--- a/infiniband/core/user_mad.c
+++ b/infiniband/core/user_mad.c
@@ -380,11 +380,22 @@ static int copy_rmpp_mad(struct ib_mad_s
 		return -EFAULT;
 
 	/* All headers are in place.  Copy data segments. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (seg = 1, left = msg->data_len, buf += msg->hdr_len; left > 0;
 	     seg++, left -= msg->seg_size, buf += msg->seg_size) {
 		if (copy_from_user(ib_get_rmpp_segment(msg, seg), buf,
 				   min(left, msg->seg_size)))
 			return -EFAULT;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	return 0;
 }
diff -u -p a/infiniband/core/multicast.c b/infiniband/core/multicast.c
--- a/infiniband/core/multicast.c
+++ b/infiniband/core/multicast.c
@@ -754,6 +754,11 @@ static void mcast_groups_event(struct mc
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&port->table); node; node = rb_next(node)) {
 		group = rb_entry(node, struct mcast_group, node);
 		spin_lock(&group->lock);
@@ -764,6 +769,12 @@ static void mcast_groups_event(struct mc
 		if (group->state != MCAST_GROUP_ERROR)
 			group->state = state;
 		spin_unlock(&group->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&port->lock, flags);
 }
diff -u -p a/scsi/bfa/bfa_svc.c b/scsi/bfa/bfa_svc.c
--- a/scsi/bfa/bfa_svc.c
+++ b/scsi/bfa/bfa_svc.c
@@ -3131,7 +3131,12 @@ bfa_fcport_fcoe_stats_swap(struct bfa_fc
 	__be32	*sip = (__be32 *) s;
 	int		i;
 
-	for (i = 0; i < ((sizeof(struct bfa_fcoe_stats_s))/sizeof(u32));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (i = 0; i < ((sizeof(struct bfa_fcoe_stats_s))/sizeof(u32));
 	     i = i + 2) {
 #ifdef __BIG_ENDIAN
 		dip[i] = be32_to_cpu(sip[i]);
@@ -3140,6 +3145,12 @@ bfa_fcport_fcoe_stats_swap(struct bfa_fc
 		dip[i] = be32_to_cpu(sip[i + 1]);
 		dip[i + 1] = be32_to_cpu(sip[i]);
 #endif
+if (_cur < timeout) {
+		rdstcll(_cur);
+}
+else {
+		break;
+}
 	}
 }
 
diff -u -p a/scsi/bfa/bfa_fcpim.c b/scsi/bfa/bfa_fcpim.c
--- a/scsi/bfa/bfa_fcpim.c
+++ b/scsi/bfa/bfa_fcpim.c
@@ -3122,6 +3122,11 @@ bfa_ioim_attach(struct bfa_fcpim_s *fcpi
 	INIT_LIST_HEAD(&fcpim->ioim_resfree_q);
 	INIT_LIST_HEAD(&fcpim->ioim_comp_q);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fcpim->fcp->num_ioim_reqs;
 	     i++, ioim++, iosp++) {
 		/*
@@ -3139,6 +3144,12 @@ bfa_ioim_attach(struct bfa_fcpim_s *fcpi
 		bfa_sgpg_winit(&ioim->iosp->sgpg_wqe,
 				   bfa_ioim_sgpg_alloced, ioim);
 		bfa_sm_set_state(ioim, bfa_ioim_sm_uninit);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/scsi/sd_dif.c b/scsi/sd_dif.c
--- a/scsi/sd_dif.c
+++ b/scsi/sd_dif.c
@@ -145,9 +145,20 @@ static void sd_dif_type1_set_tag(void *p
 	u8 *tag = tag_buf;
 	unsigned int i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 0 ; i < sectors ; i++, j += 2, sdt++) {
 		sdt->app_tag = tag[j] << 8 | tag[j+1];
 		BUG_ON(sdt->app_tag == 0xffff);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -157,9 +168,20 @@ static void sd_dif_type1_get_tag(void *p
 	u8 *tag = tag_buf;
 	unsigned int i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 0 ; i < sectors ; i++, j += 2, sdt++) {
 		tag[j] = (sdt->app_tag & 0xff00) >> 8;
 		tag[j+1] = sdt->app_tag & 0xff;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -259,10 +281,21 @@ static void sd_dif_type3_set_tag(void *p
 	u8 *tag = tag_buf;
 	unsigned int i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 0 ; i < sectors ; i++, j += 6, sdt++) {
 		sdt->app_tag = tag[j] << 8 | tag[j+1];
 		sdt->ref_tag = tag[j+2] << 24 | tag[j+3] << 16 |
 			tag[j+4] << 8 | tag[j+5];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -272,6 +305,11 @@ static void sd_dif_type3_get_tag(void *p
 	u8 *tag = tag_buf;
 	unsigned int i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 0 ; i < sectors ; i++, j += 2, sdt++) {
 		tag[j] = (sdt->app_tag & 0xff00) >> 8;
 		tag[j+1] = sdt->app_tag & 0xff;
@@ -280,6 +318,12 @@ static void sd_dif_type3_get_tag(void *p
 		tag[j+4] = (sdt->ref_tag & 0xff00) >> 8;
 		tag[j+5] = sdt->ref_tag & 0xff;
 		BUG_ON(sdt->app_tag == 0xffff || sdt->ref_tag == 0xffffffff);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/wd33c93.c b/scsi/wd33c93.c
--- a/scsi/wd33c93.c
+++ b/scsi/wd33c93.c
@@ -569,6 +569,11 @@ wd33c93_execute(struct Scsi_Host *instan
 		goto yes;
 	if (!(hostdata->input_Q))	/* input_Q empty? */
 		goto no;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = (struct scsi_cmnd *) hostdata->input_Q; prev;
 	     prev = (struct scsi_cmnd *) prev->host_scribble) {
 		if ((prev->device->id != cmd->device->id) ||
@@ -578,6 +583,12 @@ wd33c93_execute(struct Scsi_Host *instan
 				prev->SCp.phase = 1;
 			goto yes;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	goto no;
diff -u -p a/scsi/atari_NCR5380.c b/scsi/atari_NCR5380.c
--- a/scsi/atari_NCR5380.c
+++ b/scsi/atari_NCR5380.c
@@ -795,17 +795,39 @@ static int NCR5380_proc_info(struct Scsi
 				       pos, buffer, length);
 	SPRINTF("scsi%d: issue_queue\n", HOSTNO);
 	check_offset();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = (Scsi_Cmnd *)hostdata->issue_queue; ptr; ptr = NEXT(ptr)) {
 		pos = lprint_Scsi_Cmnd(ptr, pos, buffer, length);
 		check_offset();
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	SPRINTF("scsi%d: disconnected_queue\n", HOSTNO);
 	check_offset();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr;
 	     ptr = NEXT(ptr)) {
 		pos = lprint_Scsi_Cmnd(ptr, pos, buffer, length);
 		check_offset();
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	local_irq_restore(flags);
@@ -2721,6 +2743,11 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 	 * Case 2 : If the command hasn't been issued yet, we simply remove it
 	 *	    from the issue queue.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = (Scsi_Cmnd **)&(hostdata->issue_queue),
 	     tmp = (Scsi_Cmnd *)hostdata->issue_queue;
 	     tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp)) {
@@ -2738,6 +2765,12 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 			falcon_release_lock_if_possible(hostdata);
 			return SCSI_ABORT_SUCCESS;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -2782,6 +2815,11 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 	 * it from the disconnected queue.
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tmp = (Scsi_Cmnd *) hostdata->disconnected_queue; tmp;
 	     tmp = NEXT(tmp)) {
 		if (cmd == tmp) {
@@ -2796,6 +2834,11 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 			do_abort(instance);
 
 			local_irq_save(flags);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (prev = (Scsi_Cmnd **)&(hostdata->disconnected_queue),
 			     tmp = (Scsi_Cmnd *)hostdata->disconnected_queue;
 			     tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp)) {
@@ -2818,8 +2861,20 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 					falcon_release_lock_if_possible(hostdata);
 					return SCSI_ABORT_SUCCESS;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/scsi/a100u2w.c b/scsi/a100u2w.c
--- a/scsi/a100u2w.c
+++ b/scsi/a100u2w.c
@@ -329,9 +329,20 @@ static void se2_update_all(struct orc_ho
 
 	np = (u8 *) default_nvram;
 	np1 = (u8 *) nvramp;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 64; i++, np++, np1++) {
 		if (*np != *np1)
 			orc_nv_write(host, (u8) i, *np);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/scsi/initio.c b/scsi/initio.c
--- a/scsi/initio.c
+++ b/scsi/initio.c
@@ -490,9 +490,20 @@ static void initio_se2_update_all(unsign
 
 	np = (u16 *) i91udftNvRam;
 	np1 = (u16 *) i91unvramp;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 32; i++, np++, np1++) {
 		if (*np != *np1)
 			initio_se2_wr(base, i, *np);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	initio_se2_ew_ds(base);	/* Disable write   */
 }
diff -u -p a/scsi/FlashPoint.c b/scsi/FlashPoint.c
--- a/scsi/FlashPoint.c
+++ b/scsi/FlashPoint.c
@@ -1019,6 +1019,11 @@ static int FlashPoint_ProbeHostAdapter(s
 					   (unsigned short)((SYNC_RATE_TBL / 2)
 							    + id));
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 2; temp >>= 8, i++) {
 
 			temp2 >>= 1;
@@ -1043,6 +1048,12 @@ static int FlashPoint_ProbeHostAdapter(s
 			if (temp & WIDE_NEGO_BIT)
 				temp4 |= 0x8000;
 
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 
@@ -1340,7 +1351,12 @@ static unsigned long FlashPoint_Hardware
 					   (unsigned short)((SYNC_RATE_TBL / 2)
 							    + id));
 
-		for (i = 0; i < 2; temp >>= 8, i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < 2; temp >>= 8, i++) {
 
 			if (pCardInfo->si_per_targ_init_sync & sync_bit_map) {
 
@@ -1377,6 +1393,12 @@ static unsigned long FlashPoint_Hardware
 
 			sync_bit_map <<= 1;
 
+			if (_cur < timeout) {
+				    rdstcll(_cur);
+			}
+			else {
+				    break;
+			}
 		}
 	}
 
@@ -5973,6 +5995,11 @@ static unsigned char FPT_scsendi(unsigne
 
 	for (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (bit_cnt = 0x80; bit_cnt != 0; bit_cnt >>= 1) {
 
 			if (defer)
@@ -5998,6 +6025,12 @@ static unsigned char FPT_scsendi(unsigne
 			if ((defer) && (!(ret_data & 0x1F)))
 				return 0x01;	/*End of isolation stage, we lost. */
 
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}		/*bit loop */
 
 	}			/*byte loop */
@@ -6132,9 +6165,20 @@ static unsigned char FPT_scvalq(unsigned
 {
 	unsigned char count;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 1; count < 0x08; count <<= 1) {
 		if (!(p_quintet & count))
 			p_quintet -= 0x80;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (p_quintet & 0x18)
@@ -7366,7 +7410,12 @@ static void FPT_utilEEWrite(unsigned lon
 
 	ee_value |= (SEE_MS + SEE_CS);
 
-	for (i = 0x8000; i != 0; i >>= 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0x8000; i != 0; i >>= 1) {
 
 		if (i & ee_data)
 			ee_value |= SEE_DO;
@@ -7381,6 +7430,12 @@ static void FPT_utilEEWrite(unsigned lon
 		ee_value &= ~SEE_CLK;
 		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
 		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ee_value &= (EXT_ARB_ACK | SCSI_TERM_ENA_H);
 	WR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));
@@ -7497,7 +7552,12 @@ static void FPT_utilEESendCmdAddr(unsign
 	ee_value |= SEE_CS;	/* Set CS to EEPROM */
 	WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
 
-	for (i = 0x04; i != 0; i >>= 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0x04; i != 0; i >>= 1) {
 
 		if (i & ee_cmd)
 			ee_value |= SEE_DO;
@@ -7512,6 +7572,12 @@ static void FPT_utilEESendCmdAddr(unsign
 		ee_value &= ~SEE_CLK;
 		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
 		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (narrow_flg)
diff -u -p a/scsi/ncr53c8xx.c b/scsi/ncr53c8xx.c
--- a/scsi/ncr53c8xx.c
+++ b/scsi/ncr53c8xx.c
@@ -5509,7 +5509,12 @@ static void ncr_set_sync_wide_status (st
 	/*
 	**	patch ALL ccbs of this target.
 	*/
-	for (cp = np->ccb; cp; cp = cp->link_ccb) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+for (cp = np->ccb; cp; cp = cp->link_ccb) {
 		if (!cp->cmd) continue;
 		if (scmd_id(cp->cmd) != target) continue;
 #if 0
@@ -5518,6 +5523,12 @@ static void ncr_set_sync_wide_status (st
 #endif
 		cp->phys.select.sel_scntl3 = tp->wval;
 		cp->phys.select.sel_sxfer  = tp->sval;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/scsi/bnx2fc/bnx2fc_fcoe.c b/scsi/bnx2fc/bnx2fc_fcoe.c
--- a/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -130,6 +130,11 @@ static void bnx2fc_clean_rx_queue(struct
 	spin_lock_bh(&bg->fcoe_rx_list.lock);
 	list = &bg->fcoe_rx_list;
 	head = list->next;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (skb = head; skb != (struct sk_buff *)list;
 	     skb = next) {
 		next = skb->next;
@@ -138,6 +143,12 @@ static void bnx2fc_clean_rx_queue(struct
 			__skb_unlink(skb, list);
 			kfree_skb(skb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_bh(&bg->fcoe_rx_list.lock);
 }
diff -u -p a/scsi/arm/msgqueue.c b/scsi/arm/msgqueue.c
--- a/scsi/arm/msgqueue.c
+++ b/scsi/arm/msgqueue.c
@@ -152,9 +152,20 @@ void msgqueue_flush(MsgQueue_t *msgq)
 {
 	struct msgqueue_entry *mq, *mqnext;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mq = msgq->qe; mq; mq = mqnext) {
 		mqnext = mq->next;
 		mqe_free(msgq, mq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	msgq->qe = NULL;
 }
diff -u -p a/scsi/sg.c b/scsi/sg.c
--- a/scsi/sg.c
+++ b/scsi/sg.c
@@ -892,6 +892,11 @@ sg_ioctl(struct file *filp, unsigned int
 		if (!access_ok(VERIFY_WRITE, ip, sizeof (int)))
 			return -EFAULT;
 		read_lock_irqsave(&sfp->rq_list_lock, iflags);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (srp = sfp->headrp; srp; srp = srp->nextrp) {
 			if ((1 == srp->done) && (!srp->sg_io_owned)) {
 				read_unlock_irqrestore(&sfp->rq_list_lock,
@@ -899,15 +904,32 @@ sg_ioctl(struct file *filp, unsigned int
 				__put_user(srp->header.pack_id, ip);
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 		__put_user(-1, ip);
 		return 0;
 	case SG_GET_NUM_WAITING:
 		read_lock_irqsave(&sfp->rq_list_lock, iflags);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (val = 0, srp = sfp->headrp; srp; srp = srp->nextrp) {
 			if ((1 == srp->done) && (!srp->sg_io_owned))
 				++val;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 		return put_user(val, ip);
@@ -1141,11 +1163,22 @@ sg_poll(struct file *filp, poll_table *
 		return POLLERR;
 	poll_wait(filp, &sfp->read_wait, wait);
 	read_lock_irqsave(&sfp->rq_list_lock, iflags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (srp = sfp->headrp; srp; srp = srp->nextrp) {
 		/* if any read waiting, flag it */
 		if ((0 == res) && (1 == srp->done) && (!srp->sg_io_owned))
 			res = POLLIN | POLLRDNORM;
 		++count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 
diff -u -p a/scsi/be2iscsi/be_main.c b/scsi/be2iscsi/be_main.c
--- a/scsi/be2iscsi/be_main.c
+++ b/scsi/be2iscsi/be_main.c
@@ -2078,6 +2078,11 @@ hwi_write_sgl(struct iscsi_wrb *pwrb, st
 	psgl++;
 	psgl++;
 	offset = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; index < num_sg; index++, sg = sg_next(sg), psgl++) {
 		sg_len = sg_dma_len(sg);
 		addr = (u64) sg_dma_address(sg);
@@ -2089,6 +2094,12 @@ hwi_write_sgl(struct iscsi_wrb *pwrb, st
 		AMAP_SET_BITS(struct amap_iscsi_sge, sge_offset, psgl, offset);
 		AMAP_SET_BITS(struct amap_iscsi_sge, last_sge, psgl, 0);
 		offset += sg_len;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	psgl--;
 	AMAP_SET_BITS(struct amap_iscsi_sge, last_sge, psgl, 1);
diff -u -p a/scsi/fcoe/fcoe.c b/scsi/fcoe/fcoe.c
--- a/scsi/fcoe/fcoe.c
+++ b/scsi/fcoe/fcoe.c
@@ -2214,6 +2214,11 @@ void fcoe_percpu_clean(struct fc_lport *
 		spin_lock_bh(&pp->fcoe_rx_list.lock);
 		list = &pp->fcoe_rx_list;
 		head = list->next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (skb = head; skb != (struct sk_buff *)list;
 		     skb = next) {
 			next = skb->next;
@@ -2222,6 +2227,12 @@ void fcoe_percpu_clean(struct fc_lport *
 				__skb_unlink(skb, list);
 				kfree_skb(skb);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (!pp->thread || !cpu_online(cpu)) {
diff -u -p a/scsi/scsi_devinfo.c b/scsi/scsi_devinfo.c
--- a/scsi/scsi_devinfo.c
+++ b/scsi/scsi_devinfo.c
@@ -501,6 +501,11 @@ static int scsi_dev_info_list_add_str(ch
 	 * For the leading and trailing '"' case, the for loop comes
 	 * through the last time with vendor[0] == '\0'.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vendor = strsep(&next, ":"); vendor && (vendor[0] != '\0')
 	     && (res == 0); vendor = strsep(&next, ":")) {
 		strflags = NULL;
@@ -515,6 +520,12 @@ static int scsi_dev_info_list_add_str(ch
 		} else
 			res = scsi_dev_info_list_add(0 /* compatible */, vendor,
 						     model, strflags, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return res;
 }
diff -u -p a/scsi/cxgbi/cxgb3i/cxgb3i.c b/scsi/cxgbi/cxgb3i/cxgb3i.c
--- a/scsi/cxgbi/cxgb3i/cxgb3i.c
+++ b/scsi/cxgbi/cxgb3i/cxgb3i.c
@@ -1089,7 +1089,12 @@ static int ddp_set_map(struct cxgbi_sock
 		"csk 0x%p, idx %u, npods %u, gl 0x%p.\n",
 		csk, idx, npods, gl);
 
-	for (i = 0; i < npods; i++, idx++, pm_addr += PPOD_SIZE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < npods; i++, idx++, pm_addr += PPOD_SIZE) {
 		struct sk_buff *skb = alloc_wr(sizeof(struct ulp_mem_io) +
 						PPOD_SIZE, 0, GFP_ATOMIC);
 
@@ -1102,6 +1107,12 @@ static int ddp_set_map(struct cxgbi_sock
 				   hdr, gl, i * PPOD_PAGES_MAX);
 		skb->priority = CPL_PRIORITY_CONTROL;
 		cxgb3_ofld_send(cdev->lldev, skb);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return 0;
 }
@@ -1118,7 +1129,12 @@ static void ddp_clear_map(struct cxgbi_h
 		"cdev 0x%p, idx %u, npods %u, tag 0x%x.\n",
 		cdev, idx, npods, tag);
 
-	for (i = 0; i < npods; i++, idx++, pm_addr += PPOD_SIZE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < npods; i++, idx++, pm_addr += PPOD_SIZE) {
 		struct sk_buff *skb = alloc_wr(sizeof(struct ulp_mem_io) +
 						PPOD_SIZE, 0, GFP_ATOMIC);
 
@@ -1130,6 +1146,12 @@ static void ddp_clear_map(struct cxgbi_h
 		ulp_mem_io_set_hdr(skb, pm_addr);
 		skb->priority = CPL_PRIORITY_CONTROL;
 		cxgb3_ofld_send(cdev->lldev, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/cxgbi/cxgb4i/cxgb4i.c b/scsi/cxgbi/cxgb4i/cxgb4i.c
--- a/scsi/cxgbi/cxgb4i/cxgb4i.c
+++ b/scsi/cxgbi/cxgb4i/cxgb4i.c
@@ -1271,11 +1271,22 @@ static int ddp_ppod_write_idata(struct c
 	idata = (struct ulptx_idata *)(req + 1);
 	ppod = (struct cxgbi_pagepod *)(idata + 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < npods; i++, ppod++, gl_pidx += PPOD_PAGES_MAX) {
 		if (!hdr && !gl)
 			cxgbi_ddp_ppod_clear(ppod);
 		else
 			cxgbi_ddp_ppod_set(ppod, hdr, gl, gl_pidx);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	cxgb4_ofld_send(cdev->ports[port_id], skb);
diff -u -p a/scsi/aic7xxx/aicasm/aicasm.c b/scsi/aic7xxx/aicasm/aicasm.c
--- a/scsi/aic7xxx/aicasm/aicasm.c
+++ b/scsi/aic7xxx/aicasm/aicasm.c
@@ -321,6 +321,11 @@ back_patch()
 {
 	struct instruction *cur_instr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_instr = STAILQ_FIRST(&seq_program);
 	     cur_instr != NULL;
 	     cur_instr = STAILQ_NEXT(cur_instr, links)) {
@@ -342,6 +347,12 @@ back_patch()
 			address += cur_instr->patch_label->info.linfo->address;
 			f3_instr->address = address;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -363,6 +374,11 @@ output_code()
 "%s */\n", versions);
 
 	fprintf(ofile, "static const uint8_t seqprog[] = {\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_instr = STAILQ_FIRST(&seq_program);
 	     cur_instr != NULL;
 	     cur_instr = STAILQ_NEXT(cur_instr, links)) {
@@ -381,6 +397,12 @@ output_code()
 			cur_instr->format.bytes[0]);
 #endif
 		instrcount++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	fprintf(ofile, "\n};\n\n");
 
@@ -394,6 +416,11 @@ output_code()
 	fprintf(ofile,
 "typedef int %spatch_func_t (%s);\n", prefix, patch_arg_list);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_node = SLIST_FIRST(&patch_functions);
 	     cur_node != NULL;
 	     cur_node = SLIST_NEXT(cur_node,links)) {
@@ -412,6 +439,12 @@ output_code()
 			cur_node->symbol->info.condinfo->func_num,
 			patch_arg_list,
 			cur_node->symbol->name);
+	if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
 	}
 
 	fprintf(ofile,
@@ -422,6 +455,11 @@ output_code()
 "				 skip_patch	:12;\n"
 "} patches[] = {\n", prefix);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_patch = STAILQ_FIRST(&patches);
 	     cur_patch != NULL;
 	     cur_patch = STAILQ_NEXT(cur_patch,links)) {
@@ -430,6 +468,12 @@ output_code()
 			prefix,
 			cur_patch->patch_func, cur_patch->begin,
 			cur_patch->skip_instr, cur_patch->skip_patch);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	fprintf(ofile, "\n};\n\n");
@@ -440,12 +484,23 @@ output_code()
 "	uint16_t	end;\n"
 "} critical_sections[] = {\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cs = TAILQ_FIRST(&cs_tailq);
 	     cs != NULL;
 	     cs = TAILQ_NEXT(cs, links)) {
 		fprintf(ofile, "%s\t{ %d, %d }",
 			cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
 			cs->begin_addr, cs->end_addr);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	fprintf(ofile, "\n};\n\n");
@@ -564,6 +619,11 @@ output_listing(char *ifilename)
 		 */
 		
 		
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cur_func = SLIST_FIRST(&patch_functions);
 		     cur_func != NULL && SLIST_NEXT(cur_func, links) != NULL;
 		     cur_func = SLIST_NEXT(cur_func, links), func_count--) {
@@ -589,13 +649,24 @@ output_listing(char *ifilename)
 			}
 			if (isatty(fileno(stdin)) == 0)
 				putchar(input);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		fprintf(stdout, "\nThanks!\n");
 	}
 
 	/* Now output the listing */
 	cur_patch = STAILQ_FIRST(&patches);
-	for (cur_instr = STAILQ_FIRST(&seq_program);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (cur_instr = STAILQ_FIRST(&seq_program);
 	     cur_instr != NULL;
 	     cur_instr = STAILQ_NEXT(cur_instr, links), instrcount++) {
 
@@ -637,6 +708,12 @@ output_listing(char *ifilename)
 			fprintf(listfile, "\n");
 		}
 		instrptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Dump the remainder of the file */
 	while(fgets(buf, sizeof(buf), ifile) != NULL)
diff -u -p a/scsi/aic7xxx/aic79xx_core.c b/scsi/aic7xxx/aic79xx_core.c
--- a/scsi/aic7xxx/aic79xx_core.c
+++ b/scsi/aic7xxx/aic79xx_core.c
@@ -8307,6 +8307,11 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 	tid_next = ahd_inw(ahd, WAITING_TID_HEAD);
 	tid_prev = SCB_LIST_NULL;
 	targets = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (scbid = tid_next; !SCBID_IS_NULL(scbid); scbid = tid_next) {
 		u_int tid_head;
 		u_int tid_tail;
@@ -8415,6 +8420,12 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 			tid_prev = tid_head;
 		if (action == SEARCH_PRINT)
 			printk(")\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* Restore saved state. */
@@ -8440,6 +8451,11 @@ ahd_search_scb_list(struct ahd_softc *ah
 	prev = SCB_LIST_NULL;
 	next = *list_head;
 	*list_tail = SCB_LIST_NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (scbid = next; !SCBID_IS_NULL(scbid); scbid = next) {
 		if (scbid >= ahd->scb_data.numscbs) {
 			printk("%s:SCB List inconsistency. "
@@ -8483,6 +8499,12 @@ ahd_search_scb_list(struct ahd_softc *ah
 		}
 		if (found > AHD_SCB_MAX)
 			panic("SCB LIST LOOP");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	if (action == SEARCH_COMPLETE
 	 || action == SEARCH_REMOVE)
diff -u -p a/scsi/aic7xxx/aic7xxx_93cx6.c b/scsi/aic7xxx/aic7xxx_93cx6.c
--- a/scsi/aic7xxx/aic7xxx_93cx6.c
+++ b/scsi/aic7xxx/aic7xxx_93cx6.c
@@ -208,11 +208,22 @@ ahc_read_seeprom(struct seeprom_descript
 	}
 #ifdef AHC_DUMP_EEPROM
 	printk("\nSerial EEPROM:\n\t");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 0; k < count; k = k + 1) {
 		if (((k % 8) == 0) && (k != 0)) {
 			printk(KERN_CONT "\n\t");
 		}
 		printk(KERN_CONT " 0x%x", buf[k]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_CONT "\n");
 #endif
diff -u -p a/scsi/sun3_NCR5380.c b/scsi/sun3_NCR5380.c
--- a/scsi/sun3_NCR5380.c
+++ b/scsi/sun3_NCR5380.c
@@ -737,18 +737,40 @@ static int NCR5380_proc_info(struct Scsi
 				pos, buffer, length);
     SPRINTF("scsi%d: issue_queue\n", HOSTNO);
     check_offset();
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (ptr = (struct scsi_cmnd *) hostdata->issue_queue; ptr; ptr = NEXT(ptr))
     {
 	pos = lprint_Scsi_Cmnd (ptr, pos, buffer, length);
 	check_offset();
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
     }
 
     SPRINTF("scsi%d: disconnected_queue\n", HOSTNO);
     check_offset();
-    for (ptr = (struct scsi_cmnd *) hostdata->disconnected_queue; ptr;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (ptr = (struct scsi_cmnd *) hostdata->disconnected_queue; ptr;
 	 ptr = NEXT(ptr)) {
 	pos = lprint_Scsi_Cmnd (ptr, pos, buffer, length);
 	check_offset();
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
     }
 
     local_irq_restore(flags);
diff -u -p a/scsi/dpt_i2o.c b/scsi/dpt_i2o.c
--- a/scsi/dpt_i2o.c
+++ b/scsi/dpt_i2o.c
@@ -209,13 +209,24 @@ static int adpt_detect(struct scsi_host_
 	}
 
 	/* In INIT state, Activate IOPs */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
 		// Activate does get status , init outbound, and get hrt
 		if (adpt_i2o_activate_hba(pHba) < 0) {
 			adpt_i2o_delete_hba(pHba);
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 
 	/* Active IOPs in HOLD state */
@@ -236,17 +247,33 @@ rebuild_sys_tab:
 	PDEBUG("HBA's in HOLD state\n");
 
 	/* If IOP don't get online, we need to rebuild the System table */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
 		if (adpt_i2o_online_hba(pHba) < 0) {
 			adpt_i2o_delete_hba(pHba);	
 			goto rebuild_sys_tab;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Active IOPs now in OPERATIONAL state */
 	PDEBUG("HBA's in OPERATIONAL state\n");
 
 	printk("dpti: If you have a lot of devices this could take a few minutes.\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
 		printk(KERN_INFO"%s: Reading the hardware resource table.\n", pHba->name);
@@ -260,6 +287,12 @@ rebuild_sys_tab:
 			continue;
 		}
 		adpt_inquiry(pHba);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	adpt_sysfs_class = class_create(THIS_MODULE, "dpt_i2o");
@@ -268,6 +301,11 @@ rebuild_sys_tab:
 		adpt_sysfs_class = NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
 		if (adpt_scsi_host_alloc(pHba, sht) < 0){
@@ -286,6 +324,12 @@ rebuild_sys_tab:
 					pHba->unit);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	// Register our control device node
@@ -971,9 +1015,20 @@ static void adpt_i2o_sys_shutdown(void)
 	/* They should have already been released by the
 	 * scsi-core
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = pNext) {
 		pNext = pHba->next;
 		adpt_i2o_delete_hba(pHba);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Remove any timedout entries from the wait queue.  */
@@ -1222,16 +1277,38 @@ static void adpt_i2o_delete_hba(adpt_hba
 			pHba->reply_pool, pHba->reply_pool_pa);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(d = pHba->devices; d ; d = next){
 		next = d->next;
 		kfree(d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	for(i = 0 ; i < pHba->top_scsi_channel ; i++){
 		for(j = 0; j < MAX_ID; j++){
 			if(pHba->channel[i].device[j] != NULL){
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for(pDev = pHba->channel[i].device[j]; pDev; pDev = pNext){
 					pNext = pDev->next_lun;
 					kfree(pDev);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 		}
@@ -1274,10 +1351,21 @@ static struct adpt_device* adpt_find_dev
 	}
 
 	/* else we need to look through all the luns */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(d=d->next_lun ; d ; d = d->next_lun){
 		if(d->scsi_lun == lun){
 			return d;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -1420,6 +1508,11 @@ static void adpt_i2o_post_wait_complete(
 	context &= 0x7fff;
 
 	spin_lock(&adpt_post_wait_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
 		if(p1->id == context) {
 			p1->status = status;
@@ -1427,13 +1520,30 @@ static void adpt_i2o_post_wait_complete(
 			wake_up_interruptible(p1->wq);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock(&adpt_post_wait_lock);
         // If this happens we lose commands that probably really completed
 	printk(KERN_DEBUG"dpti: Could Not find task %d in wait queue\n",context);
 	printk(KERN_DEBUG"      Tasks in wait queue:\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
 		printk(KERN_DEBUG"           %d\n",p1->id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return;
 }
@@ -1649,6 +1759,11 @@ static int adpt_i2o_parse_lct(adpt_hba*
 	}
 
 	// Setup adpt_device table
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(d = pHba->devices; d ; d = d->next) {
 		if(d->lct_data.class_id  == I2O_CLASS_RANDOM_BLOCK_STORAGE ||
 		   d->lct_data.class_id  == I2O_CLASS_SCSI_PERIPHERAL ||
@@ -1674,8 +1789,19 @@ static int adpt_i2o_parse_lct(adpt_hba*
 					}
 					pHba->channel[bus_no].device[scsi_id] = pDev;
 				} else {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					for( pDev = pHba->channel[bus_no].device[scsi_id];	
 							pDev->next_lun; pDev = pDev->next_lun){
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
 					}
 					pDev->next_lun = kzalloc(sizeof(struct adpt_device),GFP_KERNEL);
 					if(pDev->next_lun == NULL) {
@@ -1703,6 +1829,12 @@ static int adpt_i2o_parse_lct(adpt_hba*
 						d->lct_data.identity_tag);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -2619,12 +2751,23 @@ static s32 adpt_i2o_reparse_lct(adpt_hba
 	max /= 9;
 
 	// Mark each drive as unscanned
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (d = pHba->devices; d; d = d->next) {
 		pDev =(struct adpt_device*) d->owner;
 		if(!pDev){
 			continue;
 		}
 		pDev->state |= DPTI_DEV_UNSCANNED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_INFO "%s: LCT has %d entries.\n", pHba->name,max);
@@ -2743,6 +2886,11 @@ static s32 adpt_i2o_reparse_lct(adpt_hba
 			}
 		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pI2o_dev = pHba->devices; pI2o_dev; pI2o_dev = pI2o_dev->next) {
 		pDev =(struct adpt_device*) pI2o_dev->owner;
 		if(!pDev){
@@ -2757,6 +2905,12 @@ static s32 adpt_i2o_reparse_lct(adpt_hba
 				scsi_device_set_state(pDev->pScsi_dev, SDEV_OFFLINE);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -3219,6 +3373,11 @@ static int adpt_i2o_build_sys_table(void
 	sys_tbl->version = I2OVERSION;
 	sys_tbl->change_ind = sys_tbl_ind++;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(pHba = hba_chain; pHba; pHba = pHba->next) {
 		u64 addr;
 		// Get updated Status Block so we have the latest information
@@ -3241,6 +3400,12 @@ static int adpt_i2o_build_sys_table(void
 		sys_tbl->iops[count].inbound_high = dma_high(addr);
 
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 #ifdef DEBUG
@@ -3667,17 +3832,39 @@ static int __init adpt_init(void)
 	if (hba_chain == NULL)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
 		error = scsi_add_host(pHba->host, &pHba->pDev->dev);
 		if (error)
 			goto fail;
 		scsi_scan_host(pHba->host);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 fail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
 		scsi_remove_host(pHba->host);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return error;
 }
@@ -3688,9 +3875,20 @@ static void __exit adpt_exit(void)
 
 	for (pHba = hba_chain; pHba; pHba = pHba->next)
 		scsi_remove_host(pHba->host);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
 		adpt_release(pHba->host);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/qla2xxx/qla_sup.c b/scsi/qla2xxx/qla_sup.c
--- a/scsi/qla2xxx/qla_sup.c
+++ b/scsi/qla2xxx/qla_sup.c
@@ -1014,6 +1014,11 @@ qla2xxx_flash_npiv_conf(scsi_qla_host_t
 
 	entry = data + sizeof(struct qla_npiv_header);
 	cnt = le16_to_cpu(hdr.entries);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; cnt; cnt--, entry++, i++) {
 		uint16_t flags;
 		struct fc_vport_identifiers vid;
@@ -1051,6 +1056,12 @@ qla2xxx_flash_npiv_conf(scsi_qla_host_t
 				    (unsigned long long)vid.port_name,
 				    (unsigned long long)vid.node_name);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 done:
 	kfree(data);
@@ -2041,6 +2052,11 @@ qla2x00_read_flash_data(struct qla_hw_da
 
 	WRT_REG_WORD(&reg->nvram, 0);
 	RD_REG_WORD(&reg->nvram);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ilength = 0; ilength < length; saddr++, ilength++, tmp_buf++) {
 		if (ilength == midpoint) {
 			WRT_REG_WORD(&reg->nvram, NVR_SELECT);
@@ -2051,6 +2067,12 @@ qla2x00_read_flash_data(struct qla_hw_da
 			udelay(10);
 		*tmp_buf = data;
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/aic94xx/aic94xx_seq.c b/scsi/aic94xx/aic94xx_seq.c
--- a/scsi/aic94xx/aic94xx_seq.c
+++ b/scsi/aic94xx/aic94xx_seq.c
@@ -196,6 +196,11 @@ static int asd_verify_cseq(struct asd_ha
 	const u32 *prog = (u32 *) _prog;
 	u32 i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < size; i += 4, prog++, addr += 4) {
 		u32 val = asd_read_reg_dword(asd_ha, addr);
 
@@ -206,6 +211,12 @@ static int asd_verify_cseq(struct asd_ha
 				   i, val, le32_to_cpu(*prog));
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ASD_DPRINTK("verified %d bytes, passed\n", size);
 	return 0;
@@ -236,6 +247,11 @@ static int asd_verify_lseq(struct asd_ha
 
 		asd_write_reg_dword(asd_ha, LmBISTCTL1(lseq),
 				    page << LmRAMPAGE_LSHIFT);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; size > 0 && i < LSEQ_CODEPAGE_SIZE;
 		     i += 4, prog++, size-=4) {
 
@@ -248,6 +264,12 @@ static int asd_verify_lseq(struct asd_ha
 					   lseq, page, i);
 				return -1;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	ASD_DPRINTK("LSEQ%d verified %d bytes, passed\n", lseq,
diff -u -p a/staging/sbe-2t3e3/main.c b/staging/sbe-2t3e3/main.c
--- a/staging/sbe-2t3e3/main.c
+++ b/staging/sbe-2t3e3/main.c
@@ -77,6 +77,11 @@ int t3e3_if_start_xmit(struct sk_buff *s
 	dev_dbg(&sc->pdev->dev, "sending mbuf (current_write = %d)\n",
 		current_write);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (skb2 = skb; skb2 != NULL; skb2 = NULL) {
 		if (skb2->len) {
 			dev_dbg(&sc->pdev->dev,
@@ -106,6 +111,12 @@ int t3e3_if_start_xmit(struct sk_buff *s
 			last_write = current_write;
 			current_write = (current_write + 1) % SBE_2T3E3_TX_DESC_RING_SIZE;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sc->ether.tx_data[last_write] = skb;
diff -u -p a/staging/rtl8187se/ieee80211/ieee80211_crypt.c b/staging/rtl8187se/ieee80211/ieee80211_crypt.c
--- a/staging/rtl8187se/ieee80211/ieee80211_crypt.c
+++ b/staging/rtl8187se/ieee80211/ieee80211_crypt.c
@@ -43,6 +43,11 @@ void ieee80211_crypt_deinit_entries(stru
 	struct list_head *ptr, *n;
 	struct ieee80211_crypt_data *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
 	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct ieee80211_crypt_data, list);
@@ -55,6 +60,12 @@ void ieee80211_crypt_deinit_entries(stru
 		if (entry->ops)
 			entry->ops->deinit(entry->priv);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/vt6656/aes_ccmp.c b/staging/vt6656/aes_ccmp.c
--- a/staging/vt6656/aes_ccmp.c
+++ b/staging/vt6656/aes_ccmp.c
@@ -324,6 +324,11 @@ BOOL AESbGenCCMP(PBYTE pbyRxKey, PBYTE p
 	abyCTRPLD[0] = 0x01;
 	memcpy(&(abyCTRPLD[1]), &(abyNonce[0]), 13);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (jj = wPayloadSize; jj > 16; jj = jj-16) {
 
 		abyCTRPLD[14] = (BYTE) (wCnt >> 8);
@@ -342,6 +347,12 @@ BOOL AESbGenCCMP(PBYTE pbyRxKey, PBYTE p
 		memcpy(pbyPayload, abyPlainText, 16);
 		wCnt++;
 		pbyPayload += 16;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} /* for wPayloadSize */
 
 	/* last payload */
diff -u -p a/staging/cxt1e1/musycc.c b/staging/cxt1e1/musycc.c
--- a/staging/cxt1e1/musycc.c
+++ b/staging/cxt1e1/musycc.c
@@ -1835,6 +1835,11 @@ musycc_start_xmit (ci_t * ci, int channu
     /***********************************************/
     m2 = mem_token;
     txd_need_cnt = 0;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (len = OS_mem_token_tlen (m2); len > 0;
          m2 = (void *) OS_mem_token_next (m2))
     {
@@ -1842,6 +1847,12 @@ musycc_start_xmit (ci_t * ci, int channu
             continue;
         txd_need_cnt++;
         len -= OS_mem_token_len (m2);
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
 
     if (txd_need_cnt == 0)
@@ -1893,6 +1904,11 @@ musycc_start_xmit (ci_t * ci, int channu
     m2 = mem_token;
     md = ch->txd_usr_add;           /* get current available descriptor */
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (len = OS_mem_token_tlen (m2); len > 0; m2 = OS_mem_token_next (m2))
     {
         int         u = OS_mem_token_len (m2);
@@ -1946,6 +1962,12 @@ musycc_start_xmit (ci_t * ci, int channu
         md->status = cpu_to_le32 (u);
         --ch->txd_free;
         md = md->snext;
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
     FLUSH_MEM_WRITE ();
 
diff -u -p a/staging/usbip/userspace/src/usbipd.c b/staging/usbip/userspace/src/usbipd.c
--- a/staging/usbip/userspace/src/usbipd.c
+++ b/staging/usbip/userspace/src/usbipd.c
@@ -355,7 +355,12 @@ static int listen_all_addrinfo(struct ad
 	struct addrinfo *ai;
 	int ret, nsockfd = 0;
 
-	for (ai = ai_head; ai && nsockfd < MAXSOCKFD; ai = ai->ai_next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (ai = ai_head; ai && nsockfd < MAXSOCKFD; ai = ai->ai_next) {
 		sockfdlist[nsockfd] = socket(ai->ai_family, ai->ai_socktype,
 					     ai->ai_protocol);
 		if (sockfdlist[nsockfd] < 0)
@@ -386,6 +391,12 @@ static int listen_all_addrinfo(struct ad
 
 		log_addrinfo(ai);
 		nsockfd++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nsockfd == 0)
diff -u -p a/staging/rtl8192u/ieee80211/ieee80211_crypt.c b/staging/rtl8192u/ieee80211/ieee80211_crypt.c
--- a/staging/rtl8192u/ieee80211/ieee80211_crypt.c
+++ b/staging/rtl8192u/ieee80211/ieee80211_crypt.c
@@ -43,6 +43,11 @@ void ieee80211_crypt_deinit_entries(stru
 	struct list_head *ptr, *n;
 	struct ieee80211_crypt_data *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
 	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct ieee80211_crypt_data, list);
@@ -55,6 +60,12 @@ void ieee80211_crypt_deinit_entries(stru
 		if (entry->ops)
 			entry->ops->deinit(entry->priv);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -227,7 +238,12 @@ void __exit ieee80211_crypto_deinit(void
 	if (hcrypt == NULL)
 		return;
 
-	for (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;
 	     ptr = n, n = ptr->next) {
 		struct ieee80211_crypto_alg *alg =
 			(struct ieee80211_crypto_alg *) ptr;
@@ -235,6 +251,12 @@ void __exit ieee80211_crypto_deinit(void
 		printk(KERN_DEBUG "ieee80211_crypt: unregistered algorithm "
 		       "'%s' (deinit)\n", alg->ops->name);
 		kfree(alg);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	kfree(hcrypt);
diff -u -p a/staging/rtl8192u/r819xU_phy.c b/staging/rtl8192u/r819xU_phy.c
--- a/staging/rtl8192u/r819xU_phy.c
+++ b/staging/rtl8192u/r819xU_phy.c
@@ -508,6 +508,11 @@ void rtl8192_phy_configmac(struct net_de
 		dwArrayLen = MACPHY_ArrayLength;
 		pdwArray = rtl819XMACPHY_Array;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(i = 0; i<dwArrayLen; i=i+3){
 		if(pdwArray[i] == 0x318)
 		{
@@ -519,6 +524,12 @@ void rtl8192_phy_configmac(struct net_de
 		RT_TRACE(COMP_DBG, "The Rtl8190MACPHY_Array[0] is %x Rtl8190MACPHY_Array[1] is %x Rtl8190MACPHY_Array[2] is %x\n",
 				pdwArray[i], pdwArray[i+1], pdwArray[i+2]);
 		rtl8192_setBBreg(dev, pdwArray[i], pdwArray[i+1], pdwArray[i+2]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return;
 
@@ -958,6 +969,11 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(st
 
 	switch(eRFPath){
 		case RF90_PATH_A:
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for(i = 0;i<RadioA_ArrayLength; i=i+2){
 
 				if(rtl819XRadioA_Array[i] == 0xfe){
@@ -967,9 +983,20 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(st
 				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioA_Array[i], bMask12Bits, rtl819XRadioA_Array[i+1]);
 				mdelay(1);
 
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 			break;
 		case RF90_PATH_B:
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for(i = 0;i<RadioB_ArrayLength; i=i+2){
 
 				if(rtl819XRadioB_Array[i] == 0xfe){
@@ -979,9 +1006,20 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(st
 				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioB_Array[i], bMask12Bits, rtl819XRadioB_Array[i+1]);
 				mdelay(1);
 
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 			break;
 		case RF90_PATH_C:
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for(i = 0;i<RadioC_ArrayLength; i=i+2){
 
 				if(rtl819XRadioC_Array[i] == 0xfe){
@@ -991,9 +1029,20 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(st
 				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioC_Array[i], bMask12Bits, rtl819XRadioC_Array[i+1]);
 				mdelay(1);
 
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 			break;
 		case RF90_PATH_D:
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for(i = 0;i<RadioD_ArrayLength; i=i+2){
 
 				if(rtl819XRadioD_Array[i] == 0xfe){
@@ -1003,6 +1052,12 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(st
 				rtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioD_Array[i], bMask12Bits, rtl819XRadioD_Array[i+1]);
 				mdelay(1);
 
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 			break;
 		default:
diff -u -p a/staging/bcm/HandleControlPacket.c b/staging/bcm/HandleControlPacket.c
--- a/staging/bcm/HandleControlPacket.c
+++ b/staging/bcm/HandleControlPacket.c
@@ -203,6 +203,11 @@ INT flushAllAppQ(void)
 	PMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);
 	PPER_TARANG_DATA	pTarang = NULL;
 	struct sk_buff *PacketToDrop = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(pTarang = Adapter->pTarangs; pTarang; pTarang = pTarang->next)
 	{
 		while(pTarang->RxAppControlHead != NULL)
@@ -215,6 +220,12 @@ INT flushAllAppQ(void)
 		//dropped contrl packet statistics also should be reset.
 		memset((PVOID)&pTarang->stDroppedAppCntrlMsgs, 0, sizeof(S_MIBS_DROPPED_APP_CNTRL_MESSAGES));
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return STATUS_SUCCESS ;
 }
diff -u -p a/staging/bcm/nvm.c b/staging/bcm/nvm.c
--- a/staging/bcm/nvm.c
+++ b/staging/bcm/nvm.c
@@ -556,6 +556,11 @@ static UINT BcmGetEEPROMSize(PMINI_ADAPT
 	BeceemEEPROMBulkRead(Adapter,&uiData,0x0,4);
 	if(uiData == BECM)
 	{
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(uiIndex = 2;uiIndex <=256; uiIndex*=2)
 		{
 			BeceemEEPROMBulkRead(Adapter,&uiData,uiIndex*1024,4);
@@ -563,7 +568,13 @@ static UINT BcmGetEEPROMSize(PMINI_ADAPT
 			{
 				return uiIndex*1024;
 			}
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+        }
 	}
 	else
 	{
@@ -575,6 +586,11 @@ static UINT BcmGetEEPROMSize(PMINI_ADAPT
 		if(0 == BeceemEEPROMBulkWrite(Adapter,(PUCHAR)&uiData,0,4,TRUE))
 		{
 			uiData = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for(uiIndex = 2;uiIndex <=256; uiIndex*=2)
 			{
 				BeceemEEPROMBulkRead(Adapter,&uiData,uiIndex*1024,4);
@@ -582,6 +598,12 @@ static UINT BcmGetEEPROMSize(PMINI_ADAPT
 				{
 					return uiIndex*1024;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
diff -u -p a/staging/rtl8192e/rtllib_crypt.c b/staging/rtl8192e/rtllib_crypt.c
--- a/staging/rtl8192e/rtllib_crypt.c
+++ b/staging/rtl8192e/rtllib_crypt.c
@@ -39,6 +39,11 @@ void rtllib_crypt_deinit_entries(struct
 	struct list_head *ptr, *n;
 	struct rtllib_crypt_data *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
 	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct rtllib_crypt_data, list);
@@ -51,6 +56,12 @@ void rtllib_crypt_deinit_entries(struct
 		if (entry->ops)
 			entry->ops->deinit(entry->priv);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -227,7 +238,12 @@ void __exit rtllib_crypto_deinit(void)
 	if (hcrypt == NULL)
 		return;
 
-	for (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;
 	     ptr = n, n = ptr->next) {
 		struct rtllib_crypto_alg *alg =
 			(struct rtllib_crypto_alg *) ptr;
@@ -235,6 +251,12 @@ void __exit rtllib_crypto_deinit(void)
 		printk(KERN_DEBUG "rtllib_crypt: unregistered algorithm "
 		       "'%s' (deinit)\n", alg->ops->name);
 		kfree(alg);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	kfree(hcrypt);
diff -u -p a/staging/vt6655/aes_ccmp.c b/staging/vt6655/aes_ccmp.c
--- a/staging/vt6655/aes_ccmp.c
+++ b/staging/vt6655/aes_ccmp.c
@@ -335,6 +335,11 @@ int             ii,jj,kk;
     abyCTRPLD[0] = 0x01;
     memcpy(&(abyCTRPLD[1]), &(abyNonce[0]), 13);
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for(jj=wPayloadSize; jj>16; jj=jj-16) {
 
         abyCTRPLD[14] = (unsigned char) (wCnt >> 8);
@@ -353,6 +358,12 @@ int             ii,jj,kk;
         memcpy(pbyPayload, abyPlainText, 16);
         wCnt++;
         pbyPayload += 16;
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     } //for wPayloadSize
 
     //last payload
diff -u -p a/staging/speakup/main.c b/staging/speakup/main.c
--- a/staging/speakup/main.c
+++ b/staging/speakup/main.c
@@ -909,9 +909,20 @@ static void say_screen_from_to(struct vc
 	if (to > vc->vc_rows)
 		to = vc->vc_rows;
 	end = vc->vc_origin + (to * vc->vc_size_row);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (from = start; from < end; from = to) {
 		to = from + vc->vc_size_row;
 		say_from_to(vc, from, to, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/media/lirc/lirc_zilog.c b/staging/media/lirc/lirc_zilog.c
--- a/staging/media/lirc/lirc_zilog.c
+++ b/staging/media/lirc/lirc_zilog.c
@@ -553,6 +553,11 @@ static int get_key_data(unsigned char *b
 	unsigned int base, lim, pos, i;
 
 	/* Binary search for the codeset */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (base = 0, lim = tx_data->num_code_sets; lim; lim >>= 1) {
 		pos = base + (lim >> 1);
 		data = tx_data->code_sets[pos];
@@ -566,6 +571,12 @@ static int get_key_data(unsigned char *b
 			base = pos + 1;
 			--lim;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Not found? */
 	if (!lim)
@@ -612,6 +623,11 @@ static int get_key_data(unsigned char *b
 		goto corrupt;
 
 	/* Binary search for the key */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (base = 0, lim = keys - 1; lim; lim >>= 1) {
 		/* Seek to block */
 		unsigned char *key_data;
@@ -636,6 +652,12 @@ static int get_key_data(unsigned char *b
 			base = pos + 1;
 			--lim;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Key not found */
 	return -EPROTO;
diff -u -p a/staging/media/solo6x10/g723.c b/staging/media/solo6x10/g723.c
--- a/staging/media/solo6x10/g723.c
+++ b/staging/media/solo6x10/g723.c
@@ -87,6 +87,11 @@ void solo_g723_isr(struct solo_dev *solo
 
 	solo_reg_write(solo_dev, SOLO_IRQ_STAT, SOLO_IRQ_G723);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ss = pstr->substream; ss != NULL; ss = ss->next) {
 		if (snd_pcm_substream_chip(ss) == NULL)
 			continue;
@@ -101,6 +106,12 @@ void solo_g723_isr(struct solo_dev *solo
 			continue;
 
 		snd_pcm_period_elapsed(ss);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/media/solo6x10/v4l2-enc.c b/staging/media/solo6x10/v4l2-enc.c
--- a/staging/media/solo6x10/v4l2-enc.c
+++ b/staging/media/solo6x10/v4l2-enc.c
@@ -275,6 +275,11 @@ static void enc_write_sg(struct scatterl
 	struct scatterlist *sg;
 	u8 *src = buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sg = sglist; sg && size > 0; sg = sg_next(sg)) {
 		u8 *p = sg_virt(sg);
 		size_t len = sg_dma_len(sg);
@@ -282,6 +287,12 @@ static void enc_write_sg(struct scatterl
 
 		for (i = 0; i < len && size; i++)
 			p[i] = *(src++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -395,7 +406,12 @@ static void solo_jpeg_header(struct solo
 	size_t copied = 0;
 	size_t to_copy = sizeof(jpeg_header);
 
-	for (sg = vbuf->sglist; sg && copied < to_copy; sg = sg_next(sg)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (sg = vbuf->sglist; sg && copied < to_copy; sg = sg_next(sg)) {
 		size_t this_copy = min(sg_dma_len(sg),
 				       (unsigned int)(to_copy - copied));
 		u8 *p = sg_virt(sg);
@@ -414,6 +430,12 @@ static void solo_jpeg_header(struct solo
 			p[(SOF0_START + 8) - copied] = 0xff & solo_enc->width;
 
 		copied += this_copy;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/tidspbridge/gen/gh.c b/staging/tidspbridge/gen/gh.c
--- a/staging/tidspbridge/gen/gh.c
+++ b/staging/tidspbridge/gen/gh.c
@@ -79,11 +79,22 @@ void gh_delete(struct gh_t_hash_tab *has
 	if (hash_tab != NULL) {
 		if (hash_tab->buckets != NULL) {
 			for (i = 0; i < hash_tab->max_bucket; i++) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (elem = hash_tab->buckets[i]; elem != NULL;
 				     elem = next) {
 					next = elem->next;
 					(*hash_tab->delete) (elem->data);
 					kfree(elem);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 
diff -u -p a/staging/tidspbridge/dynload/tramp.c b/staging/tidspbridge/dynload/tramp.c
--- a/staging/tidspbridge/dynload/tramp.c
+++ b/staging/tidspbridge/dynload/tramp.c
@@ -183,6 +183,11 @@ static struct tramp_string *priv_tramp_s
 	u32 i;
 	u32 str_len = strlen(str);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_str = dlthis->tramp.string_head;
 	     (ret_val == NULL) && (cur_str != NULL); cur_str = cur_str->next) {
 		/*  If the string lengths aren't equal, don't bother
@@ -201,6 +206,12 @@ static struct tramp_string *priv_tramp_s
 
 		if (i == str_len)
 			ret_val = cur_str;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return ret_val;
@@ -1094,6 +1105,11 @@ void dload_tramp_cleanup(struct dload_st
 		return;
 
 	/*  Destroy all tramp information */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_sym = tramp->symbol_head;
 	     cur_sym != NULL; cur_sym = tramp->symbol_head) {
 		tramp->symbol_head = cur_sym->next;
@@ -1101,12 +1117,23 @@ void dload_tramp_cleanup(struct dload_st
 			tramp->symbol_tail = NULL;
 
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_sym);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (tramp->final_sym_table != NULL)
 		dlthis->mysym->dload_deallocate(dlthis->mysym,
 						tramp->final_sym_table);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_string = tramp->string_head;
 	     cur_string != NULL; cur_string = tramp->string_head) {
 		tramp->string_head = cur_string->next;
@@ -1114,30 +1141,69 @@ void dload_tramp_cleanup(struct dload_st
 			tramp->string_tail = NULL;
 
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_string);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (tramp->final_string_table != NULL)
 		dlthis->mysym->dload_deallocate(dlthis->mysym,
 						tramp->final_string_table);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_tramp_pkt = tramp->tramp_pkts;
 	     cur_tramp_pkt != NULL; cur_tramp_pkt = tramp->tramp_pkts) {
 		tramp->tramp_pkts = cur_tramp_pkt->next;
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_tramp_pkt);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_dup_pkt = tramp->dup_pkts;
 	     cur_dup_pkt != NULL; cur_dup_pkt = tramp->dup_pkts) {
 		tramp->dup_pkts = cur_dup_pkt->next;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cur_dup_relo = cur_dup_pkt->relo_chain;
 		     cur_dup_relo != NULL;
 		     cur_dup_relo = cur_dup_pkt->relo_chain) {
 			cur_dup_pkt->relo_chain = cur_dup_relo->next;
 			dlthis->mysym->dload_deallocate(dlthis->mysym,
 							cur_dup_relo);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_dup_pkt);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
diff -u -p a/staging/tidspbridge/pmgr/dspapi.c b/staging/tidspbridge/pmgr/dspapi.c
--- a/staging/tidspbridge/pmgr/dspapi.c
+++ b/staging/tidspbridge/pmgr/dspapi.c
@@ -387,6 +387,11 @@ int api_init_complete2(void)
 	/*  Walk the list of DevObjects, get each devnode, and attempting to
 	 *  autostart the board. Note that this requires COF loading, which
 	 *  requires KFILE. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = dev_get_first(); hdev_obj != NULL;
 	     hdev_obj = dev_get_next(hdev_obj)) {
 		if (dev_get_dev_node(hdev_obj, &dev_node))
@@ -401,6 +406,12 @@ int api_init_complete2(void)
 			if (drv_datap && drv_datap->base_img)
 				proc_auto_start(dev_node, hdev_obj);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return status;
diff -u -p a/staging/tidspbridge/rmgr/pwr.c b/staging/tidspbridge/rmgr/pwr.c
--- a/staging/tidspbridge/rmgr/pwr.c
+++ b/staging/tidspbridge/rmgr/pwr.c
@@ -45,6 +45,11 @@ int pwr_sleep_dsp(const u32 sleep_code,
 	u32 ioctlcode = 0;
 	u32 arg = timeout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj =
@@ -71,6 +76,12 @@ int pwr_sleep_dsp(const u32 sleep_code,
 							      ioctlcode,
 							      (void *)&arg);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 }
@@ -87,6 +98,11 @@ int pwr_wake_dsp(const u32 timeout)
 	struct dev_object *hdev_obj = NULL;
 	u32 arg = timeout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
@@ -102,6 +118,12 @@ int pwr_wake_dsp(const u32 timeout)
 							(void *)&arg);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 }
@@ -121,6 +143,11 @@ int pwr_pm_pre_scale(u16 voltage_domain,
 	arg[0] = voltage_domain;
 	arg[1] = level;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
@@ -136,6 +163,12 @@ int pwr_pm_pre_scale(u16 voltage_domain,
 						(void *)&arg);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 }
@@ -155,6 +188,11 @@ int pwr_pm_post_scale(u16 voltage_domain
 	arg[0] = voltage_domain;
 	arg[1] = level;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
@@ -170,6 +208,12 @@ int pwr_pm_post_scale(u16 voltage_domain
 						(void *)&arg);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 
diff -u -p a/staging/tidspbridge/rmgr/dspdrv.c b/staging/tidspbridge/rmgr/dspdrv.c
--- a/staging/tidspbridge/rmgr/dspdrv.c
+++ b/staging/tidspbridge/rmgr/dspdrv.c
@@ -79,12 +79,23 @@ u32 dsp_init(u32 *init_status)
 		 * unloading. Get the Driver Object iterate through and remove.
 		 * Reset the status to E_FAIL to avoid going through
 		 * api_init_complete2. */
-		for (device_node = drv_get_first_dev_extension();
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (device_node = drv_get_first_dev_extension();
 		     device_node != 0;
 		     device_node = drv_get_next_dev_extension(device_node)) {
 			(void)dev_remove_device((struct cfg_devnode *)
 						device_node);
 			(void)drv_release_resources((u32) device_node, drv_obj);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		/* Remove the Driver Object */
 		(void)drv_destroy(drv_obj);
diff -u -p a/staging/comedi/drivers/ni_6527.c b/staging/comedi/drivers/ni_6527.c
--- a/staging/comedi/drivers/ni_6527.c
+++ b/staging/comedi/drivers/ni_6527.c
@@ -469,6 +469,11 @@ static int ni6527_find_device(struct com
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -484,6 +489,12 @@ static int ni6527_find_device(struct com
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "comedi 6527: no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/mite.c b/staging/comedi/drivers/mite.c
--- a/staging/comedi/drivers/mite.c
+++ b/staging/comedi/drivers/mite.c
@@ -212,10 +212,21 @@ void mite_cleanup(void)
 {
 	struct mite_struct *mite, *next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = next) {
 		pci_dev_put(mite->pcidev);
 		next = mite->next;
 		kfree(mite);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -248,12 +259,24 @@ void mite_list_devices(void)
 	struct mite_struct *mite, *next;
 
 	printk(KERN_INFO "Available NI device IDs:");
-	if (mite_devices)
-		for (mite = mite_devices; mite; mite = next) {
-			next = mite->next;
-			printk(KERN_INFO " 0x%04x", mite_device_id(mite));
-			if (mite->used)
-				printk(KERN_INFO "(used)");
+	if (mite_devices) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (mite = mite_devices; mite; mite = next) {
+				next = mite->next;
+				printk(KERN_INFO " 0x%04x", mite_device_id(mite));
+				if (mite->used)
+					printk(KERN_INFO "(used)");
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 		}
 	printk(KERN_INFO "\n");
 }
diff -u -p a/staging/comedi/drivers/ni_mio_common.c b/staging/comedi/drivers/ni_mio_common.c
--- a/staging/comedi/drivers/ni_mio_common.c
+++ b/staging/comedi/drivers/ni_mio_common.c
@@ -4059,7 +4059,12 @@ static int ni_serial_sw_readwrite8(struc
 	/* Wait for one bit before transfer */
 	udelay((devpriv->serial_interval_ns + 999) / 1000);
 
-	for (mask = 0x80; mask; mask >>= 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (mask = 0x80; mask; mask >>= 1) {
 		/* Output current bit; note that we cannot touch s->state
 		   because it is a per-subdevice field, and serial is
 		   a separate subdevice from DIO. */
@@ -4091,6 +4096,12 @@ static int ni_serial_sw_readwrite8(struc
 /*			printk("DIO_P_I_R: 0x%x\n", devpriv->stc_readw(dev, DIO_Parallel_Input_Register)); */
 			input |= mask;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 #ifdef DEBUG_DIO
 	printk("ni_serial_sw_readwrite8: inputted 0x%x\n", input);
@@ -4758,17 +4769,39 @@ static int ni_read_eeprom(struct comedi_
 
 	bitstring = 0x0300 | ((addr & 0x100) << 3) | (addr & 0xff);
 	ni_writeb(0x04, Serial_Command);
-	for (bit = 0x8000; bit; bit >>= 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (bit = 0x8000; bit; bit >>= 1) {
 		ni_writeb(0x04 | ((bit & bitstring) ? 0x02 : 0),
 			  Serial_Command);
 		ni_writeb(0x05 | ((bit & bitstring) ? 0x02 : 0),
 			  Serial_Command);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	bitstring = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit = 0x80; bit; bit >>= 1) {
 		ni_writeb(0x04, Serial_Command);
 		ni_writeb(0x05, Serial_Command);
 		bitstring |= ((ni_readb(XXX_Status) & PROMOUT) ? bit : 0);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	ni_writeb(0x00, Serial_Command);
 
@@ -5044,11 +5077,22 @@ static void ni_write_caldac(struct comed
 		addr -= caldacs[type].n_chans;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit = 1 << (bits - 1); bit; bit >>= 1) {
 		ni_writeb(((bit & bitstring) ? 0x02 : 0), Serial_Command);
 		udelay(1);
 		ni_writeb(1 | ((bit & bitstring) ? 0x02 : 0), Serial_Command);
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ni_writeb(loadbit, Serial_Command);
 	udelay(1);
diff -u -p a/staging/comedi/drivers/amplc_dio200.c b/staging/comedi/drivers/amplc_dio200.c
--- a/staging/comedi/drivers/amplc_dio200.c
+++ b/staging/comedi/drivers/amplc_dio200.c
@@ -562,7 +562,12 @@ dio200_find_pci(struct comedi_device *de
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
-	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
 				      PCI_ANY_ID, pci_dev)) {
@@ -596,6 +601,12 @@ dio200_find_pci(struct comedi_device *de
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/cb_pcidas.c b/staging/comedi/drivers/cb_pcidas.c
--- a/staging/comedi/drivers/cb_pcidas.c
+++ b/staging/comedi/drivers/cb_pcidas.c
@@ -1793,13 +1793,24 @@ static void write_calibration_bitstream(
 	static const int write_delay = 1;
 	unsigned int bit;
 
-	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
 		if (bitstream & bit)
 			register_bits |= SERIAL_DATA_IN_BIT;
 		else
 			register_bits &= ~SERIAL_DATA_IN_BIT;
 		udelay(write_delay);
 		outw(register_bits, devpriv->control_status + CALIBRATION_REG);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/comedi/drivers/ni_pcimio.c b/staging/comedi/drivers/ni_pcimio.c
--- a/staging/comedi/drivers/ni_pcimio.c
+++ b/staging/comedi/drivers/ni_pcimio.c
@@ -1769,6 +1769,11 @@ static int pcimio_find_device(struct com
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -1786,6 +1791,12 @@ static int pcimio_find_device(struct com
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/dt3000.c b/staging/comedi/drivers/dt3000.c
--- a/staging/comedi/drivers/dt3000.c
+++ b/staging/comedi/drivers/dt3000.c
@@ -1010,6 +1010,11 @@ static struct pci_dev *dt_pci_find_devic
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (from = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from);
 	     from != NULL;
 	     from = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from)) {
@@ -1022,6 +1027,12 @@ static struct pci_dev *dt_pci_find_devic
 		printk
 		    ("unknown Data Translation PCI device found with device_id=0x%04x\n",
 		     from->device);
+		    if (_cur < timeout) {
+			rdstcll(_cur);
+		    }
+		    else {
+			break;
+		    }
 	}
 	*board = -1;
 	return from;
diff -u -p a/staging/comedi/drivers/ni_670x.c b/staging/comedi/drivers/ni_670x.c
--- a/staging/comedi/drivers/ni_670x.c
+++ b/staging/comedi/drivers/ni_670x.c
@@ -362,6 +362,11 @@ static int ni_670x_find_device(struct co
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -379,6 +384,12 @@ static int ni_670x_find_device(struct co
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_INFO "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/ni_at_ao.c b/staging/comedi/drivers/ni_at_ao.c
--- a/staging/comedi/drivers/ni_at_ao.c
+++ b/staging/comedi/drivers/ni_at_ao.c
@@ -457,11 +457,22 @@ static int atao_calib_insn_write(struct
 
 	bitstring = ((chan & 0x7) << 8) | (data[insn->n - 1] & 0xff);
 
-	for (bit = 1 << (11 - 1); bit; bit >>= 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (bit = 1 << (11 - 1); bit; bit >>= 1) {
 		outw(devpriv->cfg2 | ((bit & bitstring) ? SDATA : 0),
 		     dev->iobase + ATAO_CFG2);
 		outw(devpriv->cfg2 | SCLK | ((bit & bitstring) ? SDATA : 0),
 		     dev->iobase + ATAO_CFG2);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* strobe the appropriate caldac */
 	outw(devpriv->cfg2 | (((chan >> 3) + 1) << 14),
diff -u -p a/staging/comedi/drivers/dyna_pci10xx.c b/staging/comedi/drivers/dyna_pci10xx.c
--- a/staging/comedi/drivers/dyna_pci10xx.c
+++ b/staging/comedi/drivers/dyna_pci10xx.c
@@ -286,6 +286,11 @@ static int dyna_pci10xx_attach(struct co
 	/*
 	 * Probe the PCI bus and located the matching device
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
@@ -310,6 +315,12 @@ static int dyna_pci10xx_attach(struct co
 		}
 
 		goto found;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	printk(KERN_ERR "comedi: dyna_pci10xx: no supported device found!\n");
 	mutex_unlock(&start_stop_sem);
diff -u -p a/staging/comedi/drivers/adv_pci_dio.c b/staging/comedi/drivers/adv_pci_dio.c
--- a/staging/comedi/drivers/adv_pci_dio.c
+++ b/staging/comedi/drivers/adv_pci_dio.c
@@ -1077,10 +1077,21 @@ static int CheckAndAllocCard(struct come
 {
 	struct pci_dio_private *pr, *prev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pr = pci_priv, prev = NULL; pr != NULL; prev = pr, pr = pr->next) {
 		if (pr->pcidev == pcidev)
 			return 0; /* this card is used, look for another */
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (prev) {
diff -u -p a/staging/comedi/drivers/amplc_pci224.c b/staging/comedi/drivers/amplc_pci224.c
--- a/staging/comedi/drivers/amplc_pci224.c
+++ b/staging/comedi/drivers/amplc_pci224.c
@@ -1327,7 +1327,12 @@ pci224_find_pci(struct comedi_device *de
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
-	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID,
 				      pci_dev)) {
@@ -1359,6 +1364,12 @@ pci224_find_pci(struct comedi_device *de
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/cb_pcidas64.c b/staging/comedi/drivers/cb_pcidas64.c
--- a/staging/comedi/drivers/cb_pcidas64.c
+++ b/staging/comedi/drivers/cb_pcidas64.c
@@ -3826,7 +3826,12 @@ static void ad8402_write(struct comedi_d
 	udelay(ad8402_udelay);
 	writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
 
-	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
 		if (bitstream & bit)
 			register_bits |= SERIAL_DATA_IN_BIT;
 		else
@@ -3836,6 +3841,12 @@ static void ad8402_write(struct comedi_d
 		udelay(ad8402_udelay);
 		writew(register_bits | SERIAL_CLOCK_BIT,
 		       priv(dev)->main_iobase + CALIBRATION_REG);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	udelay(ad8402_udelay);
@@ -3895,6 +3906,11 @@ static uint16_t read_eeprom(struct comed
 	writel(priv(dev)->plx_control_bits, plx_control_addr);
 
 	/*  write read command and desired memory address */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
 		/*  set bit to be written */
 		udelay(eeprom_udelay);
@@ -3910,9 +3926,20 @@ static uint16_t read_eeprom(struct comed
 		udelay(eeprom_udelay);
 		priv(dev)->plx_control_bits &= ~CTL_EE_CLK;
 		writel(priv(dev)->plx_control_bits, plx_control_addr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*  read back value from eeprom memory location */
 	value = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit = 1 << (value_length - 1); bit; bit >>= 1) {
 		/*  clock out bit */
 		udelay(eeprom_udelay);
@@ -3924,6 +3951,12 @@ static uint16_t read_eeprom(struct comed
 		udelay(eeprom_udelay);
 		if (readl(plx_control_addr) & CTL_EE_R)
 			value |= bit;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/*  deactivate eeprom serial input */
@@ -4114,6 +4147,11 @@ static int caldac_8800_write(struct come
 		comedi_error(dev, "illegal caldac channel");
 		return -1;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
 		register_bits = 0;
 		if (bitstream & bit)
@@ -4123,6 +4161,12 @@ static int caldac_8800_write(struct come
 		register_bits |= SERIAL_CLOCK_BIT;
 		udelay(caldac_8800_udelay);
 		writew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	udelay(caldac_8800_udelay);
 	writew(SELECT_8800_BIT, priv(dev)->main_iobase + CALIBRATION_REG);
@@ -4244,13 +4288,24 @@ static void i2c_write_byte(struct comedi
 
 	DEBUG_PRINT("writing to i2c byte 0x%x\n", byte);
 
-	for (bit = 1 << (num_bits - 1); bit; bit >>= 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (bit = 1 << (num_bits - 1); bit; bit >>= 1) {
 		i2c_set_scl(dev, 0);
 		if ((byte & bit))
 			i2c_set_sda(dev, 1);
 		else
 			i2c_set_sda(dev, 0);
 		i2c_set_scl(dev, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/comedi/drivers/usbduxfast.c b/staging/comedi/drivers/usbduxfast.c
--- a/staging/comedi/drivers/usbduxfast.c
+++ b/staging/comedi/drivers/usbduxfast.c
@@ -1341,9 +1341,20 @@ static int usbduxfast_ai_insn_read(struc
 			up(&udfs->sem);
 			return -EINVAL;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = chan; (j < n) && (i < insn->n); j = j + 16) {
 			data[i] = ((uint16_t *) (udfs->transfer_buffer))[j];
 			i++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 	up(&udfs->sem);
diff -u -p a/staging/comedi/drivers/amplc_pc236.c b/staging/comedi/drivers/amplc_pc236.c
--- a/staging/comedi/drivers/amplc_pc236.c
+++ b/staging/comedi/drivers/amplc_pc236.c
@@ -267,7 +267,12 @@ pc236_find_pci(struct comedi_device *dev
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
-	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
 				      PCI_ANY_ID, pci_dev)) {
@@ -301,6 +306,12 @@ pc236_find_pci(struct comedi_device *dev
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/ni_labpc.c b/staging/comedi/drivers/ni_labpc.c
--- a/staging/comedi/drivers/ni_labpc.c
+++ b/staging/comedi/drivers/ni_labpc.c
@@ -779,6 +779,11 @@ static int labpc_find_device(struct come
 {
 	struct mite_struct *mite;
 	int i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -798,6 +803,12 @@ static int labpc_find_device(struct come
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/ni_65xx.c b/staging/comedi/drivers/ni_65xx.c
--- a/staging/comedi/drivers/ni_65xx.c
+++ b/staging/comedi/drivers/ni_65xx.c
@@ -809,6 +809,11 @@ static int ni_65xx_find_device(struct co
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -824,6 +829,12 @@ static int ni_65xx_find_device(struct co
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_WARNING "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/amplc_pc263.c b/staging/comedi/drivers/amplc_pc263.c
--- a/staging/comedi/drivers/amplc_pc263.c
+++ b/staging/comedi/drivers/amplc_pc263.c
@@ -169,7 +169,12 @@ pc263_find_pci(struct comedi_device *dev
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
-	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
 				      PCI_ANY_ID, pci_dev)) {
@@ -203,6 +208,12 @@ pc263_find_pci(struct comedi_device *dev
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/daqboard2000.c b/staging/comedi/drivers/daqboard2000.c
--- a/staging/comedi/drivers/daqboard2000.c
+++ b/staging/comedi/drivers/daqboard2000.c
@@ -746,6 +746,11 @@ static int daqboard2000_attach(struct co
 	if (result < 0) {
 		return -ENOMEM;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (card = pci_get_device(0x1616, 0x0409, NULL);
 	     card != NULL; card = pci_get_device(0x1616, 0x0409, card)) {
 		if (bus || slot) {
@@ -756,6 +761,12 @@ static int daqboard2000_attach(struct co
 			}
 		}
 		break;		/* found one */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!card) {
 		if (bus || slot)
diff -u -p a/staging/comedi/drivers/amplc_pci230.c b/staging/comedi/drivers/amplc_pci230.c
--- a/staging/comedi/drivers/amplc_pci230.c
+++ b/staging/comedi/drivers/amplc_pci230.c
@@ -1057,12 +1057,23 @@ static int get_resources(struct comedi_d
 				devpriv->res_owner[i] = owner;
 				claimed |= b;
 			} else if (devpriv->res_owner[i] != owner) {
-				for (b = 1, i = 0; claimed != 0; b <<= 1, i++) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					for (b = 1, i = 0; claimed != 0; b <<= 1, i++) {
 					if ((claimed & b) != 0) {
 						devpriv->res_owner[i]
 						    = OWNER_NONE;
 						claimed &= ~b;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				ok = 0;
 				break;
@@ -1087,6 +1098,11 @@ static void put_resources(struct comedi_
 	unsigned long irqflags;
 
 	spin_lock_irqsave(&devpriv->res_spinlock, irqflags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (b = 1, i = 0; (i < NUM_RESOURCES)
 	     && (res_mask != 0); b <<= 1, i++) {
 		if ((res_mask & b) != 0) {
@@ -1095,6 +1111,12 @@ static void put_resources(struct comedi_
 				devpriv->res_owner[i] = OWNER_NONE;
 
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	spin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);
 }
diff -u -p a/staging/comedi/drivers/ni_660x.c b/staging/comedi/drivers/ni_660x.c
--- a/staging/comedi/drivers/ni_660x.c
+++ b/staging/comedi/drivers/ni_660x.c
@@ -1251,6 +1251,11 @@ static int ni_660x_find_device(struct co
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -1267,6 +1272,12 @@ static int ni_660x_find_device(struct co
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_WARNING "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/ni_pcidio.c b/staging/comedi/drivers/ni_pcidio.c
--- a/staging/comedi/drivers/ni_pcidio.c
+++ b/staging/comedi/drivers/ni_pcidio.c
@@ -1295,6 +1295,11 @@ static int nidio_find_device(struct come
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -1311,6 +1316,12 @@ static int nidio_find_device(struct come
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_WARNING "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers.c b/staging/comedi/drivers.c
--- a/staging/comedi/drivers.c
+++ b/staging/comedi/drivers.c
@@ -115,6 +115,11 @@ int comedi_device_attach(struct comedi_d
 	if (dev->attached)
 		return -EBUSY;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
 			printk(KERN_INFO "comedi: failed to increment module count, skipping\n");
@@ -142,11 +147,22 @@ int comedi_device_attach(struct comedi_d
 			return ret;
 		}
 		goto attached;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*  recognize has failed if we get here */
 	/*  report valid board names before returning error */
-	for (driv = comedi_drivers; driv; driv = driv->next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
 			printk(KERN_INFO
 			       "comedi: failed to increment module count\n");
@@ -154,6 +170,12 @@ int comedi_device_attach(struct comedi_d
 		}
 		comedi_report_boards(driv);
 		module_put(driv->module);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EIO;
 
@@ -216,11 +238,22 @@ int comedi_driver_unregister(struct come
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = comedi_drivers; prev->next; prev = prev->next) {
 		if (prev->next == driver) {
 			prev->next = driver->next;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EINVAL;
 }
diff -u -p a/staging/comedi/proc.c b/staging/comedi/proc.c
--- a/staging/comedi/proc.c
+++ b/staging/comedi/proc.c
@@ -69,6 +69,11 @@ static int comedi_read(char *buf, char *
 	if (!devices_q)
 		l += sprintf(buf + l, "no devices\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		l += sprintf(buf + l, "%s:\n", driv->driver_name);
 		for (i = 0; i < driv->num_names; i++) {
@@ -78,6 +83,12 @@ static int comedi_read(char *buf, char *
 		}
 		if (!driv->num_names)
 			l += sprintf(buf + l, " %s\n", driv->driver_name);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return l;
diff -u -p a/spi/spi.c b/spi/spi.c
--- a/spi/spi.c
+++ b/spi/spi.c
@@ -491,6 +491,11 @@ spi_register_board_info(struct spi_board
 	if (!bi)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < n; i++, bi++, info++) {
 		struct spi_master *master;
 
@@ -500,6 +505,12 @@ spi_register_board_info(struct spi_board
 		list_for_each_entry(master, &spi_master_list, list)
 			spi_match_master_to_boardinfo(master, &bi->board_info);
 		mutex_unlock(&board_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/spi/spidev.c b/spi/spidev.c
--- a/spi/spidev.c
+++ b/spi/spidev.c
@@ -235,7 +235,12 @@ static int spidev_message(struct spidev_
 	 */
 	buf = spidev->buffer;
 	total = 0;
-	for (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;
 			n;
 			n--, k_tmp++, u_tmp++) {
 		k_tmp->len = u_tmp->len;
@@ -278,6 +283,12 @@ static int spidev_message(struct spidev_
 			u_tmp->speed_hz ? : spidev->spi->max_speed_hz);
 #endif
 		spi_message_add_tail(k_tmp, &msg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	status = spidev_sync(spidev, &msg);
diff -u -p a/tty/isicom.c b/tty/isicom.c
--- a/tty/isicom.c
+++ b/tty/isicom.c
@@ -1416,6 +1416,11 @@ static int __devinit load_firmware(struc
 
 	retval = -EIO;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (frame = (struct stframe *)fw->data;
 			frame < (struct stframe *)(fw->data + fw->size);
 			frame = (struct stframe *)((u8 *)(frame + 1) +
@@ -1460,10 +1465,21 @@ static int __devinit load_firmware(struc
 				"Status:0x%x\n", index + 1, status);
 			goto errrelfw;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 /* XXX: should we test it by reading it back and comparing with original like
  * in load firmware package? */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (frame = (struct stframe *)fw->data;
 			frame < (struct stframe *)(fw->data + fw->size);
 			frame = (struct stframe *)((u8 *)(frame + 1) +
@@ -1524,6 +1540,12 @@ static int __devinit load_firmware(struc
 				"Card Status:0x%x\n", index + 1, status);
 			goto errrelfw;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* xfer ctrl */
diff -u -p a/tty/moxa.c b/tty/moxa.c
--- a/tty/moxa.c
+++ b/tty/moxa.c
@@ -319,6 +319,11 @@ static int moxa_ioctl(struct tty_struct
 
 		for (i = 0; i < MAX_BOARDS; i++) {
 			p = moxa_boards[i].ports;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < MAX_PORTS_PER_BOARD; j++, p++, argm++) {
 				memset(&tmp, 0, sizeof(tmp));
 				spin_lock_bh(&moxa_lock);
@@ -329,6 +334,12 @@ static int moxa_ioctl(struct tty_struct
 				spin_unlock_bh(&moxa_lock);
 				if (copy_to_user(argm, &tmp, sizeof(tmp)))
 					return -EFAULT;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 			}
 		}
 		break;
@@ -348,6 +359,11 @@ static int moxa_ioctl(struct tty_struct
 
 		for (i = 0; i < MAX_BOARDS; i++) {
 			p = moxa_boards[i].ports;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = 0; j < MAX_PORTS_PER_BOARD; j++, p++, argm++) {
 				struct tty_struct *ttyp;
 				memset(&tmp, 0, sizeof(tmp));
@@ -376,6 +392,12 @@ static int moxa_ioctl(struct tty_struct
 copy:
 				if (copy_to_user(argm, &tmp, sizeof(tmp)))
 					return -EFAULT;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 		}
 		break;
diff -u -p a/tty/serial/pch_uart.c b/tty/serial/pch_uart.c
--- a/tty/serial/pch_uart.c
+++ b/tty/serial/pch_uart.c
@@ -458,11 +458,22 @@ static int pch_uart_hal_read(struct eg20
 	u8 rbr, lsr;
 
 	lsr = ioread8(priv->membase + UART_LSR);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, lsr = ioread8(priv->membase + UART_LSR);
 	     i < rx_size && lsr & UART_LSR_DR;
 	     lsr = ioread8(priv->membase + UART_LSR)) {
 		rbr = ioread8(priv->membase + PCH_UART_RBR);
 		buf[i++] = rbr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return i;
 }
diff -u -p a/tty/serial/sn_console.c b/tty/serial/sn_console.c
--- a/tty/serial/sn_console.c
+++ b/tty/serial/sn_console.c
@@ -952,6 +952,11 @@ sn_sal_console_write(struct console *co,
 		 * is that we will time out again.
 		 */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (counter = 0; counter < 150; mdelay(125), counter++) {
 			if (!spin_is_locked(&port->sc_port.lock)
 			    || stole_lock) {
@@ -973,6 +978,12 @@ sn_sal_console_write(struct console *co,
 					counter = 0;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* flush anything in the serial core xmit buffer, raw */
 		sn_transmit_chars(port, 1);
diff -u -p a/tty/serial/samsung.c b/tty/serial/samsung.c
--- a/tty/serial/samsung.c
+++ b/tty/serial/samsung.c
@@ -1476,8 +1476,19 @@ static int s3c24xx_serial_init_ports(str
 
 	platdev_ptr = s3c24xx_uart_devs;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < CONFIG_SERIAL_SAMSUNG_UARTS; i++, ptr++, platdev_ptr++) {
 		s3c24xx_serial_init_port(ptr, info[i], *platdev_ptr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/tty/rocket.c b/tty/rocket.c
--- a/tty/rocket.c
+++ b/tty/rocket.c
@@ -582,6 +582,11 @@ static void rp_do_poll(unsigned long dum
 				AiopMask = sGetAiopIntStatus(ctlp, aiop);
 
 				/*  Check if any port read bits are set */
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (ch = 0; AiopMask;  AiopMask >>= 1, ch++) {
 					if (AiopMask & 1) {
 
@@ -590,6 +595,12 @@ static void rp_do_poll(unsigned long dum
 						line = GetLineNumber(ctrl, aiop, ch);
 						rp_handle_port(rp_table[line]);
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 		}
diff -u -p a/tty/n_r3964.c b/tty/n_r3964.c
--- a/tty/n_r3964.c
+++ b/tty/n_r3964.c
@@ -536,11 +536,22 @@ static void on_receive_block(struct r396
 	add_rx_queue(pInfo, pBlock);
 
 	/* notify attached client processes: */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pClient = pInfo->firstClient; pClient; pClient = pClient->next) {
 		if (pClient->sig_flags & R3964_SIG_DATA) {
 			add_msg(pClient, R3964_MSG_DATA, length, R3964_OK,
 				pBlock);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	wake_up_interruptible(&pInfo->read_wait);
 
@@ -739,10 +750,21 @@ static struct r3964_client_info *findCli
 {
 	struct r3964_client_info *pClient;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pClient = pInfo->firstClient; pClient; pClient = pClient->next) {
 		if (pClient->pid == pid) {
 			return pClient;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -755,6 +777,11 @@ static int enable_signals(struct r3964_i
 
 	if ((arg & R3964_SIG_ALL) == 0) {
 		/* Remove client from client list */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (ppClient = &pInfo->firstClient; *ppClient;
 		     ppClient = &(*ppClient)->next) {
 			pClient = *ppClient;
@@ -776,6 +803,12 @@ static int enable_signals(struct r3964_i
 				TRACE_M("enable_signals - kfree %p", pClient);
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		return -EINVAL;
 	} else {
diff -u -p a/tty/mxser.c b/tty/mxser.c
--- a/tty/mxser.c
+++ b/tty/mxser.c
@@ -1455,6 +1455,11 @@ static int __init mxser_read_register(in
 		return id;
 	for (i = 0; i < 14; i++) {
 		k = (i & 0x3F) | 0x180;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0x100; j > 0; j >>= 1) {
 			outb(CHIP_CS, port);
 			if (k & j) {
@@ -1464,6 +1469,12 @@ static int __init mxser_read_register(in
 				outb(CHIP_CS, port);
 				outb(CHIP_CS | CHIP_SK, port);	/* A? bit of read */
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		(void)inb(port);
 		value = 0;
diff -u -p a/tty/synclink_gt.c b/tty/synclink_gt.c
--- a/tty/synclink_gt.c
+++ b/tty/synclink_gt.c
@@ -2354,6 +2354,11 @@ static void isr_gpio(struct slgt_info *i
 	struct cond_wait *w, *prev;
 
 	/* wake processes waiting for specific transitions */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (w = info->gpio_wait_q, prev = NULL ; w != NULL ; w = w->next) {
 		if (w->data & changed) {
 			w->data = state;
@@ -2364,6 +2369,12 @@ static void isr_gpio(struct slgt_info *i
 				info->gpio_wait_q = w->next;
 		} else
 			prev = w;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/crypto/n2_core.c b/crypto/n2_core.c
--- a/crypto/n2_core.c
+++ b/crypto/n2_core.c
@@ -125,8 +125,19 @@ static irqreturn_t cwq_intr(int irq, voi
 	pr_err("CPU[%d]: CWQ gethead[%lx] hv_ret[%lu]\n",
 	       smp_processor_id(), new_head, hv_ret);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (off = q->head; off != new_head; off = spu_next_offset(q, off)) {
 		/* XXX ... XXX */
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	hv_ret = sun4v_ncs_sethead_marker(q->qhandle, new_head);
diff -u -p a/isdn/gigaset/capi.c b/isdn/gigaset/capi.c
--- a/isdn/gigaset/capi.c
+++ b/isdn/gigaset/capi.c
@@ -1698,12 +1698,23 @@ static void do_connect_resp(struct gigas
 			spin_unlock_irqrestore(&bcs->aplock, flags);
 			return;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (oap = bcs->ap; oap != NULL; oap = oap->bcnext) {
 			if (oap->bcnext == ap) {
 				oap->bcnext = oap->bcnext->bcnext;
 				spin_unlock_irqrestore(&bcs->aplock, flags);
 				return;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		spin_unlock_irqrestore(&bcs->aplock, flags);
 		dev_err(cs->dev, "%s: application %u not found\n",
diff -u -p a/isdn/hisax/ipacx.c b/isdn/hisax/ipacx.c
--- a/isdn/hisax/ipacx.c
+++ b/isdn/hisax/ipacx.c
@@ -210,8 +210,19 @@ dbusy_timer_handler(struct IsdnCardState
       debugl1(cs, "D-Channel Busy RBCHD %02x STARD %02x", rbchd, stard);
 		if (!(stard &0x40)) { // D-Channel Busy
 			set_bit(FLG_L1_DBUSY, &cs->HW_Flags);
-      for (st = cs->stlist; st; st = st->next) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (st = cs->stlist; st; st = st->next) {
 				st->l1.l1l2(st, PH_PAUSE | INDICATION, NULL); // flow control on
+				if (_cur < timeout) {
+							rdstcll(_cur);
+				}
+				else {
+							break;
+				}
 			}
 		} else {
 			// seems we lost an interrupt; reset transceiver */
diff -u -p a/isdn/capi/capidrv.c b/isdn/capi/capidrv.c
--- a/isdn/capi/capidrv.c
+++ b/isdn/capi/capidrv.c
@@ -380,6 +380,11 @@ static void free_plci(capidrv_contr * ca
 {
 	capidrv_plci **pp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pp = &card->plci_list; *pp; pp = &(*pp)->next) {
 		if (*pp == plcip) {
 			*pp = (*pp)->next;
@@ -389,6 +394,12 @@ static void free_plci(capidrv_contr * ca
 			kfree(plcip);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "capidrv-%d: free_plci %p (0x%x) not found, Huh?\n",
 	       card->contrnr, plcip, plcip->plci);
@@ -488,6 +499,11 @@ static int capidrv_del_ack(struct capidr
 	struct ncci_datahandle_queue **pp, *p;
 	int len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pp = &nccip->ackqueue; *pp; pp = &(*pp)->next) {
  		if ((*pp)->datahandle == datahandle) {
 			p = *pp;
@@ -496,6 +512,12 @@ static int capidrv_del_ack(struct capidr
 		        kfree(p);
 			return len;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -1;
 }
diff -u -p a/isdn/capi/capilib.c b/isdn/capi/capilib.c
--- a/isdn/capi/capilib.c
+++ b/isdn/capi/capilib.c
@@ -62,6 +62,11 @@ static inline int mq_enqueue(struct capi
 static inline int mq_dequeue(struct capilib_ncci * np, u16 msgid)
 {
 	struct capilib_msgidqueue **pp;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pp = &np->msgidqueue; *pp; pp = &(*pp)->next) {
 		if ((*pp)->msgid == msgid) {
 			struct capilib_msgidqueue *mq = *pp;
@@ -73,6 +78,12 @@ static inline int mq_dequeue(struct capi
 			np->nmsg--;
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/isdn/i4l/isdn_net.c b/isdn/i4l/isdn_net.c
--- a/isdn/i4l/isdn_net.c
+++ b/isdn/i4l/isdn_net.c
@@ -2983,6 +2983,11 @@ isdn_net_getphones(isdn_net_ioctl_phone
 	if (!p)
 		return -ENODEV;
 	inout &= 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = p->local->phone[inout]; n; n = n->next) {
 		if (more) {
 			put_user(' ', phones++);
@@ -2994,6 +2999,12 @@ isdn_net_getphones(isdn_net_ioctl_phone
 		phones += strlen(n->num);
 		count += strlen(n->num);
 		more = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	put_user(0, phones);
 	count++;
diff -u -p a/isdn/i4l/isdn_ttyfax.c b/isdn/i4l/isdn_ttyfax.c
--- a/isdn/i4l/isdn_ttyfax.c
+++ b/isdn/i4l/isdn_ttyfax.c
@@ -291,6 +291,11 @@ isdn_tty_fax_bitorder(modem_info * info,
 	if (!info->fax->bor) {
 		for (i = 0; i < skb->len; i++) {
 			Data = skb->data[i];
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (
 				    LeftMask = 0x80, RightMask = 0x01;
 				    LeftMask > RightMask;
@@ -306,6 +311,12 @@ isdn_tty_fax_bitorder(modem_info * info,
 				else
 					Data &= ~RightMask;
 
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 			skb->data[i] = Data;
 		}
diff -u -p a/isdn/pcbit/drv.c b/isdn/pcbit/drv.c
--- a/isdn/pcbit/drv.c
+++ b/isdn/pcbit/drv.c
@@ -1064,6 +1064,11 @@ static int pcbit_check_msn(struct pcbit_
 {
 	struct msn_entry *ptr;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr=dev->msn_list; ptr; ptr=ptr->next) {
 
 		if (ptr->msn == NULL) 
@@ -1071,6 +1076,12 @@ static int pcbit_check_msn(struct pcbit_
 		
 		if (strcmp(ptr->msn, msn) == 0)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/isdn/icn/icn.c b/isdn/icn/icn.c
--- a/isdn/icn/icn.c
+++ b/isdn/icn/icn.c
@@ -1056,6 +1056,11 @@ icn_writecmd(const u_char * buf, int len
 		icn_map_channel(card, mch);
 
 		icn_putmsg(card, '>');
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (p = msg, pp = readb(&cmd_i), i = count; i > 0; i--, p++, pp
 		     ++) {
 			writeb((*p == '\n') ? 0xff : *p,
@@ -1068,6 +1073,12 @@ icn_writecmd(const u_char * buf, int len
 				ocount++;
 			}
 			ocount++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		writeb((readb(&cmd_i) + count) & 0xff, &cmd_i);
 		if (lastmap_card)
diff -u -p a/isdn/hardware/eicon/s_4bri.c b/isdn/hardware/eicon/s_4bri.c
--- a/isdn/hardware/eicon/s_4bri.c
+++ b/isdn/hardware/eicon/s_4bri.c
@@ -334,6 +334,11 @@ int qBri_FPGA_download (PISDN_ADAPTER Io
 	{
 		val = ((word)File[code++]) << 3 ;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for ( bit = 8 ; bit-- > 0 ; val <<= 1 ) /* put byte onto FPGA */
 		{
 			baseval &= ~FPGA_DOUT ;             /* clr  data bit */
@@ -342,6 +347,12 @@ int qBri_FPGA_download (PISDN_ADAPTER Io
 			WRITE_WORD(addr, baseval | FPGA_CCLK) ;     /* set CCLK hi */
 			WRITE_WORD(addr, baseval | FPGA_CCLK) ;     /* set CCLK hi */
 			WRITE_WORD(addr, baseval) ;                 /* set CCLK lo */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	xdiFreeFile (File) ;
diff -u -p a/block/DAC960.c b/block/DAC960.c
--- a/block/DAC960.c
+++ b/block/DAC960.c
@@ -3238,11 +3238,22 @@ static void DAC960_V1_QueueReadWriteComm
 
       CommandMailbox->Type5.ScatterGatherCount = Command->SegmentCount;
 
-      for (i = 0; i < Command->SegmentCount; i++, ScatterList++, ScatterGatherList++) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+		for (i = 0; i < Command->SegmentCount; i++, ScatterList++, ScatterGatherList++) {
 		ScatterGatherList->SegmentDataPointer =
 			(DAC960_BusAddress32_T)sg_dma_address(ScatterList);
 		ScatterGatherList->SegmentByteCount =
 			(DAC960_ByteCount32_T)sg_dma_len(ScatterList);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
       }
     }
   DAC960_QueueCommand(Command);
@@ -3312,11 +3323,22 @@ static void DAC960_V2_QueueReadWriteComm
 	ScatterGatherList = CommandMailbox->SCSI_10.DataTransferMemoryAddress
 				 .ScatterGatherSegments;
 
-      for (i = 0; i < Command->SegmentCount; i++, ScatterList++, ScatterGatherList++) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+		for (i = 0; i < Command->SegmentCount; i++, ScatterList++, ScatterGatherList++) {
 		ScatterGatherList->SegmentDataPointer =
 			(DAC960_BusAddress64_T)sg_dma_address(ScatterList);
 		ScatterGatherList->SegmentByteCount =
 			(DAC960_ByteCount64_T)sg_dma_len(ScatterList);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
       }
     }
   DAC960_QueueCommand(Command);
diff -u -p a/pnp/pnpbios/core.c b/pnp/pnpbios/core.c
--- a/pnp/pnpbios/core.c
+++ b/pnp/pnpbios/core.c
@@ -445,6 +445,11 @@ static int __init pnpbios_probe_system(v
 	 * structure and, if one is found, sets up the selectors and
 	 * entry points
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (check = (union pnp_bios_install_struct *)__va(0xf0000);
 	     check < (union pnp_bios_install_struct *)__va(0xffff0);
 	     check = (void *)check + 16) {
@@ -480,6 +485,12 @@ static int __init pnpbios_probe_system(v
 		       check->fields.pm16dseg);
 		pnp_bios_install = check;
 		return 1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	printk(KERN_INFO "PnPBIOS: PnP BIOS support was not detected.\n");
diff -u -p a/pcmcia/rsrc_nonstatic.c b/pcmcia/rsrc_nonstatic.c
--- a/pcmcia/rsrc_nonstatic.c
+++ b/pcmcia/rsrc_nonstatic.c
@@ -423,6 +423,11 @@ static int do_mem_probe(struct pcmcia_so
 	/* cis_readable wants to map 2x map_size */
 	if (step < 2 * s->map_size)
 		step = 2 * s->map_size;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = j = base; i < base+num; i = j + step) {
 		if (!fail) {
 			for (j = i; j < base+num; j += step) {
@@ -443,6 +448,12 @@ static int do_mem_probe(struct pcmcia_so
 			sub_interval(&s_data->mem_db, i, j-i);
 			bad += j-i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(bad ? "\n" : " clean.\n");
 	return num - bad;
@@ -500,6 +511,11 @@ static int validate_mem(struct pcmcia_so
 		return -ENODEV;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = s_data->mem_db.next; m != &s_data->mem_db; m = mm.next) {
 		mm = *m;
 		/* Only probe < 1 MB */
@@ -521,6 +537,12 @@ static int validate_mem(struct pcmcia_so
 							   readable, checksum);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ok > 0)
@@ -544,9 +566,20 @@ static int validate_mem(struct pcmcia_so
 	struct socket_data *s_data = s->resource_data;
 	unsigned long ok = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = s_data->mem_db.next; m != &s_data->mem_db; m = mm.next) {
 		mm = *m;
 		ok += do_mem_probe(s, mm.base, mm.num, readable, checksum);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (ok > 0)
 		return 0;
@@ -658,6 +691,11 @@ static int __nonstatic_adjust_io_region(
 	struct socket_data *s_data = s->resource_data;
 	int ret = -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = s_data->io_db.next; m != &s_data->io_db; m = m->next) {
 		unsigned long start = m->base;
 		unsigned long end = m->base + m->num - 1;
@@ -666,6 +704,12 @@ static int __nonstatic_adjust_io_region(
 			continue;
 
 		ret = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
@@ -1040,17 +1084,50 @@ static void nonstatic_release_resource_d
 	struct socket_data *data = s->resource_data;
 	struct resource_map *p, *q;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db_valid.next; p != &data->mem_db_valid; p = q) {
 		q = p->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db.next; p != &data->mem_db; p = q) {
 		q = p->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->io_db.next; p != &data->io_db; p = q) {
 		q = p->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1078,6 +1155,11 @@ static ssize_t show_io_db(struct device
 	mutex_lock(&s->ops_mutex);
 	data = s->resource_data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->io_db.next; p != &data->io_db; p = p->next) {
 		if (ret > (PAGE_SIZE - 10))
 			continue;
@@ -1085,6 +1167,12 @@ static ssize_t show_io_db(struct device
 				"0x%08lx - 0x%08lx\n",
 				((unsigned long) p->base),
 				((unsigned long) p->base + p->num - 1));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&s->ops_mutex);
@@ -1134,6 +1222,11 @@ static ssize_t show_mem_db(struct device
 	mutex_lock(&s->ops_mutex);
 	data = s->resource_data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db_valid.next; p != &data->mem_db_valid;
 	     p = p->next) {
 		if (ret > (PAGE_SIZE - 10))
@@ -1142,8 +1235,19 @@ static ssize_t show_mem_db(struct device
 				"0x%08lx - 0x%08lx\n",
 				((unsigned long) p->base),
 				((unsigned long) p->base + p->num - 1));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db.next; p != &data->mem_db; p = p->next) {
 		if (ret > (PAGE_SIZE - 10))
 			continue;
@@ -1151,6 +1255,12 @@ static ssize_t show_mem_db(struct device
 				"0x%08lx - 0x%08lx\n",
 				((unsigned long) p->base),
 				((unsigned long) p->base + p->num - 1));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&s->ops_mutex);
diff -u -p a/rtc/rtc-cmos.c b/rtc/rtc-cmos.c
--- a/rtc/rtc-cmos.c
+++ b/rtc/rtc-cmos.c
@@ -517,6 +517,11 @@ cmos_nvram_read(struct file *filp, struc
 
 	off += NVRAM_OFFSET;
 	spin_lock_irq(&rtc_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (retval = 0; count; count--, off++, retval++) {
 		if (off < 128)
 			*buf++ = CMOS_READ(off);
@@ -524,6 +529,12 @@ cmos_nvram_read(struct file *filp, struc
 			*buf++ = cmos_read_bank2(off);
 		else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	spin_unlock_irq(&rtc_lock);
 
@@ -553,7 +564,12 @@ cmos_nvram_write(struct file *filp, stru
 	 */
 	off += NVRAM_OFFSET;
 	spin_lock_irq(&rtc_lock);
-	for (retval = 0; count; count--, off++, retval++) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (retval = 0; count; count--, off++, retval++) {
 		/* don't trash RTC registers */
 		if (off == cmos->day_alrm
 				|| off == cmos->mon_alrm
@@ -565,6 +581,12 @@ cmos_nvram_write(struct file *filp, stru
 			cmos_write_bank2(*buf++, off);
 		else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	spin_unlock_irq(&rtc_lock);
 
diff -u -p a/parport/share.c b/parport/share.c
--- a/parport/share.c
+++ b/parport/share.c
@@ -978,6 +978,11 @@ void parport_release(struct pardevice *d
 	/* If anybody is waiting, find out who's been there longest and
 	   then wake them up. (Note: no locking required) */
 	/* !!! LOCKING IS NEEDED HERE */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pd = port->waithead; pd; pd = pd->waitnext) {
 		if (pd->waiting & 2) { /* sleeping in claim_or_block */
 			parport_claim(pd);
@@ -991,14 +996,31 @@ void parport_release(struct pardevice *d
 		} else {
 			printk(KERN_ERR "%s: don't know how to wake %s\n", port->name, pd->name);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Nobody was waiting, so walk the list to see if anyone is
 	   interested in being woken up. (Note: no locking required) */
 	/* !!! LOCKING IS NEEDED HERE */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pd = port->devices; (port->cad == NULL) && pd; pd = pd->next) {
 		if (pd->wakeup && pd != dev)
 			pd->wakeup(pd->private);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 }
 
diff -u -p a/parport/procfs.c b/parport/procfs.c
--- a/parport/procfs.c
+++ b/parport/procfs.c
@@ -47,10 +47,21 @@ static int do_active_device(ctl_table *t
 		return 0;
 	}
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = port->devices; dev ; dev = dev->next) {
 		if(dev == port->cad) {
 			len += sprintf(buffer, "%s\n", dev->name);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if(!len) {
diff -u -p a/iommu/iova.c b/iommu/iova.c
--- a/iommu/iova.c
+++ b/iommu/iova.c
@@ -423,6 +423,11 @@ copy_reserved_iova(struct iova_domain *f
 	struct rb_node *node;
 
 	spin_lock_irqsave(&from->iova_rbtree_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&from->rbroot); node; node = rb_next(node)) {
 		struct iova *iova = container_of(node, struct iova, node);
 		struct iova *new_iova;
@@ -430,6 +435,12 @@ copy_reserved_iova(struct iova_domain *f
 		if (!new_iova)
 			printk(KERN_ERR "Reserve iova range %lx@%lx failed\n",
 				iova->pfn_lo, iova->pfn_lo);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	spin_unlock_irqrestore(&from->iova_rbtree_lock, flags);
 }
diff -u -p a/gpu/drm/nouveau/nv50_graph.c b/gpu/drm/nouveau/nv50_graph.c
--- a/gpu/drm/nouveau/nv50_graph.c
+++ b/gpu/drm/nouveau/nv50_graph.c
@@ -426,19 +426,52 @@ nv84_graph_tlb_flush(struct drm_device *
 	do {
 		idle = true;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (tmp = nv_rd32(dev, 0x400380); tmp && idle; tmp >>= 3) {
 			if ((tmp & 7) == 1)
 				idle = false;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (tmp = nv_rd32(dev, 0x400384); tmp && idle; tmp >>= 3) {
 			if ((tmp & 7) == 1)
 				idle = false;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (tmp = nv_rd32(dev, 0x400388); tmp && idle; tmp >>= 3) {
 			if ((tmp & 7) == 1)
 				idle = false;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	} while (!idle && !(timeout = ptimer->read(dev) - start > 2000000000));
 
diff -u -p a/gpu/drm/nouveau/nouveau_bios.c b/gpu/drm/nouveau/nouveau_bios.c
--- a/gpu/drm/nouveau/nouveau_bios.c
+++ b/gpu/drm/nouveau/nouveau_bios.c
@@ -2620,6 +2620,11 @@ init_configure_mem(struct nvbios *bios,
 	if (bios->data[meminitoffs] & 1)
 		seqtbloffs = bios->legacy.ddr_seq_tbl_ptr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (reg = ROM32(bios->data[seqtbloffs]);
 	     reg != 0xffffffff;
 	     reg = ROM32(bios->data[seqtbloffs += 4])) {
@@ -2642,6 +2647,12 @@ init_configure_mem(struct nvbios *bios,
 		}
 
 		bios_wr32(bios, reg, data);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return 1;
@@ -5996,6 +6007,11 @@ parse_dcb_connector_table(struct nvbios
 
 	entry = conntab + conntab[1];
 	cte = &ct->entry[0];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < conntab[2]; i++, entry += conntab[3], cte++) {
 		cte->index = i;
 		if (conntab[3] == 2)
@@ -6046,6 +6062,12 @@ parse_dcb_connector_table(struct nvbios
 				NV_WARN(dev, " -> type 0x%02x\n", cte->type);
 		}
 
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/radeon/evergreen_cs.c b/gpu/drm/radeon/evergreen_cs.c
--- a/gpu/drm/radeon/evergreen_cs.c
+++ b/gpu/drm/radeon/evergreen_cs.c
@@ -406,11 +406,22 @@ static int evergreen_cs_parse_packet0(st
 
 	idx = pkt->idx + 1;
 	reg = pkt->reg;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= pkt->count; i++, idx++, reg += 4) {
 		r = evergreen_packet0_check(p, pkt, idx, reg);
 		if (r) {
 			return r;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/gpu/drm/radeon/r600_cs.c b/gpu/drm/radeon/r600_cs.c
--- a/gpu/drm/radeon/r600_cs.c
+++ b/gpu/drm/radeon/r600_cs.c
@@ -873,11 +873,22 @@ static int r600_cs_parse_packet0(struct
 
 	idx = pkt->idx + 1;
 	reg = pkt->reg;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <= pkt->count; i++, idx++, reg += 4) {
 		r = r600_packet0_check(p, pkt, idx, reg);
 		if (r) {
 			return r;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/gpu/drm/savage/savage_state.c b/gpu/drm/savage/savage_state.c
--- a/gpu/drm/savage/savage_state.c
+++ b/gpu/drm/savage/savage_state.c
@@ -825,6 +825,11 @@ static int savage_dispatch_clear(drm_sav
 		w = boxes[i].x2 - boxes[i].x1;
 		h = boxes[i].y2 - boxes[i].y1;
 		BEGIN_DMA(nbufs * 6);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (buf = SAVAGE_FRONT; buf <= SAVAGE_DEPTH; buf <<= 1) {
 			if (!(flags & buf))
 				continue;
@@ -846,6 +851,12 @@ static int savage_dispatch_clear(drm_sav
 			DMA_WRITE(data->clear1.value);
 			DMA_WRITE(BCI_X_Y(x, y));
 			DMA_WRITE(BCI_W_H(w, h));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		DMA_COMMIT();
 	}
diff -u -p a/gpu/drm/i915/i915_mem.c b/gpu/drm/i915/i915_mem.c
--- a/gpu/drm/i915/i915_mem.c
+++ b/gpu/drm/i915/i915_mem.c
@@ -137,10 +137,21 @@ static struct mem_block *alloc_block(str
 	struct mem_block *p;
 	int mask = (1 << align2) - 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = heap->next; p != heap; p = p->next) {
 		int start = (p->start + mask) & ~mask;
 		if (p->file_priv == NULL && start + size <= p->start + p->size)
 			return split_block(p, start, size, file_priv);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NULL;
@@ -217,16 +228,32 @@ void i915_mem_release(struct drm_device
 	if (!heap || !heap->next)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = heap->next; p != heap; p = p->next) {
 		if (p->file_priv == file_priv) {
 			p->file_priv = NULL;
 			mark_block(dev, p, 0);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Assumes a single contiguous range.  Needs a special file_priv in
 	 * 'heap' to stop it being subsumed.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = heap->next; p != heap; p = p->next) {
 		while (p->file_priv == NULL && p->next->file_priv == NULL) {
 			struct mem_block *q = p->next;
@@ -235,6 +262,12 @@ void i915_mem_release(struct drm_device
 			p->next->prev = p;
 			kfree(q);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/i915/intel_dp.c b/gpu/drm/i915/intel_dp.c
--- a/gpu/drm/i915/intel_dp.c
+++ b/gpu/drm/i915/intel_dp.c
@@ -727,6 +727,11 @@ intel_dp_mode_fixup(struct drm_encoder *
 	bpp = adjusted_mode->private_flags & INTEL_MODE_DP_FORCE_6BPC ? 18 : 24;
 
 	for (clock = 0; clock <= max_clock; clock++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (lane_count = 1; lane_count <= max_lane_count; lane_count <<= 1) {
 			int link_avail = intel_dp_max_data_rate(intel_dp_link_clock(bws[clock]), lane_count);
 
@@ -741,6 +746,12 @@ intel_dp_mode_fixup(struct drm_encoder *
 				       adjusted_mode->clock);
 				return true;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/gpu/drm/mga/mga_dma.c b/gpu/drm/mga/mga_dma.c
--- a/gpu/drm/mga/mga_dma.c
+++ b/gpu/drm/mga/mga_dma.c
@@ -234,10 +234,21 @@ static void mga_freelist_print(struct dr
 				dev_priv->primary->offset));
 	DRM_INFO("current freelist:\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (entry = dev_priv->head->next; entry; entry = entry->next) {
 		DRM_INFO("   %p   idx=%2d  age=0x%x 0x%06lx\n",
 			 entry, entry->buf->idx, entry->age.head,
 			 (unsigned long)(entry->age.head - dev_priv->primary->offset));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	DRM_INFO("\n");
 }
diff -u -p a/gpu/drm/mga/mga_warp.c b/gpu/drm/mga/mga_warp.c
--- a/gpu/drm/mga/mga_warp.c
+++ b/gpu/drm/mga/mga_warp.c
@@ -88,11 +88,22 @@ int mga_warp_install_microcode(drm_mga_p
 
 	size = 0;
 	where = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)fw->data;
 	     rec;
 	     rec = ihex_next_binrec(rec)) {
 		size += WARP_UCODE_SIZE(be16_to_cpu(rec->len));
 		where++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (where != n_pipes) {
@@ -112,6 +123,11 @@ int mga_warp_install_microcode(drm_mga_p
 	memset(dev_priv->warp_pipe_phys, 0, sizeof(dev_priv->warp_pipe_phys));
 
 	where = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)fw->data;
 	     rec;
 	     rec = ihex_next_binrec(rec)) {
@@ -125,6 +141,12 @@ int mga_warp_install_microcode(drm_mga_p
 		pcbase += dst_size;
 		vcbase += dst_size;
 		where++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 out:
diff -u -p a/gpu/drm/vmwgfx/vmwgfx_resource.c b/gpu/drm/vmwgfx/vmwgfx_resource.c
--- a/gpu/drm/vmwgfx/vmwgfx_resource.c
+++ b/gpu/drm/vmwgfx/vmwgfx_resource.c
@@ -681,10 +681,21 @@ static void vmw_surface_define_encode(co
 	cmd_size = (SVGA3dSize *) cmd;
 	src_size = srf->sizes;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < srf->num_sizes; ++i, cmd_size++, src_size++) {
 		cmd_size->width = src_size->width;
 		cmd_size->height = src_size->height;
 		cmd_size->depth = src_size->depth;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/misc/emi26.c b/usb/misc/emi26.c
--- a/usb/misc/emi26.c
+++ b/usb/misc/emi26.c
@@ -170,7 +170,12 @@ static int emi26_load_firmware (struct u
 	}
 
 	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
-	for (rec = (const struct ihex_binrec *)loader_fw->data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (rec = (const struct ihex_binrec *)loader_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		err = emi26_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
@@ -179,6 +184,12 @@ static int emi26_load_firmware (struct u
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	msleep(250);	/* let device settle */
 
@@ -191,6 +202,11 @@ static int emi26_load_firmware (struct u
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (!INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -202,6 +218,12 @@ static int emi26_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	/* Assert reset (stop the CPU in the EMI) */
@@ -211,6 +233,11 @@ static int emi26_load_firmware (struct u
 		goto wraperr;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -222,6 +249,12 @@ static int emi26_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
diff -u -p a/usb/misc/emi62.c b/usb/misc/emi62.c
--- a/usb/misc/emi62.c
+++ b/usb/misc/emi62.c
@@ -177,7 +177,12 @@ static int emi62_load_firmware (struct u
 	}
 
 	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
-	for (rec = (const struct ihex_binrec *)loader_fw->data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (rec = (const struct ihex_binrec *)loader_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		err = emi62_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
@@ -186,6 +191,12 @@ static int emi62_load_firmware (struct u
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
@@ -198,6 +209,11 @@ static int emi62_load_firmware (struct u
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (!INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -209,6 +225,12 @@ static int emi62_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Assert reset (stop the CPU in the EMI) */
@@ -218,6 +240,11 @@ static int emi62_load_firmware (struct u
 		goto wraperr;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -229,6 +256,12 @@ static int emi62_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
diff -u -p a/usb/host/ohci-q.c b/usb/host/ohci-q.c
--- a/usb/host/ohci-q.c
+++ b/usb/host/ohci-q.c
@@ -904,6 +904,11 @@ finish_unlinks (struct ohci_hcd *ohci, u
 	struct ed	*ed, **last;
 
 rescan_all:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last = &ohci->ed_rm_list, ed = *last; ed != NULL; ed = *last) {
 		struct list_head	*entry, *tmp;
 		int			completed, modified;
@@ -1018,6 +1023,12 @@ rescan_this:
 
 		if (modified)
 			goto rescan_all;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* maybe reenable control and bulk lists */
diff -u -p a/usb/host/xhci-ring.c b/usb/host/xhci-ring.c
--- a/usb/host/xhci-ring.c
+++ b/usb/host/xhci-ring.c
@@ -2078,12 +2078,23 @@ static int process_isoc_td(struct xhci_h
 		frame->actual_length = frame->length;
 		td->urb->actual_length += frame->length;
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cur_trb = ep_ring->dequeue,
 		     cur_seg = ep_ring->deq_seg; cur_trb != event_trb;
 		     next_trb(xhci, ep_ring, &cur_seg, &cur_trb)) {
 			if (!TRB_TYPE_NOOP_LE32(cur_trb->generic.field[3]) &&
 			    !TRB_TYPE_LINK_LE32(cur_trb->generic.field[3]))
 				len += TRB_LEN(le32_to_cpu(cur_trb->generic.field[2]));
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
+		break;
+				}
 		}
 		len += TRB_LEN(le32_to_cpu(cur_trb->generic.field[2])) -
 			EVENT_TRB_LEN(le32_to_cpu(event->transfer_len));
@@ -2211,13 +2222,24 @@ static int process_bulk_intr_td(struct x
 		 * pointer, to get the actual length transferred.
 		 */
 		td->urb->actual_length = 0;
-		for (cur_trb = ep_ring->dequeue, cur_seg = ep_ring->deq_seg;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (cur_trb = ep_ring->dequeue, cur_seg = ep_ring->deq_seg;
 				cur_trb != event_trb;
 				next_trb(xhci, ep_ring, &cur_seg, &cur_trb)) {
 			if (!TRB_TYPE_NOOP_LE32(cur_trb->generic.field[3]) &&
 			    !TRB_TYPE_LINK_LE32(cur_trb->generic.field[3]))
 				td->urb->actual_length +=
 					TRB_LEN(le32_to_cpu(cur_trb->generic.field[2]));
+					if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		/* If the ring didn't stop on a Link or No-op TRB, add
 		 * in the actual bytes transferred from the Normal TRB
diff -u -p a/usb/host/ehci-sched.c b/usb/host/ehci-sched.c
--- a/usb/host/ehci-sched.c
+++ b/usb/host/ehci-sched.c
@@ -1363,9 +1363,20 @@ sitd_slot_ok (
 
 		/* check starts (OUT uses more than one) */
 		max_used = ehci->uframe_periodic_max - stream->usecs;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (tmp = stream->raw_mask & 0xff; tmp; tmp >>= 1, uf++) {
 			if (periodic_usecs (ehci, frame, uf) > max_used)
 				return 0;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* for IN, check CSPLIT */
diff -u -p a/usb/host/isp116x-hcd.c b/usb/host/isp116x-hcd.c
--- a/usb/host/isp116x-hcd.c
+++ b/usb/host/isp116x-hcd.c
@@ -174,6 +174,11 @@ static void pack_fifo(struct isp116x *is
 	isp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);
 	isp116x_write_reg16(isp116x, HCXFERCTR, buflen);
 	isp116x_write_addr(isp116x, HCATLPORT | ISP116x_WRITE_OFFSET);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		ptd = &ep->ptd;
 		dump_ptd(ptd);
@@ -188,6 +193,12 @@ static void pack_fifo(struct isp116x *is
 			write_ptddata_to_fifo(isp116x, ep->data, ep->length);
 			buflen -= ALIGN(ep->length, 4);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	BUG_ON(buflen);
 }
@@ -206,6 +217,11 @@ static void unpack_fifo(struct isp116x *
 	isp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);
 	isp116x_write_reg16(isp116x, HCXFERCTR, buflen);
 	isp116x_write_addr(isp116x, HCATLPORT);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		ptd = &ep->ptd;
 		ptd->count = isp116x_read_data16(isp116x);
@@ -220,6 +236,12 @@ static void unpack_fifo(struct isp116x *
 		}
 		dump_ptd(ptd);
 		dump_ptd_in_data(ptd, ep->data);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	BUG_ON(buflen);
 }
@@ -236,6 +258,11 @@ static void preproc_atl_queue(struct isp
 	struct ptd *ptd;
 	u16 len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		u16 toggle = 0, dir = PTD_DIR_SETUP;
 
@@ -285,6 +312,12 @@ static void preproc_atl_queue(struct isp
 		}
 		isp116x->atl_bufshrt = sizeof(struct ptd) + isp116x->atl_buflen;
 		isp116x->atl_buflen = isp116x->atl_bufshrt + ALIGN(len, 4);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -356,7 +389,12 @@ static void postproc_atl_queue(struct is
 	int status;
 	u8 cc;
 
-	for (ep = isp116x->atl_active; ep; ep = ep->active) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		BUG_ON(list_empty(&ep->hep->urb_list));
 		urb =
 		    container_of(ep->hep->urb_list.next, struct urb, urb_list);
@@ -471,6 +509,12 @@ static void postproc_atl_queue(struct is
  done:
 		if (status != -EINPROGRESS || urb->unlinked)
 			finish_request(isp116x, ep, urb, status);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/usb/musb/cppi_dma.c b/usb/musb/cppi_dma.c
--- a/usb/musb/cppi_dma.c
+++ b/usb/musb/cppi_dma.c
@@ -1186,6 +1186,11 @@ irqreturn_t cppi_interrupt(int irq, void
 	dev_dbg(musb->controller, "CPPI IRQ Tx%x Rx%x\n", tx, rx);
 
 	/* process TX channels */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; tx; tx = tx >> 1, index++) {
 		struct cppi_channel		*tx_ch;
 		struct cppi_tx_stateram __iomem	*tx_ram;
@@ -1273,9 +1278,20 @@ irqreturn_t cppi_interrupt(int irq, void
 			}
 		} else
 			tx_ch->head = bd;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* Start processing the RX block */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = 0; rx; rx = rx >> 1, index++) {
 
 		if (rx & 1) {
@@ -1303,6 +1319,12 @@ irqreturn_t cppi_interrupt(int irq, void
 			core_rxirq_disable(tibase, index + 1);
 			musb_dma_completion(musb, index + 1, 0);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* write to CPPI EOI register to re-enable interrupts */
diff -u -p a/usb/early/ehci-dbgp.c b/usb/early/ehci-dbgp.c
--- a/usb/early/ehci-dbgp.c
+++ b/usb/early/ehci-dbgp.c
@@ -942,6 +942,11 @@ static void early_dbgp_write(struct cons
 		}
 	}
 	while (n > 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (chunk = 0; chunk < DBGP_MAX_PACKET && n > 0;
 		     str++, chunk++, n--) {
 			if (!use_cr && *str == '\n') {
@@ -954,6 +959,12 @@ static void early_dbgp_write(struct cons
 			if (use_cr)
 				use_cr = 0;
 			buf[chunk] = *str;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (chunk > 0) {
 			ret = dbgp_bulk_write(USB_DEBUG_DEVNUM,
diff -u -p a/usb/serial/ti_usb_3410_5052.c b/usb/serial/ti_usb_3410_5052.c
--- a/usb/serial/ti_usb_3410_5052.c
+++ b/usb/serial/ti_usb_3410_5052.c
@@ -328,6 +328,11 @@ static int __init ti_init(void)
 	/* insert extra vendor and product ids */
 	c = ARRAY_SIZE(ti_id_table_combined) - 2 * TI_EXTRA_VID_PID_COUNT - 1;
 	j = ARRAY_SIZE(ti_id_table_3410) - TI_EXTRA_VID_PID_COUNT - 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < min(vendor_3410_count, product_3410_count); i++, j++, c++) {
 		ti_id_table_3410[j].idVendor = vendor_3410[i];
 		ti_id_table_3410[j].idProduct = product_3410[i];
@@ -335,8 +340,19 @@ static int __init ti_init(void)
 		ti_id_table_combined[c].idVendor = vendor_3410[i];
 		ti_id_table_combined[c].idProduct = product_3410[i];
 		ti_id_table_combined[c].match_flags = USB_DEVICE_ID_MATCH_DEVICE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	j = ARRAY_SIZE(ti_id_table_5052) - TI_EXTRA_VID_PID_COUNT - 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < min(vendor_5052_count, product_5052_count); i++, j++, c++) {
 		ti_id_table_5052[j].idVendor = vendor_5052[i];
 		ti_id_table_5052[j].idProduct = product_5052[i];
@@ -344,6 +360,12 @@ static int __init ti_init(void)
 		ti_id_table_combined[c].idVendor = vendor_5052[i];
 		ti_id_table_combined[c].idProduct = product_5052[i];
 		ti_id_table_combined[c].match_flags = USB_DEVICE_ID_MATCH_DEVICE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = usb_serial_register(&ti_1port_device);
diff -u -p a/usb/gadget/pxa27x_udc.c b/usb/gadget/pxa27x_udc.c
--- a/usb/gadget/pxa27x_udc.c
+++ b/usb/gadget/pxa27x_udc.c
@@ -2252,6 +2252,11 @@ static void irq_handle_data(int irq, str
 	}
 
 	udcisr0 >>= 2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; udcisr0 != 0 && i < 16; udcisr0 >>= 2, i++) {
 		if (!(udcisr0 & UDCISR_INT_MASK))
 			continue;
@@ -2264,8 +2269,19 @@ static void irq_handle_data(int irq, str
 			ep->stats.irqs++;
 			handle_ep(ep);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 16; udcisr1 != 0 && i < 24; udcisr1 >>= 2, i++) {
 		udc_writel(udc, UDCISR1, UDCISR_INT(i - 16, UDCISR_INT_MASK));
 		if (!(udcisr1 & UDCISR_INT_MASK))
@@ -2277,6 +2293,12 @@ static void irq_handle_data(int irq, str
 			ep->stats.irqs++;
 			handle_ep(ep);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
diff -u -p a/usb/gadget/f_mass_storage.c b/usb/gadget/f_mass_storage.c
--- a/usb/gadget/f_mass_storage.c
+++ b/usb/gadget/f_mass_storage.c
@@ -1588,6 +1588,11 @@ static int throw_away_data(struct fsg_co
 	u32			amount;
 	int			rc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bh = common->next_buffhd_to_drain;
 	     bh->state != BUF_STATE_EMPTY || common->usb_amount_left > 0;
 	     bh = common->next_buffhd_to_drain) {
@@ -1632,6 +1637,12 @@ static int throw_away_data(struct fsg_co
 		rc = sleep_thread(common);
 		if (rc)
 			return rc;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
@@ -2774,6 +2785,11 @@ static struct fsg_common *fsg_common_ini
 
 	init_rwsem(&common->filesem);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, lcfg = cfg->luns; i < nluns; ++i, ++curlun, ++lcfg) {
 		curlun->cdrom = !!lcfg->cdrom;
 		curlun->ro = lcfg->cdrom || lcfg->ro;
@@ -2816,6 +2832,12 @@ static struct fsg_common *fsg_common_ini
 			rc = -EINVAL;
 			goto error_luns;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	common->nluns = nluns;
 
diff -u -p a/usb/core/generic.c b/usb/core/generic.c
--- a/usb/core/generic.c
+++ b/usb/core/generic.c
@@ -50,6 +50,11 @@ int usb_choose_configuration(struct usb_
 	best = NULL;
 	c = udev->config;
 	num_configs = udev->descriptor.bNumConfigurations;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < num_configs; (i++, c++)) {
 		struct usb_interface_descriptor	*desc = NULL;
 
@@ -132,6 +137,12 @@ int usb_choose_configuration(struct usb_
 		 * choose the first one. */
 		else if (!best)
 			best = c;
+			if (_cur < timeout) {
+rdstcll(_cur);
+		}
+		else {
+break;
+		}
 	}
 
 	if (insufficient_power > 0)
diff -u -p a/usb/core/config.c b/usb/core/config.c
--- a/usb/core/config.c
+++ b/usb/core/config.c
@@ -333,6 +333,11 @@ static int usb_parse_interface(struct de
 
 	/* Check for duplicate altsetting entries */
 	asnum = d->bAlternateSetting;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for ((i = 0, alt = &intfc->altsetting[0]);
 	      i < intfc->num_altsetting;
 	     (++i, ++alt)) {
@@ -342,6 +347,12 @@ static int usb_parse_interface(struct de
 			    cfgno, inum, asnum);
 			goto skip_to_next_interface_descriptor;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	++intfc->num_altsetting;
diff -u -p a/char/dsp56k.c b/char/dsp56k.c
--- a/char/dsp56k.c
+++ b/char/dsp56k.c
@@ -151,11 +151,22 @@ static int dsp56k_upload(u_char __user *
 		release_firmware(fw);
 		return -EINVAL;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fw->size; i = i + 3) {
 		/* tx_wait(10); */
 		dsp56k_host_interface.data.b[1] = fw->data[i];
 		dsp56k_host_interface.data.b[2] = fw->data[i + 1];
 		dsp56k_host_interface.data.b[3] = fw->data[i + 2];
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	release_firmware(fw);
 	for (; i < 512; i++) {
diff -u -p a/char/generic_nvram.c b/char/generic_nvram.c
--- a/char/generic_nvram.c
+++ b/char/generic_nvram.c
@@ -81,10 +81,21 @@ static ssize_t write_nvram(struct file *
 		return -EFAULT;
 	if (*ppos >= nvram_len)
 		return 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = *ppos; count > 0 && i < nvram_len; ++i, ++p, --count) {
 		if (__get_user(c, p))
 			return -EFAULT;
 		nvram_write_byte(c, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*ppos = i;
 	return p - buf;
diff -u -p a/char/rtc.c b/char/rtc.c
--- a/char/rtc.c
+++ b/char/rtc.c
@@ -973,6 +973,11 @@ static int __init rtc_init(void)
 #ifdef CONFIG_SPARC32
 	for_each_node_by_name(ebus_dp, "ebus") {
 		struct device_node *dp;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (dp = ebus_dp; dp; dp = dp->sibling) {
 			if (!strcmp(dp->name, "rtc")) {
 				op = of_find_device_by_node(dp);
@@ -982,6 +987,12 @@ static int __init rtc_init(void)
 					goto found;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	rtc_has_irq = 0;
diff -u -p a/char/agp/hp-agp.c b/char/agp/hp-agp.c
--- a/char/agp/hp-agp.c
+++ b/char/agp/hp-agp.c
@@ -364,10 +364,21 @@ hp_zx1_insert_memory (struct agp_memory
 		unsigned long paddr;
 
 		paddr = page_to_phys(mem->pages[i]);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (k = 0;
 		     k < hp->io_pages_per_kpage;
 		     k++, j++, paddr += hp->io_page_size) {
 			hp->gatt[j] = HP_ZX1_PDIR_VALID_BIT | paddr;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/char/agp/parisc-agp.c b/char/agp/parisc-agp.c
--- a/char/agp/parisc-agp.c
+++ b/char/agp/parisc-agp.c
@@ -155,12 +155,23 @@ parisc_agp_insert_memory(struct agp_memo
 		unsigned long paddr;
 
 		paddr = page_to_phys(mem->pages[i]);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (k = 0;
 		     k < info->io_pages_per_kpage;
 		     k++, j++, paddr += info->io_page_size) {
 			info->gatt[j] =
 				parisc_agp_mask_memory(agp_bridge,
 					paddr, type);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
diff -u -p a/s390/block/dasd_3990_erp.c b/s390/block/dasd_3990_erp.c
--- a/s390/block/dasd_3990_erp.c
+++ b/s390/block/dasd_3990_erp.c
@@ -2707,6 +2707,11 @@ dasd_3990_erp_action(struct dasd_ccw_req
 		/* print current erp_chain */
 		dev_err(&device->cdev->dev,
 			    "ERP chain at BEGINNING of ERP-ACTION\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (temp_erp = cqr;
 		     temp_erp != NULL; temp_erp = temp_erp->refers) {
 
@@ -2714,6 +2719,12 @@ dasd_3990_erp_action(struct dasd_ccw_req
 				    "ERP %p (%02x) refers to %p\n",
 				    temp_erp, temp_erp->status,
 				    temp_erp->refers);
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
@@ -2748,6 +2759,11 @@ dasd_3990_erp_action(struct dasd_ccw_req
 		/* print current erp_chain */
 		dev_err(&device->cdev->dev,
 			    "ERP chain at END of ERP-ACTION\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (temp_erp = erp;
 		     temp_erp != NULL; temp_erp = temp_erp->refers) {
 
@@ -2755,6 +2771,12 @@ dasd_3990_erp_action(struct dasd_ccw_req
 				    "ERP %p (%02x) refers to %p\n",
 				    temp_erp, temp_erp->status,
 				    temp_erp->refers);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
diff -u -p a/s390/block/dasd_eckd.c b/s390/block/dasd_eckd.c
--- a/s390/block/dasd_eckd.c
+++ b/s390/block/dasd_eckd.c
@@ -1014,6 +1014,11 @@ static int dasd_eckd_read_conf(struct da
 	lpm = 0x80;
 	conf_data_saved = 0;
 	/* get configuration data per operational path */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (lpm = 0x80; lpm; lpm>>= 1) {
 		if (lpm & opm) {
 			rc = dasd_eckd_read_conf_lpm(device, &conf_data,
@@ -1057,6 +1062,12 @@ static int dasd_eckd_read_conf(struct da
 			if (conf_data != private->conf_data)
 				kfree(conf_data);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return 0;
 }
@@ -1111,6 +1122,11 @@ static void do_path_verification_work(st
 	npm = 0;
 	ppm = 0;
 	epm = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (lpm = 0x80; lpm; lpm >>= 1) {
 		if (lpm & data->tbvpm) {
 			memset(data->rcd_buffer, 0, sizeof(data->rcd_buffer));
@@ -1152,6 +1168,12 @@ static void do_path_verification_work(st
 				ppm &= ~lpm;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * There is a small chance that a path is lost again between
diff -u -p a/s390/block/dasd_eer.c b/s390/block/dasd_eer.c
--- a/s390/block/dasd_eer.c
+++ b/s390/block/dasd_eer.c
@@ -319,10 +319,21 @@ static void dasd_eer_write_standard_trig
 	list_for_each_entry(eerb, &bufferlist, list) {
 		dasd_eer_start_record(eerb, header.total_size);
 		dasd_eer_write_buffer(eerb, (char *) &header, sizeof(header));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (temp_cqr = cqr; temp_cqr; temp_cqr = temp_cqr->refers) {
 			sense = dasd_get_sense(&temp_cqr->irb);
 			if (sense)
 				dasd_eer_write_buffer(eerb, sense, 32);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		dasd_eer_write_buffer(eerb, "EOR", 4);
 	}
diff -u -p a/s390/block/dasd.c b/s390/block/dasd.c
--- a/s390/block/dasd.c
+++ b/s390/block/dasd.c
@@ -2133,7 +2133,12 @@ static int _dasd_sleep_on(struct dasd_cc
 	maincqr->status = DASD_CQR_FILLED;
 	device = maincqr->startdev;
 	list_add(&maincqr->blocklist, &ccw_queue);
-	for (cqr = maincqr;  __dasd_sleep_on_loop_condition(cqr);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (cqr = maincqr;  __dasd_sleep_on_loop_condition(cqr);
 	     cqr = list_first_entry(&ccw_queue,
 				    struct dasd_ccw_req, blocklist)) {
 
@@ -2185,6 +2190,12 @@ static int _dasd_sleep_on(struct dasd_cc
 			}
 		} else
 			wait_event(generic_waitq, _wait_for_wakeup(cqr));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	maincqr->endclk = get_clock();
diff -u -p a/s390/net/ctcm_mpc.c b/s390/net/ctcm_mpc.c
--- a/s390/net/ctcm_mpc.c
+++ b/s390/net/ctcm_mpc.c
@@ -147,6 +147,11 @@ void ctcmpc_dumpit(char *buf, int len)
 	duphex[0] = 0x00;
 	dup = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ct = 0; ct < len; ct++, ptr++, rptr++) {
 		if (sw == 0) {
 			#if (UTS_MACHINE == s390x)
@@ -198,6 +203,12 @@ void ctcmpc_dumpit(char *buf, int len)
 
 		sw = 0;
 		rm = 16;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}  /* endfor */
 
 	if (sw != 0) {
diff -u -p a/s390/net/qeth_l3_main.c b/s390/net/qeth_l3_main.c
--- a/s390/net/qeth_l3_main.c
+++ b/s390/net/qeth_l3_main.c
@@ -1682,6 +1682,11 @@ static void qeth_l3_add_mc(struct qeth_c
 	char buf[MAX_ADDR_LEN];
 
 	QETH_CARD_TEXT(card, 4, "addmc");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (im4 = rcu_dereference(in4_dev->mc_list); im4 != NULL;
 	     im4 = rcu_dereference(im4->next_rcu)) {
 		qeth_l3_get_mac_for_ipm(im4->multiaddr, buf, in4_dev->dev);
@@ -1693,6 +1698,12 @@ static void qeth_l3_add_mc(struct qeth_c
 		ipm->is_multicast = 1;
 		if (!qeth_l3_add_ip(card, ipm))
 			kfree(ipm);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -1747,6 +1758,11 @@ static void qeth_l3_add_mc6(struct qeth_
 	char buf[MAX_ADDR_LEN];
 
 	QETH_CARD_TEXT(card, 4, "addmc6");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (im6 = in6_dev->mc_list; im6 != NULL; im6 = im6->next) {
 		ndisc_mc_map(&im6->mca_addr, buf, in6_dev->dev, 0);
 		ipm = qeth_l3_get_addr_buffer(QETH_PROT_IPV6);
@@ -1758,6 +1774,12 @@ static void qeth_l3_add_mc6(struct qeth_
 		       sizeof(struct in6_addr));
 		if (!qeth_l3_add_ip(card, ipm))
 			kfree(ipm);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1819,6 +1841,11 @@ static void qeth_l3_free_vlan_addresses4
 	in_dev = in_dev_get(netdev);
 	if (!in_dev)
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {
 		addr = qeth_l3_get_addr_buffer(QETH_PROT_IPV4);
 		if (addr) {
@@ -1828,6 +1855,12 @@ static void qeth_l3_free_vlan_addresses4
 			if (!qeth_l3_delete_ip(card, addr))
 				kfree(addr);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	in_dev_put(in_dev);
 }
diff -u -p a/s390/cio/device_pgid.c b/s390/cio/device_pgid.c
--- a/s390/cio/device_pgid.c
+++ b/s390/cio/device_pgid.c
@@ -244,6 +244,11 @@ static void pgid_analyze(struct ccw_devi
 	*mismatch = 0;
 	*reserved = 0;
 	*reset = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, lpm = 0x80; i < 8; i++, pgid++, lpm >>= 1) {
 		if ((cdev->private->pgid_valid_mask & lpm) == 0)
 			continue;
@@ -259,6 +264,12 @@ static void pgid_analyze(struct ccw_devi
 		}
 		if (pgid_cmp(pgid, first) != 0)
 			*mismatch = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!first)
 		first = &channel_subsystems[0]->global_pgid;
diff -u -p a/net/wireless/brcm80211/brcmsmac/dma.c b/net/wireless/brcm80211/brcmsmac/dma.c
--- a/net/wireless/brcm80211/brcmsmac/dma.c
+++ b/net/wireless/brcm80211/brcmsmac/dma.c
@@ -1251,6 +1251,11 @@ int dma_txfast(struct dma_pub *pub, stru
 	 * Walk the chain of packet buffers
 	 * allocating and initializing transmit descriptor entries.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = p0; p; p = next) {
 		data = p->data;
 		len = p->len;
@@ -1283,6 +1288,12 @@ int dma_txfast(struct dma_pub *pub, stru
 		dma64_dd_upd(di, di->txd64, pa, txout, &flags, len);
 
 		txout = nexttxd(di, txout);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if last txd eof not set, fix it */
@@ -1368,6 +1379,11 @@ struct sk_buff *dma_getnexttxp(struct dm
 	if ((start == 0) && (end > di->txout))
 		goto bogus;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i != end && !txp; i = nexttxd(di, i)) {
 		dma_addr_t pa;
 		uint size;
@@ -1385,6 +1401,12 @@ struct sk_buff *dma_getnexttxp(struct dm
 		di->txp[i] = NULL;
 
 		pci_unmap_single(di->pbus, pa, size, PCI_DMA_TODEVICE);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 
 	di->txin = i;
diff -u -p a/net/wireless/brcm80211/brcmsmac/mac80211_if.c b/net/wireless/brcm80211/brcmsmac/mac80211_if.c
--- a/net/wireless/brcm80211/brcmsmac/mac80211_if.c
+++ b/net/wireless/brcm80211/brcmsmac/mac80211_if.c
@@ -857,12 +857,23 @@ static void brcms_free(struct brcms_info
 		schedule();
 
 	/* free timers */
-	for (t = wl->timers; t; t = next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (t = wl->timers; t; t = next) {
 		next = t->next;
 #ifdef BCMDBG
 		kfree(t->name);
 #endif
 		kfree(t);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/*
diff -u -p a/net/wireless/brcm80211/brcmsmac/main.c b/net/wireless/brcm80211/brcmsmac/main.c
--- a/net/wireless/brcm80211/brcmsmac/main.c
+++ b/net/wireless/brcm80211/brcmsmac/main.c
@@ -3879,11 +3879,22 @@ static void brcms_c_txflowcontrol_reset(
 {
 	struct brcms_txq_info *qi;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qi = wlc->tx_queues; qi != NULL; qi = qi->next) {
 		if (qi->stopped) {
 			brcms_c_txflowcontrol_signal(wlc, qi, OFF, ALLPRIO);
 			qi->stopped = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c b/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c
--- a/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c
+++ b/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -223,6 +223,11 @@ brcmf_sdioh_request_packet(struct brcmf_
 
 	/* Claim host controller */
 	sdio_claim_host(sdiodev->func[func]);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pnext = pkt; pnext; pnext = pnext->next) {
 		uint pkt_len = pnext->len;
 		pkt_len += 3;
@@ -260,6 +265,12 @@ brcmf_sdioh_request_packet(struct brcmf_
 			addr += pkt_len;
 		SGCount++;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Release host controller */
diff -u -p a/net/wireless/prism54/isl_ioctl.c b/net/wireless/prism54/isl_ioctl.c
--- a/net/wireless/prism54/isl_ioctl.c
+++ b/net/wireless/prism54/isl_ioctl.c
@@ -1800,11 +1800,22 @@ prism54_clear_mac(struct islpci_acl *acl
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = acl->mac_list.next, next = ptr->next;
 	     ptr != &acl->mac_list; ptr = next, next = ptr->next) {
 		entry = list_entry(ptr, struct mac_entry, _list);
 		list_del(ptr);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	acl->size = 0;
 	mutex_unlock(&acl->lock);
diff -u -p a/net/wireless/iwlegacy/iwl-4965-tx.c b/net/wireless/iwlegacy/iwl-4965-tx.c
--- a/net/wireless/iwlegacy/iwl-4965-tx.c
+++ b/net/wireless/iwlegacy/iwl-4965-tx.c
@@ -1127,6 +1127,11 @@ int iwl4965_tx_queue_reclaim(struct iwl_
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = iwl_legacy_queue_inc_wrap(index, q->n_bd);
 	     q->read_ptr != index;
 	     q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd)) {
@@ -1145,6 +1150,12 @@ int iwl4965_tx_queue_reclaim(struct iwl_
 		tx_info->skb = NULL;
 
 		priv->cfg->ops->lib->txq_free_tfd(priv, txq);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return nfreed;
 }
diff -u -p a/net/wireless/iwlegacy/iwl-tx.c b/net/wireless/iwlegacy/iwl-tx.c
--- a/net/wireless/iwlegacy/iwl-tx.c
+++ b/net/wireless/iwlegacy/iwl-tx.c
@@ -576,6 +576,11 @@ static void iwl_legacy_hcmd_queue_reclai
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = iwl_legacy_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;
 	     q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd)) {
 
@@ -585,6 +590,12 @@ static void iwl_legacy_hcmd_queue_reclai
 			queue_work(priv->workqueue, &priv->restart);
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/iwlegacy/iwl-4965-rx.c b/net/wireless/iwlegacy/iwl-4965-rx.c
--- a/net/wireless/iwlegacy/iwl-4965-rx.c
+++ b/net/wireless/iwlegacy/iwl-4965-rx.c
@@ -131,6 +131,11 @@ static void iwl4965_accumulative_statist
 	delta = (u32 *)&priv->_4965.delta_statistics;
 	max_delta = (u32 *)&priv->_4965.max_delta;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = sizeof(__le32); i < size;
 	     i += sizeof(__le32), stats++, prev_stats++, delta++,
 	     max_delta++, accum_stats++) {
@@ -141,6 +146,12 @@ static void iwl4965_accumulative_statist
 			if (*delta > *max_delta)
 				*max_delta = *delta;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/* reset accumulative statistics for "no-counter" type statistics */
diff -u -p a/net/wireless/iwlegacy/iwl-3945.c b/net/wireless/iwlegacy/iwl-3945.c
--- a/net/wireless/iwlegacy/iwl-3945.c
+++ b/net/wireless/iwlegacy/iwl-3945.c
@@ -283,6 +283,11 @@ static void iwl3945_tx_queue_reclaim(str
 
 	BUG_ON(txq_id == IWL39_CMD_QUEUE_NUM);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = iwl_legacy_queue_inc_wrap(index, q->n_bd);
 		q->read_ptr != index;
 		q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd)) {
@@ -291,6 +296,12 @@ static void iwl3945_tx_queue_reclaim(str
 		ieee80211_tx_status_irqsafe(priv->hw, tx_info->skb);
 		tx_info->skb = NULL;
 		priv->cfg->ops->lib->txq_free_tfd(priv, txq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (iwl_legacy_queue_space(q) > q->low_mark && (txq_id >= 0) &&
@@ -376,6 +387,11 @@ static void iwl3945_accumulative_statist
 	delta = (u32 *)&priv->_3945.delta_statistics;
 	max_delta = (u32 *)&priv->_3945.max_delta;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = sizeof(__le32); i < sizeof(struct iwl3945_notif_statistics);
 	     i += sizeof(__le32), stats++, prev_stats++, delta++,
 	     max_delta++, accum_stats++) {
@@ -386,6 +402,12 @@ static void iwl3945_accumulative_statist
 			if (*delta > *max_delta)
 				*max_delta = *delta;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/* reset accumulative statistics for "no-counter" type statistics */
diff -u -p a/net/wireless/rtlwifi/rtl8192se/phy.c b/net/wireless/rtlwifi/rtl8192se/phy.c
--- a/net/wireless/rtlwifi/rtl8192se/phy.c
+++ b/net/wireless/rtlwifi/rtl8192se/phy.c
@@ -856,6 +856,11 @@ static bool _rtl92s_phy_config_bb(struct
 	phy_reg_table = rtl8192sephy_reg_2t2rarray;
 
 	if (configtype == BASEBAND_CONFIG_PHY_REG) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < phy_reg_len; i = i + 2) {
 			if (phy_reg_table[i] == 0xfe)
 				mdelay(50);
@@ -875,14 +880,31 @@ static bool _rtl92s_phy_config_bb(struct
 
 			rtl92s_phy_set_bb_reg(hw, phy_reg_table[i], MASKDWORD,
 					phy_reg_table[i + 1]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else if (configtype == BASEBAND_CONFIG_AGC_TAB) {
-		for (i = 0; i < agc_len; i = i + 2) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < agc_len; i = i + 2) {
 			rtl92s_phy_set_bb_reg(hw, agc_table[i], MASKDWORD,
 					agc_table[i + 1]);
 
 			/* Add delay for ECS T20 & LG malow platform */
 			udelay(1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -909,6 +931,11 @@ static bool _rtl92s_phy_set_bb_to_diff_r
 	}
 
 	if (configtype == BASEBAND_CONFIG_PHY_REG) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < phy_regarray2xtxr_len; i = i + 3) {
 			if (phy_regarray2xtxr_table[i] == 0xfe)
 				mdelay(50);
@@ -926,6 +953,12 @@ static bool _rtl92s_phy_set_bb_to_diff_r
 			rtl92s_phy_set_bb_reg(hw, phy_regarray2xtxr_table[i],
 				phy_regarray2xtxr_table[i + 1],
 				phy_regarray2xtxr_table[i + 2]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -943,6 +976,11 @@ static bool _rtl92s_phy_config_bb_with_p
 	phy_table_pg = rtl8192sephy_reg_array_pg;
 
 	if (configtype == BASEBAND_CONFIG_PHY_REG) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < phy_pg_len; i = i + 3) {
 			if (phy_table_pg[i] == 0xfe)
 				mdelay(50);
@@ -964,6 +1002,12 @@ static bool _rtl92s_phy_config_bb_with_p
 			rtl92s_phy_set_bb_reg(hw, phy_table_pg[i],
 					phy_table_pg[i + 1],
 					phy_table_pg[i + 2]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -1058,6 +1102,11 @@ u8 rtl92s_phy_config_rf(struct ieee80211
 
 	switch (rfpath) {
 	case RF90_PATH_A:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < radio_a_tblen; i = i + 2) {
 			if (radio_a_table[i] == 0xfe)
 				/* Delay specific ms. Only RF configuration
@@ -1081,12 +1130,23 @@ u8 rtl92s_phy_config_rf(struct ieee80211
 
 			/* Add delay for ECS T20 & LG malow platform */
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* PA Bias current for inferiority IC */
 		_rtl92s_phy_config_rfpa_bias_current(hw, rfpath);
 		break;
 	case RF90_PATH_B:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < radio_b_tblen; i = i + 2) {
 			if (radio_b_table[i] == 0xfe)
 				/* Delay specific ms. Only RF configuration
@@ -1110,6 +1170,12 @@ u8 rtl92s_phy_config_rf(struct ieee80211
 
 			/* Add delay for ECS T20 & LG malow platform */
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	case RF90_PATH_C:
diff -u -p a/net/wireless/rtlwifi/rtl8192de/phy.c b/net/wireless/rtlwifi/rtl8192de/phy.c
--- a/net/wireless/rtlwifi/rtl8192de/phy.c
+++ b/net/wireless/rtlwifi/rtl8192de/phy.c
@@ -581,6 +581,11 @@ static bool _rtl92d_phy_config_bb_with_h
 	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
 		 (" ===> phy:Rtl819XPHY_REG_Array_PG\n"));
 	if (configtype == BASEBAND_CONFIG_PHY_REG) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < phy_reg_arraylen; i = i + 2) {
 			if (phy_regarray_table[i] == 0xfe)
 				mdelay(50);
@@ -602,10 +607,21 @@ static bool _rtl92d_phy_config_bb_with_h
 				  " Rtl819XPHY_REGArray[1] is %x\n",
 				  phy_regarray_table[i],
 				  phy_regarray_table[i + 1]));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	} else if (configtype == BASEBAND_CONFIG_AGC_TAB) {
 		if (rtlhal->interfaceindex == 0) {
-			for (i = 0; i < agctab_arraylen; i = i + 2) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (i = 0; i < agctab_arraylen; i = i + 2) {
 				rtl_set_bbreg(hw, agctab_array_table[i],
 					BMASKDWORD,
 					agctab_array_table[i + 1]);
@@ -618,13 +634,24 @@ static bool _rtl92d_phy_config_bb_with_h
 					 "Rtl819XPHY_REGArray[1] is %ul\n",
 					 agctab_array_table[i],
 					 agctab_array_table[i + 1]));
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
 				 ("Normal Chip, MAC0, load "
 				 "Rtl819XAGCTAB_Array\n"));
 		} else {
 			if (rtlhal->current_bandtype == BAND_ON_2_4G) {
-				for (i = 0; i < agctab_arraylen; i = i + 2) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					for (i = 0; i < agctab_arraylen; i = i + 2) {
 					rtl_set_bbreg(hw, agctab_array_table[i],
 						BMASKDWORD,
 						agctab_array_table[i + 1]);
@@ -637,11 +664,22 @@ static bool _rtl92d_phy_config_bb_with_h
 						 "REGArray[1] is %ul\n",
 						 agctab_array_table[i],
 						 agctab_array_table[i + 1]));
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 				}
 				RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
 					 ("Load Rtl819XAGCTAB_2GArray\n"));
 			} else {
-				for (i = 0; i < agctab_5garraylen; i = i + 2) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+					for (i = 0; i < agctab_5garraylen; i = i + 2) {
 					rtl_set_bbreg(hw,
 						agctab_5garray_table[i],
 						BMASKDWORD,
@@ -655,6 +693,12 @@ static bool _rtl92d_phy_config_bb_with_h
 						 "REGArray[1] is %ul\n",
 						 agctab_5garray_table[i],
 						 agctab_5garray_table[i + 1]));
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 				}
 				RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
 					("Load Rtl819XAGCTAB_5GArray\n"));
@@ -829,6 +873,11 @@ static bool _rtl92d_phy_config_bb_with_p
 	phy_regarray_pg_len = PHY_REG_ARRAY_PG_LENGTH;
 	phy_regarray_table_pg = rtl8192de_phy_reg_array_pg;
 	if (configtype == BASEBAND_CONFIG_PHY_REG) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < phy_regarray_pg_len; i = i + 3) {
 			if (phy_regarray_table_pg[i] == 0xfe)
 				mdelay(50);
@@ -846,6 +895,12 @@ static bool _rtl92d_phy_config_bb_with_p
 				phy_regarray_table_pg[i],
 				phy_regarray_table_pg[i + 1],
 				phy_regarray_table_pg[i + 2]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		RT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,
@@ -969,6 +1024,11 @@ bool rtl92d_phy_config_rf_with_headerfil
 	}
 	switch (rfpath) {
 	case RF90_PATH_A:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < radioa_arraylen; i = i + 2) {
 			if (radioa_array_table[i] == 0xfe) {
 				mdelay(50);
@@ -991,9 +1051,20 @@ bool rtl92d_phy_config_rf_with_headerfil
 				/*  Add 1us delay between BB/RF register set. */
 				udelay(1);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	case RF90_PATH_B:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < radiob_arraylen; i = i + 2) {
 			if (radiob_array_table[i] == 0xfe) {
 				/* Delay specific ms. Only RF configuration
@@ -1018,6 +1089,12 @@ bool rtl92d_phy_config_rf_with_headerfil
 				/*  Add 1us delay between BB/RF register set. */
 				udelay(1);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	case RF90_PATH_C:
diff -u -p a/net/wireless/rtlwifi/rtl8192cu/phy.c b/net/wireless/rtlwifi/rtl8192cu/phy.c
--- a/net/wireless/rtlwifi/rtl8192cu/phy.c
+++ b/net/wireless/rtlwifi/rtl8192cu/phy.c
@@ -185,6 +185,11 @@ bool _rtl92cu_phy_config_bb_with_headerf
 		phy_regarray_table = rtlphy->hwparam_tables[PHY_REG_1T].pdata;
 	}
 	if (configtype == BASEBAND_CONFIG_PHY_REG) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < phy_reg_arraylen; i = i + 2) {
 			if (phy_regarray_table[i] == 0xfe)
 				mdelay(50);
@@ -206,9 +211,20 @@ bool _rtl92cu_phy_config_bb_with_headerf
 				  " Rtl819XPHY_REGArray[1] is %x\n",
 				  phy_regarray_table[i],
 				  phy_regarray_table[i + 1]));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	} else if (configtype == BASEBAND_CONFIG_AGC_TAB) {
-		for (i = 0; i < agctab_arraylen; i = i + 2) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < agctab_arraylen; i = i + 2) {
 			rtl_set_bbreg(hw, agctab_array_table[i], MASKDWORD,
 				      agctab_array_table[i + 1]);
 			udelay(1);
@@ -217,6 +233,12 @@ bool _rtl92cu_phy_config_bb_with_headerf
 				  "%x Rtl819XPHY_REGArray[1] is %x\n",
 				  agctab_array_table[i],
 				  agctab_array_table[i + 1]));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 	return true;
@@ -235,6 +257,11 @@ bool _rtl92cu_phy_config_bb_with_pgheade
 	phy_regarray_pg_len = rtlphy->hwparam_tables[PHY_REG_PG].length;
 	phy_regarray_table_pg = rtlphy->hwparam_tables[PHY_REG_PG].pdata;
 	if (configtype == BASEBAND_CONFIG_PHY_REG) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < phy_regarray_pg_len; i = i + 3) {
 			if (phy_regarray_table_pg[i] == 0xfe)
 				mdelay(50);
@@ -252,6 +279,12 @@ bool _rtl92cu_phy_config_bb_with_pgheade
 						  phy_regarray_table_pg[i],
 						  phy_regarray_table_pg[i + 1],
 						  phy_regarray_table_pg[i + 2]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		RT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,
@@ -293,6 +326,11 @@ bool rtl92cu_phy_config_rf_with_headerfi
 	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, ("Radio No %x\n", rfpath));
 	switch (rfpath) {
 	case RF90_PATH_A:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < radioa_arraylen; i = i + 2) {
 			if (radioa_array_table[i] == 0xfe)
 				mdelay(50);
@@ -312,9 +350,20 @@ bool rtl92cu_phy_config_rf_with_headerfi
 					      radioa_array_table[i + 1]);
 				udelay(1);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	case RF90_PATH_B:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < radiob_arraylen; i = i + 2) {
 			if (radiob_array_table[i] == 0xfe) {
 				mdelay(50);
@@ -334,6 +383,12 @@ bool rtl92cu_phy_config_rf_with_headerfi
 					      radiob_array_table[i + 1]);
 				udelay(1);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	case RF90_PATH_C:
diff -u -p a/net/wireless/rtlwifi/rtl8192ce/phy.c b/net/wireless/rtlwifi/rtl8192ce/phy.c
--- a/net/wireless/rtlwifi/rtl8192ce/phy.c
+++ b/net/wireless/rtlwifi/rtl8192ce/phy.c
@@ -198,6 +198,11 @@ bool _rtl92ce_phy_config_bb_with_headerf
 		phy_regarray_table = RTL8192CEPHY_REG_1TARRAY;
 	}
 	if (configtype == BASEBAND_CONFIG_PHY_REG) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < phy_reg_arraylen; i = i + 2) {
 			if (phy_regarray_table[i] == 0xfe)
 				mdelay(50);
@@ -219,9 +224,20 @@ bool _rtl92ce_phy_config_bb_with_headerf
 				  " Rtl819XPHY_REGArray[1] is %x\n",
 				  phy_regarray_table[i],
 				  phy_regarray_table[i + 1]));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	} else if (configtype == BASEBAND_CONFIG_AGC_TAB) {
-		for (i = 0; i < agctab_arraylen; i = i + 2) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < agctab_arraylen; i = i + 2) {
 			rtl_set_bbreg(hw, agctab_array_table[i], MASKDWORD,
 				      agctab_array_table[i + 1]);
 			udelay(1);
@@ -230,6 +246,12 @@ bool _rtl92ce_phy_config_bb_with_headerf
 				  "%x Rtl819XPHY_REGArray[1] is %x\n",
 				  agctab_array_table[i],
 				  agctab_array_table[i + 1]));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 	return true;
@@ -247,6 +269,11 @@ bool _rtl92ce_phy_config_bb_with_pgheade
 	phy_regarray_table_pg = RTL8192CEPHY_REG_ARRAY_PG;
 
 	if (configtype == BASEBAND_CONFIG_PHY_REG) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < phy_regarray_pg_len; i = i + 3) {
 			if (phy_regarray_table_pg[i] == 0xfe)
 				mdelay(50);
@@ -265,6 +292,12 @@ bool _rtl92ce_phy_config_bb_with_pgheade
 					       phy_regarray_table_pg[i],
 					       phy_regarray_table_pg[i + 1],
 					       phy_regarray_table_pg[i + 2]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 
@@ -307,6 +340,11 @@ bool rtl92c_phy_config_rf_with_headerfil
 	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, ("Radio No %x\n", rfpath));
 	switch (rfpath) {
 	case RF90_PATH_A:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < radioa_arraylen; i = i + 2) {
 			if (radioa_array_table[i] == 0xfe)
 				mdelay(50);
@@ -326,9 +364,20 @@ bool rtl92c_phy_config_rf_with_headerfil
 					      radioa_array_table[i + 1]);
 				udelay(1);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	case RF90_PATH_B:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < radiob_arraylen; i = i + 2) {
 			if (radiob_array_table[i] == 0xfe) {
 				mdelay(50);
@@ -348,6 +397,12 @@ bool rtl92c_phy_config_rf_with_headerfil
 					      radiob_array_table[i + 1]);
 				udelay(1);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	case RF90_PATH_C:
diff -u -p a/net/wireless/rtlwifi/efuse.c b/net/wireless/rtlwifi/efuse.c
--- a/net/wireless/rtlwifi/efuse.c
+++ b/net/wireless/rtlwifi/efuse.c
@@ -372,6 +372,11 @@ bool efuse_shadow_update_chk(struct ieee
 		Base = section_idx * 8;
 		wordchanged = false;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 8; i = i + 2) {
 			if ((rtlefuse->efuse_map[EFUSE_INIT_MAP][Base + i] !=
 			     rtlefuse->efuse_map[EFUSE_MODIFY_MAP][Base + i]) ||
@@ -381,6 +386,12 @@ bool efuse_shadow_update_chk(struct ieee
 				words_need++;
 				wordchanged = true;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (wordchanged)
diff -u -p a/net/wireless/iwlwifi/iwl-trans-pcie-tx.c b/net/wireless/iwlwifi/iwl-trans-pcie-tx.c
--- a/net/wireless/iwlwifi/iwl-trans-pcie-tx.c
+++ b/net/wireless/iwlwifi/iwl-trans-pcie-tx.c
@@ -923,6 +923,11 @@ static void iwl_hcmd_queue_reclaim(struc
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = iwl_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;
 	     q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd)) {
 
@@ -932,6 +937,12 @@ static void iwl_hcmd_queue_reclaim(struc
 			iwlagn_fw_error(priv(trans), false);
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/iwlwifi/iwl-agn-rx.c b/net/wireless/iwlwifi/iwl-agn-rx.c
--- a/net/wireless/iwlwifi/iwl-agn-rx.c
+++ b/net/wireless/iwlwifi/iwl-agn-rx.c
@@ -430,6 +430,11 @@ static void accum_stats(__le32 *prev, __
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0;
 	     i < size / sizeof(__le32);
 	     i++, prev++, cur++, delta++, max_delta++, accum++) {
@@ -440,6 +445,12 @@ static void accum_stats(__le32 *prev, __
 			if (le32_to_cpu(*delta) > le32_to_cpu(*max_delta))
 				*max_delta = *delta;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/ipw2x00/ipw2200.c b/net/wireless/ipw2x00/ipw2200.c
--- a/net/wireless/ipw2x00/ipw2200.c
+++ b/net/wireless/ipw2x00/ipw2200.c
@@ -1354,6 +1354,11 @@ static ssize_t show_cmd_log(struct devic
 	u32 len = 0, i;
 	if (!priv->cmdlog)
 		return 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = (priv->cmdlog_pos + 1) % priv->cmdlog_len;
 	     (i != priv->cmdlog_pos) && (PAGE_SIZE - len);
 	     i = (i + 1) % priv->cmdlog_len) {
@@ -1367,6 +1372,12 @@ static ssize_t show_cmd_log(struct devic
 				 (u8 *) priv->cmdlog[i].cmd.param,
 				 priv->cmdlog[i].cmd.len);
 		len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
 	return len;
diff -u -p a/net/wireless/wl12xx/event.c b/net/wireless/wl12xx/event.c
--- a/net/wireless/wl12xx/event.c
+++ b/net/wireless/wl12xx/event.c
@@ -343,6 +343,11 @@ static int wl1271_event_process(struct w
 		const u8 *addr;
 		int h;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (h = find_first_bit(&sta_bitmap, AP_MAX_LINKS);
 		     h < AP_MAX_LINKS;
 		     h = find_next_bit(&sta_bitmap, AP_MAX_LINKS, h+1)) {
@@ -358,6 +363,12 @@ static int wl1271_event_process(struct w
 				ieee80211_report_low_ack(sta, num_packets);
 			}
 			rcu_read_unlock();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/wireless/ath/ath5k/base.c b/net/wireless/ath/ath5k/base.c
--- a/net/wireless/ath/ath5k/base.c
+++ b/net/wireless/ath/ath5k/base.c
@@ -798,26 +798,59 @@ ath5k_desc_alloc(struct ath5k_hw *ah)
 	ah->bufptr = bf;
 
 	INIT_LIST_HEAD(&ah->rxbuf);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ATH_RXBUF; i++, bf++, ds++, da += sizeof(*ds)) {
 		bf->desc = ds;
 		bf->daddr = da;
 		list_add_tail(&bf->list, &ah->rxbuf);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	INIT_LIST_HEAD(&ah->txbuf);
 	ah->txbuf_len = ATH_TXBUF;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ATH_TXBUF; i++, bf++, ds++, da += sizeof(*ds)) {
 		bf->desc = ds;
 		bf->daddr = da;
 		list_add_tail(&bf->list, &ah->txbuf);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	/* beacon buffers */
 	INIT_LIST_HEAD(&ah->bcbuf);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ATH_BCBUF; i++, bf++, ds++, da += sizeof(*ds)) {
 		bf->desc = ds;
 		bf->daddr = da;
 		list_add_tail(&bf->list, &ah->bcbuf);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	return 0;
diff -u -p a/net/wireless/ath/ath5k/phy.c b/net/wireless/ath/ath5k/phy.c
--- a/net/wireless/ath/ath5k/phy.c
+++ b/net/wireless/ath/ath5k/phy.c
@@ -176,7 +176,12 @@ static unsigned int ath5k_hw_rfb_op(stru
 	if (set)
 		data = ath5k_hw_bitswap(val, num_bits);
 
-	for (bits_shifted = 0, bits_left = num_bits; bits_left > 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (bits_shifted = 0, bits_left = num_bits; bits_left > 0;
 	     position = 0, entry++) {
 
 		last_bit = (position + bits_left > 8) ? 8 :
@@ -196,6 +201,12 @@ static unsigned int ath5k_hw_rfb_op(stru
 		}
 
 		bits_left -= 8 - position;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	data = set ? 1 : ath5k_hw_bitswap(data, num_bits);
diff -u -p a/net/wireless/ath/ath9k/debug.c b/net/wireless/ath/ath9k/debug.c
--- a/net/wireless/ath/ath9k/debug.c
+++ b/net/wireless/ath/ath9k/debug.c
@@ -267,6 +267,11 @@ static ssize_t read_file_dma(struct file
 	len += snprintf(buf + len, DMA_BUF_LEN - len,
 			"Num QCU: chain_st fsp_ok fsp_st DCU: chain_st\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < ATH9K_NUM_QUEUES; i++, qcuOffset += 4, dcuOffset += 5) {
 		if (i == 8) {
 			qcuOffset = 0;
@@ -284,6 +289,12 @@ static ssize_t read_file_dma(struct file
 			(*qcuBase & (0x8 << qcuOffset)) >> (qcuOffset + 3),
 			val[2] & (0x7 << (i * 3)) >> (i * 3),
 			(*dcuBase & (0x1f << dcuOffset)) >> dcuOffset);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	len += snprintf(buf + len, DMA_BUF_LEN - len, "\n");
@@ -1442,7 +1453,12 @@ static int open_file_bb_mac_samps(struct
 		qcuBase = &ATH_SAMP_DBG(dma_dbg_reg_vals[0]);
 		dcuBase = &ATH_SAMP_DBG(dma_dbg_reg_vals[4]);
 
-		for (i = 0; i < ATH9K_NUM_QUEUES; i++,
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < ATH9K_NUM_QUEUES; i++,
 				qcuOffset += 4, dcuOffset += 5) {
 			if (i == 8) {
 				qcuOffset = 0;
@@ -1465,6 +1481,12 @@ static int open_file_bb_mac_samps(struct
 				ATH_SAMP_DBG(dma_dbg_reg_vals[2]) &
 				(0x7 << (i * 3)) >> (i * 3),
 				(*dcuBase & (0x1f << dcuOffset)) >> dcuOffset);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		len += snprintf(buf + len, size - len, "\n");
 	}
diff -u -p a/net/wireless/ath/ath9k/init.c b/net/wireless/ath/ath9k/init.c
--- a/net/wireless/ath/ath9k/init.c
+++ b/net/wireless/ath/ath9k/init.c
@@ -377,6 +377,11 @@ int ath_descdma_setup(struct ath_softc *
 	}
 	dd->dd_bufptr = bf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < nbuf; i++, bf++, ds += (desc_len * ndesc)) {
 		bf->bf_desc = ds;
 		bf->bf_daddr = DS2PHYS(dd, ds);
@@ -399,6 +404,12 @@ int ath_descdma_setup(struct ath_softc *
 			}
 		}
 		list_add_tail(&bf->list, head);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 fail2:
diff -u -p a/net/wireless/hostap/hostap_ap.c b/net/wireless/hostap/hostap_ap.c
--- a/net/wireless/hostap/hostap_ap.c
+++ b/net/wireless/hostap/hostap_ap.c
@@ -395,6 +395,11 @@ int ap_control_del_mac(struct mac_restri
 	struct mac_entry *entry;
 
 	spin_lock_bh(&mac_restrictions->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = mac_restrictions->mac_list.next;
 	     ptr != &mac_restrictions->mac_list; ptr = ptr->next) {
 		entry = list_entry(ptr, struct mac_entry, list);
@@ -406,6 +411,12 @@ int ap_control_del_mac(struct mac_restri
 			spin_unlock_bh(&mac_restrictions->lock);
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_bh(&mac_restrictions->lock);
 	return -1;
@@ -446,12 +457,23 @@ void ap_control_flush_macs(struct mac_re
 		return;
 
 	spin_lock_bh(&mac_restrictions->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = mac_restrictions->mac_list.next, n = ptr->next;
 	     ptr != &mac_restrictions->mac_list;
 	     ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct mac_entry, list);
 		list_del(ptr);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mac_restrictions->entries = 0;
 	spin_unlock_bh(&mac_restrictions->lock);
@@ -495,6 +517,11 @@ void ap_control_kickall(struct ap_data *
 	struct sta_info *sta;
 
 	spin_lock_bh(&ap->sta_table_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ap->sta_list.next, n = ptr->next; ptr != &ap->sta_list;
 	     ptr = n, n = ptr->next) {
 		sta = list_entry(ptr, struct sta_info, list);
@@ -503,6 +530,12 @@ void ap_control_kickall(struct ap_data *
 		if ((sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)
 			hostap_event_expired_sta(sta->local->dev, sta);
 		ap_free_sta(ap, sta);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_bh(&ap->sta_table_lock);
 }
@@ -2383,6 +2416,11 @@ int prism2_ap_translate_scan(struct net_
 
 	spin_lock_bh(&ap->sta_table_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ap->sta_list.next; ptr != NULL && ptr != &ap->sta_list;
 	     ptr = ptr->next) {
 		struct sta_info *sta = (struct sta_info *) ptr;
@@ -2470,6 +2508,12 @@ int prism2_ap_translate_scan(struct net_
 		sta->last_rx_updated = IW_QUAL_DBM;
 
 		/* To be continued, we should make good use of IWEVCUSTOM */
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock_bh(&ap->sta_table_lock);
diff -u -p a/net/can/sja1000/peak_pci.c b/net/can/sja1000/peak_pci.c
--- a/net/can/sja1000/peak_pci.c
+++ b/net/can/sja1000/peak_pci.c
@@ -217,12 +217,23 @@ failure_remove_channels:
 	/* Disable interrupts */
 	writew(0x0, cfg_base + PITA_ICR + 2);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = dev0; dev; dev = chan->next_dev) {
 		unregister_sja1000dev(dev);
 		free_sja1000dev(dev);
 		priv = netdev_priv(dev);
 		chan = priv->priv;
 		dev = chan->next_dev;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	pci_iounmap(pdev, reg_base);
diff -u -p a/net/can/at91_can.c b/net/can/at91_can.c
--- a/net/can/at91_can.c
+++ b/net/can/at91_can.c
@@ -707,6 +707,11 @@ static int at91_poll_rx(struct net_devic
 			"order of incoming frames cannot be guaranteed\n");
 
  again:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mb = find_next_bit(addr, get_mb_tx_first(priv), priv->rx_next);
 	     mb < get_mb_tx_first(priv) && quota > 0;
 	     reg_sr = at91_read(priv, AT91_SR),
@@ -723,6 +728,12 @@ static int at91_poll_rx(struct net_devic
 
 		received++;
 		quota--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* upper group completed, look again in lower */
diff -u -p a/net/can/c_can/c_can.c b/net/can/c_can/c_can.c
--- a/net/can/c_can/c_can.c
+++ b/net/can/c_can/c_can.c
@@ -750,7 +750,12 @@ static int c_can_do_rx_poll(struct net_d
 	struct c_can_priv *priv = netdev_priv(dev);
 	u32 val = c_can_read_reg32(priv, &priv->regs->intpnd1);
 
-	for (msg_obj = C_CAN_MSG_OBJ_RX_FIRST;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (msg_obj = C_CAN_MSG_OBJ_RX_FIRST;
 			msg_obj <= C_CAN_MSG_OBJ_RX_LAST && quota > 0;
 			val = c_can_read_reg32(priv, &priv->regs->intpnd1),
 			msg_obj++) {
@@ -795,6 +800,12 @@ static int c_can_do_rx_poll(struct net_d
 			num_rx_pkts++;
 			quota--;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return num_rx_pkts;
diff -u -p a/net/fddi/skfp/smttimer.c b/net/fddi/skfp/smttimer.c
--- a/net/fddi/skfp/smttimer.c
+++ b/net/fddi/skfp/smttimer.c
@@ -48,6 +48,11 @@ void smt_timer_stop(struct s_smc *smc, s
 	if (smc->t.st_queue == timer && !timer->tm_next) {
 		hwt_stop(smc) ;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = &smc->t.st_queue ; (tm = *prev) ; prev = &tm->tm_next ) {
 		if (tm == timer) {
 			*prev = tm->tm_next ;
@@ -56,6 +61,12 @@ void smt_timer_stop(struct s_smc *smc, s
 			}
 			return ;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -145,9 +156,20 @@ static void timer_done(struct s_smc *smc
 	next = smc->t.st_queue ;
 	smc->t.st_queue = tm ;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for ( tm = next ; tm ; tm = next) {
 		next = tm->tm_next ;
 		timer_event(smc,tm->tm_token) ;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (restart && smc->t.st_queue)
diff -u -p a/net/fddi/skfp/pcmplc.c b/net/fddi/skfp/pcmplc.c
--- a/net/fddi/skfp/pcmplc.c
+++ b/net/fddi/skfp/pcmplc.c
@@ -1872,6 +1872,11 @@ void pcm_get_state(struct s_smc *smc, st
 	short	tbits ;
 	struct fddi_mib_p	*mib ;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, phy = smc->y, pcs = state->pcm_state ; i < NUMPHYS ;
 		i++ , phy++, pcs++ ) {
 		mib = phy->mib ;
@@ -1893,6 +1898,12 @@ void pcm_get_state(struct s_smc *smc, st
 		}
 		pcs->pcm_r_val = rbits ;
 		pcs->pcm_t_val = tbits ;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
diff -u -p a/net/fddi/skfp/hwmtm.c b/net/fddi/skfp/hwmtm.c
--- a/net/fddi/skfp/hwmtm.c
+++ b/net/fddi/skfp/hwmtm.c
@@ -1163,9 +1163,20 @@ void process_receive(struct s_smc *smc)
 		 */
 		rxd->rxd_rbctrl &= cpu_to_le32(~BMU_STF) ;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (r=rxd, i=frag_count ; i ; r=r->rxd_next, i--){
 			DB_RX("dma_complete for RxD %x",(void *)r,0,5) ;
 			dma_complete(smc,(union s_fp_descr volatile *)r,DMA_WR);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		smc->hw.fp.err_stats.err_valid++ ;
 		smc->mib.m[MAC0].fddiMACCopied_Ct++ ;
@@ -1276,11 +1287,22 @@ void process_receive(struct s_smc *smc)
 #ifdef USE_OS_CPY
 			hwm_cpy_rxd2mb(rxd,data,len) ;
 #else
-			for (r=rxd, i=used_frags ; i ; r=r->rxd_next, i--){
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+unsigned long long _start = 0;
+unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (r=rxd, i=used_frags ; i ; r=r->rxd_next, i--){
 				n = le32_to_cpu(r->rxd_rbctrl) & RD_LENGTH ;
 				DB_RX("cp SMT frame to mb: len = %d",n,0,6) ;
 				memcpy(data,r->rxd_virt,n) ;
 				data += n ;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 			}
 			data = smtod(mb,char *) - 1 ;
 #endif
@@ -1501,9 +1523,20 @@ void mac_drv_clear_rx_queue(struct s_smc
 		DB_RX("STF bit found",0,0,5) ;
 		next_rxd = r ;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (r=queue->rx_curr_get,i=frag_count; i ; r=r->rxd_next,i--){
 			DB_RX("dma_complete for RxD %x",(void *)r,0,5) ;
 			dma_complete(smc,(union s_fp_descr volatile *)r,DMA_WR);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		DB_RX("mac_drv_clear_rxd: RxD %x frag_count %d ",
diff -u -p a/net/bonding/bond_3ad.c b/net/bonding/bond_3ad.c
--- a/net/bonding/bond_3ad.c
+++ b/net/bonding/bond_3ad.c
@@ -699,12 +699,23 @@ static void __set_agg_ports_ready(struct
 {
 	struct port *port;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (port = aggregator->lag_ports; port;
 	     port = port->next_port_in_aggregator) {
 		if (val)
 			port->sm_vars |= AD_PORT_READY;
 		else
 			port->sm_vars &= ~AD_PORT_READY;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1558,6 +1569,11 @@ static void ad_agg_selection_logic(struc
 			 best->lag_ports, best->slave,
 			 best->slave ? best->slave->dev->name : "NULL");
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (agg = __get_first_agg(best->lag_ports); agg;
 		     agg = __get_next_agg(agg)) {
 
@@ -1566,6 +1582,12 @@ static void ad_agg_selection_logic(struc
 				 agg->actor_oper_aggregator_key,
 				 agg->partner_oper_aggregator_key,
 				 agg->is_individual, agg->is_active);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 
 		// check if any partner replys
@@ -1585,9 +1607,20 @@ static void ad_agg_selection_logic(struc
 
 		// disable the ports that were related to the former active_aggregator
 		if (active) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (port = active->lag_ports; port;
 			     port = port->next_port_in_aggregator) {
 				__disable_port(port);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 			}
 		}
 	}
@@ -1600,9 +1633,20 @@ static void ad_agg_selection_logic(struc
 
 	if (active) {
 		if (!__agg_has_partner(active)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (port = active->lag_ports; port;
 			     port = port->next_port_in_aggregator) {
 				__enable_port(port);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 			}
 		}
 	}
@@ -2025,10 +2069,21 @@ void bond_3ad_unbind_slave(struct slave
 				new_aggregator->num_of_ports = aggregator->num_of_ports;
 
 				// update the information that is written on the ports about the aggregator
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (temp_port = aggregator->lag_ports; temp_port;
 				     temp_port = temp_port->next_port_in_aggregator) {
 					temp_port->aggregator = new_aggregator;
 					temp_port->actor_port_aggregator_identifier = new_aggregator->aggregator_identifier;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 				}
 
 				// clear the aggregator
@@ -2129,7 +2184,12 @@ void bond_3ad_state_machine_handler(stru
 	}
 
 	// for each port run the state machines
-	for (port = __get_first_port(bond); port; port = __get_next_port(port)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (port = __get_first_port(bond); port; port = __get_next_port(port)) {
 		if (!port->slave) {
 			pr_warning("%s: Warning: Found an uninitialized port\n",
 				   bond->dev->name);
@@ -2153,6 +2213,12 @@ void bond_3ad_state_machine_handler(stru
 			port->sm_vars &= ~AD_PORT_BEGIN;
 
 		__release_state_machine_lock(port);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 re_arm:
diff -u -p a/net/wan/pc300_drv.c b/net/wan/pc300_drv.c
--- a/net/wan/pc300_drv.c
+++ b/net/wan/pc300_drv.c
@@ -375,6 +375,11 @@ static void tx_dma_buf_check(pc300_t * c
 	printk("#CH%d: f_bd = %d(0x%08zx), n_bd = %d(0x%08zx)\n", ch,
 	       first_bd, TX_BD_ADDR(ch, first_bd),
 	       next_bd, TX_BD_ADDR(ch, next_bd));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = first_bd,
 	     ptdescr = (card->hw.rambase + TX_BD_ADDR(ch, first_bd));
 	     i != ((next_bd + 1) & (N_DMA_TX_BUF - 1));
@@ -384,6 +389,12 @@ static void tx_dma_buf_check(pc300_t * c
 		       ch, i, cpc_readl(&ptdescr->next),
 		       cpc_readl(&ptdescr->ptbuf),
 		       cpc_readb(&ptdescr->status), cpc_readw(&ptdescr->len));
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	printk("\n");
 }
diff -u -p a/net/wan/cycx_drv.c b/net/wan/cycx_drv.c
--- a/net/wan/cycx_drv.c
+++ b/net/wan/cycx_drv.c
@@ -550,14 +550,26 @@ static u16 checksum(u8 *buf, u32 len)
 	u16 crc = 0;
 	u16 mask, flag;
 
-	for (; len; --len, ++buf)
-		for (mask = 0x80; mask; mask >>= 1) {
-			flag = (crc & 0x8000);
-			crc <<= 1;
-			crc |= ((*buf & mask) ? 1 : 0);
+	for (; len; --len, ++buf) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (mask = 0x80; mask; mask >>= 1) {
+				flag = (crc & 0x8000);
+				crc <<= 1;
+				crc |= ((*buf & mask) ? 1 : 0);
 
-			if (flag)
-				crc ^= 0x1021;
+				if (flag)
+					crc ^= 0x1021;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 		}
 
 	return crc;
diff -u -p a/net/ethernet/sis/sis900.c b/net/ethernet/sis/sis900.c
--- a/net/ethernet/sis/sis900.c
+++ b/net/ethernet/sis/sis900.c
@@ -725,6 +725,11 @@ static u16 sis900_default_phy(struct net
 		*default_phy = NULL, *phy_lan = NULL;
 	u16 status;
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for (phy=sis_priv->first_mii; phy; phy=phy->next) {
 		status = mdio_read(net_dev, phy->phy_addr, MII_STATUS);
 		status = mdio_read(net_dev, phy->phy_addr, MII_STATUS);
@@ -742,6 +747,12 @@ static u16 sis900_default_phy(struct net
 			else if(phy->phy_types == LAN)
 				phy_lan = phy;
 		 }
+		 if (_cur < timeout) {
+				rdstcll(_cur);
+		 }
+		else {
+				break;
+		}
 	}
 
 	if (!default_phy && phy_home)
diff -u -p a/net/ethernet/i825xx/eexpress.c b/net/ethernet/i825xx/eexpress.c
--- a/net/ethernet/i825xx/eexpress.c
+++ b/net/ethernet/i825xx/eexpress.c
@@ -1192,6 +1192,11 @@ static unsigned short __init eexp_hw_rea
 	int i;
 
 	outb(EC_CS|i586_RST,ioaddr+EEPROM_Ctrl);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0x100 ; i ; i>>=1 )
 	{
 		if (cmd&i)
@@ -1204,9 +1209,20 @@ static unsigned short __init eexp_hw_rea
 		eeprom_delay();
 		outb(wval,ioaddr+EEPROM_Ctrl);
 		eeprom_delay();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	wval &= ~EC_Wr;
 	outb(wval,ioaddr+EEPROM_Ctrl);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0x8000 ; i ; i>>=1 )
 	{
 		outb(wval|EC_Clk,ioaddr+EEPROM_Ctrl);
@@ -1215,6 +1231,12 @@ static unsigned short __init eexp_hw_rea
 			rval |= i;
 		outb(wval,ioaddr+EEPROM_Ctrl);
 		eeprom_delay();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	wval &= ~EC_CS;
 	outb(wval|EC_Clk,ioaddr+EEPROM_Ctrl);
diff -u -p a/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c b/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c
--- a/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c
+++ b/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c
@@ -255,6 +255,11 @@ static s32 ixgbe_dcb_config_tc_stats_825
 	u8  j   = 0;
 
 	/* Receive Queues stats setting -  8 queues per statistics reg */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, j = 0; i < 15 && j < 8; i = i + 2, j++) {
 		reg = IXGBE_READ_REG(hw, IXGBE_RQSMR(i));
 		reg |= ((0x1010101) * j);
@@ -262,6 +267,12 @@ static s32 ixgbe_dcb_config_tc_stats_825
 		reg = IXGBE_READ_REG(hw, IXGBE_RQSMR(i + 1));
 		reg |= ((0x1010101) * j);
 		IXGBE_WRITE_REG(hw, IXGBE_RQSMR(i + 1), reg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Transmit Queues stats setting -  4 queues per statistics reg */
 	for (i = 0; i < 8; i++) {
diff -u -p a/net/ethernet/intel/ixgbe/ixgbe_main.c b/net/ethernet/intel/ixgbe/ixgbe_main.c
--- a/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -4553,9 +4553,20 @@ static inline bool ixgbe_cache_ring_fcoe
 		fcoe_rx_i = f->mask;
 		fcoe_tx_i = f->mask;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < f->indices; i++, fcoe_rx_i++, fcoe_tx_i++) {
 		adapter->rx_ring[f->mask + i]->reg_idx = fcoe_rx_i;
 		adapter->tx_ring[f->mask + i]->reg_idx = fcoe_tx_i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return true;
 }
diff -u -p a/net/ethernet/intel/e100.c b/net/ethernet/intel/e100.c
--- a/net/ethernet/intel/e100.c
+++ b/net/ethernet/intel/e100.c
@@ -1778,6 +1778,11 @@ static int e100_tx_clean(struct nic *nic
 	spin_lock(&nic->cb_lock);
 
 	/* Clean CBs marked complete */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cb = nic->cb_to_clean;
 	    cb->status & cpu_to_le16(cb_complete);
 	    cb = nic->cb_to_clean = cb->next) {
@@ -1801,6 +1806,12 @@ static int e100_tx_clean(struct nic *nic
 		}
 		cb->status = 0;
 		nic->cbs_avail++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock(&nic->cb_lock);
diff -u -p a/net/ethernet/sun/sunhme.c b/net/ethernet/sun/sunhme.c
--- a/net/ethernet/sun/sunhme.c
+++ b/net/ethernet/sun/sunhme.c
@@ -2536,6 +2536,11 @@ static int __init quattro_sbus_register_
 {
 	struct quattro *qp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qp = qfe_sbus_list; qp != NULL; qp = qp->next) {
 		struct platform_device *op = qp->quattro_dev;
 		int err, qfe_slot, skip = 0;
@@ -2556,6 +2561,12 @@ static int __init quattro_sbus_register_
 			       "error %d.\n", err);
 			return err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -2565,6 +2576,11 @@ static void quattro_sbus_free_irqs(void)
 {
 	struct quattro *qp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qp = qfe_sbus_list; qp != NULL; qp = qp->next) {
 		struct platform_device *op = qp->quattro_dev;
 		int qfe_slot, skip = 0;
@@ -2577,6 +2593,12 @@ static void quattro_sbus_free_irqs(void)
 			continue;
 
 		free_irq(op->archdata.irqs[0], qp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 #endif /* CONFIG_SBUS */
@@ -2588,11 +2610,22 @@ static struct quattro * __devinit quattr
 	struct quattro *qp;
 
 	if (!bdev) return NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qp = qfe_pci_list; qp != NULL; qp = qp->next) {
 		struct pci_dev *qpdev = qp->quattro_dev;
 
 		if (qpdev == bdev)
 			return qp;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	qp = kmalloc(sizeof(struct quattro), GFP_KERNEL);
 	if (qp != NULL) {
diff -u -p a/net/ethernet/sun/sunvnet.c b/net/ethernet/sun/sunvnet.c
--- a/net/ethernet/sun/sunvnet.c
+++ b/net/ethernet/sun/sunvnet.c
@@ -751,9 +751,20 @@ static struct vnet_mcast_entry *__vnet_m
 {
 	struct vnet_mcast_entry *m;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = vp->mcast_list; m; m = m->next) {
 		if (!memcmp(m->addr, addr, ETH_ALEN))
 			return m;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NULL;
 }
@@ -799,7 +810,12 @@ static void __send_mc_list(struct vnet *
 	info.set = 1;
 
 	n_addrs = 0;
-	for (m = vp->mcast_list; m; m = m->next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (m = vp->mcast_list; m; m = m->next) {
 		if (m->sent)
 			continue;
 		m->sent = 1;
@@ -812,6 +828,12 @@ static void __send_mc_list(struct vnet *
 					    sizeof(info));
 			n_addrs = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (n_addrs) {
 		info.count = n_addrs;
diff -u -p a/net/ethernet/ti/tlan.c b/net/ethernet/ti/tlan.c
--- a/net/ethernet/ti/tlan.c
+++ b/net/ethernet/ti/tlan.c
@@ -2862,11 +2862,22 @@ tlan_mii_read_reg(struct net_device *dev
 		tmp = 0xffff;
 		err = true;
 	} else {					/* ACK, so read data */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (tmp = 0, i = 0x8000; i; i >>= 1) {
 			tlan_clear_bit(TLAN_NET_SIO_MCLK, sio);
 			if (tlan_get_bit(TLAN_NET_SIO_MDATA, sio))
 				tmp |= i;
 			tlan_set_bit(TLAN_NET_SIO_MCLK, sio);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -2919,6 +2930,11 @@ static void tlan_mii_send_data(u16 base_
 	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
 	tlan_set_bit(TLAN_NET_SIO_MTXEN, sio);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = (0x1 << (num_bits - 1)); i; i >>= 1) {
 		tlan_clear_bit(TLAN_NET_SIO_MCLK, sio);
 		(void) tlan_get_bit(TLAN_NET_SIO_MCLK, sio);
@@ -2928,6 +2944,12 @@ static void tlan_mii_send_data(u16 base_
 			tlan_clear_bit(TLAN_NET_SIO_MDATA, sio);
 		tlan_set_bit(TLAN_NET_SIO_MCLK, sio);
 		(void) tlan_get_bit(TLAN_NET_SIO_MCLK, sio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -3109,13 +3131,24 @@ static int tlan_ee_send_byte(u16 io_base
 	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
 
 	/* Assume clock is low, tx is enabled; */
-	for (place = 0x80; place != 0; place >>= 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (place = 0x80; place != 0; place >>= 1) {
 		if (place & data)
 			tlan_set_bit(TLAN_NET_SIO_EDATA, sio);
 		else
 			tlan_clear_bit(TLAN_NET_SIO_EDATA, sio);
 		tlan_set_bit(TLAN_NET_SIO_ECLOK, sio);
 		tlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	tlan_clear_bit(TLAN_NET_SIO_ETXEN, sio);
 	tlan_set_bit(TLAN_NET_SIO_ECLOK, sio);
@@ -3172,11 +3205,22 @@ static void tlan_ee_receive_byte(u16 io_
 
 	/* Assume clock is low, tx is enabled; */
 	tlan_clear_bit(TLAN_NET_SIO_ETXEN, sio);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (place = 0x80; place; place >>= 1) {
 		tlan_set_bit(TLAN_NET_SIO_ECLOK, sio);
 		if (tlan_get_bit(TLAN_NET_SIO_EDATA, sio))
 			*data |= place;
 		tlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tlan_set_bit(TLAN_NET_SIO_ETXEN, sio);
diff -u -p a/net/ethernet/marvell/skge.c b/net/ethernet/marvell/skge.c
--- a/net/ethernet/marvell/skge.c
+++ b/net/ethernet/marvell/skge.c
@@ -915,6 +915,11 @@ static int skge_ring_alloc(struct skge_r
 	if (!ring->start)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, e = ring->start, d = vaddr; i < ring->count; i++, e++, d++) {
 		e->desc = d;
 		if (i == ring->count - 1) {
@@ -924,6 +929,12 @@ static int skge_ring_alloc(struct skge_r
 			e->next = e + 1;
 			d->next_offset = base + (i+1) * sizeof(*d);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ring->to_use = ring->to_clean = ring->start;
 
@@ -2845,10 +2856,21 @@ static void skge_tx_clean(struct net_dev
 	struct skge_port *skge = netdev_priv(dev);
 	struct skge_element *e;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (e = skge->tx_ring.to_clean; e != skge->tx_ring.to_use; e = e->next) {
 		struct skge_tx_desc *td = e->desc;
 		skge_tx_free(skge, e, td->control);
 		td->control = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	skge->tx_ring.to_clean = e;
@@ -3652,11 +3674,22 @@ static int skge_debug_show(struct seq_fi
 		   skge_read32(hw, B0_IMSK));
 
 	seq_printf(seq, "Tx Ring: (%d)\n", skge_avail(&skge->tx_ring));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (e = skge->tx_ring.to_clean; e != skge->tx_ring.to_use; e = e->next) {
 		const struct skge_tx_desc *t = e->desc;
 		seq_printf(seq, "%#x dma=%#x%08x %#x csum=%#x/%x/%x\n",
 			   t->control, t->dma_hi, t->dma_lo, t->status,
 			   t->csum_offs, t->csum_write, t->csum_start);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	seq_printf(seq, "\nRx Ring:\n");
diff -u -p a/net/ethernet/marvell/sky2.c b/net/ethernet/marvell/sky2.c
--- a/net/ethernet/marvell/sky2.c
+++ b/net/ethernet/marvell/sky2.c
@@ -1988,11 +1988,22 @@ static netdev_tx_t sky2_xmit_frame(struc
 	return NETDEV_TX_OK;
 
 mapping_unwind:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = sky2->tx_prod; i != slot; i = RING_NEXT(i, sky2->tx_ring_size)) {
 		re = sky2->tx_ring + i;
 
 		sky2_tx_unmap(hw->pdev, re);
-	}
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+		}
 
 mapping_error:
 	if (net_ratelimit())
@@ -2018,6 +2029,11 @@ static void sky2_tx_complete(struct sky2
 
 	BUG_ON(done >= sky2->tx_ring_size);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = sky2->tx_cons; idx != done;
 	     idx = RING_NEXT(idx, sky2->tx_ring_size)) {
 		struct tx_ring_info *re = sky2->tx_ring + idx;
@@ -2039,6 +2055,12 @@ static void sky2_tx_complete(struct sky2
 
 			sky2->tx_next = RING_NEXT(idx, sky2->tx_ring_size);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sky2->tx_cons = idx;
@@ -4520,11 +4542,22 @@ static int sky2_debug_show(struct seq_fi
 		seq_puts(seq, "Status ring (empty)\n");
 	else {
 		seq_puts(seq, "Status ring\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (idx = hw->st_idx; idx != last && idx < hw->st_size;
 		     idx = RING_NEXT(idx, hw->st_size)) {
 			const struct sky2_status_le *le = hw->st_le + idx;
 			seq_printf(seq, "[%d] %#x %d %#x\n",
 				   idx, le->opcode, le->length, le->status);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		seq_puts(seq, "\n");
 	}
@@ -4536,6 +4569,11 @@ static int sky2_debug_show(struct seq_fi
 
 	/* Dump contents of tx ring */
 	sop = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = sky2->tx_next; idx != sky2->tx_prod && idx < sky2->tx_ring_size;
 	     idx = RING_NEXT(idx, sky2->tx_ring_size)) {
 		const struct sky2_tx_le *le = sky2->tx_le + idx;
@@ -4576,6 +4614,12 @@ static int sky2_debug_show(struct seq_fi
 			seq_putc(seq, '\n');
 			sop = 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	seq_printf(seq, "\nRx ring hw get=%d put=%d last=%d\n",
diff -u -p a/net/ethernet/emulex/benet/be_main.c b/net/ethernet/emulex/benet/be_main.c
--- a/net/ethernet/emulex/benet/be_main.c
+++ b/net/ethernet/emulex/benet/be_main.c
@@ -2013,17 +2013,39 @@ void be_detect_dump_ue(struct be_adapter
 	}
 
 	if (ue_lo) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; ue_lo; ue_lo >>= 1, i++) {
 			if (ue_lo & 1)
 				dev_err(&adapter->pdev->dev,
 				"UE: %s bit set\n", ue_status_low_desc[i]);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 	if (ue_hi) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; ue_hi; ue_hi >>= 1, i++) {
 			if (ue_hi & 1)
 				dev_err(&adapter->pdev->dev,
 				"UE: %s bit set\n", ue_status_hi_desc[i]);
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
+		break;
+				}
 		}
 	}
 
diff -u -p a/net/ethernet/toshiba/ps3_gelic_wireless.c b/net/ethernet/toshiba/ps3_gelic_wireless.c
--- a/net/ethernet/toshiba/ps3_gelic_wireless.c
+++ b/net/ethernet/toshiba/ps3_gelic_wireless.c
@@ -1569,6 +1569,11 @@ static void gelic_wl_scan_complete_event
 	}
 
 	/* put them in the network_list */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, scan_info_size = 0, scan_info = buf;
 	     scan_info_size < data_len;
 	     i++, scan_info_size += be16_to_cpu(scan_info->size),
@@ -1641,6 +1646,12 @@ static void gelic_wl_scan_complete_event
 			if (scan_info->ext_rate[r])
 				target->rate_ext_len++;
 		list_move_tail(&target->list, &wl->network_list);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	memset(&data, 0, sizeof(data));
 	wireless_send_event(port_to_netdev(wl_port(wl)), SIOCGIWSCAN, &data,
diff -u -p a/net/ethernet/toshiba/spider_net.c b/net/ethernet/toshiba/spider_net.c
--- a/net/ethernet/toshiba/spider_net.c
+++ b/net/ethernet/toshiba/spider_net.c
@@ -361,6 +361,11 @@ spider_net_init_chain(struct spider_net_
 	descr = chain->ring;
 	hwdescr = chain->hwring;
 	buf = chain->dma_addr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=0; i < chain->num_desc; i++, descr++, hwdescr++) {
 		hwdescr->dmac_cmd_status = SPIDER_NET_DESCR_NOT_IN_USE;
 		hwdescr->next_descr_addr = 0;
@@ -371,6 +376,12 @@ spider_net_init_chain(struct spider_net_
 		descr->prev = descr - 1;
 
 		buf += sizeof(struct spider_net_hw_descr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* do actual circular list */
 	(descr-1)->next = chain->ring;
diff -u -p a/net/ethernet/toshiba/ps3_gelic_net.c b/net/ethernet/toshiba/ps3_gelic_net.c
--- a/net/ethernet/toshiba/ps3_gelic_net.c
+++ b/net/ethernet/toshiba/ps3_gelic_net.c
@@ -215,10 +215,21 @@ static void gelic_card_free_chain(struct
 {
 	struct gelic_descr *descr;
 
-	for (descr = descr_in; descr && descr->bus_addr; descr = descr->next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (descr = descr_in; descr && descr->bus_addr; descr = descr->next) {
 		dma_unmap_single(ctodev(card), descr->bus_addr,
 				 GELIC_DESCR_SIZE, DMA_BIDIRECTIONAL);
 		descr->bus_addr = 0;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -497,6 +508,11 @@ static void gelic_card_release_tx_chain(
 	struct net_device *netdev;
 	int release = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tx_chain = &card->tx_chain;
 	     tx_chain->head != tx_chain->tail && tx_chain->tail;
 	     tx_chain->tail = tx_chain->tail->next) {
@@ -531,7 +547,13 @@ static void gelic_card_release_tx_chain(
 		}
 		gelic_descr_release_tx(card, tx_chain->tail);
 		release ++;
-	}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+		}
 out:
 	if (!stop && release)
 		gelic_card_wake_queues(card);
diff -u -p a/net/ethernet/amd/sunlance.c b/net/ethernet/amd/sunlance.c
--- a/net/ethernet/amd/sunlance.c
+++ b/net/ethernet/amd/sunlance.c
@@ -515,6 +515,11 @@ static void lance_rx_dvma(struct net_dev
 	int len, entry = lp->rx_new;
 	struct sk_buff *skb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = &ib->brx_ring [entry];
 	     !((bits = rd->rmd1_bits) & LE_R1_OWN);
 	     rd = &ib->brx_ring [entry]) {
@@ -562,6 +567,12 @@ static void lance_rx_dvma(struct net_dev
 		rd->mblength = 0;
 		rd->rmd1_bits = LE_R1_OWN;
 		entry = RX_NEXT(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lp->rx_new = entry;
@@ -687,6 +698,11 @@ static void lance_rx_pio(struct net_devi
 	struct sk_buff *skb;
 
 	entry = lp->rx_new;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = &ib->brx_ring [entry];
 	     !((bits = sbus_readb(&rd->rmd1_bits)) & LE_R1_OWN);
 	     rd = &ib->brx_ring [entry]) {
@@ -732,6 +748,12 @@ static void lance_rx_pio(struct net_devi
 		sbus_writew(0, &rd->mblength);
 		sbus_writeb(LE_R1_OWN, &rd->rmd1_bits);
 		entry = RX_NEXT(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lp->rx_new = entry;
diff -u -p a/net/ethernet/amd/depca.c b/net/ethernet/amd/depca.c
--- a/net/ethernet/amd/depca.c
+++ b/net/ethernet/amd/depca.c
@@ -1022,6 +1022,11 @@ static int depca_rx(struct net_device *d
 	int i, entry;
 	s32 status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (entry = lp->rx_new; !(readl(&lp->rx_ring[entry].base) & R_OWN); entry = lp->rx_new) {
 		status = readl(&lp->rx_ring[entry].base) >> 16;
 		if (status & R_STP) {	/* Remember start of frame */
@@ -1104,6 +1109,12 @@ static int depca_rx(struct net_device *d
 		   ** Update entry information
 		 */
 		lp->rx_new = (lp->rx_new + 1) & lp->rxRingMask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1120,6 +1131,11 @@ static int depca_tx(struct net_device *d
 	s32 status;
 	u_long ioaddr = dev->base_addr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (entry = lp->tx_old; entry != lp->tx_new; entry = lp->tx_old) {
 		status = readl(&lp->tx_ring[entry].base) >> 16;
 
@@ -1149,6 +1165,12 @@ static int depca_tx(struct net_device *d
 
 		/* Update all the pointers */
 		lp->tx_old = (lp->tx_old + 1) & lp->txRingMask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1804,12 +1826,23 @@ static int load_packet(struct net_device
 
 		/* set up the buffer descriptors */
 		len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = entry; i != end; i = (i+1) & lp->txRingMask) {
 			/* clean out flags */
 			writel(readl(&lp->tx_ring[i].base) & ~T_FLAGS, &lp->tx_ring[i].base);
 			writew(0x0000, &lp->tx_ring[i].misc);	/* clears other error flags */
 			writew(-TX_BUFF_SZ, &lp->tx_ring[i].length);	/* packet length in buffer */
 			len -= TX_BUFF_SZ;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* clean out flags */
 		writel(readl(&lp->tx_ring[end].base) & ~T_FLAGS, &lp->tx_ring[end].base);
diff -u -p a/net/ethernet/amd/a2065.c b/net/ethernet/amd/a2065.c
--- a/net/ethernet/amd/a2065.c
+++ b/net/ethernet/amd/a2065.c
@@ -265,6 +265,11 @@ static int lance_rx(struct net_device *d
 #endif
 
 	ll->rdp = LE_C0_RINT | LE_C0_INEA;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = &ib->brx_ring[lp->rx_new];
 	     !((bits = rd->rmd1_bits) & LE_R1_OWN);
 	     rd = &ib->brx_ring[lp->rx_new]) {
@@ -316,6 +321,12 @@ static int lance_rx(struct net_device *d
 		rd->mblength = 0;
 		rd->rmd1_bits = LE_R1_OWN;
 		lp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/amd/7990.c b/net/ethernet/amd/7990.c
--- a/net/ethernet/amd/7990.c
+++ b/net/ethernet/amd/7990.c
@@ -296,6 +296,11 @@ static int lance_rx (struct net_device *
 	blinken_leds(0x40, 0);
 #endif
         WRITERDP(lp, LE_C0_RINT | LE_C0_INEA);     /* ack Rx int, reenable ints */
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for (rd = &ib->brx_ring [lp->rx_new];     /* For each Rx ring we own... */
              !((bits = rd->rmd1_bits) & LE_R1_OWN);
              rd = &ib->brx_ring [lp->rx_new]) {
@@ -343,6 +348,12 @@ static int lance_rx (struct net_device *
                 rd->mblength = 0;
                 rd->rmd1_bits = LE_R1_OWN;
                 lp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;
+                if (_cur < timeout) {
+			rdstcll(_cur);
+                }
+                else {
+			break;
+                }
         }
         return 0;
 }
diff -u -p a/net/ethernet/amd/declance.c b/net/ethernet/amd/declance.c
--- a/net/ethernet/amd/declance.c
+++ b/net/ethernet/amd/declance.c
@@ -580,6 +580,11 @@ static int lance_rx(struct net_device *d
 	}
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = lib_ptr(ib, brx_ring[lp->rx_new], lp->type);
 	     !((bits = *rds_ptr(rd, rmd1, lp->type)) & LE_R1_OWN);
 	     rd = lib_ptr(ib, brx_ring[lp->rx_new], lp->type)) {
@@ -637,6 +642,12 @@ static int lance_rx(struct net_device *d
 		*rds_ptr(rd, rmd1, lp->type) =
 			((lp->rx_buf_ptr_lnc[entry] >> 16) & 0xff) | LE_R1_OWN;
 		lp->rx_new = (entry + 1) & RX_RING_MOD_MASK;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/sgi/ioc3-eth.c b/net/ethernet/sgi/ioc3-eth.c
--- a/net/ethernet/sgi/ioc3-eth.c
+++ b/net/ethernet/sgi/ioc3-eth.c
@@ -841,11 +841,22 @@ static inline void ioc3_clean_rx_ring(st
 	ip->rx_pi &= 511;
 	ip->rx_ci &= 511;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ip->rx_ci; i != ip->rx_pi; i = (i+1) & 511) {
 		struct ioc3_erxbuf *rxb;
 		skb = ip->rx_skbs[i];
 		rxb = (struct ioc3_erxbuf *) (skb->data - RX_OFFSET);
 		rxb->w0 = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/net/ethernet/broadcom/bnx2x/bnx2x_main.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@ -936,31 +936,64 @@ void bnx2x_panic_dump(struct bnx2x *bp)
 
 		start = RX_BD(le16_to_cpu(*fp->rx_cons_sb) - 10);
 		end = RX_BD(le16_to_cpu(*fp->rx_cons_sb) + 503);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = start; j != end; j = RX_BD(j + 1)) {
 			u32 *rx_bd = (u32 *)&fp->rx_desc_ring[j];
 			struct sw_rx_bd *sw_bd = &fp->rx_buf_ring[j];
 
 			BNX2X_ERR("fp%d: rx_bd[%x]=[%x:%x]  sw_bd=[%p]\n",
 				  i, j, rx_bd[1], rx_bd[0], sw_bd->skb);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		start = RX_SGE(fp->rx_sge_prod);
 		end = RX_SGE(fp->last_max_sge);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = start; j != end; j = RX_SGE(j + 1)) {
 			u32 *rx_sge = (u32 *)&fp->rx_sge_ring[j];
 			struct sw_rx_page *sw_page = &fp->rx_page_ring[j];
 
 			BNX2X_ERR("fp%d: rx_sge[%x]=[%x:%x]  sw_page=[%p]\n",
 				  i, j, rx_sge[1], rx_sge[0], sw_page->page);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		start = RCQ_BD(fp->rx_comp_cons - 10);
 		end = RCQ_BD(fp->rx_comp_cons + 503);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = start; j != end; j = RCQ_BD(j + 1)) {
 			u32 *cqe = (u32 *)&fp->rx_comp_ring[j];
 
 			BNX2X_ERR("fp%d: cqe[%x]=[%x:%x:%x:%x]\n",
 				  i, j, cqe[0], cqe[1], cqe[2], cqe[3]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -972,7 +1005,12 @@ void bnx2x_panic_dump(struct bnx2x *bp)
 
 			start = TX_BD(le16_to_cpu(*txdata->tx_cons_sb) - 10);
 			end = TX_BD(le16_to_cpu(*txdata->tx_cons_sb) + 245);
-			for (j = start; j != end; j = TX_BD(j + 1)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (j = start; j != end; j = TX_BD(j + 1)) {
 				struct sw_tx_bd *sw_bd =
 					&txdata->tx_buf_ring[j];
 
@@ -980,10 +1018,21 @@ void bnx2x_panic_dump(struct bnx2x *bp)
 					  "packet[%x]=[%p,%x]\n",
 					  i, cos, j, sw_bd->skb,
 					  sw_bd->first_bd);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			start = TX_BD(txdata->tx_bd_cons - 10);
 			end = TX_BD(txdata->tx_bd_cons + 254);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = start; j != end; j = TX_BD(j + 1)) {
 				u32 *tx_bd = (u32 *)&txdata->tx_desc_ring[j];
 
@@ -991,6 +1040,12 @@ void bnx2x_panic_dump(struct bnx2x *bp)
 					  "[%x:%x:%x:%x]\n",
 					  i, cos, j, tx_bd[0], tx_bd[1],
 					  tx_bd[2], tx_bd[3]);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_sp.c b/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
@@ -3013,11 +3013,22 @@ static inline void bnx2x_mcast_hdl_resto
 {
 	int bit;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit = bnx2x_mcast_get_next_bin(o, 0);
 	     bit >= 0;
 	     bit = bnx2x_mcast_get_next_bin(o, bit + 1)) {
 		BNX2X_57711_SET_MC_FILTER(mc_filter, bit);
 		DP(BNX2X_MSG_SP, "About to set bin %d\n", bit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/broadcom/bnx2.c b/net/ethernet/broadcom/bnx2.c
--- a/net/ethernet/broadcom/bnx2.c
+++ b/net/ethernet/broadcom/bnx2.c
@@ -8089,11 +8089,22 @@ bnx2_init_board(struct pci_dev *pdev, st
 			bp->fw_version[j++] = ' ';
 		}
 		num = (u8) (reg >> (24 - (i * 8)));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (k = 100, skip0 = 1; k >= 1; num %= k, k /= 10) {
 			if (num >= k || !skip0 || k == 1) {
 				bp->fw_version[j++] = (num / k) + '0';
 				skip0 = 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (i != 2)
 			bp->fw_version[j++] = '.';
diff -u -p a/net/ethernet/broadcom/b44.c b/net/ethernet/broadcom/b44.c
--- a/net/ethernet/broadcom/b44.c
+++ b/net/ethernet/broadcom/b44.c
@@ -597,6 +597,11 @@ static void b44_tx(struct b44 *bp)
 	cur /= sizeof(struct dma_desc);
 
 	/* XXX needs updating when NETIF_F_SG is supported */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cons = bp->tx_cons; cons != cur; cons = NEXT_TX(cons)) {
 		struct ring_info *rp = &bp->tx_buffers[cons];
 		struct sk_buff *skb = rp->skb;
@@ -609,6 +614,12 @@ static void b44_tx(struct b44 *bp)
 				 DMA_TO_DEVICE);
 		rp->skb = NULL;
 		dev_kfree_skb_irq(skb);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	bp->tx_cons = cons;
diff -u -p a/net/ethernet/smsc/smc91x.c b/net/ethernet/smsc/smc91x.c
--- a/net/ethernet/smsc/smc91x.c
+++ b/net/ethernet/smsc/smc91x.c
@@ -774,7 +774,12 @@ static void smc_mii_out(struct net_devic
 	mii_reg = SMC_GET_MII(lp) & ~(MII_MCLK | MII_MDOE | MII_MDO);
 	mii_reg |= MII_MDOE;
 
-	for (mask = 1 << (bits - 1); mask; mask >>= 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (mask = 1 << (bits - 1); mask; mask >>= 1) {
 		if (val & mask)
 			mii_reg |= MII_MDO;
 		else
@@ -784,6 +789,12 @@ static void smc_mii_out(struct net_devic
 		udelay(MII_DELAY);
 		SMC_SET_MII(lp, mii_reg | MII_MCLK);
 		udelay(MII_DELAY);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -796,6 +807,11 @@ static unsigned int smc_mii_in(struct ne
 	mii_reg = SMC_GET_MII(lp) & ~(MII_MCLK | MII_MDOE | MII_MDO);
 	SMC_SET_MII(lp, mii_reg);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mask = 1 << (bits - 1), val = 0; mask; mask >>= 1) {
 		if (SMC_GET_MII(lp) & MII_MDI)
 			val |= mask;
@@ -804,6 +820,12 @@ static unsigned int smc_mii_in(struct ne
 		udelay(MII_DELAY);
 		SMC_SET_MII(lp, mii_reg | MII_MCLK);
 		udelay(MII_DELAY);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return val;
diff -u -p a/net/ethernet/hp/hp100.c b/net/ethernet/hp/hp100.c
--- a/net/ethernet/hp/hp100.c
+++ b/net/ethernet/hp/hp100.c
@@ -626,6 +626,11 @@ static int __devinit hp100_probe1(struct
 		/* However in slave mode we need to remap high (>1GB) card memory  */
 		if (local_mode != 1) {	/* = not busmaster */
 			/* We try with smaller memory sizes, if ioremap fails */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (virt_memory_size = memory_size; virt_memory_size > 16383; virt_memory_size >>= 1) {
 				if ((mem_ptr_virt = ioremap((u_long) mem_ptr_phys, virt_memory_size)) == NULL) {
 #ifdef HP100_DEBUG
@@ -637,6 +642,12 @@ static int __devinit hp100_probe1(struct
 #endif
 					break;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			if (mem_ptr_virt == NULL) {	/* all ioremap tries failed */
diff -u -p a/net/ethernet/chelsio/cxgb3/xgmac.c b/net/ethernet/chelsio/cxgb3/xgmac.c
--- a/net/ethernet/chelsio/cxgb3/xgmac.c
+++ b/net/ethernet/chelsio/cxgb3/xgmac.c
@@ -288,11 +288,23 @@ static int hash_hw_addr(const u8 * addr)
 {
 	int hash = 0, octet, bit, i = 0, c;
 
-	for (octet = 0; octet < 6; ++octet)
-		for (c = addr[octet], bit = 0; bit < 8; c >>= 1, ++bit) {
-			hash ^= (c & 1) << i;
-			if (++i == 6)
-				i = 0;
+	for (octet = 0; octet < 6; ++octet) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (c = addr[octet], bit = 0; bit < 8; c >>= 1, ++bit) {
+				hash ^= (c & 1) << i;
+				if (++i == 6)
+					i = 0;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 		}
 	return hash;
 }
diff -u -p a/net/ethernet/chelsio/cxgb4/sge.c b/net/ethernet/chelsio/cxgb4/sge.c
--- a/net/ethernet/chelsio/cxgb4/sge.c
+++ b/net/ethernet/chelsio/cxgb4/sge.c
@@ -1890,21 +1890,33 @@ static void sge_rx_timer_cb(unsigned lon
 	struct adapter *adap = (struct adapter *)data;
 	struct sge *s = &adap->sge;
 
-	for (i = 0; i < ARRAY_SIZE(s->starving_fl); i++)
-		for (m = s->starving_fl[i]; m; m &= m - 1) {
-			struct sge_eth_rxq *rxq;
-			unsigned int id = __ffs(m) + i * BITS_PER_LONG;
-			struct sge_fl *fl = s->egr_map[id];
-
-			clear_bit(id, s->starving_fl);
-			smp_mb__after_clear_bit();
-
-			if (fl_starving(fl)) {
-				rxq = container_of(fl, struct sge_eth_rxq, fl);
-				if (napi_reschedule(&rxq->rspq.napi))
-					fl->starving++;
-				else
+	for (i = 0; i < ARRAY_SIZE(s->starving_fl); i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (m = s->starving_fl[i]; m; m &= m - 1) {
+				struct sge_eth_rxq *rxq;
+				unsigned int id = __ffs(m) + i * BITS_PER_LONG;
+				struct sge_fl *fl = s->egr_map[id];
+
+				clear_bit(id, s->starving_fl);
+				smp_mb__after_clear_bit();
+
+				if (fl_starving(fl)) {
+					rxq = container_of(fl, struct sge_eth_rxq, fl);
+					if (napi_reschedule(&rxq->rspq.napi))
+						fl->starving++;
+					else
 					set_bit(id, s->starving_fl);
+					}
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 		}
 
@@ -1935,13 +1947,25 @@ static void sge_tx_timer_cb(unsigned lon
 	struct adapter *adap = (struct adapter *)data;
 	struct sge *s = &adap->sge;
 
-	for (i = 0; i < ARRAY_SIZE(s->txq_maperr); i++)
-		for (m = s->txq_maperr[i]; m; m &= m - 1) {
-			unsigned long id = __ffs(m) + i * BITS_PER_LONG;
-			struct sge_ofld_txq *txq = s->egr_map[id];
-
-			clear_bit(id, s->txq_maperr);
-			tasklet_schedule(&txq->qresume_tsk);
+	for (i = 0; i < ARRAY_SIZE(s->txq_maperr); i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (m = s->txq_maperr[i]; m; m &= m - 1) {
+				unsigned long id = __ffs(m) + i * BITS_PER_LONG;
+				struct sge_ofld_txq *txq = s->egr_map[id];
+
+				clear_bit(id, s->txq_maperr);
+				tasklet_schedule(&txq->qresume_tsk);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
 		}
 
 	budget = MAX_TIMER_TX_RECLAIM;
@@ -2293,6 +2317,11 @@ void t4_free_sge_resources(struct adapte
 	struct sge_ofld_rxq *oq = adap->sge.ofldrxq;
 
 	/* clean up Ethernet Tx/Rx queues */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < adap->sge.ethqsets; i++, eq++, etq++) {
 		if (eq->rspq.desc)
 			free_rspq_fl(adap, &eq->rspq, &eq->fl);
@@ -2303,6 +2332,12 @@ void t4_free_sge_resources(struct adapte
 			kfree(etq->q.sdesc);
 			free_txq(adap, &etq->q);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* clean up RDMA and iSCSI Rx queues */
diff -u -p a/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/net/ethernet/chelsio/cxgb4/cxgb4_main.c
--- a/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -1049,6 +1049,11 @@ static void collect_sge_port_stats(const
 	const struct sge_eth_rxq *rx = &adap->sge.ethrxq[p->first_qset];
 
 	memset(s, 0, sizeof(*s));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < p->nqsets; i++, rx++, tx++) {
 		s->tso += tx->tso;
 		s->tx_csum += tx->tx_cso;
@@ -1057,6 +1062,12 @@ static void collect_sge_port_stats(const
 		s->vlan_ins += tx->vlan_ins;
 		s->gro_pkts += rx->stats.lro_pkts;
 		s->gro_merged += rx->stats.lro_merged;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/chelsio/cxgb4vf/sge.c b/net/ethernet/chelsio/cxgb4vf/sge.c
--- a/net/ethernet/chelsio/cxgb4vf/sge.c
+++ b/net/ethernet/chelsio/cxgb4vf/sge.c
@@ -1940,6 +1940,11 @@ static void sge_rx_timer_cb(unsigned lon
 	for (i = 0; i < ARRAY_SIZE(s->starving_fl); i++) {
 		unsigned long m;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (m = s->starving_fl[i]; m; m &= m - 1) {
 			unsigned int id = __ffs(m) + i * BITS_PER_LONG;
 			struct sge_fl *fl = s->egr_map[id];
@@ -1962,6 +1967,12 @@ static void sge_rx_timer_cb(unsigned lon
 				else
 					set_bit(id, s->starving_fl);
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
@@ -2350,6 +2361,11 @@ void t4vf_free_sge_resources(struct adap
 	struct sge_rspq *intrq = &s->intrq;
 	int qs;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qs = 0; qs < adapter->sge.ethqsets; qs++, rxq++, txq++) {
 		if (rxq->rspq.desc)
 			free_rspq_fl(adapter, &rxq->rspq, &rxq->fl);
@@ -2359,6 +2375,12 @@ void t4vf_free_sge_resources(struct adap
 			kfree(txq->q.sdesc);
 			free_txq(adapter, &txq->q);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (evtq->desc)
 		free_rspq_fl(adapter, evtq, NULL);
diff -u -p a/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c b/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
--- a/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
+++ b/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
@@ -522,7 +522,12 @@ static int setup_sge_queues(struct adapt
 		struct sge_eth_txq *txq = &s->ethtxq[pi->first_qset];
 		int qs;
 
-		for (qs = 0; qs < pi->nqsets; qs++, rxq++, txq++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (qs = 0; qs < pi->nqsets; qs++, rxq++, txq++) {
 			err = t4vf_sge_alloc_rxq(adapter, &rxq->rspq, false,
 						 dev, msix++,
 						 &rxq->fl, t4vf_ethrx_handler);
@@ -537,6 +542,12 @@ static int setup_sge_queues(struct adapt
 
 			rxq->rspq.idx = qs;
 			memset(&rxq->stats, 0, sizeof(rxq->stats));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -553,6 +564,11 @@ static int setup_sge_queues(struct adapt
 		struct sge_eth_txq *txq = &s->ethtxq[pi->first_qset];
 		int qs;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (qs = 0; qs < pi->nqsets; qs++, rxq++, txq++) {
 			IQ_MAP(s, rxq->rspq.abs_id) = &rxq->rspq;
 			EQ_MAP(s, txq->q.abs_id) = &txq->q;
@@ -568,6 +584,12 @@ static int setup_sge_queues(struct adapt
 			 */
 			rxq->fl.abs_id = rxq->fl.cntxt_id + s->egr_base;
 			EQ_MAP(s, rxq->fl.abs_id) = &rxq->fl;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 0;
@@ -1453,6 +1475,11 @@ static void collect_sge_port_stats(const
 	int qs;
 
 	memset(stats, 0, sizeof(*stats));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qs = 0; qs < pi->nqsets; qs++, rxq++, txq++) {
 		stats->tso += txq->tso;
 		stats->tx_csum += txq->tx_cso;
@@ -1461,6 +1488,12 @@ static void collect_sge_port_stats(const
 		stats->vlan_ins += txq->vlan_ins;
 		stats->lro_pkts += rxq->stats.lro_pkts;
 		stats->lro_merged += rxq->stats.lro_merged;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/cadence/macb.c b/net/ethernet/cadence/macb.c
--- a/net/ethernet/cadence/macb.c
+++ b/net/ethernet/cadence/macb.c
@@ -326,6 +326,11 @@ static void macb_tx(struct macb *bp)
 		bp->tx_ring[TX_RING_SIZE - 1].ctrl |= MACB_BIT(TX_WRAP);
 
 		/* free transmit buffer in upper layer*/
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (tail = bp->tx_tail; tail != head; tail = NEXT_TX(tail)) {
 			struct ring_info *rp = &bp->tx_skb[tail];
 			struct sk_buff *skb = rp->skb;
@@ -338,6 +343,12 @@ static void macb_tx(struct macb *bp)
 							 DMA_TO_DEVICE);
 			rp->skb = NULL;
 			dev_kfree_skb_irq(skb);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		bp->tx_head = bp->tx_tail = 0;
diff -u -p a/net/ethernet/mellanox/mlx4/fw.c b/net/ethernet/mellanox/mlx4/fw.c
--- a/net/ethernet/mellanox/mlx4/fw.c
+++ b/net/ethernet/mellanox/mlx4/fw.c
@@ -487,6 +487,11 @@ int mlx4_map_cmd(struct mlx4_dev *dev, u
 	memset(mailbox->buf, 0, MLX4_MAILBOX_SIZE);
 	pages = mailbox->buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mlx4_icm_first(icm, &iter);
 	     !mlx4_icm_last(&iter);
 	     mlx4_icm_next(&iter)) {
@@ -525,6 +530,12 @@ int mlx4_map_cmd(struct mlx4_dev *dev, u
 				nent = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nent)
diff -u -p a/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c b/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c
--- a/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c
+++ b/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c
@@ -787,6 +787,11 @@ int qlcnic_get_pci_info(struct qlcnic_ad
 	err = cmd.rsp.cmd;
 
 	if (err == QLCNIC_RCODE_SUCCESS) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < QLCNIC_MAX_PCI_FUNC; i++, npar++, pci_info++) {
 			pci_info->id = le16_to_cpu(npar->id);
 			pci_info->active = le16_to_cpu(npar->active);
@@ -798,6 +803,12 @@ int qlcnic_get_pci_info(struct qlcnic_ad
 			pci_info->tx_max_bw =
 				le16_to_cpu(npar->tx_max_bw);
 			memcpy(pci_info->mac, npar->mac, ETH_ALEN);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		dev_err(&adapter->pdev->dev,
diff -u -p a/net/ethernet/natsemi/natsemi.c b/net/ethernet/natsemi/natsemi.c
--- a/net/ethernet/natsemi/natsemi.c
+++ b/net/ethernet/natsemi/natsemi.c
@@ -1065,6 +1065,11 @@ static void mii_send_bits (struct net_de
 	u32 i;
 	void __iomem *ioaddr = ns_ioaddr(dev);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = (1 << (len-1)); i; i >>= 1)
 	{
 		u32 mdio_val = MII_Write | ((data & i)? MII_Data : 0);
@@ -1072,6 +1077,12 @@ static void mii_send_bits (struct net_de
 		mii_delay(ioaddr);
 		writel(mdio_val | MII_ShiftClk, ioaddr + EECtrl);
 		mii_delay(ioaddr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	writel(0, ioaddr + EECtrl);
 	mii_delay(ioaddr);
diff -u -p a/net/ethernet/dec/tulip/de4x5.c b/net/ethernet/dec/tulip/de4x5.c
--- a/net/ethernet/dec/tulip/de4x5.c
+++ b/net/ethernet/dec/tulip/de4x5.c
@@ -1696,6 +1696,11 @@ de4x5_tx(struct net_device *dev)
     int entry;
     s32 status;
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (entry = lp->tx_old; entry != lp->tx_new; entry = lp->tx_old) {
 	status = (s32)le32_to_cpu(lp->tx_ring[entry].status);
 	if (status < 0) {                     /* Buffer not sent yet */
@@ -1727,6 +1732,12 @@ de4x5_tx(struct net_device *dev)
 
 	/* Update all the pointers */
 	lp->tx_old = (lp->tx_old + 1) % lp->txRingSize;
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
 
     /* Any resources available? */
@@ -4991,6 +5002,11 @@ mii_get_phy(struct net_device *dev)
     lp->useMII = true;
 
     /* Search the MII address space for possible PHY devices */
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (n=0, lp->mii_cnt=0, i=1; !((i==1) && (n==1)); i=(i+1)%DE4X5_MAX_MII) {
 	lp->phy[lp->active].addr = i;
 	if (i==0) n++;                             /* Count cycles */
@@ -5027,6 +5043,12 @@ mii_get_phy(struct net_device *dev)
 	    de4x5_debug = j;
 	    printk("\n");
 	}
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
   purgatory:
     lp->active = 0;
diff -u -p a/net/ethernet/dec/tulip/dmfe.c b/net/ethernet/dec/tulip/dmfe.c
--- a/net/ethernet/dec/tulip/dmfe.c
+++ b/net/ethernet/dec/tulip/dmfe.c
@@ -1916,6 +1916,11 @@ static void dmfe_parse_srom(struct dmfe_
 		/* Get NIC support media mode */
 		db->NIC_capability = le16_to_cpup((__le16 *) (srom + 34));
 		db->PHY_reg4 = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (tmp_reg = 1; tmp_reg < 0x10; tmp_reg <<= 1) {
 			switch( db->NIC_capability & tmp_reg ) {
 			case 0x1: db->PHY_reg4 |= 0x0020; break;
@@ -1923,6 +1928,12 @@ static void dmfe_parse_srom(struct dmfe_
 			case 0x4: db->PHY_reg4 |= 0x0080; break;
 			case 0x8: db->PHY_reg4 |= 0x0100; break;
 			}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		/* Media Mode Force or not check */
diff -u -p a/net/usb/hso.c b/net/usb/hso.c
--- a/net/usb/hso.c
+++ b/net/usb/hso.c
@@ -2968,6 +2968,11 @@ static int hso_probe(struct usb_interfac
 		if (!shared_int)
 			goto exit;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 1, mux = 0; i < 0x100; i = i << 1, mux++) {
 			if (port_mask & i) {
 				hso_dev = hso_create_mux_serial_device(
@@ -2975,6 +2980,12 @@ static int hso_probe(struct usb_interfac
 				if (!hso_dev)
 					goto exit;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 
 		if (tmp_dev)
diff -u -p a/net/irda/vlsi_ir.c b/net/irda/vlsi_ir.c
--- a/net/irda/vlsi_ir.c
+++ b/net/irda/vlsi_ir.c
@@ -692,6 +692,11 @@ static void vlsi_unarm_rx(vlsi_irda_dev_
 	struct ring_descr *rd;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = ring_first(r); rd != NULL; rd = ring_get(r)) {
 
 		ret = 0;
@@ -729,6 +734,12 @@ static void vlsi_unarm_rx(vlsi_irda_dev_
 			ndev->stats.rx_packets++;
 			ndev->stats.rx_bytes += ret;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1129,6 +1140,11 @@ static void vlsi_unarm_tx(vlsi_irda_dev_
 	struct ring_descr *rd;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = ring_first(r); rd != NULL; rd = ring_get(r)) {
 
 		ret = 0;
@@ -1158,6 +1174,12 @@ static void vlsi_unarm_tx(vlsi_irda_dev_
 			ndev->stats.tx_packets++;
 			ndev->stats.tx_bytes += ret;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
diff -u -p a/net/appletalk/ipddp.c b/net/appletalk/ipddp.c
--- a/net/appletalk/ipddp.c
+++ b/net/appletalk/ipddp.c
@@ -254,12 +254,23 @@ static struct ipddp_route* __ipddp_find_
 {
         struct ipddp_route *f;
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for(f = ipddp_route_list; f != NULL; f = f->next)
         {
                 if(f->ip == rt->ip &&
 		   f->at.s_net == rt->at.s_net &&
 		   f->at.s_node == rt->at.s_node)
                         return f;
+                        if (_cur < timeout) {
+                        	rdstcll(_cur);
+                        }
+                        else {
+                        	break;
+                        }
         }
 
         return NULL;
diff -u -p a/net/tokenring/ibmtr.c b/net/tokenring/ibmtr.c
--- a/net/tokenring/ibmtr.c
+++ b/net/tokenring/ibmtr.c
@@ -444,11 +444,22 @@ static int __devinit ibmtr_probe1(struct
 	}
 	if (cardpresent != NOTOK) {
 		/*       Know presumed type, try rest of ID */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 2, j = 1; i <= 46; i = i + 2, j++) {
 			if( (readb(cd_chanid+i)&0x0f) == tchanid[j]) continue;
 			/* match failed, not TR card */
 			cardpresent = NOTOK;
 			break;
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 		}
 	}
 	/* 
@@ -550,6 +561,11 @@ static int __devinit ibmtr_probe1(struct
 
 	/* Get hw address of token ring card */
 	j = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 0x18; i = i + 2) {
 		/* technical reference states to do this */
 		temp = readb(ti->mmio + AIP + i) & 0x0f;
@@ -558,6 +574,12 @@ static int __devinit ibmtr_probe1(struct
 			dev->dev_addr[(j / 2)] =
 				ti->hw_address[j]+ (ti->hw_address[j - 1] << 4);
 		++j;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* get Adapter type:  'F' = Adapter/A, 'E' = 16/4 Adapter II,... */
 	ti->adapter_type = readb(ti->mmio + AIPADAPTYPE);
diff -u -p a/net/hamradio/hdlcdrv.c b/net/hamradio/hdlcdrv.c
--- a/net/hamradio/hdlcdrv.c
+++ b/net/hamradio/hdlcdrv.c
@@ -186,6 +186,11 @@ void hdlcdrv_receiver(struct net_device
 		s->hdlcrx.bitbuf >>= 16;
 		s->hdlcrx.bitbuf |= word << 16;
 		s->hdlcrx.numbits += 16;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(i = 15, mask1 = 0x1fc00, mask2 = 0x1fe00, mask3 = 0x0fc00,
 		    mask4 = 0x1f800, mask5 = 0xf800, mask6 = 0xffff; 
 		    i >= 0; 
@@ -212,6 +217,12 @@ void hdlcdrv_receiver(struct net_device
 				s->hdlcrx.bitbuf = (s->hdlcrx.bitbuf & (~mask6)) |
 					((s->hdlcrx.bitbuf & mask6) << 1);
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		s->hdlcrx.numbits -= hdlc_rx_add_bytes(s, s->hdlcrx.bitbuf,
 						       s->hdlcrx.numbits);
@@ -343,6 +354,11 @@ void hdlcdrv_transmitter(struct net_devi
 			mask2 = 0x10000;
 			mask3 = 0xffffffff >> (31-s->hdlctx.numbits);
 			s->hdlctx.numbits += 8;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for(i = 0; i < 8; i++, mask1 <<= 1, mask2 <<= 1, 
 			    mask3 = (mask3 << 1) | 1) {
 				if ((s->hdlctx.bitstream & mask1) != mask1) 
@@ -354,6 +370,12 @@ void hdlcdrv_transmitter(struct net_devi
 						 (~mask3)) << 1);
 				s->hdlctx.numbits++;
 				mask3 = (mask3 << 1) | 1;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 			break;
 		}
diff -u -p a/mmc/host/davinci_mmc.c b/mmc/host/davinci_mmc.c
--- a/mmc/host/davinci_mmc.c
+++ b/mmc/host/davinci_mmc.c
@@ -505,7 +505,12 @@ static void mmc_davinci_send_dma_request
 	 * per EDMA PARAM entry.  Update the PARAM
 	 * entries needed for each segment of this scatterlist.
 	 */
-	for (slot = channel, link = 0, sg = data->sg, sg_len = host->sg_len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (slot = channel, link = 0, sg = data->sg, sg_len = host->sg_len;
 			sg_len-- != 0 && bytes_left;
 			sg = sg_next(sg), slot = host->links[link++]) {
 		u32		buf = sg_dma_address(sg);
@@ -526,6 +531,12 @@ static void mmc_davinci_send_dma_request
 		template->ccnt = count >> shift;
 
 		edma_write_slot(slot, template);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (host->version == MMC_CTLR_VERSION_2)
diff -u -p a/mmc/card/mmc_test.c b/mmc/card/mmc_test.c
--- a/mmc/card/mmc_test.c
+++ b/mmc/card/mmc_test.c
@@ -1105,11 +1105,22 @@ static int mmc_test_pow2_write(struct mm
 	if (!test->card->csd.write_partial)
 		return RESULT_UNSUP_CARD;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < 512;i <<= 1) {
 		sg_init_one(&sg, test->buffer, i);
 		ret = mmc_test_transfer(test, &sg, 1, 0, 1, i, 1);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -1123,11 +1134,22 @@ static int mmc_test_pow2_read(struct mmc
 	if (!test->card->csd.read_partial)
 		return RESULT_UNSUP_CARD;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 1; i < 512;i <<= 1) {
 		sg_init_one(&sg, test->buffer, i);
 		ret = mmc_test_transfer(test, &sg, 1, 0, 1, i, 0);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -1712,11 +1734,22 @@ static int mmc_test_profile_read_perf(st
 	unsigned int dev_addr;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sz = 512; sz < t->max_tfr; sz <<= 1) {
 		dev_addr = t->dev_addr + (sz >> 9);
 		ret = mmc_test_area_io(test, sz, dev_addr, 0, 0, 1);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	sz = t->max_tfr;
 	dev_addr = t->dev_addr;
@@ -1736,11 +1769,22 @@ static int mmc_test_profile_write_perf(s
 	ret = mmc_test_area_erase(test);
 	if (ret)
 		return ret;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sz = 512; sz < t->max_tfr; sz <<= 1) {
 		dev_addr = t->dev_addr + (sz >> 9);
 		ret = mmc_test_area_io(test, sz, dev_addr, 1, 0, 1);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	ret = mmc_test_area_erase(test);
 	if (ret)
@@ -1767,6 +1811,11 @@ static int mmc_test_profile_trim_perf(st
 	if (!mmc_can_erase(test->card))
 		return RESULT_UNSUP_HOST;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sz = 512; sz < t->max_sz; sz <<= 1) {
 		dev_addr = t->dev_addr + (sz >> 9);
 		getnstimeofday(&ts1);
@@ -1775,6 +1824,12 @@ static int mmc_test_profile_trim_perf(st
 			return ret;
 		getnstimeofday(&ts2);
 		mmc_test_print_rate(test, sz, &ts1, &ts2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_addr = t->dev_addr;
 	getnstimeofday(&ts1);
@@ -1816,10 +1871,21 @@ static int mmc_test_profile_seq_read_per
 	unsigned long sz;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sz = 512; sz < t->max_tfr; sz <<= 1) {
 		ret = mmc_test_seq_read_perf(test, sz);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	sz = t->max_tfr;
 	return mmc_test_seq_read_perf(test, sz);
@@ -1858,10 +1924,21 @@ static int mmc_test_profile_seq_write_pe
 	unsigned long sz;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sz = 512; sz < t->max_tfr; sz <<= 1) {
 		ret = mmc_test_seq_write_perf(test, sz);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	sz = t->max_tfr;
 	return mmc_test_seq_write_perf(test, sz);
@@ -1884,6 +1961,11 @@ static int mmc_test_profile_seq_trim_per
 	if (!mmc_can_erase(test->card))
 		return RESULT_UNSUP_HOST;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sz = 512; sz <= t->max_sz; sz <<= 1) {
 		ret = mmc_test_area_erase(test);
 		if (ret)
@@ -1903,6 +1985,12 @@ static int mmc_test_profile_seq_trim_per
 		}
 		getnstimeofday(&ts2);
 		mmc_test_print_avg_rate(test, sz, cnt, &ts1, &ts2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1960,6 +2048,11 @@ static int mmc_test_random_perf(struct m
 	unsigned long sz;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sz = 512; sz < t->max_tfr; sz <<= 1) {
 		/*
 		 * When writing, try to get more consistent results by running
@@ -1976,6 +2069,12 @@ static int mmc_test_random_perf(struct m
 		ret = mmc_test_rnd_perf(test, write, 1, sz);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	sz = t->max_tfr;
 	if (write) {
diff -u -p a/mtd/nand/nand_base.c b/mtd/nand/nand_base.c
--- a/mtd/nand/nand_base.c
+++ b/mtd/nand/nand_base.c
@@ -1122,6 +1122,11 @@ static int nand_read_page_swecc(struct m
 	eccsteps = chip->ecc.steps;
 	p = buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		int stat;
 
@@ -1130,6 +1135,12 @@ static int nand_read_page_swecc(struct m
 			mtd->ecc_stats.failed++;
 		else
 			mtd->ecc_stats.corrected += stat;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return 0;
 }
@@ -1244,10 +1255,21 @@ static int nand_read_page_hwecc(struct m
 	uint8_t *ecc_code = chip->buffers->ecccode;
 	uint32_t *eccpos = chip->ecc.layout->eccpos;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		chip->ecc.hwctl(mtd, NAND_ECC_READ);
 		chip->read_buf(mtd, p, eccsize);
 		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
 
@@ -1257,6 +1279,11 @@ static int nand_read_page_hwecc(struct m
 	eccsteps = chip->ecc.steps;
 	p = buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		int stat;
 
@@ -1265,6 +1292,12 @@ static int nand_read_page_hwecc(struct m
 			mtd->ecc_stats.failed++;
 		else
 			mtd->ecc_stats.corrected += stat;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return 0;
 }
@@ -1301,6 +1334,11 @@ static int nand_read_page_hwecc_oob_firs
 	for (i = 0; i < chip->ecc.total; i++)
 		ecc_code[i] = chip->oob_poi[eccpos[i]];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		int stat;
 
@@ -1313,6 +1351,12 @@ static int nand_read_page_hwecc_oob_firs
 			mtd->ecc_stats.failed++;
 		else
 			mtd->ecc_stats.corrected += stat;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return 0;
 }
@@ -1336,6 +1380,11 @@ static int nand_read_page_syndrome(struc
 	uint8_t *p = buf;
 	uint8_t *oob = chip->oob_poi;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		int stat;
 
@@ -1362,6 +1411,12 @@ static int nand_read_page_syndrome(struc
 			chip->read_buf(mtd, oob, chip->ecc.postpad);
 			oob += chip->ecc.postpad;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Calculate remaining oob bytes */
@@ -1993,10 +2048,21 @@ static void nand_write_page_hwecc(struct
 	const uint8_t *p = buf;
 	uint32_t *eccpos = chip->ecc.layout->eccpos;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
 		chip->write_buf(mtd, p, eccsize);
 		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i < chip->ecc.total; i++)
@@ -2023,6 +2089,11 @@ static void nand_write_page_syndrome(str
 	const uint8_t *p = buf;
 	uint8_t *oob = chip->oob_poi;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 
 		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
@@ -2041,6 +2112,12 @@ static void nand_write_page_syndrome(str
 			chip->write_buf(mtd, oob, chip->ecc.postpad);
 			oob += chip->ecc.postpad;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Calculate remaining oob bytes */
diff -u -p a/mtd/nand/diskonchip.c b/mtd/nand/diskonchip.c
--- a/mtd/nand/diskonchip.c
+++ b/mtd/nand/diskonchip.c
@@ -1586,6 +1586,11 @@ static int __init doc_probe(unsigned lon
 		goto notfound;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mtd = doclist; mtd; mtd = doc->nextdoc) {
 		unsigned char oldval;
 		unsigned char newval;
@@ -1618,6 +1623,12 @@ static int __init doc_probe(unsigned lon
 			printk(KERN_DEBUG "Found alias of DOC at 0x%lx to 0x%lx\n", doc->physadr, physadr);
 			goto notfound;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_NOTICE "DiskOnChip found at 0x%lx\n", physadr);
@@ -1702,6 +1713,11 @@ static void release_nanddoc(void)
 	struct nand_chip *nand;
 	struct doc_priv *doc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mtd = doclist; mtd; mtd = nextmtd) {
 		nand = mtd->priv;
 		doc = nand->priv;
@@ -1710,6 +1726,12 @@ static void release_nanddoc(void)
 		nand_release(mtd);
 		iounmap(doc->virtadr);
 		kfree(mtd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/nand/sh_flctl.c b/mtd/nand/sh_flctl.c
--- a/mtd/nand/sh_flctl.c
+++ b/mtd/nand/sh_flctl.c
@@ -352,11 +352,22 @@ static int flctl_read_page_hwecc(struct
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
 		chip->read_buf(mtd, p, eccsize);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		if (flctl->hwecc_cant_correct[i])
 			mtd->ecc_stats.failed++;
 		else
 			mtd->ecc_stats.corrected += 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
diff -u -p a/mtd/nand/bcm_umi_bch.c b/mtd/nand/bcm_umi_bch.c
--- a/mtd/nand/bcm_umi_bch.c
+++ b/mtd/nand/bcm_umi_bch.c
@@ -200,6 +200,11 @@ static void bcm_umi_bch_write_page_hwecc
 	uint8_t *oobp = chip->oob_poi;
 	int sectorOobSize = mtd->oobsize / eccsteps;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sectorIdx = 0; sectorIdx < eccsteps;
 	     sectorIdx++, datap += eccsize, oobp += sectorOobSize) {
 		/* Enable hardware ECC before writing the buf */
@@ -207,6 +212,12 @@ static void bcm_umi_bch_write_page_hwecc
 		bcm_umi_nand_write_buf(mtd, datap, eccsize);
 		nand_bcm_umi_bch_write_oobEcc(mtd->writesize, oobp,
 					      NAND_ECC_NUM_BYTES);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bcm_umi_nand_write_buf(mtd, chip->oob_poi, mtd->oobsize);
diff -u -p a/mtd/nand/fsmc_nand.c b/mtd/nand/fsmc_nand.c
--- a/mtd/nand/fsmc_nand.c
+++ b/mtd/nand/fsmc_nand.c
@@ -425,6 +425,11 @@ static int fsmc_read_page_hwecc(struct m
 	uint16_t ecc_oob[7];
 	uint8_t *oob = (uint8_t *)&ecc_oob[0];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, s = 0; s < eccsteps; s++, i += eccbytes, p += eccsize) {
 
 		chip->cmdfunc(mtd, NAND_CMD_READ0, s * eccsize, page);
@@ -455,6 +460,12 @@ static int fsmc_read_page_hwecc(struct m
 			mtd->ecc_stats.failed++;
 		else
 			mtd->ecc_stats.corrected += stat;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
diff -u -p a/mtd/maps/amd76xrom.c b/mtd/maps/amd76xrom.c
--- a/mtd/maps/amd76xrom.c
+++ b/mtd/maps/amd76xrom.c
@@ -206,6 +206,11 @@ static int __devinit amd76xrom_init_one
 			MOD_NAME, (unsigned long long)map->map.phys);
 
 		/* There is no generic VPP support */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(map->map.bankwidth = 32; map->map.bankwidth;
 			map->map.bankwidth >>= 1)
 		{
@@ -224,6 +229,12 @@ static int __devinit amd76xrom_init_one
 				if (map->mtd)
 					goto found;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		map_top += ROM_PROBE_STEP_SIZE;
 		continue;
diff -u -p a/mtd/maps/esb2rom.c b/mtd/maps/esb2rom.c
--- a/mtd/maps/esb2rom.c
+++ b/mtd/maps/esb2rom.c
@@ -298,6 +298,11 @@ static int __devinit esb2rom_init_one(st
 		 * in a factory setting.  So in-place programming
 		 * needs to use a different method.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(map->map.bankwidth = 32; map->map.bankwidth;
 			map->map.bankwidth >>= 1) {
 			char **probe_type;
@@ -315,6 +320,12 @@ static int __devinit esb2rom_init_one(st
 				if (map->mtd)
 					goto found;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		map_top += ROM_PROBE_STEP_SIZE;
 		continue;
diff -u -p a/mtd/maps/ck804xrom.c b/mtd/maps/ck804xrom.c
--- a/mtd/maps/ck804xrom.c
+++ b/mtd/maps/ck804xrom.c
@@ -236,6 +236,11 @@ static int __devinit ck804xrom_init_one
 			MOD_NAME, (unsigned long long)map->map.phys);
 
 		/* There is no generic VPP support */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(map->map.bankwidth = 32; map->map.bankwidth;
 			map->map.bankwidth >>= 1)
 		{
@@ -254,6 +259,12 @@ static int __devinit ck804xrom_init_one
 				if (map->mtd)
 					goto found;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		map_top += ROM_PROBE_STEP_SIZE;
 		continue;
diff -u -p a/mtd/maps/ichxrom.c b/mtd/maps/ichxrom.c
--- a/mtd/maps/ichxrom.c
+++ b/mtd/maps/ichxrom.c
@@ -231,6 +231,11 @@ static int __devinit ichxrom_init_one (s
 		 * in a factory setting.  So in-place programming
 		 * needs to use a different method.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(map->map.bankwidth = 32; map->map.bankwidth;
 			map->map.bankwidth >>= 1)
 		{
@@ -249,6 +254,12 @@ static int __devinit ichxrom_init_one (s
 				if (map->mtd)
 					goto found;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		map_top += ROM_PROBE_STEP_SIZE;
 		continue;
diff -u -p a/mtd/chips/gen_probe.c b/mtd/chips/gen_probe.c
--- a/mtd/chips/gen_probe.c
+++ b/mtd/chips/gen_probe.c
@@ -171,6 +171,11 @@ static int genprobe_new_chip(struct map_
 	int max_chips = map_bankwidth(map); /* And minimum 1 */
 	int nr_chips, type;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nr_chips = max_chips; nr_chips >= min_chips; nr_chips >>= 1) {
 
 		if (!cfi_interleave_supported(nr_chips))
@@ -188,6 +193,12 @@ static int genprobe_new_chip(struct map_
 			if (cp->probe_chip(map, 0, NULL, cfi))
 				return 1;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return 0;
 }
diff -u -p a/mtd/cmdlinepart.c b/mtd/cmdlinepart.c
--- a/mtd/cmdlinepart.c
+++ b/mtd/cmdlinepart.c
@@ -326,6 +326,11 @@ static int parse_cmdline_partitions(stru
 	if (!cmdline_parsed)
 		mtdpart_setup_real(cmdline);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(part = partitions; part; part = part->next)
 	{
 		if ((!mtd_id) || (!strcmp(part->mtd_id, mtd_id)))
@@ -355,6 +360,12 @@ static int parse_cmdline_partitions(stru
 				return -ENOMEM;
 			return part->num_parts;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/mtd/redboot.c b/mtd/redboot.c
--- a/mtd/redboot.c
+++ b/mtd/redboot.c
@@ -220,11 +220,22 @@ static int parse_redboot_partitions(stru
 		nulllen = sizeof(nullstring);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tmp_fl = fl; tmp_fl->next; tmp_fl = tmp_fl->next) {
 		if (tmp_fl->img->flash_base + tmp_fl->img->size + master->erasesize <= tmp_fl->next->img->flash_base) {
 			nrparts++;
 			nulllen = sizeof(nullstring);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 #endif
 	parts = kzalloc(sizeof(*parts)*nrparts + nulllen + namelen, GFP_KERNEL);
diff -u -p a/macintosh/ans-lcd.c b/macintosh/ans-lcd.c
--- a/macintosh/ans-lcd.c
+++ b/macintosh/ans-lcd.c
@@ -67,11 +67,22 @@ anslcd_write( struct file * file, const
 		return -EFAULT;
 
 	mutex_lock(&anslcd_mutex);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for ( i = *ppos; count > 0; ++i, ++p, --count ) 
 	{
 		char c;
 		__get_user(c, p);
 		anslcd_write_byte_data( c );
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	mutex_unlock(&anslcd_mutex);
 	*ppos = i;
diff -u -p a/macintosh/nvram.c b/macintosh/nvram.c
--- a/macintosh/nvram.c
+++ b/macintosh/nvram.c
@@ -67,10 +67,21 @@ static ssize_t write_nvram(struct file *
 		return -EFAULT;
 	if (*ppos >= NVRAM_SIZE)
 		return 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = *ppos; count > 0 && i < NVRAM_SIZE; ++i, ++p, --count) {
 		if (__get_user(c, p))
 			return -EFAULT;
 		nvram_write_byte(c, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*ppos = i;
 	return p - buf;
diff -u -p a/media/video/pwc/pwc-dec23.c b/media/video/pwc/pwc-dec23.c
--- a/media/video/pwc/pwc-dec23.c
+++ b/media/video/pwc/pwc-dec23.c
@@ -119,6 +119,11 @@ static void build_table_color(const unsi
 		p8 = p8004[compression_mode];
 		r  = romtable[compression_mode];
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0; j < 8; j++, r++, p0 += 128) {
 
 			for (k = 0; k < 16; k++) {
@@ -152,6 +157,12 @@ static void build_table_color(const unsi
 				p0[k + 0x60] = (-3 * pw) + 0x80;
 				p0[k + 0x70] = (-4 * pw) + 0x80;
 			}	/* end of for (k=0; k<16; k++, p8++) */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}	/* end of for (j=0; j<8; j++ , table++) */
 	} /* end of foreach compression_mode */
 }
@@ -454,15 +465,37 @@ static void copy_image_block_CrCb(const
 	const int *c2 = src + 4;
 	unsigned char *d = dst;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++, c1++, c2++) {
 		*d++ = CLAMP((*c1) >> scalebits);
 		*d++ = CLAMP((*c2) >> scalebits);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	c1 = src + 12;
 	d = dst + bytes_per_line;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++, c1++, c2++) {
 		*d++ = CLAMP((*c1) >> scalebits);
 		*d++ = CLAMP((*c2) >> scalebits);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 #endif
 }
diff -u -p a/media/video/ivtv/ivtv-yuv.c b/media/video/ivtv/ivtv-yuv.c
--- a/media/video/ivtv/ivtv-yuv.c
+++ b/media/video/ivtv/ivtv-yuv.c
@@ -156,12 +156,23 @@ int ivtv_yuv_filter_check(struct ivtv *i
 {
 	int i, y, uv;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, y = 16, uv = 4; i < 16; i++, y += 24, uv += 12) {
 		if ((read_dec(IVTV_YUV_HORIZONTAL_FILTER_OFFSET + y) != i << 16) ||
 		    (read_dec(IVTV_YUV_VERTICAL_FILTER_OFFSET + uv) != i << 16)) {
 			IVTV_WARN ("YUV filter table not found in firmware.\n");
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/media/video/bt8xx/bttv-risc.c b/media/video/bt8xx/bttv-risc.c
--- a/media/video/bt8xx/bttv-risc.c
+++ b/media/video/bt8xx/bttv-risc.c
@@ -294,6 +294,11 @@ bttv_risc_overlay(struct bttv *btv, stru
 					skips, &nskips, ov->clips, ov->nclips);
 
 		/* write out risc code */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (start = 0, skip = 0; start < ov->w.width; start = end) {
 			if (skip >= nskips) {
 				ri  = BT848_RISC_WRITE;
@@ -320,6 +325,12 @@ bttv_risc_overlay(struct bttv *btv, stru
 			*(rp++)=cpu_to_le32(ri);
 			if (0 != ra)
 				*(rp++)=cpu_to_le32(ra);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 
diff -u -p a/media/video/vino.c b/media/video/vino.c
--- a/media/video/vino.c
+++ b/media/video/vino.c
@@ -894,9 +894,20 @@ static inline int vino_fifo_has_id(struc
 {
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = f->head; i == (f->tail - 1); i = (i + 1) % f->length) {
 		if (f->data[i] == id)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/media/video/adv7343.c b/media/video/adv7343.c
--- a/media/video/adv7343.c
+++ b/media/video/adv7343.c
@@ -174,10 +174,21 @@ static int adv7343_setstd(struct v4l2_su
 	/* Program the sub carrier frequency registers */
 	fsc_ptr = (unsigned char *)&std_info[i].fsc_val;
 	reg = ADV7343_FSC_REG0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 4; i++, reg++, fsc_ptr++) {
 		err = adv7343_write(sd, reg, *fsc_ptr);
 		if (err < 0)
 			goto setstd_exit;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+		}
 	}
 
 	val = state->reg80;
diff -u -p a/media/video/cx18/cx18-queue.c b/media/video/cx18/cx18-queue.c
--- a/media/video/cx18/cx18-queue.c
+++ b/media/video/cx18/cx18-queue.c
@@ -289,6 +289,11 @@ void cx18_load_queues(struct cx18_stream
 	 * Excess buffers are left in buf_pool and/or on an MDL in q_idle
 	 */
 	mdl_id = s->mdl_base_idx;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mdl = cx18_dequeue(s, &s->q_idle), i = s->bufs_per_mdl;
 	     mdl != NULL && i == s->bufs_per_mdl;
 	     mdl = cx18_dequeue(s, &s->q_idle)) {
@@ -329,6 +334,12 @@ void cx18_load_queues(struct cx18_stream
 			cx18_push(s, mdl, &s->q_idle);
 		}
 		mdl_id += i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/pvrusb2/pvrusb2-sysfs.c b/media/video/pvrusb2/pvrusb2-sysfs.c
--- a/media/video/pvrusb2/pvrusb2-sysfs.c
+++ b/media/video/pvrusb2/pvrusb2-sysfs.c
@@ -491,6 +491,11 @@ static void pvr2_sysfs_add_controls(stru
 static void pvr2_sysfs_tear_down_controls(struct pvr2_sysfs *sfp)
 {
 	struct pvr2_sysfs_ctl_item *cip1,*cip2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cip1 = sfp->item_first; cip1; cip1 = cip2) {
 		cip2 = cip1->item_next;
 		if (cip1->created_ok) {
@@ -498,6 +503,12 @@ static void pvr2_sysfs_tear_down_control
 		}
 		pvr2_sysfs_trace("Destroying pvr2_sysfs_ctl_item id=%p",cip1);
 		kfree(cip1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/pvrusb2/pvrusb2-std.c b/media/video/pvrusb2/pvrusb2-std.c
--- a/media/video/pvrusb2/pvrusb2-std.c
+++ b/media/video/pvrusb2/pvrusb2-std.c
@@ -335,6 +335,11 @@ struct v4l2_standard *pvr2_std_create_en
 	*countptr = 0;
 	std_cnt = 0;
 	fmsk = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idmsk = 1, cmsk = id; cmsk; idmsk <<= 1) {
 		if (!(idmsk & cmsk)) continue;
 		cmsk &= ~idmsk;
@@ -343,6 +348,12 @@ struct v4l2_standard *pvr2_std_create_en
 			continue;
 		}
 		fmsk |= idmsk;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (idx2 = 0; idx2 < ARRAY_SIZE(std_mixes); idx2++) {
@@ -383,11 +394,22 @@ struct v4l2_standard *pvr2_std_create_en
 		if (pvr2_std_fill(stddefs+idx,std_mixes[idx2])) idx++;
 	}
 	/* Now enumerate individual pieces */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idmsk = 1, cmsk = id; cmsk && (idx < std_cnt); idmsk <<= 1) {
 		if (!(idmsk & cmsk)) continue;
 		cmsk &= ~idmsk;
 		if (!pvr2_std_fill(stddefs+idx,idmsk)) continue;
 		idx++;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	*countptr = std_cnt;
diff -u -p a/media/video/pvrusb2/pvrusb2-context.c b/media/video/pvrusb2/pvrusb2-context.c
--- a/media/video/pvrusb2/pvrusb2-context.c
+++ b/media/video/pvrusb2/pvrusb2-context.c
@@ -140,9 +140,20 @@ static void pvr2_context_check(struct pv
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ch1 = mp->mc_first; ch1; ch1 = ch2) {
 		ch2 = ch1->mc_next;
 		if (ch1->check_func) ch1->check_func(ch1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (mp->disconnect_flag && !mp->mc_first) {
@@ -251,9 +262,20 @@ static void pvr2_context_reset_input_lim
 	struct pvr2_hdw *hdw = mp->hdw;
 	mmsk = pvr2_hdw_get_input_available(hdw);
 	tmsk = mmsk;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cp = mp->mc_first; cp; cp = cp->mc_next) {
 		if (!cp->input_mask) continue;
 		tmsk &= cp->input_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	pvr2_hdw_set_input_allowed(hdw,mmsk,tmsk);
 	pvr2_hdw_commit_ctl(hdw);
@@ -355,10 +377,21 @@ int pvr2_channel_limit_inputs(struct pvr
 			break;
 		}
 		tmsk = mmsk;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (p2 = cp->mc_head->mc_first; p2; p2 = p2->mc_next) {
 			if (p2 == cp) continue;
 			if (!p2->input_mask) continue;
 			tmsk &= p2->input_mask;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!(tmsk & cmsk)) {
 			ret = -EPERM;
diff -u -p a/media/dvb/siano/smscoreapi.c b/media/dvb/siano/smscoreapi.c
--- a/media/dvb/siano/smscoreapi.c
+++ b/media/dvb/siano/smscoreapi.c
@@ -107,6 +107,11 @@ static struct smscore_registry_entry_t *
 	struct list_head *next;
 
 	kmutex_lock(&g_smscore_registrylock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (next = g_smscore_registry.next;
 	     next != &g_smscore_registry;
 	     next = next->next) {
@@ -115,6 +120,12 @@ static struct smscore_registry_entry_t *
 			kmutex_unlock(&g_smscore_registrylock);
 			return entry;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	entry = kmalloc(sizeof(struct smscore_registry_entry_t), GFP_KERNEL);
 	if (entry) {
@@ -211,12 +222,23 @@ int smscore_register_hotplug(hotplug_t h
 	if (notifyee) {
 		/* now notify callback about existing devices */
 		first = &g_smscore_devices;
-		for (next = first->next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (next = first->next;
 		     next != first && !rc;
 		     next = next->next) {
 			struct smscore_device_t *coredev =
 				(struct smscore_device_t *) next;
 			rc = hotplug(coredev, coredev->device, 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (rc >= 0) {
@@ -948,6 +970,11 @@ smscore_client_t *smscore_find_client(st
 
 	spin_lock_irqsave(&coredev->clientslock, flags);
 	first = &coredev->clients;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (next = first->next;
 	     (next != first) && !client;
 	     next = next->next) {
@@ -962,6 +989,12 @@ smscore_client_t *smscore_find_client(st
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&coredev->clientslock, flags);
 	return client;
diff -u -p a/media/radio/radio-trust.c b/media/radio/radio-trust.c
--- a/media/radio/radio-trust.c
+++ b/media/radio/radio-trust.c
@@ -86,7 +86,12 @@ static void write_i2c(struct trust *tr,
 
 	for(; n; n--) {
 		val = va_arg(args, unsigned);
-		for(mask = 0x80; mask; mask >>= 1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for(mask = 0x80; mask; mask >>= 1) {
 			if(val & mask)
 				TR_SET_SDA;
 			else
@@ -95,6 +100,12 @@ static void write_i2c(struct trust *tr,
 			TR_DELAY;
 			TR_CLR_SCL;
 			TR_DELAY;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* acknowledge bit */
 		TR_SET_SDA;
diff -u -p a/gpio/gpio-davinci.c b/gpio/gpio-davinci.c
--- a/gpio/gpio-davinci.c
+++ b/gpio/gpio-davinci.c
@@ -438,12 +438,23 @@ static int __init davinci_gpio_irq_setup
 		 */
 		irq_set_handler_data(bank_irq, &chips[gpio / 32]);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < 16 && gpio < ngpio; i++, irq++, gpio++) {
 			irq_set_chip(irq, &gpio_irqchip);
 			irq_set_chip_data(irq, (__force void *)g);
 			irq_set_handler_data(irq, (void *)__gpio_mask(gpio));
 			irq_set_handler(irq, handle_simple_irq);
 			set_irq_flags(irq, IRQF_VALID);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		binten |= BIT(bank);
diff -u -p a/gpio/gpio-msm-v2.c b/gpio/gpio-msm-v2.c
--- a/gpio/gpio-msm-v2.c
+++ b/gpio/gpio-msm-v2.c
@@ -317,12 +317,23 @@ static void msm_summary_irq_handler(unsi
 
 	chained_irq_enter(chip, desc);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = find_first_bit(msm_gpio.enabled_irqs, NR_GPIO_IRQS);
 	     i < NR_GPIO_IRQS;
 	     i = find_next_bit(msm_gpio.enabled_irqs, NR_GPIO_IRQS, i + 1)) {
 		if (readl(GPIO_INTR_STATUS(i)) & BIT(INTR_STATUS))
 			generic_handle_irq(msm_gpio_to_irq(&msm_gpio.gpio_chip,
 							   i));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	chained_irq_exit(chip, desc);
diff -u -p a/gpio/gpiolib.c b/gpio/gpiolib.c
--- a/gpio/gpiolib.c
+++ b/gpio/gpiolib.c
@@ -1660,6 +1660,11 @@ static void gpiolib_dbg_show(struct seq_
 	struct gpio_desc	*gdesc = &gpio_desc[gpio];
 	int			is_out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < chip->ngpio; i++, gpio++, gdesc++) {
 		if (!test_bit(FLAG_REQUESTED, &gdesc->flags))
 			continue;
@@ -1672,6 +1677,12 @@ static void gpiolib_dbg_show(struct seq_
 				? (chip->get(chip, i) ? "hi" : "lo")
 				: "?  ");
 		seq_printf(s, "\n");
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/platform/x86/wmi.c b/platform/x86/wmi.c
--- a/platform/x86/wmi.c
+++ b/platform/x86/wmi.c
@@ -187,10 +187,21 @@ static bool wmi_parse_guid(const u8 *src
 		return false;
 
 	for (j = 0; j < 5; j++, src++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < size[j]; i++, src += 2, *dest++ = v) {
 			v = wmi_parse_hexbyte(src);
 			if (v < 0)
 				return false;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
diff -u -p a/mfd/twl6030-irq.c b/mfd/twl6030-irq.c
--- a/mfd/twl6030-irq.c
+++ b/mfd/twl6030-irq.c
@@ -177,7 +177,12 @@ static int twl6030_irq_thread(void *data
 		if (sts.bytes[2] & 0x10)
 			sts.bytes[2] |= 0x08;
 
-		for (i = 0; sts.int_sts; sts.int_sts >>= 1, i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; sts.int_sts; sts.int_sts >>= 1, i++) {
 			local_irq_disable();
 			if (sts.int_sts & 0x1) {
 				int module_irq = twl6030_irq_base +
@@ -186,6 +191,12 @@ static int twl6030_irq_thread(void *data
 
 			}
 		local_irq_enable();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+			}
 		}
 
 		/*
diff -u -p a/mfd/ezx-pcap.c b/mfd/ezx-pcap.c
--- a/mfd/ezx-pcap.c
+++ b/mfd/ezx-pcap.c
@@ -196,9 +196,20 @@ static void pcap_isr_work(struct work_st
 
 		local_irq_disable();
 		service = isr & ~msr;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (irq = pcap->irq_base; service; service >>= 1, irq++) {
 			if (service & 1)
 				generic_handle_irq(irq);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		local_irq_enable();
 		ezx_pcap_write(pcap, PCAP_REG_MSR, pcap->msr);
diff -u -p a/mfd/twl4030-irq.c b/mfd/twl4030-irq.c
--- a/mfd/twl4030-irq.c
+++ b/mfd/twl4030-irq.c
@@ -300,11 +300,22 @@ static irqreturn_t handle_twl4030_pih(in
 	}
 
 	/* these handlers deal with the relevant SIH irq status */
-	for (module_irq = twl4030_irq_base;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (module_irq = twl4030_irq_base;
 			pih_isr;
 			pih_isr >>= 1, module_irq++) {
 		if (pih_isr & 0x1)
 			handle_nested_irq(module_irq);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return IRQ_HANDLED;
diff -u -p a/atm/idt77105.c b/atm/idt77105.c
--- a/atm/idt77105.c
+++ b/atm/idt77105.c
@@ -88,6 +88,11 @@ static void idt77105_stats_timer_func(un
 	struct idt77105_stats *stats;
 
         DPRINTK("IDT77105 gathering statistics\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (walk = idt77105_all; walk; walk = walk->next) {
 		dev = walk->dev;
                 
@@ -96,7 +101,13 @@ static void idt77105_stats_timer_func(un
                 stats->tx_cells += get_counter(dev, IDT77105_CTRSEL_TCC);
                 stats->rx_cells += get_counter(dev, IDT77105_CTRSEL_RCC);
                 stats->rx_hec_errors += get_counter(dev, IDT77105_CTRSEL_RHEC);
-	}
+                if (_cur < timeout) {
+                	rdstcll(_cur);
+                }
+                else {
+                	break;
+                }
+        }
         if (!start_timer) mod_timer(&stats_timer,jiffies+IDT77105_STATS_TIMER_PERIOD);
 }
 
@@ -117,6 +128,11 @@ static void idt77105_restart_timer_func(
         unsigned char istat;
 
         DPRINTK("IDT77105 checking for cable re-insertion\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (walk = idt77105_all; walk; walk = walk->next) {
 		dev = walk->dev;
                 
@@ -134,7 +150,13 @@ static void idt77105_restart_timer_func(
                     /* re-enable interrupts */
 	            PUT( walk->old_mcr ,MCR);
                 }
-	}
+                if (_cur < timeout) {
+	            rdstcll(_cur);
+                }
+                else {
+	            break;
+                }
+        }
         if (!start_timer) mod_timer(&restart_timer,jiffies+IDT77105_RESTART_TIMER_PERIOD);
 }
 
diff -u -p a/atm/lanai.c b/atm/lanai.c
--- a/atm/lanai.c
+++ b/atm/lanai.c
@@ -899,7 +899,12 @@ static int __devinit eeprom_read(struct
 		/* send start bit */
 		data_l(); udelay(5);
 		clock_l(); udelay(5);
-		for (i = 128; i != 0; i >>= 1) {   /* write command out */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 128; i != 0; i >>= 1) {   /* write command out */
 			tmp = (lanai->conf1 & ~CONFIG1_PROMDATA) |
 			    ((data & i) ? CONFIG1_PROMDATA : 0);
 			if (lanai->conf1 != tmp) {
@@ -907,6 +912,12 @@ static int __devinit eeprom_read(struct
 				udelay(5);	/* Let new data settle */
 			}
 			clock_h(); udelay(5); clock_l(); udelay(5);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* look for ack */
 		data_h(); clock_h(); udelay(5);
diff -u -p a/atm/firestream.c b/atm/firestream.c
--- a/atm/firestream.c
+++ b/atm/firestream.c
@@ -1962,6 +1962,11 @@ static void __devexit firestream_remove_
 	}
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = fs_boards;dev != NULL;dev=nxtdev) {
 		fs_dprintk (FS_DEBUG_CLEANUP, "Releasing resources for dev at %p.\n", dev);
 
@@ -1981,6 +1986,11 @@ static void __devexit firestream_remove_
 		/* XXX Wait a while for the chip to release all buffers. */
 
 		for (i=0;i < FS_NR_FREE_POOLS;i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (fp=bus_to_virt (read_fs (dev, FP_SA(dev->rx_fp[i].offset)));
 			     !(fp->flags & FP_FLAGS_EPI);fp = nxt) {
 				fs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p\n", fp->skb);
@@ -1988,6 +1998,12 @@ static void __devexit firestream_remove_
 				nxt = bus_to_virt (fp->next);
 				fs_dprintk (FS_DEBUG_ALLOC, "Free rec-d: %p\n", fp);
 				kfree (fp);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			fs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p\n", fp->skb);
 			dev_kfree_skb_any (fp->skb);
@@ -2022,6 +2038,12 @@ static void __devexit firestream_remove_
 		fs_dprintk (FS_DEBUG_ALLOC, "Free fs-dev: %p\n", dev);
 		nxtdev = dev->next;
 		kfree (dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	func_exit ();
diff -u -p a/atm/solos-pci.c b/atm/solos-pci.c
--- a/atm/solos-pci.c
+++ b/atm/solos-pci.c
@@ -964,6 +964,11 @@ static uint32_t fpga_tx(struct solos_car
 	 */
 	tx_pending = card->tx_mask & ~card_flags;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (port = 0; tx_pending; tx_pending >>= 1, port++) {
 		if (tx_pending & 1) {
 			struct sk_buff *oldskb = card->tx_skb[port];
@@ -1016,6 +1021,12 @@ static uint32_t fpga_tx(struct solos_car
 				dev_kfree_skb_irq(oldskb);
 
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* For non-DMA TX, write the 'TX start' bit for all four ports simultaneously */
 	if (tx_started)
diff -u -p a/atm/suni.c b/atm/suni.c
--- a/atm/suni.c
+++ b/atm/suni.c
@@ -60,6 +60,11 @@ static void suni_hz(unsigned long from_t
 	struct atm_dev *dev;
 	struct k_sonet_stats *stats;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (walk = sunis; walk; walk = walk->next) {
 		dev = walk->dev;
 		stats = &walk->sonet_stats;
@@ -85,6 +90,12 @@ static void suni_hz(unsigned long from_t
 		ADD_LIMITED(tx_cells,(GET(TACP_TCCL) & 0xff) |
 		    ((GET(TACP_TCC) & 0xff) << 8) |
 		    ((GET(TACP_TCCM) & 7) << 16));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (from_timer) mod_timer(&poll_timer,jiffies+HZ);
 }
diff -u -p a/md/raid5.c b/md/raid5.c
--- a/md/raid5.c
+++ b/md/raid5.c
@@ -2208,12 +2208,23 @@ static int add_stripe_bio(struct stripe_
 	if (forwrite) {
 		/* check if page is covered */
 		sector_t sector = sh->dev[dd_idx].sector;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (bi=sh->dev[dd_idx].towrite;
 		     sector < sh->dev[dd_idx].sector + STRIPE_SECTORS &&
 			     bi && bi->bi_sector <= sector;
 		     bi = r5_next_bio(bi, sh->dev[dd_idx].sector)) {
 			if (bi->bi_sector + (bi->bi_size>>9) >= sector)
 				sector = bi->bi_sector + (bi->bi_size>>9);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (sector >= sh->dev[dd_idx].sector + STRIPE_SECTORS)
 			set_bit(R5_OVERWRITE, &sh->dev[dd_idx].flags);
diff -u -p a/md/dm-region-hash.c b/md/dm-region-hash.c
--- a/md/dm-region-hash.c
+++ b/md/dm-region-hash.c
@@ -526,10 +526,21 @@ void dm_rh_inc_pending(struct dm_region_
 {
 	struct bio *bio;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bio = bios->head; bio; bio = bio->bi_next) {
 		if (bio->bi_rw & (REQ_FLUSH | REQ_DISCARD))
 			continue;
 		rh_inc(rh, dm_rh_bio_to_region(rh, bio));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(dm_rh_inc_pending);
diff -u -p a/message/i2o/i2o_proc.c b/message/i2o/i2o_proc.c
--- a/message/i2o/i2o_proc.c
+++ b/message/i2o/i2o_proc.c
@@ -822,6 +822,11 @@ static int i2o_seq_show_ddm_table(struct
 		   "Tid   Module_type     Vendor Mod_id  Module_name             Vrs  Data_size Code_size\n");
 	ddm_table = result->ddm_table[0];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < result->row_count; ddm_table = result->ddm_table[++i]) {
 		seq_printf(seq, "0x%03x ", ddm_table.ddm_tid & 0xFFF);
 
@@ -844,6 +849,12 @@ static int i2o_seq_show_ddm_table(struct
 		seq_printf(seq, "%8d", ddm_table.code_size);
 
 		seq_printf(seq, "\n");
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
       out:
 	kfree(result);
@@ -924,6 +935,11 @@ static int i2o_seq_show_drivers_stored(s
 	seq_printf(seq,
 		   "#  Module_type     Vendor Mod_id  Module_name             Vrs"
 		   "Date     Mod_size Par_size Flags\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, dst = &result->dst[0]; i < result->row_count;
 	     dst = &result->dst[++i]) {
 		seq_printf(seq, "%-3d", dst->stored_ddm_index);
@@ -946,6 +962,12 @@ static int i2o_seq_show_drivers_stored(s
 		seq_printf(seq, "%8d ", dst->mpb_size);
 		seq_printf(seq, "0x%04x", dst->module_flags);
 		seq_printf(seq, "\n");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(result);
diff -u -p a/acpi/acpica/exprep.c b/acpi/acpica/exprep.c
--- a/acpi/acpica/exprep.c
+++ b/acpi/acpica/exprep.c
@@ -122,7 +122,12 @@ acpi_ex_generate_access(u32 field_bit_of
 	 *
 	 * Start at byte_acc and work upwards to qword_acc max. (1,2,4,8 bytes)
 	 */
-	for (access_byte_width = 1; access_byte_width <= 8;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			for (access_byte_width = 1; access_byte_width <= 8;
 	     access_byte_width <<= 1) {
 		/*
 		 * 1) Round end offset up to next access boundary and make sure that
@@ -194,6 +199,12 @@ acpi_ex_generate_access(u32 field_bit_of
 					  minimum_access_width));
 			return_VALUE(minimum_access_width);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/acpi/pci_irq.c b/acpi/pci_irq.c
--- a/acpi/pci_irq.c
+++ b/acpi/pci_irq.c
@@ -311,11 +311,22 @@ static int bridge_has_boot_interrupt_var
 {
 	struct pci_bus *bus_it;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bus_it = bus ; bus_it ; bus_it = bus_it->parent) {
 		if (!bus_it->self)
 			return 0;
 		if (bus_it->self->irq_reroute_variant)
 			return bus_it->self->irq_reroute_variant;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/sbus/char/bbc_i2c.c b/sbus/char/bbc_i2c.c
--- a/sbus/char/bbc_i2c.c
+++ b/sbus/char/bbc_i2c.c
@@ -321,6 +321,11 @@ static struct bbc_i2c_bus * __init attac
 	spin_lock_init(&bp->lock);
 
 	entry = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dp = op->dev.of_node->child;
 	     dp && entry < 8;
 	     dp = dp->sibling, entry++) {
@@ -329,6 +334,12 @@ static struct bbc_i2c_bus * __init attac
 		child_op = of_find_device_by_node(dp);
 		bp->devs[entry].device = child_op;
 		bp->devs[entry].client_claimed = 0;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	writeb(I2C_PCF_PIN, bp->i2c_control_regs + 0x0);
diff -u -p a/pci/hotplug/cpqphp_ctrl.c b/pci/hotplug/cpqphp_ctrl.c
--- a/pci/hotplug/cpqphp_ctrl.c
+++ b/pci/hotplug/cpqphp_ctrl.c
@@ -553,6 +553,11 @@ static struct pci_resource *get_io_resou
 	if (sort_by_size(head))
 		return NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = *head; node; node = node->next) {
 		if (node->length < size)
 			continue;
@@ -619,6 +624,12 @@ static struct pci_resource *get_io_resou
 		}
 		node->next = NULL;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return node;
@@ -647,6 +658,11 @@ static struct pci_resource *get_max_reso
 	if (sort_by_max_size(head))
 		return NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (max = *head; max; max = max->next) {
 		/* If not big enough we could probably just bail,
 		 * instead we'll continue to the next.
@@ -714,6 +730,12 @@ static struct pci_resource *get_max_reso
 
 		max->next = NULL;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return max;
@@ -744,7 +766,12 @@ static struct pci_resource *get_resource
 	if (sort_by_size(head))
 		return NULL;
 
-	for (node = *head; node; node = node->next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (node = *head; node; node = node->next) {
 		dbg("%s: req_size =%x node=%p, base=%x, length=%x\n",
 		    __func__, size, node, node->base, node->length);
 		if (node->length < size)
@@ -809,6 +836,12 @@ static struct pci_resource *get_resource
 		}
 		node->next = NULL;
 		break;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return node;
 }
@@ -1142,6 +1175,11 @@ static u8 set_controller_speed(struct co
 	/* We don't allow freq/mode changes if we find another adapter running
 	 * in another slot on this controller
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(slot = ctrl->slot; slot; slot = slot->next) {
 		if (slot->device == (hp_slot + ctrl->slot_device_offset))
 			continue;
@@ -1157,6 +1195,12 @@ static u8 set_controller_speed(struct co
 			return 0;
 
 		return 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If the controller doesn't support freq/mode changes and the
diff -u -p a/pci/hotplug/acpiphp_glue.c b/pci/hotplug/acpiphp_glue.c
--- a/pci/hotplug/acpiphp_glue.c
+++ b/pci/hotplug/acpiphp_glue.c
@@ -333,11 +333,22 @@ static struct acpiphp_func *acpiphp_brid
 	struct acpiphp_func *func;
 
 	list_for_each_entry(bridge, &bridge_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (slot = bridge->slots; slot; slot = slot->next) {
 			list_for_each_entry(func, &slot->funcs, sibling) {
 				if (func->handle == handle)
 					return func;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
@@ -1019,6 +1030,11 @@ static int acpiphp_check_bridge(struct a
 
 	enabled = disabled = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (slot = bridge->slots; slot; slot = slot->next) {
 		unsigned int status = get_slot_status(slot);
 		if (slot->flags & SLOT_ENABLED) {
@@ -1042,6 +1058,12 @@ static int acpiphp_check_bridge(struct a
 			}
 			enabled++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dbg("%s: %d enabled, %d disabled\n", __func__, enabled, disabled);
diff -u -p a/pci/probe.c b/pci/probe.c
--- a/pci/probe.c
+++ b/pci/probe.c
@@ -1319,6 +1319,11 @@ int pci_scan_slot(struct pci_bus *bus, i
 	else if (dev->multifunction)
 		next_fn = next_trad_fn;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (fn = next_fn(dev, 0); fn > 0; fn = next_fn(dev, fn)) {
 		dev = pci_scan_single_device(bus, devfn + fn);
 		if (dev) {
@@ -1326,6 +1331,12 @@ int pci_scan_slot(struct pci_bus *bus, i
 				nr++;
 			dev->multifunction = 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* only one slot has pcie device */
diff -u -p a/pci/setup-bus.c b/pci/setup-bus.c
--- a/pci/setup-bus.c
+++ b/pci/setup-bus.c
@@ -199,6 +199,11 @@ static void assign_requested_resources_s
 	struct resource_list *list;
 	int idx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (list = head->next; list; list = list->next) {
 		res = list->res;
 		idx = res - &list->dev->resource[0];
@@ -214,6 +219,12 @@ static void assign_requested_resources_s
 			}
 			reset_resource(res);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/vhost/vhost.c b/vhost/vhost.c
--- a/vhost/vhost.c
+++ b/vhost/vhost.c
@@ -422,6 +422,11 @@ int vhost_zerocopy_signal_used(struct vh
 	int i;
 	int j = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = vq->done_idx; i != vq->upend_idx; i = (i + 1) % UIO_MAXIOV) {
 		if ((vq->heads[i].len == VHOST_DMA_DONE_LEN)) {
 			vq->heads[i].len = VHOST_DMA_CLEAR_LEN;
@@ -430,6 +435,12 @@ int vhost_zerocopy_signal_used(struct vh
 			++j;
 		} else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (j)
 		vq->done_idx = i;
diff -u -p a/ata/libata-core.c b/ata/libata-core.c
--- a/ata/libata-core.c
+++ b/ata/libata-core.c
@@ -5804,12 +5804,23 @@ static void ata_finalize_port_ops(struct
 
 	spin_lock(&lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur = ops->inherits; cur; cur = cur->inherits) {
 		void **inherit = (void **)cur;
 
 		for (pp = begin; pp < end; pp++, inherit++)
 			if (!*pp)
 				*pp = *inherit;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+		}
 	}
 
 	for (pp = begin; pp < end; pp++)
@@ -6460,6 +6471,11 @@ static void __init ata_parse_force_param
 	}
 
 	/* parse and populate the table */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur = ata_force_param_buf; *cur != '\0'; cur = next) {
 		const char *reason = "";
 		struct ata_force_ent te = { .port = -1, .device = -1 };
@@ -6481,6 +6497,12 @@ static void __init ata_parse_force_param
 
 		last_port = te.port;
 		last_device = te.device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ata_force_tbl_size = idx;
diff -u -p a/vlynq/vlynq.c b/vlynq/vlynq.c
--- a/vlynq/vlynq.c
+++ b/vlynq/vlynq.c
@@ -437,6 +437,11 @@ static int __vlynq_try_local(struct vlyn
 
 	vlynq_reset(dev);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = dev->dev_id ? vlynq_ldiv2 : vlynq_ldiv8; dev->dev_id ?
 			i <= vlynq_ldiv8 : i >= vlynq_ldiv2;
 		dev->dev_id ? i++ : i--) {
@@ -456,6 +461,12 @@ static int __vlynq_try_local(struct vlyn
 		} else {
 			vlynq_reset(dev);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -ENODEV;
diff -u -p a/hwmon/applesmc.c b/hwmon/applesmc.c
--- a/hwmon/applesmc.c
+++ b/hwmon/applesmc.c
@@ -172,10 +172,21 @@ static int __wait_status(u8 val)
 
 	val = val & APPLESMC_STATUS_MASK;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (us = APPLESMC_MIN_WAIT; us < APPLESMC_MAX_WAIT; us <<= 1) {
 		udelay(us);
 		if ((inb(APPLESMC_CMD_PORT) & APPLESMC_STATUS_MASK) == val)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return -EIO;
@@ -189,11 +200,22 @@ static int __wait_status(u8 val)
 static int send_command(u8 cmd)
 {
 	int us;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (us = APPLESMC_MIN_WAIT; us < APPLESMC_MAX_WAIT; us <<= 1) {
 		outb(cmd, APPLESMC_CMD_PORT);
 		udelay(us);
 		if ((inb(APPLESMC_CMD_PORT) & APPLESMC_STATUS_MASK) == 0x0c)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return -EIO;
 }
diff -u -p a/hwmon/vt1211.c b/hwmon/vt1211.c
--- a/hwmon/vt1211.c
+++ b/hwmon/vt1211.c
@@ -656,8 +656,19 @@ static ssize_t set_pwm(struct device *de
 		val = 135000 / SENSORS_LIMIT(val, 135000 >> 7, 135000);
 		/* calculate tmp = log2(val) */
 		tmp = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (val >>= 1; val > 0; val >>= 1) {
 			tmp++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		/* sync the data cache */
 		reg = vt1211_read8(data, VT1211_REG_PWM_CLK);
diff -u -p a/hwmon/lm92.c b/hwmon/lm92.c
--- a/hwmon/lm92.c
+++ b/hwmon/lm92.c
@@ -279,6 +279,11 @@ static int max6635_check(struct i2c_clie
 	   reads and time, but this should still be sufficient to dismiss
 	   non-MAX6635 chips. */
 	conf = i2c_smbus_read_byte_data(client, LM92_REG_CONFIG);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i=16; i<96; i*=2) {
 		if (temp_hyst != i2c_smbus_read_word_data(client,
 		 		 LM92_REG_TEMP_HYST + i - 16)
@@ -291,6 +296,12 @@ static int max6635_check(struct i2c_clie
 		 || conf != i2c_smbus_read_byte_data(client,
 		 	    LM92_REG_CONFIG + i))
 			return 0;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	return 1;
