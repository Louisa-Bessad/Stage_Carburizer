diff -u -p a/base/regmap/regmap.c b/base/regmap/regmap.c
--- a/base/regmap/regmap.c
+++ b/base/regmap/regmap.c
@@ -532,8 +532,20 @@ int regmap_bulk_read(struct regmap *map,
 		if (ret != 0)
 			return ret;
 
-		for (i = 0; i < val_count * val_bytes; i += val_bytes)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < val_count * val_bytes; i += val_bytes) {
 			map->format.parse_val(val + i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	} else {
 		for (i = 0; i < val_count; i++) {
 			ret = regmap_read(map, reg + i, val + (i * val_bytes));
diff -u -p a/base/regmap/regcache-rbtree.c b/base/regmap/regcache-rbtree.c
--- a/base/regmap/regcache-rbtree.c
+++ b/base/regmap/regcache-rbtree.c
@@ -253,6 +253,11 @@ static int regcache_rbtree_write(struct
 					     map->cache_word_size);
 	} else {
 		/* look for an adjacent register to the one we are about to add */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (node = rb_first(&rbtree_ctx->root); node;
 		     node = rb_next(node)) {
 			rbnode_tmp = rb_entry(node, struct regcache_rbtree_node, node);
@@ -273,6 +278,12 @@ static int regcache_rbtree_write(struct
 				rbtree_ctx->cached_rbnode = rbnode_tmp;
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* we did not manage to find a place to insert it in an existing
 		 * block so create a new rbnode with a single register in its block.
@@ -309,6 +320,11 @@ static int regcache_rbtree_sync(struct r
 	int i;
 
 	rbtree_ctx = map->cache;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&rbtree_ctx->root); node; node = rb_next(node)) {
 		rbnode = rb_entry(node, struct regcache_rbtree_node, node);
 		for (i = 0; i < rbnode->blklen; i++) {
@@ -329,6 +345,12 @@ static int regcache_rbtree_sync(struct r
 			dev_dbg(map->dev, "Synced register %#x, value %#x\n",
 				regtmp, val);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/base/power/trace.c b/base/power/trace.c
--- a/base/power/trace.c
+++ b/base/power/trace.c
@@ -173,7 +173,12 @@ static int show_file_hash(unsigned int v
 	char *tracedata;
 
 	match = 0;
-	for (tracedata = &__tracedata_start ; tracedata < &__tracedata_end ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (tracedata = &__tracedata_start ; tracedata < &__tracedata_end ;
 			tracedata += 2 + sizeof(unsigned long)) {
 		unsigned short lineno = *(unsigned short *)tracedata;
 		const char *file = *(const char **)(tracedata + 2);
@@ -182,6 +187,12 @@ static int show_file_hash(unsigned int v
 			continue;
 		pr_info("  hash matches %s:%u\n", file, lineno);
 		match++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return match;
 }
diff -u -p a/misc/lkdtm.c b/misc/lkdtm.c
--- a/misc/lkdtm.c
+++ b/misc/lkdtm.c
@@ -332,13 +332,37 @@ static void lkdtm_do_action(enum ctype w
 	}
 	case CT_SOFTLOCKUP:
 		preempt_disable();
-		for (;;)
-			cpu_relax();
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (;;) {
+		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 		break;
 	case CT_HARDLOCKUP:
 		local_irq_disable();
-		for (;;)
-			cpu_relax();
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (;;) {
+		cpu_relax();
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+		}
 		break;
 	case CT_HUNG_TASK:
 		set_current_state(TASK_UNINTERRUPTIBLE);
diff -u -p a/input/joystick/iforce/iforce-packets.c b/input/joystick/iforce/iforce-packets.c
--- a/input/joystick/iforce/iforce-packets.c
+++ b/input/joystick/iforce/iforce-packets.c
@@ -236,8 +236,20 @@ void iforce_process_packet(struct iforce
 			}
 			if (LO(cmd) > 3) {
 				int j;
-				for (j = 3; j < LO(cmd); j += 2)
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (j = 3; j < LO(cmd); j += 2) {
 					mark_core_as_ready(iforce, data[j] | (data[j+1]<<8));
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
+				}
 			}
 			break;
 	}
diff -u -p a/input/touchscreen/max11801_ts.c b/input/touchscreen/max11801_ts.c
--- a/input/touchscreen/max11801_ts.c
+++ b/input/touchscreen/max11801_ts.c
@@ -121,6 +121,11 @@ static irqreturn_t max11801_ts_interrupt
 		if (ret < XY_BUFSIZE)
 			goto out;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < XY_BUFSIZE; i += XY_BUFSIZE / 2) {
 			if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_X_TAG)
 				x = (buf[i] << XY_BUF_OFFSET) +
@@ -128,6 +133,12 @@ static irqreturn_t max11801_ts_interrupt
 			else if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_Y_TAG)
 				y = (buf[i] << XY_BUF_OFFSET) +
 				    (buf[i + 1] >> XY_BUF_OFFSET);
+				    if (_cur < timeout) {
+				    		rdstcll(_cur);
+				    }
+				    else {
+					break;
+			}
 		}
 
 		if ((buf[1] & EVENT_TAG_MASK) != (buf[3] & EVENT_TAG_MASK))
diff -u -p a/uwb/i1480/dfu/usb.c b/uwb/i1480/dfu/usb.c
--- a/uwb/i1480/dfu/usb.c
+++ b/uwb/i1480/dfu/usb.c
@@ -160,6 +160,11 @@ int i1480_usb_read(struct i1480 *i1480,
 	if (addr >= 0x8000d200 && addr < 0x8000d400)	/* Yeah, HW quirk */
 		read_size = 4;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (itr = 0; itr < size; itr += read_size) {
 		size_t itr_addr = addr + itr;
 		size_t itr_size = min(read_size, size - itr);
@@ -182,6 +187,12 @@ int i1480_usb_read(struct i1480 *i1480,
 			goto out;
 		}
 		bytes += result;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	result = bytes;
 out:
diff -u -p a/uwb/allocator.c b/uwb/allocator.c
--- a/uwb/allocator.c
+++ b/uwb/allocator.c
@@ -28,6 +28,11 @@ static void uwb_rsv_fill_column_alloc(st
 	struct uwb_rsv_col_info *ci = ai->ci;
 	unsigned char c;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (col = ci->csi.start_col; col < UWB_NUM_ZONES; col += ci->csi.interval) {
     
 		safe_mas   = ci->csi.safe_mas_per_col;
@@ -48,6 +53,12 @@ static void uwb_rsv_fill_column_alloc(st
 				bm[col * UWB_MAS_PER_ZONE + mas] = c;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/uwb/lc-rc.c b/uwb/lc-rc.c
--- a/uwb/lc-rc.c
+++ b/uwb/lc-rc.c
@@ -65,11 +65,22 @@ static int uwb_rc_new_index(void)
 {
 	int index = 0;
 
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+for (;;) {
 		if (!uwb_rc_find_by_index(index))
 			return index;
 		if (++index < 0)
 			index = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/video/atafb_mfb.c b/video/atafb_mfb.c
--- a/video/atafb_mfb.c
+++ b/video/atafb_mfb.c
@@ -65,11 +65,22 @@ void atafb_mfb_fillrect(struct fb_info *
 		else
 			fb_memclear(dest, height * (width >> 3));
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (rows = height; rows--; dest += next_line) {
 			if (color)
 				fb_memset255(dest, width >> 3);
 			else
 				fb_memclear_small(dest, width >> 3);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 }
diff -u -p a/video/fbmem.c b/video/fbmem.c
--- a/video/fbmem.c
+++ b/video/fbmem.c
@@ -207,6 +207,11 @@ static void fb_set_logocmap(struct fb_in
 	palette_cmap.blue = palette_blue;
 	palette_cmap.transp = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < logo->clutsize; i += n) {
 		n = logo->clutsize - i;
 		/* palette_cmap provides space for only 16 colors at once */
@@ -221,6 +226,12 @@ static void fb_set_logocmap(struct fb_in
 			clut += 3;
 		}
 		fb_set_cmap(&palette_cmap, info);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/ps3fb.c b/video/ps3fb.c
--- a/video/ps3fb.c
+++ b/video/ps3fb.c
@@ -657,11 +657,22 @@ static int ps3fb_set_par(struct fb_info
 	if (par->full_offset)
 		lines++;
 	maxlines = info->fix.smem_len / ddr_line_length;
-	for (dst = 0; lines; dst += maxlines * ddr_line_length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (dst = 0; lines; dst += maxlines * ddr_line_length) {
 		unsigned int l = min(lines, maxlines);
 		ps3fb_sync_image(info->device, 0, dst, 0, vmode->xres, l,
 				 ddr_line_length, ddr_line_length);
 		lines -= l;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/matrox/matroxfb_base.c b/video/matrox/matroxfb_base.c
--- a/video/matrox/matroxfb_base.c
+++ b/video/matrox/matroxfb_base.c
@@ -1309,10 +1309,34 @@ static int matroxfb_getmemory(struct mat
 	mga_outb(M_EXTVGA_DATA, orig | 0x80);
 
 	tmp = bytes;
-	for (offs = 0x100000; offs < maxSize; offs += 0x200000)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (offs = 0x100000; offs < maxSize; offs += 0x200000) {
 		*tmp++ = mga_readb(vm, offs);
-	for (offs = 0x100000; offs < maxSize; offs += 0x200000)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (offs = 0x100000; offs < maxSize; offs += 0x200000) {
 		mga_writeb(vm, offs, 0x02);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	mga_outb(M_CACHEFLUSH, 0x00);
 	for (offs = 0x100000; offs < maxSize; offs += 0x200000) {
 		if (mga_readb(vm, offs) != 0x02)
@@ -1322,8 +1346,20 @@ static int matroxfb_getmemory(struct mat
 			break;
 	}
 	tmp = bytes;
-	for (offs2 = 0x100000; offs2 < maxSize; offs2 += 0x200000)
-		mga_writeb(vm, offs2, *tmp++);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (offs2 = 0x100000; offs2 < maxSize; offs2 += 0x200000) {
+			mga_writeb(vm, offs2, *tmp++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+	}
 
 	mga_outb(M_EXTVGA_INDEX, 0x03);
 	mga_outb(M_EXTVGA_DATA, orig);
@@ -1931,6 +1967,11 @@ int matroxfb_register_driver(struct matr
 	struct matrox_fb_info* minfo;
 
 	list_add(&drv->node, &matroxfb_driver_list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (minfo = matroxfb_l(matroxfb_list.next);
 	     minfo != matroxfb_l(&matroxfb_list);
 	     minfo = matroxfb_l(minfo->next_fb.next)) {
@@ -1943,6 +1984,12 @@ int matroxfb_register_driver(struct matr
 			minfo->drivers_data[minfo->drivers_count] = p;
 			minfo->drivers[minfo->drivers_count++] = drv;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1951,6 +1998,11 @@ void matroxfb_unregister_driver(struct m
 	struct matrox_fb_info* minfo;
 
 	list_del(&drv->node);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (minfo = matroxfb_l(matroxfb_list.next);
 	     minfo != matroxfb_l(&matroxfb_list);
 	     minfo = matroxfb_l(minfo->next_fb.next)) {
@@ -1965,6 +2017,12 @@ void matroxfb_unregister_driver(struct m
 			} else
 				i++;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
diff -u -p a/video/matrox/g450_pll.c b/video/matrox/g450_pll.c
--- a/video/matrox/g450_pll.c
+++ b/video/matrox/g450_pll.c
@@ -435,6 +435,11 @@ static int __g450_setclk(struct matrox_f
 		unsigned int mnp;
 		unsigned int xvco;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (mnp = g450_firstpll(minfo, pi, &xvco, fout); mnp != NO_MORE_MNP; mnp = g450_nextpll(minfo, pi, &xvco, mnp)) {
 			unsigned int idx;
 			unsigned int vco;
@@ -485,6 +490,12 @@ static int __g450_setclk(struct matrox_f
 			mnparray[idx] = mnp;
 			deltaarray[idx] = delta;
 			mnpcount++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	/* VideoPLL and PixelPLL matched: do nothing... In all other cases we should get at least one frequency */
diff -u -p a/video/cyber2000fb.c b/video/cyber2000fb.c
--- a/video/cyber2000fb.c
+++ b/video/cyber2000fb.c
@@ -1394,8 +1394,20 @@ static void cyberpro_init_hw(struct cfb_
 {
 	int i;
 
-	for (i = 0; i < sizeof(igs_regs); i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < sizeof(igs_regs); i += 2) {
 		cyber2000_grphw(igs_regs[i], igs_regs[i + 1], cfb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	if (cfb->id == ID_CYBERPRO_5000) {
 		unsigned char val;
diff -u -p a/video/via/via-gpio.c b/video/via/via-gpio.c
--- a/video/via/via-gpio.c
+++ b/video/via/via-gpio.c
@@ -184,8 +184,20 @@ static int viafb_gpio_resume(void *priva
 {
 	int i;
 
-	for (i = 0; i < viafb_gpio_config.gpio_chip.ngpio; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < viafb_gpio_config.gpio_chip.ngpio; i += 2) {
 		viafb_gpio_enable(viafb_gpio_config.active_gpios[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	return 0;
 }
 
@@ -248,8 +260,20 @@ static __devinit int viafb_gpio_probe(st
 	 * enable bit for both.
 	 */
 	spin_lock_irqsave(&viafb_gpio_config.vdev->reg_lock, flags);
-	for (i = 0; i < ngpio; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < ngpio; i += 2) {
 		viafb_gpio_enable(viafb_gpio_config.active_gpios[i]);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+	}
 	spin_unlock_irqrestore(&viafb_gpio_config.vdev->reg_lock, flags);
 	/*
 	 * Get registered.
@@ -290,8 +314,20 @@ static int viafb_gpio_remove(struct plat
 	 * Disable the ports.
 	 */
 	spin_lock_irqsave(&viafb_gpio_config.vdev->reg_lock, flags);
-	for (i = 0; i < viafb_gpio_config.gpio_chip.ngpio; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < viafb_gpio_config.gpio_chip.ngpio; i += 2) {
 		viafb_gpio_disable(viafb_gpio_config.active_gpios[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	viafb_gpio_config.gpio_chip.ngpio = 0;
 	spin_unlock_irqrestore(&viafb_gpio_config.vdev->reg_lock, flags);
 	return ret;
diff -u -p a/video/via/accel.c b/video/via/accel.c
--- a/video/via/accel.c
+++ b/video/via/accel.c
@@ -394,8 +394,20 @@ void viafb_reset_engine(struct viafb_par
 		highest_reg = 0x40;
 		break;
 	}
-	for (i = 0; i <= highest_reg; i += 4)
-		writel(0x0, engine + i);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i <= highest_reg; i += 4) {
+	writel(0x0, engine + i);
+	if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
+	}
 
 	/* Init AGP and VQ regs */
 	switch (chip_name) {
diff -u -p a/video/omap2/vrfb.c b/video/omap2/vrfb.c
--- a/video/omap2/vrfb.c
+++ b/video/omap2/vrfb.c
@@ -104,11 +104,22 @@ void omap_vrfb_restore_context(void)
 	int i;
 	unsigned long map = ctx_map;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ffs(map); i; i = ffs(map)) {
 		/* i=1..32 */
 		i--;
 		map &= ~(1 << i);
 		restore_hw_context(i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/omap/blizzard.c b/video/omap/blizzard.c
--- a/video/omap/blizzard.c
+++ b/video/omap/blizzard.c
@@ -1377,8 +1377,20 @@ static void _save_regs(const struct bliz
 
 	for (i = 0; i < cnt; i++, list++) {
 		int reg;
-		for (reg = list->start; reg <= list->end; reg += 2)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (reg = list->start; reg <= list->end; reg += 2) {
 			blizzard_reg_cache[reg / 2] = blizzard_read_reg(reg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 }
 
@@ -1388,8 +1400,20 @@ static void _restore_regs(const struct b
 
 	for (i = 0; i < cnt; i++, list++) {
 		int reg;
-		for (reg = list->start; reg <= list->end; reg += 2)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (reg = list->start; reg <= list->end; reg += 2) {
 			blizzard_write_reg(reg, blizzard_reg_cache[reg / 2]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 }
 
diff -u -p a/video/wm8505fb.c b/video/wm8505fb.c
--- a/video/wm8505fb.c
+++ b/video/wm8505fb.c
@@ -52,8 +52,20 @@ static int wm8505fb_init_hw(struct fb_in
 	int i;
 
 	/* I know the purpose only of few registers, so clear unknown */
-	for (i = 0; i < 0x200; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 0x200; i += 4) {
 		writel(0, fbi->regbase + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* Set frame buffer address */
 	writel(fbi->fb.fix.smem_start, fbi->regbase + WMT_GOVR_FBADDR);
diff -u -p a/video/riva/riva_hw.c b/video/riva/riva_hw.c
--- a/video/riva/riva_hw.c
+++ b/video/riva/riva_hw.c
@@ -538,8 +538,18 @@ static char nv3_get_param(nv3_fifo_info
     done = 0;
     for (p=0; p < 2; p++)
     {
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for (g=128 ; g > 32; g= g>> 1)
         {
+            unsigned long long delta = (cpu / khz / HZ) * 2;
+            unsigned long long _start = 0;
+            unsigned long long _cur = 0;
+            unsigned long long timeout;
+            timeout = rdstcll(start) + delta;
             for (v=128; v >=32; v = v>> 1)
             {
                 ainfo->priority = p;
@@ -551,6 +561,18 @@ static char nv3_get_param(nv3_fifo_info
                         done = 0;
                 if (done)
                     goto Done;
+                    if (_cur < timeout) {
+                        rdstcll(_cur);
+                    }
+                    else {
+                        break;
+                    }
+            }
+            if (_cur < timeout) {
+                    rdstcll(_cur);
+            }
+            else {
+                    break;
             }
         }
     }
diff -u -p a/video/fbsysfs.c b/video/fbsysfs.c
--- a/video/fbsysfs.c
+++ b/video/fbsysfs.c
@@ -475,17 +475,29 @@ static ssize_t show_bl_curve(struct devi
 		return -ENODEV;
 
 	mutex_lock(&fb_info->bl_curve_mutex);
-	for (i = 0; i < FB_BACKLIGHT_LEVELS; i += 8)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < FB_BACKLIGHT_LEVELS; i += 8) {
 		len += snprintf(&buf[len], PAGE_SIZE,
-				"%02x %02x %02x %02x %02x %02x %02x %02x\n",
-				fb_info->bl_curve[i + 0],
-				fb_info->bl_curve[i + 1],
-				fb_info->bl_curve[i + 2],
-				fb_info->bl_curve[i + 3],
-				fb_info->bl_curve[i + 4],
-				fb_info->bl_curve[i + 5],
-				fb_info->bl_curve[i + 6],
-				fb_info->bl_curve[i + 7]);
+		"%02x %02x %02x %02x %02x %02x %02x %02x\n",
+		fb_info->bl_curve[i + 0],
+		fb_info->bl_curve[i + 1],
+		fb_info->bl_curve[i + 2],
+		fb_info->bl_curve[i + 3],
+		fb_info->bl_curve[i + 4],
+		fb_info->bl_curve[i + 5],
+		fb_info->bl_curve[i + 6],
+		fb_info->bl_curve[i + 7]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	mutex_unlock(&fb_info->bl_curve_mutex);
 
 	return len;
diff -u -p a/video/aty/aty128fb.c b/video/aty/aty128fb.c
--- a/video/aty/aty128fb.c
+++ b/video/aty/aty128fb.c
@@ -607,6 +607,11 @@ static void do_wait_for_fifo(u16 entries
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		for (i = 0; i < 2000000; i++) {
 			par->fifo_slots = aty_ld_le32(GUI_STAT) & 0x0fff;
@@ -614,6 +619,12 @@ static void do_wait_for_fifo(u16 entries
 				return;
 		}
 		aty128_reset_engine(par);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -624,6 +635,11 @@ static void wait_for_idle(struct aty128f
 
 	do_wait_for_fifo(64, par);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		for (i = 0; i < 2000000; i++) {
 			if (!(aty_ld_le32(GUI_STAT) & (1 << 31))) {
@@ -633,6 +649,12 @@ static void wait_for_idle(struct aty128f
 			}
 		}
 		aty128_reset_engine(par);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/sm501fb.c b/video/sm501fb.c
--- a/video/sm501fb.c
+++ b/video/sm501fb.c
@@ -1125,8 +1125,20 @@ static int sm501fb_cursor(struct fb_info
 		dev_dbg(fbi->dev, "%s: setting shape (%d,%d)\n",
 			__func__, cursor->image.width, cursor->image.height);
 
-		for (op = 0; op < (64*64*2)/8; op+=4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (op = 0; op < (64*64*2)/8; op+=4) {
 			smc501_writel(0x0, dst + op);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 
 		for (y = 0; y < cursor->image.height; y++) {
 			for (x = 0; x < cursor->image.width; x++) {
@@ -1228,9 +1240,21 @@ static int sm501fb_show_regs(struct sm50
 	char *buf = ptr;
 	unsigned int reg;
 
-	for (reg = start; reg < (len + start); reg += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (reg = start; reg < (len + start); reg += 4) {
 		ptr += sprintf(ptr, "%08x = %08x\n", reg,
-				smc501_readl(mem + reg));
+		smc501_readl(mem + reg));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	return ptr - buf;
 }
diff -u -p a/video/tgafb.c b/video/tgafb.c
--- a/video/tgafb.c
+++ b/video/tgafb.c
@@ -1023,8 +1023,20 @@ tgafb_fillrect(struct fb_info *info, con
 		ldata = ((width & 2047) - 1) | align;
 
 		for (i = 0; i < height; ++i) {
-			for (j = 0; j < nwidth; j += 2048)
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; j < nwidth; j += 2048) {
 				__raw_writel(fdata, fb_base + pos + j*Bpp);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
 			if (j < width)
 				__raw_writel(ldata, fb_base + pos + j*Bpp);
 			pos += line_length;
diff -u -p a/nubus/proc.c b/nubus/proc.c
--- a/nubus/proc.c
+++ b/nubus/proc.c
@@ -162,8 +162,20 @@ void __init proc_bus_nubus_add_devices(v
 {
 	struct nubus_dev *dev;
 	
-	for(dev = nubus_devices; dev; dev = dev->next)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for(dev = nubus_devices; dev; dev = dev->next) {
 		nubus_proc_attach_device(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 void __init nubus_proc_init(void)
diff -u -p a/edac/mpc85xx_edac.c b/edac/mpc85xx_edac.c
--- a/edac/mpc85xx_edac.c
+++ b/edac/mpc85xx_edac.c
@@ -729,8 +729,20 @@ static u8 syndrome_from_bit(unsigned int
 	 * ecc_table depending on if 'bit' is in the upper or lower half of
 	 * 64-bit data.
 	 */
-	for (i = bit < 32; i < 16; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = bit < 32; i < 16; i += 2) {
 		syndrome |= ((ecc_table[i] >> (bit % 32)) & 1) << (i / 2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	return syndrome;
 }
diff -u -p a/firmware/pcdp.c b/firmware/pcdp.c
--- a/firmware/pcdp.c
+++ b/firmware/pcdp.c
@@ -119,6 +119,11 @@ efi_setup_pcdp_console(char *cmdline)
 	}
 
 	end = (struct pcdp_device *) ((u8 *) pcdp + pcdp->length);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = (struct pcdp_device *) (pcdp->uart + pcdp->num_uarts);
 	     dev < end;
 	     dev = (struct pcdp_device *) ((u8 *) dev + dev->length)) {
@@ -128,6 +133,12 @@ efi_setup_pcdp_console(char *cmdline)
 				goto out;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out:
diff -u -p a/firmware/dmi_scan.c b/firmware/dmi_scan.c
--- a/firmware/dmi_scan.c
+++ b/firmware/dmi_scan.c
@@ -671,13 +671,24 @@ const struct dmi_device * dmi_find_devic
 	const struct list_head *head = from ? &from->list : &dmi_devices;
 	struct list_head *d;
 
-	for(d = head->next; d != &dmi_devices; d = d->next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for(d = head->next; d != &dmi_devices; d = d->next) {
 		const struct dmi_device *dev =
 			list_entry(d, struct dmi_device, list);
 
 		if (((type == DMI_DEV_TYPE_ANY) || (dev->type == type)) &&
 		    ((name == NULL) || (strcmp(dev->name, name) == 0)))
 			return dev;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NULL;
diff -u -p a/of/base.c b/of/base.c
--- a/of/base.c
+++ b/of/base.c
@@ -497,11 +497,22 @@ struct device_node *of_find_node_with_pr
 	read_lock(&devtree_lock);
 	np = from ? from->allnext : allnodes;
 	for (; np; np = np->allnext) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (pp = np->properties; pp != 0; pp = pp->next) {
 			if (of_prop_cmp(pp->name, prop_name) == 0) {
 				of_node_get(np);
 				goto out;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 out:
@@ -750,12 +761,23 @@ int of_property_read_string_index(struct
 
 	p = prop->value;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; total < prop->length; total += l, p += l) {
 		l = strlen(p) + 1;
 		if ((*p != 0) && (i++ == index)) {
 			*output = p;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -ENODATA;
 }
@@ -790,10 +812,21 @@ int of_property_count_strings(struct dev
 
 	p = prop->value;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; total < prop->length; total += l, p += l) {
 		l = strlen(p) + 1;
 		if (*p != 0)
 			i++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return i;
 }
diff -u -p a/infiniband/hw/ipath/ipath_driver.c b/infiniband/hw/ipath/ipath_driver.c
--- a/infiniband/hw/ipath/ipath_driver.c
+++ b/infiniband/hw/ipath/ipath_driver.c
@@ -1176,6 +1176,11 @@ void ipath_kreceive(struct ipath_portdat
 	}
 
 reloop:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last = 0, i = 1; !last; i += !last) {
 		hdr = dd->ipath_f_get_msgheader(dd, rhf_addr);
 		eflags = ipath_hdrget_err_flags(rhf_addr);
@@ -1286,6 +1291,12 @@ reloop:
 				updegr = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!dd->ipath_rhdrhead_intr_off && !reloop &&
diff -u -p a/infiniband/hw/ipath/ipath_user_pages.c b/infiniband/hw/ipath/ipath_user_pages.c
--- a/infiniband/hw/ipath/ipath_user_pages.c
+++ b/infiniband/hw/ipath/ipath_user_pages.c
@@ -70,13 +70,24 @@ static int __ipath_get_user_pages(unsign
 	ipath_cdbg(VERBOSE, "pin %lx pages from vaddr %lx\n",
 		   (unsigned long) num_pages, start_page);
 
-	for (got = 0; got < num_pages; got += ret) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (got = 0; got < num_pages; got += ret) {
 		ret = get_user_pages(current, current->mm,
 				     start_page + got * PAGE_SIZE,
 				     num_pages - got, 1, 1,
 				     p + got, vma);
 		if (ret < 0)
 			goto bail_release;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	current->mm->pinned_vm += num_pages;
diff -u -p a/infiniband/hw/ipath/ipath_cq.c b/infiniband/hw/ipath/ipath_cq.c
--- a/infiniband/hw/ipath/ipath_cq.c
+++ b/infiniband/hw/ipath/ipath_cq.c
@@ -175,6 +175,11 @@ static void send_complete(unsigned long
 	 * won't call us again until we return so we check triggered to
 	 * see if we need to call the handler again.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		u8 triggered = cq->triggered;
 
@@ -182,6 +187,12 @@ static void send_complete(unsigned long
 
 		if (cq->triggered == triggered)
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/infiniband/hw/qib/qib_user_pages.c b/infiniband/hw/qib/qib_user_pages.c
--- a/infiniband/hw/qib/qib_user_pages.c
+++ b/infiniband/hw/qib/qib_user_pages.c
@@ -65,13 +65,24 @@ static int __qib_get_user_pages(unsigned
 		goto bail;
 	}
 
-	for (got = 0; got < num_pages; got += ret) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (got = 0; got < num_pages; got += ret) {
 		ret = get_user_pages(current, current->mm,
 				     start_page + got * PAGE_SIZE,
 				     num_pages - got, 1, 1,
 				     p + got, vma);
 		if (ret < 0)
 			goto bail_release;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	current->mm->pinned_vm += num_pages;
diff -u -p a/infiniband/hw/qib/qib_cq.c b/infiniband/hw/qib/qib_cq.c
--- a/infiniband/hw/qib/qib_cq.c
+++ b/infiniband/hw/qib/qib_cq.c
@@ -174,6 +174,11 @@ static void send_complete(struct work_st
 	 * won't call us again until we return so we check triggered to
 	 * see if we need to call the handler again.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		u8 triggered = cq->triggered;
 
@@ -189,6 +194,12 @@ static void send_complete(struct work_st
 
 		if (cq->triggered == triggered)
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/infiniband/hw/qib/qib_mad.c b/infiniband/hw/qib/qib_mad.c
--- a/infiniband/hw/qib/qib_mad.c
+++ b/infiniband/hw/qib/qib_mad.c
@@ -1042,9 +1042,22 @@ static int subn_get_sl_to_vl(struct ib_s
 
 	if (!(ibp->port_cap_flags & IB_PORT_SL_MAP_SUP))
 		smp->status |= IB_SMP_UNSUP_METHOD;
-	else
-		for (i = 0; i < ARRAY_SIZE(ibp->sl_to_vl); i += 2)
+	else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < ARRAY_SIZE(ibp->sl_to_vl); i += 2) {
 			*p++ = (ibp->sl_to_vl[i] << 4) | ibp->sl_to_vl[i + 1];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+	}
 
 	return reply(smp);
 }
diff -u -p a/infiniband/hw/qib/qib_driver.c b/infiniband/hw/qib/qib_driver.c
--- a/infiniband/hw/qib/qib_driver.c
+++ b/infiniband/hw/qib/qib_driver.c
@@ -469,6 +469,11 @@ u32 qib_kreceive(struct qib_ctxtdata *rc
 		smp_rmb();  /* prevent speculative reads of dma'ed hdrq */
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last = 0, i = 1; !last; i += !last) {
 		hdr = dd->f_get_msgheader(dd, rhf_addr);
 		eflags = qib_hdrget_err_flags(rhf_addr);
@@ -542,6 +547,12 @@ move_along:
 			dd->f_update_usrhead(rcd, lval, updegr, etail, i);
 			updegr = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * Notify qib_destroy_qp() if it is waiting
diff -u -p a/infiniband/hw/cxgb3/cxio_resource.c b/infiniband/hw/cxgb3/cxio_resource.c
--- a/infiniband/hw/cxgb3/cxio_resource.c
+++ b/infiniband/hw/cxgb3/cxio_resource.c
@@ -329,11 +329,24 @@ int cxio_hal_rqtpool_create(struct cxio_
 {
 	unsigned long i;
 	rdev_p->rqt_pool = gen_pool_create(MIN_RQT_SHIFT, -1);
-	if (rdev_p->rqt_pool)
+	if (rdev_p->rqt_pool) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = rdev_p->rnic_info.rqt_base;
-		     i <= rdev_p->rnic_info.rqt_top - RQT_CHUNK + 1;
-		     i += RQT_CHUNK)
+		i <= rdev_p->rnic_info.rqt_top - RQT_CHUNK + 1;
+		i += RQT_CHUNK) {
 			gen_pool_add(rdev_p->rqt_pool, i, RQT_CHUNK, -1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+	}
 	return rdev_p->rqt_pool ? 0 : -ENOMEM;
 }
 
diff -u -p a/infiniband/hw/mthca/mthca_qp.c b/infiniband/hw/mthca/mthca_qp.c
--- a/infiniband/hw/mthca/mthca_qp.c
+++ b/infiniband/hw/mthca/mthca_qp.c
@@ -1827,6 +1827,11 @@ int mthca_tavor_post_receive(struct ib_q
 
 	ind = qp->rq.next_ind;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (nreq = 0; wr; wr = wr->next) {
 		if (mthca_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {
 			mthca_err(dev, "RQ %06x full (%u head, %u tail,"
@@ -1886,7 +1891,13 @@ int mthca_tavor_post_receive(struct ib_q
 			qp->rq.next_ind = ind;
 			qp->rq.head += MTHCA_TAVOR_MAX_WQES_PER_RECV_DB;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 out:
 	if (likely(nreq)) {
diff -u -p a/infiniband/hw/mthca/mthca_cmd.c b/infiniband/hw/mthca/mthca_cmd.c
--- a/infiniband/hw/mthca/mthca_cmd.c
+++ b/infiniband/hw/mthca/mthca_cmd.c
@@ -670,6 +670,11 @@ static int mthca_map_cmd(struct mthca_de
 	memset(mailbox->buf, 0, MTHCA_MAILBOX_SIZE);
 	pages = mailbox->buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mthca_icm_first(icm, &iter);
 	     !mthca_icm_last(&iter);
 	     mthca_icm_next(&iter)) {
@@ -707,6 +712,12 @@ static int mthca_map_cmd(struct mthca_de
 				nent = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nent)
diff -u -p a/infiniband/hw/mthca/mthca_memfree.c b/infiniband/hw/mthca/mthca_memfree.c
--- a/infiniband/hw/mthca/mthca_memfree.c
+++ b/infiniband/hw/mthca/mthca_memfree.c
@@ -324,10 +324,21 @@ int mthca_table_get_range(struct mthca_d
 	int inc = MTHCA_TABLE_CHUNK_SIZE / table->obj_size;
 	int i, err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i <= end; i += inc) {
 		err = mthca_table_get(dev, table, i);
 		if (err)
 			goto fail;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -349,8 +360,20 @@ void mthca_table_put_range(struct mthca_
 	if (!mthca_is_memfree(dev))
 		return;
 
-	for (i = start; i <= end; i += MTHCA_TABLE_CHUNK_SIZE / table->obj_size)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = start; i <= end; i += MTHCA_TABLE_CHUNK_SIZE / table->obj_size) {
 		mthca_table_put(dev, table, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 struct mthca_icm_table *mthca_alloc_icm_table(struct mthca_dev *dev,
diff -u -p a/infiniband/hw/ehca/ipz_pt_fn.c b/infiniband/hw/ehca/ipz_pt_fn.c
--- a/infiniband/hw/ehca/ipz_pt_fn.c
+++ b/infiniband/hw/ehca/ipz_pt_fn.c
@@ -118,9 +118,21 @@ static int alloc_queue_pages(struct ipz_
 	return 1;
 
 out:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (f = 0; f < nr_of_pages && queue->queue_pages[f];
-	     f += PAGES_PER_KPAGE)
-		free_page((unsigned long)(queue->queue_pages)[f]);
+	     f += PAGES_PER_KPAGE) {
+	free_page((unsigned long)(queue->queue_pages)[f]);
+	if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
+	}
 	return 0;
 }
 
@@ -265,8 +277,20 @@ int ipz_queue_dtor(struct ehca_pd *pd, s
 		free_small_queue_page(queue, pd);
 	else {
 		nr_pages = queue->queue_length / queue->pagesize;
-		for (i = 0; i < nr_pages; i += PAGES_PER_KPAGE)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < nr_pages; i += PAGES_PER_KPAGE) {
 			free_page((unsigned long)queue->queue_pages[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 
 	if (is_vmalloc_addr(queue->queue_pages))
diff -u -p a/infiniband/core/user_mad.c b/infiniband/core/user_mad.c
--- a/infiniband/core/user_mad.c
+++ b/infiniband/core/user_mad.c
@@ -289,7 +289,12 @@ static ssize_t copy_recv_mad(struct ib_u
 		offset = ib_get_mad_data_offset(recv_buf->mad->mad_hdr.mgmt_class);
 		max_seg_payload = sizeof (struct ib_mad) - offset;
 
-		for (left = packet->length - seg_payload, buf += seg_payload;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (left = packet->length - seg_payload, buf += seg_payload;
 		     left; left -= seg_payload, buf += seg_payload) {
 			recv_buf = container_of(recv_buf->list.next,
 						struct ib_mad_recv_buf, list);
@@ -297,6 +302,12 @@ static ssize_t copy_recv_mad(struct ib_u
 			if (copy_to_user(buf, ((void *) recv_buf->mad) + offset,
 					 seg_payload))
 				return -EFAULT;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 	}
 	return hdr_size(file) + packet->length;
diff -u -p a/infiniband/core/multicast.c b/infiniband/core/multicast.c
--- a/infiniband/core/multicast.c
+++ b/infiniband/core/multicast.c
@@ -754,6 +754,11 @@ static void mcast_groups_event(struct mc
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&port->table); node; node = rb_next(node)) {
 		group = rb_entry(node, struct mcast_group, node);
 		spin_lock(&group->lock);
@@ -764,6 +769,12 @@ static void mcast_groups_event(struct mc
 		if (group->state != MCAST_GROUP_ERROR)
 			group->state = state;
 		spin_unlock(&group->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&port->lock, flags);
 }
diff -u -p a/infiniband/core/mad.c b/infiniband/core/mad.c
--- a/infiniband/core/mad.c
+++ b/infiniband/core/mad.c
@@ -834,6 +834,11 @@ static int alloc_send_rmpp_list(struct i
 	pad = send_wr->pad;
 
 	/* Allocate data segments. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (left = send_buf->data_len + pad; left > 0; left -= seg_size) {
 		seg = kmalloc(sizeof (*seg) + seg_size, gfp_mask);
 		if (!seg) {
@@ -845,6 +850,12 @@ static int alloc_send_rmpp_list(struct i
 		}
 		seg->num = ++send_buf->seg_count;
 		list_add_tail(&seg->list, &send_wr->rmpp_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Zero any padding */
diff -u -p a/scsi/device_handler/scsi_dh_alua.c b/scsi/device_handler/scsi_dh_alua.c
--- a/scsi/device_handler/scsi_dh_alua.c
+++ b/scsi/device_handler/scsi_dh_alua.c
@@ -546,12 +546,23 @@ static int alua_rtpg(struct scsi_device
 		goto retry;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = 4, ucp = h->buff + 4; k < len; k += off, ucp += off) {
 		if (h->group_id == (ucp[2] << 8) + ucp[3]) {
 			h->state = ucp[0] & 0x0f;
 			valid_states = ucp[1];
 		}
 		off = 8 + (ucp[7] * 4);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sdev_printk(KERN_INFO, sdev,
diff -u -p a/scsi/lpfc/lpfc_attr.c b/scsi/lpfc/lpfc_attr.c
--- a/scsi/lpfc/lpfc_attr.c
+++ b/scsi/lpfc/lpfc_attr.c
@@ -3911,10 +3911,22 @@ sysfs_ctlreg_write(struct file *filp, st
 		return -EPERM;
 
 	spin_lock_irq(&phba->hbalock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (buf_off = 0; buf_off < count - LPFC_REG_WRITE_KEY_SIZE;
-			buf_off += sizeof(uint32_t))
+			buf_off += sizeof(uint32_t)) {
 		writel(*((uint32_t *)(buf + buf_off + LPFC_REG_WRITE_KEY_SIZE)),
-		       phba->ctrl_regs_memmap_p + off + buf_off);
+		phba->ctrl_regs_memmap_p + off + buf_off);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	spin_unlock_irq(&phba->hbalock);
 
diff -u -p a/scsi/qlogicfas.c b/scsi/qlogicfas.c
--- a/scsi/qlogicfas.c
+++ b/scsi/qlogicfas.c
@@ -216,8 +216,20 @@ static __exit void qlogicfas_exit(void)
 {
 	struct qlogicfas408_priv *priv;
 
-	for (priv = cards; priv != NULL; priv = priv->next)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (priv = cards; priv != NULL; priv = priv->next) {
 		qlogicfas_release(priv->shost);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 MODULE_AUTHOR("Tom Zerucha, Michael Griffith");
diff -u -p a/scsi/NCR5380.c b/scsi/NCR5380.c
--- a/scsi/NCR5380.c
+++ b/scsi/NCR5380.c
@@ -757,12 +757,36 @@ static int __maybe_unused NCR5380_proc_i
 	else
 		pos = lprint_Scsi_Cmnd((Scsi_Cmnd *) hostdata->connected, pos, buffer, length);
 	SPRINTF("scsi%d: issue_queue\n", instance->host_no);
-	for (ptr = (Scsi_Cmnd *) hostdata->issue_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (ptr = (Scsi_Cmnd *) hostdata->issue_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble) {
 		pos = lprint_Scsi_Cmnd(ptr, pos, buffer, length);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 
 	SPRINTF("scsi%d: disconnected_queue\n", instance->host_no);
-	for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble) {
 		pos = lprint_Scsi_Cmnd(ptr, pos, buffer, length);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 	spin_unlock_irq(instance->host_lock);
 	
 	*start = buffer;
diff -u -p a/scsi/wd33c93.c b/scsi/wd33c93.c
--- a/scsi/wd33c93.c
+++ b/scsi/wd33c93.c
@@ -569,15 +569,38 @@ wd33c93_execute(struct Scsi_Host *instan
 		goto yes;
 	if (!(hostdata->input_Q))	/* input_Q empty? */
 		goto no;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = (struct scsi_cmnd *) hostdata->input_Q; prev;
 	     prev = (struct scsi_cmnd *) prev->host_scribble) {
 		if ((prev->device->id != cmd->device->id) ||
 		    (prev->device->lun != cmd->device->lun)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (prev = (struct scsi_cmnd *) hostdata->input_Q; prev;
-			     prev = (struct scsi_cmnd *) prev->host_scribble)
-				prev->SCp.phase = 1;
+			     prev = (struct scsi_cmnd *) prev->host_scribble) {
+		prev->SCp.phase = 1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+			}
 			goto yes;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	goto no;
diff -u -p a/scsi/aha152x.c b/scsi/aha152x.c
--- a/scsi/aha152x.c
+++ b/scsi/aha152x.c
@@ -1812,6 +1812,11 @@ static void seldi_run(struct Scsi_Host *
  */
 static void msgi_run(struct Scsi_Host *shpnt)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(;;) {
 		int sstat1 = GETPORT(SSTAT1);
 
@@ -1980,6 +1985,12 @@ static void msgi_run(struct Scsi_Host *s
 		}
 
 		MSGILEN=0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2959,8 +2970,20 @@ static void show_queues(struct Scsi_Host
 
 	DO_LOCK(flags);
 	printk(KERN_DEBUG "\nqueue status:\nissue_SC:\n");
-	for (ptr = ISSUE_SC; ptr; ptr = SCNEXT(ptr))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (ptr = ISSUE_SC; ptr; ptr = SCNEXT(ptr)) {
 		show_command(ptr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	DO_UNLOCK(flags);
 
 	printk(KERN_DEBUG "current_SC:\n");
@@ -2970,8 +2993,20 @@ static void show_queues(struct Scsi_Host
 		printk(KERN_DEBUG "none\n");
 
 	printk(KERN_DEBUG "disconnected_SC:\n");
-	for (ptr = DISCONNECTED_SC; ptr; ptr = SCDATA(ptr) ? SCNEXT(ptr) : NULL)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (ptr = DISCONNECTED_SC; ptr; ptr = SCDATA(ptr) ? SCNEXT(ptr) : NULL) {
 		show_command(ptr);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 
 	disp_ports(shpnt);
 	disp_enintr(shpnt);
@@ -3392,8 +3427,20 @@ static int aha152x_proc_info(struct Scsi
 	DO_LOCK(flags);
 	if (ISSUE_SC) {
 		SPRINTF("not yet issued commands:\n");
-		for (ptr = ISSUE_SC; ptr; ptr = SCNEXT(ptr))
-			pos += get_command(pos, ptr);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (ptr = ISSUE_SC; ptr; ptr = SCNEXT(ptr)) {
+	pos += get_command(pos, ptr);
+	if (_cur < timeout) {
+				rdstcll(_cur);
+	}
+	else {
+				break;
+	}
+		}
 	} else
 		SPRINTF("no not yet issued commands\n");
 	DO_UNLOCK(flags);
@@ -3406,8 +3453,20 @@ static int aha152x_proc_info(struct Scsi
 
 	if (DISCONNECTED_SC) {
 		SPRINTF("disconnected commands:\n");
-		for (ptr = DISCONNECTED_SC; ptr; ptr = SCNEXT(ptr))
-			pos += get_command(pos, ptr);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (ptr = DISCONNECTED_SC; ptr; ptr = SCNEXT(ptr)) {
+		pos += get_command(pos, ptr);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+		}
 	} else
 		SPRINTF("no disconnected commands\n");
 
diff -u -p a/scsi/dc395x.c b/scsi/dc395x.c
--- a/scsi/dc395x.c
+++ b/scsi/dc395x.c
@@ -4252,8 +4252,20 @@ static void adapter_sg_tables_free(struc
 	int i;
 	const unsigned srbs_per_page = PAGE_SIZE/SEGMENTX_LEN;
 
-	for (i = 0; i < DC395x_MAX_SRB_CNT; i += srbs_per_page)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < DC395x_MAX_SRB_CNT; i += srbs_per_page) {
 		kfree(acb->srb_array[i].segment_x);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 
diff -u -p a/scsi/atari_NCR5380.c b/scsi/atari_NCR5380.c
--- a/scsi/atari_NCR5380.c
+++ b/scsi/atari_NCR5380.c
@@ -795,17 +795,39 @@ static int NCR5380_proc_info(struct Scsi
 				       pos, buffer, length);
 	SPRINTF("scsi%d: issue_queue\n", HOSTNO);
 	check_offset();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = (Scsi_Cmnd *)hostdata->issue_queue; ptr; ptr = NEXT(ptr)) {
 		pos = lprint_Scsi_Cmnd(ptr, pos, buffer, length);
 		check_offset();
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	SPRINTF("scsi%d: disconnected_queue\n", HOSTNO);
 	check_offset();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr;
 	     ptr = NEXT(ptr)) {
 		pos = lprint_Scsi_Cmnd(ptr, pos, buffer, length);
 		check_offset();
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	local_irq_restore(flags);
@@ -2721,6 +2743,11 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 	 * Case 2 : If the command hasn't been issued yet, we simply remove it
 	 *	    from the issue queue.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = (Scsi_Cmnd **)&(hostdata->issue_queue),
 	     tmp = (Scsi_Cmnd *)hostdata->issue_queue;
 	     tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp)) {
@@ -2738,6 +2765,12 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 			falcon_release_lock_if_possible(hostdata);
 			return SCSI_ABORT_SUCCESS;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -2782,6 +2815,11 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 	 * it from the disconnected queue.
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tmp = (Scsi_Cmnd *) hostdata->disconnected_queue; tmp;
 	     tmp = NEXT(tmp)) {
 		if (cmd == tmp) {
@@ -2796,6 +2834,11 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 			do_abort(instance);
 
 			local_irq_save(flags);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (prev = (Scsi_Cmnd **)&(hostdata->disconnected_queue),
 			     tmp = (Scsi_Cmnd *)hostdata->disconnected_queue;
 			     tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp)) {
@@ -2818,8 +2861,20 @@ int NCR5380_abort(Scsi_Cmnd *cmd)
 					falcon_release_lock_if_possible(hostdata);
 					return SCSI_ABORT_SUCCESS;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/scsi/initio.c b/scsi/initio.c
--- a/scsi/initio.c
+++ b/scsi/initio.c
@@ -1102,6 +1102,11 @@ static int tulip_main(struct initio_host
 {
 	struct scsi_ctrl_blk *scb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		tulip_scsi(host);	/* Call tulip_scsi              */
 
@@ -1166,6 +1171,12 @@ static int tulip_main(struct initio_host
 		/* Check pending SCB            */
 		if (initio_find_first_pend_scb(host) == NULL)
 			return 1;	/* return to OS, enable interrupt */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}			/* End of for loop */
 	/* statement won't reach here */
 }
@@ -1280,7 +1291,12 @@ static int initio_next_state(struct init
 	int next;
 
 	next = host->active->next_state;
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		switch (next) {
 		case 1:
 			next = initio_state_1(host);
@@ -1310,6 +1326,12 @@ static int initio_next_state(struct init
 		}
 		if (next <= 0)
 			return next;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1414,6 +1436,11 @@ static int initio_state_3(struct initio_
 #if DEBUG_STATE
 	printk("-s3-");
 #endif
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		switch (host->phase) {
 		case CMD_OUT:	/* Command out phase            */
@@ -1462,6 +1489,12 @@ static int initio_state_3(struct initio_
 		default:
 			return initio_bad_seq(host);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1482,6 +1515,11 @@ static int initio_state_4(struct initio_
 	if ((scb->flags & SCF_DIR) == SCF_NO_XF) {
 		return 6;	/* Go to state 6 (After data) */
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		if (scb->buflen == 0)
 			return 6;
@@ -1525,6 +1563,12 @@ static int initio_state_4(struct initio_
 		default:
 			return initio_bad_seq(host);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1632,6 +1676,11 @@ static int initio_state_6(struct initio_
 #if DEBUG_STATE
 	printk("-s6-");
 #endif
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		switch (host->phase) {
 		case STATUS_IN:	/* Status phase                 */
@@ -1661,6 +1710,12 @@ static int initio_state_6(struct initio_
 		default:
 			return initio_bad_seq(host);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1763,7 +1818,12 @@ int initio_xpad_in(struct initio_host *
 
 	if ((scb->flags & SCF_DIR) != SCF_NO_DCHK)
 		scb->hastat = HOST_DO_DU;	/* over run             */
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		if (active_tc->js_period & TSC_WIDE_SCSI)
 			outl(2, host->addr + TUL_SCnt0);
 		else
@@ -1777,6 +1837,12 @@ int initio_xpad_in(struct initio_host *
 			return 6;
 		}
 		inb(host->addr + TUL_SFifo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1787,7 +1853,12 @@ int initio_xpad_out(struct initio_host *
 
 	if ((scb->flags & SCF_DIR) != SCF_NO_DCHK)
 		scb->hastat = HOST_DO_DU;	/* over run             */
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		if (active_tc->js_period & TSC_WIDE_SCSI)
 			outl(2, host->addr + TUL_SCnt0);
 		else
@@ -1802,6 +1873,12 @@ int initio_xpad_out(struct initio_host *
 			outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
 			return 6;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2080,6 +2157,11 @@ static int initio_msgin(struct initio_ho
 {
 	struct target_control *active_tc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
 
@@ -2122,6 +2204,12 @@ static int initio_msgin(struct initio_ho
 		}
 		if (host->phase != MSG_IN)
 			return host->phase;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	/* statement won't reach here */
 }
diff -u -p a/scsi/scsi_scan.c b/scsi/scsi_scan.c
--- a/scsi/scsi_scan.c
+++ b/scsi/scsi_scan.c
@@ -1252,9 +1252,21 @@ int scsilun_to_int(struct scsi_lun *scsi
 	unsigned int lun;
 
 	lun = 0;
-	for (i = 0; i < sizeof(lun); i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < sizeof(lun); i += 2) {
 		lun = lun | (((scsilun->scsi_lun[i] << 8) |
-			      scsilun->scsi_lun[i + 1]) << (i * 8));
+		scsilun->scsi_lun[i + 1]) << (i * 8));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	return lun;
 }
 EXPORT_SYMBOL(scsilun_to_int);
diff -u -p a/scsi/ncr53c8xx.c b/scsi/ncr53c8xx.c
--- a/scsi/ncr53c8xx.c
+++ b/scsi/ncr53c8xx.c
@@ -5230,9 +5230,21 @@ void ncr_init (struct ncb *np, int reset
 	**	Clear Start Queue
 	*/
 	np->queuedepth = MAX_START - 1;	/* 1 entry needed as end marker */
-	for (i = 1; i < MAX_START + MAX_START; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (i = 1; i < MAX_START + MAX_START; i += 2) {
 		np->scripth0->tryloop[i] =
-				cpu_to_scr(NCB_SCRIPT_PHYS (np, idle));
+		cpu_to_scr(NCB_SCRIPT_PHYS (np, idle));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+				}
 
 	/*
 	**	Start at first entry.
@@ -5509,7 +5521,12 @@ static void ncr_set_sync_wide_status (st
 	/*
 	**	patch ALL ccbs of this target.
 	*/
-	for (cp = np->ccb; cp; cp = cp->link_ccb) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+for (cp = np->ccb; cp; cp = cp->link_ccb) {
 		if (!cp->cmd) continue;
 		if (scmd_id(cp->cmd) != target) continue;
 #if 0
@@ -5518,6 +5535,12 @@ static void ncr_set_sync_wide_status (st
 #endif
 		cp->phys.select.sel_scntl3 = tp->wval;
 		cp->phys.select.sel_sxfer  = tp->sval;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/scsi/bnx2fc/bnx2fc_fcoe.c b/scsi/bnx2fc/bnx2fc_fcoe.c
--- a/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -130,6 +130,11 @@ static void bnx2fc_clean_rx_queue(struct
 	spin_lock_bh(&bg->fcoe_rx_list.lock);
 	list = &bg->fcoe_rx_list;
 	head = list->next;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (skb = head; skb != (struct sk_buff *)list;
 	     skb = next) {
 		next = skb->next;
@@ -138,6 +143,12 @@ static void bnx2fc_clean_rx_queue(struct
 			__skb_unlink(skb, list);
 			kfree_skb(skb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_bh(&bg->fcoe_rx_list.lock);
 }
diff -u -p a/scsi/arm/msgqueue.c b/scsi/arm/msgqueue.c
--- a/scsi/arm/msgqueue.c
+++ b/scsi/arm/msgqueue.c
@@ -85,8 +85,20 @@ int msgqueue_msglength(MsgQueue_t *msgq)
 	struct msgqueue_entry *mq = msgq->qe;
 	int length = 0;
 
-	for (mq = msgq->qe; mq; mq = mq->next)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (mq = msgq->qe; mq; mq = mq->next) {
 		length += mq->msg.length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	return length;
 }
@@ -152,9 +164,20 @@ void msgqueue_flush(MsgQueue_t *msgq)
 {
 	struct msgqueue_entry *mq, *mqnext;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mq = msgq->qe; mq; mq = mqnext) {
 		mqnext = mq->next;
 		mqe_free(msgq, mq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	msgq->qe = NULL;
 }
diff -u -p a/scsi/sg.c b/scsi/sg.c
--- a/scsi/sg.c
+++ b/scsi/sg.c
@@ -892,6 +892,11 @@ sg_ioctl(struct file *filp, unsigned int
 		if (!access_ok(VERIFY_WRITE, ip, sizeof (int)))
 			return -EFAULT;
 		read_lock_irqsave(&sfp->rq_list_lock, iflags);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (srp = sfp->headrp; srp; srp = srp->nextrp) {
 			if ((1 == srp->done) && (!srp->sg_io_owned)) {
 				read_unlock_irqrestore(&sfp->rq_list_lock,
@@ -899,15 +904,32 @@ sg_ioctl(struct file *filp, unsigned int
 				__put_user(srp->header.pack_id, ip);
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 		__put_user(-1, ip);
 		return 0;
 	case SG_GET_NUM_WAITING:
 		read_lock_irqsave(&sfp->rq_list_lock, iflags);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (val = 0, srp = sfp->headrp; srp; srp = srp->nextrp) {
 			if ((1 == srp->done) && (!srp->sg_io_owned))
 				++val;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 		return put_user(val, ip);
@@ -1141,11 +1163,22 @@ sg_poll(struct file *filp, poll_table *
 		return POLLERR;
 	poll_wait(filp, &sfp->read_wait, wait);
 	read_lock_irqsave(&sfp->rq_list_lock, iflags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (srp = sfp->headrp; srp; srp = srp->nextrp) {
 		/* if any read waiting, flag it */
 		if ((0 == res) && (1 == srp->done) && (!srp->sg_io_owned))
 			res = POLLIN | POLLRDNORM;
 		++count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
 
diff -u -p a/scsi/fcoe/fcoe.c b/scsi/fcoe/fcoe.c
--- a/scsi/fcoe/fcoe.c
+++ b/scsi/fcoe/fcoe.c
@@ -2214,6 +2214,11 @@ void fcoe_percpu_clean(struct fc_lport *
 		spin_lock_bh(&pp->fcoe_rx_list.lock);
 		list = &pp->fcoe_rx_list;
 		head = list->next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (skb = head; skb != (struct sk_buff *)list;
 		     skb = next) {
 			next = skb->next;
@@ -2222,6 +2227,12 @@ void fcoe_percpu_clean(struct fc_lport *
 				__skb_unlink(skb, list);
 				kfree_skb(skb);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (!pp->thread || !cpu_online(cpu)) {
diff -u -p a/scsi/scsi_devinfo.c b/scsi/scsi_devinfo.c
--- a/scsi/scsi_devinfo.c
+++ b/scsi/scsi_devinfo.c
@@ -501,6 +501,11 @@ static int scsi_dev_info_list_add_str(ch
 	 * For the leading and trailing '"' case, the for loop comes
 	 * through the last time with vendor[0] == '\0'.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (vendor = strsep(&next, ":"); vendor && (vendor[0] != '\0')
 	     && (res == 0); vendor = strsep(&next, ":")) {
 		strflags = NULL;
@@ -515,6 +520,12 @@ static int scsi_dev_info_list_add_str(ch
 		} else
 			res = scsi_dev_info_list_add(0 /* compatible */, vendor,
 						     model, strflags, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return res;
 }
diff -u -p a/scsi/aic7xxx/aicasm/aicasm.c b/scsi/aic7xxx/aicasm/aicasm.c
--- a/scsi/aic7xxx/aicasm/aicasm.c
+++ b/scsi/aic7xxx/aicasm/aicasm.c
@@ -216,16 +216,23 @@ main(int argc, char *argv[])
 							"times\n", appname);
 				}
 				includes_search_curdir = 0;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (include_dir = SLIST_FIRST(&search_path);
 				     include_dir != NULL;
 				     include_dir = SLIST_NEXT(include_dir,
-							      links))
-					/*
-					 * All entries before a '-I-' only
-					 * apply to includes specified with
-					 * quotes instead of "<>".
-					 */
+							      links)) {
 					include_dir->quoted_includes_only = 1;
+					if (_cur < timeout) {
+				rdstcll(_cur);
+					}
+					else {
+				break;
+					}
+				}
 			} else {
 				include_dir =
 				    (path_entry_t)malloc(sizeof(*include_dir));
@@ -321,6 +328,11 @@ back_patch()
 {
 	struct instruction *cur_instr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_instr = STAILQ_FIRST(&seq_program);
 	     cur_instr != NULL;
 	     cur_instr = STAILQ_NEXT(cur_instr, links)) {
@@ -342,6 +354,12 @@ back_patch()
 			address += cur_instr->patch_label->info.linfo->address;
 			f3_instr->address = address;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -363,6 +381,11 @@ output_code()
 "%s */\n", versions);
 
 	fprintf(ofile, "static const uint8_t seqprog[] = {\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_instr = STAILQ_FIRST(&seq_program);
 	     cur_instr != NULL;
 	     cur_instr = STAILQ_NEXT(cur_instr, links)) {
@@ -381,6 +404,12 @@ output_code()
 			cur_instr->format.bytes[0]);
 #endif
 		instrcount++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	fprintf(ofile, "\n};\n\n");
 
@@ -394,6 +423,11 @@ output_code()
 	fprintf(ofile,
 "typedef int %spatch_func_t (%s);\n", prefix, patch_arg_list);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_node = SLIST_FIRST(&patch_functions);
 	     cur_node != NULL;
 	     cur_node = SLIST_NEXT(cur_node,links)) {
@@ -412,6 +446,12 @@ output_code()
 			cur_node->symbol->info.condinfo->func_num,
 			patch_arg_list,
 			cur_node->symbol->name);
+	if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
 	}
 
 	fprintf(ofile,
@@ -422,6 +462,11 @@ output_code()
 "				 skip_patch	:12;\n"
 "} patches[] = {\n", prefix);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_patch = STAILQ_FIRST(&patches);
 	     cur_patch != NULL;
 	     cur_patch = STAILQ_NEXT(cur_patch,links)) {
@@ -430,6 +475,12 @@ output_code()
 			prefix,
 			cur_patch->patch_func, cur_patch->begin,
 			cur_patch->skip_instr, cur_patch->skip_patch);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	fprintf(ofile, "\n};\n\n");
@@ -440,12 +491,23 @@ output_code()
 "	uint16_t	end;\n"
 "} critical_sections[] = {\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cs = TAILQ_FIRST(&cs_tailq);
 	     cs != NULL;
 	     cs = TAILQ_NEXT(cs, links)) {
 		fprintf(ofile, "%s\t{ %d, %d }",
 			cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
 			cs->begin_addr, cs->end_addr);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	fprintf(ofile, "\n};\n\n");
@@ -543,10 +605,22 @@ output_listing(char *ifilename)
 	/*
 	 * Determine which options to apply to this listing.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (func_count = 0, cur_func = SLIST_FIRST(&patch_functions);
 	    cur_func != NULL;
-	    cur_func = SLIST_NEXT(cur_func, links))
-		func_count++;
+	    cur_func = SLIST_NEXT(cur_func, links)) {
+			func_count++;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
+		}
 
 	func_values = NULL;
 	if (func_count != 0) {
diff -u -p a/scsi/aic7xxx/aic79xx_core.c b/scsi/aic7xxx/aic79xx_core.c
--- a/scsi/aic7xxx/aic79xx_core.c
+++ b/scsi/aic7xxx/aic79xx_core.c
@@ -8307,6 +8307,11 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 	tid_next = ahd_inw(ahd, WAITING_TID_HEAD);
 	tid_prev = SCB_LIST_NULL;
 	targets = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (scbid = tid_next; !SCBID_IS_NULL(scbid); scbid = tid_next) {
 		u_int tid_head;
 		u_int tid_tail;
@@ -8415,6 +8420,12 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 			tid_prev = tid_head;
 		if (action == SEARCH_PRINT)
 			printk(")\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* Restore saved state. */
@@ -8440,6 +8451,11 @@ ahd_search_scb_list(struct ahd_softc *ah
 	prev = SCB_LIST_NULL;
 	next = *list_head;
 	*list_tail = SCB_LIST_NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (scbid = next; !SCBID_IS_NULL(scbid); scbid = next) {
 		if (scbid >= ahd->scb_data.numscbs) {
 			printk("%s:SCB List inconsistency. "
@@ -8483,6 +8499,12 @@ ahd_search_scb_list(struct ahd_softc *ah
 		}
 		if (found > AHD_SCB_MAX)
 			panic("SCB LIST LOOP");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	if (action == SEARCH_COMPLETE
 	 || action == SEARCH_REMOVE)
diff -u -p a/scsi/aic7xxx/aic79xx_pci.c b/scsi/aic7xxx/aic79xx_pci.c
--- a/scsi/aic7xxx/aic79xx_pci.c
+++ b/scsi/aic7xxx/aic79xx_pci.c
@@ -601,8 +601,20 @@ ahd_check_extport(struct ahd_softc *ahd)
 
 			ahd_set_scbptr(ahd, nvram_scb);
 			sc_data = (uint16_t *)sc;
-			for (i = 0; i < 64; i += 2)
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < 64; i += 2) {
 				*sc_data++ = ahd_inw_scbram(ahd, SCB_BASE+i);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
 			have_seeprom = ahd_verify_cksum(sc);
 			if (have_seeprom)
 				ahd->flags |= AHD_SCB_CONFIG_USED;
@@ -617,8 +629,20 @@ ahd_check_extport(struct ahd_softc *ahd)
 
 		printk("%s: Seeprom Contents:", ahd_name(ahd));
 		sc_data = (uint16_t *)sc;
-		for (i = 0; i < (sizeof(*sc)); i += 2)
-			printk("\n\t0x%.4x", sc_data[i]);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < (sizeof(*sc)); i += 2) {
+		printk("\n\t0x%.4x", sc_data[i]);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+		}
 		printk("\n");
 	}
 #endif
diff -u -p a/scsi/sun3_NCR5380.c b/scsi/sun3_NCR5380.c
--- a/scsi/sun3_NCR5380.c
+++ b/scsi/sun3_NCR5380.c
@@ -737,18 +737,40 @@ static int NCR5380_proc_info(struct Scsi
 				pos, buffer, length);
     SPRINTF("scsi%d: issue_queue\n", HOSTNO);
     check_offset();
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (ptr = (struct scsi_cmnd *) hostdata->issue_queue; ptr; ptr = NEXT(ptr))
     {
 	pos = lprint_Scsi_Cmnd (ptr, pos, buffer, length);
 	check_offset();
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
     }
 
     SPRINTF("scsi%d: disconnected_queue\n", HOSTNO);
     check_offset();
-    for (ptr = (struct scsi_cmnd *) hostdata->disconnected_queue; ptr;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (ptr = (struct scsi_cmnd *) hostdata->disconnected_queue; ptr;
 	 ptr = NEXT(ptr)) {
 	pos = lprint_Scsi_Cmnd (ptr, pos, buffer, length);
 	check_offset();
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
     }
 
     local_irq_restore(flags);
diff -u -p a/scsi/dpt_i2o.c b/scsi/dpt_i2o.c
--- a/scsi/dpt_i2o.c
+++ b/scsi/dpt_i2o.c
@@ -209,13 +209,24 @@ static int adpt_detect(struct scsi_host_
 	}
 
 	/* In INIT state, Activate IOPs */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
 		// Activate does get status , init outbound, and get hrt
 		if (adpt_i2o_activate_hba(pHba) < 0) {
 			adpt_i2o_delete_hba(pHba);
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 
 	/* Active IOPs in HOLD state */
@@ -236,17 +247,33 @@ rebuild_sys_tab:
 	PDEBUG("HBA's in HOLD state\n");
 
 	/* If IOP don't get online, we need to rebuild the System table */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
 		if (adpt_i2o_online_hba(pHba) < 0) {
 			adpt_i2o_delete_hba(pHba);	
 			goto rebuild_sys_tab;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Active IOPs now in OPERATIONAL state */
 	PDEBUG("HBA's in OPERATIONAL state\n");
 
 	printk("dpti: If you have a lot of devices this could take a few minutes.\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
 		printk(KERN_INFO"%s: Reading the hardware resource table.\n", pHba->name);
@@ -260,6 +287,12 @@ rebuild_sys_tab:
 			continue;
 		}
 		adpt_inquiry(pHba);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	adpt_sysfs_class = class_create(THIS_MODULE, "dpt_i2o");
@@ -268,6 +301,11 @@ rebuild_sys_tab:
 		adpt_sysfs_class = NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
 		if (adpt_scsi_host_alloc(pHba, sht) < 0){
@@ -286,6 +324,12 @@ rebuild_sys_tab:
 					pHba->unit);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	// Register our control device node
@@ -971,9 +1015,20 @@ static void adpt_i2o_sys_shutdown(void)
 	/* They should have already been released by the
 	 * scsi-core
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = pNext) {
 		pNext = pHba->next;
 		adpt_i2o_delete_hba(pHba);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Remove any timedout entries from the wait queue.  */
@@ -1222,16 +1277,38 @@ static void adpt_i2o_delete_hba(adpt_hba
 			pHba->reply_pool, pHba->reply_pool_pa);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(d = pHba->devices; d ; d = next){
 		next = d->next;
 		kfree(d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	for(i = 0 ; i < pHba->top_scsi_channel ; i++){
 		for(j = 0; j < MAX_ID; j++){
 			if(pHba->channel[i].device[j] != NULL){
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for(pDev = pHba->channel[i].device[j]; pDev; pDev = pNext){
 					pNext = pDev->next_lun;
 					kfree(pDev);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 		}
@@ -1274,10 +1351,21 @@ static struct adpt_device* adpt_find_dev
 	}
 
 	/* else we need to look through all the luns */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(d=d->next_lun ; d ; d = d->next_lun){
 		if(d->scsi_lun == lun){
 			return d;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -1420,6 +1508,11 @@ static void adpt_i2o_post_wait_complete(
 	context &= 0x7fff;
 
 	spin_lock(&adpt_post_wait_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
 		if(p1->id == context) {
 			p1->status = status;
@@ -1427,13 +1520,30 @@ static void adpt_i2o_post_wait_complete(
 			wake_up_interruptible(p1->wq);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock(&adpt_post_wait_lock);
         // If this happens we lose commands that probably really completed
 	printk(KERN_DEBUG"dpti: Could Not find task %d in wait queue\n",context);
 	printk(KERN_DEBUG"      Tasks in wait queue:\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
 		printk(KERN_DEBUG"           %d\n",p1->id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return;
 }
@@ -1649,6 +1759,11 @@ static int adpt_i2o_parse_lct(adpt_hba*
 	}
 
 	// Setup adpt_device table
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(d = pHba->devices; d ; d = d->next) {
 		if(d->lct_data.class_id  == I2O_CLASS_RANDOM_BLOCK_STORAGE ||
 		   d->lct_data.class_id  == I2O_CLASS_SCSI_PERIPHERAL ||
@@ -1674,8 +1789,19 @@ static int adpt_i2o_parse_lct(adpt_hba*
 					}
 					pHba->channel[bus_no].device[scsi_id] = pDev;
 				} else {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					for( pDev = pHba->channel[bus_no].device[scsi_id];	
 							pDev->next_lun; pDev = pDev->next_lun){
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
 					}
 					pDev->next_lun = kzalloc(sizeof(struct adpt_device),GFP_KERNEL);
 					if(pDev->next_lun == NULL) {
@@ -1703,6 +1829,12 @@ static int adpt_i2o_parse_lct(adpt_hba*
 						d->lct_data.identity_tag);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -2619,12 +2751,23 @@ static s32 adpt_i2o_reparse_lct(adpt_hba
 	max /= 9;
 
 	// Mark each drive as unscanned
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (d = pHba->devices; d; d = d->next) {
 		pDev =(struct adpt_device*) d->owner;
 		if(!pDev){
 			continue;
 		}
 		pDev->state |= DPTI_DEV_UNSCANNED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_INFO "%s: LCT has %d entries.\n", pHba->name,max);
@@ -2743,6 +2886,11 @@ static s32 adpt_i2o_reparse_lct(adpt_hba
 			}
 		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pI2o_dev = pHba->devices; pI2o_dev; pI2o_dev = pI2o_dev->next) {
 		pDev =(struct adpt_device*) pI2o_dev->owner;
 		if(!pDev){
@@ -2757,6 +2905,12 @@ static s32 adpt_i2o_reparse_lct(adpt_hba
 				scsi_device_set_state(pDev->pScsi_dev, SDEV_OFFLINE);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -3219,6 +3373,11 @@ static int adpt_i2o_build_sys_table(void
 	sys_tbl->version = I2OVERSION;
 	sys_tbl->change_ind = sys_tbl_ind++;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(pHba = hba_chain; pHba; pHba = pHba->next) {
 		u64 addr;
 		// Get updated Status Block so we have the latest information
@@ -3241,6 +3400,12 @@ static int adpt_i2o_build_sys_table(void
 		sys_tbl->iops[count].inbound_high = dma_high(addr);
 
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 #ifdef DEBUG
@@ -3667,17 +3832,39 @@ static int __init adpt_init(void)
 	if (hba_chain == NULL)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
 		error = scsi_add_host(pHba->host, &pHba->pDev->dev);
 		if (error)
 			goto fail;
 		scsi_scan_host(pHba->host);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 fail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
 		scsi_remove_host(pHba->host);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return error;
 }
@@ -3686,11 +3873,34 @@ static void __exit adpt_exit(void)
 {
 	adpt_hba	*pHba, *next;
 
-	for (pHba = hba_chain; pHba; pHba = pHba->next)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
 		scsi_remove_host(pHba->host);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
 		adpt_release(pHba->host);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/qla2xxx/qla_dbg.c b/scsi/qla2xxx/qla_dbg.c
--- a/scsi/qla2xxx/qla_dbg.c
+++ b/scsi/qla2xxx/qla_dbg.c
@@ -83,6 +83,11 @@ qla24xx_dump_ram(struct qla_hw_data *ha,
 	clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
 
 	dwords = GID_LIST_SIZE / 4;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < ram_dwords && rval == QLA_SUCCESS;
 	    cnt += dwords, addr += dwords) {
 		if (cnt + dwords > ram_dwords)
@@ -133,6 +138,12 @@ qla24xx_dump_ram(struct qla_hw_data *ha,
 		} else {
 			rval = QLA_FUNCTION_FAILED;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*nxt = rval == QLA_SUCCESS ? &ram[cnt]: NULL;
@@ -258,6 +269,11 @@ qla2xxx_dump_ram(struct qla_hw_data *ha,
 	clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
 
 	words = GID_LIST_SIZE / 2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cnt = 0; cnt < ram_words && rval == QLA_SUCCESS;
 	    cnt += words, addr += words) {
 		if (cnt + words > ram_words)
@@ -318,6 +334,12 @@ qla2xxx_dump_ram(struct qla_hw_data *ha,
 		} else {
 			rval = QLA_FUNCTION_FAILED;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*nxt = rval == QLA_SUCCESS ? &ram[cnt]: NULL;
diff -u -p a/scsi/scsi_debug.c b/scsi/scsi_debug.c
--- a/scsi/scsi_debug.c
+++ b/scsi/scsi_debug.c
@@ -1889,6 +1889,11 @@ static int prot_verify_write(struct scsi
 		daddr = kmap_atomic(sg_page(dsgl), KM_IRQ0) + dsgl->offset;
 
 		/* For each sector-sized chunk in data page */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = 0 ; j < dsgl->length ; j += scsi_debug_sector_size) {
 
 			/* If we're at the end of the current
@@ -1969,6 +1974,12 @@ static int prot_verify_write(struct scsi
 			ei_lba++;
 			daddr += scsi_debug_sector_size;
 			ppage_offset += sizeof(struct sd_dif_tuple);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kunmap_atomic(daddr, KM_IRQ0);
diff -u -p a/scsi/sym53c8xx_2/sym_nvram.c b/scsi/sym53c8xx_2/sym_nvram.c
--- a/scsi/sym53c8xx_2/sym_nvram.c
+++ b/scsi/sym53c8xx_2/sym_nvram.c
@@ -716,8 +716,20 @@ static int sym_read_Tekram_nvram (struct
 		return 1;
 
 	/* verify checksum */
-	for (x = 0, csum = 0; x < len - 1; x += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (x = 0, csum = 0; x < len - 1; x += 2) {
 		csum += data[x] + (data[x+1] << 8);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	if (csum != 0x1234)
 		return 1;
 
diff -u -p a/scsi/advansys.c b/scsi/advansys.c
--- a/scsi/advansys.c
+++ b/scsi/advansys.c
@@ -8509,6 +8509,11 @@ adv_get_sglist(struct asc_board *boardp,
 	prev_sg_block = NULL;
 	reqp->sgblkp = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		/*
 		 * Allocate a 'adv_sgblk_t' structure from the board free
@@ -8588,6 +8593,12 @@ adv_get_sglist(struct asc_board *boardp,
 		}
 		sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
 		prev_sg_block = sg_block;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/aic94xx/aic94xx_sds.c b/scsi/aic94xx/aic94xx_sds.c
--- a/scsi/aic94xx/aic94xx_sds.c
+++ b/scsi/aic94xx/aic94xx_sds.c
@@ -292,8 +292,20 @@ asd_hwi_initialize_ocm_dir (struct asd_h
 	int i;
 
 	/* Zero OCM */
-	for (i = 0; i < OCM_MAX_SIZE; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < OCM_MAX_SIZE; i += 4) {
 		asd_write_ocm_dword(asd_ha, i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* Write Dir */
 	asd_write_ocm_seg(asd_ha, &OCMDirInit, 0,
diff -u -p a/scsi/aic94xx/aic94xx_seq.c b/scsi/aic94xx/aic94xx_seq.c
--- a/scsi/aic94xx/aic94xx_seq.c
+++ b/scsi/aic94xx/aic94xx_seq.c
@@ -649,8 +649,20 @@ static void asd_init_lseq_mip(struct asd
 	asd_write_reg_byte(asd_ha, LmSEQ_EMPTY_SCB_HEAD(lseq), 0);
 	asd_write_reg_byte(asd_ha, LmSEQ_EMPTY_SCB_TAIL(lseq), 0);
 	asd_write_reg_byte(asd_ha, LmSEQ_EMPTY_BUFS_AVAIL(lseq), 0);
-	for (i = 0; i < 12; i += 4)
-		asd_write_reg_dword(asd_ha, LmSEQ_ATA_SCR_REGS(lseq) + i, 0);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 12; i += 4) {
+	asd_write_reg_dword(asd_ha, LmSEQ_ATA_SCR_REGS(lseq) + i, 0);
+	if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
+	}
 
 	/* LSEQ Mode Independent page 3 setup. */
 
@@ -798,8 +810,20 @@ static void asd_init_lseq_mdp(struct asd
 		/* Start from Page 1 of Mode 0 and 1. */
 		moffs = LSEQ_PAGE_SIZE + i*LSEQ_MODE_SCRATCH_SIZE;
 		/* All the fields of page 1 can be initialized to 0. */
-		for (j = 0; j < LSEQ_PAGE_SIZE; j += 4)
-			asd_write_reg_dword(asd_ha, LmSCRATCH(lseq)+moffs+j,0);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (j = 0; j < LSEQ_PAGE_SIZE; j += 4) {
+	asd_write_reg_dword(asd_ha, LmSCRATCH(lseq)+moffs+j,0);
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
+		}
 	}
 
 	/* LSEQ Mode dependent, mode 2, page 1 setup. */
@@ -808,8 +832,20 @@ static void asd_init_lseq_mdp(struct asd
 	asd_write_reg_dword(asd_ha, LmSEQ_LOSS_OF_SYNC_COUNT(lseq), 0);
 
 	/* LSEQ Mode dependent, mode 4/5, page 1. */
-	for (i = 0; i < LSEQ_PAGE_SIZE; i+=4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < LSEQ_PAGE_SIZE; i+=4) {
 		asd_write_reg_dword(asd_ha, LmSEQ_FRAME_TYPE_MASK(lseq)+i, 0);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
+	}
 	asd_write_reg_byte(asd_ha, LmSEQ_FRAME_TYPE_MASK(lseq), 0xFF);
 	asd_write_reg_byte(asd_ha, LmSEQ_HASHED_DEST_ADDR_MASK(lseq), 0xFF);
 	asd_write_reg_byte(asd_ha, LmSEQ_HASHED_DEST_ADDR_MASK(lseq)+1,0xFF);
@@ -885,8 +921,20 @@ static void asd_init_scb_sites(struct as
 		u16	i;
 
 		/* Initialize all fields in the SCB site to 0. */
-		for (i = 0; i < ASD_SCB_SIZE; i += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < ASD_SCB_SIZE; i += 4) {
 			asd_scbsite_write_dword(asd_ha, site_no, i, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 
 		/* Initialize SCB Site Opcode field to invalid. */
 		asd_scbsite_write_byte(asd_ha, site_no,
@@ -1121,8 +1169,20 @@ static void asd_init_ddb_0(struct asd_ha
 	int	i;
 
 	/* Zero out the DDB explicitly */
-	for (i = 0; i < sizeof(struct asd_ddb_seq_shared); i+=4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < sizeof(struct asd_ddb_seq_shared); i+=4) {
 		asd_ddbsite_write_dword(asd_ha, 0, i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	asd_ddbsite_write_word(asd_ha, 0,
 		 offsetof(struct asd_ddb_seq_shared, q_free_ddb_head), 0);
@@ -1159,9 +1219,22 @@ static void asd_seq_init_ddb_sites(struc
 	unsigned int i;
 	unsigned int ddb_site;
 
-	for (ddb_site = 0 ; ddb_site < ASD_MAX_DDBS; ddb_site++)
-		for (i = 0; i < sizeof(struct asd_ddb_ssp_smp_target_port); i+= 4)
+	for (ddb_site = 0 ; ddb_site < ASD_MAX_DDBS; ddb_site++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < sizeof(struct asd_ddb_ssp_smp_target_port); i+= 4) {
 			asd_ddbsite_write_dword(asd_ha, ddb_site, i, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+	}
 }
 
 /**
diff -u -p a/scsi/aic94xx/aic94xx_dev.c b/scsi/aic94xx/aic94xx_dev.c
--- a/scsi/aic94xx/aic94xx_dev.c
+++ b/scsi/aic94xx/aic94xx_dev.c
@@ -46,8 +46,20 @@ static int asd_get_ddb(struct asd_ha_str
 	}
 	SET_DDB(ddb, asd_ha);
 
-	for (i = 0; i < sizeof(struct asd_ddb_ssp_smp_target_port); i+= 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < sizeof(struct asd_ddb_ssp_smp_target_port); i+= 4) {
 		asd_ddbsite_write_dword(asd_ha, ddb, i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 out:
 	return ddb;
 }
@@ -101,8 +113,20 @@ static int asd_init_sata_tag_ddb(struct
 	if (ddb < 0)
 		return ddb;
 
-	for (i = 0; i < sizeof(struct asd_ddb_sata_tag); i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < sizeof(struct asd_ddb_sata_tag); i += 2) {
 		asd_ddbsite_write_word(asd_ha, ddb, i, 0xFFFF);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	asd_ddbsite_write_word(asd_ha, (int) (unsigned long) dev->lldd_dev,
 			       SISTER_DDB, ddb);
@@ -231,8 +255,20 @@ static int asd_init_sata_pm_table_ddb(st
 	if (ddb < 0)
 		return ddb;
 
-	for (i = 0; i < 32; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 32; i += 2) {
 		asd_ddbsite_write_word(asd_ha, ddb, i, 0xFFFF);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	asd_ddbsite_write_word(asd_ha, (int) (unsigned long) dev->lldd_dev,
 			       SISTER_DDB, ddb);
diff -u -p a/scsi/aic94xx/aic94xx_dump.c b/scsi/aic94xx/aic94xx_dump.c
--- a/scsi/aic94xx/aic94xx_dump.c
+++ b/scsi/aic94xx/aic94xx_dump.c
@@ -916,13 +916,25 @@ void asd_dump_frame_rcvd(struct asd_phy
 		break;
 	}
 	spin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);
-	for (i = 0; i < phy->sas_phy.frame_rcvd_size; i+=4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < phy->sas_phy.frame_rcvd_size; i+=4) {
 		ASD_DPRINTK("%02x: %02x %02x %02x %02x\n",
-			    i,
-			    phy->frame_rcvd[i],
-			    phy->frame_rcvd[i+1],
-			    phy->frame_rcvd[i+2],
-			    phy->frame_rcvd[i+3]);
+		i,
+		phy->frame_rcvd[i],
+		phy->frame_rcvd[i+1],
+		phy->frame_rcvd[i+2],
+		phy->frame_rcvd[i+3]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 	spin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);
 }
 
diff -u -p a/staging/sbe-2t3e3/main.c b/staging/sbe-2t3e3/main.c
--- a/staging/sbe-2t3e3/main.c
+++ b/staging/sbe-2t3e3/main.c
@@ -77,6 +77,11 @@ int t3e3_if_start_xmit(struct sk_buff *s
 	dev_dbg(&sc->pdev->dev, "sending mbuf (current_write = %d)\n",
 		current_write);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (skb2 = skb; skb2 != NULL; skb2 = NULL) {
 		if (skb2->len) {
 			dev_dbg(&sc->pdev->dev,
@@ -106,6 +111,12 @@ int t3e3_if_start_xmit(struct sk_buff *s
 			last_write = current_write;
 			current_write = (current_write + 1) % SBE_2T3E3_TX_DESC_RING_SIZE;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sc->ether.tx_data[last_write] = skb;
diff -u -p a/staging/rtl8187se/r8180_core.c b/staging/rtl8187se/r8180_core.c
--- a/staging/rtl8187se/r8180_core.c
+++ b/staging/rtl8187se/r8180_core.c
@@ -621,6 +621,11 @@ void fix_rx_fifo(struct net_device *dev)
 
 	rx_desc_size = 8; /* 4*8 = 32 bytes */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tmp = priv->rxring, rxbuf = priv->rxbufferhead;
 	     (tmp < (priv->rxring)+(priv->rxringcount)*rx_desc_size);
 	     tmp += rx_desc_size, rxbuf = rxbuf->next) {
@@ -628,6 +633,12 @@ void fix_rx_fifo(struct net_device *dev)
 		*tmp = *tmp & ~0xfff;
 		*tmp = *tmp | priv->rxbuffersize;
 		*tmp |= (1<<31);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	priv->rxringtail = priv->rxring;
diff -u -p a/staging/rtl8187se/ieee80211/ieee80211_crypt.c b/staging/rtl8187se/ieee80211/ieee80211_crypt.c
--- a/staging/rtl8187se/ieee80211/ieee80211_crypt.c
+++ b/staging/rtl8187se/ieee80211/ieee80211_crypt.c
@@ -43,6 +43,11 @@ void ieee80211_crypt_deinit_entries(stru
 	struct list_head *ptr, *n;
 	struct ieee80211_crypt_data *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
 	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct ieee80211_crypt_data, list);
@@ -55,6 +60,12 @@ void ieee80211_crypt_deinit_entries(stru
 		if (entry->ops)
 			entry->ops->deinit(entry->priv);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/cxt1e1/musycc.c b/staging/cxt1e1/musycc.c
--- a/staging/cxt1e1/musycc.c
+++ b/staging/cxt1e1/musycc.c
@@ -1835,6 +1835,11 @@ musycc_start_xmit (ci_t * ci, int channu
     /***********************************************/
     m2 = mem_token;
     txd_need_cnt = 0;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (len = OS_mem_token_tlen (m2); len > 0;
          m2 = (void *) OS_mem_token_next (m2))
     {
@@ -1842,6 +1847,12 @@ musycc_start_xmit (ci_t * ci, int channu
             continue;
         txd_need_cnt++;
         len -= OS_mem_token_len (m2);
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
 
     if (txd_need_cnt == 0)
@@ -1893,6 +1904,11 @@ musycc_start_xmit (ci_t * ci, int channu
     m2 = mem_token;
     md = ch->txd_usr_add;           /* get current available descriptor */
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (len = OS_mem_token_tlen (m2); len > 0; m2 = OS_mem_token_next (m2))
     {
         int         u = OS_mem_token_len (m2);
@@ -1946,6 +1962,12 @@ musycc_start_xmit (ci_t * ci, int channu
         md->status = cpu_to_le32 (u);
         --ch->txd_free;
         md = md->snext;
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
     FLUSH_MEM_WRITE ();
 
diff -u -p a/staging/usbip/userspace/src/usbipd.c b/staging/usbip/userspace/src/usbipd.c
--- a/staging/usbip/userspace/src/usbipd.c
+++ b/staging/usbip/userspace/src/usbipd.c
@@ -355,7 +355,12 @@ static int listen_all_addrinfo(struct ad
 	struct addrinfo *ai;
 	int ret, nsockfd = 0;
 
-	for (ai = ai_head; ai && nsockfd < MAXSOCKFD; ai = ai->ai_next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (ai = ai_head; ai && nsockfd < MAXSOCKFD; ai = ai->ai_next) {
 		sockfdlist[nsockfd] = socket(ai->ai_family, ai->ai_socktype,
 					     ai->ai_protocol);
 		if (sockfdlist[nsockfd] < 0)
@@ -386,6 +391,12 @@ static int listen_all_addrinfo(struct ad
 
 		log_addrinfo(ai);
 		nsockfd++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nsockfd == 0)
diff -u -p a/staging/rtl8192u/ieee80211/cipher.c b/staging/rtl8192u/ieee80211/cipher.c
--- a/staging/rtl8192u/ieee80211/cipher.c
+++ b/staging/rtl8192u/ieee80211/cipher.c
@@ -67,6 +67,11 @@ static int crypt(struct crypto_tfm *tfm,
 	scatterwalk_start(&walk_in, src);
 	scatterwalk_start(&walk_out, dst);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(;;) {
 		u8 *src_p, *dst_p;
 		int in_place;
@@ -93,6 +98,12 @@ static int crypt(struct crypto_tfm *tfm,
 			return 0;
 
 		crypto_yield(tfm);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/rtl8192u/ieee80211/ieee80211_crypt.c b/staging/rtl8192u/ieee80211/ieee80211_crypt.c
--- a/staging/rtl8192u/ieee80211/ieee80211_crypt.c
+++ b/staging/rtl8192u/ieee80211/ieee80211_crypt.c
@@ -43,6 +43,11 @@ void ieee80211_crypt_deinit_entries(stru
 	struct list_head *ptr, *n;
 	struct ieee80211_crypt_data *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
 	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct ieee80211_crypt_data, list);
@@ -55,6 +60,12 @@ void ieee80211_crypt_deinit_entries(stru
 		if (entry->ops)
 			entry->ops->deinit(entry->priv);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -227,7 +238,12 @@ void __exit ieee80211_crypto_deinit(void
 	if (hcrypt == NULL)
 		return;
 
-	for (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;
 	     ptr = n, n = ptr->next) {
 		struct ieee80211_crypto_alg *alg =
 			(struct ieee80211_crypto_alg *) ptr;
@@ -235,6 +251,12 @@ void __exit ieee80211_crypto_deinit(void
 		printk(KERN_DEBUG "ieee80211_crypt: unregistered algorithm "
 		       "'%s' (deinit)\n", alg->ops->name);
 		kfree(alg);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	kfree(hcrypt);
diff -u -p a/staging/rtl8192u/r819xU_cmdpkt.c b/staging/rtl8192u/r819xU_cmdpkt.c
--- a/staging/rtl8192u/r819xU_cmdpkt.c
+++ b/staging/rtl8192u/r819xU_cmdpkt.c
@@ -33,8 +33,21 @@
 	u32	temp[10];\
 	\
 	memcpy(temp, Address, 40);\
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i <40; i+=4)\
-		printk("\r\n %08x", temp[i]);\
+		{
+		printk("\r\n %08x", temp[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}\
 }\
 /*---------------------------Define functions---------------------------------*/
 
diff -u -p a/staging/gma500/accel_2d.c b/staging/gma500/accel_2d.c
--- a/staging/gma500/accel_2d.c
+++ b/staging/gma500/accel_2d.c
@@ -123,8 +123,20 @@ static int psbfb_2d_submit(struct drm_ps
 
 		submit_size <<= 2;
 
-		for (i = 0; i < submit_size; i += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < submit_size; i += 4) {
 			PSB_WSGX32(*cmdbuf++, PSB_SGX_2D_SLAVE_PORT + i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 
 		(void)PSB_RSGX32(PSB_SGX_2D_SLAVE_PORT + i - 4);
 	}
diff -u -p a/staging/bcm/HandleControlPacket.c b/staging/bcm/HandleControlPacket.c
--- a/staging/bcm/HandleControlPacket.c
+++ b/staging/bcm/HandleControlPacket.c
@@ -203,6 +203,11 @@ INT flushAllAppQ(void)
 	PMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);
 	PPER_TARANG_DATA	pTarang = NULL;
 	struct sk_buff *PacketToDrop = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(pTarang = Adapter->pTarangs; pTarang; pTarang = pTarang->next)
 	{
 		while(pTarang->RxAppControlHead != NULL)
@@ -215,6 +220,12 @@ INT flushAllAppQ(void)
 		//dropped contrl packet statistics also should be reset.
 		memset((PVOID)&pTarang->stDroppedAppCntrlMsgs, 0, sizeof(S_MIBS_DROPPED_APP_CNTRL_MESSAGES));
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return STATUS_SUCCESS ;
 }
diff -u -p a/staging/bcm/nvm.c b/staging/bcm/nvm.c
--- a/staging/bcm/nvm.c
+++ b/staging/bcm/nvm.c
@@ -1254,6 +1254,11 @@ static INT BeceemFlashBulkWrite(
 		//do_gettimeofday(&te);
 		//BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "Total time taken by Erase :%ld ms\n", (te.tv_sec *1000 + te.tv_usec/1000) - (tr.tv_sec *1000 + tr.tv_usec/1000));
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(uiIndex = 0; uiIndex < Adapter->uiSectorSize; uiIndex +=Adapter->ulFlashWriteSize)
 		{
 			if(Adapter->device_removed)
@@ -1266,6 +1271,12 @@ static INT BeceemFlashBulkWrite(
 				Status = -1;
 				goto BeceemFlashBulkWrite_EXIT;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		//do_gettimeofday(&tw);
@@ -1460,6 +1471,11 @@ static INT BeceemFlashBulkWriteStatus(
 
 		FlashSectorErase(Adapter,uiPartOffset,1);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for(uiIndex = 0; uiIndex < Adapter->uiSectorSize; uiIndex +=Adapter->ulFlashWriteSize)
 
 		{
@@ -1474,6 +1490,12 @@ static INT BeceemFlashBulkWriteStatus(
 				Status = -1;
 				goto BeceemFlashBulkWriteStatus_EXIT;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if(bVerify)
diff -u -p a/staging/bcm/IPv6Protocol.c b/staging/bcm/IPv6Protocol.c
--- a/staging/bcm/IPv6Protocol.c
+++ b/staging/bcm/IPv6Protocol.c
@@ -285,6 +285,11 @@ static BOOLEAN MatchSrcIpv6Address(S_CLA
 		aulSrcIP[uiIpv6AddIndex]=ntohl(pstIpv6Header->ulSrcIpAddress[uiIpv6AddIndex]);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(uiLoopIndex=0;uiLoopIndex<uiCountIPSrcAddresses;uiLoopIndex+=uiIpv6AddrNoLongWords)
 	{
 		BCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Src Ipv6 Address In Received Packet : \n ");
@@ -310,6 +315,12 @@ static BOOLEAN MatchSrcIpv6Address(S_CLA
 				return TRUE;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return FALSE;
 }
@@ -338,6 +349,11 @@ static BOOLEAN MatchDestIpv6Address(S_CL
 		aulDestIP[uiIpv6AddIndex]=ntohl(pstIpv6Header->ulDestIpAddress[uiIpv6AddIndex]);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(uiLoopIndex=0;uiLoopIndex<uiCountIPDestinationAddresses;uiLoopIndex+=uiIpv6AddrNoLongWords)
 	{
 		BCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Destination Ipv6 Address In Received Packet : \n ");
@@ -363,6 +379,12 @@ static BOOLEAN MatchDestIpv6Address(S_CL
 				return TRUE;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return FALSE;
 
diff -u -p a/staging/sep/sep_driver.c b/staging/sep/sep_driver.c
--- a/staging/sep/sep_driver.c
+++ b/staging/sep/sep_driver.c
@@ -81,9 +81,21 @@ static void sep_dump_message(struct sep_
 {
 	int count;
 	u32 *p = sep->shared_addr;
-	for (count = 0; count < 12 * 4; count += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (count = 0; count < 12 * 4; count += 4) {
 		dev_dbg(&sep->pdev->dev, "Word %d of the message is %x\n",
-								count, *p++);
+		count, *p++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 /**
diff -u -p a/staging/rtl8192e/r8192E_cmdpkt.c b/staging/rtl8192e/r8192E_cmdpkt.c
--- a/staging/rtl8192e/r8192E_cmdpkt.c
+++ b/staging/rtl8192e/r8192E_cmdpkt.c
@@ -29,8 +29,21 @@
 	u32	temp[10];\
 	\
 	memcpy(temp, Address, 40);\
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 40; i += 4)\
-		printk(KERN_INFO "\r\n %08x", temp[i]);\
+		{
+		printk(KERN_INFO "\r\n %08x", temp[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}\
 }
 
 /*---------------------------Define functions---------------------------------*/
diff -u -p a/staging/rtl8192e/rtllib_crypt.c b/staging/rtl8192e/rtllib_crypt.c
--- a/staging/rtl8192e/rtllib_crypt.c
+++ b/staging/rtl8192e/rtllib_crypt.c
@@ -39,6 +39,11 @@ void rtllib_crypt_deinit_entries(struct
 	struct list_head *ptr, *n;
 	struct rtllib_crypt_data *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
 	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct rtllib_crypt_data, list);
@@ -51,6 +56,12 @@ void rtllib_crypt_deinit_entries(struct
 		if (entry->ops)
 			entry->ops->deinit(entry->priv);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -227,7 +238,12 @@ void __exit rtllib_crypto_deinit(void)
 	if (hcrypt == NULL)
 		return;
 
-	for (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (ptr = hcrypt->algs.next, n = ptr->next; ptr != &hcrypt->algs;
 	     ptr = n, n = ptr->next) {
 		struct rtllib_crypto_alg *alg =
 			(struct rtllib_crypto_alg *) ptr;
@@ -235,6 +251,12 @@ void __exit rtllib_crypto_deinit(void)
 		printk(KERN_DEBUG "rtllib_crypt: unregistered algorithm "
 		       "'%s' (deinit)\n", alg->ops->name);
 		kfree(alg);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	kfree(hcrypt);
diff -u -p a/staging/speakup/main.c b/staging/speakup/main.c
--- a/staging/speakup/main.c
+++ b/staging/speakup/main.c
@@ -909,9 +909,20 @@ static void say_screen_from_to(struct vc
 	if (to > vc->vc_rows)
 		to = vc->vc_rows;
 	end = vc->vc_origin + (to * vc->vc_size_row);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (from = start; from < end; from = to) {
 		to = from + vc->vc_size_row;
 		say_from_to(vc, from, to, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/media/go7007/go7007-fw.c b/staging/media/go7007/go7007-fw.c
--- a/staging/media/go7007/go7007-fw.c
+++ b/staging/media/go7007/go7007-fw.c
@@ -395,6 +395,11 @@ static int gen_mjpeghdr_to_package(struc
 	memmove(buf + size, buf + size + 80, chunk - 80);
 	size += chunk - 80;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < size; i += chunk * 2) {
 		if (space - off < 32) {
 			off = -1;
@@ -421,6 +426,12 @@ static int gen_mjpeghdr_to_package(struc
 
 		memcpy(&code[off + 2], buf + i, chunk * 2);
 		off += 32;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 done:
 	kfree(buf);
@@ -686,6 +697,11 @@ static int gen_mpeg1hdr_to_package(struc
 	i += 1632 + 16;
 	mpeg1_sequence_header(go, buf + i, 0);
 	i += 40;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 5120; i += chunk * 2) {
 		if (space - off < 32) {
 			off = -1;
@@ -715,6 +731,12 @@ static int gen_mpeg1hdr_to_package(struc
 
 		memcpy(&code[off + 2], buf + i, chunk * 2);
 		off += 32;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 done:
 	kfree(buf);
@@ -855,6 +877,11 @@ static int gen_mpeg4hdr_to_package(struc
 	i += 16;
 	mpeg4_sequence_header(go, buf + i, 0);
 	i += 40;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 5120; i += chunk * 2) {
 		if (space - off < 32) {
 			off = -1;
@@ -884,6 +911,12 @@ static int gen_mpeg4hdr_to_package(struc
 
 		memcpy(&code[off + 2], buf + i, chunk * 2);
 		off += 32;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mem = 0x3e00;
 	addr = go->ipb ? 0x14f9 : 0x0af9;
@@ -898,6 +931,11 @@ static int gen_mpeg4hdr_to_package(struc
 	i += 1632;
 	mpeg4_frame_header(go, buf + i, 1, BFRAME_EMPTY);
 	i += 16;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 5120; i += chunk * 2) {
 		if (space - off < 32) {
 			off = -1;
@@ -927,6 +965,12 @@ static int gen_mpeg4hdr_to_package(struc
 
 		memcpy(&code[off + 2], buf + i, chunk * 2);
 		off += 32;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 done:
 	kfree(buf);
diff -u -p a/staging/media/lirc/lirc_sir.c b/staging/media/lirc/lirc_sir.c
--- a/staging/media/lirc/lirc_sir.c
+++ b/staging/media/lirc/lirc_sir.c
@@ -713,6 +713,11 @@ static void send_pulse(unsigned long len
 	 * due to integer arithmetic, but we can accept this inaccuracy
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (k = flag = 0; k < length; k += delay, flag = !flag) {
 		if (flag) {
 			off();
@@ -722,6 +727,12 @@ static void send_pulse(unsigned long len
 			delay = pulse_width;
 		}
 		safe_udelay(delay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	off();
 }
diff -u -p a/staging/media/solo6x10/disp.c b/staging/media/solo6x10/disp.c
--- a/staging/media/solo6x10/disp.c
+++ b/staging/media/solo6x10/disp.c
@@ -155,10 +155,22 @@ static int solo_dma_vin_region(struct so
 	for (i = 0; i < sizeof(buf) >> 1; i++)
 		buf[i] = val;
 
-	for (i = 0; i < reg_size; i += sizeof(buf))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < reg_size; i += sizeof(buf)) {
 		ret |= solo_p2m_dma(solo_dev, SOLO_P2M_DMA_ID_VIN, 1, buf,
-				    SOLO_MOTION_EXT_ADDR(solo_dev) + off + i,
-				    sizeof(buf));
+		SOLO_MOTION_EXT_ADDR(solo_dev) + off + i,
+		sizeof(buf));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	return ret;
 }
diff -u -p a/staging/media/solo6x10/g723.c b/staging/media/solo6x10/g723.c
--- a/staging/media/solo6x10/g723.c
+++ b/staging/media/solo6x10/g723.c
@@ -87,6 +87,11 @@ void solo_g723_isr(struct solo_dev *solo
 
 	solo_reg_write(solo_dev, SOLO_IRQ_STAT, SOLO_IRQ_G723);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ss = pstr->substream; ss != NULL; ss = ss->next) {
 		if (snd_pcm_substream_chip(ss) == NULL)
 			continue;
@@ -101,6 +106,12 @@ void solo_g723_isr(struct solo_dev *solo
 			continue;
 
 		snd_pcm_period_elapsed(ss);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/media/solo6x10/v4l2-enc.c b/staging/media/solo6x10/v4l2-enc.c
--- a/staging/media/solo6x10/v4l2-enc.c
+++ b/staging/media/solo6x10/v4l2-enc.c
@@ -275,6 +275,11 @@ static void enc_write_sg(struct scatterl
 	struct scatterlist *sg;
 	u8 *src = buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sg = sglist; sg && size > 0; sg = sg_next(sg)) {
 		u8 *p = sg_virt(sg);
 		size_t len = sg_dma_len(sg);
@@ -282,6 +287,12 @@ static void enc_write_sg(struct scatterl
 
 		for (i = 0; i < len && size; i++)
 			p[i] = *(src++);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -395,7 +406,12 @@ static void solo_jpeg_header(struct solo
 	size_t copied = 0;
 	size_t to_copy = sizeof(jpeg_header);
 
-	for (sg = vbuf->sglist; sg && copied < to_copy; sg = sg_next(sg)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (sg = vbuf->sglist; sg && copied < to_copy; sg = sg_next(sg)) {
 		size_t this_copy = min(sg_dma_len(sg),
 				       (unsigned int)(to_copy - copied));
 		u8 *p = sg_virt(sg);
@@ -414,6 +430,12 @@ static void solo_jpeg_header(struct solo
 			p[(SOF0_START + 8) - copied] = 0xff & solo_enc->width;
 
 		copied += this_copy;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/tidspbridge/gen/gh.c b/staging/tidspbridge/gen/gh.c
--- a/staging/tidspbridge/gen/gh.c
+++ b/staging/tidspbridge/gen/gh.c
@@ -79,11 +79,22 @@ void gh_delete(struct gh_t_hash_tab *has
 	if (hash_tab != NULL) {
 		if (hash_tab->buckets != NULL) {
 			for (i = 0; i < hash_tab->max_bucket; i++) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (elem = hash_tab->buckets[i]; elem != NULL;
 				     elem = next) {
 					next = elem->next;
 					(*hash_tab->delete) (elem->data);
 					kfree(elem);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 
diff -u -p a/staging/tidspbridge/dynload/tramp.c b/staging/tidspbridge/dynload/tramp.c
--- a/staging/tidspbridge/dynload/tramp.c
+++ b/staging/tidspbridge/dynload/tramp.c
@@ -183,6 +183,11 @@ static struct tramp_string *priv_tramp_s
 	u32 i;
 	u32 str_len = strlen(str);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_str = dlthis->tramp.string_head;
 	     (ret_val == NULL) && (cur_str != NULL); cur_str = cur_str->next) {
 		/*  If the string lengths aren't equal, don't bother
@@ -201,6 +206,12 @@ static struct tramp_string *priv_tramp_s
 
 		if (i == str_len)
 			ret_val = cur_str;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return ret_val;
@@ -1094,6 +1105,11 @@ void dload_tramp_cleanup(struct dload_st
 		return;
 
 	/*  Destroy all tramp information */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_sym = tramp->symbol_head;
 	     cur_sym != NULL; cur_sym = tramp->symbol_head) {
 		tramp->symbol_head = cur_sym->next;
@@ -1101,12 +1117,23 @@ void dload_tramp_cleanup(struct dload_st
 			tramp->symbol_tail = NULL;
 
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_sym);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (tramp->final_sym_table != NULL)
 		dlthis->mysym->dload_deallocate(dlthis->mysym,
 						tramp->final_sym_table);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_string = tramp->string_head;
 	     cur_string != NULL; cur_string = tramp->string_head) {
 		tramp->string_head = cur_string->next;
@@ -1114,30 +1141,69 @@ void dload_tramp_cleanup(struct dload_st
 			tramp->string_tail = NULL;
 
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_string);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (tramp->final_string_table != NULL)
 		dlthis->mysym->dload_deallocate(dlthis->mysym,
 						tramp->final_string_table);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_tramp_pkt = tramp->tramp_pkts;
 	     cur_tramp_pkt != NULL; cur_tramp_pkt = tramp->tramp_pkts) {
 		tramp->tramp_pkts = cur_tramp_pkt->next;
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_tramp_pkt);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur_dup_pkt = tramp->dup_pkts;
 	     cur_dup_pkt != NULL; cur_dup_pkt = tramp->dup_pkts) {
 		tramp->dup_pkts = cur_dup_pkt->next;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cur_dup_relo = cur_dup_pkt->relo_chain;
 		     cur_dup_relo != NULL;
 		     cur_dup_relo = cur_dup_pkt->relo_chain) {
 			cur_dup_pkt->relo_chain = cur_dup_relo->next;
 			dlthis->mysym->dload_deallocate(dlthis->mysym,
 							cur_dup_relo);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_dup_pkt);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
diff -u -p a/staging/tidspbridge/pmgr/dspapi.c b/staging/tidspbridge/pmgr/dspapi.c
--- a/staging/tidspbridge/pmgr/dspapi.c
+++ b/staging/tidspbridge/pmgr/dspapi.c
@@ -387,6 +387,11 @@ int api_init_complete2(void)
 	/*  Walk the list of DevObjects, get each devnode, and attempting to
 	 *  autostart the board. Note that this requires COF loading, which
 	 *  requires KFILE. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = dev_get_first(); hdev_obj != NULL;
 	     hdev_obj = dev_get_next(hdev_obj)) {
 		if (dev_get_dev_node(hdev_obj, &dev_node))
@@ -401,6 +406,12 @@ int api_init_complete2(void)
 			if (drv_datap && drv_datap->base_img)
 				proc_auto_start(dev_node, hdev_obj);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return status;
diff -u -p a/staging/tidspbridge/pmgr/dmm.c b/staging/tidspbridge/pmgr/dmm.c
--- a/staging/tidspbridge/pmgr/dmm.c
+++ b/staging/tidspbridge/pmgr/dmm.c
@@ -500,6 +500,11 @@ u32 dmm_mem_map_dump(struct dmm_object *
 	spin_lock(&dmm_mgr->dmm_lock);
 
 	if (virtual_mapping_table != NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; i < table_size; i +=
 		     virtual_mapping_table[i].region_size) {
 			curr_node = virtual_mapping_table + i;
@@ -518,6 +523,12 @@ u32 dmm_mem_map_dump(struct dmm_object *
 				if (curr_node->region_size > bigsize)
 					bigsize = curr_node->region_size;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 	spin_unlock(&dmm_mgr->dmm_lock);
diff -u -p a/staging/tidspbridge/rmgr/pwr.c b/staging/tidspbridge/rmgr/pwr.c
--- a/staging/tidspbridge/rmgr/pwr.c
+++ b/staging/tidspbridge/rmgr/pwr.c
@@ -45,6 +45,11 @@ int pwr_sleep_dsp(const u32 sleep_code,
 	u32 ioctlcode = 0;
 	u32 arg = timeout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj =
@@ -71,6 +76,12 @@ int pwr_sleep_dsp(const u32 sleep_code,
 							      ioctlcode,
 							      (void *)&arg);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 }
@@ -87,6 +98,11 @@ int pwr_wake_dsp(const u32 timeout)
 	struct dev_object *hdev_obj = NULL;
 	u32 arg = timeout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
@@ -102,6 +118,12 @@ int pwr_wake_dsp(const u32 timeout)
 							(void *)&arg);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 }
@@ -121,6 +143,11 @@ int pwr_pm_pre_scale(u16 voltage_domain,
 	arg[0] = voltage_domain;
 	arg[1] = level;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
@@ -136,6 +163,12 @@ int pwr_pm_pre_scale(u16 voltage_domain,
 						(void *)&arg);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 }
@@ -155,6 +188,11 @@ int pwr_pm_post_scale(u16 voltage_domain
 	arg[0] = voltage_domain;
 	arg[1] = level;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
 	     hdev_obj != NULL;
 	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
@@ -170,6 +208,12 @@ int pwr_pm_post_scale(u16 voltage_domain
 						(void *)&arg);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 
diff -u -p a/staging/tidspbridge/rmgr/dspdrv.c b/staging/tidspbridge/rmgr/dspdrv.c
--- a/staging/tidspbridge/rmgr/dspdrv.c
+++ b/staging/tidspbridge/rmgr/dspdrv.c
@@ -79,12 +79,23 @@ u32 dsp_init(u32 *init_status)
 		 * unloading. Get the Driver Object iterate through and remove.
 		 * Reset the status to E_FAIL to avoid going through
 		 * api_init_complete2. */
-		for (device_node = drv_get_first_dev_extension();
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (device_node = drv_get_first_dev_extension();
 		     device_node != 0;
 		     device_node = drv_get_next_dev_extension(device_node)) {
 			(void)dev_remove_device((struct cfg_devnode *)
 						device_node);
 			(void)drv_release_resources((u32) device_node, drv_obj);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		/* Remove the Driver Object */
 		(void)drv_destroy(drv_obj);
diff -u -p a/staging/comedi/drivers/ni_6527.c b/staging/comedi/drivers/ni_6527.c
--- a/staging/comedi/drivers/ni_6527.c
+++ b/staging/comedi/drivers/ni_6527.c
@@ -469,6 +469,11 @@ static int ni6527_find_device(struct com
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -484,6 +489,12 @@ static int ni6527_find_device(struct com
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "comedi 6527: no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/mite.c b/staging/comedi/drivers/mite.c
--- a/staging/comedi/drivers/mite.c
+++ b/staging/comedi/drivers/mite.c
@@ -212,10 +212,21 @@ void mite_cleanup(void)
 {
 	struct mite_struct *mite, *next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = next) {
 		pci_dev_put(mite->pcidev);
 		next = mite->next;
 		kfree(mite);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -248,12 +259,24 @@ void mite_list_devices(void)
 	struct mite_struct *mite, *next;
 
 	printk(KERN_INFO "Available NI device IDs:");
-	if (mite_devices)
-		for (mite = mite_devices; mite; mite = next) {
-			next = mite->next;
-			printk(KERN_INFO " 0x%04x", mite_device_id(mite));
-			if (mite->used)
-				printk(KERN_INFO "(used)");
+	if (mite_devices) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (mite = mite_devices; mite; mite = next) {
+				next = mite->next;
+				printk(KERN_INFO " 0x%04x", mite_device_id(mite));
+				if (mite->used)
+					printk(KERN_INFO "(used)");
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 		}
 	printk(KERN_INFO "\n");
 }
diff -u -p a/staging/comedi/drivers/amplc_dio200.c b/staging/comedi/drivers/amplc_dio200.c
--- a/staging/comedi/drivers/amplc_dio200.c
+++ b/staging/comedi/drivers/amplc_dio200.c
@@ -562,7 +562,12 @@ dio200_find_pci(struct comedi_device *de
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
-	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
 				      PCI_ANY_ID, pci_dev)) {
@@ -596,6 +601,12 @@ dio200_find_pci(struct comedi_device *de
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/ni_pcimio.c b/staging/comedi/drivers/ni_pcimio.c
--- a/staging/comedi/drivers/ni_pcimio.c
+++ b/staging/comedi/drivers/ni_pcimio.c
@@ -1769,6 +1769,11 @@ static int pcimio_find_device(struct com
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -1786,6 +1791,12 @@ static int pcimio_find_device(struct com
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/dt3000.c b/staging/comedi/drivers/dt3000.c
--- a/staging/comedi/drivers/dt3000.c
+++ b/staging/comedi/drivers/dt3000.c
@@ -1010,6 +1010,11 @@ static struct pci_dev *dt_pci_find_devic
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (from = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from);
 	     from != NULL;
 	     from = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from)) {
@@ -1022,6 +1027,12 @@ static struct pci_dev *dt_pci_find_devic
 		printk
 		    ("unknown Data Translation PCI device found with device_id=0x%04x\n",
 		     from->device);
+		    if (_cur < timeout) {
+			rdstcll(_cur);
+		    }
+		    else {
+			break;
+		    }
 	}
 	*board = -1;
 	return from;
diff -u -p a/staging/comedi/drivers/ni_670x.c b/staging/comedi/drivers/ni_670x.c
--- a/staging/comedi/drivers/ni_670x.c
+++ b/staging/comedi/drivers/ni_670x.c
@@ -362,6 +362,11 @@ static int ni_670x_find_device(struct co
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -379,6 +384,12 @@ static int ni_670x_find_device(struct co
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_INFO "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/dyna_pci10xx.c b/staging/comedi/drivers/dyna_pci10xx.c
--- a/staging/comedi/drivers/dyna_pci10xx.c
+++ b/staging/comedi/drivers/dyna_pci10xx.c
@@ -286,6 +286,11 @@ static int dyna_pci10xx_attach(struct co
 	/*
 	 * Probe the PCI bus and located the matching device
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
@@ -310,6 +315,12 @@ static int dyna_pci10xx_attach(struct co
 		}
 
 		goto found;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	printk(KERN_ERR "comedi: dyna_pci10xx: no supported device found!\n");
 	mutex_unlock(&start_stop_sem);
diff -u -p a/staging/comedi/drivers/adv_pci_dio.c b/staging/comedi/drivers/adv_pci_dio.c
--- a/staging/comedi/drivers/adv_pci_dio.c
+++ b/staging/comedi/drivers/adv_pci_dio.c
@@ -1077,10 +1077,21 @@ static int CheckAndAllocCard(struct come
 {
 	struct pci_dio_private *pr, *prev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pr = pci_priv, prev = NULL; pr != NULL; prev = pr, pr = pr->next) {
 		if (pr->pcidev == pcidev)
 			return 0; /* this card is used, look for another */
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (prev) {
diff -u -p a/staging/comedi/drivers/amplc_pci224.c b/staging/comedi/drivers/amplc_pci224.c
--- a/staging/comedi/drivers/amplc_pci224.c
+++ b/staging/comedi/drivers/amplc_pci224.c
@@ -1327,7 +1327,12 @@ pci224_find_pci(struct comedi_device *de
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
-	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID,
 				      pci_dev)) {
@@ -1359,6 +1364,12 @@ pci224_find_pci(struct comedi_device *de
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/amplc_pc236.c b/staging/comedi/drivers/amplc_pc236.c
--- a/staging/comedi/drivers/amplc_pc236.c
+++ b/staging/comedi/drivers/amplc_pc236.c
@@ -267,7 +267,12 @@ pc236_find_pci(struct comedi_device *dev
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
-	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
 				      PCI_ANY_ID, pci_dev)) {
@@ -301,6 +306,12 @@ pc236_find_pci(struct comedi_device *dev
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/ni_labpc.c b/staging/comedi/drivers/ni_labpc.c
--- a/staging/comedi/drivers/ni_labpc.c
+++ b/staging/comedi/drivers/ni_labpc.c
@@ -779,6 +779,11 @@ static int labpc_find_device(struct come
 {
 	struct mite_struct *mite;
 	int i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -798,6 +803,12 @@ static int labpc_find_device(struct come
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/ni_65xx.c b/staging/comedi/drivers/ni_65xx.c
--- a/staging/comedi/drivers/ni_65xx.c
+++ b/staging/comedi/drivers/ni_65xx.c
@@ -809,6 +809,11 @@ static int ni_65xx_find_device(struct co
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -824,6 +829,12 @@ static int ni_65xx_find_device(struct co
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_WARNING "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/amplc_pc263.c b/staging/comedi/drivers/amplc_pc263.c
--- a/staging/comedi/drivers/amplc_pc263.c
+++ b/staging/comedi/drivers/amplc_pc263.c
@@ -169,7 +169,12 @@ pc263_find_pci(struct comedi_device *dev
 	*pci_dev_p = NULL;
 
 	/* Look for matching PCI device. */
-	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
 	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
 				      PCI_ANY_ID, pci_dev)) {
@@ -203,6 +208,12 @@ pc263_find_pci(struct comedi_device *dev
 		/* Found a match. */
 		*pci_dev_p = pci_dev;
 		return 0;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* No match found. */
 	if (bus || slot) {
diff -u -p a/staging/comedi/drivers/cb_das16_cs.c b/staging/comedi/drivers/cb_das16_cs.c
--- a/staging/comedi/drivers/cb_das16_cs.c
+++ b/staging/comedi/drivers/cb_das16_cs.c
@@ -173,8 +173,20 @@ static int das16cs_attach(struct comedi_
 	printk("I/O base=0x%04lx ", dev->iobase);
 
 	printk("fingerprint:\n");
-	for (i = 0; i < 48; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 48; i += 2) {
 		printk("%04x ", inw(dev->iobase + i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	printk("\n");
 
diff -u -p a/staging/comedi/drivers/ni_660x.c b/staging/comedi/drivers/ni_660x.c
--- a/staging/comedi/drivers/ni_660x.c
+++ b/staging/comedi/drivers/ni_660x.c
@@ -1251,6 +1251,11 @@ static int ni_660x_find_device(struct co
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -1267,6 +1272,12 @@ static int ni_660x_find_device(struct co
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_WARNING "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers/ni_pcidio.c b/staging/comedi/drivers/ni_pcidio.c
--- a/staging/comedi/drivers/ni_pcidio.c
+++ b/staging/comedi/drivers/ni_pcidio.c
@@ -1295,6 +1295,11 @@ static int nidio_find_device(struct come
 	struct mite_struct *mite;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mite = mite_devices; mite; mite = mite->next) {
 		if (mite->used)
 			continue;
@@ -1311,6 +1316,12 @@ static int nidio_find_device(struct come
 				return 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_WARNING "no device found\n");
 	mite_list_devices();
diff -u -p a/staging/comedi/drivers.c b/staging/comedi/drivers.c
--- a/staging/comedi/drivers.c
+++ b/staging/comedi/drivers.c
@@ -115,6 +115,11 @@ int comedi_device_attach(struct comedi_d
 	if (dev->attached)
 		return -EBUSY;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
 			printk(KERN_INFO "comedi: failed to increment module count, skipping\n");
@@ -142,11 +147,22 @@ int comedi_device_attach(struct comedi_d
 			return ret;
 		}
 		goto attached;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*  recognize has failed if we get here */
 	/*  report valid board names before returning error */
-	for (driv = comedi_drivers; driv; driv = driv->next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (driv = comedi_drivers; driv; driv = driv->next) {
 		if (!try_module_get(driv->module)) {
 			printk(KERN_INFO
 			       "comedi: failed to increment module count\n");
@@ -154,6 +170,12 @@ int comedi_device_attach(struct comedi_d
 		}
 		comedi_report_boards(driv);
 		module_put(driv->module);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EIO;
 
@@ -216,11 +238,22 @@ int comedi_driver_unregister(struct come
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = comedi_drivers; prev->next; prev = prev->next) {
 		if (prev->next == driver) {
 			prev->next = driver->next;
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EINVAL;
 }
diff -u -p a/staging/comedi/proc.c b/staging/comedi/proc.c
--- a/staging/comedi/proc.c
+++ b/staging/comedi/proc.c
@@ -69,6 +69,11 @@ static int comedi_read(char *buf, char *
 	if (!devices_q)
 		l += sprintf(buf + l, "no devices\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (driv = comedi_drivers; driv; driv = driv->next) {
 		l += sprintf(buf + l, "%s:\n", driv->driver_name);
 		for (i = 0; i < driv->num_names; i++) {
@@ -78,6 +83,12 @@ static int comedi_read(char *buf, char *
 		}
 		if (!driv->num_names)
 			l += sprintf(buf + l, " %s\n", driv->driver_name);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return l;
diff -u -p a/spi/spi-tegra.c b/spi/spi-tegra.c
--- a/spi/spi-tegra.c
+++ b/spi/spi-tegra.c
@@ -213,12 +213,23 @@ static unsigned spi_tegra_fill_tx_fifo(s
 	val |= SLINK_WORD_SIZE(len / tspi->cur_bytes_per_word - 1);
 	spi_tegra_writel(tspi, val, SLINK_COMMAND);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i += tspi->cur_bytes_per_word) {
 		val = 0;
 		for (j = 0; j < tspi->cur_bytes_per_word; j++)
 			val |= tx_buf[i + j] << j * 8;
 
 		spi_tegra_writel(tspi, val, SLINK_TX_FIFO);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tspi->rx_dma_req.size = len / tspi->cur_bytes_per_word * 4;
@@ -234,10 +245,21 @@ static unsigned spi_tegra_drain_rx_fifo(
 	int i, j;
 	unsigned long val;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i += tspi->cur_bytes_per_word) {
 		val = tspi->rx_bb[i / tspi->cur_bytes_per_word];
 		for (j = 0; j < tspi->cur_bytes_per_word; j++)
 			rx_buf[i + j] = (val >> (j * 8)) & 0xff;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return len;
diff -u -p a/tty/isicom.c b/tty/isicom.c
--- a/tty/isicom.c
+++ b/tty/isicom.c
@@ -1416,6 +1416,11 @@ static int __devinit load_firmware(struc
 
 	retval = -EIO;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (frame = (struct stframe *)fw->data;
 			frame < (struct stframe *)(fw->data + fw->size);
 			frame = (struct stframe *)((u8 *)(frame + 1) +
@@ -1460,10 +1465,21 @@ static int __devinit load_firmware(struc
 				"Status:0x%x\n", index + 1, status);
 			goto errrelfw;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 /* XXX: should we test it by reading it back and comparing with original like
  * in load firmware package? */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (frame = (struct stframe *)fw->data;
 			frame < (struct stframe *)(fw->data + fw->size);
 			frame = (struct stframe *)((u8 *)(frame + 1) +
@@ -1524,6 +1540,12 @@ static int __devinit load_firmware(struc
 				"Card Status:0x%x\n", index + 1, status);
 			goto errrelfw;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* xfer ctrl */
diff -u -p a/tty/hvc/hvc_vio.c b/tty/hvc/hvc_vio.c
--- a/tty/hvc/hvc_vio.c
+++ b/tty/hvc/hvc_vio.c
@@ -378,6 +378,11 @@ static int udbg_hvc_getc_poll(void)
 static int udbg_hvc_getc(void)
 {
 	int ch;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		ch = udbg_hvc_getc_poll();
 		if (ch == -1) {
@@ -388,6 +393,12 @@ static int udbg_hvc_getc(void)
 		} else {
 			return ch;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/hvc/hvsi.c b/tty/hvc/hvsi.c
--- a/tty/hvc/hvsi.c
+++ b/tty/hvc/hvsi.c
@@ -551,6 +551,11 @@ static int __init poll_for_state(struct
 {
 	unsigned long end_jiffies = jiffies + HVSI_TIMEOUT;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		hvsi_interrupt(hp->virq, (void *)hp); /* get pending data */
 
@@ -560,6 +565,12 @@ static int __init poll_for_state(struct
 		mdelay(5);
 		if (time_after(jiffies, end_jiffies))
 			return -EIO;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/tty/hvc/hvc_beat.c b/tty/hvc/hvc_beat.c
--- a/tty/hvc/hvc_beat.c
+++ b/tty/hvc/hvc_beat.c
@@ -75,11 +75,22 @@ static int hvc_beat_put_chars(uint32_t v
 	unsigned long kb[2];
 	int rest, nlen;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rest = cnt; rest > 0; rest -= nlen) {
 		nlen = (rest > 16) ? 16 : rest;
 		memcpy(kb, buf, nlen);
 		beat_put_term_char(vtermno, nlen, kb[0], kb[1]);
 		buf += nlen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return cnt;
 }
diff -u -p a/tty/hvc/hvc_opal.c b/tty/hvc/hvc_opal.c
--- a/tty/hvc/hvc_opal.c
+++ b/tty/hvc/hvc_opal.c
@@ -305,6 +305,11 @@ static int udbg_opal_getc_poll(void)
 static int udbg_opal_getc(void)
 {
 	int ch;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		ch = udbg_opal_getc_poll();
 		if (ch == -1) {
@@ -315,6 +320,12 @@ static int udbg_opal_getc(void)
 		} else {
 			return ch;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/serial/8250_early.c b/tty/serial/8250_early.c
--- a/tty/serial/8250_early.c
+++ b/tty/serial/8250_early.c
@@ -83,11 +83,22 @@ static void __init wait_for_xmitr(struct
 {
 	unsigned int status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		status = serial_in(port, UART_LSR);
 		if ((status & BOTH_EMPTY) == BOTH_EMPTY)
 			return;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/serial/pch_uart.c b/tty/serial/pch_uart.c
--- a/tty/serial/pch_uart.c
+++ b/tty/serial/pch_uart.c
@@ -458,11 +458,22 @@ static int pch_uart_hal_read(struct eg20
 	u8 rbr, lsr;
 
 	lsr = ioread8(priv->membase + UART_LSR);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0, lsr = ioread8(priv->membase + UART_LSR);
 	     i < rx_size && lsr & UART_LSR_DR;
 	     lsr = ioread8(priv->membase + UART_LSR)) {
 		rbr = ioread8(priv->membase + PCH_UART_RBR);
 		buf[i++] = rbr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return i;
 }
diff -u -p a/tty/serial/mrst_max3110.c b/tty/serial/mrst_max3110.c
--- a/tty/serial/mrst_max3110.c
+++ b/tty/serial/mrst_max3110.c
@@ -369,12 +369,23 @@ receive_chars(struct uart_max3110 *max,
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (r = 0; w; r += usable, w -= usable) {
 		usable = tty_buffer_request_room(tty, w);
 		if (usable) {
 			tty_insert_flip_string(tty, buf + r, usable);
 			port->icount.rx += usable;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	tty_flip_buffer_push(tty);
 	tty_kref_put(tty);
diff -u -p a/tty/serial/68328serial.c b/tty/serial/68328serial.c
--- a/tty/serial/68328serial.c
+++ b/tty/serial/68328serial.c
@@ -616,7 +616,12 @@ static void rs_flush_chars(struct tty_st
 	if (serial_paranoia_check(info, tty->name, "rs_flush_chars"))
 		return;
 #ifndef USE_INTS
-	for(;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for(;;) {
 #endif
 
 	/* Enable transmitter */
@@ -647,6 +652,12 @@ static void rs_flush_chars(struct tty_st
 
 #ifndef USE_INTS
 	while (!(uart->utx.w & UTX_TX_AVAIL)) udelay(5);
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
 	}
 #endif
 	local_irq_restore(flags);
diff -u -p a/tty/n_r3964.c b/tty/n_r3964.c
--- a/tty/n_r3964.c
+++ b/tty/n_r3964.c
@@ -263,8 +263,20 @@ static void remove_from_tx_queue(struct
 #ifdef DEBUG_QUEUE
 	printk("r3964: remove_from_tx_queue: %p, length %u - ",
 		pHeader, pHeader->length);
-	for (pDump = pHeader; pDump; pDump = pDump->next)
-		printk("%p ", pDump);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (pDump = pHeader; pDump; pDump = pDump->next) {
+			printk("%p ", pDump);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
+	}
 	printk("\n");
 #endif
 
@@ -536,11 +548,22 @@ static void on_receive_block(struct r396
 	add_rx_queue(pInfo, pBlock);
 
 	/* notify attached client processes: */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pClient = pInfo->firstClient; pClient; pClient = pClient->next) {
 		if (pClient->sig_flags & R3964_SIG_DATA) {
 			add_msg(pClient, R3964_MSG_DATA, length, R3964_OK,
 				pBlock);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	wake_up_interruptible(&pInfo->read_wait);
 
@@ -739,10 +762,21 @@ static struct r3964_client_info *findCli
 {
 	struct r3964_client_info *pClient;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pClient = pInfo->firstClient; pClient; pClient = pClient->next) {
 		if (pClient->pid == pid) {
 			return pClient;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -755,6 +789,11 @@ static int enable_signals(struct r3964_i
 
 	if ((arg & R3964_SIG_ALL) == 0) {
 		/* Remove client from client list */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (ppClient = &pInfo->firstClient; *ppClient;
 		     ppClient = &(*ppClient)->next) {
 			pClient = *ppClient;
@@ -776,6 +815,12 @@ static int enable_signals(struct r3964_i
 				TRACE_M("enable_signals - kfree %p", pClient);
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		return -EINVAL;
 	} else {
diff -u -p a/tty/synclink_gt.c b/tty/synclink_gt.c
--- a/tty/synclink_gt.c
+++ b/tty/synclink_gt.c
@@ -2354,6 +2354,11 @@ static void isr_gpio(struct slgt_info *i
 	struct cond_wait *w, *prev;
 
 	/* wake processes waiting for specific transitions */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (w = info->gpio_wait_q, prev = NULL ; w != NULL ; w = w->next) {
 		if (w->data & changed) {
 			w->data = state;
@@ -2364,6 +2369,12 @@ static void isr_gpio(struct slgt_info *i
 				info->gpio_wait_q = w->next;
 		} else
 			prev = w;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -3745,8 +3756,20 @@ static void slgt_cleanup(void)
 	printk(KERN_INFO "unload %s\n", driver_name);
 
 	if (serial_driver) {
-		for (info=slgt_device_list ; info != NULL ; info=info->next_device)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (info=slgt_device_list ; info != NULL ; info=info->next_device) {
 			tty_unregister_device(serial_driver, info->line);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 		if ((rc = tty_unregister_driver(serial_driver)))
 			DBGERR(("tty_unregister_driver error=%d\n", rc));
 		put_tty_driver(serial_driver);
diff -u -p a/crypto/n2_core.c b/crypto/n2_core.c
--- a/crypto/n2_core.c
+++ b/crypto/n2_core.c
@@ -125,8 +125,19 @@ static irqreturn_t cwq_intr(int irq, voi
 	pr_err("CPU[%d]: CWQ gethead[%lx] hv_ret[%lu]\n",
 	       smp_processor_id(), new_head, hv_ret);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (off = q->head; off != new_head; off = spu_next_offset(q, off)) {
 		/* XXX ... XXX */
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	hv_ret = sun4v_ncs_sethead_marker(q->qhandle, new_head);
diff -u -p a/isdn/gigaset/bas-gigaset.c b/isdn/gigaset/bas-gigaset.c
--- a/isdn/gigaset/bas-gigaset.c
+++ b/isdn/gigaset/bas-gigaset.c
@@ -1310,6 +1310,11 @@ static void read_iso_tasklet(unsigned lo
 	int totleft, numbytes, offset, frame, rc;
 
 	/* loop while more completed URBs arrive in the meantime */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		/* retrieve URB */
 		spin_lock_irqsave(&ubc->isoinlock, flags);
@@ -1430,6 +1435,12 @@ error:
 			dump_urb(DEBUG_ISO, "resubmit isoc read", urb);
 			error_hangup(bcs);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/isdn/gigaset/capi.c b/isdn/gigaset/capi.c
--- a/isdn/gigaset/capi.c
+++ b/isdn/gigaset/capi.c
@@ -1698,12 +1698,23 @@ static void do_connect_resp(struct gigas
 			spin_unlock_irqrestore(&bcs->aplock, flags);
 			return;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (oap = bcs->ap; oap != NULL; oap = oap->bcnext) {
 			if (oap->bcnext == ap) {
 				oap->bcnext = oap->bcnext->bcnext;
 				spin_unlock_irqrestore(&bcs->aplock, flags);
 				return;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		spin_unlock_irqrestore(&bcs->aplock, flags);
 		dev_err(cs->dev, "%s: application %u not found\n",
diff -u -p a/isdn/hisax/gazel.c b/isdn/hisax/gazel.c
--- a/isdn/hisax/gazel.c
+++ b/isdn/hisax/gazel.c
@@ -323,8 +323,20 @@ release_io_gazel(struct IsdnCardState *c
 
 	switch (cs->subtyp) {
 		case R647:
-			for (i = 0x0000; i < 0xC000; i += 0x1000)
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0x0000; i < 0xC000; i += 0x1000) {
 				release_region(i + cs->hw.gazel.hscx[0], 16);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
 			release_region(0xC000 + cs->hw.gazel.hscx[0], 1);
 			break;
 
@@ -444,8 +456,20 @@ reserve_regions(struct IsdnCard *card, s
 					goto error;
 			}
 			if (i != 0xC000) {
-				for (j = 0; j < i; j+= 0x1000)
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (j = 0; j < i; j+= 0x1000) {
 					release_region(j + base, 16);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 				release_region(0xC000 + base, 1);
 				goto error;
 			}
diff -u -p a/isdn/hisax/config.c b/isdn/hisax/config.c
--- a/isdn/hisax/config.c
+++ b/isdn/hisax/config.c
@@ -1672,8 +1672,20 @@ static void hisax_bh(struct work_struct
 			pr = PH_ACTIVATE | INDICATION;
 		else
 			pr = PH_DEACTIVATE | INDICATION;
-		for (st = cs->stlist; st; st = st->next)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (st = cs->stlist; st; st = st->next) {
 			st->l1.l1l2(st, pr, NULL);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
 		
 	}
 }
diff -u -p a/isdn/hisax/ipacx.c b/isdn/hisax/ipacx.c
--- a/isdn/hisax/ipacx.c
+++ b/isdn/hisax/ipacx.c
@@ -210,8 +210,19 @@ dbusy_timer_handler(struct IsdnCardState
       debugl1(cs, "D-Channel Busy RBCHD %02x STARD %02x", rbchd, stard);
 		if (!(stard &0x40)) { // D-Channel Busy
 			set_bit(FLG_L1_DBUSY, &cs->HW_Flags);
-      for (st = cs->stlist; st; st = st->next) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (st = cs->stlist; st; st = st->next) {
 				st->l1.l1l2(st, PH_PAUSE | INDICATION, NULL); // flow control on
+				if (_cur < timeout) {
+							rdstcll(_cur);
+				}
+				else {
+							break;
+				}
 			}
 		} else {
 			// seems we lost an interrupt; reset transceiver */
diff -u -p a/isdn/capi/capidrv.c b/isdn/capi/capidrv.c
--- a/isdn/capi/capidrv.c
+++ b/isdn/capi/capidrv.c
@@ -380,6 +380,11 @@ static void free_plci(capidrv_contr * ca
 {
 	capidrv_plci **pp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pp = &card->plci_list; *pp; pp = &(*pp)->next) {
 		if (*pp == plcip) {
 			*pp = (*pp)->next;
@@ -389,6 +394,12 @@ static void free_plci(capidrv_contr * ca
 			kfree(plcip);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "capidrv-%d: free_plci %p (0x%x) not found, Huh?\n",
 	       card->contrnr, plcip, plcip->plci);
@@ -488,6 +499,11 @@ static int capidrv_del_ack(struct capidr
 	struct ncci_datahandle_queue **pp, *p;
 	int len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pp = &nccip->ackqueue; *pp; pp = &(*pp)->next) {
  		if ((*pp)->datahandle == datahandle) {
 			p = *pp;
@@ -496,6 +512,12 @@ static int capidrv_del_ack(struct capidr
 		        kfree(p);
 			return len;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -1;
 }
diff -u -p a/isdn/capi/capilib.c b/isdn/capi/capilib.c
--- a/isdn/capi/capilib.c
+++ b/isdn/capi/capilib.c
@@ -62,6 +62,11 @@ static inline int mq_enqueue(struct capi
 static inline int mq_dequeue(struct capilib_ncci * np, u16 msgid)
 {
 	struct capilib_msgidqueue **pp;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pp = &np->msgidqueue; *pp; pp = &(*pp)->next) {
 		if ((*pp)->msgid == msgid) {
 			struct capilib_msgidqueue *mq = *pp;
@@ -73,6 +78,12 @@ static inline int mq_dequeue(struct capi
 			np->nmsg--;
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/isdn/i4l/isdn_net.c b/isdn/i4l/isdn_net.c
--- a/isdn/i4l/isdn_net.c
+++ b/isdn/i4l/isdn_net.c
@@ -2983,6 +2983,11 @@ isdn_net_getphones(isdn_net_ioctl_phone
 	if (!p)
 		return -ENODEV;
 	inout &= 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (n = p->local->phone[inout]; n; n = n->next) {
 		if (more) {
 			put_user(' ', phones++);
@@ -2994,6 +2999,12 @@ isdn_net_getphones(isdn_net_ioctl_phone
 		phones += strlen(n->num);
 		count += strlen(n->num);
 		more = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	put_user(0, phones);
 	count++;
diff -u -p a/isdn/pcbit/drv.c b/isdn/pcbit/drv.c
--- a/isdn/pcbit/drv.c
+++ b/isdn/pcbit/drv.c
@@ -1064,6 +1064,11 @@ static int pcbit_check_msn(struct pcbit_
 {
 	struct msn_entry *ptr;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr=dev->msn_list; ptr; ptr=ptr->next) {
 
 		if (ptr->msn == NULL) 
@@ -1071,6 +1076,12 @@ static int pcbit_check_msn(struct pcbit_
 		
 		if (strcmp(ptr->msn, msn) == 0)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/isdn/hardware/eicon/message.c b/isdn/hardware/eicon/message.c
--- a/isdn/hardware/eicon/message.c
+++ b/isdn/hardware/eicon/message.c
@@ -7371,9 +7371,20 @@ static void add_ss(PLCI   * plci, byte c
 
   if(p){
     dbug(1,dprintf("add_ss(%x,len=%d)",code,p->length));
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for(i=2;i<(byte)p->length;i+=p->info[i]+2){
       dbug(1,dprintf("add_ss_ie(%x,len=%d)",p->info[i-1],p->info[i]));
       add_ie(plci, p->info[i-1], (byte   *)&(p->info[i]), (word)p->info[i]);
+      if (_cur < timeout) {
+        rdstcll(_cur);
+      }
+      else {
+        break;
+      }
     }
   }
 }
@@ -7386,10 +7397,21 @@ static byte getChannel(API_PARSE * p)
   byte i;
 
   if(p){
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for(i=2;i<(byte)p->length;i+=p->info[i]+2){
       if(p->info[i]==2){
         if(p->info[i-1]==ESC && p->info[i+1]==CHI) return (p->info[i+2]);
       }
+      if (_cur < timeout) {
+        rdstcll(_cur);
+      }
+      else {
+        break;
+      }
     }
   }
   return 0;
diff -u -p a/block/swim3.c b/block/swim3.c
--- a/block/swim3.c
+++ b/block/swim3.c
@@ -501,7 +501,12 @@ static inline void setup_transfer(struct
 
 static void act(struct floppy_state *fs)
 {
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (;;) {
 		swim3_dbg("  act loop, state=%d, req_cyl=%d, cur_cyl=%d\n",
 			  fs->state, fs->req_cyl, fs->cur_cyl);
 
@@ -565,6 +570,12 @@ static void act(struct floppy_state *fs)
 			swim3_err("Unknown state %d\n", fs->state);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/block/pktcdvd.c b/block/pktcdvd.c
--- a/block/pktcdvd.c
+++ b/block/pktcdvd.c
@@ -1454,6 +1454,11 @@ static void pkt_run_state_machine(struct
 
 	VPRINTK("run_state_machine: pkt %d\n", pkt->id);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		switch (pkt->state) {
 		case PACKET_WAITING_STATE:
@@ -1505,6 +1510,12 @@ static void pkt_run_state_machine(struct
 			BUG();
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/block/drbd/drbd_receiver.c b/block/drbd/drbd_receiver.c
--- a/block/drbd/drbd_receiver.c
+++ b/block/drbd/drbd_receiver.c
@@ -3391,6 +3391,11 @@ recv_bm_rle_bits(struct drbd_conf *mdev,
 	if (bits < 0)
 		return -EIO;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (have = bits; have > 0; s += rl, toggle = !toggle) {
 		bits = vli_decode_bits(&rl, look_ahead);
 		if (bits <= 0)
@@ -3420,6 +3425,12 @@ recv_bm_rle_bits(struct drbd_conf *mdev,
 			return -EIO;
 		look_ahead |= tmp << have;
 		have += bits;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	c->bit_offset = s;
diff -u -p a/pnp/pnpbios/core.c b/pnp/pnpbios/core.c
--- a/pnp/pnpbios/core.c
+++ b/pnp/pnpbios/core.c
@@ -445,6 +445,11 @@ static int __init pnpbios_probe_system(v
 	 * structure and, if one is found, sets up the selectors and
 	 * entry points
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (check = (union pnp_bios_install_struct *)__va(0xf0000);
 	     check < (union pnp_bios_install_struct *)__va(0xffff0);
 	     check = (void *)check + 16) {
@@ -480,6 +485,12 @@ static int __init pnpbios_probe_system(v
 		       check->fields.pm16dseg);
 		pnp_bios_install = check;
 		return 1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	printk(KERN_INFO "PnPBIOS: PnP BIOS support was not detected.\n");
diff -u -p a/pnp/core.c b/pnp/core.c
--- a/pnp/core.c
+++ b/pnp/core.c
@@ -192,8 +192,20 @@ int pnp_add_device(struct pnp_dev *dev)
 		return ret;
 
 	buf[0] = '\0';
-	for (id = dev->id; id; id = id->next)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (id = dev->id; id; id = id->next) {
 		len += scnprintf(buf + len, sizeof(buf) - len, " %s", id->id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	dev_printk(KERN_DEBUG, &dev->dev, "%s device, IDs%s (%s)\n",
 		   dev->protocol->name, buf,
diff -u -p a/pcmcia/rsrc_nonstatic.c b/pcmcia/rsrc_nonstatic.c
--- a/pcmcia/rsrc_nonstatic.c
+++ b/pcmcia/rsrc_nonstatic.c
@@ -423,6 +423,11 @@ static int do_mem_probe(struct pcmcia_so
 	/* cis_readable wants to map 2x map_size */
 	if (step < 2 * s->map_size)
 		step = 2 * s->map_size;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = j = base; i < base+num; i = j + step) {
 		if (!fail) {
 			for (j = i; j < base+num; j += step) {
@@ -443,6 +448,12 @@ static int do_mem_probe(struct pcmcia_so
 			sub_interval(&s_data->mem_db, i, j-i);
 			bad += j-i;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(bad ? "\n" : " clean.\n");
 	return num - bad;
@@ -500,6 +511,11 @@ static int validate_mem(struct pcmcia_so
 		return -ENODEV;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = s_data->mem_db.next; m != &s_data->mem_db; m = mm.next) {
 		mm = *m;
 		/* Only probe < 1 MB */
@@ -521,6 +537,12 @@ static int validate_mem(struct pcmcia_so
 							   readable, checksum);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ok > 0)
@@ -544,9 +566,20 @@ static int validate_mem(struct pcmcia_so
 	struct socket_data *s_data = s->resource_data;
 	unsigned long ok = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = s_data->mem_db.next; m != &s_data->mem_db; m = mm.next) {
 		mm = *m;
 		ok += do_mem_probe(s, mm.base, mm.num, readable, checksum);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (ok > 0)
 		return 0;
@@ -658,6 +691,11 @@ static int __nonstatic_adjust_io_region(
 	struct socket_data *s_data = s->resource_data;
 	int ret = -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = s_data->io_db.next; m != &s_data->io_db; m = m->next) {
 		unsigned long start = m->base;
 		unsigned long end = m->base + m->num - 1;
@@ -666,6 +704,12 @@ static int __nonstatic_adjust_io_region(
 			continue;
 
 		ret = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
@@ -1040,17 +1084,50 @@ static void nonstatic_release_resource_d
 	struct socket_data *data = s->resource_data;
 	struct resource_map *p, *q;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db_valid.next; p != &data->mem_db_valid; p = q) {
 		q = p->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db.next; p != &data->mem_db; p = q) {
 		q = p->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->io_db.next; p != &data->io_db; p = q) {
 		q = p->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1078,6 +1155,11 @@ static ssize_t show_io_db(struct device
 	mutex_lock(&s->ops_mutex);
 	data = s->resource_data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->io_db.next; p != &data->io_db; p = p->next) {
 		if (ret > (PAGE_SIZE - 10))
 			continue;
@@ -1085,6 +1167,12 @@ static ssize_t show_io_db(struct device
 				"0x%08lx - 0x%08lx\n",
 				((unsigned long) p->base),
 				((unsigned long) p->base + p->num - 1));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&s->ops_mutex);
@@ -1134,6 +1222,11 @@ static ssize_t show_mem_db(struct device
 	mutex_lock(&s->ops_mutex);
 	data = s->resource_data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db_valid.next; p != &data->mem_db_valid;
 	     p = p->next) {
 		if (ret > (PAGE_SIZE - 10))
@@ -1142,8 +1235,19 @@ static ssize_t show_mem_db(struct device
 				"0x%08lx - 0x%08lx\n",
 				((unsigned long) p->base),
 				((unsigned long) p->base + p->num - 1));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = data->mem_db.next; p != &data->mem_db; p = p->next) {
 		if (ret > (PAGE_SIZE - 10))
 			continue;
@@ -1151,6 +1255,12 @@ static ssize_t show_mem_db(struct device
 				"0x%08lx - 0x%08lx\n",
 				((unsigned long) p->base),
 				((unsigned long) p->base + p->num - 1));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&s->ops_mutex);
diff -u -p a/parport/share.c b/parport/share.c
--- a/parport/share.c
+++ b/parport/share.c
@@ -978,6 +978,11 @@ void parport_release(struct pardevice *d
 	/* If anybody is waiting, find out who's been there longest and
 	   then wake them up. (Note: no locking required) */
 	/* !!! LOCKING IS NEEDED HERE */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pd = port->waithead; pd; pd = pd->waitnext) {
 		if (pd->waiting & 2) { /* sleeping in claim_or_block */
 			parport_claim(pd);
@@ -991,14 +996,31 @@ void parport_release(struct pardevice *d
 		} else {
 			printk(KERN_ERR "%s: don't know how to wake %s\n", port->name, pd->name);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Nobody was waiting, so walk the list to see if anyone is
 	   interested in being woken up. (Note: no locking required) */
 	/* !!! LOCKING IS NEEDED HERE */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pd = port->devices; (port->cad == NULL) && pd; pd = pd->next) {
 		if (pd->wakeup && pd != dev)
 			pd->wakeup(pd->private);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 }
 
diff -u -p a/parport/procfs.c b/parport/procfs.c
--- a/parport/procfs.c
+++ b/parport/procfs.c
@@ -47,10 +47,21 @@ static int do_active_device(ctl_table *t
 		return 0;
 	}
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = port->devices; dev ; dev = dev->next) {
 		if(dev == port->cad) {
 			len += sprintf(buffer, "%s\n", dev->name);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if(!len) {
diff -u -p a/iommu/iova.c b/iommu/iova.c
--- a/iommu/iova.c
+++ b/iommu/iova.c
@@ -423,6 +423,11 @@ copy_reserved_iova(struct iova_domain *f
 	struct rb_node *node;
 
 	spin_lock_irqsave(&from->iova_rbtree_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (node = rb_first(&from->rbroot); node; node = rb_next(node)) {
 		struct iova *iova = container_of(node, struct iova, node);
 		struct iova *new_iova;
@@ -430,6 +435,12 @@ copy_reserved_iova(struct iova_domain *f
 		if (!new_iova)
 			printk(KERN_ERR "Reserve iova range %lx@%lx failed\n",
 				iova->pfn_lo, iova->pfn_lo);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	spin_unlock_irqrestore(&from->iova_rbtree_lock, flags);
 }
diff -u -p a/gpu/drm/nouveau/nv50_instmem.c b/gpu/drm/nouveau/nv50_instmem.c
--- a/gpu/drm/nouveau/nv50_instmem.c
+++ b/gpu/drm/nouveau/nv50_instmem.c
@@ -139,8 +139,20 @@ nv50_instmem_init(struct drm_device *dev
 	dev_priv->engine.instmem.priv = priv;
 
 	/* Save state, will restore at takedown. */
-	for (i = 0x1700; i <= 0x1710; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x1700; i <= 0x1710; i += 4) {
 		priv->save1700[(i-0x1700)/4] = nv_rd32(dev, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* Global PRAMIN heap */
 	ret = drm_mm_init(&dev_priv->ramin_heap, 0, dev_priv->ramin_size);
@@ -246,8 +258,20 @@ nv50_instmem_takedown(struct drm_device
 
 	nouveau_vm_ref(NULL, &dev_priv->chan_vm, NULL);
 
-	for (i = 0x1700; i <= 0x1710; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x1700; i <= 0x1710; i += 4) {
 		nv_wr32(dev, i, priv->save1700[(i - 0x1700) / 4]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	nouveau_gpuobj_ref(NULL, &priv->bar3_dmaobj);
 	nouveau_gpuobj_ref(NULL, &priv->bar1_dmaobj);
diff -u -p a/gpu/drm/nouveau/nouveau_state.c b/gpu/drm/nouveau/nouveau_state.c
--- a/gpu/drm/nouveau/nouveau_state.c
+++ b/gpu/drm/nouveau/nouveau_state.c
@@ -944,8 +944,20 @@ static void nouveau_OF_copy_vbios_to_ram
 
 	bios = of_get_property(dn, "NVDA,BMP", &size);
 	if (bios) {
-		for (i = 0; i < size; i += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < size; i += 4) {
 			nv_wi32(dev, i, bios[i/4]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 		NV_INFO(dev, "OF bios successfully copied (%d bytes)\n", size);
 	} else {
 		NV_INFO(dev, "Unable to get the OF bios\n");
diff -u -p a/gpu/drm/nouveau/nv40_grctx.c b/gpu/drm/nouveau/nv40_grctx.c
--- a/gpu/drm/nouveau/nv40_grctx.c
+++ b/gpu/drm/nouveau/nv40_grctx.c
@@ -588,10 +588,34 @@ nv40_graph_construct_shader(struct nouve
 		nv_wo32(obj, offset * 4, 0x3f800000);
 
 	for (vs = 0; vs < vs_nr; vs++, offset += vs_len) {
-		for (i = 0; i < vs_nr_b0 * 6; i += 6)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < vs_nr_b0 * 6; i += 6) {
 			nv_wo32(obj, (offset + b0_offset + i) * 4, 0x00000001);
-		for (i = 0; i < vs_nr_b1 * 4; i += 4)
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < vs_nr_b1 * 4; i += 4) {
 			nv_wo32(obj, (offset + b1_offset + i) * 4, 0x3f800000);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 }
 
diff -u -p a/gpu/drm/nouveau/nouveau_object.c b/gpu/drm/nouveau/nouveau_object.c
--- a/gpu/drm/nouveau/nouveau_object.c
+++ b/gpu/drm/nouveau/nouveau_object.c
@@ -224,8 +224,20 @@ nouveau_gpuobj_new(struct drm_device *de
 	}
 
 	if (gpuobj->flags & NVOBJ_FLAG_ZERO_ALLOC) {
-		for (i = 0; i < gpuobj->size; i += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < gpuobj->size; i += 4) {
 			nv_wo32(gpuobj, i, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 		instmem->flush(dev);
 	}
 
@@ -284,8 +296,20 @@ nouveau_gpuobj_del(struct kref *ref)
 	NV_DEBUG(dev, "gpuobj %p\n", gpuobj);
 
 	if (gpuobj->node && (gpuobj->flags & NVOBJ_FLAG_ZERO_FREE)) {
-		for (i = 0; i < gpuobj->size; i += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < gpuobj->size; i += 4) {
 			nv_wo32(gpuobj, i, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 		instmem->flush(dev);
 	}
 
@@ -349,8 +373,20 @@ nouveau_gpuobj_new_fake(struct drm_devic
 	gpuobj->vinst = vinst;
 
 	if (gpuobj->flags & NVOBJ_FLAG_ZERO_ALLOC) {
-		for (i = 0; i < gpuobj->size; i += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < gpuobj->size; i += 4) {
 			nv_wo32(gpuobj, i, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 		dev_priv->engine.instmem.flush(dev);
 	}
 
@@ -913,8 +949,20 @@ nouveau_gpuobj_suspend(struct drm_device
 			return -ENOMEM;
 		}
 
-		for (i = 0; i < gpuobj->size; i += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < gpuobj->size; i += 4) {
 			gpuobj->suspend[i/4] = nv_ro32(gpuobj, i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 
 	return 0;
@@ -931,8 +979,20 @@ nouveau_gpuobj_resume(struct drm_device
 		if (!gpuobj->suspend)
 			continue;
 
-		for (i = 0; i < gpuobj->size; i += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < gpuobj->size; i += 4) {
 			nv_wo32(gpuobj, i, gpuobj->suspend[i/4]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 
 		vfree(gpuobj->suspend);
 		gpuobj->suspend = NULL;
diff -u -p a/gpu/drm/nouveau/nva3_copy.c b/gpu/drm/nouveau/nva3_copy.c
--- a/gpu/drm/nouveau/nva3_copy.c
+++ b/gpu/drm/nouveau/nva3_copy.c
@@ -96,8 +96,20 @@ nva3_copy_context_del(struct nouveau_cha
 	/* restore fifo access */
 	nv_wr32(dev, 0x104048, 0x00000003);
 
-	for (inst = 0xc0; inst <= 0xd4; inst += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (inst = 0xc0; inst <= 0xd4; inst += 4) {
 		nv_wo32(chan->ramin, inst, 0x00000000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	nouveau_gpuobj_ref(NULL, &ctx);
 
diff -u -p a/gpu/drm/nouveau/nvc0_grctx.c b/gpu/drm/nouveau/nvc0_grctx.c
--- a/gpu/drm/nouveau/nvc0_grctx.c
+++ b/gpu/drm/nouveau/nvc0_grctx.c
@@ -828,8 +828,20 @@ nvc0_grctx_generate_9097(struct drm_devi
 	nv_mthd(dev, 0x9097, 0x1ed8, 0x00000001);
 	nv_mthd(dev, 0x9097, 0x1ef8, 0x00000001);
 	if (fermi == 0x9097) {
-		for (mthd = 0x3400; mthd <= 0x35fc; mthd += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (mthd = 0x3400; mthd <= 0x35fc; mthd += 4) {
 			nv_mthd(dev, 0x9097, mthd, 0x00000000);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 	nv_mthd(dev, 0x9097, 0x030c, 0x00000001);
 	nv_mthd(dev, 0x9097, 0x1944, 0x00000000);
@@ -1206,8 +1218,20 @@ nvc0_grctx_generate_9197(struct drm_devi
 	u32 mthd;
 
 	if (fermi == 0x9197) {
-		for (mthd = 0x3400; mthd <= 0x35fc; mthd += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (mthd = 0x3400; mthd <= 0x35fc; mthd += 4) {
 			nv_mthd(dev, 0x9197, mthd, 0x00000000);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 	nv_mthd(dev, 0x9197, 0x02e4, 0x0000b001);
 }
@@ -1219,8 +1243,20 @@ nvc0_grctx_generate_9297(struct drm_devi
 	u32 mthd;
 
 	if (fermi == 0x9297) {
-		for (mthd = 0x3400; mthd <= 0x35fc; mthd += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (mthd = 0x3400; mthd <= 0x35fc; mthd += 4) {
 			nv_mthd(dev, 0x9297, mthd, 0x00000000);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 	nv_mthd(dev, 0x9297, 0x036c, 0x00000000);
 	nv_mthd(dev, 0x9297, 0x0370, 0x00000000);
diff -u -p a/gpu/drm/nouveau/nvc0_graph.c b/gpu/drm/nouveau/nvc0_graph.c
--- a/gpu/drm/nouveau/nvc0_graph.c
+++ b/gpu/drm/nouveau/nvc0_graph.c
@@ -140,8 +140,20 @@ nvc0_graph_construct_context(struct nouv
 			goto err;
 	}
 
-	for (i = 0; i < priv->grctx_size; i += 4)
-		ctx[i / 4] = nv_ro32(grch->grctx, i);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < priv->grctx_size; i += 4) {
+			ctx[i / 4] = nv_ro32(grch->grctx, i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+	}
 
 	priv->grctx_vals = ctx;
 	return 0;
@@ -282,8 +294,20 @@ nvc0_graph_context_new(struct nouveau_ch
 			goto error;
 	}
 
-	for (i = 0; i < priv->grctx_size; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < priv->grctx_size; i += 4) {
 		nv_wo32(grctx, i, priv->grctx_vals[i / 4]);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 
 	if (!nouveau_ctxfw) {
 		nv_wo32(grctx, 0x00, grch->mmio_nr);
diff -u -p a/gpu/drm/nouveau/nv50_graph.c b/gpu/drm/nouveau/nv50_graph.c
--- a/gpu/drm/nouveau/nv50_graph.c
+++ b/gpu/drm/nouveau/nv50_graph.c
@@ -284,8 +284,20 @@ nv50_graph_context_del(struct nouveau_ch
 	if (nv50_graph_channel(dev) == chan)
 		nv50_graph_unload_context(dev);
 
-	for (i = hdr; i < hdr + 24; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = hdr; i < hdr + 24; i += 4) {
 		nv_wo32(chan->ramin, i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	dev_priv->engine.instmem.flush(dev);
 
 	nv50_graph_fifo_access(dev, true);
@@ -610,9 +622,21 @@ nv50_pgraph_tp_trap(struct drm_device *d
 		case 6: /* texture error... unknown for now */
 			if (display) {
 				NV_ERROR(dev, "magic set %d:\n", i);
-				for (r = ustatus_addr + 4; r <= ustatus_addr + 0x10; r += 4)
-					NV_ERROR(dev, "\t0x%08x: 0x%08x\n", r,
-						nv_rd32(dev, r));
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (r = ustatus_addr + 4; r <= ustatus_addr + 0x10; r += 4) {
+						NV_ERROR(dev, "\t0x%08x: 0x%08x\n", r,
+					nv_rd32(dev, r));
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 			}
 			break;
 		case 7: /* MP error */
diff -u -p a/gpu/drm/nouveau/nouveau_fence.c b/gpu/drm/nouveau/nouveau_fence.c
--- a/gpu/drm/nouveau/nouveau_fence.c
+++ b/gpu/drm/nouveau/nouveau_fence.c
@@ -296,8 +296,20 @@ semaphore_alloc(struct drm_device *dev)
 
 	kref_init(&sema->ref);
 	sema->dev = dev;
-	for (i = sema->mem->start; i < sema->mem->start + size; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = sema->mem->start; i < sema->mem->start + size; i += 4) {
 		nouveau_bo_wr32(dev_priv->fence.bo, i / 4, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	return sema;
 fail:
diff -u -p a/gpu/drm/nouveau/nouveau_bios.c b/gpu/drm/nouveau/nouveau_bios.c
--- a/gpu/drm/nouveau/nouveau_bios.c
+++ b/gpu/drm/nouveau/nouveau_bios.c
@@ -6700,8 +6700,20 @@ static int load_nv17_hwsq_ucode_entry(st
 	bytes_to_write -= 4;
 
 	/* write ucode */
-	for (i = 0; i < bytes_to_write; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < bytes_to_write; i += 4) {
 		bios_wr32(bios, 0x00001400 + i, ROM32(bios->data[hwsq_entry_offset + i + 4]));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 
 	/* twiddle NV_PBUS_DEBUG_4 */
 	bios_wr32(bios, NV_PBUS_DEBUG_4, bios_rd32(bios, NV_PBUS_DEBUG_4) | 0x18);
diff -u -p a/gpu/drm/nouveau/nouveau_ramht.c b/gpu/drm/nouveau/nouveau_ramht.c
--- a/gpu/drm/nouveau/nouveau_ramht.c
+++ b/gpu/drm/nouveau/nouveau_ramht.c
@@ -38,9 +38,20 @@ nouveau_ramht_hash_handle(struct nouveau
 
 	NV_DEBUG(dev, "ch%d handle=0x%08x\n", chan->id, handle);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 32; i > 0; i -= ramht->bits) {
 		hash ^= (handle & ((1 << ramht->bits) - 1));
 		handle >>= ramht->bits;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (dev_priv->card_type < NV_50)
diff -u -p a/gpu/drm/nouveau/nv50_mpeg.c b/gpu/drm/nouveau/nv50_mpeg.c
--- a/gpu/drm/nouveau/nv50_mpeg.c
+++ b/gpu/drm/nouveau/nv50_mpeg.c
@@ -96,8 +96,20 @@ nv50_mpeg_context_del(struct nouveau_cha
 	nv_mask(dev, 0x00b32c, 0x00000001, 0x00000001);
 	spin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);
 
-	for (i = 0x00; i <= 0x14; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x00; i <= 0x14; i += 4) {
 		nv_wo32(chan->ramin, CTX_PTR(dev, i), 0x00000000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nouveau_gpuobj_ref(NULL, &ctx);
 	chan->engctx[engine] = NULL;
 }
diff -u -p a/gpu/drm/nouveau/nv50_evo.c b/gpu/drm/nouveau/nv50_evo.c
--- a/gpu/drm/nouveau/nv50_evo.c
+++ b/gpu/drm/nouveau/nv50_evo.c
@@ -370,8 +370,20 @@ nv50_evo_create(struct drm_device *dev)
 		if (ret)
 			goto err;
 
-		for (j = 0; j < 4096; j += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (j = 0; j < 4096; j += 4) {
 			nouveau_bo_wr32(dispc->sem.bo, j / 4, 0x74b1e000);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
 		dispc->sem.offset = 0;
 	}
 
diff -u -p a/gpu/drm/nouveau/nv20_graph.c b/gpu/drm/nouveau/nv20_graph.c
--- a/gpu/drm/nouveau/nv20_graph.c
+++ b/gpu/drm/nouveau/nv20_graph.c
@@ -97,18 +97,90 @@ nv20_graph_context_init(struct nouveau_g
 	nv_wo32(ctx, 0x047c, 0x00000101);
 	nv_wo32(ctx, 0x0490, 0x00000111);
 	nv_wo32(ctx, 0x04a8, 0x44400000);
-	for (i = 0x04d4; i <= 0x04e0; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x04d4; i <= 0x04e0; i += 4) {
 		nv_wo32(ctx, i, 0x00030303);
-	for (i = 0x04f4; i <= 0x0500; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x04f4; i <= 0x0500; i += 4) {
 		nv_wo32(ctx, i, 0x00080000);
-	for (i = 0x050c; i <= 0x0518; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x050c; i <= 0x0518; i += 4) {
 		nv_wo32(ctx, i, 0x01012000);
-	for (i = 0x051c; i <= 0x0528; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x051c; i <= 0x0528; i += 4) {
 		nv_wo32(ctx, i, 0x000105b8);
-	for (i = 0x052c; i <= 0x0538; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x052c; i <= 0x0538; i += 4) {
 		nv_wo32(ctx, i, 0x00080008);
-	for (i = 0x055c; i <= 0x0598; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x055c; i <= 0x0598; i += 4) {
 		nv_wo32(ctx, i, 0x07ff0000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x05a4, 0x4b7fffff);
 	nv_wo32(ctx, 0x05fc, 0x00000001);
 	nv_wo32(ctx, 0x0604, 0x00004000);
@@ -132,8 +204,20 @@ nv20_graph_context_init(struct nouveau_g
 	nv_wo32(ctx, 0x34a4, 0x000fe000);
 	nv_wo32(ctx, 0x3530, 0x000003f8);
 	nv_wo32(ctx, 0x3540, 0x002fe000);
-	for (i = 0x355c; i <= 0x3578; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x355c; i <= 0x3578; i += 4) {
 		nv_wo32(ctx, i, 0x001c527c);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static void
@@ -151,18 +235,90 @@ nv25_graph_context_init(struct nouveau_g
 	nv_wo32(ctx, 0x04d0, 0x00000001);
 	nv_wo32(ctx, 0x04e4, 0x44400000);
 	nv_wo32(ctx, 0x04fc, 0x4b800000);
-	for (i = 0x0510; i <= 0x051c; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0510; i <= 0x051c; i += 4) {
 		nv_wo32(ctx, i, 0x00030303);
-	for (i = 0x0530; i <= 0x053c; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0530; i <= 0x053c; i += 4) {
 		nv_wo32(ctx, i, 0x00080000);
-	for (i = 0x0548; i <= 0x0554; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0548; i <= 0x0554; i += 4) {
 		nv_wo32(ctx, i, 0x01012000);
-	for (i = 0x0558; i <= 0x0564; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0558; i <= 0x0564; i += 4) {
 		nv_wo32(ctx, i, 0x000105b8);
-	for (i = 0x0568; i <= 0x0574; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0568; i <= 0x0574; i += 4) {
 		nv_wo32(ctx, i, 0x00080008);
-	for (i = 0x0598; i <= 0x05d4; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0598; i <= 0x05d4; i += 4) {
 		nv_wo32(ctx, i, 0x07ff0000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x05e0, 0x4b7fffff);
 	nv_wo32(ctx, 0x0620, 0x00000080);
 	nv_wo32(ctx, 0x0624, 0x30201000);
@@ -191,8 +347,20 @@ nv25_graph_context_init(struct nouveau_g
 	nv_wo32(ctx, 0x308c, 0x000fe000);
 	nv_wo32(ctx, 0x3108, 0x000003f8);
 	nv_wo32(ctx, 0x3468, 0x002fe000);
-	for (i = 0x3484; i <= 0x34a0; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x3484; i <= 0x34a0; i += 4) {
 		nv_wo32(ctx, i, 0x001c527c);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static void
@@ -206,18 +374,90 @@ nv2a_graph_context_init(struct nouveau_g
 	nv_wo32(ctx, 0x047c, 0x00000101);
 	nv_wo32(ctx, 0x0490, 0x00000111);
 	nv_wo32(ctx, 0x04a8, 0x44400000);
-	for (i = 0x04d4; i <= 0x04e0; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x04d4; i <= 0x04e0; i += 4) {
 		nv_wo32(ctx, i, 0x00030303);
-	for (i = 0x04f4; i <= 0x0500; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x04f4; i <= 0x0500; i += 4) {
 		nv_wo32(ctx, i, 0x00080000);
-	for (i = 0x050c; i <= 0x0518; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x050c; i <= 0x0518; i += 4) {
 		nv_wo32(ctx, i, 0x01012000);
-	for (i = 0x051c; i <= 0x0528; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x051c; i <= 0x0528; i += 4) {
 		nv_wo32(ctx, i, 0x000105b8);
-	for (i = 0x052c; i <= 0x0538; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x052c; i <= 0x0538; i += 4) {
 		nv_wo32(ctx, i, 0x00080008);
-	for (i = 0x055c; i <= 0x0598; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x055c; i <= 0x0598; i += 4) {
 		nv_wo32(ctx, i, 0x07ff0000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x05a4, 0x4b7fffff);
 	nv_wo32(ctx, 0x05fc, 0x00000001);
 	nv_wo32(ctx, 0x0604, 0x00004000);
@@ -241,8 +481,20 @@ nv2a_graph_context_init(struct nouveau_g
 	nv_wo32(ctx, 0x3024, 0x000fe000);
 	nv_wo32(ctx, 0x30a0, 0x000003f8);
 	nv_wo32(ctx, 0x33fc, 0x002fe000);
-	for (i = 0x341c; i <= 0x3438; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x341c; i <= 0x3438; i += 4) {
 		nv_wo32(ctx, i, 0x001c527c);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static void
@@ -258,11 +510,35 @@ nv30_31_graph_context_init(struct nouvea
 	nv_wo32(ctx, 0x044c, 0x00000001);
 	nv_wo32(ctx, 0x0460, 0x44400000);
 	nv_wo32(ctx, 0x048c, 0xffff0000);
-	for (i = 0x04e0; i < 0x04e8; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x04e0; i < 0x04e8; i += 4) {
 		nv_wo32(ctx, i, 0x0fff0000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x04ec, 0x00011100);
-	for (i = 0x0508; i < 0x0548; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0508; i < 0x0548; i += 4) {
 		nv_wo32(ctx, i, 0x07ff0000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x0550, 0x4b7fffff);
 	nv_wo32(ctx, 0x058c, 0x00000080);
 	nv_wo32(ctx, 0x0590, 0x30201000);
@@ -270,27 +546,111 @@ nv30_31_graph_context_init(struct nouvea
 	nv_wo32(ctx, 0x0598, 0xb8a89888);
 	nv_wo32(ctx, 0x059c, 0xf8e8d8c8);
 	nv_wo32(ctx, 0x05b0, 0xb0000000);
-	for (i = 0x0600; i < 0x0640; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0600; i < 0x0640; i += 4) {
 		nv_wo32(ctx, i, 0x00010588);
-	for (i = 0x0640; i < 0x0680; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0640; i < 0x0680; i += 4) {
 		nv_wo32(ctx, i, 0x00030303);
-	for (i = 0x06c0; i < 0x0700; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x06c0; i < 0x0700; i += 4) {
 		nv_wo32(ctx, i, 0x0008aae4);
-	for (i = 0x0700; i < 0x0740; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0700; i < 0x0740; i += 4) {
 		nv_wo32(ctx, i, 0x01012000);
-	for (i = 0x0740; i < 0x0780; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0740; i < 0x0780; i += 4) {
 		nv_wo32(ctx, i, 0x00080008);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x085c, 0x00040000);
 	nv_wo32(ctx, 0x0860, 0x00010000);
-	for (i = 0x0864; i < 0x0874; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0864; i < 0x0874; i += 4) {
 		nv_wo32(ctx, i, 0x00040004);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	for (i = 0x1f18; i <= 0x3088 ; i += 16) {
 		nv_wo32(ctx, i + 0, 0x10700ff9);
 		nv_wo32(ctx, i + 1, 0x0436086c);
 		nv_wo32(ctx, i + 2, 0x000c001b);
 	}
-	for (i = 0x30b8; i < 0x30c8; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x30b8; i < 0x30c8; i += 4) {
 		nv_wo32(ctx, i, 0x0000ffff);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x344c, 0x3f800000);
 	nv_wo32(ctx, 0x3808, 0x3f800000);
 	nv_wo32(ctx, 0x381c, 0x3f800000);
@@ -316,11 +676,35 @@ nv34_graph_context_init(struct nouveau_g
 	nv_wo32(ctx, 0x0448, 0x00000001);
 	nv_wo32(ctx, 0x045c, 0x44400000);
 	nv_wo32(ctx, 0x0480, 0xffff0000);
-	for (i = 0x04d4; i < 0x04dc; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x04d4; i < 0x04dc; i += 4) {
 		nv_wo32(ctx, i, 0x0fff0000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x04e0, 0x00011100);
-	for (i = 0x04fc; i < 0x053c; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x04fc; i < 0x053c; i += 4) {
 		nv_wo32(ctx, i, 0x07ff0000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x0544, 0x4b7fffff);
 	nv_wo32(ctx, 0x057c, 0x00000080);
 	nv_wo32(ctx, 0x0580, 0x30201000);
@@ -328,27 +712,111 @@ nv34_graph_context_init(struct nouveau_g
 	nv_wo32(ctx, 0x0588, 0xb8a89888);
 	nv_wo32(ctx, 0x058c, 0xf8e8d8c8);
 	nv_wo32(ctx, 0x05a0, 0xb0000000);
-	for (i = 0x05f0; i < 0x0630; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x05f0; i < 0x0630; i += 4) {
 		nv_wo32(ctx, i, 0x00010588);
-	for (i = 0x0630; i < 0x0670; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0630; i < 0x0670; i += 4) {
 		nv_wo32(ctx, i, 0x00030303);
-	for (i = 0x06b0; i < 0x06f0; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x06b0; i < 0x06f0; i += 4) {
 		nv_wo32(ctx, i, 0x0008aae4);
-	for (i = 0x06f0; i < 0x0730; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x06f0; i < 0x0730; i += 4) {
 		nv_wo32(ctx, i, 0x01012000);
-	for (i = 0x0730; i < 0x0770; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0730; i < 0x0770; i += 4) {
 		nv_wo32(ctx, i, 0x00080008);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x0850, 0x00040000);
 	nv_wo32(ctx, 0x0854, 0x00010000);
-	for (i = 0x0858; i < 0x0868; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0858; i < 0x0868; i += 4) {
 		nv_wo32(ctx, i, 0x00040004);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	for (i = 0x15ac; i <= 0x271c ; i += 16) {
 		nv_wo32(ctx, i + 0, 0x10700ff9);
 		nv_wo32(ctx, i + 1, 0x0436086c);
 		nv_wo32(ctx, i + 2, 0x000c001b);
 	}
-	for (i = 0x274c; i < 0x275c; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x274c; i < 0x275c; i += 4) {
 		nv_wo32(ctx, i, 0x0000ffff);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x2ae0, 0x3f800000);
 	nv_wo32(ctx, 0x2e9c, 0x3f800000);
 	nv_wo32(ctx, 0x2eb0, 0x3f800000);
@@ -374,11 +842,35 @@ nv35_36_graph_context_init(struct nouvea
 	nv_wo32(ctx, 0x0448, 0x00000001);
 	nv_wo32(ctx, 0x045c, 0x44400000);
 	nv_wo32(ctx, 0x0488, 0xffff0000);
-	for (i = 0x04dc; i < 0x04e4; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x04dc; i < 0x04e4; i += 4) {
 		nv_wo32(ctx, i, 0x0fff0000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x04e8, 0x00011100);
-	for (i = 0x0504; i < 0x0544; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0504; i < 0x0544; i += 4) {
 		nv_wo32(ctx, i, 0x07ff0000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x054c, 0x4b7fffff);
 	nv_wo32(ctx, 0x0588, 0x00000080);
 	nv_wo32(ctx, 0x058c, 0x30201000);
@@ -386,27 +878,111 @@ nv35_36_graph_context_init(struct nouvea
 	nv_wo32(ctx, 0x0594, 0xb8a89888);
 	nv_wo32(ctx, 0x0598, 0xf8e8d8c8);
 	nv_wo32(ctx, 0x05ac, 0xb0000000);
-	for (i = 0x0604; i < 0x0644; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0604; i < 0x0644; i += 4) {
 		nv_wo32(ctx, i, 0x00010588);
-	for (i = 0x0644; i < 0x0684; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0644; i < 0x0684; i += 4) {
 		nv_wo32(ctx, i, 0x00030303);
-	for (i = 0x06c4; i < 0x0704; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x06c4; i < 0x0704; i += 4) {
 		nv_wo32(ctx, i, 0x0008aae4);
-	for (i = 0x0704; i < 0x0744; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0704; i < 0x0744; i += 4) {
 		nv_wo32(ctx, i, 0x01012000);
-	for (i = 0x0744; i < 0x0784; i += 4)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0744; i < 0x0784; i += 4) {
 		nv_wo32(ctx, i, 0x00080008);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x0860, 0x00040000);
 	nv_wo32(ctx, 0x0864, 0x00010000);
-	for (i = 0x0868; i < 0x0878; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x0868; i < 0x0878; i += 4) {
 		nv_wo32(ctx, i, 0x00040004);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	for (i = 0x1f1c; i <= 0x308c ; i += 16) {
 		nv_wo32(ctx, i + 0, 0x10700ff9);
 		nv_wo32(ctx, i + 4, 0x0436086c);
 		nv_wo32(ctx, i + 8, 0x000c001b);
 	}
-	for (i = 0x30bc; i < 0x30cc; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x30bc; i < 0x30cc; i += 4) {
 		nv_wo32(ctx, i, 0x0000ffff);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	nv_wo32(ctx, 0x3450, 0x3f800000);
 	nv_wo32(ctx, 0x380c, 0x3f800000);
 	nv_wo32(ctx, 0x3820, 0x3f800000);
diff -u -p a/gpu/drm/radeon/evergreen.c b/gpu/drm/radeon/evergreen.c
--- a/gpu/drm/radeon/evergreen.c
+++ b/gpu/drm/radeon/evergreen.c
@@ -2276,10 +2276,34 @@ static void evergreen_gpu_init(struct ra
 	WREG32(CB_COLOR11_BASE, 0);
 
 	/* set the shader const cache sizes to 0 */
-	for (i = SQ_ALU_CONST_BUFFER_SIZE_PS_0; i < 0x28200; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = SQ_ALU_CONST_BUFFER_SIZE_PS_0; i < 0x28200; i += 4) {
 		WREG32(i, 0);
-	for (i = SQ_ALU_CONST_BUFFER_SIZE_HS_0; i < 0x29000; i += 4)
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = SQ_ALU_CONST_BUFFER_SIZE_HS_0; i < 0x29000; i += 4) {
 		WREG32(i, 0);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 
 	tmp = RREG32(HDP_MISC_CNTL);
 	tmp |= HDP_FLUSH_INVALIDATE_CACHE;
diff -u -p a/gpu/drm/drm_edid.c b/gpu/drm/drm_edid.c
--- a/gpu/drm/drm_edid.c
+++ b/gpu/drm/drm_edid.c
@@ -1455,6 +1455,11 @@ void drm_edid_to_eld(struct drm_connecto
 	eld[18] = edid->prod_code[0];
 	eld[19] = edid->prod_code[1];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (db = cea + 4; db < cea + cea[2]; db += dbl + 1) {
 		dbl = db[0] & 0x1f;
 
@@ -1474,6 +1479,12 @@ void drm_edid_to_eld(struct drm_connecto
 		default:
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	eld[5] |= sad_count << 4;
 	eld[2] = (20 + mnl + sad_count * 3 + 3) / 4;
@@ -1619,15 +1630,38 @@ bool drm_detect_monitor_audio(struct edi
 	start_offset = 4;
 	end_offset = edid_ext[2];
 
-	for (i = start_offset; i < end_offset;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = start_offset; i < end_offset;
 			i += ((edid_ext[i] & 0x1f) + 1)) {
 		if ((edid_ext[i] >> 5) == AUDIO_BLOCK) {
 			has_audio = true;
-			for (j = 1; j < (edid_ext[i] & 0x1f); j += 3)
-				DRM_DEBUG_KMS("CEA audio format %d\n",
-					      (edid_ext[i + j] >> 3) & 0xf);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 1; j < (edid_ext[i] & 0x1f); j += 3) {
+					DRM_DEBUG_KMS("CEA audio format %d\n",
+				(edid_ext[i + j] >> 3) & 0xf);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
 			goto end;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 end:
 	return has_audio;
diff -u -p a/gpu/drm/drm_cache.c b/gpu/drm/drm_cache.c
--- a/gpu/drm/drm_cache.c
+++ b/gpu/drm/drm_cache.c
@@ -42,8 +42,20 @@ drm_clflush_page(struct page *page)
 		return;
 
 	page_virtual = kmap_atomic(page, KM_USER0);
-	for (i = 0; i < PAGE_SIZE; i += boot_cpu_data.x86_clflush_size)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < PAGE_SIZE; i += boot_cpu_data.x86_clflush_size) {
 		clflush(page_virtual + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	kunmap_atomic(page_virtual, KM_USER0);
 }
 
diff -u -p a/gpu/drm/i915/i915_mem.c b/gpu/drm/i915/i915_mem.c
--- a/gpu/drm/i915/i915_mem.c
+++ b/gpu/drm/i915/i915_mem.c
@@ -137,10 +137,21 @@ static struct mem_block *alloc_block(str
 	struct mem_block *p;
 	int mask = (1 << align2) - 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = heap->next; p != heap; p = p->next) {
 		int start = (p->start + mask) & ~mask;
 		if (p->file_priv == NULL && start + size <= p->start + p->size)
 			return split_block(p, start, size, file_priv);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NULL;
@@ -217,16 +228,32 @@ void i915_mem_release(struct drm_device
 	if (!heap || !heap->next)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = heap->next; p != heap; p = p->next) {
 		if (p->file_priv == file_priv) {
 			p->file_priv = NULL;
 			mark_block(dev, p, 0);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Assumes a single contiguous range.  Needs a special file_priv in
 	 * 'heap' to stop it being subsumed.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = heap->next; p != heap; p = p->next) {
 		while (p->file_priv == NULL && p->next->file_priv == NULL) {
 			struct mem_block *q = p->next;
@@ -235,6 +262,12 @@ void i915_mem_release(struct drm_device
 			p->next->prev = p;
 			kfree(q);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/i915/i915_debugfs.c b/gpu/drm/i915/i915_debugfs.c
--- a/gpu/drm/i915/i915_debugfs.c
+++ b/gpu/drm/i915/i915_debugfs.c
@@ -574,8 +574,20 @@ static void i915_dump_object(struct seq_
 	for (page = 0; page < page_count; page++) {
 		u32 *mem = io_mapping_map_wc(mapping,
 					     obj->gtt_offset + page * PAGE_SIZE);
-		for (i = 0; i < PAGE_SIZE; i += 4)
-			seq_printf(m, "%08x :  %08x\n", i, mem[i / 4]);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < PAGE_SIZE; i += 4) {
+		seq_printf(m, "%08x :  %08x\n", i, mem[i / 4]);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+		}
 		io_mapping_unmap(mem);
 	}
 }
diff -u -p a/gpu/drm/mga/mga_dma.c b/gpu/drm/mga/mga_dma.c
--- a/gpu/drm/mga/mga_dma.c
+++ b/gpu/drm/mga/mga_dma.c
@@ -234,10 +234,21 @@ static void mga_freelist_print(struct dr
 				dev_priv->primary->offset));
 	DRM_INFO("current freelist:\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (entry = dev_priv->head->next; entry; entry = entry->next) {
 		DRM_INFO("   %p   idx=%2d  age=0x%x 0x%06lx\n",
 			 entry, entry->buf->idx, entry->age.head,
 			 (unsigned long)(entry->age.head - dev_priv->primary->offset));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	DRM_INFO("\n");
 }
diff -u -p a/gpu/drm/mga/mga_warp.c b/gpu/drm/mga/mga_warp.c
--- a/gpu/drm/mga/mga_warp.c
+++ b/gpu/drm/mga/mga_warp.c
@@ -88,11 +88,22 @@ int mga_warp_install_microcode(drm_mga_p
 
 	size = 0;
 	where = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)fw->data;
 	     rec;
 	     rec = ihex_next_binrec(rec)) {
 		size += WARP_UCODE_SIZE(be16_to_cpu(rec->len));
 		where++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (where != n_pipes) {
@@ -112,6 +123,11 @@ int mga_warp_install_microcode(drm_mga_p
 	memset(dev_priv->warp_pipe_phys, 0, sizeof(dev_priv->warp_pipe_phys));
 
 	where = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)fw->data;
 	     rec;
 	     rec = ihex_next_binrec(rec)) {
@@ -125,6 +141,12 @@ int mga_warp_install_microcode(drm_mga_p
 		pcbase += dst_size;
 		vcbase += dst_size;
 		where++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 out:
diff -u -p a/gpu/drm/vmwgfx/vmwgfx_fb.c b/gpu/drm/vmwgfx/vmwgfx_fb.c
--- a/gpu/drm/vmwgfx/vmwgfx_fb.c
+++ b/gpu/drm/vmwgfx/vmwgfx_fb.c
@@ -237,9 +237,20 @@ static void vmw_fb_dirty_flush(struct vm
 	par->dirty.y1 = par->dirty.y2 = 0;
 	spin_unlock_irqrestore(&par->dirty.lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = y * stride; i < info->fix.smem_len / 4; i += stride) {
 		for (k = i+x; k < i+x+w && k < info->fix.smem_len / 4; k++)
 			iowrite32(src[k], vram_mem + k);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 #if 0
diff -u -p a/usb/misc/emi26.c b/usb/misc/emi26.c
--- a/usb/misc/emi26.c
+++ b/usb/misc/emi26.c
@@ -170,7 +170,12 @@ static int emi26_load_firmware (struct u
 	}
 
 	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
-	for (rec = (const struct ihex_binrec *)loader_fw->data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (rec = (const struct ihex_binrec *)loader_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		err = emi26_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
@@ -179,6 +184,12 @@ static int emi26_load_firmware (struct u
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	msleep(250);	/* let device settle */
 
@@ -191,6 +202,11 @@ static int emi26_load_firmware (struct u
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (!INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -202,6 +218,12 @@ static int emi26_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	/* Assert reset (stop the CPU in the EMI) */
@@ -211,6 +233,11 @@ static int emi26_load_firmware (struct u
 		goto wraperr;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -222,6 +249,12 @@ static int emi26_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
diff -u -p a/usb/misc/emi62.c b/usb/misc/emi62.c
--- a/usb/misc/emi62.c
+++ b/usb/misc/emi62.c
@@ -177,7 +177,12 @@ static int emi62_load_firmware (struct u
 	}
 
 	/* 3. We need to put the loader for the firmware into the EZ-USB (again...) */
-	for (rec = (const struct ihex_binrec *)loader_fw->data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (rec = (const struct ihex_binrec *)loader_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		err = emi62_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
@@ -186,6 +191,12 @@ static int emi62_load_firmware (struct u
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
@@ -198,6 +209,11 @@ static int emi62_load_firmware (struct u
 
 	/* 4. We put the part of the firmware that lies in the external RAM into the EZ-USB */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (!INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -209,6 +225,12 @@ static int emi62_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Assert reset (stop the CPU in the EMI) */
@@ -218,6 +240,11 @@ static int emi62_load_firmware (struct u
 		goto wraperr;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rec = (const struct ihex_binrec *)firmware_fw->data;
 	     rec; rec = ihex_next_binrec(rec)) {
 		if (INTERNAL_RAM(be32_to_cpu(rec->addr))) {
@@ -229,6 +256,12 @@ static int emi62_load_firmware (struct u
 				goto wraperr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
diff -u -p a/usb/host/ohci-q.c b/usb/host/ohci-q.c
--- a/usb/host/ohci-q.c
+++ b/usb/host/ohci-q.c
@@ -130,6 +130,11 @@ static void periodic_link (struct ohci_h
 		(ed->hwINFO & cpu_to_hc32 (ohci, ED_ISO)) ? "iso " : "",
 		ed, ed->branch, ed->load, ed->interval);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ed->branch; i < NUM_INTS; i += ed->interval) {
 		struct ed	**prev = &ohci->periodic [i];
 		__hc32		*prev_p = &ohci->hcca->int_table [i];
@@ -156,6 +161,12 @@ static void periodic_link (struct ohci_h
 			wmb();
 		}
 		ohci->load [i] += ed->load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ohci_to_hcd(ohci)->self.bandwidth_allocated += ed->load / ed->interval;
 }
@@ -256,6 +267,11 @@ static void periodic_unlink (struct ohci
 {
 	int	i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ed->branch; i < NUM_INTS; i += ed->interval) {
 		struct ed	*temp;
 		struct ed	**prev = &ohci->periodic [i];
@@ -270,6 +286,12 @@ static void periodic_unlink (struct ohci
 			*prev = ed->ed_next;
 		}
 		ohci->load [i] -= ed->load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ohci_to_hcd(ohci)->self.bandwidth_allocated -= ed->load / ed->interval;
 
@@ -904,6 +926,11 @@ finish_unlinks (struct ohci_hcd *ohci, u
 	struct ed	*ed, **last;
 
 rescan_all:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (last = &ohci->ed_rm_list, ed = *last; ed != NULL; ed = *last) {
 		struct list_head	*entry, *tmp;
 		int			completed, modified;
@@ -1018,6 +1045,12 @@ rescan_this:
 
 		if (modified)
 			goto rescan_all;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* maybe reenable control and bulk lists */
diff -u -p a/usb/host/isp1760-hcd.c b/usb/host/isp1760-hcd.c
--- a/usb/host/isp1760-hcd.c
+++ b/usb/host/isp1760-hcd.c
@@ -698,10 +698,22 @@ __acquires(priv->lock)
 
 	if (usb_pipein(urb->pipe) && usb_pipetype(urb->pipe) != PIPE_CONTROL) {
 		void *ptr;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (ptr = urb->transfer_buffer;
 		     ptr < urb->transfer_buffer + urb->transfer_buffer_length;
-		     ptr += PAGE_SIZE)
+		     ptr += PAGE_SIZE) {
 			flush_dcache_page(virt_to_page(ptr));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 
 	/* complete() can reenter this HCD */
diff -u -p a/usb/host/xhci-ring.c b/usb/host/xhci-ring.c
--- a/usb/host/xhci-ring.c
+++ b/usb/host/xhci-ring.c
@@ -279,9 +279,21 @@ static int room_on_ring(struct xhci_hcd
 	if (enq == ring->dequeue) {
 		/* Can't use link trbs */
 		left_on_ring = TRBS_PER_SEGMENT - 1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cur_seg = enq_seg->next; cur_seg != enq_seg;
-				cur_seg = cur_seg->next)
-			left_on_ring += TRBS_PER_SEGMENT - 1;
+				cur_seg = cur_seg->next) {
+				left_on_ring += TRBS_PER_SEGMENT - 1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
 
 		/* Always need one TRB free in the ring. */
 		left_on_ring -= 1;
@@ -2078,12 +2090,23 @@ static int process_isoc_td(struct xhci_h
 		frame->actual_length = frame->length;
 		td->urb->actual_length += frame->length;
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (cur_trb = ep_ring->dequeue,
 		     cur_seg = ep_ring->deq_seg; cur_trb != event_trb;
 		     next_trb(xhci, ep_ring, &cur_seg, &cur_trb)) {
 			if (!TRB_TYPE_NOOP_LE32(cur_trb->generic.field[3]) &&
 			    !TRB_TYPE_LINK_LE32(cur_trb->generic.field[3]))
 				len += TRB_LEN(le32_to_cpu(cur_trb->generic.field[2]));
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
+		break;
+				}
 		}
 		len += TRB_LEN(le32_to_cpu(cur_trb->generic.field[2])) -
 			EVENT_TRB_LEN(le32_to_cpu(event->transfer_len));
@@ -2211,13 +2234,24 @@ static int process_bulk_intr_td(struct x
 		 * pointer, to get the actual length transferred.
 		 */
 		td->urb->actual_length = 0;
-		for (cur_trb = ep_ring->dequeue, cur_seg = ep_ring->deq_seg;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (cur_trb = ep_ring->dequeue, cur_seg = ep_ring->deq_seg;
 				cur_trb != event_trb;
 				next_trb(xhci, ep_ring, &cur_seg, &cur_trb)) {
 			if (!TRB_TYPE_NOOP_LE32(cur_trb->generic.field[3]) &&
 			    !TRB_TYPE_LINK_LE32(cur_trb->generic.field[3]))
 				td->urb->actual_length +=
 					TRB_LEN(le32_to_cpu(cur_trb->generic.field[2]));
+					if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		/* If the ring didn't stop on a Link or No-op TRB, add
 		 * in the actual bytes transferred from the Normal TRB
diff -u -p a/usb/host/ehci-dbg.c b/usb/host/ehci-dbg.c
--- a/usb/host/ehci-dbg.c
+++ b/usb/host/ehci-dbg.c
@@ -537,15 +537,39 @@ static ssize_t fill_async_buffer(struct
 	 * one QH per line, and TDs we know about
 	 */
 	spin_lock_irqsave (&ehci->lock, flags);
-	for (qh = ehci->async->qh_next.qh; size > 0 && qh; qh = qh->qh_next.qh)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (qh = ehci->async->qh_next.qh; size > 0 && qh; qh = qh->qh_next.qh) {
 		qh_lines (ehci, qh, &next, &size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	if (ehci->reclaim && size > 0) {
 		temp = scnprintf (next, size, "\nreclaim =\n");
 		size -= temp;
 		next += temp;
 
-		for (qh = ehci->reclaim; size > 0 && qh; qh = qh->reclaim)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (qh = ehci->reclaim; size > 0 && qh; qh = qh->reclaim) {
 			qh_lines (ehci, qh, &next, &size);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 	spin_unlock_irqrestore (&ehci->lock, flags);
 
diff -u -p a/usb/host/sl811-hcd.c b/usb/host/sl811-hcd.c
--- a/usb/host/sl811-hcd.c
+++ b/usb/host/sl811-hcd.c
@@ -449,6 +449,11 @@ static void finish_request(
 
 	/* periodic deschedule */
 	DBG("deschedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
 		struct sl811h_ep	*temp;
 		struct sl811h_ep	**prev = &sl811->periodic[i];
@@ -458,6 +463,12 @@ static void finish_request(
 		if (*prev)
 			*prev = ep->next;
 		sl811->load[i] -= ep->load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ep->branch = PERIODIC_SIZE;
 	sl811->periodic_count--;
@@ -919,6 +930,11 @@ static int sl811h_urb_enqueue(
 		 * dummy/placeholder nodes
 		 */
 		DBG("schedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
 			struct sl811h_ep	**prev = &sl811->periodic[i];
 			struct sl811h_ep	*here = *prev;
@@ -934,6 +950,12 @@ static int sl811h_urb_enqueue(
 				*prev = ep;
 			}
 			sl811->load[i] += ep->load;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		sl811->periodic_count++;
 		hcd->self.bandwidth_allocated += ep->load / ep->period;
diff -u -p a/usb/host/uhci-q.c b/usb/host/uhci-q.c
--- a/usb/host/uhci-q.c
+++ b/usb/host/uhci-q.c
@@ -612,8 +612,20 @@ static int uhci_highest_load(struct uhci
 {
 	int highest_load = uhci->load[phase];
 
-	for (phase += period; phase < MAX_PHASE; phase += period)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (phase += period; phase < MAX_PHASE; phase += period) {
 		highest_load = max_t(int, highest_load, uhci->load[phase]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	return highest_load;
 }
 
@@ -663,9 +675,20 @@ static void uhci_reserve_bandwidth(struc
 	int load = qh->load;
 	char *p = "??";
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = qh->phase; i < MAX_PHASE; i += qh->period) {
 		uhci->load[i] += load;
 		uhci->total_load += load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	uhci_to_hcd(uhci)->self.bandwidth_allocated =
 			uhci->total_load / MAX_PHASE;
@@ -696,9 +719,20 @@ static void uhci_release_bandwidth(struc
 	int load = qh->load;
 	char *p = "??";
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = qh->phase; i < MAX_PHASE; i += qh->period) {
 		uhci->load[i] -= load;
 		uhci->total_load -= load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	uhci_to_hcd(uhci)->self.bandwidth_allocated =
 			uhci->total_load / MAX_PHASE;
diff -u -p a/usb/host/oxu210hp-hcd.c b/usb/host/oxu210hp-hcd.c
--- a/usb/host/oxu210hp-hcd.c
+++ b/usb/host/oxu210hp-hcd.c
@@ -500,7 +500,12 @@ static int oxu_buf_alloc(struct oxu_hcd
 		;
 
 	/* Find a suitable available data buffer */
-	for (i = 0; i < BUFFER_NUM;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < BUFFER_NUM;
 			i += max(a_blocks, (int)oxu->db_used[i])) {
 
 		/* Check all the required blocks are available */
@@ -521,6 +526,12 @@ static int oxu_buf_alloc(struct oxu_hcd
 		spin_unlock(&oxu->mem_lock);
 
 		return 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Failed */
@@ -1942,6 +1953,11 @@ static int qh_link_periodic(struct oxu_h
 	if (period == 0)
 		period = 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = qh->start; i < oxu->periodic_size; i += period) {
 		union ehci_shadow	*prev = &oxu->pshadow[i];
 		__le32			*hw_p = &oxu->periodic[i];
@@ -1977,6 +1993,12 @@ static int qh_link_periodic(struct oxu_h
 			prev->qh = qh;
 			*hw_p = QH_NEXT(qh->qh_dma);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	qh->qh_state = QH_STATE_LINKED;
 	qh_get(qh);
@@ -2011,8 +2033,20 @@ static void qh_unlink_periodic(struct ox
 	if (period == 0)
 		period = 1;
 
-	for (i = qh->start; i < oxu->periodic_size; i += period)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = qh->start; i < oxu->periodic_size; i += period) {
 		periodic_unlink(oxu, i, qh);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* update per-qh bandwidth for usbfs */
 	oxu_to_hcd(oxu)->self.bandwidth_allocated -= qh->period
diff -u -p a/usb/host/xhci-dbg.c b/usb/host/xhci-dbg.c
--- a/usb/host/xhci-dbg.c
+++ b/usb/host/xhci-dbg.c
@@ -362,8 +362,20 @@ void xhci_debug_ring(struct xhci_hcd *xh
 		xhci_dbg(xhci, "  Ring has not been updated\n");
 		return;
 	}
-	for (seg = first_seg->next; seg != first_seg; seg = seg->next)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (seg = first_seg->next; seg != first_seg; seg = seg->next) {
 		xhci_debug_segment(xhci, seg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 void xhci_dbg_ep_rings(struct xhci_hcd *xhci,
diff -u -p a/usb/host/xhci-mem.c b/usb/host/xhci-mem.c
--- a/usb/host/xhci-mem.c
+++ b/usb/host/xhci-mem.c
@@ -419,7 +419,12 @@ static int xhci_test_radix_tree(struct x
 		int trb_size = sizeof(union xhci_trb);
 
 		cur_ring = stream_info->stream_rings[cur_stream];
-		for (addr = cur_ring->first_seg->dma;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (addr = cur_ring->first_seg->dma;
 				addr < cur_ring->first_seg->dma + SEGMENT_SIZE;
 				addr += trb_size) {
 			mapped_ring = dma_to_stream_ring(stream_info, addr);
@@ -432,6 +437,12 @@ static int xhci_test_radix_tree(struct x
 						mapped_ring);
 				return -EINVAL;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* One TRB after the end of the ring segment shouldn't return a
 		 * pointer to the current ring (although it may be a part of a
diff -u -p a/usb/host/r8a66597-hcd.c b/usb/host/r8a66597-hcd.c
--- a/usb/host/r8a66597-hcd.c
+++ b/usb/host/r8a66597-hcd.c
@@ -837,10 +837,22 @@ __acquires(r8a66597->lock)
 	if (usb_pipein(urb->pipe) && usb_pipetype(urb->pipe) != PIPE_CONTROL) {
 		void *ptr;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (ptr = urb->transfer_buffer;
 		     ptr < urb->transfer_buffer + urb->transfer_buffer_length;
-		     ptr += PAGE_SIZE)
+		     ptr += PAGE_SIZE) {
 			flush_dcache_page(virt_to_page(ptr));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 
 	usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
diff -u -p a/usb/host/isp116x-hcd.c b/usb/host/isp116x-hcd.c
--- a/usb/host/isp116x-hcd.c
+++ b/usb/host/isp116x-hcd.c
@@ -174,6 +174,11 @@ static void pack_fifo(struct isp116x *is
 	isp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);
 	isp116x_write_reg16(isp116x, HCXFERCTR, buflen);
 	isp116x_write_addr(isp116x, HCATLPORT | ISP116x_WRITE_OFFSET);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		ptd = &ep->ptd;
 		dump_ptd(ptd);
@@ -188,6 +193,12 @@ static void pack_fifo(struct isp116x *is
 			write_ptddata_to_fifo(isp116x, ep->data, ep->length);
 			buflen -= ALIGN(ep->length, 4);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	BUG_ON(buflen);
 }
@@ -206,6 +217,11 @@ static void unpack_fifo(struct isp116x *
 	isp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);
 	isp116x_write_reg16(isp116x, HCXFERCTR, buflen);
 	isp116x_write_addr(isp116x, HCATLPORT);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		ptd = &ep->ptd;
 		ptd->count = isp116x_read_data16(isp116x);
@@ -220,6 +236,12 @@ static void unpack_fifo(struct isp116x *
 		}
 		dump_ptd(ptd);
 		dump_ptd_in_data(ptd, ep->data);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	BUG_ON(buflen);
 }
@@ -236,6 +258,11 @@ static void preproc_atl_queue(struct isp
 	struct ptd *ptd;
 	u16 len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		u16 toggle = 0, dir = PTD_DIR_SETUP;
 
@@ -285,6 +312,12 @@ static void preproc_atl_queue(struct isp
 		}
 		isp116x->atl_bufshrt = sizeof(struct ptd) + isp116x->atl_buflen;
 		isp116x->atl_buflen = isp116x->atl_bufshrt + ALIGN(len, 4);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -322,6 +355,11 @@ __releases(isp116x->lock) __acquires(isp
 
 	/* periodic deschedule */
 	DBG("deschedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
 		struct isp116x_ep *temp;
 		struct isp116x_ep **prev = &isp116x->periodic[i];
@@ -331,6 +369,12 @@ __releases(isp116x->lock) __acquires(isp
 		if (*prev)
 			*prev = ep->next;
 		isp116x->load[i] -= ep->load;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ep->branch = PERIODIC_SIZE;
 	isp116x_to_hcd(isp116x)->self.bandwidth_allocated -=
@@ -356,7 +400,12 @@ static void postproc_atl_queue(struct is
 	int status;
 	u8 cc;
 
-	for (ep = isp116x->atl_active; ep; ep = ep->active) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (ep = isp116x->atl_active; ep; ep = ep->active) {
 		BUG_ON(list_empty(&ep->hep->urb_list));
 		urb =
 		    container_of(ep->hep->urb_list.next, struct urb, urb_list);
@@ -471,6 +520,12 @@ static void postproc_atl_queue(struct is
  done:
 		if (status != -EINPROGRESS || urb->unlinked)
 			finish_request(isp116x, ep, urb, status);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -793,6 +848,11 @@ static int isp116x_urb_enqueue(struct us
 		   to share the faster parts of the tree without needing
 		   dummy/placeholder nodes */
 		DBG("schedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
 			struct isp116x_ep **prev = &isp116x->periodic[i];
 			struct isp116x_ep *here = *prev;
@@ -808,6 +868,12 @@ static int isp116x_urb_enqueue(struct us
 				*prev = ep;
 			}
 			isp116x->load[i] += ep->load;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		hcd->self.bandwidth_allocated += ep->load / ep->period;
 
diff -u -p a/usb/musb/cppi_dma.c b/usb/musb/cppi_dma.c
--- a/usb/musb/cppi_dma.c
+++ b/usb/musb/cppi_dma.c
@@ -455,8 +455,20 @@ static void cppi_dump_rxq(int level, con
 	cppi_dump_rx(level, rx, tag);
 	if (rx->last_processed)
 		cppi_dump_rxbd("last", rx->last_processed);
-	for (bd = rx->head; bd; bd = bd->next)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (bd = rx->head; bd; bd = bd->next) {
 		cppi_dump_rxbd("active", bd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 #endif
 }
 
@@ -900,8 +912,20 @@ cppi_next_rx_segment(struct musb *musb,
 	if (_dbg_level(5)) {
 		struct cppi_descriptor	*d;
 
-		for (d = rx->head; d; d = d->next)
-			cppi_dump_rxbd("S", d);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (d = rx->head; d; d = d->next) {
+		cppi_dump_rxbd("S", d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 	}
 #endif
 
diff -u -p a/usb/serial/ftdi_sio.c b/usb/serial/ftdi_sio.c
--- a/usb/serial/ftdi_sio.c
+++ b/usb/serial/ftdi_sio.c
@@ -2157,9 +2157,20 @@ static void ftdi_process_read_urb(struct
 	if (!tty)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < urb->actual_length; i += priv->max_packet_size) {
 		len = min_t(int, urb->actual_length - i, priv->max_packet_size);
 		count += ftdi_process_packet(tty, port, priv, &data[i], len);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (count)
@@ -2526,6 +2537,11 @@ static int ftdi_ioctl(struct tty_struct
 	 */
 	case TIOCMIWAIT:
 		cprev = priv->icount;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (;;) {
 			interruptible_sleep_on(&port->delta_msr_wait);
 			/* see if a signal did it */
@@ -2543,6 +2559,12 @@ static int ftdi_ioctl(struct tty_struct
 				return 0;
 			}
 			cprev = cnow;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	case TIOCSERGETLSR:
 		return get_lsr_info(port, (struct serial_struct __user *)arg);
diff -u -p a/usb/serial/mct_u232.c b/usb/serial/mct_u232.c
--- a/usb/serial/mct_u232.c
+++ b/usb/serial/mct_u232.c
@@ -892,7 +892,12 @@ static int  mct_u232_ioctl(struct tty_st
 		spin_lock_irqsave(&mct_u232_port->lock, flags);
 		cprev = mct_u232_port->icount;
 		spin_unlock_irqrestore(&mct_u232_port->lock, flags);
-		for ( ; ; ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for ( ; ; ) {
 			prepare_to_wait(&port->delta_msr_wait,
 					&wait, TASK_INTERRUPTIBLE);
 			schedule();
@@ -917,6 +922,12 @@ static int  mct_u232_ioctl(struct tty_st
 				return 0;
 			}
 			cprev = cnow;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	}
diff -u -p a/usb/serial/ark3116.c b/usb/serial/ark3116.c
--- a/usb/serial/ark3116.c
+++ b/usb/serial/ark3116.c
@@ -456,6 +456,11 @@ static int ark3116_ioctl(struct tty_stru
 			return -EFAULT;
 		return 0;
 	case TIOCMIWAIT:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (;;) {
 			struct async_icount prev = priv->icount;
 			interruptible_sleep_on(&port->delta_msr_wait);
@@ -480,6 +485,12 @@ static int ark3116_ioctl(struct tty_stru
 			    (arg & TIOCM_CTS &&
 			     (prev.cts != priv->icount.cts)))
 				return 0;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 		break;
 	}
diff -u -p a/usb/serial/cypress_m8.c b/usb/serial/cypress_m8.c
--- a/usb/serial/cypress_m8.c
+++ b/usb/serial/cypress_m8.c
@@ -942,6 +942,11 @@ static int cypress_ioctl(struct tty_stru
 	switch (cmd) {
 	/* This code comes from drivers/char/serial.c and ftdi_sio.c */
 	case TIOCMIWAIT:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (;;) {
 			interruptible_sleep_on(&port->delta_msr_wait);
 			/* see if a signal did it */
@@ -971,6 +976,12 @@ static int cypress_ioctl(struct tty_stru
 				 * more events.
 				 */
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		return 0;
 	default:
diff -u -p a/usb/class/cdc-acm.c b/usb/class/cdc-acm.c
--- a/usb/class/cdc-acm.c
+++ b/usb/class/cdc-acm.c
@@ -104,6 +104,11 @@ static int acm_wb_alloc(struct acm *acm)
 
 	wbn = 0;
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		wb = &acm->wb[wbn];
 		if (!wb->use) {
@@ -113,6 +118,12 @@ static int acm_wb_alloc(struct acm *acm)
 		wbn = (wbn + 1) % ACM_NW;
 		if (++i >= ACM_NW)
 			return -1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/usb/gadget/f_mass_storage.c b/usb/gadget/f_mass_storage.c
--- a/usb/gadget/f_mass_storage.c
+++ b/usb/gadget/f_mass_storage.c
@@ -1588,6 +1588,11 @@ static int throw_away_data(struct fsg_co
 	u32			amount;
 	int			rc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bh = common->next_buffhd_to_drain;
 	     bh->state != BUF_STATE_EMPTY || common->usb_amount_left > 0;
 	     bh = common->next_buffhd_to_drain) {
@@ -1632,6 +1637,12 @@ static int throw_away_data(struct fsg_co
 		rc = sleep_thread(common);
 		if (rc)
 			return rc;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/usb/gadget/s3c-hsudc.c b/usb/gadget/s3c-hsudc.c
--- a/usb/gadget/s3c-hsudc.c
+++ b/usb/gadget/s3c-hsudc.c
@@ -346,8 +346,20 @@ static int s3c_hsudc_write_fifo(struct s
 	hsreq->req.actual += length;
 
 	writel(length, hsep->dev->regs + S3C_BWCR);
-	for (count = 0; count < length; count += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (count = 0; count < length; count += 2) {
 		writel(*buf++, fifo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	if (count != max) {
 		is_last = true;
diff -u -p a/usb/gadget/s3c-hsotg.c b/usb/gadget/s3c-hsotg.c
--- a/usb/gadget/s3c-hsotg.c
+++ b/usb/gadget/s3c-hsotg.c
@@ -1396,8 +1396,20 @@ static void s3c_hsotg_rx_data(struct s3c
 			 __func__, size, ep_idx, epctl);
 
 		/* dump the data from the FIFO, we've nothing we can do */
-		for (ptr = 0; ptr < size; ptr += 4)
-			(void)readl(fifo);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (ptr = 0; ptr < size; ptr += 4) {
+		(void)readl(fifo);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+		}
 
 		return;
 	}
diff -u -p a/usb/atm/usbatm.c b/usb/atm/usbatm.c
--- a/usb/atm/usbatm.c
+++ b/usb/atm/usbatm.c
@@ -477,6 +477,11 @@ static unsigned int usbatm_write_cells(s
 	vdbg("%s: skb->len=%d, avail_space=%u", __func__, skb->len, avail_space);
 	UDSL_ASSERT(instance, !(avail_space % stride));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bytes_written = 0; bytes_written < avail_space && ctrl->len;
 	     bytes_written += stride, target += stride) {
 		unsigned int data_len = min_t(unsigned int, skb->len, ATM_CELL_PAYLOAD);
@@ -518,6 +523,12 @@ static unsigned int usbatm_write_cells(s
 			ctrl->len = 0;		/* tag this skb finished */
 		} else
 			ctrl->crc = crc32_be(ctrl->crc, ptr, left);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return bytes_written;
diff -u -p a/usb/atm/ueagle-atm.c b/usb/atm/ueagle-atm.c
--- a/usb/atm/ueagle-atm.c
+++ b/usb/atm/ueagle-atm.c
@@ -1948,6 +1948,11 @@ static int load_XILINX_firmware(struct u
 		ret = -EILSEQ;
 		goto err1;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (u = 0; u < size; u += ln) {
 		ln = min(size - u, 64);
 		ret = uea_request(sc, 0xe, 0, ln, pfw + u);
@@ -1956,6 +1961,12 @@ static int load_XILINX_firmware(struct u
 			       "elsa download data failed (%d)\n", ret);
 			goto err1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* finish to send the fpga */
diff -u -p a/char/random.c b/char/random.c
--- a/char/random.c
+++ b/char/random.c
@@ -934,8 +934,20 @@ static void extract_buf(struct entropy_s
 	/* Generate a hash across the pool, 16 words (512 bits) at a time */
 	sha_init(hash.w);
 	spin_lock_irqsave(&r->lock, flags);
-	for (i = 0; i < r->poolinfo->poolwords; i += 16)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < r->poolinfo->poolwords; i += 16) {
 		sha_transform(hash.w, (__u8 *)(r->pool + i), workspace);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/*
 	 * We mix the hash back into the pool to prevent backtracking
diff -u -p a/char/rtc.c b/char/rtc.c
--- a/char/rtc.c
+++ b/char/rtc.c
@@ -973,6 +973,11 @@ static int __init rtc_init(void)
 #ifdef CONFIG_SPARC32
 	for_each_node_by_name(ebus_dp, "ebus") {
 		struct device_node *dp;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (dp = ebus_dp; dp; dp = dp->sibling) {
 			if (!strcmp(dp->name, "rtc")) {
 				op = of_find_device_by_node(dp);
@@ -982,6 +987,12 @@ static int __init rtc_init(void)
 					goto found;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	rtc_has_irq = 0;
diff -u -p a/char/tile-srom.c b/char/tile-srom.c
--- a/char/tile-srom.c
+++ b/char/tile-srom.c
@@ -88,7 +88,12 @@ static ssize_t _srom_read(int hv_devhdl,
 			  loff_t off, size_t count)
 {
 	int retval, retries = SROM_MAX_WAIT_TRY_TIMES;
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (;;) {
 		retval = hv_dev_pread(hv_devhdl, 0, (HV_VirtAddr)buf,
 				      count, off);
 		if (retval >= 0)
@@ -101,6 +106,12 @@ static ssize_t _srom_read(int hv_devhdl,
 		}
 		pr_err("_srom_read: error %d\n", retval);
 		return -EIO;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -108,7 +119,12 @@ static ssize_t _srom_write(int hv_devhdl
 			   loff_t off, size_t count)
 {
 	int retval, retries = SROM_MAX_WAIT_TRY_TIMES;
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (;;) {
 		retval = hv_dev_pwrite(hv_devhdl, 0, (HV_VirtAddr)buf,
 				       count, off);
 		if (retval >= 0)
@@ -121,6 +137,12 @@ static ssize_t _srom_write(int hv_devhdl
 		}
 		pr_err("_srom_write: error %d\n", retval);
 		return -EIO;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/char/agp/efficeon-agp.c b/char/agp/efficeon-agp.c
--- a/char/agp/efficeon-agp.c
+++ b/char/agp/efficeon-agp.c
@@ -222,8 +222,20 @@ static int efficeon_create_gatt_table(st
 		}
 		SetPageReserved(virt_to_page((char *)page));
 
-		for (offset = 0; offset < PAGE_SIZE; offset += clflush_chunk)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (offset = 0; offset < PAGE_SIZE; offset += clflush_chunk) {
 			clflush((char *)page+offset);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 
 		efficeon_private.l1_table[index] = page;
 
diff -u -p a/i2c/busses/i2c-xiic.c b/i2c/busses/i2c-xiic.c
--- a/i2c/busses/i2c-xiic.c
+++ b/i2c/busses/i2c-xiic.c
@@ -225,10 +225,22 @@ static inline void xiic_irq_clr_en(struc
 static void xiic_clear_rx_fifo(struct xiic_i2c *i2c)
 {
 	u8 sr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sr = xiic_getreg8(i2c, XIIC_SR_REG_OFFSET);
 		!(sr & XIIC_SR_RX_FIFO_EMPTY_MASK);
-		sr = xiic_getreg8(i2c, XIIC_SR_REG_OFFSET))
+		sr = xiic_getreg8(i2c, XIIC_SR_REG_OFFSET)) {
 		xiic_getreg8(i2c, XIIC_DRR_REG_OFFSET);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static void xiic_reinit(struct xiic_i2c *i2c)
diff -u -p a/ide/ide-iops.c b/ide/ide-iops.c
--- a/ide/ide-iops.c
+++ b/ide/ide-iops.c
@@ -72,8 +72,20 @@ void ide_fixstring(u8 *s, const int byte
 
 	if (byteswap) {
 		/* convert from big-endian to host byte order */
-		for (p = s ; p != end ; p += 2)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (p = s ; p != end ; p += 2) {
 			be16_to_cpus((u16 *) p);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 
 	/* strip leading blanks */
diff -u -p a/s390/block/dasd_3990_erp.c b/s390/block/dasd_3990_erp.c
--- a/s390/block/dasd_3990_erp.c
+++ b/s390/block/dasd_3990_erp.c
@@ -2707,6 +2707,11 @@ dasd_3990_erp_action(struct dasd_ccw_req
 		/* print current erp_chain */
 		dev_err(&device->cdev->dev,
 			    "ERP chain at BEGINNING of ERP-ACTION\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (temp_erp = cqr;
 		     temp_erp != NULL; temp_erp = temp_erp->refers) {
 
@@ -2714,6 +2719,12 @@ dasd_3990_erp_action(struct dasd_ccw_req
 				    "ERP %p (%02x) refers to %p\n",
 				    temp_erp, temp_erp->status,
 				    temp_erp->refers);
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
@@ -2748,6 +2759,11 @@ dasd_3990_erp_action(struct dasd_ccw_req
 		/* print current erp_chain */
 		dev_err(&device->cdev->dev,
 			    "ERP chain at END of ERP-ACTION\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (temp_erp = erp;
 		     temp_erp != NULL; temp_erp = temp_erp->refers) {
 
@@ -2755,6 +2771,12 @@ dasd_3990_erp_action(struct dasd_ccw_req
 				    "ERP %p (%02x) refers to %p\n",
 				    temp_erp, temp_erp->status,
 				    temp_erp->refers);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
diff -u -p a/s390/block/dasd_eckd.c b/s390/block/dasd_eckd.c
--- a/s390/block/dasd_eckd.c
+++ b/s390/block/dasd_eckd.c
@@ -1746,8 +1746,20 @@ static int dasd_eckd_end_analysis(struct
 		return -EMEDIUMTYPE;
 	}
 	block->s2b_shift = 0;	/* bits to shift 512 to get a block */
-	for (sb = 512; sb < block->bp_block; sb = sb << 1)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (sb = 512; sb < block->bp_block; sb = sb << 1) {
 		block->s2b_shift++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 
 	blk_per_trk = recs_per_track(&private->rdc_data, 0, block->bp_block);
 
@@ -2235,6 +2247,11 @@ static struct dasd_ccw_req *dasd_eckd_bu
 			if (copy)
 				dst = copy + bv->bv_offset;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (off = 0; off < bv->bv_len; off += blksize) {
 			sector_t trkid = recid;
 			unsigned int recoffs = sector_div(trkid, blk_per_trk);
@@ -2278,6 +2295,12 @@ static struct dasd_ccw_req *dasd_eckd_bu
 			ccw++;
 			dst += blksize;
 			recid++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (blk_noretry_request(req) ||
@@ -2987,6 +3010,11 @@ dasd_eckd_free_cp(struct dasd_ccw_req *c
 		ccw++;
 	rq_for_each_segment(bv, req, iter) {
 		dst = page_address(bv->bv_page) + bv->bv_offset;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (off = 0; off < bv->bv_len; off += blksize) {
 			/* Skip locate record. */
 			if (private->uses_cdl && recid <= 2*blk_per_trk)
@@ -3006,6 +3034,12 @@ dasd_eckd_free_cp(struct dasd_ccw_req *c
 			}
 			ccw++;
 			recid++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 out:
diff -u -p a/s390/block/dasd_eer.c b/s390/block/dasd_eer.c
--- a/s390/block/dasd_eer.c
+++ b/s390/block/dasd_eer.c
@@ -319,10 +319,21 @@ static void dasd_eer_write_standard_trig
 	list_for_each_entry(eerb, &bufferlist, list) {
 		dasd_eer_start_record(eerb, header.total_size);
 		dasd_eer_write_buffer(eerb, (char *) &header, sizeof(header));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (temp_cqr = cqr; temp_cqr; temp_cqr = temp_cqr->refers) {
 			sense = dasd_get_sense(&temp_cqr->irb);
 			if (sense)
 				dasd_eer_write_buffer(eerb, sense, 32);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		dasd_eer_write_buffer(eerb, "EOR", 4);
 	}
diff -u -p a/s390/block/dasd.c b/s390/block/dasd.c
--- a/s390/block/dasd.c
+++ b/s390/block/dasd.c
@@ -2133,7 +2133,12 @@ static int _dasd_sleep_on(struct dasd_cc
 	maincqr->status = DASD_CQR_FILLED;
 	device = maincqr->startdev;
 	list_add(&maincqr->blocklist, &ccw_queue);
-	for (cqr = maincqr;  __dasd_sleep_on_loop_condition(cqr);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (cqr = maincqr;  __dasd_sleep_on_loop_condition(cqr);
 	     cqr = list_first_entry(&ccw_queue,
 				    struct dasd_ccw_req, blocklist)) {
 
@@ -2185,6 +2190,12 @@ static int _dasd_sleep_on(struct dasd_cc
 			}
 		} else
 			wait_event(generic_waitq, _wait_for_wakeup(cqr));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	maincqr->endclk = get_clock();
diff -u -p a/s390/block/dasd_diag.c b/s390/block/dasd_diag.c
--- a/s390/block/dasd_diag.c
+++ b/s390/block/dasd_diag.c
@@ -439,8 +439,20 @@ dasd_diag_check_device(struct dasd_devic
 		block->blocks = end_block;
 	block->bp_block = bsize;
 	block->s2b_shift = 0;	/* bits to shift 512 to get a block */
-	for (sb = 512; sb < bsize; sb = sb << 1)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (sb = 512; sb < bsize; sb = sb << 1) {
 		block->s2b_shift++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 	rc = mdsk_init_io(device, block->bp_block, 0, NULL);
 	if (rc && (rc != 4)) {
 		pr_warning("%s: DIAG initialization failed with rc=%d\n",
@@ -546,6 +558,11 @@ static struct dasd_ccw_req *dasd_diag_bu
 	recid = first_rec;
 	rq_for_each_segment(bv, req, iter) {
 		dst = page_address(bv->bv_page) + bv->bv_offset;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (off = 0; off < bv->bv_len; off += blksize) {
 			memset(dbio, 0, sizeof (struct dasd_diag_bio));
 			dbio->type = rw_cmd;
@@ -554,6 +571,12 @@ static struct dasd_ccw_req *dasd_diag_bu
 			dbio++;
 			dst += blksize;
 			recid++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 	cqr->retries = DIAG_MAX_RETRIES;
diff -u -p a/s390/char/tape_class.c b/s390/char/tape_class.c
--- a/s390/char/tape_class.c
+++ b/s390/char/tape_class.c
@@ -55,11 +55,35 @@ struct tape_class_device *register_tape_
 		return ERR_PTR(-ENOMEM);
 
 	strncpy(tcd->device_name, device_name, TAPECLASS_NAME_LEN);
-	for (s = strchr(tcd->device_name, '/'); s; s = strchr(s, '/'))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (s = strchr(tcd->device_name, '/'); s; s = strchr(s, '/')) {
 		*s = '!';
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	strncpy(tcd->mode_name, mode_name, TAPECLASS_NAME_LEN);
-	for (s = strchr(tcd->mode_name, '/'); s; s = strchr(s, '/'))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (s = strchr(tcd->mode_name, '/'); s; s = strchr(s, '/')) {
 		*s = '!';
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	tcd->char_device = cdev_alloc();
 	if (!tcd->char_device) {
diff -u -p a/s390/net/qeth_l3_main.c b/s390/net/qeth_l3_main.c
--- a/s390/net/qeth_l3_main.c
+++ b/s390/net/qeth_l3_main.c
@@ -1682,6 +1682,11 @@ static void qeth_l3_add_mc(struct qeth_c
 	char buf[MAX_ADDR_LEN];
 
 	QETH_CARD_TEXT(card, 4, "addmc");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (im4 = rcu_dereference(in4_dev->mc_list); im4 != NULL;
 	     im4 = rcu_dereference(im4->next_rcu)) {
 		qeth_l3_get_mac_for_ipm(im4->multiaddr, buf, in4_dev->dev);
@@ -1693,6 +1698,12 @@ static void qeth_l3_add_mc(struct qeth_c
 		ipm->is_multicast = 1;
 		if (!qeth_l3_add_ip(card, ipm))
 			kfree(ipm);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -1747,6 +1758,11 @@ static void qeth_l3_add_mc6(struct qeth_
 	char buf[MAX_ADDR_LEN];
 
 	QETH_CARD_TEXT(card, 4, "addmc6");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (im6 = in6_dev->mc_list; im6 != NULL; im6 = im6->next) {
 		ndisc_mc_map(&im6->mca_addr, buf, in6_dev->dev, 0);
 		ipm = qeth_l3_get_addr_buffer(QETH_PROT_IPV6);
@@ -1758,6 +1774,12 @@ static void qeth_l3_add_mc6(struct qeth_
 		       sizeof(struct in6_addr));
 		if (!qeth_l3_add_ip(card, ipm))
 			kfree(ipm);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1819,6 +1841,11 @@ static void qeth_l3_free_vlan_addresses4
 	in_dev = in_dev_get(netdev);
 	if (!in_dev)
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {
 		addr = qeth_l3_get_addr_buffer(QETH_PROT_IPV4);
 		if (addr) {
@@ -1828,6 +1855,12 @@ static void qeth_l3_free_vlan_addresses4
 			if (!qeth_l3_delete_ip(card, addr))
 				kfree(addr);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	in_dev_put(in_dev);
 }
diff -u -p a/watchdog/wdrtas.c b/watchdog/wdrtas.c
--- a/watchdog/wdrtas.c
+++ b/watchdog/wdrtas.c
@@ -169,19 +169,31 @@ static void wdrtas_log_scanned_event(voi
 {
 	int i;
 
-	for (i = 0; i < WDRTAS_LOGBUFFER_LEN; i += 16)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < WDRTAS_LOGBUFFER_LEN; i += 16) {
 		printk(KERN_INFO "wdrtas: dumping event (line %i/%i), data = "
-		       "%02x %02x %02x %02x  %02x %02x %02x %02x   "
-		       "%02x %02x %02x %02x  %02x %02x %02x %02x\n",
-		       (i / 16) + 1, (WDRTAS_LOGBUFFER_LEN / 16),
-		       wdrtas_logbuffer[i + 0], wdrtas_logbuffer[i + 1],
-		       wdrtas_logbuffer[i + 2], wdrtas_logbuffer[i + 3],
-		       wdrtas_logbuffer[i + 4], wdrtas_logbuffer[i + 5],
-		       wdrtas_logbuffer[i + 6], wdrtas_logbuffer[i + 7],
-		       wdrtas_logbuffer[i + 8], wdrtas_logbuffer[i + 9],
-		       wdrtas_logbuffer[i + 10], wdrtas_logbuffer[i + 11],
-		       wdrtas_logbuffer[i + 12], wdrtas_logbuffer[i + 13],
-		       wdrtas_logbuffer[i + 14], wdrtas_logbuffer[i + 15]);
+		"%02x %02x %02x %02x  %02x %02x %02x %02x   "
+		"%02x %02x %02x %02x  %02x %02x %02x %02x\n",
+		(i / 16) + 1, (WDRTAS_LOGBUFFER_LEN / 16),
+		wdrtas_logbuffer[i + 0], wdrtas_logbuffer[i + 1],
+		wdrtas_logbuffer[i + 2], wdrtas_logbuffer[i + 3],
+		wdrtas_logbuffer[i + 4], wdrtas_logbuffer[i + 5],
+		wdrtas_logbuffer[i + 6], wdrtas_logbuffer[i + 7],
+		wdrtas_logbuffer[i + 8], wdrtas_logbuffer[i + 9],
+		wdrtas_logbuffer[i + 10], wdrtas_logbuffer[i + 11],
+		wdrtas_logbuffer[i + 12], wdrtas_logbuffer[i + 13],
+		wdrtas_logbuffer[i + 14], wdrtas_logbuffer[i + 15]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 /**
diff -u -p a/net/ppp/pppoe.c b/net/ppp/pppoe.c
--- a/net/ppp/pppoe.c
+++ b/net/ppp/pppoe.c
@@ -150,8 +150,20 @@ static int hash_item(__be16 sid, unsigne
 
 	for (i = 0; i < ETH_ALEN; i++)
 		hash ^= addr[i];
-	for (i = 0; i < sizeof(sid_t) * 8; i += 8)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < sizeof(sid_t) * 8; i += 8) {
 		hash ^= (__force __u32)sid >> i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	for (i = 8; (i >>= 1) >= PPPOE_HASH_BITS;)
 		hash ^= hash >> i;
 
diff -u -p a/net/caif/caif_spi_slave.c b/net/caif/caif_spi_slave.c
--- a/net/caif/caif_spi_slave.c
+++ b/net/caif/caif_spi_slave.c
@@ -71,7 +71,12 @@ void cfspi_xfer(struct work_struct *work
 	/* Initialize state. */
 	cfspi->cmd = SPI_CMD_EOT;
 
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 
 		cfspi_dbg_state(cfspi, CFSPI_STATE_WAITING);
 
@@ -243,6 +248,12 @@ void cfspi_xfer(struct work_struct *work
 			clear_bit(SPI_XFER, &cfspi->state);
 
 		spin_unlock_irqrestore(&cfspi->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/brcm80211/brcmsmac/dma.c b/net/wireless/brcm80211/brcmsmac/dma.c
--- a/net/wireless/brcm80211/brcmsmac/dma.c
+++ b/net/wireless/brcm80211/brcmsmac/dma.c
@@ -1251,6 +1251,11 @@ int dma_txfast(struct dma_pub *pub, stru
 	 * Walk the chain of packet buffers
 	 * allocating and initializing transmit descriptor entries.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (p = p0; p; p = next) {
 		data = p->data;
 		len = p->len;
@@ -1283,6 +1288,12 @@ int dma_txfast(struct dma_pub *pub, stru
 		dma64_dd_upd(di, di->txd64, pa, txout, &flags, len);
 
 		txout = nexttxd(di, txout);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if last txd eof not set, fix it */
@@ -1368,6 +1379,11 @@ struct sk_buff *dma_getnexttxp(struct dm
 	if ((start == 0) && (end > di->txout))
 		goto bogus;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i != end && !txp; i = nexttxd(di, i)) {
 		dma_addr_t pa;
 		uint size;
@@ -1385,6 +1401,12 @@ struct sk_buff *dma_getnexttxp(struct dm
 		di->txp[i] = NULL;
 
 		pci_unmap_single(di->pbus, pa, size, PCI_DMA_TODEVICE);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 
 	di->txin = i;
diff -u -p a/net/wireless/brcm80211/brcmsmac/mac80211_if.c b/net/wireless/brcm80211/brcmsmac/mac80211_if.c
--- a/net/wireless/brcm80211/brcmsmac/mac80211_if.c
+++ b/net/wireless/brcm80211/brcmsmac/mac80211_if.c
@@ -857,12 +857,23 @@ static void brcms_free(struct brcms_info
 		schedule();
 
 	/* free timers */
-	for (t = wl->timers; t; t = next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for (t = wl->timers; t; t = next) {
 		next = t->next;
 #ifdef BCMDBG
 		kfree(t->name);
 #endif
 		kfree(t);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/*
diff -u -p a/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c b/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c
--- a/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c
+++ b/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c
@@ -3211,8 +3211,20 @@ static void wlc_lcnphy_clear_papd_compta
 	tab.tbl_offset = 0;
 
 	memset(temp_offset, 0, sizeof(temp_offset));
-	for (j = 1; j < 128; j += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (j = 1; j < 128; j += 2) {
 		temp_offset[j] = 0x80000;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	wlc_lcnphy_write_table(pi, &tab);
 	return;
@@ -3729,7 +3741,17 @@ wlc_lcnphy_a1(struct brcms_phy *pi, int
 		else if (phy_c5 > 7)
 			phy_c5 = 7;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (k = -phy_c7; k <= phy_c7; k += phy_c7) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (l = -phy_c7; l <= phy_c7; l += phy_c7) {
 				phy_c11 = phy_c15 + k;
 				phy_c12 = phy_c16 + l;
@@ -3773,6 +3795,18 @@ wlc_lcnphy_a1(struct brcms_phy *pi, int
 					phy_c14 = phy_c12;
 				}
 				phy_c23 = 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 		phy_c23 = 1;
diff -u -p a/net/wireless/brcm80211/brcmutil/utils.c b/net/wireless/brcm80211/brcmutil/utils.c
--- a/net/wireless/brcm80211/brcmutil/utils.c
+++ b/net/wireless/brcm80211/brcmutil/utils.c
@@ -201,8 +201,20 @@ struct sk_buff *brcmu_pktq_pdeq_tail(str
 	if (p == NULL)
 		return NULL;
 
-	for (prev = NULL; p != q->tail; p = p->prev)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (prev = NULL; p != q->tail; p = p->prev) {
 		prev = p;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	if (prev)
 		prev->prev = NULL;
@@ -359,8 +371,20 @@ void brcmu_prpkt(const char *msg, struct
 	if (msg && (msg[0] != '\0'))
 		printk(KERN_DEBUG "%s:\n", msg);
 
-	for (p = p0; p; p = p->next)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (p = p0; p; p = p->next) {
 		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, p->data, p->len);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 EXPORT_SYMBOL(brcmu_prpkt);
 #endif				/* defined(BCMDBG) */
diff -u -p a/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c b/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c
--- a/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c
+++ b/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -223,6 +223,11 @@ brcmf_sdioh_request_packet(struct brcmf_
 
 	/* Claim host controller */
 	sdio_claim_host(sdiodev->func[func]);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (pnext = pkt; pnext; pnext = pnext->next) {
 		uint pkt_len = pnext->len;
 		pkt_len += 3;
@@ -260,6 +265,12 @@ brcmf_sdioh_request_packet(struct brcmf_
 			addr += pkt_len;
 		SGCount++;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Release host controller */
diff -u -p a/net/wireless/b43legacy/main.c b/net/wireless/b43legacy/main.c
--- a/net/wireless/b43legacy/main.c
+++ b/net/wireless/b43legacy/main.c
@@ -1662,8 +1662,20 @@ static int b43legacy_upload_microcode(st
 	/* Zero out all microcode PSM registers and shared memory. */
 	for (i = 0; i < 64; i++)
 		b43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS, i, 0);
-	for (i = 0; i < 4096; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 4096; i += 2) {
 		b43legacy_shm_write16(dev, B43legacy_SHM_SHARED, i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* Upload Microcode. */
 	data = (__be32 *) (dev->fw.ucode->data + hdr_len);
diff -u -p a/net/wireless/prism54/isl_ioctl.c b/net/wireless/prism54/isl_ioctl.c
--- a/net/wireless/prism54/isl_ioctl.c
+++ b/net/wireless/prism54/isl_ioctl.c
@@ -1800,11 +1800,22 @@ prism54_clear_mac(struct islpci_acl *acl
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = acl->mac_list.next, next = ptr->next;
 	     ptr != &acl->mac_list; ptr = next, next = ptr->next) {
 		entry = list_entry(ptr, struct mac_entry, _list);
 		list_del(ptr);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	acl->size = 0;
 	mutex_unlock(&acl->lock);
diff -u -p a/net/wireless/iwlegacy/iwl-4965-tx.c b/net/wireless/iwlegacy/iwl-4965-tx.c
--- a/net/wireless/iwlegacy/iwl-4965-tx.c
+++ b/net/wireless/iwlegacy/iwl-4965-tx.c
@@ -1127,6 +1127,11 @@ int iwl4965_tx_queue_reclaim(struct iwl_
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = iwl_legacy_queue_inc_wrap(index, q->n_bd);
 	     q->read_ptr != index;
 	     q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd)) {
@@ -1145,6 +1150,12 @@ int iwl4965_tx_queue_reclaim(struct iwl_
 		tx_info->skb = NULL;
 
 		priv->cfg->ops->lib->txq_free_tfd(priv, txq);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return nfreed;
 }
diff -u -p a/net/wireless/iwlegacy/iwl-tx.c b/net/wireless/iwlegacy/iwl-tx.c
--- a/net/wireless/iwlegacy/iwl-tx.c
+++ b/net/wireless/iwlegacy/iwl-tx.c
@@ -576,6 +576,11 @@ static void iwl_legacy_hcmd_queue_reclai
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = iwl_legacy_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;
 	     q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd)) {
 
@@ -585,6 +590,12 @@ static void iwl_legacy_hcmd_queue_reclai
 			queue_work(priv->workqueue, &priv->restart);
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/iwlegacy/iwl-3945.c b/net/wireless/iwlegacy/iwl-3945.c
--- a/net/wireless/iwlegacy/iwl-3945.c
+++ b/net/wireless/iwlegacy/iwl-3945.c
@@ -283,6 +283,11 @@ static void iwl3945_tx_queue_reclaim(str
 
 	BUG_ON(txq_id == IWL39_CMD_QUEUE_NUM);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (index = iwl_legacy_queue_inc_wrap(index, q->n_bd);
 		q->read_ptr != index;
 		q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd)) {
@@ -291,6 +296,12 @@ static void iwl3945_tx_queue_reclaim(str
 		ieee80211_tx_status_irqsafe(priv->hw, tx_info->skb);
 		tx_info->skb = NULL;
 		priv->cfg->ops->lib->txq_free_tfd(priv, txq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (iwl_legacy_queue_space(q) > q->low_mark && (txq_id >= 0) &&
diff -u -p a/net/wireless/libertas/if_cs.c b/net/wireless/libertas/if_cs.c
--- a/net/wireless/libertas/if_cs.c
+++ b/net/wireless/libertas/if_cs.c
@@ -694,6 +694,11 @@ static int if_cs_prog_real(struct if_cs_
 		goto done;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (sent = 0; sent < fw->size; sent += len) {
 		len = if_cs_read16(card, IF_CS_SQ_READ_LOW);
 		if (len & 1) {
@@ -727,6 +732,12 @@ static int if_cs_prog_real(struct if_cs_
 			pr_err("can't download firmware at 0x%x\n", sent);
 			goto done;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = if_cs_poll_while_fw_download(card, IF_CS_SCRATCH, 0x5a);
diff -u -p a/net/wireless/iwlwifi/iwl-trans-pcie-tx.c b/net/wireless/iwlwifi/iwl-trans-pcie-tx.c
--- a/net/wireless/iwlwifi/iwl-trans-pcie-tx.c
+++ b/net/wireless/iwlwifi/iwl-trans-pcie-tx.c
@@ -923,6 +923,11 @@ static void iwl_hcmd_queue_reclaim(struc
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = iwl_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;
 	     q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd)) {
 
@@ -932,6 +937,12 @@ static void iwl_hcmd_queue_reclaim(struc
 			iwlagn_fw_error(priv(trans), false);
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/ipw2x00/ipw2200.c b/net/wireless/ipw2x00/ipw2200.c
--- a/net/wireless/ipw2x00/ipw2200.c
+++ b/net/wireless/ipw2x00/ipw2200.c
@@ -1354,6 +1354,11 @@ static ssize_t show_cmd_log(struct devic
 	u32 len = 0, i;
 	if (!priv->cmdlog)
 		return 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = (priv->cmdlog_pos + 1) % priv->cmdlog_len;
 	     (i != priv->cmdlog_pos) && (PAGE_SIZE - len);
 	     i = (i + 1) % priv->cmdlog_len) {
@@ -1367,6 +1372,12 @@ static ssize_t show_cmd_log(struct devic
 				 (u8 *) priv->cmdlog[i].cmd.param,
 				 priv->cmdlog[i].cmd.len);
 		len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
 	return len;
diff -u -p a/net/wireless/ipw2x00/ipw2100.c b/net/wireless/ipw2x00/ipw2100.c
--- a/net/wireless/ipw2x00/ipw2100.c
+++ b/net/wireless/ipw2x00/ipw2100.c
@@ -468,8 +468,20 @@ static void write_nic_memory(struct net_
 	/* read DWs through autoincrement registers */
 	write_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS, aligned_addr);
 	aligned_len = len & (~0x3);
-	for (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4) {
 		write_register(dev, IPW_REG_AUTOINCREMENT_DATA, *(u32 *) buf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* copy the last nibble */
 	dif_len = len - aligned_len;
@@ -506,8 +518,20 @@ static void read_nic_memory(struct net_d
 	/* read DWs through autoincrement registers */
 	write_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS, aligned_addr);
 	aligned_len = len & (~0x3);
-	for (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4) {
 		read_register(dev, IPW_REG_AUTOINCREMENT_DATA, (u32 *) buf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* copy the last nibble */
 	dif_len = len - aligned_len;
@@ -1087,21 +1111,81 @@ static int ipw2100_download_firmware(str
 #endif
 
 	/* zero out Domain 1 area indirectly (Si requirement) */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (address = IPW_HOST_FW_SHARED_AREA0;
-	     address < IPW_HOST_FW_SHARED_AREA0_END; address += 4)
-		write_nic_dword(priv->net_dev, address, 0);
+	     address < IPW_HOST_FW_SHARED_AREA0_END; address += 4) {
+	write_nic_dword(priv->net_dev, address, 0);
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (address = IPW_HOST_FW_SHARED_AREA1;
-	     address < IPW_HOST_FW_SHARED_AREA1_END; address += 4)
-		write_nic_dword(priv->net_dev, address, 0);
+	     address < IPW_HOST_FW_SHARED_AREA1_END; address += 4) {
+	write_nic_dword(priv->net_dev, address, 0);
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (address = IPW_HOST_FW_SHARED_AREA2;
-	     address < IPW_HOST_FW_SHARED_AREA2_END; address += 4)
-		write_nic_dword(priv->net_dev, address, 0);
+	     address < IPW_HOST_FW_SHARED_AREA2_END; address += 4) {
+	write_nic_dword(priv->net_dev, address, 0);
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (address = IPW_HOST_FW_SHARED_AREA3;
-	     address < IPW_HOST_FW_SHARED_AREA3_END; address += 4)
-		write_nic_dword(priv->net_dev, address, 0);
+	     address < IPW_HOST_FW_SHARED_AREA3_END; address += 4) {
+	write_nic_dword(priv->net_dev, address, 0);
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (address = IPW_HOST_FW_INTERRUPT_AREA;
-	     address < IPW_HOST_FW_INTERRUPT_AREA_END; address += 4)
-		write_nic_dword(priv->net_dev, address, 0);
+	     address < IPW_HOST_FW_INTERRUPT_AREA_END; address += 4) {
+	write_nic_dword(priv->net_dev, address, 0);
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
+	}
 
 	return 0;
 
diff -u -p a/net/wireless/rt2x00/rt2800lib.c b/net/wireless/rt2x00/rt2800lib.c
--- a/net/wireless/rt2x00/rt2800lib.c
+++ b/net/wireless/rt2x00/rt2800lib.c
@@ -760,8 +760,20 @@ static inline void rt2800_clear_beacon_r
 	 * the whole TXWI which (when set to 0) will invalidate
 	 * the entire beacon.
 	 */
-	for (i = 0; i < TXWI_DESC_SIZE; i += sizeof(__le32))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < TXWI_DESC_SIZE; i += sizeof(__le32)) {
 		rt2800_register_write(rt2x00dev, beacon_base + i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 void rt2800_clear_beacon(struct queue_entry *entry)
@@ -3793,8 +3805,20 @@ void rt2800_read_eeprom_efuse(struct rt2
 {
 	unsigned int i;
 
-	for (i = 0; i < EEPROM_SIZE / sizeof(u16); i += 8)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < EEPROM_SIZE / sizeof(u16); i += 8) {
 		rt2800_efuse_read(rt2x00dev, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 EXPORT_SYMBOL_GPL(rt2800_read_eeprom_efuse);
 
diff -u -p a/net/wireless/b43/main.c b/net/wireless/b43/main.c
--- a/net/wireless/b43/main.c
+++ b/net/wireless/b43/main.c
@@ -2449,8 +2449,20 @@ static int b43_upload_microcode(struct b
 	/* Zero out all microcode PSM registers and shared memory. */
 	for (i = 0; i < 64; i++)
 		b43_shm_write16(dev, B43_SHM_SCRATCH, i, 0);
-	for (i = 0; i < 4096; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 4096; i += 2) {
 		b43_shm_write16(dev, B43_SHM_SHARED, i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* Upload Microcode. */
 	data = (__be32 *) (dev->fw.ucode.data->data + hdr_len);
diff -u -p a/net/wireless/zd1211rw/zd_chip.c b/net/wireless/zd1211rw/zd_chip.c
--- a/net/wireless/zd1211rw/zd_chip.c
+++ b/net/wireless/zd1211rw/zd_chip.c
@@ -204,6 +204,11 @@ int zd_iowrite16a_locked(struct zd_chip
 	ZD_ASSERT(mutex_is_locked(&chip->mutex));
 	zd_usb_iowrite16v_async_start(&chip->usb);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i += j + t) {
 		t = 0;
 		max = count-i;
@@ -224,6 +229,12 @@ int zd_iowrite16a_locked(struct zd_chip
 				  r);
 			return r;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return zd_usb_iowrite16v_async_end(&chip->usb, 50 /* ms */);
@@ -241,6 +252,11 @@ int zd_iowrite32a_locked(struct zd_chip
 
 	zd_usb_iowrite16v_async_start(&chip->usb);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < count; i += j + t) {
 		t = 0;
 		max = count-i;
@@ -261,6 +277,12 @@ int zd_iowrite32a_locked(struct zd_chip
 				" Error number %d\n", r);
 			return r;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return zd_usb_iowrite16v_async_end(&chip->usb, 50 /* ms */);
diff -u -p a/net/wireless/wl12xx/event.c b/net/wireless/wl12xx/event.c
--- a/net/wireless/wl12xx/event.c
+++ b/net/wireless/wl12xx/event.c
@@ -343,6 +343,11 @@ static int wl1271_event_process(struct w
 		const u8 *addr;
 		int h;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (h = find_first_bit(&sta_bitmap, AP_MAX_LINKS);
 		     h < AP_MAX_LINKS;
 		     h = find_next_bit(&sta_bitmap, AP_MAX_LINKS, h+1)) {
@@ -358,6 +363,12 @@ static int wl1271_event_process(struct w
 				ieee80211_report_low_ack(sta, num_packets);
 			}
 			rcu_read_unlock();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/wireless/ath/ath6kl/debug.c b/net/wireless/ath/ath6kl/debug.c
--- a/net/wireless/ath/ath6kl/debug.c
+++ b/net/wireless/ath/ath6kl/debug.c
@@ -256,7 +256,12 @@ static void ath6kl_debug_fwlog_add(struc
 		fwlog->tail = (fwlog->tail + ATH6KL_FWLOG_SLOT_SIZE) &
 			(ATH6KL_FWLOG_SIZE - 1);
 
-	for (i = 0; i < buf_len; i += space) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < buf_len; i += space) {
 		space = CIRC_SPACE_TO_END(fwlog->head, fwlog->tail,
 					  ATH6KL_FWLOG_SIZE);
 
@@ -265,6 +270,12 @@ static void ath6kl_debug_fwlog_add(struc
 
 		memcpy(&fwlog->buf[fwlog->head], buf, space);
 		fwlog->head = (fwlog->head + space) & (ATH6KL_FWLOG_SIZE - 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
diff -u -p a/net/wireless/ath/ath9k/ar9003_eeprom.c b/net/wireless/ath/ath9k/ar9003_eeprom.c
--- a/net/wireless/ath/ath9k/ar9003_eeprom.c
+++ b/net/wireless/ath/ath9k/ar9003_eeprom.c
@@ -3170,6 +3170,11 @@ static bool ar9300_uncompress_block(stru
 
 	spot = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (it = 0; it < size; it += (length+2)) {
 		offset = block[it];
 		offset &= 0xff;
@@ -3189,6 +3194,12 @@ static bool ar9300_uncompress_block(stru
 				it, spot, offset, length);
 			return false;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return true;
 }
diff -u -p a/net/wireless/hostap/hostap_ap.c b/net/wireless/hostap/hostap_ap.c
--- a/net/wireless/hostap/hostap_ap.c
+++ b/net/wireless/hostap/hostap_ap.c
@@ -395,6 +395,11 @@ int ap_control_del_mac(struct mac_restri
 	struct mac_entry *entry;
 
 	spin_lock_bh(&mac_restrictions->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = mac_restrictions->mac_list.next;
 	     ptr != &mac_restrictions->mac_list; ptr = ptr->next) {
 		entry = list_entry(ptr, struct mac_entry, list);
@@ -406,6 +411,12 @@ int ap_control_del_mac(struct mac_restri
 			spin_unlock_bh(&mac_restrictions->lock);
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_bh(&mac_restrictions->lock);
 	return -1;
@@ -446,12 +457,23 @@ void ap_control_flush_macs(struct mac_re
 		return;
 
 	spin_lock_bh(&mac_restrictions->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = mac_restrictions->mac_list.next, n = ptr->next;
 	     ptr != &mac_restrictions->mac_list;
 	     ptr = n, n = ptr->next) {
 		entry = list_entry(ptr, struct mac_entry, list);
 		list_del(ptr);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mac_restrictions->entries = 0;
 	spin_unlock_bh(&mac_restrictions->lock);
@@ -495,6 +517,11 @@ void ap_control_kickall(struct ap_data *
 	struct sta_info *sta;
 
 	spin_lock_bh(&ap->sta_table_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ap->sta_list.next, n = ptr->next; ptr != &ap->sta_list;
 	     ptr = n, n = ptr->next) {
 		sta = list_entry(ptr, struct sta_info, list);
@@ -503,6 +530,12 @@ void ap_control_kickall(struct ap_data *
 		if ((sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)
 			hostap_event_expired_sta(sta->local->dev, sta);
 		ap_free_sta(ap, sta);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_bh(&ap->sta_table_lock);
 }
@@ -2383,6 +2416,11 @@ int prism2_ap_translate_scan(struct net_
 
 	spin_lock_bh(&ap->sta_table_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ptr = ap->sta_list.next; ptr != NULL && ptr != &ap->sta_list;
 	     ptr = ptr->next) {
 		struct sta_info *sta = (struct sta_info *) ptr;
@@ -2470,6 +2508,12 @@ int prism2_ap_translate_scan(struct net_
 		sta->last_rx_updated = IW_QUAL_DBM;
 
 		/* To be continued, we should make good use of IWEVCUSTOM */
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock_bh(&ap->sta_table_lock);
diff -u -p a/net/can/sja1000/peak_pci.c b/net/can/sja1000/peak_pci.c
--- a/net/can/sja1000/peak_pci.c
+++ b/net/can/sja1000/peak_pci.c
@@ -217,12 +217,23 @@ failure_remove_channels:
 	/* Disable interrupts */
 	writew(0x0, cfg_base + PITA_ICR + 2);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = dev0; dev; dev = chan->next_dev) {
 		unregister_sja1000dev(dev);
 		free_sja1000dev(dev);
 		priv = netdev_priv(dev);
 		chan = priv->priv;
 		dev = chan->next_dev;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	pci_iounmap(pdev, reg_base);
diff -u -p a/net/fddi/defxx.c b/net/fddi/defxx.c
--- a/net/fddi/defxx.c
+++ b/net/fddi/defxx.c
@@ -2931,13 +2931,18 @@ static int dfx_rcv_init(DFX_board_t *bp,
 
 	if (get_buffers) {
 #ifdef DYNAMIC_BUFFERS
-	for (i = 0; i < (int)(bp->rcv_bufs_to_post); i++)
-		for (j = 0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)
-		{
-			struct sk_buff *newskb = __netdev_alloc_skb(bp->dev, NEW_SKB_SIZE, GFP_NOIO);
-			if (!newskb)
-				return -ENOMEM;
-			bp->descr_block_virt->rcv_data[i+j].long_0 = (u32) (PI_RCV_DESCR_M_SOP |
+	for (i = 0; i < (int)(bp->rcv_bufs_to_post); i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)
+			{
+				struct sk_buff *newskb = __netdev_alloc_skb(bp->dev, NEW_SKB_SIZE, GFP_NOIO);
+				if (!newskb)
+					return -ENOMEM;
+				bp->descr_block_virt->rcv_data[i+j].long_0 = (u32) (PI_RCV_DESCR_M_SOP |
 				((PI_RCV_DATA_K_SIZE_MAX / PI_ALIGN_K_RCV_DATA_BUFF) << PI_RCV_DESCR_V_SEG_LEN));
 			/*
 			 * align to 128 bytes for compatibility with
@@ -2946,23 +2951,42 @@ static int dfx_rcv_init(DFX_board_t *bp,
 
 			my_skb_align(newskb, 128);
 			bp->descr_block_virt->rcv_data[i + j].long_1 =
-				(u32)dma_map_single(bp->bus_dev, newskb->data,
-						    NEW_SKB_SIZE,
-						    DMA_FROM_DEVICE);
+			(u32)dma_map_single(bp->bus_dev, newskb->data,
+					NEW_SKB_SIZE,
+					DMA_FROM_DEVICE);
 			/*
 			 * p_rcv_buff_va is only used inside the
 			 * kernel so we put the skb pointer here.
 			 */
-			bp->p_rcv_buff_va[i+j] = (char *) newskb;
+				bp->p_rcv_buff_va[i+j] = (char *) newskb;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
+			}
 		}
 #else
-	for (i=0; i < (int)(bp->rcv_bufs_to_post); i++)
-		for (j=0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)
+	for (i=0; i < (int)(bp->rcv_bufs_to_post); i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j=0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)
 			{
 			bp->descr_block_virt->rcv_data[i+j].long_0 = (u32) (PI_RCV_DESCR_M_SOP |
-				((PI_RCV_DATA_K_SIZE_MAX / PI_ALIGN_K_RCV_DATA_BUFF) << PI_RCV_DESCR_V_SEG_LEN));
+((PI_RCV_DATA_K_SIZE_MAX / PI_ALIGN_K_RCV_DATA_BUFF) << PI_RCV_DESCR_V_SEG_LEN));
 			bp->descr_block_virt->rcv_data[i+j].long_1 = (u32) (bp->rcv_block_phys + (i * PI_RCV_DATA_K_SIZE_MAX));
 			bp->p_rcv_buff_va[i+j] = (char *) (bp->rcv_block_virt + (i * PI_RCV_DATA_K_SIZE_MAX));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+			}
 			}
 #endif
 	}
@@ -3453,14 +3477,26 @@ static void dfx_rcv_flush( DFX_board_t *
 	{
 	int i, j;
 
-	for (i = 0; i < (int)(bp->rcv_bufs_to_post); i++)
-		for (j = 0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)
-		{
-			struct sk_buff *skb;
-			skb = (struct sk_buff *)bp->p_rcv_buff_va[i+j];
-			if (skb)
-				dev_kfree_skb(skb);
-			bp->p_rcv_buff_va[i+j] = NULL;
+	for (i = 0; i < (int)(bp->rcv_bufs_to_post); i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (j = 0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)
+			{
+				struct sk_buff *skb;
+				skb = (struct sk_buff *)bp->p_rcv_buff_va[i+j];
+				if (skb)
+					dev_kfree_skb(skb);
+				bp->p_rcv_buff_va[i+j] = NULL;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
 		}
 
 	}
diff -u -p a/net/fddi/skfp/skfddi.c b/net/fddi/skfp/skfddi.c
--- a/net/fddi/skfp/skfddi.c
+++ b/net/fddi/skfp/skfddi.c
@@ -1115,6 +1115,11 @@ static void send_queued_packets(struct s
 	int frame_status;	// HWM tx frame status.
 
 	pr_debug("send queued packets\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		// send first buffer from queue
 		skb = skb_dequeue(&bp->SendSkbQueue);
@@ -1189,6 +1194,12 @@ static void send_queued_packets(struct s
 			dev_kfree_skb_irq(skb);
 		}
 		spin_unlock_irqrestore(&bp->DriverLock, Flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}			// for
 
 	return;			// never reached
diff -u -p a/net/fddi/skfp/smttimer.c b/net/fddi/skfp/smttimer.c
--- a/net/fddi/skfp/smttimer.c
+++ b/net/fddi/skfp/smttimer.c
@@ -48,6 +48,11 @@ void smt_timer_stop(struct s_smc *smc, s
 	if (smc->t.st_queue == timer && !timer->tm_next) {
 		hwt_stop(smc) ;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (prev = &smc->t.st_queue ; (tm = *prev) ; prev = &tm->tm_next ) {
 		if (tm == timer) {
 			*prev = tm->tm_next ;
@@ -56,6 +61,12 @@ void smt_timer_stop(struct s_smc *smc, s
 			}
 			return ;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -145,9 +156,20 @@ static void timer_done(struct s_smc *smc
 	next = smc->t.st_queue ;
 	smc->t.st_queue = tm ;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for ( tm = next ; tm ; tm = next) {
 		next = tm->tm_next ;
 		timer_event(smc,tm->tm_token) ;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (restart && smc->t.st_queue)
diff -u -p a/net/bonding/bond_3ad.c b/net/bonding/bond_3ad.c
--- a/net/bonding/bond_3ad.c
+++ b/net/bonding/bond_3ad.c
@@ -699,12 +699,23 @@ static void __set_agg_ports_ready(struct
 {
 	struct port *port;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (port = aggregator->lag_ports; port;
 	     port = port->next_port_in_aggregator) {
 		if (val)
 			port->sm_vars |= AD_PORT_READY;
 		else
 			port->sm_vars &= ~AD_PORT_READY;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1558,6 +1569,11 @@ static void ad_agg_selection_logic(struc
 			 best->lag_ports, best->slave,
 			 best->slave ? best->slave->dev->name : "NULL");
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (agg = __get_first_agg(best->lag_ports); agg;
 		     agg = __get_next_agg(agg)) {
 
@@ -1566,6 +1582,12 @@ static void ad_agg_selection_logic(struc
 				 agg->actor_oper_aggregator_key,
 				 agg->partner_oper_aggregator_key,
 				 agg->is_individual, agg->is_active);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 
 		// check if any partner replys
@@ -1585,9 +1607,20 @@ static void ad_agg_selection_logic(struc
 
 		// disable the ports that were related to the former active_aggregator
 		if (active) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (port = active->lag_ports; port;
 			     port = port->next_port_in_aggregator) {
 				__disable_port(port);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 			}
 		}
 	}
@@ -1600,9 +1633,20 @@ static void ad_agg_selection_logic(struc
 
 	if (active) {
 		if (!__agg_has_partner(active)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (port = active->lag_ports; port;
 			     port = port->next_port_in_aggregator) {
 				__enable_port(port);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 			}
 		}
 	}
@@ -2025,10 +2069,21 @@ void bond_3ad_unbind_slave(struct slave
 				new_aggregator->num_of_ports = aggregator->num_of_ports;
 
 				// update the information that is written on the ports about the aggregator
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				for (temp_port = aggregator->lag_ports; temp_port;
 				     temp_port = temp_port->next_port_in_aggregator) {
 					temp_port->aggregator = new_aggregator;
 					temp_port->actor_port_aggregator_identifier = new_aggregator->aggregator_identifier;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 				}
 
 				// clear the aggregator
@@ -2129,7 +2184,12 @@ void bond_3ad_state_machine_handler(stru
 	}
 
 	// for each port run the state machines
-	for (port = __get_first_port(bond); port; port = __get_next_port(port)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (port = __get_first_port(bond); port; port = __get_next_port(port)) {
 		if (!port->slave) {
 			pr_warning("%s: Warning: Found an uninitialized port\n",
 				   bond->dev->name);
@@ -2153,6 +2213,12 @@ void bond_3ad_state_machine_handler(stru
 			port->sm_vars &= ~AD_PORT_BEGIN;
 
 		__release_state_machine_lock(port);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 re_arm:
diff -u -p a/net/wan/wanxl.c b/net/wan/wanxl.c
--- a/net/wan/wanxl.c
+++ b/net/wan/wanxl.c
@@ -716,8 +716,20 @@ static int __devinit wanxl_pci_init_one(
 		return -EFAULT;
 	}
 
-	for (i = 0; i < sizeof(firmware); i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < sizeof(firmware); i += 4) {
 		writel(ntohl(*(__be32*)(firmware + i)), mem + PDM_OFFSET + i);
+		if (_cur < timeout) {
+ 		rdstcll(_cur);
+		}
+		else {
+ 		break;
+		}
+	}
 
 	for (i = 0; i < ports; i++)
 		writel(card->status_address +
diff -u -p a/net/wan/pc300_drv.c b/net/wan/pc300_drv.c
--- a/net/wan/pc300_drv.c
+++ b/net/wan/pc300_drv.c
@@ -375,6 +375,11 @@ static void tx_dma_buf_check(pc300_t * c
 	printk("#CH%d: f_bd = %d(0x%08zx), n_bd = %d(0x%08zx)\n", ch,
 	       first_bd, TX_BD_ADDR(ch, first_bd),
 	       next_bd, TX_BD_ADDR(ch, next_bd));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = first_bd,
 	     ptdescr = (card->hw.rambase + TX_BD_ADDR(ch, first_bd));
 	     i != ((next_bd + 1) & (N_DMA_TX_BUF - 1));
@@ -384,6 +389,12 @@ static void tx_dma_buf_check(pc300_t * c
 		       ch, i, cpc_readl(&ptdescr->next),
 		       cpc_readl(&ptdescr->ptbuf),
 		       cpc_readb(&ptdescr->status), cpc_readw(&ptdescr->len));
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	printk("\n");
 }
diff -u -p a/net/wan/hdlc_ppp.c b/net/wan/hdlc_ppp.c
--- a/net/wan/hdlc_ppp.c
+++ b/net/wan/hdlc_ppp.c
@@ -385,6 +385,11 @@ static void ppp_cp_parse_cr(struct net_d
 		return;	/* out of memory, ignore CR packet */
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (opt = data; len; len -= opt[1], opt += opt[1]) {
 		if (len < 2 || len < opt[1]) {
 			dev->stats.rx_errors++;
@@ -417,6 +422,12 @@ static void ppp_cp_parse_cr(struct net_d
 		/* reject this option */
 		memcpy(out + rej_len, opt, opt[1]);
 		rej_len += opt[1];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (rej_len)
diff -u -p a/net/ethernet/sis/sis900.c b/net/ethernet/sis/sis900.c
--- a/net/ethernet/sis/sis900.c
+++ b/net/ethernet/sis/sis900.c
@@ -725,6 +725,11 @@ static u16 sis900_default_phy(struct net
 		*default_phy = NULL, *phy_lan = NULL;
 	u16 status;
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for (phy=sis_priv->first_mii; phy; phy=phy->next) {
 		status = mdio_read(net_dev, phy->phy_addr, MII_STATUS);
 		status = mdio_read(net_dev, phy->phy_addr, MII_STATUS);
@@ -742,6 +747,12 @@ static u16 sis900_default_phy(struct net
 			else if(phy->phy_types == LAN)
 				phy_lan = phy;
 		 }
+		 if (_cur < timeout) {
+				rdstcll(_cur);
+		 }
+		else {
+				break;
+		}
 	}
 
 	if (!default_phy && phy_home)
diff -u -p a/net/ethernet/i825xx/eexpress.c b/net/ethernet/i825xx/eexpress.c
--- a/net/ethernet/i825xx/eexpress.c
+++ b/net/ethernet/i825xx/eexpress.c
@@ -1477,12 +1477,36 @@ static void eexp_hw_init586(struct net_d
 	for (i = 0; i < ARRAY_SIZE(start_code) * 2; i+=32) {
 		int j;
 		outw(i, ioaddr + SM_PTR);
-		for (j = 0; j < 16 && (i+j)/2 < ARRAY_SIZE(start_code); j+=2)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (j = 0; j < 16 && (i+j)/2 < ARRAY_SIZE(start_code); j+=2) {
 			outw(start_code[(i+j)/2],
-			     ioaddr+0x4000+j);
-		for (j = 0; j < 16 && (i+j+16)/2 < ARRAY_SIZE(start_code); j+=2)
-			outw(start_code[(i+j+16)/2],
-			     ioaddr+0x8000+j);
+			ioaddr+0x4000+j);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (j = 0; j < 16 && (i+j+16)/2 < ARRAY_SIZE(start_code); j+=2) {
+		outw(start_code[(i+j+16)/2],
+			ioaddr+0x8000+j);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 	}
 
 	/* Do we want promiscuous mode or multicast? */
diff -u -p a/net/ethernet/intel/e1000/e1000_main.c b/net/ethernet/intel/e1000/e1000_main.c
--- a/net/ethernet/intel/e1000/e1000_main.c
+++ b/net/ethernet/intel/e1000/e1000_main.c
@@ -749,8 +749,20 @@ static void e1000_dump_eeprom(struct e10
 
 	csum_old = (data[EEPROM_CHECKSUM_REG * 2]) +
 		   (data[EEPROM_CHECKSUM_REG * 2 + 1] << 8);
-	for (i = 0; i < EEPROM_CHECKSUM_REG * 2; i += 2)
-		csum_new += data[i] + (data[i + 1] << 8);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < EEPROM_CHECKSUM_REG * 2; i += 2) {
+		   csum_new += data[i] + (data[i + 1] << 8);
+		   if (_cur < timeout) {
+		rdstcll(_cur);
+		   }
+		   else {
+		break;
+		   }
+	}
 	csum_new = EEPROM_SUM - csum_new;
 
 	pr_err("/*********************/\n");
diff -u -p a/net/ethernet/intel/e100.c b/net/ethernet/intel/e100.c
--- a/net/ethernet/intel/e100.c
+++ b/net/ethernet/intel/e100.c
@@ -1778,6 +1778,11 @@ static int e100_tx_clean(struct nic *nic
 	spin_lock(&nic->cb_lock);
 
 	/* Clean CBs marked complete */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cb = nic->cb_to_clean;
 	    cb->status & cpu_to_le16(cb_complete);
 	    cb = nic->cb_to_clean = cb->next) {
@@ -1801,6 +1806,12 @@ static int e100_tx_clean(struct nic *nic
 		}
 		cb->status = 0;
 		nic->cbs_avail++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock(&nic->cb_lock);
diff -u -p a/net/ethernet/sun/sunhme.c b/net/ethernet/sun/sunhme.c
--- a/net/ethernet/sun/sunhme.c
+++ b/net/ethernet/sun/sunhme.c
@@ -2536,6 +2536,11 @@ static int __init quattro_sbus_register_
 {
 	struct quattro *qp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qp = qfe_sbus_list; qp != NULL; qp = qp->next) {
 		struct platform_device *op = qp->quattro_dev;
 		int err, qfe_slot, skip = 0;
@@ -2556,6 +2561,12 @@ static int __init quattro_sbus_register_
 			       "error %d.\n", err);
 			return err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -2565,6 +2576,11 @@ static void quattro_sbus_free_irqs(void)
 {
 	struct quattro *qp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qp = qfe_sbus_list; qp != NULL; qp = qp->next) {
 		struct platform_device *op = qp->quattro_dev;
 		int qfe_slot, skip = 0;
@@ -2577,6 +2593,12 @@ static void quattro_sbus_free_irqs(void)
 			continue;
 
 		free_irq(op->archdata.irqs[0], qp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 #endif /* CONFIG_SBUS */
@@ -2588,11 +2610,22 @@ static struct quattro * __devinit quattr
 	struct quattro *qp;
 
 	if (!bdev) return NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (qp = qfe_pci_list; qp != NULL; qp = qp->next) {
 		struct pci_dev *qpdev = qp->quattro_dev;
 
 		if (qpdev == bdev)
 			return qp;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	qp = kmalloc(sizeof(struct quattro), GFP_KERNEL);
 	if (qp != NULL) {
diff -u -p a/net/ethernet/sun/sunvnet.c b/net/ethernet/sun/sunvnet.c
--- a/net/ethernet/sun/sunvnet.c
+++ b/net/ethernet/sun/sunvnet.c
@@ -751,9 +751,20 @@ static struct vnet_mcast_entry *__vnet_m
 {
 	struct vnet_mcast_entry *m;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (m = vp->mcast_list; m; m = m->next) {
 		if (!memcmp(m->addr, addr, ETH_ALEN))
 			return m;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return NULL;
 }
@@ -799,7 +810,12 @@ static void __send_mc_list(struct vnet *
 	info.set = 1;
 
 	n_addrs = 0;
-	for (m = vp->mcast_list; m; m = m->next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (m = vp->mcast_list; m; m = m->next) {
 		if (m->sent)
 			continue;
 		m->sent = 1;
@@ -812,6 +828,12 @@ static void __send_mc_list(struct vnet *
 					    sizeof(info));
 			n_addrs = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (n_addrs) {
 		info.count = n_addrs;
diff -u -p a/net/ethernet/davicom/dm9000.c b/net/ethernet/davicom/dm9000.c
--- a/net/ethernet/davicom/dm9000.c
+++ b/net/ethernet/davicom/dm9000.c
@@ -629,8 +629,20 @@ static int dm9000_get_eeprom(struct net_
 
 	ee->magic = DM_EEPROM_MAGIC;
 
-	for (i = 0; i < len; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < len; i += 2) {
 		dm9000_read_eeprom(dm, (offset + i) / 2, data + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	return 0;
 }
@@ -1572,8 +1584,20 @@ dm9000_probe(struct platform_device *pde
 	mac_src = "eeprom";
 
 	/* try reading the node address from the attached EEPROM */
-	for (i = 0; i < 6; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 6; i += 2) {
 		dm9000_read_eeprom(db, i / 2, ndev->dev_addr+i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	if (!is_valid_ether_addr(ndev->dev_addr) && pdata != NULL) {
 		mac_src = "platform data";
diff -u -p a/net/ethernet/via/via-velocity.c b/net/ethernet/via/via-velocity.c
--- a/net/ethernet/via/via-velocity.c
+++ b/net/ethernet/via/via-velocity.c
@@ -2991,14 +2991,50 @@ static void velocity_save_context(struct
 	u16 i;
 	u8 __iomem *ptr = (u8 __iomem *)regs;
 
-	for (i = MAC_REG_PAR; i < MAC_REG_CR0_CLR; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = MAC_REG_PAR; i < MAC_REG_CR0_CLR; i += 4) {
 		*((u32 *) (context->mac_reg + i)) = readl(ptr + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
-	for (i = MAC_REG_MAR; i < MAC_REG_TDCSR_CLR; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = MAC_REG_MAR; i < MAC_REG_TDCSR_CLR; i += 4) {
 		*((u32 *) (context->mac_reg + i)) = readl(ptr + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
-	for (i = MAC_REG_RDBASE_LO; i < MAC_REG_FIFO_TEST0; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = MAC_REG_RDBASE_LO; i < MAC_REG_FIFO_TEST0; i += 4) {
 		*((u32 *) (context->mac_reg + i)) = readl(ptr + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 }
 
@@ -3048,8 +3084,20 @@ static void velocity_restore_context(str
 	int i;
 	u8 __iomem *ptr = (u8 __iomem *)regs;
 
-	for (i = MAC_REG_PAR; i < MAC_REG_CR0_SET; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = MAC_REG_PAR; i < MAC_REG_CR0_SET; i += 4) {
 		writel(*((u32 *) (context->mac_reg + i)), ptr + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* Just skip cr0 */
 	for (i = MAC_REG_CR1_SET; i < MAC_REG_CR0_CLR; i++) {
@@ -3059,11 +3107,35 @@ static void velocity_restore_context(str
 		writeb(*((u8 *) (context->mac_reg + i)), ptr + i);
 	}
 
-	for (i = MAC_REG_MAR; i < MAC_REG_IMR; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = MAC_REG_MAR; i < MAC_REG_IMR; i += 4) {
 		writel(*((u32 *) (context->mac_reg + i)), ptr + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
-	for (i = MAC_REG_RDBASE_LO; i < MAC_REG_FIFO_TEST0; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = MAC_REG_RDBASE_LO; i < MAC_REG_FIFO_TEST0; i += 4) {
 		writel(*((u32 *) (context->mac_reg + i)), ptr + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	for (i = MAC_REG_TDCSR_SET; i <= MAC_REG_RDCSR_SET; i++)
 		writeb(*((u8 *) (context->mac_reg + i)), ptr + i);
diff -u -p a/net/ethernet/ti/tlan.c b/net/ethernet/ti/tlan.c
--- a/net/ethernet/ti/tlan.c
+++ b/net/ethernet/ti/tlan.c
@@ -2170,8 +2170,20 @@ tlan_reset_adapter(struct net_device *de
 
 /*  3.	Clear AREGs and HASHs. */
 
-	for (i = TLAN_AREG_0; i <= TLAN_HASH_2; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = TLAN_AREG_0; i <= TLAN_HASH_2; i += 4) {
 		tlan_dio_write32(dev->base_addr, (u16) i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 /*  4.	Setup NetConfig register. */
 
diff -u -p a/net/ethernet/marvell/skge.c b/net/ethernet/marvell/skge.c
--- a/net/ethernet/marvell/skge.c
+++ b/net/ethernet/marvell/skge.c
@@ -2845,10 +2845,21 @@ static void skge_tx_clean(struct net_dev
 	struct skge_port *skge = netdev_priv(dev);
 	struct skge_element *e;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (e = skge->tx_ring.to_clean; e != skge->tx_ring.to_use; e = e->next) {
 		struct skge_tx_desc *td = e->desc;
 		skge_tx_free(skge, e, td->control);
 		td->control = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	skge->tx_ring.to_clean = e;
@@ -3652,11 +3663,22 @@ static int skge_debug_show(struct seq_fi
 		   skge_read32(hw, B0_IMSK));
 
 	seq_printf(seq, "Tx Ring: (%d)\n", skge_avail(&skge->tx_ring));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (e = skge->tx_ring.to_clean; e != skge->tx_ring.to_use; e = e->next) {
 		const struct skge_tx_desc *t = e->desc;
 		seq_printf(seq, "%#x dma=%#x%08x %#x csum=%#x/%x/%x\n",
 			   t->control, t->dma_hi, t->dma_lo, t->status,
 			   t->csum_offs, t->csum_write, t->csum_start);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	seq_printf(seq, "\nRx Ring:\n");
diff -u -p a/net/ethernet/marvell/sky2.c b/net/ethernet/marvell/sky2.c
--- a/net/ethernet/marvell/sky2.c
+++ b/net/ethernet/marvell/sky2.c
@@ -943,8 +943,20 @@ static void sky2_mac_init(struct sky2_hw
 	reg = gma_read16(hw, port, GM_PHY_ADDR);
 	gma_write16(hw, port, GM_PHY_ADDR, reg | GM_PAR_MIB_CLR);
 
-	for (i = GM_MIB_CNT_BASE; i <= GM_MIB_CNT_END; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = GM_MIB_CNT_BASE; i <= GM_MIB_CNT_END; i += 4) {
 		gma_read16(hw, port, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	gma_write16(hw, port, GM_PHY_ADDR, reg);
 
 	/* transmit control */
@@ -1988,11 +2000,22 @@ static netdev_tx_t sky2_xmit_frame(struc
 	return NETDEV_TX_OK;
 
 mapping_unwind:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = sky2->tx_prod; i != slot; i = RING_NEXT(i, sky2->tx_ring_size)) {
 		re = sky2->tx_ring + i;
 
 		sky2_tx_unmap(hw->pdev, re);
-	}
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+		}
 
 mapping_error:
 	if (net_ratelimit())
@@ -2018,6 +2041,11 @@ static void sky2_tx_complete(struct sky2
 
 	BUG_ON(done >= sky2->tx_ring_size);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = sky2->tx_cons; idx != done;
 	     idx = RING_NEXT(idx, sky2->tx_ring_size)) {
 		struct tx_ring_info *re = sky2->tx_ring + idx;
@@ -2039,6 +2067,12 @@ static void sky2_tx_complete(struct sky2
 
 			sky2->tx_next = RING_NEXT(idx, sky2->tx_ring_size);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sky2->tx_cons = idx;
@@ -4520,11 +4554,22 @@ static int sky2_debug_show(struct seq_fi
 		seq_puts(seq, "Status ring (empty)\n");
 	else {
 		seq_puts(seq, "Status ring\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (idx = hw->st_idx; idx != last && idx < hw->st_size;
 		     idx = RING_NEXT(idx, hw->st_size)) {
 			const struct sky2_status_le *le = hw->st_le + idx;
 			seq_printf(seq, "[%d] %#x %d %#x\n",
 				   idx, le->opcode, le->length, le->status);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		seq_puts(seq, "\n");
 	}
@@ -4536,6 +4581,11 @@ static int sky2_debug_show(struct seq_fi
 
 	/* Dump contents of tx ring */
 	sop = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (idx = sky2->tx_next; idx != sky2->tx_prod && idx < sky2->tx_ring_size;
 	     idx = RING_NEXT(idx, sky2->tx_ring_size)) {
 		const struct sky2_tx_le *le = sky2->tx_le + idx;
@@ -4576,6 +4626,12 @@ static int sky2_debug_show(struct seq_fi
 			seq_putc(seq, '\n');
 			sop = 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	seq_printf(seq, "\nRx ring hw get=%d put=%d last=%d\n",
diff -u -p a/net/ethernet/marvell/mv643xx_eth.c b/net/ethernet/marvell/mv643xx_eth.c
--- a/net/ethernet/marvell/mv643xx_eth.c
+++ b/net/ethernet/marvell/mv643xx_eth.c
@@ -1223,8 +1223,20 @@ static void mib_counters_clear(struct mv
 {
 	int i;
 
-	for (i = 0; i < 0x80; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 0x80; i += 4) {
 		mib_read(mp, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static void mib_counters_update(struct mv643xx_eth_private *mp)
diff -u -p a/net/ethernet/freescale/ucc_geth.c b/net/ethernet/freescale/ucc_geth.c
--- a/net/ethernet/freescale/ucc_geth.c
+++ b/net/ethernet/freescale/ucc_geth.c
@@ -174,12 +174,24 @@ static void mem_disp(u8 *addr, int size)
 	if (size % 16)
 		notAlign = 1;
 
-	for (i = addr; (u32) i < (u32) addr + size16Aling; i += 16)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = addr; (u32) i < (u32) addr + size16Aling; i += 16) {
 		printk("0x%08x: %08x %08x %08x %08x\r\n",
-		       (u32) i,
-		       *((u32 *) (i)),
-		       *((u32 *) (i + 4)),
-		       *((u32 *) (i + 8)), *((u32 *) (i + 12)));
+			(u32) i,
+			*((u32 *) (i)),
+			*((u32 *) (i + 4)),
+			*((u32 *) (i + 8)), *((u32 *) (i + 12)));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 	if (notAlign == 1)
 		printk("0x%08x: ", (u32) i);
 	for (; (u32) i < (u32) addr + size4Aling; i += 4)
diff -u -p a/net/ethernet/8390/pcnet_cs.c b/net/ethernet/8390/pcnet_cs.c
--- a/net/ethernet/8390/pcnet_cs.c
+++ b/net/ethernet/8390/pcnet_cs.c
@@ -1426,8 +1426,20 @@ static int setup_shmem_window(struct pcm
     /* Try scribbling on the buffer */
     info->base = ioremap(link->resource[3]->start,
 			resource_size(link->resource[3]));
-    for (i = 0; i < (TX_PAGES<<8); i += 2)
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    for (i = 0; i < (TX_PAGES<<8); i += 2) {
 	__raw_writew((i>>1), info->base+offset+i);
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
+    }
     udelay(100);
     for (i = 0; i < (TX_PAGES<<8); i += 2)
 	if (__raw_readw(info->base+offset+i) != (i>>1)) break;
diff -u -p a/net/ethernet/toshiba/ps3_gelic_net.c b/net/ethernet/toshiba/ps3_gelic_net.c
--- a/net/ethernet/toshiba/ps3_gelic_net.c
+++ b/net/ethernet/toshiba/ps3_gelic_net.c
@@ -215,10 +215,21 @@ static void gelic_card_free_chain(struct
 {
 	struct gelic_descr *descr;
 
-	for (descr = descr_in; descr && descr->bus_addr; descr = descr->next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (descr = descr_in; descr && descr->bus_addr; descr = descr->next) {
 		dma_unmap_single(ctodev(card), descr->bus_addr,
 				 GELIC_DESCR_SIZE, DMA_BIDIRECTIONAL);
 		descr->bus_addr = 0;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -497,6 +508,11 @@ static void gelic_card_release_tx_chain(
 	struct net_device *netdev;
 	int release = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tx_chain = &card->tx_chain;
 	     tx_chain->head != tx_chain->tail && tx_chain->tail;
 	     tx_chain->tail = tx_chain->tail->next) {
@@ -531,7 +547,13 @@ static void gelic_card_release_tx_chain(
 		}
 		gelic_descr_release_tx(card, tx_chain->tail);
 		release ++;
-	}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+		}
 out:
 	if (!stop && release)
 		gelic_card_wake_queues(card);
diff -u -p a/net/ethernet/sfc/mtd.c b/net/ethernet/sfc/mtd.c
--- a/net/ethernet/sfc/mtd.c
+++ b/net/ethernet/sfc/mtd.c
@@ -163,7 +163,12 @@ efx_spi_erase(struct efx_mtd_partition *
 
 	/* Verify the entire region has been wiped */
 	memset(empty, 0xff, sizeof(empty));
-	for (pos = 0; pos < len; pos += block_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (pos = 0; pos < len; pos += block_len) {
 		block_len = min(len - pos, sizeof(buffer));
 		rc = falcon_spi_read(efx, spi, start + pos, block_len,
 				     NULL, buffer);
@@ -176,6 +181,12 @@ efx_spi_erase(struct efx_mtd_partition *
 		cond_resched();
 		if (signal_pending(current))
 			return -EINTR;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	return rc;
diff -u -p a/net/ethernet/sfc/mcdi.c b/net/ethernet/sfc/mcdi.c
--- a/net/ethernet/sfc/mcdi.c
+++ b/net/ethernet/sfc/mcdi.c
@@ -94,8 +94,20 @@ static void efx_mcdi_copyin(struct efx_n
 
 	efx_writed(efx, &hdr, pdu);
 
-	for (i = 0; i < inlen; i += 4)
-		_efx_writed(efx, *((__le32 *)(inbuf + i)), pdu + 4 + i);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < inlen; i += 4) {
+	_efx_writed(efx, *((__le32 *)(inbuf + i)), pdu + 4 + i);
+	if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
+	}
 
 	/* Ensure the payload is written out before the header */
 	wmb();
@@ -113,8 +125,20 @@ static void efx_mcdi_copyout(struct efx_
 	BUG_ON(atomic_read(&mcdi->state) == MCDI_STATE_QUIESCENT);
 	BUG_ON(outlen & 3 || outlen >= 0x100);
 
-	for (i = 0; i < outlen; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < outlen; i += 4) {
 		*((__le32 *)(outbuf + i)) = _efx_readd(efx, pdu + 4 + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static int efx_mcdi_poll(struct efx_nic *efx)
diff -u -p a/net/ethernet/sfc/filter.c b/net/ethernet/sfc/filter.c
--- a/net/ethernet/sfc/filter.c
+++ b/net/ethernet/sfc/filter.c
@@ -346,6 +346,11 @@ static int efx_filter_search(struct efx_
 		      FILTER_CTL_SRCH_HINT_MAX : FILTER_CTL_SRCH_MAX) :
 		     table->search_depth[spec->type]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		/* Return success if entry is used and matches this spec
 		 * or entry is unused and we are trying to insert.
@@ -363,6 +368,12 @@ static int efx_filter_search(struct efx_
 
 		filter_idx = (filter_idx + incr) & (table->size - 1);
 		++depth;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/sfc/falcon.c b/net/ethernet/sfc/falcon.c
--- a/net/ethernet/sfc/falcon.c
+++ b/net/ethernet/sfc/falcon.c
@@ -232,7 +232,12 @@ static int falcon_spi_wait(struct efx_ni
 		udelay(10);
 	}
 
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		if (!falcon_spi_poll(efx))
 			return 0;
 		if (time_after_eq(jiffies, timeout)) {
@@ -241,6 +246,12 @@ static int falcon_spi_wait(struct efx_ni
 			return -ETIMEDOUT;
 		}
 		schedule_timeout_uninterruptible(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -322,7 +333,12 @@ falcon_spi_wait_write(struct efx_nic *ef
 	u8 status;
 	int rc;
 
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (;;) {
 		rc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,
 				    &status, sizeof(status));
 		if (rc)
@@ -337,6 +353,12 @@ falcon_spi_wait_write(struct efx_nic *ef
 			return -ETIMEDOUT;
 		}
 		schedule_timeout_uninterruptible(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/amd/sunlance.c b/net/ethernet/amd/sunlance.c
--- a/net/ethernet/amd/sunlance.c
+++ b/net/ethernet/amd/sunlance.c
@@ -515,6 +515,11 @@ static void lance_rx_dvma(struct net_dev
 	int len, entry = lp->rx_new;
 	struct sk_buff *skb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = &ib->brx_ring [entry];
 	     !((bits = rd->rmd1_bits) & LE_R1_OWN);
 	     rd = &ib->brx_ring [entry]) {
@@ -562,6 +567,12 @@ static void lance_rx_dvma(struct net_dev
 		rd->mblength = 0;
 		rd->rmd1_bits = LE_R1_OWN;
 		entry = RX_NEXT(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lp->rx_new = entry;
@@ -687,6 +698,11 @@ static void lance_rx_pio(struct net_devi
 	struct sk_buff *skb;
 
 	entry = lp->rx_new;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = &ib->brx_ring [entry];
 	     !((bits = sbus_readb(&rd->rmd1_bits)) & LE_R1_OWN);
 	     rd = &ib->brx_ring [entry]) {
@@ -732,6 +748,12 @@ static void lance_rx_pio(struct net_devi
 		sbus_writew(0, &rd->mblength);
 		sbus_writeb(LE_R1_OWN, &rd->rmd1_bits);
 		entry = RX_NEXT(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lp->rx_new = entry;
diff -u -p a/net/ethernet/amd/depca.c b/net/ethernet/amd/depca.c
--- a/net/ethernet/amd/depca.c
+++ b/net/ethernet/amd/depca.c
@@ -1804,12 +1804,23 @@ static int load_packet(struct net_device
 
 		/* set up the buffer descriptors */
 		len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = entry; i != end; i = (i+1) & lp->txRingMask) {
 			/* clean out flags */
 			writel(readl(&lp->tx_ring[i].base) & ~T_FLAGS, &lp->tx_ring[i].base);
 			writew(0x0000, &lp->tx_ring[i].misc);	/* clears other error flags */
 			writew(-TX_BUFF_SZ, &lp->tx_ring[i].length);	/* packet length in buffer */
 			len -= TX_BUFF_SZ;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* clean out flags */
 		writel(readl(&lp->tx_ring[end].base) & ~T_FLAGS, &lp->tx_ring[end].base);
diff -u -p a/net/ethernet/amd/a2065.c b/net/ethernet/amd/a2065.c
--- a/net/ethernet/amd/a2065.c
+++ b/net/ethernet/amd/a2065.c
@@ -265,6 +265,11 @@ static int lance_rx(struct net_device *d
 #endif
 
 	ll->rdp = LE_C0_RINT | LE_C0_INEA;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = &ib->brx_ring[lp->rx_new];
 	     !((bits = rd->rmd1_bits) & LE_R1_OWN);
 	     rd = &ib->brx_ring[lp->rx_new]) {
@@ -316,6 +321,12 @@ static int lance_rx(struct net_device *d
 		rd->mblength = 0;
 		rd->rmd1_bits = LE_R1_OWN;
 		lp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/amd/7990.c b/net/ethernet/amd/7990.c
--- a/net/ethernet/amd/7990.c
+++ b/net/ethernet/amd/7990.c
@@ -296,6 +296,11 @@ static int lance_rx (struct net_device *
 	blinken_leds(0x40, 0);
 #endif
         WRITERDP(lp, LE_C0_RINT | LE_C0_INEA);     /* ack Rx int, reenable ints */
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for (rd = &ib->brx_ring [lp->rx_new];     /* For each Rx ring we own... */
              !((bits = rd->rmd1_bits) & LE_R1_OWN);
              rd = &ib->brx_ring [lp->rx_new]) {
@@ -343,6 +348,12 @@ static int lance_rx (struct net_device *
                 rd->mblength = 0;
                 rd->rmd1_bits = LE_R1_OWN;
                 lp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;
+                if (_cur < timeout) {
+			rdstcll(_cur);
+                }
+                else {
+			break;
+                }
         }
         return 0;
 }
diff -u -p a/net/ethernet/amd/pcnet32.c b/net/ethernet/amd/pcnet32.c
--- a/net/ethernet/amd/pcnet32.c
+++ b/net/ethernet/amd/pcnet32.c
@@ -1376,8 +1376,20 @@ static void pcnet32_get_regs(struct net_
 		pcnet32_suspend(dev, &flags, 1);
 
 	/* read address PROM */
-	for (i = 0; i < 16; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 16; i += 2) {
 		*buff++ = inw(ioaddr + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* read control and status registers */
 	for (i = 0; i < 90; i++)
diff -u -p a/net/ethernet/amd/declance.c b/net/ethernet/amd/declance.c
--- a/net/ethernet/amd/declance.c
+++ b/net/ethernet/amd/declance.c
@@ -580,6 +580,11 @@ static int lance_rx(struct net_device *d
 	}
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = lib_ptr(ib, brx_ring[lp->rx_new], lp->type);
 	     !((bits = *rds_ptr(rd, rmd1, lp->type)) & LE_R1_OWN);
 	     rd = lib_ptr(ib, brx_ring[lp->rx_new], lp->type)) {
@@ -637,6 +642,12 @@ static int lance_rx(struct net_device *d
 		*rds_ptr(rd, rmd1, lp->type) =
 			((lp->rx_buf_ptr_lnc[entry] >> 16) & 0xff) | LE_R1_OWN;
 		lp->rx_new = (entry + 1) & RX_RING_MOD_MASK;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/sgi/ioc3-eth.c b/net/ethernet/sgi/ioc3-eth.c
--- a/net/ethernet/sgi/ioc3-eth.c
+++ b/net/ethernet/sgi/ioc3-eth.c
@@ -841,11 +841,22 @@ static inline void ioc3_clean_rx_ring(st
 	ip->rx_pi &= 511;
 	ip->rx_ci &= 511;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = ip->rx_ci; i != ip->rx_pi; i = (i+1) & 511) {
 		struct ioc3_erxbuf *rxb;
 		skb = ip->rx_skbs[i];
 		rxb = (struct ioc3_erxbuf *) (skb->data - RX_OFFSET);
 		rxb->w0 = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/jme.c b/net/ethernet/jme.c
--- a/net/ethernet/jme.c
+++ b/net/ethernet/jme.c
@@ -2407,8 +2407,20 @@ mmapio_memcpy(struct jme_adapter *jme, u
 {
 	int i;
 
-	for (i = 0 ; i < len ; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0 ; i < len ; i += 4) {
 		p[i >> 2] = jread32(jme, reg + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static void
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/net/ethernet/broadcom/bnx2x/bnx2x_main.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@ -740,17 +740,39 @@ void bnx2x_fw_dump_lvl(struct bnx2x *bp,
 	printk("%s" "begin fw dump (mark 0x%x)\n", lvl, mark);
 
 	printk("%s", lvl);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = mark; offset <= trace_shmem_base; offset += 0x8*4) {
 		for (word = 0; word < 8; word++)
 			data[word] = htonl(REG_RD(bp, offset + 4*word));
 		data[8] = 0x0;
 		pr_cont("%s", (char *)data);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = addr + 4; offset <= mark; offset += 0x8*4) {
 		for (word = 0; word < 8; word++)
 			data[word] = htonl(REG_RD(bp, offset + 4*word));
 		data[8] = 0x0;
 		pr_cont("%s", (char *)data);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("%s" "end of fw dump\n", lvl);
 }
@@ -936,31 +958,64 @@ void bnx2x_panic_dump(struct bnx2x *bp)
 
 		start = RX_BD(le16_to_cpu(*fp->rx_cons_sb) - 10);
 		end = RX_BD(le16_to_cpu(*fp->rx_cons_sb) + 503);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = start; j != end; j = RX_BD(j + 1)) {
 			u32 *rx_bd = (u32 *)&fp->rx_desc_ring[j];
 			struct sw_rx_bd *sw_bd = &fp->rx_buf_ring[j];
 
 			BNX2X_ERR("fp%d: rx_bd[%x]=[%x:%x]  sw_bd=[%p]\n",
 				  i, j, rx_bd[1], rx_bd[0], sw_bd->skb);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		start = RX_SGE(fp->rx_sge_prod);
 		end = RX_SGE(fp->last_max_sge);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = start; j != end; j = RX_SGE(j + 1)) {
 			u32 *rx_sge = (u32 *)&fp->rx_sge_ring[j];
 			struct sw_rx_page *sw_page = &fp->rx_page_ring[j];
 
 			BNX2X_ERR("fp%d: rx_sge[%x]=[%x:%x]  sw_page=[%p]\n",
 				  i, j, rx_sge[1], rx_sge[0], sw_page->page);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		start = RCQ_BD(fp->rx_comp_cons - 10);
 		end = RCQ_BD(fp->rx_comp_cons + 503);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = start; j != end; j = RCQ_BD(j + 1)) {
 			u32 *cqe = (u32 *)&fp->rx_comp_ring[j];
 
 			BNX2X_ERR("fp%d: cqe[%x]=[%x:%x:%x:%x]\n",
 				  i, j, cqe[0], cqe[1], cqe[2], cqe[3]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -972,7 +1027,12 @@ void bnx2x_panic_dump(struct bnx2x *bp)
 
 			start = TX_BD(le16_to_cpu(*txdata->tx_cons_sb) - 10);
 			end = TX_BD(le16_to_cpu(*txdata->tx_cons_sb) + 245);
-			for (j = start; j != end; j = TX_BD(j + 1)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				for (j = start; j != end; j = TX_BD(j + 1)) {
 				struct sw_tx_bd *sw_bd =
 					&txdata->tx_buf_ring[j];
 
@@ -980,10 +1040,21 @@ void bnx2x_panic_dump(struct bnx2x *bp)
 					  "packet[%x]=[%p,%x]\n",
 					  i, cos, j, sw_bd->skb,
 					  sw_bd->first_bd);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			start = TX_BD(txdata->tx_bd_cons - 10);
 			end = TX_BD(txdata->tx_bd_cons + 254);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (j = start; j != end; j = TX_BD(j + 1)) {
 				u32 *tx_bd = (u32 *)&txdata->tx_desc_ring[j];
 
@@ -991,6 +1062,12 @@ void bnx2x_panic_dump(struct bnx2x *bp)
 					  "[%x:%x:%x:%x]\n",
 					  i, cos, j, tx_bd[0], tx_bd[1],
 					  tx_bd[2], tx_bd[3]);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -4723,9 +4800,22 @@ static void bnx2x_timer(unsigned long da
 static inline void bnx2x_fill(struct bnx2x *bp, u32 addr, int fill, u32 len)
 {
 	u32 i;
-	if (!(len%4) && !(addr%4))
-		for (i = 0; i < len; i += 4)
-			REG_WR(bp, addr + i, fill);
+	if (!(len%4) && !(addr%4)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < len; i += 4) {
+				REG_WR(bp, addr + i, fill);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+	}
 	else
 		for (i = 0; i < len; i++)
 			REG_WR8(bp, addr + i, fill);
@@ -6785,12 +6875,23 @@ static int bnx2x_init_hw_func(struct bnx
 					  "function init (0x%x)!\n", val);
 
 		/* Clear "false" parity errors in MSI-X table */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = main_mem_base;
 		     i < main_mem_base + main_mem_size * 4;
 		     i += main_mem_width) {
 			bnx2x_read_dmae(bp, i, main_mem_width / 4);
 			bnx2x_write_dmae(bp, bnx2x_sp_mapping(bp, wb_data),
 					 i, main_mem_width / 4);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		/* Clear HC parity attention */
 		REG_RD(bp, main_mem_prty_clr);
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_link.c b/net/ethernet/broadcom/bnx2x/bnx2x_link.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_link.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_link.c
@@ -5495,7 +5495,12 @@ static void bnx2x_set_gmii_tx_driver(str
 	if (lp_up2 == 0)
 		return;
 
-	for (bank = MDIO_REG_BANK_TX0; bank <= MDIO_REG_BANK_TX3;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (bank = MDIO_REG_BANK_TX0; bank <= MDIO_REG_BANK_TX3;
 	      bank += (MDIO_REG_BANK_TX1 - MDIO_REG_BANK_TX0)) {
 		CL22_RD_OVER_CL45(bp, phy,
 				  bank,
@@ -5510,6 +5515,12 @@ static void bnx2x_set_gmii_tx_driver(str
 					  bank,
 					  MDIO_TX0_TX_DRIVER, tx_driver);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_sp.c b/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
@@ -3013,11 +3013,22 @@ static inline void bnx2x_mcast_hdl_resto
 {
 	int bit;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bit = bnx2x_mcast_get_next_bin(o, 0);
 	     bit >= 0;
 	     bit = bnx2x_mcast_get_next_bin(o, bit + 1)) {
 		BNX2X_57711_SET_MC_FILTER(mc_filter, bit);
 		DP(BNX2X_MSG_SP, "About to set bin %d\n", bit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/broadcom/bnx2.c b/net/ethernet/broadcom/bnx2.c
--- a/net/ethernet/broadcom/bnx2.c
+++ b/net/ethernet/broadcom/bnx2.c
@@ -2620,8 +2620,20 @@ bnx2_init_context(struct bnx2 *bp)
 			REG_WR(bp, BNX2_CTX_PAGE_TBL, pcid_addr);
 
 			/* Zero out the context. */
-			for (offset = 0; offset < PHY_CTX_SIZE; offset += 4)
-				bnx2_ctx_wr(bp, vcid_addr, offset, 0);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (offset = 0; offset < PHY_CTX_SIZE; offset += 4) {
+	    		bnx2_ctx_wr(bp, vcid_addr, offset, 0);
+	    		if (_cur < timeout) {
+				rdstcll(_cur);
+	    		}
+	    		else {
+				break;
+	    		}
+			}
 		}
 	}
 }
diff -u -p a/net/ethernet/broadcom/cnic.c b/net/ethernet/broadcom/cnic.c
--- a/net/ethernet/broadcom/cnic.c
+++ b/net/ethernet/broadcom/cnic.c
@@ -4120,8 +4120,20 @@ static void cnic_init_context(struct cni
 
 	cid_addr = GET_CID_ADDR(cid);
 
-	for (i = 0; i < CTX_SIZE; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < CTX_SIZE; i += 4) {
 		cnic_ctx_wr(dev, cid_addr, i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static int cnic_setup_5709_context(struct cnic_dev *dev, int valid)
@@ -4301,8 +4313,20 @@ static void cnic_init_bnx2_tx_ring(struc
 	if (CHIP_NUM(cp) == CHIP_NUM_5709) {
 		u32 cid_addr2 = GET_CID_ADDR(tx_cid + 4) + 0x40;
 
-		for (i = 0; i < PHY_CTX_SIZE; i += 4)
-			cnic_ctx_wr(dev, cid_addr2, i, 0);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < PHY_CTX_SIZE; i += 4) {
+		cnic_ctx_wr(dev, cid_addr2, i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 		offset0 = BNX2_L2CTX_TYPE_XI;
 		offset1 = BNX2_L2CTX_CMD_TYPE_XI;
diff -u -p a/net/ethernet/broadcom/b44.c b/net/ethernet/broadcom/b44.c
--- a/net/ethernet/broadcom/b44.c
+++ b/net/ethernet/broadcom/b44.c
@@ -597,6 +597,11 @@ static void b44_tx(struct b44 *bp)
 	cur /= sizeof(struct dma_desc);
 
 	/* XXX needs updating when NETIF_F_SG is supported */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cons = bp->tx_cons; cons != cur; cons = NEXT_TX(cons)) {
 		struct ring_info *rp = &bp->tx_buffers[cons];
 		struct sk_buff *skb = rp->skb;
@@ -609,6 +614,12 @@ static void b44_tx(struct b44 *bp)
 				 DMA_TO_DEVICE);
 		rp->skb = NULL;
 		dev_kfree_skb_irq(skb);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	bp->tx_cons = cons;
@@ -1242,10 +1253,34 @@ static void b44_clear_stats(struct b44 *
 	unsigned long reg;
 
 	bw32(bp, B44_MIB_CTRL, MIB_CTRL_CLR_ON_READ);
-	for (reg = B44_TX_GOOD_O; reg <= B44_TX_PAUSE; reg += 4UL)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (reg = B44_TX_GOOD_O; reg <= B44_TX_PAUSE; reg += 4UL) {
 		br32(bp, reg);
-	for (reg = B44_RX_GOOD_O; reg <= B44_RX_NPAUSE; reg += 4UL)
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (reg = B44_RX_GOOD_O; reg <= B44_RX_NPAUSE; reg += 4UL) {
 		br32(bp, reg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 /* bp->lock is held. */
diff -u -p a/net/ethernet/smsc/smc91c92_cs.c b/net/ethernet/smsc/smc91c92_cs.c
--- a/net/ethernet/smsc/smc91c92_cs.c
+++ b/net/ethernet/smsc/smc91c92_cs.c
@@ -1038,8 +1038,20 @@ static void smc_dump(struct net_device *
     for (w = 0; w < 4; w++) {
 	SMC_SELECT_BANK(w);
 	netdev_printk(KERN_DEBUG, dev, "bank %d: ", w);
-	for (i = 0; i < 14; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 14; i += 2) {
 	    pr_cont(" %04x", inw(ioaddr + i));
+	    if (_cur < timeout) {
+	        rdstcll(_cur);
+	    }
+	    else {
+	        break;
+	    }
+	}
 	pr_cont("\n");
     }
     outw(save, ioaddr + BANK_SELECT);
@@ -1672,9 +1684,21 @@ static void smc_reset(struct net_device
 	     ioaddr - 0x10 + OSITECH_AUI_PWR);
 
     /* Fill in the physical address.  The databook is wrong about the order! */
-    for (i = 0; i < 6; i += 2)
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    for (i = 0; i < 6; i += 2) {
 	outw((dev->dev_addr[i+1]<<8)+dev->dev_addr[i],
-	     ioaddr + ADDR0 + i);
+ioaddr + ADDR0 + i);
+	if (_cur < timeout) {
+    rdstcll(_cur);
+	}
+	else {
+    break;
+	}
+    }
 
     /* Reset the MMU */
     SMC_SELECT_BANK(2);
diff -u -p a/net/ethernet/smsc/smsc9420.c b/net/ethernet/smsc/smsc9420.c
--- a/net/ethernet/smsc/smsc9420.c
+++ b/net/ethernet/smsc/smsc9420.c
@@ -322,8 +322,20 @@ smsc9420_ethtool_getregs(struct net_devi
 	u32 *data = buf;
 
 	regs->version = smsc9420_reg_read(pd, ID_REV);
-	for (i = 0; i < 0x100; i += (sizeof(u32)))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 0x100; i += (sizeof(u32))) {
 		data[j++] = smsc9420_reg_read(pd, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	// cannot read phy registers if the net device is down
 	if (!phy_dev)
diff -u -p a/net/ethernet/hp/hp100.c b/net/ethernet/hp/hp100.c
--- a/net/ethernet/hp/hp100.c
+++ b/net/ethernet/hp/hp100.c
@@ -1734,9 +1734,22 @@ static netdev_tx_t hp100_start_xmit(stru
 	} else {		/* programmed i/o */
 		outsl(ioaddr + HP100_REG_DATA32, skb->data,
 		      (skb->len + 3) >> 2);
-		if (!ok_flag)
-			for (i = (skb->len + 3) & ~3; i < HP100_MIN_PACKET_SIZE; i += 4)
-				hp100_outl(0, DATA32);
+		if (!ok_flag) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = (skb->len + 3) & ~3; i < HP100_MIN_PACKET_SIZE; i += 4) {
+hp100_outl(0, DATA32);
+if (_cur < timeout) {
+		rdstcll(_cur);
+}
+else {
+		break;
+}
+		}
+		}
 	}
 
 	hp100_outb(HP100_TX_CMD | HP100_SET_LB, OPTION_MSW);	/* send packet */
diff -u -p a/net/ethernet/chelsio/cxgb3/cxgb3_main.c b/net/ethernet/chelsio/cxgb3/cxgb3_main.c
--- a/net/ethernet/chelsio/cxgb3/cxgb3_main.c
+++ b/net/ethernet/chelsio/cxgb3/cxgb3_main.c
@@ -1982,8 +1982,20 @@ static int get_eeprom(struct net_device
 		return -ENOMEM;
 
 	e->magic = EEPROM_MAGIC;
-	for (i = e->offset & ~3; !err && i < e->offset + e->len; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = e->offset & ~3; !err && i < e->offset + e->len; i += 4) {
 		err = t3_seeprom_read(adapter, i, (__le32 *) & buf[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	if (!err)
 		memcpy(data, buf + e->offset, e->len);
diff -u -p a/net/ethernet/chelsio/cxgb3/ael1002.c b/net/ethernet/chelsio/cxgb3/ael1002.c
--- a/net/ethernet/chelsio/cxgb3/ael1002.c
+++ b/net/ethernet/chelsio/cxgb3/ael1002.c
@@ -313,10 +313,22 @@ static int ael2005_setup_sr_edc(struct c
 	if (err)
 		return err;
 
-	for (i = 0; i <  EDC_OPT_AEL2005_SIZE / sizeof(u16) && !err; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i <  EDC_OPT_AEL2005_SIZE / sizeof(u16) && !err; i += 2) {
 		err = t3_mdio_write(phy, MDIO_MMD_PMAPMD,
-				    phy->phy_cache[i],
-				    phy->phy_cache[i + 1]);
+			phy->phy_cache[i],
+			phy->phy_cache[i + 1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 	if (!err)
 		phy->priv = edc_sr;
 	return err;
@@ -349,10 +361,22 @@ static int ael2005_setup_twinax_edc(stru
 	if (err)
 		return err;
 
-	for (i = 0; i <  EDC_TWX_AEL2005_SIZE / sizeof(u16) && !err; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i <  EDC_TWX_AEL2005_SIZE / sizeof(u16) && !err; i += 2) {
 		err = t3_mdio_write(phy, MDIO_MMD_PMAPMD,
-				    phy->phy_cache[i],
-				    phy->phy_cache[i + 1]);
+			phy->phy_cache[i],
+			phy->phy_cache[i + 1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 	if (!err)
 		phy->priv = edc_twinax;
 	return err;
@@ -587,10 +611,22 @@ static int ael2020_setup_twinax_edc(stru
 	if (err)
 		return err;
 
-	for (i = 0; i <  EDC_TWX_AEL2020_SIZE / sizeof(u16) && !err; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i <  EDC_TWX_AEL2020_SIZE / sizeof(u16) && !err; i += 2) {
 		err = t3_mdio_write(phy, MDIO_MMD_PMAPMD,
-				    phy->phy_cache[i],
-				    phy->phy_cache[i + 1]);
+			phy->phy_cache[i],
+			phy->phy_cache[i + 1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 	/* activate uC */
 	err = set_phy_regs(phy, uCactivate);
 	if (!err)
diff -u -p a/net/ethernet/chelsio/cxgb3/t3_hw.c b/net/ethernet/chelsio/cxgb3/t3_hw.c
--- a/net/ethernet/chelsio/cxgb3/t3_hw.c
+++ b/net/ethernet/chelsio/cxgb3/t3_hw.c
@@ -892,6 +892,11 @@ static int t3_write_flash(struct adapter
 	    (ret = sf1_write(adapter, 4, 1, val)) != 0)
 		return ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (left = n; left; left -= c) {
 		c = min(left, 4U);
 		for (val = 0, i = 0; i < c; ++i)
@@ -900,6 +905,12 @@ static int t3_write_flash(struct adapter
 		ret = sf1_write(adapter, c, c != left, val);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+		}
 	}
 	if ((ret = flash_wait_op(adapter, 5, 1)) != 0)
 		return ret;
diff -u -p a/net/ethernet/chelsio/cxgb4/sge.c b/net/ethernet/chelsio/cxgb4/sge.c
--- a/net/ethernet/chelsio/cxgb4/sge.c
+++ b/net/ethernet/chelsio/cxgb4/sge.c
@@ -1890,21 +1890,33 @@ static void sge_rx_timer_cb(unsigned lon
 	struct adapter *adap = (struct adapter *)data;
 	struct sge *s = &adap->sge;
 
-	for (i = 0; i < ARRAY_SIZE(s->starving_fl); i++)
-		for (m = s->starving_fl[i]; m; m &= m - 1) {
-			struct sge_eth_rxq *rxq;
-			unsigned int id = __ffs(m) + i * BITS_PER_LONG;
-			struct sge_fl *fl = s->egr_map[id];
-
-			clear_bit(id, s->starving_fl);
-			smp_mb__after_clear_bit();
-
-			if (fl_starving(fl)) {
-				rxq = container_of(fl, struct sge_eth_rxq, fl);
-				if (napi_reschedule(&rxq->rspq.napi))
-					fl->starving++;
-				else
+	for (i = 0; i < ARRAY_SIZE(s->starving_fl); i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (m = s->starving_fl[i]; m; m &= m - 1) {
+				struct sge_eth_rxq *rxq;
+				unsigned int id = __ffs(m) + i * BITS_PER_LONG;
+				struct sge_fl *fl = s->egr_map[id];
+
+				clear_bit(id, s->starving_fl);
+				smp_mb__after_clear_bit();
+
+				if (fl_starving(fl)) {
+					rxq = container_of(fl, struct sge_eth_rxq, fl);
+					if (napi_reschedule(&rxq->rspq.napi))
+						fl->starving++;
+					else
 					set_bit(id, s->starving_fl);
+					}
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 		}
 
@@ -1935,13 +1947,25 @@ static void sge_tx_timer_cb(unsigned lon
 	struct adapter *adap = (struct adapter *)data;
 	struct sge *s = &adap->sge;
 
-	for (i = 0; i < ARRAY_SIZE(s->txq_maperr); i++)
-		for (m = s->txq_maperr[i]; m; m &= m - 1) {
-			unsigned long id = __ffs(m) + i * BITS_PER_LONG;
-			struct sge_ofld_txq *txq = s->egr_map[id];
-
-			clear_bit(id, s->txq_maperr);
-			tasklet_schedule(&txq->qresume_tsk);
+	for (i = 0; i < ARRAY_SIZE(s->txq_maperr); i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (m = s->txq_maperr[i]; m; m &= m - 1) {
+				unsigned long id = __ffs(m) + i * BITS_PER_LONG;
+				struct sge_ofld_txq *txq = s->egr_map[id];
+
+				clear_bit(id, s->txq_maperr);
+				tasklet_schedule(&txq->qresume_tsk);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
 		}
 
 	budget = MAX_TIMER_TX_RECLAIM;
@@ -2415,8 +2439,20 @@ void t4_sge_init(struct adapter *adap)
 			 RXPKTCPLMODE |
 			 (STAT_LEN == 128 ? EGRSTATUSPAGESIZE : 0));
 
-	for (i = v = 0; i < 32; i += 4)
-		v |= (PAGE_SHIFT - 10) << i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = v = 0; i < 32; i += 4) {
+	v |= (PAGE_SHIFT - 10) << i;
+	if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
+	}
 	t4_write_reg(adap, SGE_HOST_PAGE_SIZE, v);
 	t4_write_reg(adap, SGE_FL_BUFFER_SIZE0, PAGE_SIZE);
 #if FL_PG_ORDER > 0
diff -u -p a/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/net/ethernet/chelsio/cxgb4/cxgb4_main.c
--- a/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -131,6 +131,11 @@ static unsigned int pfvfres_pmask(struct
 
 	portn = pf % adapter->params.nports;
 	portvec = adapter->params.portvec;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		/*
 		 * Isolate the lowest set bit in the port vector.  If we're at
@@ -143,6 +148,12 @@ static unsigned int pfvfres_pmask(struct
 			return pmask;
 		portn--;
 		portvec &= ~pmask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*NOTREACHED*/
 }
@@ -1321,8 +1332,20 @@ static void get_regs(struct net_device *
 	regs->version = mk_adap_vers(ap);
 
 	memset(buf, 0, T4_REGMAP_SIZE);
-	for (i = 0; i < ARRAY_SIZE(reg_ranges); i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < ARRAY_SIZE(reg_ranges); i += 2) {
 		reg_block_dump(ap, buf, reg_ranges[i], reg_ranges[i + 1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static int restart_autoneg(struct net_device *dev)
@@ -1741,8 +1764,20 @@ static int get_eeprom(struct net_device
 		return -ENOMEM;
 
 	e->magic = EEPROM_MAGIC;
-	for (i = e->offset & ~3; !err && i < e->offset + e->len; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = e->offset & ~3; !err && i < e->offset + e->len; i += 4) {
 		err = eeprom_rd_phys(adapter, i, (u32 *)&buf[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	if (!err)
 		memcpy(data, buf + e->offset, e->len);
diff -u -p a/net/ethernet/chelsio/cxgb4/t4_hw.c b/net/ethernet/chelsio/cxgb4/t4_hw.c
--- a/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -211,8 +211,20 @@ int t4_wr_mbox_meat(struct adapter *adap
 	if (v != MBOX_OWNER_DRV)
 		return v ? -EBUSY : -ETIMEDOUT;
 
-	for (i = 0; i < size; i += 8)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < size; i += 8) {
 		t4_write_reg64(adap, data_reg + i, be64_to_cpu(*p++));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	t4_write_reg(adap, ctl_reg, MBMSGVALID | MBOWNER(MBOX_OWNER_FW));
 	t4_read_reg(adap, ctl_reg);          /* flush write */
@@ -220,6 +232,11 @@ int t4_wr_mbox_meat(struct adapter *adap
 	delay_idx = 0;
 	ms = delay[0];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < FW_CMD_MAX_TIMEOUT; i += ms) {
 		if (sleep_ok) {
 			ms = delay[delay_idx];  /* last element may repeat */
@@ -248,6 +265,12 @@ int t4_wr_mbox_meat(struct adapter *adap
 			t4_write_reg(adap, ctl_reg, 0);
 			return -FW_CMD_RETVAL_GET((int)res);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dump_mbox(adap, mbox, data_reg);
@@ -585,6 +608,11 @@ static int t4_write_flash(struct adapter
 	    (ret = sf1_write(adapter, 4, 1, 1, val)) != 0)
 		goto unlock;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (left = n; left; left -= c) {
 		c = min(left, 4U);
 		for (val = 0, i = 0; i < c; ++i)
@@ -593,6 +621,12 @@ static int t4_write_flash(struct adapter
 		ret = sf1_write(adapter, c, c != left, 1, val);
 		if (ret)
 			goto unlock;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	ret = flash_wait_op(adapter, 8, 1);
 	if (ret)
diff -u -p a/net/ethernet/chelsio/cxgb4vf/sge.c b/net/ethernet/chelsio/cxgb4vf/sge.c
--- a/net/ethernet/chelsio/cxgb4vf/sge.c
+++ b/net/ethernet/chelsio/cxgb4vf/sge.c
@@ -1940,6 +1940,11 @@ static void sge_rx_timer_cb(unsigned lon
 	for (i = 0; i < ARRAY_SIZE(s->starving_fl); i++) {
 		unsigned long m;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (m = s->starving_fl[i]; m; m &= m - 1) {
 			unsigned int id = __ffs(m) + i * BITS_PER_LONG;
 			struct sge_fl *fl = s->egr_map[id];
@@ -1962,6 +1967,12 @@ static void sge_rx_timer_cb(unsigned lon
 				else
 					set_bit(id, s->starving_fl);
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
diff -u -p a/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c b/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
--- a/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
+++ b/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
@@ -156,8 +156,20 @@ int t4vf_wr_mbox_core(struct adapter *ad
 	 * Data registers before doing the write to the VF Mailbox Control
 	 * register.
 	 */
-	for (i = 0, p = cmd; i < size; i += 8)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0, p = cmd; i < size; i += 8) {
 		t4_write_reg64(adapter, mbox_data + i, be64_to_cpu(*p++));
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+			}
+	}
 	t4_read_reg(adapter, mbox_data);         /* flush write */
 
 	t4_write_reg(adapter, mbox_ctl,
@@ -170,6 +182,11 @@ int t4vf_wr_mbox_core(struct adapter *ad
 	delay_idx = 0;
 	ms = delay[0];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < FW_CMD_MAX_TIMEOUT; i += ms) {
 		if (sleep_ok) {
 			ms = delay[delay_idx];
@@ -219,6 +236,12 @@ int t4vf_wr_mbox_core(struct adapter *ad
 				     MBOWNER(MBOX_OWNER_NONE));
 			return -FW_CMD_RETVAL_GET(v);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/net/ethernet/chelsio/cxgb/subr.c b/net/ethernet/chelsio/cxgb/subr.c
--- a/net/ethernet/chelsio/cxgb/subr.c
+++ b/net/ethernet/chelsio/cxgb/subr.c
@@ -589,9 +589,21 @@ static int t1_eeprom_vpd_get(adapter_t *
 {
 	int addr, ret = 0;
 
-	for (addr = 0; !ret && addr < sizeof(*vpd); addr += sizeof(u32))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (addr = 0; !ret && addr < sizeof(*vpd); addr += sizeof(u32)) {
 		ret = t1_seeprom_read(adapter, addr,
-				      (__le32 *)((u8 *)vpd + addr));
+		(__le32 *)((u8 *)vpd + addr));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	return ret;
 }
diff -u -p a/net/ethernet/chelsio/cxgb/cxgb2.c b/net/ethernet/chelsio/cxgb/cxgb2.c
--- a/net/ethernet/chelsio/cxgb/cxgb2.c
+++ b/net/ethernet/chelsio/cxgb/cxgb2.c
@@ -783,8 +783,20 @@ static int get_eeprom(struct net_device
 	struct adapter *adapter = dev->ml_priv;
 
 	e->magic = EEPROM_MAGIC(adapter);
-	for (i = e->offset & ~3; i < e->offset + e->len; i += sizeof(u32))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = e->offset & ~3; i < e->offset + e->len; i += sizeof(u32)) {
 		t1_seeprom_read(adapter, i, (__le32 *)&buf[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	memcpy(data, buf + e->offset, e->len);
 	return 0;
 }
diff -u -p a/net/ethernet/cadence/macb.c b/net/ethernet/cadence/macb.c
--- a/net/ethernet/cadence/macb.c
+++ b/net/ethernet/cadence/macb.c
@@ -326,6 +326,11 @@ static void macb_tx(struct macb *bp)
 		bp->tx_ring[TX_RING_SIZE - 1].ctrl |= MACB_BIT(TX_WRAP);
 
 		/* free transmit buffer in upper layer*/
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (tail = bp->tx_tail; tail != head; tail = NEXT_TX(tail)) {
 			struct ring_info *rp = &bp->tx_skb[tail];
 			struct sk_buff *skb = rp->skb;
@@ -338,6 +343,12 @@ static void macb_tx(struct macb *bp)
 							 DMA_TO_DEVICE);
 			rp->skb = NULL;
 			dev_kfree_skb_irq(skb);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		bp->tx_head = bp->tx_tail = 0;
@@ -450,8 +461,20 @@ static void discard_partial_frame(struct
 {
 	unsigned int frag;
 
-	for (frag = begin; frag != end; frag = NEXT_RX(frag))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (frag = begin; frag != end; frag = NEXT_RX(frag)) {
 		bp->rx_ring[frag].addr &= ~MACB_BIT(RX_USED);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	wmb();
 
 	/*
diff -u -p a/net/ethernet/mellanox/mlx4/en_netdev.c b/net/ethernet/mellanox/mlx4/en_netdev.c
--- a/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -638,8 +638,20 @@ int mlx4_en_start_port(struct net_device
 			goto tx_err;
 		}
 		/* Set initial ownership of all Tx TXBBs to SW (1) */
-		for (j = 0; j < tx_ring->buf_size; j += STAMP_STRIDE)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (j = 0; j < tx_ring->buf_size; j += STAMP_STRIDE) {
 			*((u32 *) (tx_ring->buf + j)) = 0xffffffff;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
 		++tx_index;
 	}
 
diff -u -p a/net/ethernet/mellanox/mlx4/fw.c b/net/ethernet/mellanox/mlx4/fw.c
--- a/net/ethernet/mellanox/mlx4/fw.c
+++ b/net/ethernet/mellanox/mlx4/fw.c
@@ -487,6 +487,11 @@ int mlx4_map_cmd(struct mlx4_dev *dev, u
 	memset(mailbox->buf, 0, MLX4_MAILBOX_SIZE);
 	pages = mailbox->buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mlx4_icm_first(icm, &iter);
 	     !mlx4_icm_last(&iter);
 	     mlx4_icm_next(&iter)) {
@@ -525,6 +530,12 @@ int mlx4_map_cmd(struct mlx4_dev *dev, u
 				nent = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nent)
diff -u -p a/net/ethernet/mellanox/mlx4/icm.c b/net/ethernet/mellanox/mlx4/icm.c
--- a/net/ethernet/mellanox/mlx4/icm.c
+++ b/net/ethernet/mellanox/mlx4/icm.c
@@ -330,10 +330,21 @@ int mlx4_table_get_range(struct mlx4_dev
 	int inc = MLX4_TABLE_CHUNK_SIZE / table->obj_size;
 	int i, err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i <= end; i += inc) {
 		err = mlx4_table_get(dev, table, i);
 		if (err)
 			goto fail;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -352,8 +363,20 @@ void mlx4_table_put_range(struct mlx4_de
 {
 	int i;
 
-	for (i = start; i <= end; i += MLX4_TABLE_CHUNK_SIZE / table->obj_size)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = start; i <= end; i += MLX4_TABLE_CHUNK_SIZE / table->obj_size) {
 		mlx4_table_put(dev, table, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 int mlx4_init_icm_table(struct mlx4_dev *dev, struct mlx4_icm_table *table,
diff -u -p a/net/ethernet/ibm/ehea/ehea_qmr.c b/net/ethernet/ibm/ehea/ehea_qmr.c
--- a/net/ethernet/ibm/ehea/ehea_qmr.c
+++ b/net/ethernet/ibm/ehea/ehea_qmr.c
@@ -114,8 +114,20 @@ static void hw_queue_dtor(struct hw_queu
 
 	nr_pages = queue->queue_length / queue->pagesize;
 
-	for (i = 0; i < nr_pages; i += pages_per_kpage)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < nr_pages; i += pages_per_kpage) {
 		free_page((unsigned long)(queue->queue_pages)[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	kfree(queue->queue_pages);
 }
diff -u -p a/net/ethernet/pasemi/pasemi_mac.c b/net/ethernet/pasemi/pasemi_mac.c
--- a/net/ethernet/pasemi/pasemi_mac.c
+++ b/net/ethernet/pasemi/pasemi_mac.c
@@ -570,6 +570,11 @@ static void pasemi_mac_free_tx_resources
 	if (start > limit)
 		limit += TX_RING_SIZE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = start; i < limit; i += freed) {
 		info = &txring->ring_info[(i+1) & (TX_RING_SIZE-1)];
 		if (info->dma && info->skb) {
@@ -581,6 +586,12 @@ static void pasemi_mac_free_tx_resources
 							info->skb, dmas);
 		} else
 			freed = 2;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	kfree(txring->ring_info);
diff -u -p a/net/ethernet/tehuti/tehuti.c b/net/ethernet/tehuti/tehuti.c
--- a/net/ethernet/tehuti/tehuti.c
+++ b/net/ethernet/tehuti/tehuti.c
@@ -527,8 +527,20 @@ static int bdx_sw_reset(struct bdx_priv
 	/* 9. zero all read and write pointers */
 	for (i = regTXD_WPTR_0; i <= regTXF_RPTR_3; i += 0x10)
 		DBG("%x = %x\n", i, READ_REG(priv, i) & TXF_WPTR_WR_PTR);
-	for (i = regTXD_WPTR_0; i <= regTXF_RPTR_3; i += 0x10)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = regTXD_WPTR_0; i <= regTXF_RPTR_3; i += 0x10) {
 		WRITE_REG(priv, i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	/* 10. unseet port disable */
 	WRITE_REG(priv, regDIS_PORT, 0);
 	/* 11. unset queue disable */
diff -u -p a/net/ethernet/dec/tulip/de4x5.c b/net/ethernet/dec/tulip/de4x5.c
--- a/net/ethernet/dec/tulip/de4x5.c
+++ b/net/ethernet/dec/tulip/de4x5.c
@@ -4991,6 +4991,11 @@ mii_get_phy(struct net_device *dev)
     lp->useMII = true;
 
     /* Search the MII address space for possible PHY devices */
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     for (n=0, lp->mii_cnt=0, i=1; !((i==1) && (n==1)); i=(i+1)%DE4X5_MAX_MII) {
 	lp->phy[lp->active].addr = i;
 	if (i==0) n++;                             /* Count cycles */
@@ -5027,6 +5032,12 @@ mii_get_phy(struct net_device *dev)
 	    de4x5_debug = j;
 	    printk("\n");
 	}
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
   purgatory:
     lp->active = 0;
diff -u -p a/net/ethernet/dec/tulip/uli526x.c b/net/ethernet/dec/tulip/uli526x.c
--- a/net/ethernet/dec/tulip/uli526x.c
+++ b/net/ethernet/dec/tulip/uli526x.c
@@ -1645,12 +1645,36 @@ static void phy_write(unsigned long ioba
 	phy_write_1bit(ioaddr, PHY_DATA_1, chip_id);
 
 	/* Send Phy address */
-	for (i = 0x10; i > 0; i = i >> 1)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x10; i > 0; i = i >> 1) {
 		phy_write_1bit(ioaddr, phy_addr & i ? PHY_DATA_1 : PHY_DATA_0, chip_id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* Send register address */
-	for (i = 0x10; i > 0; i = i >> 1)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x10; i > 0; i = i >> 1) {
 		phy_write_1bit(ioaddr, offset & i ? PHY_DATA_1 : PHY_DATA_0, chip_id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* written trasnition */
 	phy_write_1bit(ioaddr, PHY_DATA_1, chip_id);
@@ -1691,12 +1715,36 @@ static u16 phy_read(unsigned long iobase
 	phy_write_1bit(ioaddr, PHY_DATA_0, chip_id);
 
 	/* Send Phy address */
-	for (i = 0x10; i > 0; i = i >> 1)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x10; i > 0; i = i >> 1) {
 		phy_write_1bit(ioaddr, phy_addr & i ? PHY_DATA_1 : PHY_DATA_0, chip_id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* Send register address */
-	for (i = 0x10; i > 0; i = i >> 1)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x10; i > 0; i = i >> 1) {
 		phy_write_1bit(ioaddr, offset & i ? PHY_DATA_1 : PHY_DATA_0, chip_id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* Skip transition state */
 	phy_read_1bit(ioaddr, chip_id);
diff -u -p a/net/ethernet/dec/tulip/dmfe.c b/net/ethernet/dec/tulip/dmfe.c
--- a/net/ethernet/dec/tulip/dmfe.c
+++ b/net/ethernet/dec/tulip/dmfe.c
@@ -1788,14 +1788,38 @@ static void phy_write(unsigned long ioba
 		phy_write_1bit(ioaddr, PHY_DATA_1);
 
 		/* Send Phy address */
-		for (i = 0x10; i > 0; i = i >> 1)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0x10; i > 0; i = i >> 1) {
 			phy_write_1bit(ioaddr,
-				       phy_addr & i ? PHY_DATA_1 : PHY_DATA_0);
+			phy_addr & i ? PHY_DATA_1 : PHY_DATA_0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 
 		/* Send register address */
-		for (i = 0x10; i > 0; i = i >> 1)
-			phy_write_1bit(ioaddr,
-				       offset & i ? PHY_DATA_1 : PHY_DATA_0);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0x10; i > 0; i = i >> 1) {
+		phy_write_1bit(ioaddr,
+				offset & i ? PHY_DATA_1 : PHY_DATA_0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+			}
 
 		/* written trasnition */
 		phy_write_1bit(ioaddr, PHY_DATA_1);
@@ -1840,14 +1864,38 @@ static u16 phy_read(unsigned long iobase
 		phy_write_1bit(ioaddr, PHY_DATA_0);
 
 		/* Send Phy address */
-		for (i = 0x10; i > 0; i = i >> 1)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0x10; i > 0; i = i >> 1) {
 			phy_write_1bit(ioaddr,
-				       phy_addr & i ? PHY_DATA_1 : PHY_DATA_0);
+			phy_addr & i ? PHY_DATA_1 : PHY_DATA_0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 
 		/* Send register address */
-		for (i = 0x10; i > 0; i = i >> 1)
-			phy_write_1bit(ioaddr,
-				       offset & i ? PHY_DATA_1 : PHY_DATA_0);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0x10; i > 0; i = i >> 1) {
+		phy_write_1bit(ioaddr,
+				offset & i ? PHY_DATA_1 : PHY_DATA_0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+			}
 
 		/* Skip transition state */
 		phy_read_1bit(ioaddr);
diff -u -p a/net/ethernet/dlink/dl2k.c b/net/ethernet/dlink/dl2k.c
--- a/net/ethernet/dlink/dl2k.c
+++ b/net/ethernet/dlink/dl2k.c
@@ -1030,8 +1030,20 @@ get_stats (struct net_device *dev)
 	readw (ioaddr + FramesWEXDeferal);
 
 #ifdef MEM_MAPPING
-	for (i = 0x100; i <= 0x150; i += 4)
-		readl (ioaddr + i);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x100; i <= 0x150; i += 4) {
+	readl (ioaddr + i);
+	if (_cur < timeout) {
+			     rdstcll(_cur);
+	}
+	else {
+			     break;
+	}
+	}
 #endif
 	readw (ioaddr + TxJumboFrames);
 	readw (ioaddr + RxJumboFrames);
@@ -1084,8 +1096,20 @@ clear_stats (struct net_device *dev)
 	readw (ioaddr + MacControlFramesXmtd);
 	readw (ioaddr + FramesWEXDeferal);
 #ifdef MEM_MAPPING
-	for (i = 0x100; i <= 0x150; i += 4)
-		readl (ioaddr + i);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0x100; i <= 0x150; i += 4) {
+	readl (ioaddr + i);
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
+	}
 #endif
 	readw (ioaddr + TxJumboFrames);
 	readw (ioaddr + RxJumboFrames);
diff -u -p a/net/irda/vlsi_ir.c b/net/irda/vlsi_ir.c
--- a/net/irda/vlsi_ir.c
+++ b/net/irda/vlsi_ir.c
@@ -692,6 +692,11 @@ static void vlsi_unarm_rx(vlsi_irda_dev_
 	struct ring_descr *rd;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = ring_first(r); rd != NULL; rd = ring_get(r)) {
 
 		ret = 0;
@@ -729,6 +734,12 @@ static void vlsi_unarm_rx(vlsi_irda_dev_
 			ndev->stats.rx_packets++;
 			ndev->stats.rx_bytes += ret;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1129,6 +1140,11 @@ static void vlsi_unarm_tx(vlsi_irda_dev_
 	struct ring_descr *rd;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (rd = ring_first(r); rd != NULL; rd = ring_get(r)) {
 
 		ret = 0;
@@ -1158,6 +1174,12 @@ static void vlsi_unarm_tx(vlsi_irda_dev_
 			ndev->stats.tx_packets++;
 			ndev->stats.tx_bytes += ret;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -1257,8 +1279,20 @@ static inline void vlsi_clear_regs(unsig
 	unsigned	i;
 	const unsigned	chip_io_extent = 32;
 
-	for (i = 0; i < chip_io_extent; i += sizeof(u16))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < chip_io_extent; i += sizeof(u16)) {
 		outw(0, iobase + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static int vlsi_init_chip(struct pci_dev *pdev)
diff -u -p a/net/appletalk/ipddp.c b/net/appletalk/ipddp.c
--- a/net/appletalk/ipddp.c
+++ b/net/appletalk/ipddp.c
@@ -254,12 +254,23 @@ static struct ipddp_route* __ipddp_find_
 {
         struct ipddp_route *f;
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for(f = ipddp_route_list; f != NULL; f = f->next)
         {
                 if(f->ip == rt->ip &&
 		   f->at.s_net == rt->at.s_net &&
 		   f->at.s_node == rt->at.s_node)
                         return f;
+                        if (_cur < timeout) {
+                        	rdstcll(_cur);
+                        }
+                        else {
+                        	break;
+                        }
         }
 
         return NULL;
diff -u -p a/net/arcnet/com90xx.c b/net/arcnet/com90xx.c
--- a/net/arcnet/com90xx.c
+++ b/net/arcnet/com90xx.c
@@ -144,14 +144,40 @@ static void __init com90xx_probe(void)
 	numports = numshmems = 0;
 	if (io)
 		ports[numports++] = io;
-	else
-		for (count = 0x200; count <= 0x3f0; count += 16)
-			ports[numports++] = count;
+	else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (count = 0x200; count <= 0x3f0; count += 16) {
+		ports[numports++] = count;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+			}
+		}
+	}
 	if (shmem)
 		shmems[numshmems++] = shmem;
-	else
-		for (count = 0xA0000; count <= 0xFF800; count += 2048)
+	else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (count = 0xA0000; count <= 0xFF800; count += 2048) {
 			shmems[numshmems++] = count;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
+		}
+	}
 
 	/* Stage 1: abandon any reserved ports, or ones with status==0xFF
 	 * (empty), and reset any others by reading the reset port.
diff -u -p a/net/arcnet/arcnet.c b/net/arcnet/arcnet.c
--- a/net/arcnet/arcnet.c
+++ b/net/arcnet/arcnet.c
@@ -249,8 +249,20 @@ static void release_arcbuf(struct net_de
 	BUGLVL(D_DURING) {
 		BUGMSG(D_DURING, "release_arcbuf: freed #%d; buffer queue is now: ",
 		       bufnum);
-		for (i = lp->next_buf; i != lp->first_free_buf; i = (i+1) % 5)
-			BUGMSG2(D_DURING, "#%d ", lp->buf_queue[i]);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = lp->next_buf; i != lp->first_free_buf; i = (i+1) % 5) {
+		BUGMSG2(D_DURING, "#%d ", lp->buf_queue[i]);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+		}
 		BUGMSG2(D_DURING, "\n");
 	}
 }
@@ -285,8 +297,20 @@ static int get_arcbuf(struct net_device
 
 	BUGLVL(D_DURING) {
 		BUGMSG(D_DURING, "get_arcbuf: got #%d; buffer queue is now: ", buf);
-		for (i = lp->next_buf; i != lp->first_free_buf; i = (i+1) % 5)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = lp->next_buf; i != lp->first_free_buf; i = (i+1) % 5) {
 			BUGMSG2(D_DURING, "#%d ", lp->buf_queue[i]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 		BUGMSG2(D_DURING, "\n");
 	}
 
diff -u -p a/net/tokenring/smctr.c b/net/tokenring/smctr.c
--- a/net/tokenring/smctr.c
+++ b/net/tokenring/smctr.c
@@ -461,8 +461,20 @@ static int smctr_checksum_firmware(struc
 
         smctr_enable_adapter_ctrl_store(dev);
 
-        for(i = 0; i < CS_RAM_SIZE; i += 2)
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        for(i = 0; i < CS_RAM_SIZE; i += 2) {
                 checksum += *((__u16 *)(tp->ram_access + i));
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
+        }
 
         tp->microcode_version = *(__u16 *)(tp->ram_access
                 + CS_RAM_VERSION_OFFSET);
@@ -1474,6 +1486,11 @@ static int smctr_hardware_send_packet(st
         if(tp->monitor_state_ready != 1)
                 return -1;
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         for(;;)
         {
                 /* Send first buffer from queue */
@@ -1507,6 +1524,12 @@ static int smctr_hardware_send_packet(st
                 tstat->tx_packets++;
 
                 smctr_disable_16bit(dev);
+                if (_cur < timeout) {
+                rdstcll(_cur);
+                }
+                else {
+                break;
+                }
         }
 
         return 0;
@@ -2999,8 +3022,20 @@ static int smctr_load_firmware(struct ne
         }
 
         /* UCODE_SIZE is not included in Checksum. */
-        for(i = 0; i < *((__u16 *)(fw->data + UCODE_SIZE_OFFSET)); i += 2)
-                checksum += *((__u16 *)(fw->data + 2 + i));
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        for(i = 0; i < *((__u16 *)(fw->data + UCODE_SIZE_OFFSET)); i += 2) {
+		checksum += *((__u16 *)(fw->data + 2 + i));
+		if (_cur < timeout) {
+                        rdstcll(_cur);
+		}
+		else {
+                        break;
+		}
+        }
         if (checksum) {
 		err = (UCODE_NOT_PRESENT);
 		goto out;
@@ -3017,8 +3052,20 @@ static int smctr_load_firmware(struct ne
                 smctr_enable_adapter_ctrl_store(dev);
 
                 /* Zero out ram space for firmware. */
-                for(i = 0; i < CS_RAM_SIZE; i += 2)
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                timeout = rdstcll(start) + delta;
+                for(i = 0; i < CS_RAM_SIZE; i += 2) {
                         *((__u16 *)(tp->ram_access + i)) = 0;
+                        if (_cur < timeout) {
+                                rdstcll(_cur);
+                        }
+                        else {
+                                break;
+                        }
+                }
 
                 smctr_decode_firmware(dev, fw);
 
@@ -3929,8 +3976,20 @@ static int smctr_ram_memory_test(struct
                         + (page * tp->ram_usable * 1024) + 1));
                 word_pattern = start_pattern;
 
-                for(j = 1; j < (__u32)(tp->ram_usable * 1024) - 1; j += 2)
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                timeout = rdstcll(start) + delta;
+                for(j = 1; j < (__u32)(tp->ram_usable * 1024) - 1; j += 2) {
                         *(__u16 *)(pword + j) = word_pattern++;
+                        if (_cur < timeout) {
+                                rdstcll(_cur);
+                        }
+                        else {
+                                break;
+                        }
+                }
 
                 word_pattern = start_pattern;
 
@@ -3956,8 +4015,20 @@ static int smctr_ram_memory_test(struct
                         + (page * tp->ram_usable * 1024)));
                 word_pattern = 0;
 
-                for(j = 0; j < (__u32)tp->ram_usable * 1024; j +=2)
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                timeout = rdstcll(start) + delta;
+                for(j = 0; j < (__u32)tp->ram_usable * 1024; j +=2) {
                         *(__u16 *)(pword + j) = word_pattern;
+                        if (_cur < timeout) {
+                                rdstcll(_cur);
+                        }
+                        else {
+                                break;
+                        }
+                }
 
                 for(j =0; j < (__u32)tp->ram_usable * 1024 && (~err); j += 2)
                 {
diff -u -p a/net/hamradio/hdlcdrv.c b/net/hamradio/hdlcdrv.c
--- a/net/hamradio/hdlcdrv.c
+++ b/net/hamradio/hdlcdrv.c
@@ -273,6 +273,11 @@ void hdlcdrv_transmitter(struct net_devi
 		return;
 	if (test_and_set_bit(0, &s->hdlctx.in_hdlc_tx))
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		if (s->hdlctx.numbits >= 16) {
 			if (hdlcdrv_hbuf_full(&s->hdlctx.hbuf)) {
@@ -357,6 +362,12 @@ void hdlcdrv_transmitter(struct net_devi
 			}
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/inftlcore.c b/mtd/inftlcore.c
--- a/mtd/inftlcore.c
+++ b/mtd/inftlcore.c
@@ -708,6 +708,11 @@ static void INFTL_trydeletechain(struct
 	 */
 	pr_debug("INFTL: deleting empty VUC %d\n", thisVUC);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		u16 *prevEUN = &inftl->VUtable[thisVUC];
 		thisEUN = *prevEUN;
@@ -747,6 +752,12 @@ static void INFTL_trydeletechain(struct
 		   requests while we're doing this -- if there's
 		   free space why should others be made to wait? */
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	inftl->VUtable[thisVUC] = BLOCK_NIL;
diff -u -p a/mtd/nand/cafe_nand.c b/mtd/nand/cafe_nand.c
--- a/mtd/nand/cafe_nand.c
+++ b/mtd/nand/cafe_nand.c
@@ -265,8 +265,20 @@ static void cafe_nand_cmdfunc(struct mtd
 	if (unlikely(regdebug)) {
 		int i;
 		printk("About to write command %08x to register 0\n", ctl1);
-		for (i=4; i< 0x5c; i+=4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i=4; i< 0x5c; i+=4) {
 			printk("Register %x: %08x\n", i, readl(cafe->mmio + i));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	}
 
 	cafe_writel(cafe, ctl1, NAND_CTRL1);
@@ -443,8 +455,20 @@ static int cafe_nand_read_page(struct mt
 		if (n < 0) {
 			dev_dbg(&cafe->pdev->dev, "Failed to correct ECC at %08x\n",
 				cafe_readl(cafe, NAND_ADDR2) * 2048);
-			for (i = 0; i < 0x5c; i += 4)
-				printk("Register %x: %08x\n", i, readl(cafe->mmio + i));
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < 0x5c; i += 4) {
+			printk("Register %x: %08x\n", i, readl(cafe->mmio + i));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+			}
 			mtd->ecc_stats.failed++;
 		} else {
 			dev_dbg(&cafe->pdev->dev, "Corrected %d symbol errors\n", n);
diff -u -p a/mtd/nand/nand_base.c b/mtd/nand/nand_base.c
--- a/mtd/nand/nand_base.c
+++ b/mtd/nand/nand_base.c
@@ -1171,8 +1171,20 @@ static int nand_read_subpage(struct mtd_
 	chip->read_buf(mtd, p, datafrag_len);
 
 	/* Calculate ECC */
-	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
 		chip->ecc.calculate(mtd, p, &chip->buffers->ecccalc[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/*
 	 * The performance is faster if we position offsets according to
@@ -1211,6 +1223,11 @@ static int nand_read_subpage(struct mtd_
 		chip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + index]];
 
 	p = bufpoi + data_col_addr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
 		int stat;
 
@@ -1220,6 +1237,12 @@ static int nand_read_subpage(struct mtd_
 			mtd->ecc_stats.failed++;
 		else
 			mtd->ecc_stats.corrected += stat;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return 0;
 }
diff -u -p a/mtd/nand/diskonchip.c b/mtd/nand/diskonchip.c
--- a/mtd/nand/diskonchip.c
+++ b/mtd/nand/diskonchip.c
@@ -1071,6 +1071,11 @@ static int __init find_media_headers(str
 	int ret;
 	size_t retlen;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offs = 0; offs < mtd->size; offs += mtd->erasesize) {
 		ret = mtd->read(mtd, offs, mtd->writesize, &retlen, buf);
 		if (retlen != mtd->writesize)
@@ -1089,6 +1094,12 @@ static int __init find_media_headers(str
 		}
 		doc->mh1_page = offs >> this->page_shift;
 		return 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (doc->mh0_page == -1) {
 		printk(KERN_WARNING "DiskOnChip %s Media Header not found.\n", id);
@@ -1586,6 +1597,11 @@ static int __init doc_probe(unsigned lon
 		goto notfound;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mtd = doclist; mtd; mtd = doc->nextdoc) {
 		unsigned char oldval;
 		unsigned char newval;
@@ -1618,6 +1634,12 @@ static int __init doc_probe(unsigned lon
 			printk(KERN_DEBUG "Found alias of DOC at 0x%lx to 0x%lx\n", doc->physadr, physadr);
 			goto notfound;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_NOTICE "DiskOnChip found at 0x%lx\n", physadr);
@@ -1702,6 +1724,11 @@ static void release_nanddoc(void)
 	struct nand_chip *nand;
 	struct doc_priv *doc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mtd = doclist; mtd; mtd = nextmtd) {
 		nand = mtd->priv;
 		doc = nand->priv;
@@ -1710,6 +1737,12 @@ static void release_nanddoc(void)
 		nand_release(mtd);
 		iounmap(doc->virtadr);
 		kfree(mtd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/nand/davinci_nand.c b/mtd/nand/davinci_nand.c
--- a/mtd/nand/davinci_nand.c
+++ b/mtd/nand/davinci_nand.c
@@ -379,6 +379,11 @@ compare:
 		cpu_relax();
 	} while ((ecc_state < 4) && time_before(jiffies, timeo));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		u32	fsr = davinci_nand_readl(info, NANDFSR_OFFSET);
 
@@ -397,6 +402,12 @@ compare:
 			cpu_relax();
 			continue;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 correct:
diff -u -p a/mtd/devices/m25p80.c b/mtd/devices/m25p80.c
--- a/mtd/devices/m25p80.c
+++ b/mtd/devices/m25p80.c
@@ -471,6 +471,11 @@ static int m25p80_write(struct mtd_info
 		*retlen = m.actual_length - m25p_cmdsz(flash);
 
 		/* write everything in flash->page_size chunks */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = page_size; i < len; i += page_size) {
 			page_size = len - i;
 			if (page_size > flash->page_size)
@@ -489,6 +494,12 @@ static int m25p80_write(struct mtd_info
 			spi_sync(flash->spi, &m);
 
 			*retlen += m.actual_length - m25p_cmdsz(flash);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/mtd/devices/sst25l.c b/mtd/devices/sst25l.c
--- a/mtd/devices/sst25l.c
+++ b/mtd/devices/sst25l.c
@@ -290,6 +290,11 @@ static int sst25l_write(struct mtd_info
 	if (ret)
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < len; i += mtd->writesize) {
 		ret = sst25l_wait_till_ready(flash);
 		if (ret)
@@ -321,7 +326,13 @@ static int sst25l_write(struct mtd_info
 			if (ret)
 				goto out;
 		}
-	}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+		}
 
 out:
 	ret = sst25l_write_enable(flash, 0);
diff -u -p a/mtd/devices/mtd_dataflash.c b/mtd/devices/mtd_dataflash.c
--- a/mtd/devices/mtd_dataflash.c
+++ b/mtd/devices/mtd_dataflash.c
@@ -130,7 +130,12 @@ static int dataflash_waitready(struct sp
 {
 	int	status;
 
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		status = dataflash_status(spi);
 		if (status < 0) {
 			pr_debug("%s: status %d?\n",
@@ -142,6 +147,12 @@ static int dataflash_waitready(struct sp
 			return status;
 
 		msleep(3);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/chips/cfi_cmdset_0020.c b/mtd/chips/cfi_cmdset_0020.c
--- a/mtd/chips/cfi_cmdset_0020.c
+++ b/mtd/chips/cfi_cmdset_0020.c
@@ -523,11 +523,22 @@ static inline int do_write_buffer(struct
 	map_write(map, CMD(len/map_bankwidth(map)-1), cmd_adr );
 
 	/* Write data */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (z = 0; z < len;
 	     z += map_bankwidth(map), buf += map_bankwidth(map)) {
 		map_word d;
 		d = map_word_load(map, buf);
 		map_write(map, d, adr+z);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* GO GO GO */
 	map_write(map, CMD(0xd0), cmd_adr);
diff -u -p a/mtd/chips/map_ram.c b/mtd/chips/map_ram.c
--- a/mtd/chips/map_ram.c
+++ b/mtd/chips/map_ram.c
@@ -123,8 +123,20 @@ static int mapram_erase (struct mtd_info
 
 	allff = map_word_ff(map);
 
-	for (i=0; i<instr->len; i += map_bankwidth(map))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i=0; i<instr->len; i += map_bankwidth(map)) {
 		map_write(map, allff, instr->addr + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	instr->state = MTD_ERASE_DONE;
 
diff -u -p a/mtd/cmdlinepart.c b/mtd/cmdlinepart.c
--- a/mtd/cmdlinepart.c
+++ b/mtd/cmdlinepart.c
@@ -326,6 +326,11 @@ static int parse_cmdline_partitions(stru
 	if (!cmdline_parsed)
 		mtdpart_setup_real(cmdline);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(part = partitions; part; part = part->next)
 	{
 		if ((!mtd_id) || (!strcmp(part->mtd_id, mtd_id)))
@@ -355,6 +360,12 @@ static int parse_cmdline_partitions(stru
 				return -ENOMEM;
 			return part->num_parts;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/mtd/redboot.c b/mtd/redboot.c
--- a/mtd/redboot.c
+++ b/mtd/redboot.c
@@ -220,11 +220,22 @@ static int parse_redboot_partitions(stru
 		nulllen = sizeof(nullstring);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tmp_fl = fl; tmp_fl->next; tmp_fl = tmp_fl->next) {
 		if (tmp_fl->img->flash_base + tmp_fl->img->size + master->erasesize <= tmp_fl->next->img->flash_base) {
 			nrparts++;
 			nulllen = sizeof(nullstring);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 #endif
 	parts = kzalloc(sizeof(*parts)*nrparts + nulllen + namelen, GFP_KERNEL);
diff -u -p a/mtd/tests/mtd_torturetest.c b/mtd/tests/mtd_torturetest.c
--- a/mtd/tests/mtd_torturetest.c
+++ b/mtd/tests/mtd_torturetest.c
@@ -447,7 +447,12 @@ static void report_corrupt(unsigned char
 	printk(PRINT_PREF "The following is a list of all differences between"
 	       " what was read from flash and what was expected\n");
 
-	for (i = 0; i < check_len; i += pgsize) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (i = 0; i < check_len; i += pgsize) {
 		cond_resched();
 		bytes = bits = 0;
 		first = countdiffs(written, read, i, pgsize, &bytes,
@@ -467,6 +472,12 @@ static void report_corrupt(unsigned char
 		len = ((first + bytes) | 0x7) + 1 - offset;
 
 		print_bufs(read, written, offset, len);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/macintosh/therm_pm72.c b/macintosh/therm_pm72.c
--- a/macintosh/therm_pm72.c
+++ b/macintosh/therm_pm72.c
@@ -368,6 +368,11 @@ static int read_smon_adc(struct cpu_pid_
 	int rc, data, tries = 0;
 	u8 buf[2];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		/* Set channel */
 		buf[0] = 1;
@@ -395,6 +400,12 @@ static int read_smon_adc(struct cpu_pid_
 			return -1;
 		}
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -403,6 +414,11 @@ static int read_lm87_reg(struct i2c_clie
 	int rc, tries = 0;
 	u8 buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		/* Set address */
 		buf = (u8)reg;
@@ -420,6 +436,12 @@ static int read_lm87_reg(struct i2c_clie
 			return -1;
 		}
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/dma/txx9dmac.c b/dma/txx9dmac.c
--- a/dma/txx9dmac.c
+++ b/dma/txx9dmac.c
@@ -771,6 +771,11 @@ txx9dmac_prep_dma_memcpy(struct dma_chan
 
 	prev = first = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < len; offset += xfer_count) {
 		xfer_count = min_t(size_t, len - offset, TXX9_DMA_MAX_COUNT);
 		/*
@@ -826,6 +831,12 @@ txx9dmac_prep_dma_memcpy(struct dma_chan
 			list_add_tail(&desc->desc_node, &first->tx_list);
 		}
 		prev = desc;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Trigger interrupt after last block */
diff -u -p a/dma/dw_dmac.c b/dma/dw_dmac.c
--- a/dma/dw_dmac.c
+++ b/dma/dw_dmac.c
@@ -648,7 +648,12 @@ dwc_prep_dma_memcpy(struct dma_chan *cha
 			| DWC_CTLL_FC_M2M;
 	prev = first = NULL;
 
-	for (offset = 0; offset < len; offset += xfer_count << src_width) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (offset = 0; offset < len; offset += xfer_count << src_width) {
 		xfer_count = min_t(size_t, (len - offset) >> src_width,
 				DWC_MAX_COUNT);
 
@@ -672,6 +677,12 @@ dwc_prep_dma_memcpy(struct dma_chan *cha
 					&first->tx_list);
 		}
 		prev = desc;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 
diff -u -p a/dma/ep93xx_dma.c b/dma/ep93xx_dma.c
--- a/dma/ep93xx_dma.c
+++ b/dma/ep93xx_dma.c
@@ -912,6 +912,11 @@ ep93xx_dma_prep_dma_memcpy(struct dma_ch
 	size_t bytes, offset;
 
 	first = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < len; offset += bytes) {
 		desc = ep93xx_dma_desc_get(edmac);
 		if (!desc) {
@@ -929,6 +934,12 @@ ep93xx_dma_prep_dma_memcpy(struct dma_ch
 			first = desc;
 		else
 			list_add_tail(&desc->node, &first->tx_list);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	first->txd.cookie = -EBUSY;
@@ -1058,6 +1069,11 @@ ep93xx_dma_prep_dma_cyclic(struct dma_ch
 
 	/* Split the buffer into period size chunks */
 	first = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < buf_len; offset += period_len) {
 		desc = ep93xx_dma_desc_get(edmac);
 		if (!desc) {
@@ -1079,6 +1095,12 @@ ep93xx_dma_prep_dma_cyclic(struct dma_ch
 			first = desc;
 		else
 			list_add_tail(&desc->node, &first->tx_list);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	first->txd.cookie = -EBUSY;
diff -u -p a/dma/at_hdmac.c b/dma/at_hdmac.c
--- a/dma/at_hdmac.c
+++ b/dma/at_hdmac.c
@@ -611,7 +611,12 @@ atc_prep_dma_memcpy(struct dma_chan *cha
 		src_width = dst_width = 0;
 	}
 
-	for (offset = 0; offset < len; offset += xfer_count << src_width) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (offset = 0; offset < len; offset += xfer_count << src_width) {
 		xfer_count = min_t(size_t, (len - offset) >> src_width,
 				ATC_BTSIZE_MAX);
 
@@ -627,6 +632,12 @@ atc_prep_dma_memcpy(struct dma_chan *cha
 		desc->txd.cookie = 0;
 
 		atc_desc_chain(&first, &prev, desc);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* First descriptor of the chain embedds additional information */
diff -u -p a/xen/xenbus/xenbus_xs.c b/xen/xenbus/xenbus_xs.c
--- a/xen/xenbus/xenbus_xs.c
+++ b/xen/xenbus/xenbus_xs.c
@@ -308,8 +308,20 @@ static unsigned int count_strings(const
 	unsigned int num;
 	const char *p;
 
-	for (p = strings, num = 0; p < strings + len; p += strlen(p) + 1)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (p = strings, num = 0; p < strings + len; p += strlen(p) + 1) {
 		num++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	return num;
 }
@@ -343,8 +355,20 @@ static char **split(char *strings, unsig
 	kfree(strings);
 
 	strings = (char *)&ret[*num];
-	for (p = strings, *num = 0; p < strings + len; p += strlen(p) + 1)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (p = strings, *num = 0; p < strings + len; p += strlen(p) + 1) {
 		ret[(*num)++] = p;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	return ret;
 }
diff -u -p a/media/video/fsl-viu.c b/media/video/fsl-viu.c
--- a/media/video/fsl-viu.c
+++ b/media/video/fsl-viu.c
@@ -347,6 +347,11 @@ static int restart_video_queue(struct vi
 	}
 
 	prev = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		if (list_empty(&vidq->queued))
 			return 0;
@@ -376,6 +381,12 @@ static int restart_video_queue(struct vi
 			return 0;
 		}
 		prev = buf;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/cx25821/cx25821-video-upstream.c b/media/video/cx25821/cx25821-video-upstream.c
--- a/media/video/cx25821/cx25821-video-upstream.c
+++ b/media/video/cx25821/cx25821-video-upstream.c
@@ -85,8 +85,20 @@ int cx25821_sram_channel_setup_upstream(
 
 	cx_write(ch->cmds_start + 20, VID_IQ_SIZE_DW);
 
-	for (i = 24; i < 80; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 24; i < 80; i += 4) {
 		cx_write(ch->cmds_start + i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* fill registers */
 	cx_write(ch->ptr1_reg, ch->fifo_start);
diff -u -p a/media/video/cx25821/cx25821-audio-upstream.c b/media/video/cx25821/cx25821-audio-upstream.c
--- a/media/video/cx25821/cx25821-audio-upstream.c
+++ b/media/video/cx25821/cx25821-audio-upstream.c
@@ -87,8 +87,20 @@ int cx25821_sram_channel_setup_upstream_
 	/* IQ size */
 	cx_write(ch->cmds_start + 20, AUDIO_IQ_SIZE_DW);
 
-	for (i = 24; i < 80; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 24; i < 80; i += 4) {
 		cx_write(ch->cmds_start + i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* fill registers */
 	cx_write(ch->ptr1_reg, ch->fifo_start);
diff -u -p a/media/video/cx25821/cx25821-core.c b/media/video/cx25821/cx25821-core.c
--- a/media/video/cx25821/cx25821-core.c
+++ b/media/video/cx25821/cx25821-core.c
@@ -520,8 +520,20 @@ int cx25821_sram_channel_setup(struct cx
 	else
 		cx_write(ch->cmds_start + 20, 64 >> 2);
 
-	for (i = 24; i < 80; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 24; i < 80; i += 4) {
 		cx_write(ch->cmds_start + i, 0);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 
 	/* fill registers */
 	cx_write(ch->ptr1_reg, ch->fifo_start);
@@ -587,8 +599,20 @@ int cx25821_sram_channel_setup_audio(str
 		cx_write(ch->cmds_start + 20, 64 >> 2);
 
 	/* zero out */
-	for (i = 24; i < 80; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 24; i < 80; i += 4) {
 		cx_write(ch->cmds_start + i, 0);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 
 	/* fill registers */
 	cx_write(ch->ptr1_reg, ch->fifo_start);
@@ -633,6 +657,11 @@ void cx25821_sram_channel_dump(struct cx
 		i += cx25821_risc_decode(risc);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (64 >> 2); i += n) {
 		risc = cx_read(ch->ctrl_start + 4 * i);
 		/* No consideration for bits 63-32 */
@@ -645,6 +674,12 @@ void cx25821_sram_channel_dump(struct cx
 			pr_warn("ctrl + 0x%2x :   iq %x: 0x%08x [ arg #%d ]\n",
 				4 * (i + j), i + j, risc, j);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_warn("        :   fifo: 0x%08x -> 0x%x\n",
@@ -700,6 +735,11 @@ void cx25821_sram_channel_dump_audio(str
 		i += cx25821_risc_decode(risc);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (64 >> 2); i += n) {
 		risc = cx_read(ch->ctrl_start + 4 * i);
 		/* No consideration for bits 63-32 */
@@ -713,6 +753,12 @@ void cx25821_sram_channel_dump_audio(str
 			pr_warn("ctrl + 0x%2x :   iq %x: 0x%08x [ arg #%d ]\n",
 				4 * (i + j), i + j, risc, j);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_warn("        :   fifo: 0x%08x -> 0x%x\n",
diff -u -p a/media/video/cx25821/cx25821-video.c b/media/video/cx25821/cx25821-video.c
--- a/media/video/cx25821/cx25821-video.c
+++ b/media/video/cx25821/cx25821-video.c
@@ -333,7 +333,12 @@ int cx25821_restart_video_queue(struct c
 	}
 
 	prev = NULL;
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		if (list_empty(&q->queued))
 			return 0;
 
@@ -358,6 +363,12 @@ int cx25821_restart_video_queue(struct c
 			return 0;
 		}
 		prev = buf;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/zoran/zoran_procfs.c b/media/video/zoran/zoran_procfs.c
--- a/media/video/zoran/zoran_procfs.c
+++ b/media/video/zoran/zoran_procfs.c
@@ -122,9 +122,21 @@ static int zoran_show(struct seq_file *p
 	int i;
 
 	seq_printf(p, "ZR36067 registers:\n");
-	for (i = 0; i < 0x130; i += 16)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 0x130; i += 16) {
 		seq_printf(p, "%03X %08X  %08X  %08X  %08X \n", i,
-			   btread(i), btread(i+4), btread(i+8), btread(i+12));
+		btread(i), btread(i+4), btread(i+8), btread(i+12));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	return 0;
 }
 
diff -u -p a/media/video/zoran/zoran_driver.c b/media/video/zoran/zoran_driver.c
--- a/media/video/zoran/zoran_driver.c
+++ b/media/video/zoran/zoran_driver.c
@@ -239,9 +239,21 @@ static int v4l_fbuffer_alloc(struct zora
 		fh->buffers.buffer[i].v4l.fbuffer = mem;
 		fh->buffers.buffer[i].v4l.fbuffer_phys = virt_to_phys(mem);
 		fh->buffers.buffer[i].v4l.fbuffer_bus = virt_to_bus(mem);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (off = 0; off < fh->buffers.buffer_size;
-		     off += PAGE_SIZE)
+		     off += PAGE_SIZE) {
 			SetPageReserved(virt_to_page(mem + off));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
 		dprintk(4,
 			KERN_INFO
 			"%s: %s - V4L frame %d mem 0x%lx (bus: 0x%llx)\n",
@@ -268,9 +280,21 @@ static void v4l_fbuffer_free(struct zora
 			continue;
 
 		mem = fh->buffers.buffer[i].v4l.fbuffer;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (off = 0; off < fh->buffers.buffer_size;
-		     off += PAGE_SIZE)
+		     off += PAGE_SIZE) {
 			ClearPageReserved(virt_to_page(mem + off));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 		kfree(fh->buffers.buffer[i].v4l.fbuffer);
 		fh->buffers.buffer[i].v4l.fbuffer = NULL;
 	}
@@ -347,8 +371,20 @@ static int jpg_fbuffer_alloc(struct zora
 				cpu_to_le32(virt_to_bus(mem));
 			fh->buffers.buffer[i].jpg.frag_tab[1] =
 				cpu_to_le32((fh->buffers.buffer_size >> 1) | 1);
-			for (off = 0; off < fh->buffers.buffer_size; off += PAGE_SIZE)
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (off = 0; off < fh->buffers.buffer_size; off += PAGE_SIZE) {
 				SetPageReserved(virt_to_page(mem + off));
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
 		} else {
 			/* jpg_bufsize is already page aligned */
 			for (j = 0; j < fh->buffers.buffer_size / PAGE_SIZE; j++) {
@@ -404,8 +440,20 @@ static void jpg_fbuffer_free(struct zora
 
 			if (frag_tab) {
 				mem = bus_to_virt(le32_to_cpu(frag_tab));
-				for (off = 0; off < fh->buffers.buffer_size; off += PAGE_SIZE)
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (off = 0; off < fh->buffers.buffer_size; off += PAGE_SIZE) {
 					ClearPageReserved(virt_to_page(mem + off));
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 				kfree(mem);
 				buffer->jpg.frag_tab[0] = 0;
 				buffer->jpg.frag_tab[1] = 0;
diff -u -p a/media/video/ivtv/ivtv-queue.c b/media/video/ivtv/ivtv-queue.c
--- a/media/video/ivtv/ivtv-queue.c
+++ b/media/video/ivtv/ivtv-queue.c
@@ -37,8 +37,20 @@ void ivtv_buf_swap(struct ivtv_buffer *b
 {
 	int i;
 
-	for (i = 0; i < buf->bytesused; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < buf->bytesused; i += 4) {
 		swab32s((u32 *)(buf->buf + i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 void ivtv_queue_init(struct ivtv_queue *q)
diff -u -p a/media/video/cx23885/cx23885-video.c b/media/video/cx23885/cx23885-video.c
--- a/media/video/cx23885/cx23885-video.c
+++ b/media/video/cx23885/cx23885-video.c
@@ -595,7 +595,12 @@ static int cx23885_restart_video_queue(s
 	}
 
 	prev = NULL;
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		if (list_empty(&q->queued))
 			return 0;
 		buf = list_entry(q->queued.next, struct cx23885_buffer,
@@ -623,6 +628,12 @@ static int cx23885_restart_video_queue(s
 			return 0;
 		}
 		prev = buf;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/cx23885/cx23885-417.c b/media/video/cx23885/cx23885-417.c
--- a/media/video/cx23885/cx23885-417.c
+++ b/media/video/cx23885/cx23885-417.c
@@ -309,6 +309,11 @@ static int mc417_wait_ready(struct cx238
 	u32 mi_ready;
 	unsigned long timeout = jiffies + msecs_to_jiffies(1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		mi_ready = cx_read(MC417_RWD) & MC417_MIRDY;
 		if (mi_ready != 0)
@@ -316,6 +321,12 @@ static int mc417_wait_ready(struct cx238
 		if (time_after(jiffies, timeout))
 			return -1;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/cx23885/cx23885-core.c b/media/video/cx23885/cx23885-core.c
--- a/media/video/cx23885/cx23885-core.c
+++ b/media/video/cx23885/cx23885-core.c
@@ -509,8 +509,20 @@ int cx23885_sram_channel_setup(struct cx
 		cx_write(ch->cmds_start + 20, 0x80000000 | (64 >> 2));
 	else
 		cx_write(ch->cmds_start + 20, 64 >> 2);
-	for (i = 24; i < 80; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 24; i < 80; i += 4) {
 		cx_write(ch->cmds_start + i, 0);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 
 	/* fill registers */
 	cx_write(ch->ptr1_reg, ch->fifo_start);
@@ -561,6 +573,11 @@ void cx23885_sram_channel_dump(struct cx
 		printk(KERN_WARNING "%s:   risc%d: ", dev->name, i);
 		cx23885_risc_decode(risc);
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < (64 >> 2); i += n) {
 		risc = cx_read(ch->ctrl_start + 4 * i);
 		/* No consideration for bits 63-32 */
@@ -573,6 +590,12 @@ void cx23885_sram_channel_dump(struct cx
 			printk(KERN_WARNING "%s:   iq %x: 0x%08x [ arg #%d ]\n",
 			       dev->name, i+j, risc, j);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_WARNING "%s: fifo: 0x%08x -> 0x%x\n",
@@ -1503,7 +1526,12 @@ int cx23885_restart_queue(struct cx23885
 
 		dprintk(5, "%s() queue is empty\n", __func__);
 
-		for (;;) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (;;) {
 			if (list_empty(&q->queued))
 				return 0;
 			buf = list_entry(q->queued.next, struct cx23885_buffer,
@@ -1534,6 +1562,12 @@ int cx23885_restart_queue(struct cx23885
 				return 0;
 			}
 			prev = buf;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		return 0;
 	}
diff -u -p a/media/video/bt8xx/bttv-risc.c b/media/video/bt8xx/bttv-risc.c
--- a/media/video/bt8xx/bttv-risc.c
+++ b/media/video/bt8xx/bttv-risc.c
@@ -183,6 +183,11 @@ bttv_risc_planar(struct bttv *btv, struc
 			break;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (todo = ybpl; todo > 0; todo -= ylen) {
 			/* go to next sg entry if needed */
 			while (yoffset && yoffset >= sg_dma_len(ysg)) {
@@ -228,6 +233,12 @@ bttv_risc_planar(struct bttv *btv, struc
 				*(rp++)=cpu_to_le32(sg_dma_address(vsg)+voffset);
 				voffset += ylen >> hshift;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		yoffset += ypadding;
 		if (chroma) {
@@ -294,6 +305,11 @@ bttv_risc_overlay(struct bttv *btv, stru
 					skips, &nskips, ov->clips, ov->nclips);
 
 		/* write out risc code */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (start = 0, skip = 0; start < ov->w.width; start = end) {
 			if (skip >= nskips) {
 				ri  = BT848_RISC_WRITE;
@@ -320,6 +336,12 @@ bttv_risc_overlay(struct bttv *btv, stru
 			*(rp++)=cpu_to_le32(ri);
 			if (0 != ra)
 				*(rp++)=cpu_to_le32(ra);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 
diff -u -p a/media/video/vino.c b/media/video/vino.c
--- a/media/video/vino.c
+++ b/media/video/vino.c
@@ -894,9 +894,20 @@ static inline int vino_fifo_has_id(struc
 {
 	unsigned int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = f->head; i == (f->tail - 1); i = (i + 1) % f->length) {
 		if (f->data[i] == id)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/media/video/bt856.c b/media/video/bt856.c
--- a/media/video/bt856.c
+++ b/media/video/bt856.c
@@ -86,8 +86,20 @@ static void bt856_dump(struct bt856 *enc
 	int i;
 
 	v4l2_info(&encoder->sd, "register dump:\n");
-	for (i = 0; i < BT856_NR_REG; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < BT856_NR_REG; i += 2) {
 		printk(KERN_CONT " %02x", encoder->reg[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	printk(KERN_CONT "\n");
 }
 
diff -u -p a/media/video/cx88/cx88-input.c b/media/video/cx88/cx88-input.c
--- a/media/video/cx88/cx88-input.c
+++ b/media/video/cx88/cx88-input.c
@@ -525,12 +525,23 @@ void cx88_ir_irq(struct cx88_core *core)
 		return;
 
 	init_ir_raw_event(&ev);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (todo = 32; todo > 0; todo -= bits) {
 		ev.pulse = samples & 0x80000000 ? false : true;
 		bits = min(todo, 32U - fls(ev.pulse ? samples : ~samples));
 		ev.duration = (bits * (NSEC_PER_SEC / 1000)) / ir_samplerate;
 		ir_raw_event_store_with_filter(ir->dev, &ev);
 		samples <<= bits;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ir_raw_event_handle(ir->dev);
 }
diff -u -p a/media/video/cx88/cx88-mpeg.c b/media/video/cx88/cx88-mpeg.c
--- a/media/video/cx88/cx88-mpeg.c
+++ b/media/video/cx88/cx88-mpeg.c
@@ -212,6 +212,11 @@ static int cx8802_restart_queue(struct c
 
 		dprintk(1, "cx8802_restart_queue: queue is empty\n" );
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (;;) {
 			if (list_empty(&q->queued))
 				return 0;
@@ -240,6 +245,12 @@ static int cx8802_restart_queue(struct c
 				return 0;
 			}
 			prev = buf;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		return 0;
 	}
diff -u -p a/media/video/cx88/cx88-core.c b/media/video/cx88/cx88-core.c
--- a/media/video/cx88/cx88-core.c
+++ b/media/video/cx88/cx88-core.c
@@ -376,8 +376,20 @@ int cx88_sram_channel_setup(struct cx88_
 	cx_write(ch->cmds_start +  8, (lines*16) >> 3);
 	cx_write(ch->cmds_start + 12, ch->ctrl_start);
 	cx_write(ch->cmds_start + 16, 64 >> 2);
-	for (i = 20; i < 64; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 20; i < 64; i += 4) {
 		cx_write(ch->cmds_start + i, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* fill registers */
 	cx_write(ch->ptr1_reg, ch->fifo_start);
@@ -464,6 +476,11 @@ void cx88_sram_channel_dump(struct cx88_
 		else
 			n = cx88_risc_decode(risc);
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < 16; i += n) {
 		risc = cx_read(ch->ctrl_start + 4 * i);
 		printk("%s:   iq %x: ", core->name, i);
@@ -473,6 +490,12 @@ void cx88_sram_channel_dump(struct cx88_
 			printk("%s:   iq %x: 0x%08x [ arg #%d ]\n",
 			       core->name, i+j, risc, j);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk("%s: fifo: 0x%08x -> 0x%x\n",
diff -u -p a/media/video/cx88/cx88-video.c b/media/video/cx88/cx88-video.c
--- a/media/video/cx88/cx88-video.c
+++ b/media/video/cx88/cx88-video.c
@@ -556,6 +556,11 @@ static int restart_video_queue(struct cx
 	}
 
 	prev = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		if (list_empty(&q->queued))
 			return 0;
@@ -582,6 +587,12 @@ static int restart_video_queue(struct cx
 			return 0;
 		}
 		prev = buf;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/cx88/cx88-blackbird.c b/media/video/cx88/cx88-blackbird.c
--- a/media/video/cx88/cx88-blackbird.c
+++ b/media/video/cx88/cx88-blackbird.c
@@ -220,6 +220,11 @@ static int wait_ready_gpio0_bit1(struct
 	u32 gpio0,need;
 
 	need = state ? 2 : 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		gpio0 = cx_read(MO_GP0_IO) & 2;
 		if (need == gpio0)
@@ -227,6 +232,12 @@ static int wait_ready_gpio0_bit1(struct
 		if (time_after(jiffies,timeout))
 			return -1;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/au0828/au0828-core.c b/media/video/au0828/au0828-core.c
--- a/media/video/au0828/au0828-core.c
+++ b/media/video/au0828/au0828-core.c
@@ -72,18 +72,30 @@ static void cmd_msg_dump(struct au0828_d
 {
 	int i;
 
-	for (i = 0; i < sizeof(dev->ctrlmsg); i += 16)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < sizeof(dev->ctrlmsg); i += 16) {
 		dprintk(2, "%s() %02x %02x %02x %02x %02x %02x %02x %02x "
-				"%02x %02x %02x %02x %02x %02x %02x %02x\n",
-			__func__,
-			dev->ctrlmsg[i+0], dev->ctrlmsg[i+1],
-			dev->ctrlmsg[i+2], dev->ctrlmsg[i+3],
-			dev->ctrlmsg[i+4], dev->ctrlmsg[i+5],
-			dev->ctrlmsg[i+6], dev->ctrlmsg[i+7],
-			dev->ctrlmsg[i+8], dev->ctrlmsg[i+9],
-			dev->ctrlmsg[i+10], dev->ctrlmsg[i+11],
-			dev->ctrlmsg[i+12], dev->ctrlmsg[i+13],
-			dev->ctrlmsg[i+14], dev->ctrlmsg[i+15]);
+		"%02x %02x %02x %02x %02x %02x %02x %02x\n",
+		__func__,
+		dev->ctrlmsg[i+0], dev->ctrlmsg[i+1],
+		dev->ctrlmsg[i+2], dev->ctrlmsg[i+3],
+		dev->ctrlmsg[i+4], dev->ctrlmsg[i+5],
+		dev->ctrlmsg[i+6], dev->ctrlmsg[i+7],
+		dev->ctrlmsg[i+8], dev->ctrlmsg[i+9],
+		dev->ctrlmsg[i+10], dev->ctrlmsg[i+11],
+		dev->ctrlmsg[i+12], dev->ctrlmsg[i+13],
+		dev->ctrlmsg[i+14], dev->ctrlmsg[i+15]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static int send_control_msg(struct au0828_dev *dev, u16 request, u32 value,
diff -u -p a/media/video/au0828/au0828-video.c b/media/video/au0828/au0828-video.c
--- a/media/video/au0828/au0828-video.c
+++ b/media/video/au0828/au0828-video.c
@@ -474,8 +474,20 @@ static void au0828_copy_vbi(struct au082
 	if (buf->top_field == 0)
 		startwrite += bytesperline * dev->vbi_height;
 
-	for (i = 0; i < len; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < len; i += 2) {
 		startwrite[j++] = startread[i+1];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	dma_q->pos += len;
 }
diff -u -p a/media/video/saa7164/saa7164-fw.c b/media/video/saa7164/saa7164-fw.c
--- a/media/video/saa7164/saa7164-fw.c
+++ b/media/video/saa7164/saa7164-fw.c
@@ -132,6 +132,11 @@ int saa7164_downloadimage(struct saa7164
 		goto out;
 
 	/* Deal with the raw firmware, in the appropriate chunk size */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; srcsize > dstsize;
 		srcsize -= dstsize, offset += dstsize) {
 
@@ -150,6 +155,12 @@ int saa7164_downloadimage(struct saa7164
 		if (ret < 0)
 			goto out;
 
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	dprintk(DBGLVL_FW, "%s() memcpy(l) %d\n", __func__, dstsize);
diff -u -p a/media/video/saa7164/saa7164-core.c b/media/video/saa7164/saa7164-core.c
--- a/media/video/saa7164/saa7164-core.c
+++ b/media/video/saa7164/saa7164-core.c
@@ -784,14 +784,26 @@ void saa7164_dumphex16(struct saa7164_de
 	printk(KERN_INFO "--------------------> "
 		"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n");
 
-	for (i = 0; i < len; i += 16)
-		printk(KERN_INFO "         [0x%08x] "
-			"%02x %02x %02x %02x %02x %02x %02x %02x "
-			"%02x %02x %02x %02x %02x %02x %02x %02x\n", i,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < len; i += 16) {
+	printk(KERN_INFO "         [0x%08x] "
+		"%02x %02x %02x %02x %02x %02x %02x %02x "
+		"%02x %02x %02x %02x %02x %02x %02x %02x\n", i,
 		*(buf+i+0), *(buf+i+1), *(buf+i+2), *(buf+i+3),
 		*(buf+i+4), *(buf+i+5), *(buf+i+6), *(buf+i+7),
 		*(buf+i+8), *(buf+i+9), *(buf+i+10), *(buf+i+11),
 		*(buf+i+12), *(buf+i+13), *(buf+i+14), *(buf+i+15));
+	if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
+	}
 }
 
 /* TODO: Debugging func, remove */
@@ -802,27 +814,39 @@ void saa7164_dumpregs(struct saa7164_dev
 	dprintk(1, "--------------------> "
 		"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n");
 
-	for (i = 0; i < 0x100; i += 16)
-		dprintk(1, "region0[0x%08x] = "
-			"%02x %02x %02x %02x %02x %02x %02x %02x"
-			" %02x %02x %02x %02x %02x %02x %02x %02x\n", i,
-			(u8)saa7164_readb(addr + i + 0),
-			(u8)saa7164_readb(addr + i + 1),
-			(u8)saa7164_readb(addr + i + 2),
-			(u8)saa7164_readb(addr + i + 3),
-			(u8)saa7164_readb(addr + i + 4),
-			(u8)saa7164_readb(addr + i + 5),
-			(u8)saa7164_readb(addr + i + 6),
-			(u8)saa7164_readb(addr + i + 7),
-			(u8)saa7164_readb(addr + i + 8),
-			(u8)saa7164_readb(addr + i + 9),
-			(u8)saa7164_readb(addr + i + 10),
-			(u8)saa7164_readb(addr + i + 11),
-			(u8)saa7164_readb(addr + i + 12),
-			(u8)saa7164_readb(addr + i + 13),
-			(u8)saa7164_readb(addr + i + 14),
-			(u8)saa7164_readb(addr + i + 15)
-			);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 0x100; i += 16) {
+	dprintk(1, "region0[0x%08x] = "
+		"%02x %02x %02x %02x %02x %02x %02x %02x"
+		" %02x %02x %02x %02x %02x %02x %02x %02x\n", i,
+		(u8)saa7164_readb(addr + i + 0),
+		(u8)saa7164_readb(addr + i + 1),
+		(u8)saa7164_readb(addr + i + 2),
+		(u8)saa7164_readb(addr + i + 3),
+		(u8)saa7164_readb(addr + i + 4),
+		(u8)saa7164_readb(addr + i + 5),
+		(u8)saa7164_readb(addr + i + 6),
+		(u8)saa7164_readb(addr + i + 7),
+		(u8)saa7164_readb(addr + i + 8),
+		(u8)saa7164_readb(addr + i + 9),
+		(u8)saa7164_readb(addr + i + 10),
+		(u8)saa7164_readb(addr + i + 11),
+		(u8)saa7164_readb(addr + i + 12),
+		(u8)saa7164_readb(addr + i + 13),
+		(u8)saa7164_readb(addr + i + 14),
+		(u8)saa7164_readb(addr + i + 15)
+		);
+	if (_cur < timeout) {
+		rdstcll(_cur);
+	}
+	else {
+		break;
+	}
+	}
 }
 
 static void saa7164_dump_hwdesc(struct saa7164_dev *dev)
diff -u -p a/media/video/usbvision/usbvision-core.c b/media/video/usbvision/usbvision-core.c
--- a/media/video/usbvision/usbvision-core.c
+++ b/media/video/usbvision/usbvision-core.c
@@ -516,6 +516,11 @@ static enum parse_state usbvision_parse_
 	clipmask_index = frame->curline * MAX_FRAME_WIDTH;
 	clipmask_add = usbvision->stretch_width;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < frame->frmwidth; i += (2 * usbvision->stretch_width)) {
 		scratch_get(usbvision, &yuyv[0], 4);
 
@@ -586,6 +591,12 @@ static enum parse_state usbvision_parse_
 		}
 		clipmask_index += clipmask_add;
 		f += stretch_bytes;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	frame->curline += usbvision->stretch_height;
diff -u -p a/media/video/davinci/dm644x_ccdc.c b/media/video/davinci/dm644x_ccdc.c
--- a/media/video/davinci/dm644x_ccdc.c
+++ b/media/video/davinci/dm644x_ccdc.c
@@ -326,8 +326,20 @@ static void ccdc_restore_defaults(void)
 	/* disable CCDC */
 	ccdc_enable(0);
 	/* set all registers to default value */
-	for (i = 4; i <= 0x94; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 4; i <= 0x94; i += 4) {
 		regw(0,  i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	regw(CCDC_NO_CULLING, CCDC_CULLING);
 	regw(CCDC_GAMMA_BITS_11_2, CCDC_ALAW);
 }
diff -u -p a/media/video/davinci/dm355_ccdc.c b/media/video/davinci/dm355_ccdc.c
--- a/media/video/davinci/dm355_ccdc.c
+++ b/media/video/davinci/dm355_ccdc.c
@@ -178,8 +178,20 @@ static int ccdc_restore_defaults(void)
 
 	dev_dbg(ccdc_cfg.dev, "\nstarting ccdc_restore_defaults...");
 	/* set all registers to zero */
-	for (i = 0; i <= CCDC_REG_LAST; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i <= CCDC_REG_LAST; i += 4) {
 		regw(0, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* now override the values with power on defaults in registers */
 	regw(MODESET_DEFAULT, MODESET);
diff -u -p a/media/video/tm6000/tm6000-video.c b/media/video/tm6000/tm6000-video.c
--- a/media/video/tm6000/tm6000-video.c
+++ b/media/video/tm6000/tm6000-video.c
@@ -334,8 +334,20 @@ static int copy_streams(u8 *data, unsign
 				break;
 			case TM6000_URB_MSG_AUDIO: {
 				int i;
-				for (i = 0; i < cpysize; i += 2)
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				for (i = 0; i < cpysize; i += 2) {
 					swab16s((u16 *)(ptr + i));
+					if (_cur < timeout) {
+				rdstcll(_cur);
+					}
+					else {
+				break;
+					}
+				}
 
 				tm6000_call_fillbuf(dev, TM6000_AUDIO, ptr, cpysize);
 				break;
diff -u -p a/media/video/bt866.c b/media/video/bt866.c
--- a/media/video/bt866.c
+++ b/media/video/bt866.c
@@ -132,8 +132,20 @@ static int bt866_s_routing(struct v4l2_s
 	u8 val;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(init) / 2; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < ARRAY_SIZE(init) / 2; i += 2) {
 		bt866_write(encoder, init[i], init[i+1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	val = encoder->reg[0xdc];
 
diff -u -p a/media/video/gspca/vc032x.c b/media/video/gspca/vc032x.c
--- a/media/video/gspca/vc032x.c
+++ b/media/video/gspca/vc032x.c
@@ -3368,6 +3368,11 @@ static void usb_exchange(struct gspca_de
 {
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		switch (data[i][3]) {
 		default:
@@ -3387,6 +3392,12 @@ static void usb_exchange(struct gspca_de
 			break;
 		}
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*not reached*/
 }
diff -u -p a/media/video/gspca/pac7302.c b/media/video/gspca/pac7302.c
--- a/media/video/gspca/pac7302.c
+++ b/media/video/gspca/pac7302.c
@@ -483,7 +483,12 @@ static void reg_w_var(struct gspca_dev *
 {
 	int index, len;
 
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		index = *seq++;
 		len = *seq++;
 		switch (len) {
@@ -511,6 +516,12 @@ static void reg_w_var(struct gspca_dev *
 				len -= 8;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* not reached */
 }
diff -u -p a/media/video/gspca/pac7311.c b/media/video/gspca/pac7311.c
--- a/media/video/gspca/pac7311.c
+++ b/media/video/gspca/pac7311.c
@@ -351,7 +351,12 @@ static void reg_w_var(struct gspca_dev *
 {
 	int index, len;
 
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		index = *seq++;
 		len = *seq++;
 		switch (len) {
@@ -379,6 +384,12 @@ static void reg_w_var(struct gspca_dev *
 				len -= 8;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* not reached */
 }
diff -u -p a/media/video/cx18/cx18-queue.c b/media/video/cx18/cx18-queue.c
--- a/media/video/cx18/cx18-queue.c
+++ b/media/video/cx18/cx18-queue.c
@@ -32,8 +32,20 @@ void cx18_buf_swap(struct cx18_buffer *b
 {
 	int i;
 
-	for (i = 0; i < buf->bytesused; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < buf->bytesused; i += 4) {
 		swab32s((u32 *)(buf->buf + i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 void _cx18_mdl_swap(struct cx18_mdl *mdl)
@@ -289,6 +301,11 @@ void cx18_load_queues(struct cx18_stream
 	 * Excess buffers are left in buf_pool and/or on an MDL in q_idle
 	 */
 	mdl_id = s->mdl_base_idx;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (mdl = cx18_dequeue(s, &s->q_idle), i = s->bufs_per_mdl;
 	     mdl != NULL && i == s->bufs_per_mdl;
 	     mdl = cx18_dequeue(s, &s->q_idle)) {
@@ -329,6 +346,12 @@ void cx18_load_queues(struct cx18_stream
 			cx18_push(s, mdl, &s->q_idle);
 		}
 		mdl_id += i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/pvrusb2/pvrusb2-sysfs.c b/media/video/pvrusb2/pvrusb2-sysfs.c
--- a/media/video/pvrusb2/pvrusb2-sysfs.c
+++ b/media/video/pvrusb2/pvrusb2-sysfs.c
@@ -491,6 +491,11 @@ static void pvr2_sysfs_add_controls(stru
 static void pvr2_sysfs_tear_down_controls(struct pvr2_sysfs *sfp)
 {
 	struct pvr2_sysfs_ctl_item *cip1,*cip2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cip1 = sfp->item_first; cip1; cip1 = cip2) {
 		cip2 = cip1->item_next;
 		if (cip1->created_ok) {
@@ -498,6 +503,12 @@ static void pvr2_sysfs_tear_down_control
 		}
 		pvr2_sysfs_trace("Destroying pvr2_sysfs_ctl_item id=%p",cip1);
 		kfree(cip1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/pvrusb2/pvrusb2-hdw.c b/media/video/pvrusb2/pvrusb2-hdw.c
--- a/media/video/pvrusb2/pvrusb2-hdw.c
+++ b/media/video/pvrusb2/pvrusb2-hdw.c
@@ -3533,6 +3533,11 @@ static u8 *pvr2_full_eeprom_fetch(struct
 	   getting the whole thing our I2C driver can't grab it in one
 	   pass - which is what tveeprom is otherwise going to attempt */
 	memset(eeprom,0,EEPROM_SIZE);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tcnt = 0; tcnt < EEPROM_SIZE; tcnt += pcnt) {
 		pcnt = 16;
 		if (pcnt + tcnt > EEPROM_SIZE) pcnt = EEPROM_SIZE-tcnt;
@@ -3552,6 +3557,12 @@ static u8 *pvr2_full_eeprom_fetch(struct
 			kfree(eeprom);
 			return NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return eeprom;
 }
diff -u -p a/media/video/pvrusb2/pvrusb2-eeprom.c b/media/video/pvrusb2/pvrusb2-eeprom.c
--- a/media/video/pvrusb2/pvrusb2-eeprom.c
+++ b/media/video/pvrusb2/pvrusb2-eeprom.c
@@ -90,6 +90,11 @@ static u8 *pvr2_eeprom_fetch(struct pvr2
 	   getting the whole thing our I2C driver can't grab it in one
 	   pass - which is what tveeprom is otherwise going to attempt */
 	memset(eeprom,0,EEPROM_SIZE);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (tcnt = 0; tcnt < EEPROM_SIZE; tcnt += pcnt) {
 		pcnt = 16;
 		if (pcnt + tcnt > EEPROM_SIZE) pcnt = EEPROM_SIZE-tcnt;
@@ -109,6 +114,12 @@ static u8 *pvr2_eeprom_fetch(struct pvr2
 			kfree(eeprom);
 			return NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return eeprom;
 }
diff -u -p a/media/video/pvrusb2/pvrusb2-context.c b/media/video/pvrusb2/pvrusb2-context.c
--- a/media/video/pvrusb2/pvrusb2-context.c
+++ b/media/video/pvrusb2/pvrusb2-context.c
@@ -140,9 +140,20 @@ static void pvr2_context_check(struct pv
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (ch1 = mp->mc_first; ch1; ch1 = ch2) {
 		ch2 = ch1->mc_next;
 		if (ch1->check_func) ch1->check_func(ch1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (mp->disconnect_flag && !mp->mc_first) {
@@ -251,9 +262,20 @@ static void pvr2_context_reset_input_lim
 	struct pvr2_hdw *hdw = mp->hdw;
 	mmsk = pvr2_hdw_get_input_available(hdw);
 	tmsk = mmsk;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cp = mp->mc_first; cp; cp = cp->mc_next) {
 		if (!cp->input_mask) continue;
 		tmsk &= cp->input_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	pvr2_hdw_set_input_allowed(hdw,mmsk,tmsk);
 	pvr2_hdw_commit_ctl(hdw);
@@ -355,10 +377,21 @@ int pvr2_channel_limit_inputs(struct pvr
 			break;
 		}
 		tmsk = mmsk;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (p2 = cp->mc_head->mc_first; p2; p2 = p2->mc_next) {
 			if (p2 == cp) continue;
 			if (!p2->input_mask) continue;
 			tmsk &= p2->input_mask;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!(tmsk & cmsk)) {
 			ret = -EPERM;
diff -u -p a/media/dvb/siano/smscoreapi.c b/media/dvb/siano/smscoreapi.c
--- a/media/dvb/siano/smscoreapi.c
+++ b/media/dvb/siano/smscoreapi.c
@@ -107,6 +107,11 @@ static struct smscore_registry_entry_t *
 	struct list_head *next;
 
 	kmutex_lock(&g_smscore_registrylock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (next = g_smscore_registry.next;
 	     next != &g_smscore_registry;
 	     next = next->next) {
@@ -115,6 +120,12 @@ static struct smscore_registry_entry_t *
 			kmutex_unlock(&g_smscore_registrylock);
 			return entry;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	entry = kmalloc(sizeof(struct smscore_registry_entry_t), GFP_KERNEL);
 	if (entry) {
@@ -211,12 +222,23 @@ int smscore_register_hotplug(hotplug_t h
 	if (notifyee) {
 		/* now notify callback about existing devices */
 		first = &g_smscore_devices;
-		for (next = first->next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (next = first->next;
 		     next != first && !rc;
 		     next = next->next) {
 			struct smscore_device_t *coredev =
 				(struct smscore_device_t *) next;
 			rc = hotplug(coredev, coredev->device, 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (rc >= 0) {
@@ -948,6 +970,11 @@ smscore_client_t *smscore_find_client(st
 
 	spin_lock_irqsave(&coredev->clientslock, flags);
 	first = &coredev->clients;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (next = first->next;
 	     (next != first) && !client;
 	     next = next->next) {
@@ -962,6 +989,12 @@ smscore_client_t *smscore_find_client(st
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&coredev->clientslock, flags);
 	return client;
diff -u -p a/media/dvb/ttusb-budget/dvb-ttusb-budget.c b/media/dvb/ttusb-budget/dvb-ttusb-budget.c
--- a/media/dvb/ttusb-budget/dvb-ttusb-budget.c
+++ b/media/dvb/ttusb-budget/dvb-ttusb-budget.c
@@ -561,8 +561,20 @@ static void ttusb_process_muxpack(struct
 {
 	u16 csum = 0, cc;
 	int i;
-	for (i = 0; i < len; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < len; i += 2) {
 		csum ^= le16_to_cpup((__le16 *) (muxpack + i));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	if (csum) {
 		printk("%s: muxpack with incorrect checksum, ignoring\n",
 		       __func__);
diff -u -p a/media/dvb/ttpci/av7110_hw.c b/media/dvb/ttpci/av7110_hw.c
--- a/media/dvb/ttpci/av7110_hw.c
+++ b/media/dvb/ttpci/av7110_hw.c
@@ -232,8 +232,20 @@ int av7110_bootarm(struct av7110 *av7110
 		       ret, 0x10325476);
 		return -1;
 	}
-	for (i = 0; i < 8192; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 8192; i += 4) {
 		iwdebi(av7110, DEBISWAP, DPRAM_BASE + i, 0x00, 4);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 	dprintk(2, "debi test OK\n");
 
 	/* boot */
diff -u -p a/media/dvb/dvb-usb/lmedm04.c b/media/dvb/dvb-usb/lmedm04.c
--- a/media/dvb/dvb-usb/lmedm04.c
+++ b/media/dvb/dvb-usb/lmedm04.c
@@ -718,6 +718,11 @@ static int lme2510_download_firmware(str
 	for (i = 1; i < 3; i++) {
 		start = (i == 1) ? 0 : 512;
 		end = (i == 1) ? 512 : fw->size;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (j = start; j < end; j += (packet_size+1)) {
 			fw_data = (u8 *)(fw->data + j);
 			if ((end - j) > packet_size) {
@@ -736,6 +741,12 @@ static int lme2510_download_firmware(str
 			ret |= lme2510_bulk_write(dev, data,  wlen, 1);
 			ret |= lme2510_bulk_read(dev, data, len_in , 1);
 			ret |= (data[0] == 0x88) ? 0 : -1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
diff -u -p a/media/dvb/dvb-usb/digitv.c b/media/dvb/dvb-usb/digitv.c
--- a/media/dvb/dvb-usb/digitv.c
+++ b/media/dvb/dvb-usb/digitv.c
@@ -103,13 +103,37 @@ static int digitv_mt352_demod_init(struc
 			0x75, 0x32 };
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(reset_buf); i += 2)
-		mt352_write(fe, &reset_buf[i], 2);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < ARRAY_SIZE(reset_buf); i += 2) {
+	mt352_write(fe, &reset_buf[i], 2);
+	if (_cur < timeout) {
+			rdstcll(_cur);
+	}
+	else {
+			break;
+	}
+	}
 
 	msleep(1);
 
-	for (i = 0; i < ARRAY_SIZE(init_buf); i += 2)
-		mt352_write(fe, &init_buf[i], 2);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < ARRAY_SIZE(init_buf); i += 2) {
+	mt352_write(fe, &init_buf[i], 2);
+	if (_cur < timeout) {
+			rdstcll(_cur);
+	}
+	else {
+			break;
+	}
+	}
 
 	return 0;
 }
diff -u -p a/media/dvb/dvb-usb/it913x.c b/media/dvb/dvb-usb/it913x.c
--- a/media/dvb/dvb-usb/it913x.c
+++ b/media/dvb/dvb-usb/it913x.c
@@ -444,6 +444,11 @@ static int it913x_download_firmware(stru
 	/* This uses scatter write firmware headers follow */
 	/* 03 XX 00     XX = chip number? */ 
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = 0; i < fw->size; i += packet_size) {
 			if (i > 0)
 				packet_size = 0x39;
@@ -453,6 +458,12 @@ static int it913x_download_firmware(stru
 			ret |= it913x_io(udev, WRITE_DATA, DEV_0,
 				CMD_SCATTER_WRITE, 0, 0, fw_data, dlen);
 			udelay(1000);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	ret |= it913x_io(udev, WRITE_CMD, DEV_0,
diff -u -p a/media/dvb/ttusb-dec/ttusb_dec.c b/media/dvb/ttusb-dec/ttusb_dec.c
--- a/media/dvb/ttusb-dec/ttusb_dec.c
+++ b/media/dvb/ttusb-dec/ttusb_dec.c
@@ -552,8 +552,20 @@ static void ttusb_dec_process_packet(str
 		return;
 	}
 
-	for (i = 0; i < dec->packet_length; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < dec->packet_length; i += 2) {
 		csum ^= ((dec->packet[i] << 8) + dec->packet[i + 1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	if (csum) {
 		printk("%s: checksum failed - discarding\n", __func__);
diff -u -p a/media/dvb/firewire/firedtv-fw.c b/media/dvb/firewire/firedtv-fw.c
--- a/media/dvb/firewire/firedtv-fw.c
+++ b/media/dvb/firewire/firedtv-fw.c
@@ -115,9 +115,21 @@ static void handle_iso(struct fw_iso_con
 				+ (i % PACKETS_PER_PAGE) * MAX_PACKET_SIZE;
 		p_end = p + length;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (p += CIP_HEADER_SIZE + MPEG2_TS_HEADER_SIZE; p < p_end;
-		     p += MPEG2_TS_SOURCE_PACKET_SIZE)
-			dvb_dmx_swfilter_packets(&fdtv->demux, p, 1);
+		     p += MPEG2_TS_SOURCE_PACKET_SIZE) {
+				dvb_dmx_swfilter_packets(&fdtv->demux, p, 1);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
+			}
 
 		err = queue_iso(ctx, i);
 		if (unlikely(err))
diff -u -p a/media/dvb/frontends/stv0297.c b/media/dvb/frontends/stv0297.c
--- a/media/dvb/frontends/stv0297.c
+++ b/media/dvb/frontends/stv0297.c
@@ -307,8 +307,20 @@ static int stv0297_init(struct dvb_front
 	int i;
 
 	/* load init table */
-	for (i=0; !(state->config->inittab[i] == 0xff && state->config->inittab[i+1] == 0xff); i+=2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i=0; !(state->config->inittab[i] == 0xff && state->config->inittab[i+1] == 0xff); i+=2) {
 		stv0297_writereg(state, state->config->inittab[i], state->config->inittab[i+1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	msleep(200);
 
 	state->last_ber = 0;
diff -u -p a/media/dvb/frontends/cx24116.c b/media/dvb/frontends/cx24116.c
--- a/media/dvb/frontends/cx24116.c
+++ b/media/dvb/frontends/cx24116.c
@@ -610,6 +610,11 @@ static int cx24116_load_firmware(struct
 	else
 		max = INT_MAX; /* enough for 32k firmware */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (remaining = fw->size; remaining > 0; remaining -= max - 1) {
 		len = remaining;
 		if (len > max - 1)
@@ -617,6 +622,12 @@ static int cx24116_load_firmware(struct
 
 		cx24116_writeregN(state, 0xF7, &fw->data[fw->size - remaining],
 			len);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	cx24116_writereg(state, 0xF4, 0x10);
diff -u -p a/media/dvb/frontends/dib9000.c b/media/dvb/frontends/dib9000.c
--- a/media/dvb/frontends/dib9000.c
+++ b/media/dvb/frontends/dib9000.c
@@ -1036,8 +1036,20 @@ static int dib9000_risc_apb_access_write
 	/* dprintk( "APB access thru wr fw %d %x", address, attribute); */
 
 	mb[0] = (unsigned short)address;
-	for (i = 0; i < len && i < 20; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < len && i < 20; i += 2) {
 		mb[1 + (i / 2)] = (b[i] << 8 | b[i + 1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	dib9000_mbx_send_attr(state, OUT_MSG_BRIDGE_APB_W, mb, 1 + len / 2, attribute);
 	return dib9000_mbx_get_message_attr(state, IN_MSG_END_BRIDGE_APB_RW, mb, &s, attribute) == 1 ? 0 : -EINVAL;
@@ -1606,8 +1618,20 @@ static int dib9000_tuner_xfer(struct i2c
 			if (len > 16)
 				len = 16;
 
-			for (i = 0; i < len; i += 2)
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (i = 0; i < len; i += 2) {
 				dib9000_write_word(state, 785, (msg[index_msg].buf[i] << 8) | msg[index_msg].buf[i + 1]);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
 			dib9000_write_word(state, 784, (u16) msg[index_msg].addr);
 			dib9000_write_word(state, 787, (len / 2) - 1);
 			dib9000_write_word(state, 786, 0);	/* start write */
diff -u -p a/media/dvb/frontends/tda10071.c b/media/dvb/frontends/tda10071.c
--- a/media/dvb/frontends/tda10071.c
+++ b/media/dvb/frontends/tda10071.c
@@ -971,6 +971,11 @@ static int tda10071_init(struct dvb_fron
 		/* do not download last byte */
 		fw_size = fw->size - 1;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (remaining = fw_size; remaining > 0;
 			remaining -= (priv->cfg.i2c_wr_max - 1)) {
 			len = remaining;
@@ -984,6 +989,12 @@ static int tda10071_init(struct dvb_fron
 				if (ret)
 					goto error_release_firmware;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		release_firmware(fw);
 
diff -u -p a/media/dvb/frontends/cx22702.c b/media/dvb/frontends/cx22702.c
--- a/media/dvb/frontends/cx22702.c
+++ b/media/dvb/frontends/cx22702.c
@@ -441,8 +441,20 @@ static int cx22702_init(struct dvb_front
 
 	msleep(10);
 
-	for (i = 0; i < ARRAY_SIZE(init_tab); i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < ARRAY_SIZE(init_tab); i += 2) {
 		cx22702_writereg(state, init_tab[i], init_tab[i + 1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	cx22702_writereg(state, 0xf8, (state->config->output_mode << 1)
 		& 0x02);
diff -u -p a/media/dvb/frontends/stv0288.c b/media/dvb/frontends/stv0288.c
--- a/media/dvb/frontends/stv0288.c
+++ b/media/dvb/frontends/stv0288.c
@@ -345,10 +345,22 @@ static int stv0288_init(struct dvb_front
 
 	/* we have default inittab */
 	if (state->config->inittab == NULL) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (i = 0; !(stv0288_inittab[i] == 0xff &&
-				stv0288_inittab[i + 1] == 0xff); i += 2)
+				stv0288_inittab[i + 1] == 0xff); i += 2) {
 			stv0288_writeregI(state, stv0288_inittab[i],
-					stv0288_inittab[i + 1]);
+			stv0288_inittab[i + 1]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 	} else {
 		for (i = 0; ; i += 2)  {
 			reg = state->config->inittab[i];
diff -u -p a/media/dvb/frontends/it913x-fe.c b/media/dvb/frontends/it913x-fe.c
--- a/media/dvb/frontends/it913x-fe.c
+++ b/media/dvb/frontends/it913x-fe.c
@@ -430,8 +430,20 @@ static int it913x_fe_select_bw(struct it
 	/* start at COEFF_1_2048 and write through to fftinx_bfsfcw_ratio*/
 	ret = it913x_write(state, PRO_DMOD, COEFF_1_2048, buffer, count);
 
-	for (i = 0; i < 42; i += 8)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < 42; i += 8) {
 		debug_data_snipet(0x1, "Buffer", &buffer[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	return ret;
 }
diff -u -p a/media/dvb/frontends/cx22700.c b/media/dvb/frontends/cx22700.c
--- a/media/dvb/frontends/cx22700.c
+++ b/media/dvb/frontends/cx22700.c
@@ -240,8 +240,20 @@ static int cx22700_init (struct dvb_fron
 
 	msleep(10);
 
-	for (i=0; i<sizeof(init_tab); i+=2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i=0; i<sizeof(init_tab); i+=2) {
 		cx22700_writereg (state, init_tab[i], init_tab[i+1]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	cx22700_writereg (state, 0x00, 0x01);
 
diff -u -p a/media/radio/si4713-i2c.c b/media/radio/si4713-i2c.c
--- a/media/radio/si4713-i2c.c
+++ b/media/radio/si4713-i2c.c
@@ -824,11 +824,22 @@ static int si4713_set_rds_ps_name(struct
 
 	if (sdev->power_state) {
 		/* Write the new ps name and clear the padding */
-		for (i = 0; i < MAX_RDS_PS_NAME; i += (RDS_BLOCK / 2)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			for (i = 0; i < MAX_RDS_PS_NAME; i += (RDS_BLOCK / 2)) {
 			rval = si4713_tx_rds_ps(sdev, (i / (RDS_BLOCK / 2)),
 						ps_name + i);
 			if (rval < 0)
 				goto unlock;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Setup the size to be sent */
diff -u -p a/gpio/gpio-msm-v2.c b/gpio/gpio-msm-v2.c
--- a/gpio/gpio-msm-v2.c
+++ b/gpio/gpio-msm-v2.c
@@ -317,12 +317,23 @@ static void msm_summary_irq_handler(unsi
 
 	chained_irq_enter(chip, desc);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (i = find_first_bit(msm_gpio.enabled_irqs, NR_GPIO_IRQS);
 	     i < NR_GPIO_IRQS;
 	     i = find_next_bit(msm_gpio.enabled_irqs, NR_GPIO_IRQS, i + 1)) {
 		if (readl(GPIO_INTR_STATUS(i)) & BIT(INTR_STATUS))
 			generic_handle_irq(msm_gpio_to_irq(&msm_gpio.gpio_chip,
 							   i));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	chained_irq_exit(chip, desc);
diff -u -p a/firewire/core-card.c b/firewire/core-card.c
--- a/firewire/core-card.c
+++ b/firewire/core-card.c
@@ -138,8 +138,20 @@ static void generate_config_rom(struct f
 	 * assumes that CRC length and info length are identical for
 	 * the bus info block, which is always the case for this
 	 * implementation. */
-	for (i = 0; i < j; i += length + 1)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < j; i += length + 1) {
 		length = fw_compute_block_crc(config_rom + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	WARN_ON(j != config_rom_length);
 }
diff -u -p a/hv/vmbus_drv.c b/hv/vmbus_drv.c
--- a/hv/vmbus_drv.c
+++ b/hv/vmbus_drv.c
@@ -120,8 +120,20 @@ static void get_channel_info(struct hv_d
 static void print_alias_name(struct hv_device *hv_dev, char *alias_name)
 {
 	int i;
-	for (i = 0; i < VMBUS_ALIAS_LEN; i += 2)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < VMBUS_ALIAS_LEN; i += 2) {
 		sprintf(&alias_name[i], "%02x", hv_dev->dev_type.b[i/2]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 /*
diff -u -p a/platform/x86/intel_scu_ipc.c b/platform/x86/intel_scu_ipc.c
--- a/platform/x86/intel_scu_ipc.c
+++ b/platform/x86/intel_scu_ipc.c
@@ -185,8 +185,20 @@ static int pwr_reg_rdwr(u16 *addr, u8 *d
 			if (id == IPC_CMD_PCNTRL_M)
 				cbuf[bytes++] = data[d++];
 		}
-		for (i = 0; i < bytes; i += 4)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (i = 0; i < bytes; i += 4) {
 			ipc_data_writel(wbuf[i/4], i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
 		ipc_command(bytes << 16 |  id << 12 | 0 << 8 | op);
 	} else {
 		for (nc = 0; nc < count; nc++, offset += 2) {
diff -u -p a/mfd/htc-egpio.c b/mfd/htc-egpio.c
--- a/mfd/htc-egpio.c
+++ b/mfd/htc-egpio.c
@@ -236,7 +236,12 @@ static void egpio_write_cache(struct egp
 		if (!egpio->is_out)
 			continue;
 
-		for (shift = 0; shift < egpio->chip.ngpio;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (shift = 0; shift < egpio->chip.ngpio;
 				shift += (1<<ei->reg_shift)) {
 
 			int reg = egpio->reg_start + egpio_pos(ei, shift);
@@ -250,6 +255,12 @@ static void egpio_write_cache(struct egp
 
 			egpio_writew((egpio->cached_values >> shift)
 					& ei->reg_mask, ei, reg);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 }
diff -u -p a/atm/idt77105.c b/atm/idt77105.c
--- a/atm/idt77105.c
+++ b/atm/idt77105.c
@@ -88,6 +88,11 @@ static void idt77105_stats_timer_func(un
 	struct idt77105_stats *stats;
 
         DPRINTK("IDT77105 gathering statistics\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (walk = idt77105_all; walk; walk = walk->next) {
 		dev = walk->dev;
                 
@@ -96,7 +101,13 @@ static void idt77105_stats_timer_func(un
                 stats->tx_cells += get_counter(dev, IDT77105_CTRSEL_TCC);
                 stats->rx_cells += get_counter(dev, IDT77105_CTRSEL_RCC);
                 stats->rx_hec_errors += get_counter(dev, IDT77105_CTRSEL_RHEC);
-	}
+                if (_cur < timeout) {
+                	rdstcll(_cur);
+                }
+                else {
+                	break;
+                }
+        }
         if (!start_timer) mod_timer(&stats_timer,jiffies+IDT77105_STATS_TIMER_PERIOD);
 }
 
@@ -117,6 +128,11 @@ static void idt77105_restart_timer_func(
         unsigned char istat;
 
         DPRINTK("IDT77105 checking for cable re-insertion\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (walk = idt77105_all; walk; walk = walk->next) {
 		dev = walk->dev;
                 
@@ -134,7 +150,13 @@ static void idt77105_restart_timer_func(
                     /* re-enable interrupts */
 	            PUT( walk->old_mcr ,MCR);
                 }
-	}
+                if (_cur < timeout) {
+	            rdstcll(_cur);
+                }
+                else {
+	            break;
+                }
+        }
         if (!start_timer) mod_timer(&restart_timer,jiffies+IDT77105_RESTART_TIMER_PERIOD);
 }
 
diff -u -p a/atm/lanai.c b/atm/lanai.c
--- a/atm/lanai.c
+++ b/atm/lanai.c
@@ -569,8 +569,20 @@ static int __devinit sram_test_word(cons
 static int __devinit sram_test_pass(const struct lanai_dev *lanai, u32 pattern)
 {
 	int offset, result = 0;
-	for (offset = 0; offset < SRAM_BYTES && result == 0; offset += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (offset = 0; offset < SRAM_BYTES && result == 0; offset += 4) {
 		result = sram_test_word(lanai, offset, pattern);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	return result;
 }
 
diff -u -p a/atm/idt77252.c b/atm/idt77252.c
--- a/atm/idt77252.c
+++ b/atm/idt77252.c
@@ -3114,8 +3114,20 @@ init_sram(struct idt77252_dev *card)
 {
 	int i;
 
-	for (i = 0; i < card->sramsize; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < card->sramsize; i += 4) {
 		write_sram(card, (i >> 2), 0);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
+	}
 
 	/* set SRAM layout for THIS card */
 	if (card->sramsize == (512 * 1024)) {
diff -u -p a/atm/firestream.c b/atm/firestream.c
--- a/atm/firestream.c
+++ b/atm/firestream.c
@@ -1962,6 +1962,11 @@ static void __devexit firestream_remove_
 	}
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (dev = fs_boards;dev != NULL;dev=nxtdev) {
 		fs_dprintk (FS_DEBUG_CLEANUP, "Releasing resources for dev at %p.\n", dev);
 
@@ -1981,6 +1986,11 @@ static void __devexit firestream_remove_
 		/* XXX Wait a while for the chip to release all buffers. */
 
 		for (i=0;i < FS_NR_FREE_POOLS;i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			for (fp=bus_to_virt (read_fs (dev, FP_SA(dev->rx_fp[i].offset)));
 			     !(fp->flags & FP_FLAGS_EPI);fp = nxt) {
 				fs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p\n", fp->skb);
@@ -1988,6 +1998,12 @@ static void __devexit firestream_remove_
 				nxt = bus_to_virt (fp->next);
 				fs_dprintk (FS_DEBUG_ALLOC, "Free rec-d: %p\n", fp);
 				kfree (fp);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			fs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p\n", fp->skb);
 			dev_kfree_skb_any (fp->skb);
@@ -2022,6 +2038,12 @@ static void __devexit firestream_remove_
 		fs_dprintk (FS_DEBUG_ALLOC, "Free fs-dev: %p\n", dev);
 		nxtdev = dev->next;
 		kfree (dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	func_exit ();
diff -u -p a/atm/solos-pci.c b/atm/solos-pci.c
--- a/atm/solos-pci.c
+++ b/atm/solos-pci.c
@@ -588,6 +588,11 @@ static int flash_upgrade(struct solos_ca
 	iowrite32(1, card->config_regs + WRITE_FLASH);
 	wait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (offset = 0; offset < fw->size; offset += blocksize) {
 		int i;
 
@@ -611,6 +616,12 @@ static int flash_upgrade(struct solos_ca
 		iowrite32(offset / blocksize, card->config_regs + FLASH_BLOCK);
 		iowrite32(1, card->config_regs + WRITE_FLASH);
 		wait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	release_firmware(fw);
diff -u -p a/atm/ambassador.c b/atm/ambassador.c
--- a/atm/ambassador.c
+++ b/atm/ambassador.c
@@ -355,14 +355,50 @@ static inline void dump_registers (const
   if (debug & DBG_REGS) {
     size_t i;
     PRINTD (DBG_REGS, "reading PLX control: ");
-    for (i = 0x00; i < 0x30; i += sizeof(u32))
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    for (i = 0x00; i < 0x30; i += sizeof(u32)) {
       rd_mem (dev, i);
+      if (_cur < timeout) {
+        rdstcll(_cur);
+      }
+      else {
+        break;
+      }
+    }
     PRINTD (DBG_REGS, "reading mailboxes: ");
-    for (i = 0x40; i < 0x60; i += sizeof(u32))
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    for (i = 0x40; i < 0x60; i += sizeof(u32)) {
       rd_mem (dev, i);
+      if (_cur < timeout) {
+        rdstcll(_cur);
+      }
+      else {
+        break;
+      }
+    }
     PRINTD (DBG_REGS, "reading doorb irqev irqen reset:");
-    for (i = 0x60; i < 0x70; i += sizeof(u32))
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    for (i = 0x60; i < 0x70; i += sizeof(u32)) {
       rd_mem (dev, i);
+      if (_cur < timeout) {
+        rdstcll(_cur);
+      }
+      else {
+        break;
+      }
+    }
   }
 #else
   (void) dev;
diff -u -p a/atm/nicstar.c b/atm/nicstar.c
--- a/atm/nicstar.c
+++ b/atm/nicstar.c
@@ -340,8 +340,20 @@ static void ns_write_sram(ns_dev * card,
 	c <<= 2;		/* to use increments of 4 */
 	spin_lock_irqsave(&card->res_lock, flags);
 	while (CMD_BUSY(card)) ;
-	for (i = 0; i <= c; i += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i <= c; i += 4) {
 		writel(*(value++), card->membase + i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	/* Note: DR# registers are the first 4 dwords in nicstar's memspace,
 	   so card->membase + DR0 == card->membase */
 	sram_address <<= 2;
diff -u -p a/atm/suni.c b/atm/suni.c
--- a/atm/suni.c
+++ b/atm/suni.c
@@ -60,6 +60,11 @@ static void suni_hz(unsigned long from_t
 	struct atm_dev *dev;
 	struct k_sonet_stats *stats;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (walk = sunis; walk; walk = walk->next) {
 		dev = walk->dev;
 		stats = &walk->sonet_stats;
@@ -85,6 +90,12 @@ static void suni_hz(unsigned long from_t
 		ADD_LIMITED(tx_cells,(GET(TACP_TCCL) & 0xff) |
 		    ((GET(TACP_TCC) & 0xff) << 8) |
 		    ((GET(TACP_TCCM) & 7) << 16));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (from_timer) mod_timer(&poll_timer,jiffies+HZ);
 }
diff -u -p a/md/raid5.c b/md/raid5.c
--- a/md/raid5.c
+++ b/md/raid5.c
@@ -2208,12 +2208,23 @@ static int add_stripe_bio(struct stripe_
 	if (forwrite) {
 		/* check if page is covered */
 		sector_t sector = sh->dev[dd_idx].sector;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (bi=sh->dev[dd_idx].towrite;
 		     sector < sh->dev[dd_idx].sector + STRIPE_SECTORS &&
 			     bi && bi->bi_sector <= sector;
 		     bi = r5_next_bio(bi, sh->dev[dd_idx].sector)) {
 			if (bi->bi_sector + (bi->bi_size>>9) >= sector)
 				sector = bi->bi_sector + (bi->bi_size>>9);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (sector >= sh->dev[dd_idx].sector + STRIPE_SECTORS)
 			set_bit(R5_OVERWRITE, &sh->dev[dd_idx].flags);
diff -u -p a/md/dm-region-hash.c b/md/dm-region-hash.c
--- a/md/dm-region-hash.c
+++ b/md/dm-region-hash.c
@@ -526,10 +526,21 @@ void dm_rh_inc_pending(struct dm_region_
 {
 	struct bio *bio;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bio = bios->head; bio; bio = bio->bi_next) {
 		if (bio->bi_rw & (REQ_FLUSH | REQ_DISCARD))
 			continue;
 		rh_inc(rh, dm_rh_bio_to_region(rh, bio));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(dm_rh_inc_pending);
diff -u -p a/cdrom/gdrom.c b/cdrom/gdrom.c
--- a/cdrom/gdrom.c
+++ b/cdrom/gdrom.c
@@ -408,8 +408,20 @@ static int gdrom_hardreset(struct cdrom_
 {
 	int count;
 	__raw_writel(0x1fffff, GDROM_RESET_REG);
-	for (count = 0xa0000000; count < 0xa0200000; count += 4)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (count = 0xa0000000; count < 0xa0200000; count += 4) {
 		__raw_readl(count);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	return 0;
 }
 
diff -u -p a/acpi/bus.c b/acpi/bus.c
--- a/acpi/bus.c
+++ b/acpi/bus.c
@@ -407,8 +407,20 @@ static void acpi_print_osc_error(acpi_ha
 		kfree(buffer.pointer);
 	}
 	printk(KERN_DEBUG"_OSC request data:");
-	for (i = 0; i < context->cap.length; i += sizeof(u32))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (i = 0; i < context->cap.length; i += sizeof(u32)) {
 		printk("%x ", *((u32 *)(context->cap.pointer + i)));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	printk("\n");
 }
 
diff -u -p a/acpi/pci_irq.c b/acpi/pci_irq.c
--- a/acpi/pci_irq.c
+++ b/acpi/pci_irq.c
@@ -311,11 +311,22 @@ static int bridge_has_boot_interrupt_var
 {
 	struct pci_bus *bus_it;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (bus_it = bus ; bus_it ; bus_it = bus_it->parent) {
 		if (!bus_it->self)
 			return 0;
 		if (bus_it->self->irq_reroute_variant)
 			return bus_it->self->irq_reroute_variant;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/sbus/char/jsflash.c b/sbus/char/jsflash.c
--- a/sbus/char/jsflash.c
+++ b/sbus/char/jsflash.c
@@ -138,10 +138,21 @@ static struct jsflash jsf0;
 static void jsf_wait(unsigned long p) {
 	unsigned int x1, x2;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		x1 = jsf_inl(p);
 		x2 = jsf_inl(p);
 		if ((x1 & 0x40404040) == (x2 & 0x40404040)) return;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/pci/hotplug/cpqphp_ctrl.c b/pci/hotplug/cpqphp_ctrl.c
--- a/pci/hotplug/cpqphp_ctrl.c
+++ b/pci/hotplug/cpqphp_ctrl.c
@@ -1142,6 +1142,11 @@ static u8 set_controller_speed(struct co
 	/* We don't allow freq/mode changes if we find another adapter running
 	 * in another slot on this controller
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(slot = ctrl->slot; slot; slot = slot->next) {
 		if (slot->device == (hp_slot + ctrl->slot_device_offset))
 			continue;
@@ -1157,6 +1162,12 @@ static u8 set_controller_speed(struct co
 			return 0;
 
 		return 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If the controller doesn't support freq/mode changes and the
@@ -1755,9 +1766,22 @@ static int event_thread(void* data)
 		/* Do stuff here */
 		if (pushbutton_pending)
 			cpqhp_pushbutton_thread(pushbutton_pending);
-		else
-			for (ctrl = cpqhp_ctrl_list; ctrl; ctrl=ctrl->next)
+		else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for (ctrl = cpqhp_ctrl_list; ctrl; ctrl=ctrl->next) {
 				interrupt_event_handler(ctrl);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+		}
 	}
 	dbg("event_thread signals exit\n");
 	return 0;
diff -u -p a/pci/hotplug/acpiphp_glue.c b/pci/hotplug/acpiphp_glue.c
--- a/pci/hotplug/acpiphp_glue.c
+++ b/pci/hotplug/acpiphp_glue.c
@@ -333,11 +333,22 @@ static struct acpiphp_func *acpiphp_brid
 	struct acpiphp_func *func;
 
 	list_for_each_entry(bridge, &bridge_list, list) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (slot = bridge->slots; slot; slot = slot->next) {
 			list_for_each_entry(func, &slot->funcs, sibling) {
 				if (func->handle == handle)
 					return func;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
@@ -1019,6 +1030,11 @@ static int acpiphp_check_bridge(struct a
 
 	enabled = disabled = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (slot = bridge->slots; slot; slot = slot->next) {
 		unsigned int status = get_slot_status(slot);
 		if (slot->flags & SLOT_ENABLED) {
@@ -1042,6 +1058,12 @@ static int acpiphp_check_bridge(struct a
 			}
 			enabled++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dbg("%s: %d enabled, %d disabled\n", __func__, enabled, disabled);
diff -u -p a/pci/probe.c b/pci/probe.c
--- a/pci/probe.c
+++ b/pci/probe.c
@@ -1319,6 +1319,11 @@ int pci_scan_slot(struct pci_bus *bus, i
 	else if (dev->multifunction)
 		next_fn = next_trad_fn;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (fn = next_fn(dev, 0); fn > 0; fn = next_fn(dev, fn)) {
 		dev = pci_scan_single_device(bus, devfn + fn);
 		if (dev) {
@@ -1326,6 +1331,12 @@ int pci_scan_slot(struct pci_bus *bus, i
 				nr++;
 			dev->multifunction = 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* only one slot has pcie device */
@@ -1494,8 +1505,20 @@ unsigned int __devinit pci_scan_child_bu
 	dev_dbg(&bus->dev, "scanning bus\n");
 
 	/* Go find them, Rover! */
-	for (devfn = 0; devfn < 0x100; devfn += 8)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	for (devfn = 0; devfn < 0x100; devfn += 8) {
 		pci_scan_slot(bus, devfn);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	/* Reserve buses for SR-IOV capability. */
 	max += pci_iov_bus_range(bus);
diff -u -p a/pci/setup-bus.c b/pci/setup-bus.c
--- a/pci/setup-bus.c
+++ b/pci/setup-bus.c
@@ -199,6 +199,11 @@ static void assign_requested_resources_s
 	struct resource_list *list;
 	int idx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (list = head->next; list; list = list->next) {
 		res = list->res;
 		idx = res - &list->dev->resource[0];
@@ -214,6 +219,12 @@ static void assign_requested_resources_s
 			}
 			reset_resource(res);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/pci/access.c b/pci/access.c
--- a/pci/access.c
+++ b/pci/access.c
@@ -219,7 +219,12 @@ static int pci_vpd_pci22_wait(struct pci
 	if (!vpd->busy)
 		return 0;
 
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (;;) {
 		ret = pci_user_read_config_word(dev, vpd->cap + PCI_VPD_ADDR,
 						&status);
 		if (ret < 0)
@@ -241,6 +246,12 @@ static int pci_vpd_pci22_wait(struct pci
 			return -EINTR;
 		if (!cond_resched())
 			udelay(10);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/ata/libata-sff.c b/ata/libata-sff.c
--- a/ata/libata-sff.c
+++ b/ata/libata-sff.c
@@ -2167,9 +2167,21 @@ void ata_sff_drain_fifo(struct ata_queue
 
 	ap = qc->ap;
 	/* Drain up to 64K of data before we give up this recovery method */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (count = 0; (ap->ops->sff_check_status(ap) & ATA_DRQ)
-						&& count < 65536; count += 2)
+						&& count < 65536; count += 2) {
 		ioread16(ap->ioaddr.data_addr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 	/* Can become DEBUG later */
 	if (count)
diff -u -p a/ata/libata-core.c b/ata/libata-core.c
--- a/ata/libata-core.c
+++ b/ata/libata-core.c
@@ -5804,12 +5804,23 @@ static void ata_finalize_port_ops(struct
 
 	spin_lock(&lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur = ops->inherits; cur; cur = cur->inherits) {
 		void **inherit = (void **)cur;
 
 		for (pp = begin; pp < end; pp++, inherit++)
 			if (!*pp)
 				*pp = *inherit;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+		}
 	}
 
 	for (pp = begin; pp < end; pp++)
@@ -6460,6 +6471,11 @@ static void __init ata_parse_force_param
 	}
 
 	/* parse and populate the table */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (cur = ata_force_param_buf; *cur != '\0'; cur = next) {
 		const char *reason = "";
 		struct ata_force_ent te = { .port = -1, .device = -1 };
@@ -6481,6 +6497,12 @@ static void __init ata_parse_force_param
 
 		last_port = te.port;
 		last_device = te.device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ata_force_tbl_size = idx;
diff -u -p a/hwmon/abituguru.c b/hwmon/abituguru.c
--- a/hwmon/abituguru.c
+++ b/hwmon/abituguru.c
@@ -301,6 +301,11 @@ static int abituguru_send_address(struct
 	   any retries, and thus be quiet. */
 	int report_errors = retries;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		/* Make sure the uguru is ready and then send the bank address,
 		   after this the uguru is no longer "ready". */
@@ -329,6 +334,12 @@ static int abituguru_send_address(struct
 		}
 		outb(sensor_addr, data->addr + ABIT_UGURU_CMD);
 		return 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
