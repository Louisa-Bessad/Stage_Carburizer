diff -u -p a/hv/channel.c b/hv/channel.c
--- a/hv/channel.c
+++ b/hv/channel.c
@@ -301,7 +301,12 @@ static int create_gpadl_header(void *kbu
 		pfncount = pfnsize / sizeof(u64);
 
 		/* fill in the body */
-		while (pfnleft) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (pfnleft) {
 			if (pfnleft > pfncount)
 				pfncurr = pfncount;
 			else
@@ -348,6 +353,12 @@ static int create_gpadl_header(void *kbu
 				      &msgheader->submsglist);
 			pfnsum += pfncurr;
 			pfnleft -= pfncurr;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	} else {
 		/* everything fits in a header */
diff -u -p a/md/dm.c b/md/dm.c
--- a/md/dm.c
+++ b/md/dm.c
@@ -1645,6 +1645,11 @@ static void dm_request_fn(struct request
 	 * number of in-flight I/Os after the queue is stopped in
 	 * dm_suspend().
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!blk_queue_stopped(q)) {
 		rq = blk_peek_request(q);
 		if (!rq)
@@ -1678,6 +1683,12 @@ static void dm_request_fn(struct request
 
 		BUG_ON(!irqs_disabled());
 		spin_lock(q->queue_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	goto out;
@@ -2063,12 +2074,23 @@ static int dm_table_merge_is_optional(st
 	unsigned i = 0;
 	struct dm_target *ti;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < dm_table_get_num_targets(table)) {
 		ti = dm_table_get_target(table, i++);
 
 		if (ti->type->iterate_devices &&
 		    ti->type->iterate_devices(ti, dm_device_merge_is_compulsory, NULL))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 1;
diff -u -p a/md/md.c b/md/md.c
--- a/md/md.c
+++ b/md/md.c
@@ -237,11 +237,22 @@ void md_trim_bio(struct bio *bio, int of
 	offset <<= 9;
 	clear_bit(BIO_SEG_VALID, &bio->bi_flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bio->bi_idx < bio->bi_vcnt &&
 	       bio->bi_io_vec[bio->bi_idx].bv_len <= offset) {
 		/* remove this whole bio_vec */
 		offset -= bio->bi_io_vec[bio->bi_idx].bv_len;
 		bio->bi_idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (bio->bi_idx < bio->bi_vcnt) {
 		bio->bi_io_vec[bio->bi_idx].bv_offset += offset;
@@ -649,6 +660,11 @@ static struct mddev * mddev_find(dev_t u
 		int start = next_minor;
 		int is_free = 0;
 		int dev = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!is_free) {
 			dev = MKDEV(MD_MAJOR, next_minor);
 			next_minor++;
@@ -667,6 +683,12 @@ static struct mddev * mddev_find(dev_t u
 					is_free = 0;
 					break;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		new->unit = dev;
 		new->md_minor = MINOR(dev);
@@ -2519,9 +2541,20 @@ static int cmd_match(const char *cmd, co
 	 * str.  They must either be the same, or cmd can
 	 * have a trailing newline
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*cmd && *str && *cmd == *str) {
 		cmd++;
 		str++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (*cmd == '\n')
 		cmd++;
@@ -3243,9 +3276,20 @@ int strict_strtoul_scaled(const char *cp
 		return -EINVAL;
 	if (decimals < 0)
 		decimals = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (decimals < scale) {
 		result *= 10;
 		decimals ++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	*res = result;
 	return 0;
@@ -6417,7 +6461,12 @@ static int md_thread(void * arg)
 	 */
 
 	allow_signal(SIGKILL);
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 
 		/* We need to wait INTERRUPTIBLE so that
 		 * we don't add to the load-average.
@@ -6436,6 +6485,12 @@ static int md_thread(void * arg)
 		clear_bit(THREAD_WAKEUP, &thread->flags);
 		if (!kthread_should_stop())
 			thread->run(thread->mddev);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
@@ -7200,6 +7255,11 @@ void md_do_sync(struct mddev *mddev)
 			sysfs_notify(&mddev->kobj, NULL, "sync_completed");
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (j >= mddev->resync_max && !kthread_should_stop()) {
 			/* As this condition is controlled by user-space,
 			 * we can block indefinitely, so use '_interruptible'
@@ -7209,6 +7269,12 @@ void md_do_sync(struct mddev *mddev)
 			wait_event_interruptible(mddev->recovery_wait,
 						 mddev->resync_max > j
 						 || kthread_should_stop());
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		if (kthread_should_stop())
diff -u -p a/md/dm-crypt.c b/md/dm-crypt.c
--- a/md/dm-crypt.c
+++ b/md/dm-crypt.c
@@ -771,6 +771,11 @@ static int crypt_convert(struct crypt_co
 
 	atomic_set(&ctx->pending, 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ctx->idx_in < ctx->bio_in->bi_vcnt &&
 	      ctx->idx_out < ctx->bio_out->bi_vcnt) {
 
@@ -803,6 +808,12 @@ static int crypt_convert(struct crypt_co
 			atomic_dec(&ctx->pending);
 			return r;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/md/raid1.c b/md/raid1.c
--- a/md/raid1.c
+++ b/md/raid1.c
@@ -674,11 +674,22 @@ static void flush_pending_writes(struct
 		bitmap_unplug(conf->mddev->bitmap);
 		wake_up(&conf->wait_barrier);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bio) { /* submit pending writes */
 			struct bio *next = bio->bi_next;
 			bio->bi_next = NULL;
 			generic_make_request(bio);
 			bio = next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else
 		spin_unlock_irq(&conf->device_lock);
@@ -1501,6 +1512,11 @@ static int fix_sync_read_error(struct r1
 	int sectors = r1_bio->sectors;
 	int idx = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(sectors) {
 		int s = sectors;
 		int d = r1_bio->read_disk;
@@ -1566,6 +1582,11 @@ static int fix_sync_read_error(struct r1
 
 		start = d;
 		/* write it back and re-read */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (d != r1_bio->read_disk) {
 			if (d == 0)
 				d = conf->raid_disks;
@@ -1579,8 +1600,19 @@ static int fix_sync_read_error(struct r1
 				r1_bio->bios[d]->bi_end_io = NULL;
 				rdev_dec_pending(rdev, mddev);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		d = start;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (d != r1_bio->read_disk) {
 			if (d == 0)
 				d = conf->raid_disks;
@@ -1592,10 +1624,22 @@ static int fix_sync_read_error(struct r1
 					    bio->bi_io_vec[idx].bv_page,
 					    READ) != 0)
 				atomic_add(s, &rdev->corrected_errors);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 		sectors -= s;
 		sect += s;
 		idx ++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	set_bit(R1BIO_Uptodate, &r1_bio->state);
 	set_bit(BIO_UPTODATE, &bio->bi_flags);
@@ -1789,6 +1833,11 @@ static void fix_read_error(struct r1conf
 		}
 		/* write it back and re-read */
 		start = d;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (d != read_disk) {
 			if (d==0)
 				d = conf->raid_disks;
@@ -1798,8 +1847,19 @@ static void fix_read_error(struct r1conf
 			    test_bit(In_sync, &rdev->flags))
 				r1_sync_page_io(rdev, sect, s,
 						conf->tmppage, WRITE);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		d = start;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (d != read_disk) {
 			char b[BDEVNAME_SIZE];
 			if (d==0)
@@ -1820,6 +1880,12 @@ static void fix_read_error(struct r1conf
 					       bdevname(rdev->bdev, b));
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		sectors -= s;
 		sect += s;
@@ -1890,6 +1956,11 @@ static int narrow_write_error(struct r1b
 		vec = r1_bio->master_bio->bi_io_vec;
 		idx = r1_bio->master_bio->bi_idx;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sect_to_write) {
 		struct bio *wbio;
 		if (sectors > sect_to_write)
@@ -1917,6 +1988,12 @@ static int narrow_write_error(struct r1b
 		sect_to_write -= sectors;
 		sector += sectors;
 		sectors = block_sectors;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return ok;
 }
diff -u -p a/md/raid5.c b/md/raid5.c
--- a/md/raid5.c
+++ b/md/raid5.c
@@ -171,6 +171,11 @@ static int raid6_idx_to_slot(int idx, st
 static void return_io(struct bio *return_bi)
 {
 	struct bio *bi = return_bi;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bi) {
 
 		return_bi = bi->bi_next;
@@ -178,6 +183,12 @@ static void return_io(struct bio *return
 		bi->bi_size = 0;
 		bio_endio(bi, 0);
 		bi = return_bi;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -674,6 +685,11 @@ static void ops_complete_biofill(void *s
 			BUG_ON(!dev->read);
 			rbi = dev->read;
 			dev->read = NULL;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (rbi && rbi->bi_sector <
 				dev->sector + STRIPE_SECTORS) {
 				rbi2 = r5_next_bio(rbi, dev->sector);
@@ -682,6 +698,12 @@ static void ops_complete_biofill(void *s
 					return_bi = rbi;
 				}
 				rbi = rbi2;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -712,11 +734,22 @@ static void ops_run_biofill(struct strip
 			dev->read = rbi = dev->toread;
 			dev->toread = NULL;
 			spin_unlock_irq(&conf->device_lock);
-			while (rbi && rbi->bi_sector <
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (rbi && rbi->bi_sector <
 				dev->sector + STRIPE_SECTORS) {
 				tx = async_copy_data(0, rbi, dev->page,
 					dev->sector, tx);
 				rbi = r5_next_bio(rbi, dev->sector);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
@@ -1054,13 +1087,24 @@ ops_run_biodrain(struct stripe_head *sh,
 			wbi = dev->written = chosen;
 			spin_unlock_irq(&sh->raid_conf->device_lock);
 
-			while (wbi && wbi->bi_sector <
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (wbi && wbi->bi_sector <
 				dev->sector + STRIPE_SECTORS) {
 				if (wbi->bi_rw & REQ_FUA)
 					set_bit(R5_WantFUA, &dev->flags);
 				tx = async_copy_data(1, wbi, dev->page,
 					dev->sector, tx);
 				wbi = r5_next_bio(wbi, dev->sector);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
@@ -1474,10 +1518,21 @@ static int resize_stripes(struct r5conf
 	}
 	if (i) {
 		/* didn't get enough, give up */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!list_empty(&newstripes)) {
 			nsh = list_entry(newstripes.next, struct stripe_head, lru);
 			list_del(&nsh->lru);
 			kmem_cache_free(sc, nsh);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		kmem_cache_destroy(sc);
 		return -ENOMEM;
@@ -1537,6 +1592,11 @@ static int resize_stripes(struct r5conf
 	put_online_cpus();
 
 	/* Step 4, return new stripes to service */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(!list_empty(&newstripes)) {
 		nsh = list_entry(newstripes.next, struct stripe_head, lru);
 		list_del_init(&nsh->lru);
@@ -1549,6 +1609,12 @@ static int resize_stripes(struct r5conf
 					err = -ENOMEM;
 			}
 		release_stripe(nsh);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* critical section pass, GFP_NOIO no longer needed */
 
@@ -2191,10 +2257,21 @@ static int add_stripe_bio(struct stripe_
 			firstwrite = 1;
 	} else
 		bip = &sh->dev[dd_idx].toread;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*bip && (*bip)->bi_sector < bi->bi_sector) {
 		if ((*bip)->bi_sector + ((*bip)->bi_size >> 9) > bi->bi_sector)
 			goto overlap;
 		bip = & (*bip)->bi_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (*bip && (*bip)->bi_sector < bi->bi_sector + ((bi->bi_size)>>9))
 		goto overlap;
@@ -2296,6 +2373,11 @@ handle_failed_stripe(struct r5conf *conf
 		if (test_and_clear_bit(R5_Overlap, &sh->dev[i].flags))
 			wake_up(&conf->wait_for_overlap);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bi && bi->bi_sector <
 			sh->dev[i].sector + STRIPE_SECTORS) {
 			struct bio *nextbi = r5_next_bio(bi, sh->dev[i].sector);
@@ -2306,11 +2388,22 @@ handle_failed_stripe(struct r5conf *conf
 				*return_bi = bi;
 			}
 			bi = nextbi;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* and fail all 'written' */
 		bi = sh->dev[i].written;
 		sh->dev[i].written = NULL;
 		if (bi) bitmap_end = 1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bi && bi->bi_sector <
 		       sh->dev[i].sector + STRIPE_SECTORS) {
 			struct bio *bi2 = r5_next_bio(bi, sh->dev[i].sector);
@@ -2321,6 +2414,12 @@ handle_failed_stripe(struct r5conf *conf
 				*return_bi = bi;
 			}
 			bi = bi2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* fail any reads if this device is non-operational and
@@ -2334,7 +2433,12 @@ handle_failed_stripe(struct r5conf *conf
 			if (test_and_clear_bit(R5_Overlap, &sh->dev[i].flags))
 				wake_up(&conf->wait_for_overlap);
 			if (bi) s->to_read--;
-			while (bi && bi->bi_sector <
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (bi && bi->bi_sector <
 			       sh->dev[i].sector + STRIPE_SECTORS) {
 				struct bio *nextbi =
 					r5_next_bio(bi, sh->dev[i].sector);
@@ -2344,6 +2448,12 @@ handle_failed_stripe(struct r5conf *conf
 					*return_bi = bi;
 				}
 				bi = nextbi;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		spin_unlock_irq(&conf->device_lock);
@@ -2529,6 +2639,11 @@ static void handle_stripe_clean_event(st
 				spin_lock_irq(&conf->device_lock);
 				wbi = dev->written;
 				dev->written = NULL;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (wbi && wbi->bi_sector <
 					dev->sector + STRIPE_SECTORS) {
 					wbi2 = r5_next_bio(wbi, dev->sector);
@@ -2538,6 +2653,12 @@ static void handle_stripe_clean_event(st
 						*return_bi = wbi;
 					}
 					wbi = wbi2;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (dev->towrite == NULL)
 					bitmap_end = 1;
@@ -3398,6 +3519,11 @@ finish:
 static void raid5_activate_delayed(struct r5conf *conf)
 {
 	if (atomic_read(&conf->preread_active_stripes) < IO_THRESHOLD) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!list_empty(&conf->delayed_list)) {
 			struct list_head *l = conf->delayed_list.next;
 			struct stripe_head *sh;
@@ -3407,6 +3533,12 @@ static void raid5_activate_delayed(struc
 			if (!test_and_set_bit(STRIPE_PREREAD_ACTIVE, &sh->state))
 				atomic_inc(&conf->preread_active_stripes);
 			list_add_tail(&sh->lru, &conf->hold_list);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -3417,11 +3549,22 @@ static void activate_bit_delay(struct r5
 	struct list_head head;
 	list_add(&head, &conf->bitmap_list);
 	list_del_init(&conf->bitmap_list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&head)) {
 		struct stripe_head *sh = list_entry(head.next, struct stripe_head, lru);
 		list_del_init(&sh->lru);
 		atomic_inc(&sh->count);
 		__release_stripe(conf, sh);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4048,20 +4191,42 @@ static sector_t reshape_request(struct m
 				     1, &dd_idx, NULL);
 	if (last_sector >= mddev->dev_sectors)
 		last_sector = mddev->dev_sectors - 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (first_sector <= last_sector) {
 		sh = get_active_stripe(conf, first_sector, 1, 0, 1);
 		set_bit(STRIPE_EXPAND_SOURCE, &sh->state);
 		set_bit(STRIPE_HANDLE, &sh->state);
 		release_stripe(sh);
 		first_sector += STRIPE_SECTORS;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* Now that the sources are clearly marked, we can release
 	 * the destination stripes
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&stripes)) {
 		sh = list_entry(stripes.next, struct stripe_head, lru);
 		list_del_init(&sh->lru);
 		release_stripe(sh);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* If this takes us to the resync_max point where we have to pause,
 	 * then we need to write out the superblock.
diff -u -p a/md/bitmap.c b/md/bitmap.c
--- a/md/bitmap.c
+++ b/md/bitmap.c
@@ -309,12 +309,23 @@ static void write_page(struct bitmap *bi
 
 		bh = page_buffers(page);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bh && bh->b_blocknr) {
 			atomic_inc(&bitmap->pending_writes);
 			set_buffer_locked(bh);
 			set_buffer_mapped(bh);
 			submit_bh(WRITE | REQ_SYNC, bh);
 			bh = bh->b_this_page;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (wait)
@@ -351,10 +362,21 @@ static void free_buffers(struct page *pa
 {
 	struct buffer_head *bh = page_buffers(page);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bh) {
 		struct buffer_head *next = bh->b_this_page;
 		free_buffer_head(bh);
 		bh = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	__clear_page_buffers(page);
 	put_page(page);
@@ -393,6 +415,11 @@ static struct page *read_page(struct fil
 	}
 	attach_page_buffers(page, bh);
 	block = index << (PAGE_SHIFT - inode->i_blkbits);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bh) {
 		if (count == 0)
 			bh->b_blocknr = 0;
@@ -419,6 +446,12 @@ static struct page *read_page(struct fil
 		}
 		block++;
 		bh = bh->b_this_page;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	page->index = index;
 
@@ -1333,6 +1366,11 @@ int bitmap_startwrite(struct bitmap *bit
 			 bw, bitmap->mddev->bitmap_info.max_write_behind);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sectors) {
 		sector_t blocks;
 		bitmap_counter_t *bmc;
@@ -1376,6 +1414,12 @@ int bitmap_startwrite(struct bitmap *bit
 			sectors -= blocks;
 		else
 			sectors = 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return 0;
 }
@@ -1394,6 +1438,11 @@ void bitmap_endwrite(struct bitmap *bitm
 			 bitmap->mddev->bitmap_info.max_write_behind);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sectors) {
 		sector_t blocks;
 		unsigned long flags;
@@ -1434,6 +1483,12 @@ void bitmap_endwrite(struct bitmap *bitm
 			sectors -= blocks;
 		else
 			sectors = 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 EXPORT_SYMBOL(bitmap_endwrite);
@@ -1480,11 +1535,22 @@ int bitmap_start_sync(struct bitmap *bit
 	sector_t blocks1;
 
 	*blocks = 0;
-	while (*blocks < (PAGE_SIZE>>9)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*blocks < (PAGE_SIZE>>9)) {
 		rv |= __bitmap_start_sync(bitmap, offset,
 					  &blocks1, degraded);
 		offset += blocks1;
 		*blocks += blocks1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return rv;
 }
@@ -1533,9 +1599,20 @@ void bitmap_close_sync(struct bitmap *bi
 	sector_t blocks;
 	if (!bitmap)
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sector < bitmap->mddev->resync_max_sectors) {
 		bitmap_end_sync(bitmap, sector, &blocks, 0);
 		sector += blocks;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL(bitmap_close_sync);
@@ -1561,9 +1638,20 @@ void bitmap_cond_end_sync(struct bitmap
 	set_bit(MD_CHANGE_CLEAN, &bitmap->mddev->flags);
 	sector &= ~((1ULL << CHUNK_BLOCK_SHIFT(bitmap)) - 1);
 	s = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (s < sector && s < bitmap->mddev->resync_max_sectors) {
 		bitmap_end_sync(bitmap, s, &blocks, 0);
 		s += blocks;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	bitmap->last_end_sync = jiffies;
 	sysfs_notify(&bitmap->mddev->kobj, NULL, "sync_completed");
@@ -1806,10 +1894,21 @@ int bitmap_load(struct mddev *mddev)
 	 * so we should forget old cached info.
 	 * All chunks should be clean, but some might need_sync.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sector < mddev->resync_max_sectors) {
 		sector_t blocks;
 		bitmap_start_sync(bitmap, sector, &blocks, 0);
 		sector += blocks;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	bitmap_close_sync(bitmap);
 
diff -u -p a/md/dm-table.c b/md/dm-table.c
--- a/md/dm-table.c
+++ b/md/dm-table.c
@@ -1242,7 +1242,12 @@ int dm_calculate_queue_limits(struct dm_
 
 	blk_set_default_limits(limits);
 
-	while (i < dm_table_get_num_targets(table)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < dm_table_get_num_targets(table)) {
 		blk_set_default_limits(&ti_limits);
 
 		ti = dm_table_get_target(table, i++);
@@ -1280,6 +1285,12 @@ combine_limits:
 			       dm_device_name(table->md),
 			       (unsigned long long) ti->begin,
 			       (unsigned long long) ti->len);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return validate_hardware_logical_block_alignment(table, limits);
@@ -1331,6 +1342,11 @@ static bool dm_table_supports_flush(stru
 	 * so we need to use iterate_devices here, which targets
 	 * supporting flushes must provide.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
@@ -1340,6 +1356,12 @@ static bool dm_table_supports_flush(stru
 		if (ti->type->iterate_devices &&
 		    ti->type->iterate_devices(ti, device_flush_capable, &flush))
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -1351,11 +1373,22 @@ static bool dm_table_discard_zeroes_data
 	unsigned i = 0;
 
 	/* Ensure that all targets supports discard_zeroes_data. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
 		if (ti->discard_zeroes_data_unsupported)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 1;
@@ -1383,12 +1416,23 @@ static bool dm_table_all_devices_attribu
 	struct dm_target *ti;
 	unsigned i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
 		if (!ti->type->iterate_devices ||
 		    !ti->type->iterate_devices(ti, func, NULL))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 1;
@@ -1595,6 +1639,11 @@ bool dm_table_supports_discards(struct d
 	 * so we need to use iterate_devices here, which targets
 	 * supporting discard selectively must provide.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
@@ -1607,6 +1656,12 @@ bool dm_table_supports_discards(struct d
 		if (ti->type->iterate_devices &&
 		    ti->type->iterate_devices(ti, device_discard_capable, NULL))
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/md/dm-snap.c b/md/dm-snap.c
--- a/md/dm-snap.c
+++ b/md/dm-snap.c
@@ -960,12 +960,23 @@ static void snapshot_merge_next_chunks(s
 	 * significant impact on performance.
 	 */
 	previous_count = read_pending_exceptions_done_count();
-	while (origin_write_extent(s, dest.sector, io_size)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (origin_write_extent(s, dest.sector, io_size)) {
 		wait_event(_pending_exceptions_done,
 			   (read_pending_exceptions_done_count() !=
 			    previous_count));
 		/* Retry after the wait, until all exceptions are done. */
 		previous_count = read_pending_exceptions_done_count();
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	down_write(&s->lock);
@@ -1332,11 +1343,22 @@ static void flush_bios(struct bio *bio)
 {
 	struct bio *n;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
 		generic_make_request(bio);
 		bio = n;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1350,6 +1372,11 @@ static void retry_origin_bios(struct dm_
 	struct bio *n;
 	int r;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
@@ -1357,6 +1384,12 @@ static void retry_origin_bios(struct dm_
 		if (r == DM_MAPIO_REMAPPED)
 			generic_make_request(bio);
 		bio = n;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1367,11 +1400,22 @@ static void error_bios(struct bio *bio)
 {
 	struct bio *n;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
 		bio_io_error(bio);
 		bio = n;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/md/dm-thin.c b/md/dm-thin.c
--- a/md/dm-thin.c
+++ b/md/dm-thin.c
@@ -427,10 +427,21 @@ static unsigned ds_next(unsigned index)
 
 static void __sweep(struct deferred_set *ds, struct list_head *head)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ds->sweeper != ds->current_entry) &&
 	       !ds->entries[ds->sweeper].count) {
 		list_splice_init(&ds->entries[ds->sweeper].work_items, head);
 		ds->sweeper = ds_next(ds->sweeper);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if ((ds->sweeper == ds->current_entry) && !ds->entries[ds->sweeper].count)
@@ -636,11 +647,22 @@ static void __requeue_bio_list(struct th
 	bio_list_merge(&bios, master);
 	bio_list_init(master);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((bio = bio_list_pop(&bios))) {
 		if (dm_get_mapinfo(bio)->ptr == tc)
 			bio_endio(bio, DM_ENDIO_REQUEUE);
 		else
 			bio_list_add(master, bio);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1680,6 +1702,11 @@ static int parse_pool_features(struct dm
 	if (r)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (argc && !r) {
 		arg_name = dm_shift_arg(as);
 		argc--;
@@ -1691,6 +1718,12 @@ static int parse_pool_features(struct dm
 
 		ti->error = "Unrecognised pool feature requested";
 		r = -EINVAL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return r;
diff -u -p a/md/raid10.c b/md/raid10.c
--- a/md/raid10.c
+++ b/md/raid10.c
@@ -511,12 +511,23 @@ static sector_t raid10_find_virt(struct
 		if (dev < 0)
 			dev += conf->raid_disks;
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sector >= conf->stride) {
 			sector -= conf->stride;
 			if (dev < conf->near_copies)
 				dev += conf->raid_disks - conf->near_copies;
 			else
 				dev -= conf->near_copies;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		chunk = sector >> conf->chunk_shift;
 	}
@@ -734,11 +745,22 @@ static void flush_pending_writes(struct
 		bitmap_unplug(conf->mddev->bitmap);
 		wake_up(&conf->wait_barrier);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bio) { /* submit pending writes */
 			struct bio *next = bio->bi_next;
 			bio->bi_next = NULL;
 			generic_make_request(bio);
 			bio = next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else
 		spin_unlock_irq(&conf->device_lock);
@@ -1914,6 +1936,11 @@ static void fix_read_error(struct r10con
 		start = sl;
 		/* write it back and re-read */
 		rcu_read_lock();
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sl != r10_bio->read_slot) {
 			char b[BDEVNAME_SIZE];
 
@@ -1949,8 +1976,19 @@ static void fix_read_error(struct r10con
 			}
 			rdev_dec_pending(rdev, mddev);
 			rcu_read_lock();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		sl = start;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sl != r10_bio->read_slot) {
 			char b[BDEVNAME_SIZE];
 
@@ -1998,6 +2036,12 @@ static void fix_read_error(struct r10con
 
 			rdev_dec_pending(rdev, mddev);
 			rcu_read_lock();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		rcu_read_unlock();
 
@@ -2057,6 +2101,11 @@ static int narrow_write_error(struct r10
 		   & ~(sector_t)(block_sectors - 1))
 		- sector;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sect_to_write) {
 		struct bio *wbio;
 		if (sectors > sect_to_write)
@@ -2078,6 +2127,12 @@ static int narrow_write_error(struct r10
 		sect_to_write -= sectors;
 		sector += sectors;
 		sectors = block_sectors;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return ok;
 }
@@ -2594,11 +2649,22 @@ static sector_t sync_request(struct mdde
 			}
 		}
 		if (biolist == NULL) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (r10_bio) {
 				struct r10bio *rb2 = r10_bio;
 				r10_bio = (struct r10bio*) rb2->master_bio;
 				rb2->master_bio = NULL;
 				put_buf(rb2);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			goto giveup;
 		}
@@ -2726,6 +2792,11 @@ static sector_t sync_request(struct mdde
  bio_full:
 	r10_bio->sectors = nr_sectors;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (biolist) {
 		bio = biolist;
 		biolist = biolist->bi_next;
@@ -2738,6 +2809,12 @@ static sector_t sync_request(struct mdde
 			md_sync_acct(bio->bi_bdev, nr_sectors);
 			generic_make_request(bio);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (sectors_skipped)
diff -u -p a/md/dm-mpath.c b/md/dm-mpath.c
--- a/md/dm-mpath.c
+++ b/md/dm-mpath.c
@@ -830,6 +830,11 @@ static int multipath_ctr(struct dm_targe
 	}
 
 	/* parse the priority groups */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (as.argc) {
 		struct priority_group *pg;
 
@@ -845,6 +850,12 @@ static int multipath_ctr(struct dm_targe
 		pg->pg_num = pg_count;
 		if (!--next_pg_num)
 			m->next_pg = pg;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (pg_count != m->nr_priority_groups) {
diff -u -p a/md/persistent-data/dm-space-map-common.c b/md/persistent-data/dm-space-map-common.c
--- a/md/persistent-data/dm-space-map-common.c
+++ b/md/persistent-data/dm-space-map-common.c
@@ -168,6 +168,11 @@ static void sm_set_bitmap(void *addr, un
 static int sm_find_free(void *addr, unsigned begin, unsigned end,
 			unsigned *result)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (begin < end) {
 		if (!(begin & (ENTRIES_PER_WORD - 1)) &&
 		    bitmap_word_used(addr, begin)) {
@@ -181,6 +186,12 @@ static int sm_find_free(void *addr, unsi
 		}
 
 		begin++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -ENOSPC;
diff -u -p a/md/persistent-data/dm-btree.c b/md/persistent-data/dm-btree.c
--- a/md/persistent-data/dm-btree.c
+++ b/md/persistent-data/dm-btree.c
@@ -246,6 +246,11 @@ int dm_btree_del(struct dm_btree_info *i
 	if (r)
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (unprocessed_frames(s)) {
 		uint32_t flags;
 		struct frame *f;
@@ -285,7 +290,13 @@ int dm_btree_del(struct dm_btree_info *i
 			}
 			f->current_child = f->nr_children;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	kfree(s);
diff -u -p a/md/dm-kcopyd.c b/md/dm-kcopyd.c
--- a/md/dm-kcopyd.c
+++ b/md/dm-kcopyd.c
@@ -158,10 +158,21 @@ static void drop_pages(struct page_list
 {
 	struct page_list *next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pl) {
 		next = pl->next;
 		free_pl(pl);
 		pl = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/md/dm-bufio.c b/md/dm-bufio.c
--- a/md/dm-bufio.c
+++ b/md/dm-bufio.c
@@ -744,6 +744,11 @@ static struct dm_buffer *__alloc_buffer_
 	 * For debugging, if we set the cache size to 1, no new buffers will
 	 * be allocated.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (dm_bufio_cache_size_latch != 1) {
 			b = alloc_buffer(c, GFP_NOIO | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);
@@ -765,6 +770,12 @@ static struct dm_buffer *__alloc_buffer_
 			return b;
 
 		__wait_for_free_buffer(c);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -852,6 +863,11 @@ static void __check_watermark(struct dm_
 
 	__get_memory_limit(c, &threshold_buffers, &limit_buffers);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (c->n_buffers[LIST_CLEAN] + c->n_buffers[LIST_DIRTY] >
 	       limit_buffers) {
 
@@ -862,6 +878,12 @@ static void __check_watermark(struct dm_
 
 		__free_buffer_wake(b);
 		dm_bufio_cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (c->n_buffers[LIST_DIRTY] > threshold_buffers)
@@ -1472,6 +1494,11 @@ struct dm_bufio_client *dm_bufio_client_
 	}
 	mutex_unlock(&dm_bufio_clients_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (c->need_reserved_buffers) {
 		struct dm_buffer *b = alloc_buffer(c, GFP_KERNEL);
 
@@ -1480,6 +1507,12 @@ struct dm_bufio_client *dm_bufio_client_
 			goto bad_buffer;
 		}
 		__free_buffer_wake(b);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_lock(&dm_bufio_clients_lock);
@@ -1497,11 +1530,22 @@ struct dm_bufio_client *dm_bufio_client_
 
 bad_buffer:
 bad_cache:
-	while (!list_empty(&c->reserved_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&c->reserved_buffers)) {
 		struct dm_buffer *b = list_entry(c->reserved_buffers.next,
 						 struct dm_buffer, lru_list);
 		list_del(&b->lru_list);
 		free_buffer(b);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	dm_io_client_destroy(c->dm_io);
 bad_dm_io:
@@ -1538,11 +1582,22 @@ void dm_bufio_client_destroy(struct dm_b
 
 	BUG_ON(c->need_reserved_buffers);
 
-	while (!list_empty(&c->reserved_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&c->reserved_buffers)) {
 		struct dm_buffer *b = list_entry(c->reserved_buffers.next,
 						 struct dm_buffer, lru_list);
 		list_del(&b->lru_list);
 		free_buffer(b);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i < LIST_SIZE; i++)
diff -u -p a/md/dm-flakey.c b/md/dm-flakey.c
--- a/md/dm-flakey.c
+++ b/md/dm-flakey.c
@@ -61,6 +61,11 @@ static int parse_features(struct dm_arg_
 	if (r)
 		return r;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (argc) {
 		arg_name = dm_shift_arg(as);
 		argc--;
@@ -126,6 +131,12 @@ static int parse_features(struct dm_arg_
 
 		ti->error = "Unrecognised flakey feature requested";
 		return -EINVAL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (test_bit(DROP_WRITES, &fc->flags) && (fc->corrupt_bio_rw == WRITE)) {
diff -u -p a/md/dm-raid1.c b/md/dm-raid1.c
--- a/md/dm-raid1.c
+++ b/md/dm-raid1.c
@@ -383,10 +383,21 @@ static void do_recovery(struct mirror_se
 	/*
 	 * Copy any already quiesced regions.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((reg = dm_rh_recovery_start(ms->rh))) {
 		r = recover(ms, reg);
 		if (r)
 			dm_rh_recovery_end(reg, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+		}
 	}
 
 	/*
@@ -550,6 +561,11 @@ static void do_reads(struct mirror_set *
 	struct bio *bio;
 	struct mirror *m;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((bio = bio_list_pop(reads))) {
 		region = dm_rh_bio_to_region(ms->rh, bio);
 		m = get_default_mirror(ms);
@@ -566,6 +582,12 @@ static void do_reads(struct mirror_set *
 			read_async_bio(m, bio);
 		else
 			bio_endio(bio, -EIO);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -673,6 +695,11 @@ static void do_writes(struct mirror_set
 	bio_list_init(&recover);
 	bio_list_init(&requeue);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((bio = bio_list_pop(writes))) {
 		if ((bio->bi_rw & REQ_FLUSH) ||
 		    (bio->bi_rw & REQ_DISCARD)) {
@@ -705,6 +732,12 @@ static void do_writes(struct mirror_set
 		}
 
 		bio_list_add(this_list, bio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -748,6 +781,11 @@ static void do_writes(struct mirror_set
 	while ((bio = bio_list_pop(&recover)))
 		dm_rh_delay(ms->rh, bio);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((bio = bio_list_pop(&nosync))) {
 		if (unlikely(ms->leg_failure) && errors_handled(ms)) {
 			spin_lock_irq(&ms->lock);
@@ -758,6 +796,12 @@ static void do_writes(struct mirror_set
 			map_bio(get_default_mirror(ms), bio);
 			generic_make_request(bio);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -785,6 +829,11 @@ static void do_failures(struct mirror_se
 	 * for us to treat them the same and requeue them
 	 * as well.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((bio = bio_list_pop(failures))) {
 		if (!ms->log_failure) {
 			ms->in_sync = 0;
@@ -805,6 +854,12 @@ static void do_failures(struct mirror_se
 			hold_bio(ms, bio);
 		else
 			bio_endio(bio, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/md/linear.c b/md/linear.c
--- a/md/linear.c
+++ b/md/linear.c
@@ -40,6 +40,11 @@ static inline struct dev_info *which_dev
 	 * Binary Search
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hi > lo) {
 
 		mid = (hi + lo) / 2;
@@ -47,6 +52,12 @@ static inline struct dev_info *which_dev
 			hi = mid;
 		else
 			lo = mid + 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return conf->disks + lo;
diff -u -p a/md/dm-delay.c b/md/dm-delay.c
--- a/md/dm-delay.c
+++ b/md/dm-delay.c
@@ -69,11 +69,22 @@ static void flush_bios(struct bio *bio)
 {
 	struct bio *n;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bio) {
 		n = bio->bi_next;
 		bio->bi_next = NULL;
 		generic_make_request(bio);
 		bio = n;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/of/fdt.c b/of/fdt.c
--- a/of/fdt.c
+++ b/of/fdt.c
@@ -114,11 +114,22 @@ int of_fdt_match(struct boot_param_heade
 	if (!compat)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*compat) {
 		tmp = of_fdt_is_compatible(blob, node, *compat);
 		if (tmp && (score == 0 || (tmp < score)))
 			score = tmp;
 		compat++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return score;
@@ -291,12 +302,23 @@ static unsigned long unflatten_dt_node(s
 		char *p1 = pathp, *ps = pathp, *pa = NULL;
 		int sz;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (*p1) {
 			if ((*p1) == '@')
 				pa = p1;
 			if ((*p1) == '/')
 				ps = p1 + 1;
 			p1++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (pa < ps)
 			pa = p1;
@@ -647,6 +669,11 @@ int __init early_init_dt_scan_memory(uns
 	pr_debug("memory scan node %s, reg size %ld, data: %x %x %x %x,\n",
 	    uname, l, reg[0], reg[1], reg[2], reg[3]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
 		u64 base, size;
 
@@ -659,6 +686,12 @@ int __init early_init_dt_scan_memory(uns
 		    (unsigned long long)size);
 
 		early_init_dt_add_memory_arch(base, size);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
diff -u -p a/of/irq.c b/of/irq.c
--- a/of/irq.c
+++ b/of/irq.c
@@ -188,6 +188,11 @@ int of_irq_map_raw(struct device_node *p
 
 		/* Parse interrupt-map */
 		match = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (imaplen > (addrsize + intsize + 1) && !match) {
 			/* Compare specifiers */
 			match = 1;
@@ -242,6 +247,12 @@ int of_irq_map_raw(struct device_node *p
 			imaplen -= newaddrsize + newintsize;
 
 			pr_debug(" -> imaplen=%d\n", imaplen);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!match)
 			goto fail;
diff -u -p a/of/pdt.c b/of/pdt.c
--- a/of/pdt.c
+++ b/of/pdt.c
@@ -145,10 +145,21 @@ static struct property * __init of_pdt_b
 
 	tail->next = of_pdt_build_one_prop(node, NULL, NULL, NULL, 0);
 	tail = tail->next;
-	while(tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(tail) {
 		tail->next = of_pdt_build_one_prop(node, tail->name,
 					    NULL, NULL, 0);
 		tail = tail->next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return head;
diff -u -p a/of/address.c b/of/address.c
--- a/of/address.c
+++ b/of/address.c
@@ -589,12 +589,23 @@ struct device_node *of_find_matching_nod
 	struct device_node *dn = of_find_matching_node(from, matches);
 	struct resource res;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dn) {
 		if (of_address_to_resource(dn, 0, &res))
 			continue;
 		if (res.start == base_address)
 			return dn;
 		dn = of_find_matching_node(dn, matches);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/of/base.c b/of/base.c
--- a/of/base.c
+++ b/of/base.c
@@ -132,6 +132,11 @@ static void of_node_release(struct kref
 	if (!of_node_check_flag(node, OF_DYNAMIC))
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (prop) {
 		struct property *next = prop->next;
 		kfree(prop->name);
@@ -143,6 +148,12 @@ static void of_node_release(struct kref
 			prop = node->deadprops;
 			node->deadprops = NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(node->full_name);
 	kfree(node->data);
@@ -524,6 +535,11 @@ const struct of_device_id *of_match_node
 	if (!matches)
 		return NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
 		int match = 1;
 		if (matches->name[0])
@@ -538,6 +554,12 @@ const struct of_device_id *of_match_node
 		if (match)
 			return matches;
 		matches++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -951,6 +973,11 @@ int prom_add_property(struct device_node
 	prop->next = NULL;
 	write_lock_irqsave(&devtree_lock, flags);
 	next = &np->properties;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*next) {
 		if (strcmp(prop->name, (*next)->name) == 0) {
 			/* duplicate ! don't insert it */
@@ -958,6 +985,12 @@ int prom_add_property(struct device_node
 			return -1;
 		}
 		next = &(*next)->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*next = prop;
 	write_unlock_irqrestore(&devtree_lock, flags);
diff -u -p a/w1/w1.c b/w1/w1.c
--- a/w1/w1.c
+++ b/w1/w1.c
@@ -83,11 +83,22 @@ static void w1_slave_release(struct devi
 
 	dev_dbg(dev, "%s: Releasing %s.\n", __func__, sl->name);
 
-	while (atomic_read(&sl->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&sl->refcnt)) {
 		dev_dbg(dev, "Waiting for %s to become free: refcnt=%d.\n",
 				sl->name, atomic_read(&sl->refcnt));
 		if (msleep_interruptible(1000))
 			flush_signals(current);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	w1_family_put(sl->family);
diff -u -p a/w1/w1_int.c b/w1/w1_int.c
--- a/w1/w1_int.c
+++ b/w1/w1_int.c
@@ -211,12 +211,23 @@ void __w1_remove_master_device(struct w1
 	mutex_unlock(&dev->mutex);
 	atomic_dec(&dev->refcnt);
 
-	while (atomic_read(&dev->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&dev->refcnt)) {
 		dev_info(&dev->dev, "Waiting for %s to become free: refcnt=%d.\n",
 				dev->name, atomic_read(&dev->refcnt));
 
 		if (msleep_interruptible(1000))
 			flush_signals(current);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	memset(&msg, 0, sizeof(msg));
diff -u -p a/w1/masters/omap_hdq.c b/w1/masters/omap_hdq.c
--- a/w1/masters/omap_hdq.c
+++ b/w1/masters/omap_hdq.c
@@ -134,17 +134,39 @@ static int hdq_wait_for_flag(struct hdq_
 
 	if (flag_set == OMAP_HDQ_FLAG_CLEAR) {
 		/* wait for the flag clear */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (((*status = hdq_reg_in(hdq_data, offset)) & flag)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if (*status & flag)
 			ret = -ETIMEDOUT;
 	} else if (flag_set == OMAP_HDQ_FLAG_SET) {
 		/* wait for the flag set */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!((*status = hdq_reg_in(hdq_data, offset)) & flag)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!(*status & flag))
 			ret = -ETIMEDOUT;
@@ -375,10 +397,21 @@ static int hdq_read_byte(struct hdq_data
 		 * triggers another interrupt before we
 		 * sleep. So we have to wait for RXCOMPLETE bit.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(hdq_data->hdq_irqstatus
 			& OMAP_HDQ_INT_STATUS_RXCOMPLETE)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		hdq_reg_merge(hdq_data, OMAP_HDQ_CTRL_STATUS, 0,
 			OMAP_HDQ_CTRL_STATUS_DIR);
diff -u -p a/w1/slaves/w1_ds2433.c b/w1/slaves/w1_ds2433.c
--- a/w1/slaves/w1_ds2433.c
+++ b/w1/slaves/w1_ds2433.c
@@ -237,6 +237,11 @@ static ssize_t w1_f23_write_bin(struct f
 
 	/* Can only write data to one page at a time */
 	idx = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (idx < count) {
 		addr = off + idx;
 		len = W1_PAGE_SIZE - (addr & W1_PAGE_MASK);
@@ -248,7 +253,13 @@ static ssize_t w1_f23_write_bin(struct f
 			goto out_up;
 		}
 		idx += len;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out_up:
 	mutex_unlock(&sl->master->mutex);
diff -u -p a/w1/w1_family.c b/w1/w1_family.c
--- a/w1/w1_family.c
+++ b/w1/w1_family.c
@@ -78,12 +78,23 @@ void w1_unregister_family(struct w1_fami
 	/* deatch devices using this family code */
 	w1_reconnect_slaves(fent, 0);
 
-	while (atomic_read(&fent->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&fent->refcnt)) {
 		printk(KERN_INFO "Waiting for family %u to become free: refcnt=%d.\n",
 				fent->fid, atomic_read(&fent->refcnt));
 
 		if (msleep_interruptible(1000))
 			flush_signals(current);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/sh/intc/handle.c b/sh/intc/handle.c
--- a/sh/intc/handle.c
+++ b/sh/intc/handle.c
@@ -45,6 +45,11 @@ static unsigned int __init _intc_mask_da
 	unsigned int fn, mode;
 	unsigned long reg_e, reg_d;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mr && enum_id && *reg_idx < desc->hw.nr_mask_regs) {
 		mr = desc->hw.mask_regs + *reg_idx;
 
@@ -80,6 +85,12 @@ static unsigned int __init _intc_mask_da
 
 		*fld_idx = 0;
 		(*reg_idx)++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -113,6 +124,11 @@ static unsigned int __init _intc_prio_da
 	unsigned int fn, n, mode, bit;
 	unsigned long reg_e, reg_d;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pr && enum_id && *reg_idx < desc->hw.nr_prio_regs) {
 		pr = desc->hw.prio_regs + *reg_idx;
 
@@ -149,6 +165,12 @@ static unsigned int __init _intc_prio_da
 
 		*fld_idx = 0;
 		(*reg_idx)++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/sh/superhyway/superhyway.c b/sh/superhyway/superhyway.c
--- a/sh/superhyway/superhyway.c
+++ b/sh/superhyway/superhyway.c
@@ -124,11 +124,22 @@ static const struct superhyway_device_id
 superhyway_match_id(const struct superhyway_device_id *ids,
 		    struct superhyway_device *dev)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ids->id) {
 		if (ids->id == dev->id.id)
 			return ids;
 
 		ids++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/tc/tc-driver.c b/tc/tc-driver.c
--- a/tc/tc-driver.c
+++ b/tc/tc-driver.c
@@ -62,11 +62,22 @@ const struct tc_device_id *tc_match_devi
 	const struct tc_device_id *id = tdrv->id_table;
 
 	if (id) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (id->name[0] || id->vendor[0]) {
 			if (strcmp(tdev->name, id->name) == 0 &&
 			    strcmp(tdev->vendor, id->vendor) == 0)
 				return id;
 			id++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return NULL;
diff -u -p a/ata/libata-core.c b/ata/libata-core.c
--- a/ata/libata-core.c
+++ b/ata/libata-core.c
@@ -3371,6 +3371,11 @@ int ata_wait_ready(struct ata_link *link
 	if (time_after(nodev_deadline, deadline))
 		nodev_deadline = deadline;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		unsigned long now = jiffies;
 		int ready, tmp;
@@ -3413,6 +3418,12 @@ int ata_wait_ready(struct ata_link *link
 		}
 
 		ata_msleep(link->ap, 50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -3480,6 +3491,11 @@ int sata_link_debounce(struct ata_link *
 	last = cur;
 	last_jiffies = jiffies;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		ata_msleep(link->ap, interval);
 		if ((rc = sata_scr_read(link, SCR_STATUS, &cur)))
@@ -3505,6 +3521,12 @@ int sata_link_debounce(struct ata_link *
 		 */
 		if (time_after(jiffies, deadline))
 			return -EPIPE;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -4231,10 +4253,21 @@ static int glob_match (const char *text,
 		if (!*++pattern)
 			return 0;  /* Match: avoid recursion at end of pattern */
 		/* Loop to handle additional pattern chars after the wildcard */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (*text) {
 			if (glob_match(text, pattern) == 0)
 				return 0;  /* Remainder matched */
 			++text;  /* Absorb (match) this char and try again */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (!*text && !*pattern)
@@ -4251,6 +4284,11 @@ static unsigned long ata_dev_blacklisted
 	ata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));
 	ata_id_c_string(dev->id, model_rev, ATA_ID_FW_REV, sizeof(model_rev));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ad->model_num) {
 		if (!glob_match(model_num, ad->model_num)) {
 			if (ad->model_rev == NULL)
@@ -4259,6 +4297,12 @@ static unsigned long ata_dev_blacklisted
 				return ad->horkage;
 		}
 		ad++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return 0;
 }
@@ -4988,6 +5032,11 @@ int ata_qc_complete_multiple(struct ata_
 		return -EINVAL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (done_mask) {
 		struct ata_queued_cmd *qc;
 		unsigned int tag = __ffs(done_mask);
@@ -4998,6 +5047,12 @@ int ata_qc_complete_multiple(struct ata_
 			nr_done++;
 		}
 		done_mask &= ~(1 << tag);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return nr_done;
@@ -6596,9 +6651,20 @@ u32 ata_wait_register(struct ata_port *a
 	 */
 	deadline = ata_deadline(jiffies, timeout);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((tmp & mask) == val && time_before(jiffies, deadline)) {
 		ata_msleep(ap, interval);
 		tmp = ioread32(reg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return tmp;
diff -u -p a/ata/pata_samsung_cf.c b/ata/pata_samsung_cf.c
--- a/ata/pata_samsung_cf.c
+++ b/ata/pata_samsung_cf.c
@@ -116,9 +116,20 @@ static int wait_for_host_ready(struct s3
 
 	/* wait for maximum of 20 msec */
 	timeout = jiffies + msecs_to_jiffies(20);
-	while (time_before(jiffies, timeout)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (time_before(jiffies, timeout)) {
 		if ((readl(fifo_reg) >> 28) == 0)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return -EBUSY;
 }
diff -u -p a/ata/sata_dwc_460ex.c b/ata/sata_dwc_460ex.c
--- a/ata/sata_dwc_460ex.c
+++ b/ata/sata_dwc_460ex.c
@@ -1075,11 +1075,27 @@ DRVSTILLBUSY:
 
 	tag = 0;
 	num_processed = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tag_mask) {
 		num_processed++;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(tag_mask & 0x00000001)) {
 			tag++;
 			tag_mask <<= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		tag_mask &= (~0x00000001);
@@ -1119,6 +1135,12 @@ STILLBUSY:
 		ap->stats.idle_irq++;
 		dev_warn(ap->dev, "STILL BUSY IRQ ata%d: irq trap\n",
 			ap->print_id);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	} /* while tag_mask */
 
 	/*
diff -u -p a/ata/pata_hpt366.c b/ata/pata_hpt366.c
--- a/ata/pata_hpt366.c
+++ b/ata/pata_hpt366.c
@@ -124,10 +124,21 @@ static u32 hpt36x_find_mode(struct ata_p
 {
 	struct hpt_clock *clocks = ap->host->private_data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (clocks->xfer_mode) {
 		if (clocks->xfer_mode == speed)
 			return clocks->timing;
 		clocks++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	BUG();
 	return 0xffffffffU;	/* silence compiler warning */
diff -u -p a/ata/pata_hpt37x.c b/ata/pata_hpt37x.c
--- a/ata/pata_hpt37x.c
+++ b/ata/pata_hpt37x.c
@@ -212,10 +212,21 @@ static u32 hpt37x_find_mode(struct ata_p
 {
 	struct hpt_clock *clocks = ap->host->private_data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (clocks->xfer_speed) {
 		if (clocks->xfer_speed == speed)
 			return clocks->timing;
 		clocks++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	BUG();
 	return 0xffffffffU;	/* silence compiler warning */
diff -u -p a/ata/pata_macio.c b/ata/pata_macio.c
--- a/ata/pata_macio.c
+++ b/ata/pata_macio.c
@@ -535,6 +535,11 @@ static void pata_macio_qc_prep(struct at
 		addr = (u32) sg_dma_address(sg);
 		sg_len = sg_dma_len(sg);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sg_len) {
 			/* table overflow should never happen */
 			BUG_ON (pi++ >= MAX_DCMDS);
@@ -549,6 +554,12 @@ static void pata_macio_qc_prep(struct at
 			addr += len;
 			sg_len -= len;
 			++table;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/ata/pata_hpt3x2n.c b/ata/pata_hpt3x2n.c
--- a/ata/pata_hpt3x2n.c
+++ b/ata/pata_hpt3x2n.c
@@ -105,10 +105,21 @@ static u32 hpt3x2n_find_mode(struct ata_
 {
 	struct hpt_clock *clocks = hpt3x2n_clocks;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (clocks->xfer_speed) {
 		if (clocks->xfer_speed == speed)
 			return clocks->timing;
 		clocks++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	BUG();
 	return 0xffffffffU;	/* silence compiler warning */
diff -u -p a/ata/ata_piix.c b/ata/ata_piix.c
--- a/ata/ata_piix.c
+++ b/ata/ata_piix.c
@@ -758,6 +758,11 @@ static int ich_pata_cable_detect(struct
 	u8 mask;
 
 	/* Check for specials - Acer Aspire 5602WLMi */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lap->device) {
 		if (lap->device == pdev->device &&
 		    lap->subvendor == pdev->subsystem_vendor &&
@@ -765,6 +770,12 @@ static int ich_pata_cable_detect(struct
 			return ATA_CBL_PATA40_SHORT;
 
 		lap++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* check BIOS cable detect results */
diff -u -p a/ata/sata_promise.c b/ata/sata_promise.c
--- a/ata/sata_promise.c
+++ b/ata/sata_promise.c
@@ -611,6 +611,11 @@ static void pdc_fill_sg(struct ata_queue
 		addr = (u32) sg_dma_address(sg);
 		sg_len = sg_dma_len(sg);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -624,6 +629,12 @@ static void pdc_fill_sg(struct ata_queue
 			idx++;
 			sg_len -= len;
 			addr += len;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/ata/pata_serverworks.c b/ata/pata_serverworks.c
--- a/ata/pata_serverworks.c
+++ b/ata/pata_serverworks.c
@@ -105,6 +105,11 @@ static int serverworks_cable_detect(stru
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 	struct sv_cable_table *cb = cable_detect;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(cb->device) {
 		if (cb->device == pdev->device &&
 		    (cb->subvendor == pdev->subsystem_vendor ||
@@ -112,6 +117,12 @@ static int serverworks_cable_detect(stru
 			return cb->cable_detect(ap);
 		}
 		cb++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	BUG();
diff -u -p a/ata/sata_sx4.c b/ata/sata_sx4.c
--- a/ata/sata_sx4.c
+++ b/ata/sata_sx4.c
@@ -1394,10 +1394,21 @@ static unsigned int pdc20621_dimm_init(s
 		addr = 0;
 		length = size * 1024 * 1024;
 		buf = kzalloc(ECC_ERASE_BUF_SZ, GFP_KERNEL);
-		while (addr < length) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (addr < length) {
 			pdc20621_put_to_dimm(host, buf, addr,
 					     ECC_ERASE_BUF_SZ);
 			addr += ECC_ERASE_BUF_SZ;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		kfree(buf);
 		VPRINTK("Finish ECC initialization\n");
diff -u -p a/ata/libata-eh.c b/ata/libata-eh.c
--- a/ata/libata-eh.c
+++ b/ata/libata-eh.c
@@ -847,11 +847,22 @@ void ata_port_wait_eh(struct ata_port *a
  retry:
 	spin_lock_irqsave(ap->lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ap->pflags & (ATA_PFLAG_EH_PENDING | ATA_PFLAG_EH_IN_PROGRESS)) {
 		prepare_to_wait(&ap->eh_wait_q, &wait, TASK_UNINTERRUPTIBLE);
 		spin_unlock_irqrestore(ap->lock, flags);
 		schedule();
 		spin_lock_irqsave(ap->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	finish_wait(&ap->eh_wait_q, &wait);
 
diff -u -p a/ata/pata_mpc52xx.c b/ata/pata_mpc52xx.c
--- a/ata/pata_mpc52xx.c
+++ b/ata/pata_mpc52xx.c
@@ -458,6 +458,11 @@ mpc52xx_ata_build_dmatable(struct ata_qu
 		dma_addr_t cur_addr = sg_dma_address(sg);
 		u32 cur_len = sg_dma_len(sg);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cur_len) {
 			unsigned int tc = min(cur_len, MAX_DMA_BUFFER_SIZE);
 			bd = (struct bcom_ata_bd *)
@@ -486,6 +491,12 @@ mpc52xx_ata_build_dmatable(struct ata_qu
 					"too small\n");
 				goto use_pio_instead;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 1;
diff -u -p a/ata/pata_ns87415.c b/ata/pata_ns87415.c
--- a/ata/pata_ns87415.c
+++ b/ata/pata_ns87415.c
@@ -82,9 +82,20 @@ static void ns87415_set_mode(struct ata_
 	   but if so wait */
 
 	pci_read_config_byte(dev, 0x43, &status);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & 0x03) {
 		udelay(1);
 		pci_read_config_byte(dev, 0x43, &status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Flip the IORDY/DMA bits now we are sure the write buffers are
 	   clear */
diff -u -p a/ata/pata_sis.c b/ata/pata_sis.c
--- a/ata/pata_sis.c
+++ b/ata/pata_sis.c
@@ -64,12 +64,23 @@ static int sis_short_ata40(struct pci_de
 {
 	const struct sis_laptop *lap = &sis_laptop[0];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lap->device) {
 		if (lap->device == dev->device &&
 		    lap->subvendor == dev->subsystem_vendor &&
 		    lap->subdevice == dev->subsystem_device)
 			return 1;
 		lap++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/ata/pata_arasan_cf.c b/ata/pata_arasan_cf.c
--- a/ata/pata_arasan_cf.c
+++ b/ata/pata_arasan_cf.c
@@ -454,7 +454,12 @@ static int sg_xfer(struct arasan_cf_dev
 	 * buffer available interrupt will be generated. At this time we will
 	 * fill FIFO again: max FIFO_SIZE data.
 	 */
-	while (sglen) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sglen) {
 		xfer_cnt = min(sglen, MAX_XFER_COUNT);
 		spin_lock_irqsave(&acdev->host->lock, flags);
 		xfer_ctr = readl(acdev->vbase + XFER_CTR) &
@@ -464,6 +469,11 @@ static int sg_xfer(struct arasan_cf_dev
 		spin_unlock_irqrestore(&acdev->host->lock, flags);
 
 		/* continue dma xfers until current sg is completed */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (xfer_cnt) {
 			/* wait for read to complete */
 			if (!write) {
@@ -494,8 +504,20 @@ static int sg_xfer(struct arasan_cf_dev
 				if (ret)
 					goto fail;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
-	}
+}
 
 fail:
 	spin_lock_irqsave(&acdev->host->lock, flags);
diff -u -p a/ata/sata_mv.c b/ata/sata_mv.c
--- a/ata/sata_mv.c
+++ b/ata/sata_mv.c
@@ -1765,6 +1765,11 @@ static void mv_fill_sg(struct ata_queued
 		dma_addr_t addr = sg_dma_address(sg);
 		u32 sg_len = sg_dma_len(sg);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sg_len) {
 			u32 offset = addr & 0xffff;
 			u32 len = sg_len;
@@ -1782,6 +1787,12 @@ static void mv_fill_sg(struct ata_queued
 
 			last_sg = mv_sg;
 			mv_sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -2781,6 +2792,11 @@ static void mv_process_crpb_entries(stru
 			>> EDMA_RSP_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK;
 
 	/* Process new responses from since the last time we looked */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (in_index != pp->resp_idx) {
 		unsigned int tag;
 		struct mv_crpb *response = &pp->crpb[pp->resp_idx];
@@ -2797,6 +2813,12 @@ static void mv_process_crpb_entries(stru
 		if (mv_process_crpb_response(ap, response, tag, ncq_enabled))
 			done_mask |= 1 << tag;
 		work_done = true;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (work_done) {
diff -u -p a/ata/sata_nv.c b/ata/sata_nv.c
--- a/ata/sata_nv.c
+++ b/ata/sata_nv.c
@@ -1010,7 +1010,12 @@ static irqreturn_t nv_adma_interrupt(int
 			}
 
 			/* check CPBs for completed commands */
-			while ((pos = ffs(check_commands))) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((pos = ffs(check_commands))) {
 				pos--;
 				rc = nv_adma_check_cpb(ap, pos,
 						notifier_error & (1 << pos));
@@ -1019,6 +1024,12 @@ static irqreturn_t nv_adma_interrupt(int
 				else if (unlikely(rc < 0))
 					check_commands = 0;
 				check_commands &= ~(1 << pos);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			ata_qc_complete_multiple(ap, ap->qc_active ^ done_mask);
 		}
@@ -2021,6 +2032,11 @@ static void nv_swncq_fill_sg(struct ata_
 		addr = (u32)sg_dma_address(sg);
 		sg_len = sg_dma_len(sg);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -2033,6 +2049,12 @@ static void nv_swncq_fill_sg(struct ata_
 			idx++;
 			sg_len -= len;
 			addr += len;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/ata/libata-sff.c b/ata/libata-sff.c
--- a/ata/libata-sff.c
+++ b/ata/libata-sff.c
@@ -2657,6 +2657,11 @@ static void ata_bmdma_fill_sg(struct ata
 		addr = (u32) sg_dma_address(sg);
 		sg_len = sg_dma_len(sg);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -2670,6 +2675,12 @@ static void ata_bmdma_fill_sg(struct ata
 			pi++;
 			sg_len -= len;
 			addr += len;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -2708,6 +2719,11 @@ static void ata_bmdma_fill_sg_dumb(struc
 		addr = (u32) sg_dma_address(sg);
 		sg_len = sg_dma_len(sg);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sg_len) {
 			offset = addr & 0xffff;
 			len = sg_len;
@@ -2730,6 +2746,12 @@ static void ata_bmdma_fill_sg_dumb(struc
 			pi++;
 			sg_len -= len;
 			addr += len;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/atm/he.c b/atm/he.c
--- a/atm/he.c
+++ b/atm/he.c
@@ -1673,6 +1673,11 @@ he_service_rbrq(struct he_dev *he_dev, i
 	int updated = 0;
 
 	read_lock(&vcc_sklist_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (he_dev->rbrq_head != rbrq_tail) {
 		++updated;
 
@@ -1803,6 +1808,12 @@ next_rbrq_entry:
 				((unsigned long) he_dev->rbrq_base |
 					RBRQ_MASK(he_dev->rbrq_head + 1));
 
+				if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	read_unlock(&vcc_sklist_lock);
 
@@ -1829,7 +1840,12 @@ he_service_tbrq(struct he_dev *he_dev, i
 
 	/* 2.1.6 transmit buffer return queue */
 
-	while (he_dev->tbrq_head != tbrq_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (he_dev->tbrq_head != tbrq_tail) {
 		++updated;
 
 		HPRINTK("tbrq%d 0x%x%s%s\n",
@@ -1885,6 +1901,12 @@ next_tbrq_entry:
 		he_dev->tbrq_head = (struct he_tbrq *)
 				((unsigned long) he_dev->tbrq_base |
 					TBRQ_MASK(he_dev->tbrq_head + 1));
+				if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (updated) {
@@ -1954,6 +1976,11 @@ he_tasklet(unsigned long data)
 	HPRINTK("tasklet (0x%lx)\n", data);
 	spin_lock_irqsave(&he_dev->global_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (he_dev->irq_head != he_dev->irq_tail) {
 		++updated;
 
@@ -2015,6 +2042,12 @@ he_tasklet(unsigned long data)
 		he_dev->irq_head->isw = ITYPE_INVALID;
 
 		he_dev->irq_head = (struct he_irq *) NEXT_ENTRY(he_dev->irq_base, he_dev->irq_head, IRQ_MASK);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (updated) {
@@ -2373,9 +2406,20 @@ he_close(struct atm_vcc *vcc)
 		/* wait for previous close (if any) to finish */
 
 		spin_lock_irqsave(&he_dev->global_lock, flags);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (he_readl(he_dev, RCC_STAT) & RCC_BUSY) {
 			HPRINTK("close cid 0x%x RCC_BUSY\n", cid);
 			udelay(250);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		set_current_state(TASK_UNINTERRUPTIBLE);
@@ -2470,9 +2514,20 @@ he_close(struct atm_vcc *vcc)
 			goto close_tx_incomplete;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!((tsr4 = he_readl_tsr4(he_dev, cid)) & TSR4_SESSION_ENDED)) {
 			HPRINTK("close tx cid 0x%x !TSR4_SESSION_ENDED (tsr4 = 0x%x)\n", cid, tsr4);
 			udelay(250);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		while (TSR0_CONN_STATE(tsr0 = he_readl_tsr0(he_dev, cid)) != 0) {
diff -u -p a/atm/iphase.c b/atm/iphase.c
--- a/atm/iphase.c
+++ b/atm/iphase.c
@@ -144,6 +144,11 @@ static void ia_hack_tcq(IADEV *dev) {
   struct ia_vcc         *iavcc_r = NULL; 
 
   tcq_wr = readl(dev->seg_reg+TCQ_WR_PTR) & 0xffff;
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (dev->host_tcq_wr != tcq_wr) {
      desc1 = *(u_short *)(dev->seg_ram + dev->host_tcq_wr);
      if (!desc1) ;
@@ -171,6 +176,12 @@ static void ia_hack_tcq(IADEV *dev) {
      dev->host_tcq_wr += 2;
      if (dev->host_tcq_wr > dev->ffL.tcq_ed) 
         dev->host_tcq_wr = dev->ffL.tcq_st;
+        if (_cur < timeout) {
+              rdstcll(_cur);
+        }
+        else {
+              break;
+        }
   }
 } /* ia_hack_tcq */
 
@@ -186,6 +197,11 @@ static u16 get_desc (IADEV *dev, struct
   if((time_after(jiffies,timer+50)) || ((dev->ffL.tcq_rd==dev->host_tcq_wr))) {
      timer = jiffies; 
      i=0;
+     unsigned long long delta = (cpu / khz / HZ) * 2;
+     unsigned long long _start = 0;
+     unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
      while (i < dev->num_tx_desc) {
         if (!dev->desc_tbl[i].timestamp) {
            i++;
@@ -210,6 +226,12 @@ static u16 get_desc (IADEV *dev, struct
            dev->desc_tbl[i].txskb = NULL;
         }
         i++;
+        if (_cur < timeout) {
+           rdstcll(_cur);
+        }
+        else {
+           break;
+        }
      } /* while */
   }
   if (dev->ffL.tcq_rd == dev->host_tcq_wr) 
@@ -218,6 +240,11 @@ static u16 get_desc (IADEV *dev, struct
   /* Get the next available descriptor number from TCQ */
   desc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (!desc_num || (dev->desc_tbl[desc_num -1]).timestamp) {
      dev->ffL.tcq_rd += 2;
      if (dev->ffL.tcq_rd > dev->ffL.tcq_ed) 
@@ -225,6 +252,12 @@ static u16 get_desc (IADEV *dev, struct
      if (dev->ffL.tcq_rd == dev->host_tcq_wr) 
         return 0xFFFF; 
      desc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);
+     if (_cur < timeout) {
+        rdstcll(_cur);
+     }
+     else {
+        break;
+     }
   }
 
   /* get system time */
@@ -505,6 +538,11 @@ static int ia_cbr_setup (IADEV *dev, str
    fracSlot = 0;
    vcIndex  = vcc->vci;
    IF_CBR(printk("Vci=0x%x,Spacing=0x%x,Sp_mod=0x%x\n",vcIndex,spacing,sp_mod);)
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    while (toBeAssigned)
    {
       // If this is the first time, start the table loading for this connection
@@ -562,6 +600,12 @@ static int ia_cbr_setup (IADEV *dev, str
        memcpy((caddr_t)TstSchedTbl, (caddr_t)&vcIndex, sizeof(*TstSchedTbl));
        dev->CbrRemEntries--;
        toBeAssigned--;
+       if (_cur < timeout) {
+          rdstcll(_cur);
+       }
+       else {
+          break;
+       }
    } /* while */ 
 
    /* IaFFrednCbrEnable */
@@ -663,6 +707,11 @@ static void ia_tx_poll (IADEV *iadev) {
        }
 
        skb1 = skb_dequeue(&iavcc->txing_skb);
+       unsigned long long delta = (cpu / khz / HZ) * 2;
+       unsigned long long _start = 0;
+       unsigned long long _cur = 0;
+       unsigned long long timeout;
+       timeout = rdstcll(start) + delta;
        while (skb1 && (skb1 != skb)) {
           if (!(IA_SKB_STATE(skb1) & IA_TX_DONE)) {
              printk("IA_tx_intr: Vci %d lost pkt!!!\n", vcc->vci);
@@ -677,6 +726,12 @@ static void ia_tx_poll (IADEV *iadev) {
           else 
              dev_kfree_skb_any(skb1);
           skb1 = skb_dequeue(&iavcc->txing_skb);
+          if (_cur < timeout) {
+             rdstcll(_cur);
+          }
+          else {
+             break;
+          }
        }                                                        
        if (!skb1) {
           IF_EVENT(printk("IA: Vci %d - skb not found requed\n",vcc->vci);)
@@ -981,6 +1036,11 @@ static void xdump( u_char*  cp, int  len
     u_char prntBuf[120];
     u_char*  pBuf = prntBuf;
     count = 0;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while(count < length){
         pBuf += sprintf( pBuf, "%s", prefix );
         for(col = 0;count + col < length && col < 16; col++){
@@ -1003,6 +1063,12 @@ static void xdump( u_char*  cp, int  len
         printk("%s\n", prntBuf);
         count += col;
         pBuf = prntBuf;
+        if (_cur < timeout) {
+                rdstcll(_cur);
+        }
+        else {
+                break;
+        }
     }
 
 }  /* close xdump(... */
@@ -1037,10 +1103,21 @@ static void desc_dbg(IADEV *iadev) {
   tcq_ed_ptr =  readw(iadev->seg_reg+TCQ_ED_ADR);
   printk("tcq_st_ptr = 0x%x    tcq_ed_ptr = 0x%x \n", tcq_st_ptr, tcq_ed_ptr);
   i = 0;
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (tcq_st_ptr != tcq_ed_ptr) {
       tmp = iadev->seg_ram+tcq_st_ptr;
       printk("TCQ slot %d desc = %d  Addr = %p\n", i++, readw(tmp), tmp);
       tcq_st_ptr += 2;
+      if (_cur < timeout) {
+  rdstcll(_cur);
+      }
+      else {
+  break;
+      }
   }
   for(i=0; i <iadev->num_tx_desc; i++)
       printk("Desc_tbl[%d] = %d \n", i, iadev->desc_tbl[i].timestamp);
@@ -1224,11 +1301,22 @@ static void rx_intr(struct atm_dev *dev)
 	*/  
 	state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  
         IF_EVENT(printk("Rx intr status: RX_PKT_RCVD %08x\n", status);) 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(!(state & PCQ_EMPTY))  
 	{  
              rx_pkt(dev);  
 	     state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  
-	}  
+	     if (_cur < timeout) {
+	       rdstcll(_cur);
+	     }
+	     else {
+          break;
+        }
+        }  
         iadev->rxing = 1;
   }  
   if (status & RX_FREEQ_EMPT)  
@@ -1287,6 +1375,11 @@ static void rx_dle_intr(struct atm_dev *
   dle = iadev->rx_dle_q.read;  
   dle_lp = readl(iadev->dma+IPHASE5575_RX_LIST_ADDR) & (sizeof(struct dle)*DLE_ENTRIES - 1);  
   cur_dle = (struct dle*)(iadev->rx_dle_q.start + (dle_lp >> 4));  
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while(dle != cur_dle)  
   {  
       /* free the DMAed skb */  
@@ -1353,6 +1446,12 @@ static void rx_dle_intr(struct atm_dev *
 INCR_DLE:
       if (++dle == iadev->rx_dle_q.end)  
     	  dle = iadev->rx_dle_q.start;  
+    	  if (_cur < timeout) {
+        rdstcll(_cur);
+    	  }
+    	  else {
+        break;
+     }
   }  
   iadev->rx_dle_q.read = dle;  
   
@@ -1555,9 +1654,20 @@ static int rx_init(struct atm_dev *dev)
 		*reass_table++ = NO_AAL5_PKT;  
        i = 8*1024;
        vcsize_sel =  0;
+       unsigned long long delta = (cpu / khz / HZ) * 2;
+       unsigned long long _start = 0;
+       unsigned long long _cur = 0;
+       unsigned long long timeout;
+       timeout = rdstcll(start) + delta;
        while (i != iadev->num_vc) {
           i /= 2;
           vcsize_sel++;
+          if (_cur < timeout) {
+       	rdstcll(_cur);
+          }
+          else {
+       	break;
+          }
        }
        i = RX_VC_TABLE * iadev->memSize;
        writew(((i>>3) & 0xfff8) | vcsize_sel, iadev->reass_reg+VC_LKUP_BASE);
@@ -2090,9 +2200,20 @@ static int tx_init(struct atm_dev *dev)
         
         vcsize_sel = 0;
         i = 8*1024;
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (i != iadev->num_vc) {
           i /= 2;
           vcsize_sel++;
+          if (_cur < timeout) {
+        rdstcll(_cur);
+          }
+          else {
+        break;
+          }
         }
  
         i = MAIN_VC_TABLE * iadev->memSize;
@@ -2220,6 +2341,11 @@ static irqreturn_t ia_int(int irq, void
 
    dev = dev_id;  
    iadev = INPH_IA_DEV(dev);  
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    while( (status = readl(iadev->reg+IPHASE5575_BUS_STATUS_REG) & 0x7f))  
    { 
 	handled = 1;
@@ -2252,6 +2378,12 @@ static irqreturn_t ia_int(int irq, void
            if (status & STAT_FEINT) 
                ia_frontend_intr(iadev);
 	}  
+	if (_cur < timeout) {
+               rdstcll(_cur);
+	}
+	else {
+               break;
+	}
    }
    return IRQ_RETVAL(handled);
 }  
@@ -2620,6 +2752,11 @@ static void ia_close(struct atm_vcc *vcc
 	   schedule_timeout(50);
 	   finish_wait(&iadev->timeout_wait, &wait);
            spin_lock_irqsave(&iadev->tx_lock, flags); 
+           unsigned long long delta = (cpu / khz / HZ) * 2;
+           unsigned long long _start = 0;
+           unsigned long long _cur = 0;
+           unsigned long long timeout;
+           timeout = rdstcll(start) + delta;
            while((skb = skb_dequeue(&iadev->tx_backlog))) {
               if (ATM_SKB(skb)->vcc == vcc){ 
                  if (vcc->pop) vcc->pop(vcc, skb);
@@ -2627,6 +2764,12 @@ static void ia_close(struct atm_vcc *vcc
               }
               else 
                  skb_queue_tail(&tmp_tx_backlog, skb);
+                 if (_cur < timeout) {
+                 rdstcll(_cur);
+                 }
+             else {
+                 break;
+             }
            } 
            while((skb = skb_dequeue(&tmp_tx_backlog))) 
              skb_queue_tail(&iadev->tx_backlog, skb);
diff -u -p a/atm/eni.c b/atm/eni.c
--- a/atm/eni.c
+++ b/atm/eni.c
@@ -623,7 +623,12 @@ static inline int rx_vcc(struct atm_vcc
 	eni_vcc = ENI_VCC(vcc);
 	vci_dsc = ENI_DEV(vcc->dev)->vci+vcc->vci*16;
 	EVENT("rx_vcc(1)\n",0,0);
-	while (eni_vcc->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR) >>
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (eni_vcc->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR) >>
 	    MID_VCI_DESCR_SHIFT)) {
 		EVENT("rx_vcc(2: host dsc=0x%lx, nic dsc=0x%lx)\n",
 		    eni_vcc->descr,tmp);
@@ -631,6 +636,12 @@ static inline int rx_vcc(struct atm_vcc
 		    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>
 		    MID_VCI_DESCR_SHIFT));
 		if (ENI_VCC(vcc)->rx(vcc)) return 1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* clear IN_SERVICE flag */
 	writel(readl(vci_dsc) & ~MID_VCI_IN_SERVICE,vci_dsc);
@@ -640,7 +651,12 @@ static inline int rx_vcc(struct atm_vcc
 	 * follows. So we have to loop again to be sure.
 	 */
 	EVENT("rx_vcc(3)\n",0,0);
-	while (ENI_VCC(vcc)->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ENI_VCC(vcc)->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR)
 	    >> MID_VCI_DESCR_SHIFT)) {
 		EVENT("rx_vcc(4: host dsc=0x%lx, nic dsc=0x%lx)\n",
 		    eni_vcc->descr,tmp);
@@ -648,6 +664,12 @@ static inline int rx_vcc(struct atm_vcc
 		    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>
 		    MID_VCI_DESCR_SHIFT));
 		if (ENI_VCC(vcc)->rx(vcc)) return 1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return 0;
 }
@@ -659,6 +681,11 @@ static void poll_rx(struct atm_dev *dev)
 	struct atm_vcc *curr;
 
 	eni_dev = ENI_DEV(dev);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((curr = eni_dev->fast)) {
 		EVENT("poll_rx.fast\n",0,0);
 		if (rx_vcc(curr)) return;
@@ -666,7 +693,18 @@ static void poll_rx(struct atm_dev *dev)
 		ENI_VCC(curr)->next = ENI_VCC_NOS;
 		barrier();
 		ENI_VCC(curr)->servicing--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((curr = eni_dev->slow)) {
 		EVENT("poll_rx.slow\n",0,0);
 		if (rx_vcc(curr)) return;
@@ -674,6 +712,12 @@ static void poll_rx(struct atm_dev *dev)
 		ENI_VCC(curr)->next = ENI_VCC_NOS;
 		barrier();
 		ENI_VCC(curr)->servicing--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -686,6 +730,11 @@ static void get_service(struct atm_dev *
 
 	DPRINTK(">get_service\n");
 	eni_dev = ENI_DEV(dev);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (eni_in(MID_SERV_WRITE) != eni_dev->serv_read) {
 		vci = readl(eni_dev->service+eni_dev->serv_read*4);
 		eni_dev->serv_read = (eni_dev->serv_read+1) & (NR_SERVICE-1);
@@ -718,6 +767,12 @@ static void get_service(struct atm_dev *
 		}
 putting++;
 		ENI_VCC(vcc)->servicing++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/atm/lanai.c b/atm/lanai.c
--- a/atm/lanai.c
+++ b/atm/lanai.c
@@ -1724,11 +1724,22 @@ static void run_service(struct lanai_dev
 	int ntx = 0;
 	u32 wreg = reg_read(lanai, ServWrite_Reg);
 	const u32 *end = lanai->service.start + wreg;
-	while (lanai->service.ptr != end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (lanai->service.ptr != end) {
 		ntx += handle_service(lanai,
 		    le32_to_cpup(lanai->service.ptr++));
 		if (lanai->service.ptr >= lanai->service.end)
 			lanai->service.ptr = lanai->service.start;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 	reg_write(lanai, wreg, ServRead_Reg);
 	if (ntx != 0) {
diff -u -p a/atm/ambassador.c b/atm/ambassador.c
--- a/atm/ambassador.c
+++ b/atm/ambassador.c
@@ -591,17 +591,39 @@ static int command_do (amb_dev * dev, co
     msleep(cq->pending);
     
     // wait for my slot to be reached (all waiters are here or above, until...)
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (ptrs->out != my_slot) {
       PRINTD (DBG_CMD, "wait: command slot (now at %p)", ptrs->out);
       set_current_state(TASK_UNINTERRUPTIBLE);
       schedule();
+      if (_cur < timeout) {
+        rdstcll(_cur);
+      }
+      else {
+        break;
+      }
     }
     
     // wait on my slot (... one gets to its slot, and... )
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (ptrs->out->request != cpu_to_be32 (SRB_COMPLETE)) {
       PRINTD (DBG_CMD, "wait: command slot completion");
       set_current_state(TASK_UNINTERRUPTIBLE);
       schedule();
+      if (_cur < timeout) {
+        rdstcll(_cur);
+      }
+      else {
+        break;
+      }
     }
     
     PRINTD (DBG_CMD, "command complete");
@@ -789,6 +811,11 @@ static void fill_rx_pool (amb_dev * dev,
     return;
   
   rxq = &dev->rxq[pool];
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (rxq->pending < rxq->maximum && rxq->pending < rxq->buffers_wanted) {
     
     struct sk_buff * skb = alloc_skb (rxq->buffer_size, priority);
@@ -808,6 +835,12 @@ static void fill_rx_pool (amb_dev * dev,
     if (rx_give (dev, &rx, pool))
       dev_kfree_skb_any (skb);
     
+      if (_cur < timeout) {
+      rdstcll(_cur);
+      }
+      else {
+      break;
+      }
   }
   
   return;
@@ -924,9 +957,20 @@ static int make_rate (unsigned int rate,
     man = rate;
     
     // invariant: rate = man*2^(exp-31)
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (!(man & (1<<31))) {
       exp = exp - 1;
       man = man<<1;
+      if (_cur < timeout) {
+	rdstcll(_cur);
+      }
+      else {
+	break;
+      }
     }
     
     // man has top bit set
@@ -2031,9 +2075,20 @@ static void __devinit amb_ucode_version
   u32 minor;
   command cmd;
   cmd.request = cpu_to_be32 (SRB_GET_VERSION);
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (command_do (dev, &cmd)) {
     set_current_state(TASK_UNINTERRUPTIBLE);
     schedule();
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
   major = be32_to_cpu (cmd.args.version.major);
   minor = be32_to_cpu (cmd.args.version.minor);
@@ -2047,9 +2102,20 @@ static void __devinit amb_esi (amb_dev *
   command cmd;
   
   cmd.request = cpu_to_be32 (SRB_GET_BIA);
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (command_do (dev, &cmd)) {
     set_current_state(TASK_UNINTERRUPTIBLE);
     schedule();
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
   lower4 = be32_to_cpu (cmd.args.bia.lower4);
   upper2 = be32_to_cpu (cmd.args.bia.upper2);
diff -u -p a/atm/nicstar.c b/atm/nicstar.c
--- a/atm/nicstar.c
+++ b/atm/nicstar.c
@@ -1164,6 +1164,11 @@ static irqreturn_t ns_irq_handler(int ir
 		/* NOTE: the following procedure may keep a raw cell pending until the
 		   next interrupt. As this preliminary support is only meant to
 		   avoid buffer leakage, this is not an issue. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (readl(card->membase + RAWCT) != card->rawch) {
 
 			if (ns_rcqe_islast(card->rawcell)) {
@@ -1180,6 +1185,12 @@ static irqreturn_t ns_irq_handler(int ir
 				card->rawch += NS_RCQE_SIZE;
 				card->rawcell++;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1745,6 +1756,11 @@ static int push_scqe(ns_dev * card, vc_m
 	int index;
 
 	spin_lock_irqsave(&scq->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (scq->tail == scq->next) {
 		if (in_interrupt()) {
 			spin_unlock_irqrestore(&scq->lock, flags);
@@ -1764,6 +1780,12 @@ static int push_scqe(ns_dev * card, vc_m
 			       card->index);
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*scq->next = *tbd;
 	index = (int)(scq->next - scq->base);
@@ -1865,6 +1887,11 @@ static void process_tsq(ns_dev * card)
 	else
 		two_ahead = one_ahead + 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!ns_tsi_isempty(card->tsq.next) || !ns_tsi_isempty(one_ahead) ||
 	       !ns_tsi_isempty(two_ahead))
 		/* At most two empty, as stated in the 77201 errata */
@@ -1872,11 +1899,22 @@ static void process_tsq(ns_dev * card)
 		serviced_entries = 1;
 
 		/* Skip the one or two possible empty entries */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ns_tsi_isempty(card->tsq.next)) {
 			if (card->tsq.next == card->tsq.last)
 				card->tsq.next = card->tsq.base;
 			else
 				card->tsq.next++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+			else {
+				break;
+			}
 		}
 
 		if (!ns_tsi_tmrof(card->tsq.next)) {
@@ -1914,6 +1952,12 @@ static void process_tsq(ns_dev * card)
 			two_ahead = card->tsq.base;
 		else
 			two_ahead = one_ahead + 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (serviced_entries)
@@ -1939,7 +1983,12 @@ static void drain_scq(ns_dev * card, scq
 	i = (int)(scq->tail - scq->base);
 	if (++i == scq->num_entries)
 		i = 0;
-	while (i != pos) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i != pos) {
 		skb = scq->skb[i];
 		XPRINTK("nicstar%d: freeing skb at 0x%p (index %d).\n",
 			card->index, skb, i);
@@ -1958,6 +2007,12 @@ static void drain_scq(ns_dev * card, scq
 		}
 		if (++i == scq->num_entries)
 			i = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	scq->tail = scq->base + pos;
 	spin_unlock_irqrestore(&scq->lock, flags);
@@ -2671,6 +2726,11 @@ static int ns_ioctl(struct atm_dev *dev,
 		btype = (long)arg;	/* a long is the same size as a pointer or bigger */
 		switch (btype) {
 		case NS_BUFTYPE_SMALL:
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (card->sbfqc < card->sbnr.init) {
 				struct sk_buff *sb;
 
@@ -2681,10 +2741,21 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->sbpool.queue, sb);
 				skb_reserve(sb, NS_AAL0_HEADER);
 				push_rxbufs(card, sb);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			break;
 
 		case NS_BUFTYPE_LARGE:
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (card->lbfqc < card->lbnr.init) {
 				struct sk_buff *lb;
 
@@ -2695,10 +2766,21 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->lbpool.queue, lb);
 				skb_reserve(lb, NS_SMBUFSIZE);
 				push_rxbufs(card, lb);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			break;
 
 		case NS_BUFTYPE_HUGE:
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (card->hbpool.count > card->hbnr.init) {
 				struct sk_buff *hb;
 
@@ -2713,7 +2795,18 @@ static int ns_ioctl(struct atm_dev *dev,
 				else
 					dev_kfree_skb_any(hb);
 
+					if (_cur < timeout) {
+					    rdstcll(_cur);
+					}
+					else {
+					    break;
+					}
 			}
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (card->hbpool.count < card->hbnr.init) {
 				struct sk_buff *hb;
 
@@ -2725,10 +2818,21 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->hbpool.queue, hb);
 				card->hbpool.count++;
 				spin_unlock_irqrestore(&card->int_lock, flags);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			break;
 
 		case NS_BUFTYPE_IOVEC:
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (card->iovpool.count > card->iovnr.init) {
 				struct sk_buff *iovb;
 
@@ -2743,7 +2847,18 @@ static int ns_ioctl(struct atm_dev *dev,
 				else
 					dev_kfree_skb_any(iovb);
 
+					if (_cur < timeout) {
+					    rdstcll(_cur);
+					}
+					else {
+					    break;
+					}
 			}
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (card->iovpool.count < card->iovnr.init) {
 				struct sk_buff *iovb;
 
@@ -2755,6 +2870,12 @@ static int ns_ioctl(struct atm_dev *dev,
 				skb_queue_tail(&card->iovpool.queue, iovb);
 				card->iovpool.count++;
 				spin_unlock_irqrestore(&card->int_lock, flags);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			break;
 
diff -u -p a/atm/firestream.c b/atm/firestream.c
--- a/atm/firestream.c
+++ b/atm/firestream.c
@@ -486,9 +486,20 @@ static int make_rate(unsigned int rate,
 		man = rate;
     
 		/* invariant: rate = man*2^(exp-31) */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(man & (1<<31))) {
 			exp = exp - 1;
 			man = man<<1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 		}
     
 		/* man has top bit set
@@ -600,10 +611,21 @@ static void submit_qentry (struct fs_dev
 	/* XXX Sanity check: the write pointer can be checked to be 
 	   still the same as the value passed as qe... -- REW */
 	/*  udelay (5); */
-	while ((wp = read_fs (dev, Q_WP (q->offset))) & Q_FULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((wp = read_fs (dev, Q_WP (q->offset))) & Q_FULL) {
 		fs_dprintk (FS_DEBUG_TXQ, "Found queue at %x full. Waiting.\n", 
 			    q->offset);
 		schedule ();
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	wp &= ~0xf;
@@ -681,6 +703,11 @@ static void process_return_queue (struct
 	struct FS_QENTRY *qe;
 	void *tc;
   
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {
 		fs_dprintk (FS_DEBUG_QUEUE, "reaping return queue entry at %lx\n", rq); 
 		qe = bus_to_virt (rq);
@@ -697,6 +724,12 @@ static void process_return_queue (struct
 		}
     
 		write_fs (dev, Q_RP(q->offset), Q_INCWRAP);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -709,6 +742,11 @@ static void process_txdone_queue (struct
 	struct sk_buff *skb;
 	struct FS_BPENTRY *td;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {
 		fs_dprintk (FS_DEBUG_QUEUE, "reaping txdone entry at %lx\n", rq); 
 		qe = bus_to_virt (rq);
@@ -767,6 +805,12 @@ static void process_txdone_queue (struct
 		}
     
 		write_fs (dev, Q_RP(q->offset), Q_INCWRAP);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -780,6 +824,11 @@ static void process_incoming (struct fs_
 	unsigned int channo;
 	struct atm_vcc *atm_vcc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {
 		fs_dprintk (FS_DEBUG_QUEUE, "reaping incoming queue entry at %lx\n", rq); 
 		qe = bus_to_virt (rq);
@@ -850,6 +899,12 @@ static void process_incoming (struct fs_
 				STATUS_CODE(qe), res_strings[STATUS_CODE (qe)]);
 		}
 		write_fs (dev, Q_RP(q->offset), Q_INCWRAP);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/atm/fore200e.c b/atm/fore200e.c
--- a/atm/fore200e.c
+++ b/atm/fore200e.c
@@ -955,6 +955,11 @@ int bsq_audit(int where, struct host_bsq
     int count = 0;
 
     buffer = bsq->freebuf;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (buffer) {
 
 	if (buffer->supplied) {
@@ -979,6 +984,12 @@ int bsq_audit(int where, struct host_bsq
 
 	count++;
 	buffer = buffer->next;
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
 
     if (count != bsq->freebuf_count) {
@@ -2459,6 +2470,11 @@ fore200e_monitor_getc(struct fore200e* f
     unsigned long      timeout = jiffies + msecs_to_jiffies(50);
     int                c;
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (time_before(jiffies, timeout)) {
 
 	c = (int) fore200e->bus->read(&monitor->soft_uart.recv);
@@ -2471,6 +2487,12 @@ fore200e_monitor_getc(struct fore200e* f
 #endif
 	    return c & 0xFF;
 	}
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
 
     return -1;
@@ -2480,12 +2502,23 @@ fore200e_monitor_getc(struct fore200e* f
 static void __devinit
 fore200e_monitor_puts(struct fore200e* fore200e, char* str)
 {
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (*str) {
 
 	/* the i960 monitor doesn't accept any new character if it has something to say */
 	while (fore200e_monitor_getc(fore200e) >= 0);
 	
 	fore200e_monitor_putc(fore200e, *str++);
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
 
     while (fore200e_monitor_getc(fore200e) >= 0);
diff -u -p a/atm/horizon.c b/atm/horizon.c
--- a/atm/horizon.c
+++ b/atm/horizon.c
@@ -953,6 +953,11 @@ static void rx_schedule (hrz_dev * dev,
   int pio_instead = 0;
 #ifndef TAILRECURSIONWORKS
   pio_instead = 1;
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (pio_instead) {
 #endif
     // bytes waiting for RX transfer
@@ -1071,6 +1076,12 @@ static void rx_schedule (hrz_dev * dev,
 #else
     // grrrrrrr!
     irq = 0;
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
   return;
 #endif
@@ -1119,6 +1130,11 @@ static void tx_schedule (hrz_dev * const
   int pio_instead = 0;
 #ifndef TAILRECURSIONWORKS
   pio_instead = 1;
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (pio_instead) {
 #endif
     // bytes in current region waiting for TX transfer
@@ -1227,6 +1243,12 @@ static void tx_schedule (hrz_dev * const
 #else
     // grrrrrrr!
     irq = 0;
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
   return;
 #endif
@@ -1394,7 +1416,12 @@ static irqreturn_t interrupt_handler(int
   
   // definitely for us
   irq_ok = 0;
-  while ((int_source = rd_regl (dev, INT_SOURCE_REG_OFF)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
+    while ((int_source = rd_regl (dev, INT_SOURCE_REG_OFF)
 	  & INTERESTING_INTERRUPTS)) {
     // In the interests of fairness, the handlers below are
     // called in sequence and without immediate return to the head of
@@ -1427,6 +1454,12 @@ static irqreturn_t interrupt_handler(int
       PRINTD (DBG_IRQ|DBG_RX, "rx_data_av asserted");
       rx_data_av_handler (dev);
     }
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
   if (irq_ok) {
     PRINTD (DBG_IRQ, "work done: %u", irq_ok);
@@ -1469,6 +1502,11 @@ static short setup_idle_tx_channel (hrz_
   // better would be to fail immediately, the caller can then decide whether
   // to wait or drop (depending on whether this is UBR etc.)
   spin_count = 0;
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (!(idle_channels = rd_regw (dev, TX_STATUS_OFF) & IDLE_CHANNELS_MASK)) {
     PRINTD (DBG_TX|DBG_WARN, "waiting for idle TX channel");
     // delay a bit here
@@ -1476,6 +1514,12 @@ static short setup_idle_tx_channel (hrz_
       PRINTD (DBG_TX|DBG_ERR, "spun out waiting for idle TX channel");
       return -EBUSY;
     }
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
   
   // got an idle channel
@@ -1484,6 +1528,11 @@ static short setup_idle_tx_channel (hrz_
     int chan = dev->tx_idle;
     
     int keep_going = 1;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (keep_going) {
       if (idle_channels & (1<<chan)) {
 	tx_channel = chan;
@@ -1492,6 +1541,12 @@ static short setup_idle_tx_channel (hrz_
       ++chan;
       if (chan == TX_CHANS)
 	chan = 0;
+	if (_cur < timeout) {
+	  rdstcll(_cur);
+	}
+	else {
+	  break;
+	}
     }
     
     dev->tx_idle = chan;
@@ -1668,7 +1723,12 @@ static int hrz_send (struct atm_vcc * at
   
   // replace with timer and sleep, add dev->tx_buffers_queue (max 1 entry)
   spin_count = 0;
-  while ((free_buffers = rd_regw (dev, TX_FREE_BUFFER_COUNT_OFF)) < buffers_required) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while ((free_buffers = rd_regw (dev, TX_FREE_BUFFER_COUNT_OFF)) < buffers_required) {
     PRINTD (DBG_TX, "waiting for free TX buffers, got %d of %d",
 	    free_buffers, buffers_required);
     // what is the appropriate delay? implement a timeout? (depending on line speed?)
@@ -1682,6 +1742,12 @@ static int hrz_send (struct atm_vcc * at
       hrz_kfree_skb (skb);
       return -ERESTARTSYS;
     }
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
   
   // Select a channel to transmit the frame on.
diff -u -p a/atm/uPD98402.c b/atm/uPD98402.c
--- a/atm/uPD98402.c
+++ b/atm/uPD98402.c
@@ -187,6 +187,11 @@ static void uPD98402_int(struct atm_dev
 	static unsigned long silence = 0;
 	unsigned char reason;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((reason = GET(PICR))) {
 		if (reason & uPD98402_INT_LOS)
 			printk(KERN_NOTICE "%s(itf %d): signal lost\n",
@@ -203,6 +208,12 @@ static void uPD98402_int(struct atm_dev
 			    "FIFO overflow\n",dev->type,dev->number);
 			silence = (jiffies+HZ/2)|1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/atm/zatm.c b/atm/zatm.c
--- a/atm/zatm.c
+++ b/atm/zatm.c
@@ -367,6 +367,11 @@ static void poll_rx(struct atm_dev *dev,
 	EVENT("poll_rx\n",0,0);
 	zatm_dev = ZATM_DEV(dev);
 	pos = (zatm_dev->mbx_start[mbx] & ~0xffffUL) | zin(MTA(mbx));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (x = zin(MWA(mbx)), (pos & 0xffff) != x) {
 		u32 *here;
 		struct sk_buff *skb;
@@ -471,6 +476,12 @@ printk("dummy: 0x%08lx, 0x%08lx\n",dummy
 		ATM_SKB(skb)->vcc = vcc;
 		vcc->push(vcc,skb);
 		atomic_inc(&vcc->stats->rx);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	zout(pos & 0xffff,MTA(mbx));
 #if 0 /* probably a stupid idea */
@@ -748,6 +759,11 @@ static void poll_tx(struct atm_dev *dev,
 	EVENT("poll_tx\n",0,0);
 	zatm_dev = ZATM_DEV(dev);
 	pos = (zatm_dev->mbx_start[mbx] & ~0xffffUL) | zin(MTA(mbx));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (x = zin(MWA(mbx)), (pos & 0xffff) != x) {
 		int chan;
 
@@ -775,6 +791,12 @@ NO !
 		}
 		if (((pos += 4) & 0xffff) == zatm_dev->mbx_end[mbx])
 			pos = zatm_dev->mbx_start[mbx];
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	zout(pos & 0xffff,MTA(mbx));
 }
@@ -1024,6 +1046,11 @@ static irqreturn_t zatm_int(int irq,void
 
 	dev = dev_id;
 	zatm_dev = ZATM_DEV(dev);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((reason = zin(GSR))) {
 		handled = 1;
 		EVENT("reason 0x%x\n",reason,0);
@@ -1087,6 +1114,12 @@ static irqreturn_t zatm_int(int irq,void
 			if (reason & 8) poll_tx(dev,3);
 		}
 		/* @@@ handle RCRn */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return IRQ_RETVAL(handled);
 }
diff -u -p a/atm/idt77252.c b/atm/idt77252.c
--- a/atm/idt77252.c
+++ b/atm/idt77252.c
@@ -585,10 +585,21 @@ sb_pool_add(struct idt77252_dev *card, s
 	int index;
 
 	index = pool->index;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pool->skb[index]) {
 		index = (index + 1) & FBQ_MASK;
 		if (index == pool->index)
 			return -ENOBUFS;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	pool->skb[index] = skb;
@@ -674,7 +685,12 @@ free_scq(struct idt77252_dev *card, stru
 	pci_free_consistent(card->pcidev, SCQ_SIZE,
 			    scq->base, scq->paddr);
 
-	while ((skb = skb_dequeue(&scq->transmit))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&scq->transmit))) {
 		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
 				 skb->len, PCI_DMA_TODEVICE);
 
@@ -683,9 +699,20 @@ free_scq(struct idt77252_dev *card, stru
 			vcc->pop(vcc, skb);
 		else
 			dev_kfree_skb(skb);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
-	while ((skb = skb_dequeue(&scq->pending))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&scq->pending))) {
 		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
 				 skb->len, PCI_DMA_TODEVICE);
 
@@ -694,6 +721,12 @@ free_scq(struct idt77252_dev *card, stru
 			vcc->pop(vcc, skb);
 		else
 			dev_kfree_skb(skb);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	kfree(scq);
@@ -3773,6 +3806,11 @@ static void __exit idt77252_exit(void)
 
 	pci_unregister_driver(&idt77252_driver);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (idt77252_chain) {
 		card = idt77252_chain;
 		dev = card->atmdev;
@@ -3783,6 +3821,12 @@ static void __exit idt77252_exit(void)
 		deinit_card(card);
 		pci_disable_device(card->pcidev);
 		kfree(card);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DIPRINTK("idt77252: finished cleanup-module().\n");
diff -u -p a/i2c/i2c-core.c b/i2c/i2c-core.c
--- a/i2c/i2c-core.c
+++ b/i2c/i2c-core.c
@@ -57,10 +57,21 @@ static int i2c_detect(struct i2c_adapter
 static const struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,
 						const struct i2c_client *client)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (id->name[0]) {
 		if (strcmp(client->name, id->name) == 0)
 			return id;
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/i2c/algos/i2c-algo-pca.c b/i2c/algos/i2c-algo-pca.c
--- a/i2c/algos/i2c-algo-pca.c
+++ b/i2c/algos/i2c-algo-pca.c
@@ -225,6 +225,11 @@ static int pca_xfer(struct i2c_adapter *
 
 	curmsg = 0;
 	ret = -EIO;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (curmsg < num) {
 		state = pca_status(adap);
 
@@ -341,6 +346,12 @@ static int pca_xfer(struct i2c_adapter *
 
 		if (!completed)
 			goto out;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	ret = curmsg;
diff -u -p a/i2c/busses/i2c-bfin-twi.c b/i2c/busses/i2c-bfin-twi.c
--- a/i2c/busses/i2c-bfin-twi.c
+++ b/i2c/busses/i2c-bfin-twi.c
@@ -360,12 +360,23 @@ static int bfin_twi_do_master_xfer(struc
 		((CONFIG_I2C_BLACKFIN_TWI_CLK_KHZ > 100) ? FAST : 0));
 	SSYNC();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!iface->result) {
 		if (!wait_for_completion_timeout(&iface->complete,
 			adap->timeout)) {
 			iface->result = -1;
 			dev_err(&adap->dev, "master transfer timeout\n");
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (iface->result == 1)
@@ -570,12 +581,23 @@ int bfin_twi_do_smbus_xfer(struct i2c_ad
 	}
 	SSYNC();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!iface->result) {
 		if (!wait_for_completion_timeout(&iface->complete,
 			adap->timeout)) {
 			iface->result = -1;
 			dev_err(&adap->dev, "smbus transfer timeout\n");
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rc = (iface->result >= 0) ? 0 : -1;
diff -u -p a/i2c/busses/i2c-designware-core.c b/i2c/busses/i2c-designware-core.c
--- a/i2c/busses/i2c-designware-core.c
+++ b/i2c/busses/i2c-designware-core.c
@@ -315,6 +315,11 @@ static int i2c_dw_wait_bus_not_busy(stru
 {
 	int timeout = TIMEOUT;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dw_readl(dev, DW_IC_STATUS) & DW_IC_STATUS_ACTIVITY) {
 		if (timeout <= 0) {
 			dev_warn(dev->dev, "timeout waiting for bus ready\n");
@@ -322,6 +327,12 @@ static int i2c_dw_wait_bus_not_busy(stru
 		}
 		timeout--;
 		mdelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/i2c/busses/i2c-omap.c b/i2c/busses/i2c-omap.c
--- a/i2c/busses/i2c-omap.c
+++ b/i2c/busses/i2c-omap.c
@@ -335,7 +335,12 @@ static int omap_i2c_init(struct omap_i2c
 		 * reset done bit gets set. */
 		timeout = jiffies + OMAP_I2C_TIMEOUT;
 		omap_i2c_write_reg(dev, OMAP_I2C_CON_REG, OMAP_I2C_CON_EN);
-		while (!(omap_i2c_read_reg(dev, OMAP_I2C_SYSS_REG) &
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!(omap_i2c_read_reg(dev, OMAP_I2C_SYSS_REG) &
 			 SYSS_RESETDONE_MASK)) {
 			if (time_after(jiffies, timeout)) {
 				dev_warn(dev->dev, "timeout waiting "
@@ -343,6 +348,12 @@ static int omap_i2c_init(struct omap_i2c
 				return -ETIMEDOUT;
 			}
 			msleep(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* SYSC register is cleared by the reset; rewrite it */
@@ -501,12 +512,23 @@ static int omap_i2c_wait_for_bb(struct o
 	unsigned long timeout;
 
 	timeout = jiffies + OMAP_I2C_TIMEOUT;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG) & OMAP_I2C_STAT_BB) {
 		if (time_after(jiffies, timeout)) {
 			dev_warn(dev->dev, "timeout waiting for bus ready\n");
 			return -ETIMEDOUT;
 		}
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -566,6 +588,11 @@ static int omap_i2c_xfer_msg(struct i2c_
 	if (dev->b_hw && stop) {
 		unsigned long delay = jiffies + OMAP_I2C_TIMEOUT;
 		u16 con = omap_i2c_read_reg(dev, OMAP_I2C_CON_REG);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (con & OMAP_I2C_CON_STT) {
 			con = omap_i2c_read_reg(dev, OMAP_I2C_CON_REG);
 
@@ -576,6 +603,12 @@ static int omap_i2c_xfer_msg(struct i2c_
 				return -ETIMEDOUT;
 			}
 			cpu_relax();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		w |= OMAP_I2C_CON_STP;
diff -u -p a/i2c/busses/i2c-au1550.c b/i2c/busses/i2c-au1550.c
--- a/i2c/busses/i2c-au1550.c
+++ b/i2c/busses/i2c-au1550.c
@@ -180,12 +180,23 @@ static int i2c_read(struct i2c_au1550_da
 	 * receive fifo, then reading the bytes.
 	 */
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < (len - 1)) {
 		WR(adap, PSC_SMBTXRX, 0);
 		if (wait_for_rx_byte(adap, &buf[i]))
 			return -EIO;
 
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* The last byte has to indicate transfer done. */
@@ -207,12 +218,23 @@ static int i2c_write(struct i2c_au1550_d
 		return 0;
 
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < (len-1)) {
 		data = buf[i];
 		WR(adap, PSC_SMBTXRX, data);
 		if (wait_ack(adap))
 			return -EIO;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* The last byte has to indicate transfer done. */
diff -u -p a/i2c/busses/i2c-sh7760.c b/i2c/busses/i2c-sh7760.c
--- a/i2c/busses/i2c-sh7760.c
+++ b/i2c/busses/i2c-sh7760.c
@@ -179,10 +179,21 @@ static irqreturn_t sh7760_i2c_irq(int ir
 				fsr &= ~FSR_RDF;
 			}
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (msg->len && len) {
 			*data++ = IN32(id, I2CRXTX);
 			msg->len--;
 			len--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (msg->len) {
diff -u -p a/i2c/busses/i2c-nomadik.c b/i2c/busses/i2c-nomadik.c
--- a/i2c/busses/i2c-nomadik.c
+++ b/i2c/busses/i2c-nomadik.c
@@ -210,10 +210,21 @@ static int flush_i2c_fifo(struct nmk_i2c
 	for (i = 0; i < LOOP_ATTEMPTS; i++) {
 		timeout = jiffies + dev->adap.timeout;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!time_after(jiffies, timeout)) {
 			if ((readl(dev->virtbase + I2C_CR) &
 				(I2C_CR_FTX | I2C_CR_FRX)) == 0)
 					return 0;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 		}
 	}
 
diff -u -p a/i2c/busses/i2c-eg20t.c b/i2c/busses/i2c-eg20t.c
--- a/i2c/busses/i2c-eg20t.c
+++ b/i2c/busses/i2c-eg20t.c
@@ -981,9 +981,20 @@ static int pch_i2c_suspend(struct pci_de
 	adap_info->pch_i2c_suspended = true;
 
 	for (i = 0; i < adap_info->ch_num; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((adap_info->pch_data[i].pch_i2c_xfer_in_progress)) {
 			/* Wait until all channel transfers are completed */
 			msleep(20);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/i2c/busses/i2c-mv64xxx.c b/i2c/busses/i2c-mv64xxx.c
--- a/i2c/busses/i2c-mv64xxx.c
+++ b/i2c/busses/i2c-mv64xxx.c
@@ -321,12 +321,23 @@ mv64xxx_i2c_intr(int irq, void *dev_id)
 	irqreturn_t	rc = IRQ_NONE;
 
 	spin_lock_irqsave(&drv_data->lock, flags);
-	while (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &
 						MV64XXX_I2C_REG_CONTROL_IFLG) {
 		status = readl(drv_data->reg_base + MV64XXX_I2C_REG_STATUS);
 		mv64xxx_i2c_fsm(drv_data, status);
 		mv64xxx_i2c_do_action(drv_data);
 		rc = IRQ_HANDLED;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	spin_unlock_irqrestore(&drv_data->lock, flags);
 
diff -u -p a/i2c/busses/i2c-cpm.c b/i2c/busses/i2c-cpm.c
--- a/i2c/busses/i2c-cpm.c
+++ b/i2c/busses/i2c-cpm.c
@@ -338,6 +338,11 @@ static int cpm_i2c_xfer(struct i2c_adapt
 	tptr = 0;
 	rptr = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tptr < num) {
 		pmsg = &msgs[tptr];
 		dev_dbg(&adap->dev, "R: %d T: %d\n", rptr, tptr);
@@ -346,6 +351,12 @@ static int cpm_i2c_xfer(struct i2c_adapt
 		if (pmsg->flags & I2C_M_RD)
 			rptr++;
 		tptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Start transfer now */
 	/* Enable RX/TX/Error interupts */
@@ -359,6 +370,11 @@ static int cpm_i2c_xfer(struct i2c_adapt
 	tptr = 0;
 	rptr = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tptr < num) {
 		/* Check for outstanding messages */
 		dev_dbg(&adap->dev, "test ready.\n");
@@ -386,7 +402,13 @@ static int cpm_i2c_xfer(struct i2c_adapt
 			if (ret)
 				goto out_err;
 		}
-	}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+}
 #ifdef I2C_CHIP_ERRATA
 	/*
 	 * Chip errata, clear enable. This is not needed on rev D4 CPUs.
diff -u -p a/i2c/busses/i2c-tegra.c b/i2c/busses/i2c-tegra.c
--- a/i2c/busses/i2c-tegra.c
+++ b/i2c/busses/i2c-tegra.c
@@ -205,6 +205,11 @@ static int tegra_i2c_flush_fifos(struct
 	val |= I2C_FIFO_CONTROL_TX_FLUSH | I2C_FIFO_CONTROL_RX_FLUSH;
 	i2c_writel(i2c_dev, val, I2C_FIFO_CONTROL);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i2c_readl(i2c_dev, I2C_FIFO_CONTROL) &
 		(I2C_FIFO_CONTROL_TX_FLUSH | I2C_FIFO_CONTROL_RX_FLUSH)) {
 		if (time_after(jiffies, timeout)) {
@@ -212,6 +217,12 @@ static int tegra_i2c_flush_fifos(struct
 			return -ETIMEDOUT;
 		}
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/i2c/busses/i2c-mpc.c b/i2c/busses/i2c-mpc.c
--- a/i2c/busses/i2c-mpc.c
+++ b/i2c/busses/i2c-mpc.c
@@ -506,6 +506,11 @@ static int mpc_xfer(struct i2c_adapter *
 	mpc_i2c_start(i2c);
 
 	/* Allow bus up to 1s to become not busy */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (readb(i2c->base + MPC_I2C_SR) & CSR_MBB) {
 		if (signal_pending(current)) {
 			dev_dbg(i2c->dev, "Interrupted\n");
@@ -524,6 +529,12 @@ static int mpc_xfer(struct i2c_adapter *
 			return -EIO;
 		}
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; ret >= 0 && i < num; i++) {
diff -u -p a/i2c/busses/i2c-mxs.c b/i2c/busses/i2c-mxs.c
--- a/i2c/busses/i2c-mxs.c
+++ b/i2c/busses/i2c-mxs.c
@@ -182,11 +182,22 @@ static int mxs_i2c_wait_for_data(struct
 {
 	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (readl(i2c->regs + MXS_I2C_QUEUESTAT)
 			& MXS_I2C_QUEUESTAT_RD_QUEUE_EMPTY) {
 			if (time_after(jiffies, timeout))
 				return -ETIMEDOUT;
 			cond_resched();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/i2c/busses/i2c-pxa.c b/i2c/busses/i2c-pxa.c
--- a/i2c/busses/i2c-pxa.c
+++ b/i2c/busses/i2c-pxa.c
@@ -332,6 +332,11 @@ static int i2c_pxa_wait_master(struct px
 {
 	unsigned long timeout = jiffies + HZ*4;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, timeout)) {
 		if (i2c_debug > 1)
 			dev_dbg(&i2c->adap.dev, "%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\n",
@@ -354,6 +359,12 @@ static int i2c_pxa_wait_master(struct px
 		}
 
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (i2c_debug > 0)
@@ -388,6 +399,11 @@ static int i2c_pxa_wait_slave(struct pxa
 
 	show_state(i2c);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, timeout)) {
 		if (i2c_debug > 1)
 			dev_dbg(&i2c->adap.dev, "%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\n",
@@ -402,6 +418,12 @@ static int i2c_pxa_wait_slave(struct pxa
 		}
 
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (i2c_debug > 0)
diff -u -p a/i2c/busses/i2c-highlander.c b/i2c/busses/i2c-highlander.c
--- a/i2c/busses/i2c-highlander.c
+++ b/i2c/busses/i2c-highlander.c
@@ -131,6 +131,11 @@ static int highlander_i2c_wait_for_bbsy(
 	unsigned long timeout;
 
 	timeout = jiffies + msecs_to_jiffies(iic_timeout);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ioread16(dev->base + SMCR) & SMCR_BBSY) {
 		if (time_after(jiffies, timeout)) {
 			dev_warn(dev->dev, "timeout waiting for bus ready\n");
@@ -138,6 +143,12 @@ static int highlander_i2c_wait_for_bbsy(
 		}
 
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/i2c/busses/i2c-ibm_iic.c b/i2c/busses/i2c-ibm_iic.c
--- a/i2c/busses/i2c-ibm_iic.c
+++ b/i2c/busses/i2c-ibm_iic.c
@@ -230,10 +230,21 @@ static void iic_dev_reset(struct ibm_iic
 static int iic_dc_wait(volatile struct iic_regs __iomem *iic, u8 mask)
 {
 	unsigned long x = jiffies + HZ / 28 + 2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((in_8(&iic->directcntl) & mask) != mask){
 		if (unlikely(time_after(jiffies, x)))
 			return -1;
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/i2c/busses/i2c-davinci.c b/i2c/busses/i2c-davinci.c
--- a/i2c/busses/i2c-davinci.c
+++ b/i2c/busses/i2c-davinci.c
@@ -279,6 +279,11 @@ static int i2c_davinci_wait_bus_not_busy
 	static u16 to_cnt;
 
 	timeout = jiffies + dev->adapter.timeout;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (davinci_i2c_read_reg(dev, DAVINCI_I2C_STR_REG)
 	       & DAVINCI_I2C_STR_BB) {
 		if (to_cnt <= DAVINCI_I2C_MAX_TRIES) {
@@ -295,6 +300,12 @@ static int i2c_davinci_wait_bus_not_busy
 		}
 		if (allow_sleep)
 			schedule_timeout(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/i2c/busses/i2c-s6000.c b/i2c/busses/i2c-s6000.c
--- a/i2c/busses/i2c-s6000.c
+++ b/i2c/busses/i2c-s6000.c
@@ -98,6 +98,11 @@ static void s6i2c_handle_interrupt(struc
 		i2c_wr16(iface, S6_I2C_INTRMASK, 0);
 		return;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((iface->msgs_push < iface->msgs_num)
 	    && (i2c_rd16(iface, S6_I2C_STATUS) & (1 << S6_I2C_STATUS_TFNF))) {
 		struct i2c_msg *m = &iface->msgs[iface->msgs_push];
@@ -110,6 +115,12 @@ static void s6i2c_handle_interrupt(struc
 			iface->push = 0;
 			iface->msgs_push += 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	do {
 		struct i2c_msg *m = &iface->msgs[iface->msgs_done];
diff -u -p a/i2c/busses/i2c-sh_mobile.c b/i2c/busses/i2c-sh_mobile.c
--- a/i2c/busses/i2c-sh_mobile.c
+++ b/i2c/busses/i2c-sh_mobile.c
@@ -541,6 +541,11 @@ static int sh_mobile_i2c_hook_irqs(struc
 	int ret = -ENXIO;
 	int n, k = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((res = platform_get_resource(dev, IORESOURCE_IRQ, k))) {
 		for (n = res->start; hook && n <= res->end; n++) {
 			if (request_irq(n, sh_mobile_i2c_isr, 0,
@@ -552,6 +557,12 @@ static int sh_mobile_i2c_hook_irqs(struc
 			}
 		}
 		k++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (hook)
diff -u -p a/i2c/busses/i2c-stu300.c b/i2c/busses/i2c-stu300.c
--- a/i2c/busses/i2c-stu300.c
+++ b/i2c/busses/i2c-stu300.c
@@ -448,12 +448,23 @@ static int stu300_wait_while_busy(struct
 	for (i = 0; i < BUSY_RELEASE_ATTEMPTS; i++) {
 		timeout = jiffies + STU300_TIMEOUT;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!time_after(jiffies, timeout)) {
 			/* Is not busy? */
 			if ((stu300_r8(dev->virtbase + I2C_SR1) &
 			     I2C_SR1_BUSY_IND) == 0)
 				return 0;
 			msleep(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		dev_err(&dev->pdev->dev, "transaction timed out "
diff -u -p a/dio/dio-driver.c b/dio/dio-driver.c
--- a/dio/dio-driver.c
+++ b/dio/dio-driver.c
@@ -29,6 +29,11 @@ const struct dio_device_id *
 dio_match_device(const struct dio_device_id *ids,
 		   const struct dio_dev *d)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ids->id) {
 		if (ids->id == DIO_WILDCARD)
 			return ids;
@@ -40,6 +45,12 @@ dio_match_device(const struct dio_device
 				return ids;
 		}
 		ids++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/dma/ipu/ipu_irq.c b/dma/ipu/ipu_irq.c
--- a/dma/ipu/ipu_irq.c
+++ b/dma/ipu/ipu_irq.c
@@ -285,6 +285,11 @@ static void ipu_irq_err(unsigned int irq
 		 */
 		status &= ipu_read_reg(ipu, bank->control);
 		raw_spin_unlock(&bank_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((line = ffs(status))) {
 			struct ipu_irq_map *map;
 
@@ -303,6 +308,12 @@ static void ipu_irq_err(unsigned int irq
 				continue;
 			}
 			generic_handle_irq(irq);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -322,6 +333,11 @@ static void ipu_irq_fn(unsigned int irq,
 		/* Not clearing all interrupts, see above */
 		status &= ipu_read_reg(ipu, bank->control);
 		raw_spin_unlock(&bank_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((line = ffs(status))) {
 			struct ipu_irq_map *map;
 
@@ -340,6 +356,12 @@ static void ipu_irq_fn(unsigned int irq,
 				continue;
 			}
 			generic_handle_irq(irq);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
diff -u -p a/dma/mv_xor.c b/dma/mv_xor.c
--- a/dma/mv_xor.c
+++ b/dma/mv_xor.c
@@ -496,6 +496,11 @@ retry:
 			struct mv_xor_desc_slot *alloc_tail = NULL;
 			struct mv_xor_desc_slot *last_used = NULL;
 			iter = alloc_start;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (num_slots) {
 				int i;
 
@@ -515,6 +520,12 @@ retry:
 						slot_node);
 				}
 				num_slots -= slots_per_op;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			alloc_tail->group_head = alloc_start;
 			alloc_tail->async_tx.cookie = -EBUSY;
diff -u -p a/dma/coh901318_lli.c b/dma/coh901318_lli.c
--- a/dma/coh901318_lli.c
+++ b/dma/coh901318_lli.c
@@ -126,11 +126,22 @@ void coh901318_lli_free(struct coh901318
 
 	spin_lock(&pool->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (l->link_addr) {
 		next = l->virt_link_addr;
 		dma_pool_free(pool->dmapool, l, l->phy_this);
 		DEBUGFS_POOL_COUNTER_ADD(pool, -1);
 		l = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dma_pool_free(pool->dmapool, l, l->phy_this);
 	DEBUGFS_POOL_COUNTER_ADD(pool, -1);
@@ -153,6 +164,11 @@ coh901318_lli_fill_memcpy(struct coh9013
 	lli->src_addr = src;
 	lli->dst_addr = dst;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lli->link_addr) {
 		lli->control = ctrl_chained | MAX_DMA_PACKET_SIZE;
 		lli->src_addr = src;
@@ -163,6 +179,12 @@ coh901318_lli_fill_memcpy(struct coh9013
 
 		src += MAX_DMA_PACKET_SIZE;
 		dst += MAX_DMA_PACKET_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lli->control = ctrl_eom | s;
@@ -196,6 +218,11 @@ coh901318_lli_fill_single(struct coh9013
 		return -EINVAL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lli->link_addr) {
 		size_t block_size = MAX_DMA_PACKET_SIZE;
 		lli->control = ctrl_chained | MAX_DMA_PACKET_SIZE;
@@ -219,6 +246,12 @@ coh901318_lli_fill_single(struct coh9013
 			src += block_size;
 		else if (dir == DMA_FROM_DEVICE)
 			dst += block_size;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	lli->control = ctrl_eom | s;
@@ -278,6 +311,11 @@ coh901318_lli_fill_sg(struct coh901318_p
 
 		bytes_to_transfer = sg_dma_len(sg);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bytes_to_transfer) {
 			u32 val;
 
@@ -302,6 +340,12 @@ coh901318_lli_fill_sg(struct coh901318_p
 
 			bytes_to_transfer -= elem_size;
 			lli = coh901318_lli_next(lli);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	}
diff -u -p a/dma/mxs-dma.c b/dma/mxs-dma.c
--- a/dma/mxs-dma.c
+++ b/dma/mxs-dma.c
@@ -276,7 +276,12 @@ static irqreturn_t mxs_dma_int_handler(i
 
 	/* combine error and completion status for checking */
 	stat1 = (stat2 << MXS_DMA_CHANNELS) | stat1;
-	while (stat1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (stat1) {
 		int channel = fls(stat1) - 1;
 		struct mxs_dma_chan *mxs_chan =
 			&mxs_dma->mxs_chans[channel % MXS_DMA_CHANNELS];
@@ -301,6 +306,12 @@ static irqreturn_t mxs_dma_int_handler(i
 
 		/* schedule tasklet on this channel */
 		tasklet_schedule(&mxs_chan->tasklet);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return IRQ_HANDLED;
@@ -499,6 +510,11 @@ static struct dma_async_tx_descriptor *m
 		goto err_out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (buf < buf_len) {
 		struct mxs_dma_ccw *ccw = &mxs_chan->ccw[i];
 
@@ -522,6 +538,12 @@ static struct dma_async_tx_descriptor *m
 		buf += period_len;
 
 		i++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return &mxs_chan->desc;
diff -u -p a/dma/ste_dma40.c b/dma/ste_dma40.c
--- a/dma/ste_dma40.c
+++ b/dma/ste_dma40.c
@@ -812,21 +812,54 @@ static void d40_term_all(struct d40_chan
 	struct d40_desc *_d;
 
 	/* Release active descriptors */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((d40d = d40_first_active_get(d40c))) {
 		d40_desc_remove(d40d);
 		d40_desc_free(d40c, d40d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Release queued descriptors waiting for transfer */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((d40d = d40_first_queued(d40c))) {
 		d40_desc_remove(d40d);
 		d40_desc_free(d40c, d40d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Release pending descriptors */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((d40d = d40_first_pending(d40c))) {
 		d40_desc_remove(d40d);
 		d40_desc_free(d40c, d40d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Release client owned descriptors */
diff -u -p a/dma/intel_mid_dma.c b/dma/intel_mid_dma.c
--- a/dma/intel_mid_dma.c
+++ b/dma/intel_mid_dma.c
@@ -945,6 +945,11 @@ static void dma_tasklet(unsigned long da
 	raw_block = ioread32(mid->dma_base + RAW_BLOCK);
 	status = raw_tfr | raw_block;
 	status &= mid->intr_mask;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status) {
 		/*txn interrupt*/
 		i = get_ch_index(&status, mid->chan_base);
@@ -977,10 +982,21 @@ static void dma_tasklet(unsigned long da
 				mid->dma_base + MASK_BLOCK);
 		}
 		spin_unlock_bh(&midc->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	status = ioread32(mid->dma_base + RAW_ERR);
 	status &= mid->intr_mask;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status) {
 		/*err interrupt*/
 		i = get_ch_index(&status, mid->chan_base);
@@ -1002,6 +1018,12 @@ static void dma_tasklet(unsigned long da
 		iowrite32(UNMASK_INTR_REG(midc->ch_id),
 				mid->dma_base + MASK_ERR);
 		spin_unlock_bh(&midc->lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	pr_debug("MDMA:Exiting takslet...\n");
 	return;
diff -u -p a/dma/ppc4xx/adma.c b/dma/ppc4xx/adma.c
--- a/dma/ppc4xx/adma.c
+++ b/dma/ppc4xx/adma.c
@@ -1157,7 +1157,12 @@ static void ppc440spe_adma_device_clear_
 	case PPC440SPE_DMA1_ID:
 		/* read FIFO to ack */
 		dma_reg = chan->device->dma_reg;
-		while ((rv = ioread32(&dma_reg->csfpl))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((rv = ioread32(&dma_reg->csfpl))) {
 			i = rv & DMA_CDB_ADDR_MSK;
 			cdb = (struct dma_cdb *)&p[i -
 			    (u32)chan->device->dma_desc_pool];
@@ -1217,6 +1222,12 @@ static void ppc440spe_adma_device_clear_
 						BUG();
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		rv = ioread32(&dma_reg->dsts);
@@ -2032,6 +2043,11 @@ retry:
 			struct ppc440spe_adma_desc_slot *last_used = NULL;
 
 			iter = alloc_start;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (num_slots) {
 				int i;
 				/* pre-ack all but the last descriptor */
@@ -2053,6 +2069,12 @@ retry:
 						slot_node);
 				}
 				num_slots -= slots_per_op;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			alloc_tail->group_head = alloc_start;
 			alloc_tail->async_tx.cookie = -EBUSY;
@@ -3732,7 +3754,12 @@ static void ppc440spe_adma_dma2rxor_set_
 	int k = 0, op = 0, lop = 0;
 
 	/* get the RXOR operand which corresponds to index addr */
-	while (op <= index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (op <= index) {
 		lop = op;
 		if (k == XOR_MAX_OPS) {
 			k = 0;
@@ -3746,6 +3773,12 @@ static void ppc440spe_adma_dma2rxor_set_
 			op += 2;
 		else
 			op += 3;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	BUG_ON(k < 1);
@@ -3773,7 +3806,12 @@ static void ppc440spe_adma_dma2rxor_set_
 	int k = 0, op = 0, lop = 0;
 
 	/* get the RXOR operand which corresponds to index mult */
-	while (op <= index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (op <= index) {
 		lop = op;
 		if (k == XOR_MAX_OPS) {
 			k = 0;
@@ -3788,6 +3826,12 @@ static void ppc440spe_adma_dma2rxor_set_
 			op += 2;
 		else
 			op += 3;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	BUG_ON(k < 1);
diff -u -p a/dma/dmaengine.c b/dma/dmaengine.c
--- a/dma/dmaengine.c
+++ b/dma/dmaengine.c
@@ -195,9 +195,20 @@ static void balance_ref_count(struct dma
 {
 	struct module *owner = dma_chan_to_owner(chan);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (chan->client_count < dmaengine_ref_count) {
 		__module_get(owner);
 		chan->client_count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/dma/imx-sdma.c b/dma/imx-sdma.c
--- a/dma/imx-sdma.c
+++ b/dma/imx-sdma.c
@@ -546,6 +546,11 @@ static irqreturn_t sdma_int_handler(int
 	stat = __raw_readl(sdma->regs + SDMA_H_INTR);
 	__raw_writel(stat, sdma->regs + SDMA_H_INTR);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (stat) {
 		int channel = fls(stat) - 1;
 		struct sdma_channel *sdmac = &sdma->channel[channel];
@@ -553,6 +558,12 @@ static irqreturn_t sdma_int_handler(int
 		mxc_sdma_handle_channel(sdmac);
 
 		stat &= ~(1 << channel);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return IRQ_HANDLED;
@@ -1041,6 +1052,11 @@ static struct dma_async_tx_descriptor *s
 		goto err_out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (buf < buf_len) {
 		struct sdma_buffer_descriptor *bd = &sdmac->bd[i];
 		int param;
@@ -1071,6 +1087,12 @@ static struct dma_async_tx_descriptor *s
 		buf += period_len;
 
 		i++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	sdmac->num_bd = num_periods;
diff -u -p a/dma/amba-pl08x.c b/dma/amba-pl08x.c
--- a/dma/amba-pl08x.c
+++ b/dma/amba-pl08x.c
@@ -712,6 +712,11 @@ static int pl08x_fill_llis_for_desc(stru
 			 * Make largest possible LLIs until less than one bus
 			 * width left
 			 */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (bd.remainder > (mbus->buswidth - 1)) {
 				size_t lli_len, tsize, width;
 
@@ -741,6 +746,12 @@ static int pl08x_fill_llis_for_desc(stru
 				pl08x_fill_lli_for_desc(&bd, num_llis++,
 						lli_len, cctl);
 				total_bytes += lli_len;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 
 			/*
diff -u -p a/dma/ep93xx_dma.c b/dma/ep93xx_dma.c
--- a/dma/ep93xx_dma.c
+++ b/dma/ep93xx_dma.c
@@ -225,7 +225,12 @@ static void ep93xx_dma_set_active(struct
 	list_add_tail(&desc->node, &edmac->active);
 
 	/* Flatten the @desc->tx_list chain into @edmac->active list */
-	while (!list_empty(&desc->tx_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&desc->tx_list)) {
 		struct ep93xx_dma_desc *d = list_first_entry(&desc->tx_list,
 			struct ep93xx_dma_desc, node);
 
@@ -239,6 +244,12 @@ static void ep93xx_dma_set_active(struct
 		d->txd.callback_param = desc->txd.callback_param;
 
 		list_move_tail(&d->node, &edmac->active);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/dma/iop-adma.c b/dma/iop-adma.c
--- a/dma/iop-adma.c
+++ b/dma/iop-adma.c
@@ -394,7 +394,12 @@ retry:
 			struct iop_adma_desc_slot *alloc_tail = NULL;
 			struct iop_adma_desc_slot *last_used = NULL;
 			iter = alloc_start;
-			while (num_slots) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (num_slots) {
 				int i;
 				dev_dbg(iop_chan->device->common.dev,
 					"allocated slot: %d "
@@ -419,6 +424,12 @@ retry:
 						slot_node);
 				}
 				num_slots -= slots_per_op;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			alloc_tail->group_head = alloc_start;
 			alloc_tail->async_tx.cookie = -EBUSY;
diff -u -p a/dma/pl330.c b/dma/pl330.c
--- a/dma/pl330.c
+++ b/dma/pl330.c
@@ -402,6 +402,11 @@ static dma_cookie_t pl330_tx_submit(stru
 	/* Assign cookies to all nodes */
 	cookie = tx->chan->cookie;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&last->node)) {
 		desc = list_entry(last->node.next, struct dma_pl330_desc, node);
 
@@ -410,6 +415,12 @@ static dma_cookie_t pl330_tx_submit(stru
 		desc->txd.cookie = cookie;
 
 		list_move_tail(&desc->node, &pch->work_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (++cookie < 0)
@@ -729,10 +740,21 @@ pl330_prep_slave_sg(struct dma_chan *cha
 
 			spin_lock_irqsave(&pdmac->pool_lock, flags);
 
-			while (!list_empty(&first->node)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&first->node)) {
 				desc = list_entry(first->node.next,
 						struct dma_pl330_desc, node);
 				list_move_tail(&desc->node, &pdmac->desc_pool);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 
 			list_move_tail(&first->node, &pdmac->desc_pool);
diff -u -p a/dma/iovlock.c b/dma/iovlock.c
--- a/dma/iovlock.c
+++ b/dma/iovlock.c
@@ -161,6 +161,11 @@ dma_cookie_t dma_memcpy_to_iovec(struct
 		return memcpy_toiovec(iov, kdata, len);
 
 	iovec_idx = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (iovec_idx < pinned_list->nr_iovecs) {
 		struct dma_page_list *page_list;
 
@@ -175,6 +180,11 @@ dma_cookie_t dma_memcpy_to_iovec(struct
 			 - ((unsigned long)page_list->base_address & PAGE_MASK)) >> PAGE_SHIFT;
 
 		/* break up copies to not cross page boundary */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (iov[iovec_idx].iov_len) {
 			copy = min_t(int, PAGE_SIZE - iov_byte_offset, len);
 			copy = min_t(int, copy, iov[iovec_idx].iov_len);
@@ -200,8 +210,20 @@ dma_cookie_t dma_memcpy_to_iovec(struct
 			kdata += copy;
 			iov_byte_offset = 0;
 			page_idx++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		iovec_idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* really bad if we ever run out of iovecs */
@@ -230,6 +252,11 @@ dma_cookie_t dma_memcpy_pg_to_iovec(stru
 	}
 
 	iovec_idx = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (iovec_idx < pinned_list->nr_iovecs) {
 		struct dma_page_list *page_list;
 
@@ -244,6 +271,11 @@ dma_cookie_t dma_memcpy_pg_to_iovec(stru
 			 - ((unsigned long)page_list->base_address & PAGE_MASK)) >> PAGE_SHIFT;
 
 		/* break up copies to not cross page boundary */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (iov[iovec_idx].iov_len) {
 			copy = min_t(int, PAGE_SIZE - iov_byte_offset, len);
 			copy = min_t(int, copy, iov[iovec_idx].iov_len);
@@ -270,8 +302,20 @@ dma_cookie_t dma_memcpy_pg_to_iovec(stru
 			offset += copy;
 			iov_byte_offset = 0;
 			page_idx++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		iovec_idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* really bad if we ever run out of iovecs */
diff -u -p a/dma/coh901318.c b/dma/coh901318.c
--- a/dma/coh901318.c
+++ b/dma/coh901318.c
@@ -87,13 +87,24 @@ static void coh901318_list_print(struct
 	struct coh901318_lli *l = lli;
 	int i = 0;
 
-	while (l) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l) {
 		dev_vdbg(COHC_2_DEV(cohc), "i %d, lli %p, ctrl 0x%x, src 0x%x"
 			 ", dst 0x%x, link 0x%x virt_link_addr 0x%p\n",
 			 i, l, l->control, l->src_addr, l->dst_addr,
 			 l->link_addr, l->virt_link_addr);
 		i++;
 		l = l->virt_link_addr;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -423,9 +434,20 @@ static inline u32 coh901318_get_bytes_in
 	struct coh901318_lli *lli = in_lli;
 	u32 bytes = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lli) {
 		bytes += lli->control & COH901318_CX_CTRL_TC_VALUE_MASK;
 		lli = lli->virt_link_addr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return bytes;
 }
@@ -819,6 +841,11 @@ static irqreturn_t dma_irq_handler(int i
 	 *       minimize interrupt latency */
 
 	/* Check the first 32 DMA channels for IRQ */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status1) {
 		/* Find first bit set, return as a number. */
 		i = ffs(status1) - 1;
@@ -863,9 +890,20 @@ static irqreturn_t dma_irq_handler(int i
 			}
 		}
 		spin_unlock(&cohc->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Check the remaining 32 DMA channels for IRQ */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status2) {
 		/* Find first bit set, return as a number. */
 		i = ffs(status2) - 1;
@@ -908,6 +946,12 @@ static irqreturn_t dma_irq_handler(int i
 			}
 		}
 		spin_unlock(&cohc->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return IRQ_HANDLED;
@@ -1389,6 +1433,11 @@ coh901318_control(struct dma_chan *chan,
 
 	enable_powersave(cohc);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cohd = coh901318_first_active_get(cohc))) {
 		/* release the lli allocation*/
 		coh901318_lli_free(&cohc->base->pool, &cohd->lli);
@@ -1396,8 +1445,19 @@ coh901318_control(struct dma_chan *chan,
 		/* return desc to free-list */
 		coh901318_desc_remove(cohd);
 		coh901318_desc_free(cohc, cohd);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cohd = coh901318_first_queued(cohc))) {
 		/* release the lli allocation*/
 		coh901318_lli_free(&cohc->base->pool, &cohd->lli);
@@ -1405,6 +1465,12 @@ coh901318_control(struct dma_chan *chan,
 		/* return desc to free-list */
 		coh901318_desc_remove(cohd);
 		coh901318_desc_free(cohc, cohd);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 
diff -u -p a/gpu/drm/mga/mga_dma.c b/gpu/drm/mga/mga_dma.c
--- a/gpu/drm/mga/mga_dma.c
+++ b/gpu/drm/mga/mga_dma.c
@@ -294,10 +294,21 @@ static void mga_freelist_cleanup(struct
 	DRM_DEBUG("\n");
 
 	entry = dev_priv->head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (entry) {
 		next = entry->next;
 		kfree(entry);
 		entry = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev_priv->head = dev_priv->tail = NULL;
diff -u -p a/gpu/drm/ttm/ttm_bo.c b/gpu/drm/ttm/ttm_bo.c
--- a/gpu/drm/ttm/ttm_bo.c
+++ b/gpu/drm/ttm/ttm_bo.c
@@ -1321,6 +1321,11 @@ static int ttm_bo_force_list_clean(struc
 	 */
 
 	spin_lock(&glob->lru_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&man->lru)) {
 		spin_unlock(&glob->lru_lock);
 		ret = ttm_mem_evict_first(bdev, mem_type, false, false, false);
@@ -1333,6 +1338,12 @@ static int ttm_bo_force_list_clean(struc
 			}
 		}
 		spin_lock(&glob->lru_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock(&glob->lru_lock);
 	return 0;
@@ -1644,6 +1655,11 @@ static void ttm_bo_vm_insert_rb(struct t
 	unsigned long offset = bo->vm_node->start;
 	unsigned long cur_offset;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*cur) {
 		parent = *cur;
 		cur_bo = rb_entry(parent, struct ttm_buffer_object, vm_rb);
@@ -1654,6 +1670,12 @@ static void ttm_bo_vm_insert_rb(struct t
 			cur = &parent->rb_right;
 		else
 			BUG();
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	rb_link_node(&bo->vm_rb, parent, cur);
@@ -1720,6 +1742,11 @@ int ttm_bo_wait(struct ttm_buffer_object
 	if (likely(bo->sync_obj == NULL))
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bo->sync_obj) {
 
 		if (driver->sync_obj_signaled(bo->sync_obj, bo->sync_obj_arg)) {
@@ -1761,6 +1788,12 @@ int ttm_bo_wait(struct ttm_buffer_object
 			driver->sync_obj_unref(&sync_obj);
 			spin_lock(&bdev->fence_lock);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/gpu/drm/ttm/ttm_object.c b/gpu/drm/ttm/ttm_object.c
--- a/gpu/drm/ttm/ttm_object.c
+++ b/gpu/drm/ttm/ttm_object.c
@@ -365,10 +365,21 @@ void ttm_object_file_release(struct ttm_
 	 * restart it from the beginning each time.
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&tfile->ref_list)) {
 		list = tfile->ref_list.next;
 		ref = list_entry(list, struct ttm_ref_object, head);
 		ttm_ref_object_release(&ref->kref);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i < TTM_REF_NUM; ++i)
diff -u -p a/gpu/drm/ttm/ttm_memory.c b/gpu/drm/ttm/ttm_memory.c
--- a/gpu/drm/ttm/ttm_memory.c
+++ b/gpu/drm/ttm/ttm_memory.c
@@ -219,6 +219,11 @@ static void ttm_shrink(struct ttm_mem_gl
 	if (glob->shrink == NULL)
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ttm_zones_above_swap_target(glob, from_wq, extra)) {
 		shrink = glob->shrink;
 		spin_unlock(&glob->lock);
@@ -226,7 +231,13 @@ static void ttm_shrink(struct ttm_mem_gl
 		spin_lock(&glob->lock);
 		if (unlikely(ret != 0))
 			goto out;
-	}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+}
 out:
 	spin_unlock(&glob->lock);
 }
diff -u -p a/gpu/drm/via/via_dmablit.c b/gpu/drm/via/via_dmablit.c
--- a/gpu/drm/via/via_dmablit.c
+++ b/gpu/drm/via/via_dmablit.c
@@ -507,6 +507,11 @@ via_dmablit_workqueue(struct work_struct
 
 	spin_lock_irqsave(&blitq->blit_lock, irqsave);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (blitq->serviced != blitq->cur) {
 
 		cur_released = blitq->serviced++;
@@ -527,6 +532,12 @@ via_dmablit_workqueue(struct work_struct
 		kfree(cur_sg);
 
 		spin_lock_irqsave(&blitq->blit_lock, irqsave);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&blitq->blit_lock, irqsave);
diff -u -p a/gpu/drm/i810/i810_dma.c b/gpu/drm/i810/i810_dma.c
--- a/gpu/drm/i810/i810_dma.c
+++ b/gpu/drm/i810/i810_dma.c
@@ -248,6 +248,11 @@ static int i810_wait_ring(struct drm_dev
 	unsigned int last_head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
 
 	end = jiffies + (HZ * 3);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ring->space < n) {
 		ring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
 		ring->space = ring->head - (ring->tail + 8);
@@ -266,7 +271,13 @@ static int i810_wait_ring(struct drm_dev
 			goto out_wait_ring;
 		}
 		udelay(1);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out_wait_ring:
 	return iters;
diff -u -p a/gpu/drm/i915/i915_gem_execbuffer.c b/gpu/drm/i915/i915_gem_execbuffer.c
--- a/gpu/drm/i915/i915_gem_execbuffer.c
+++ b/gpu/drm/i915/i915_gem_execbuffer.c
@@ -472,7 +472,12 @@ i915_gem_execbuffer_reserve(struct intel
 	struct list_head ordered_objects;
 
 	INIT_LIST_HEAD(&ordered_objects);
-	while (!list_empty(objects)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(objects)) {
 		struct drm_i915_gem_exec_object2 *entry;
 		bool need_fence, need_mappable;
 
@@ -495,6 +500,12 @@ i915_gem_execbuffer_reserve(struct intel
 
 		obj->base.pending_read_domains = 0;
 		obj->base.pending_write_domain = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	list_splice(&ordered_objects, objects);
 
@@ -604,6 +615,11 @@ err:
 	obj = list_entry(obj->exec_list.prev,
 			 struct drm_i915_gem_object,
 			 exec_list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (objects != &obj->exec_list) {
 		if (obj->gtt_space)
 			i915_gem_object_unpin(obj);
@@ -611,6 +627,12 @@ err:
 		obj = list_entry(obj->exec_list.prev,
 				 struct drm_i915_gem_object,
 				 exec_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
@@ -631,12 +653,23 @@ i915_gem_execbuffer_relocate_slow(struct
 	int i, total, ret;
 
 	/* We may process another execbuffer during the unlock... */
-	while (!list_empty(objects)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(objects)) {
 		obj = list_first_entry(objects,
 				       struct drm_i915_gem_object,
 				       exec_list);
 		list_del_init(&obj->exec_list);
 		drm_gem_object_unreference(&obj->base);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	mutex_unlock(&dev->struct_mutex);
@@ -1243,7 +1276,12 @@ i915_gem_do_execbuffer(struct drm_device
 
 err:
 	eb_destroy(eb);
-	while (!list_empty(&objects)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&objects)) {
 		struct drm_i915_gem_object *obj;
 
 		obj = list_first_entry(&objects,
@@ -1251,6 +1289,12 @@ err:
 				       exec_list);
 		list_del_init(&obj->exec_list);
 		drm_gem_object_unreference(&obj->base);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	mutex_unlock(&dev->struct_mutex);
diff -u -p a/gpu/drm/i915/intel_i2c.c b/gpu/drm/i915/intel_i2c.c
--- a/gpu/drm/i915/intel_i2c.c
+++ b/gpu/drm/i915/intel_i2c.c
@@ -284,6 +284,11 @@ gmbus_xfer(struct i2c_adapter *adapter,
 				   GMBUS_SLAVE_WRITE | GMBUS_SW_RDY);
 			POSTING_READ(GMBUS2+reg_offset);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (len) {
 				if (wait_for(I915_READ(GMBUS2 + reg_offset) & (GMBUS_SATOER | GMBUS_HW_RDY), 50))
 					goto timeout;
@@ -297,6 +302,12 @@ gmbus_xfer(struct i2c_adapter *adapter,
 
 				I915_WRITE(GMBUS3 + reg_offset, val);
 				POSTING_READ(GMBUS2+reg_offset);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
diff -u -p a/gpu/drm/i915/i915_gem_evict.c b/gpu/drm/i915/i915_gem_evict.c
--- a/gpu/drm/i915/i915_gem_evict.c
+++ b/gpu/drm/i915/i915_gem_evict.c
@@ -130,7 +130,12 @@ i915_gem_evict_something(struct drm_devi
 	}
 
 	/* Nothing found, clean up and bail out! */
-	while (!list_empty(&unwind_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&unwind_list)) {
 		obj = list_first_entry(&unwind_list,
 				       struct drm_i915_gem_object,
 				       exec_list);
@@ -140,6 +145,12 @@ i915_gem_evict_something(struct drm_devi
 
 		list_del_init(&obj->exec_list);
 		drm_gem_object_unreference(&obj->base);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* We expect the caller to unpin, evict all and try again, or give up.
@@ -152,7 +163,12 @@ found:
 	 * scanning, therefore store to be evicted objects on a
 	 * temporary list. */
 	INIT_LIST_HEAD(&eviction_list);
-	while (!list_empty(&unwind_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&unwind_list)) {
 		obj = list_first_entry(&unwind_list,
 				       struct drm_i915_gem_object,
 				       exec_list);
@@ -162,10 +178,21 @@ found:
 		}
 		list_del_init(&obj->exec_list);
 		drm_gem_object_unreference(&obj->base);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Unbinding will emit any required flushes */
-	while (!list_empty(&eviction_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&eviction_list)) {
 		obj = list_first_entry(&eviction_list,
 				       struct drm_i915_gem_object,
 				       exec_list);
@@ -174,6 +201,12 @@ found:
 
 		list_del_init(&obj->exec_list);
 		drm_gem_object_unreference(&obj->base);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
diff -u -p a/gpu/drm/i915/intel_bios.c b/gpu/drm/i915/intel_bios.c
--- a/gpu/drm/i915/intel_bios.c
+++ b/gpu/drm/i915/intel_bios.c
@@ -50,6 +50,11 @@ find_section(struct bdb_header *bdb, int
 	total = bdb->bdb_size;
 
 	/* walk the sections looking for section_id */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (index < total) {
 		current_id = *(base + index);
 		index++;
@@ -58,6 +63,12 @@ find_section(struct bdb_header *bdb, int
 		if (current_id == section_id)
 			return base + index;
 		index += current_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/gpu/drm/i915/i915_gem.c b/gpu/drm/i915/i915_gem.c
--- a/gpu/drm/i915/i915_gem.c
+++ b/gpu/drm/i915/i915_gem.c
@@ -1749,7 +1749,12 @@ i915_gem_request_remove_from_client(stru
 static void i915_gem_reset_ring_lists(struct drm_i915_private *dev_priv,
 				      struct intel_ring_buffer *ring)
 {
-	while (!list_empty(&ring->request_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ring->request_list)) {
 		struct drm_i915_gem_request *request;
 
 		request = list_first_entry(&ring->request_list,
@@ -1759,9 +1764,20 @@ static void i915_gem_reset_ring_lists(st
 		list_del(&request->list);
 		i915_gem_request_remove_from_client(request);
 		kfree(request);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
-	while (!list_empty(&ring->active_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ring->active_list)) {
 		struct drm_i915_gem_object *obj;
 
 		obj = list_first_entry(&ring->active_list,
@@ -1771,6 +1787,12 @@ static void i915_gem_reset_ring_lists(st
 		obj->base.write_domain = 0;
 		list_del_init(&obj->gpu_write_list);
 		i915_gem_object_move_to_inactive(obj);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1810,7 +1832,12 @@ void i915_gem_reset(struct drm_device *d
 	 * to be lost on reset along with the data, so simply move the
 	 * lost bo to the inactive list.
 	 */
-	while (!list_empty(&dev_priv->mm.flushing_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev_priv->mm.flushing_list)) {
 		obj = list_first_entry(&dev_priv->mm.flushing_list,
 				      struct drm_i915_gem_object,
 				      mm_list);
@@ -1818,6 +1845,12 @@ void i915_gem_reset(struct drm_device *d
 		obj->base.write_domain = 0;
 		list_del_init(&obj->gpu_write_list);
 		i915_gem_object_move_to_inactive(obj);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Move everything out of the GPU domains to ensure we do any
@@ -4173,7 +4206,12 @@ void i915_gem_release(struct drm_device
 	 * file_priv.
 	 */
 	spin_lock(&file_priv->mm.lock);
-	while (!list_empty(&file_priv->mm.request_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&file_priv->mm.request_list)) {
 		struct drm_i915_gem_request *request;
 
 		request = list_first_entry(&file_priv->mm.request_list,
@@ -4181,6 +4219,12 @@ void i915_gem_release(struct drm_device
 					   client_list);
 		list_del(&request->client_list);
 		request->file_priv = NULL;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock(&file_priv->mm.lock);
 }
diff -u -p a/gpu/drm/radeon/r600_blit_kms.c b/gpu/drm/radeon/r600_blit_kms.c
--- a/gpu/drm/radeon/r600_blit_kms.c
+++ b/gpu/drm/radeon/r600_blit_kms.c
@@ -527,9 +527,20 @@ int r600_blit_init(struct radeon_device
 		rdev->r600_blit.state_len = r6xx_default_size;
 
 	dwords = rdev->r600_blit.state_len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dwords & 0xf) {
 		packet2s[num_packet2s++] = cpu_to_le32(PACKET2(0));
 		dwords++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	obj_size = dwords * 4;
@@ -689,11 +700,22 @@ int r600_blit_prepare_copy(struct radeon
 		return r;
 
 	/* num loops */
-	while (num_gpu_pages) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_gpu_pages) {
 		num_gpu_pages -=
 			r600_blit_create_rect(num_gpu_pages, NULL, NULL,
 					      rdev->r600_blit.max_dim);
 		num_loops++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* calculate number of loops correctly */
@@ -733,7 +755,12 @@ void r600_kms_blit_copy(struct radeon_de
 		  num_gpu_pages, rdev->r600_blit.vb_used);
 	vb = (u32 *)(rdev->r600_blit.vb_ib->ptr + rdev->r600_blit.vb_used);
 
-	while (num_gpu_pages) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (num_gpu_pages) {
 		int w, h;
 		unsigned size_in_bytes;
 		unsigned pages_per_loop =
@@ -779,5 +806,11 @@ void r600_kms_blit_copy(struct radeon_de
 		src_gpu_addr += size_in_bytes;
 		dst_gpu_addr += size_in_bytes;
 		num_gpu_pages -= pages_per_loop;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
diff -u -p a/gpu/drm/radeon/rs600.c b/gpu/drm/radeon/rs600.c
--- a/gpu/drm/radeon/rs600.c
+++ b/gpu/drm/radeon/rs600.c
@@ -639,6 +639,11 @@ int rs600_irq_process(struct radeon_devi
 	if (!status && !rdev->irq.stat_regs.r500.disp_int) {
 		return IRQ_NONE;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status || rdev->irq.stat_regs.r500.disp_int) {
 		/* SW interrupt */
 		if (G_000044_SW_INT(status)) {
@@ -678,6 +683,12 @@ int rs600_irq_process(struct radeon_devi
 			DRM_DEBUG("HPD2\n");
 		}
 		status = rs600_irq_ack(rdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* reset gui idle ack.  the status bit is broken */
 	rdev->irq.gui_idle_acked = false;
diff -u -p a/gpu/drm/radeon/radeon_i2c.c b/gpu/drm/radeon/radeon_i2c.c
--- a/gpu/drm/radeon/radeon_i2c.c
+++ b/gpu/drm/radeon/radeon_i2c.c
@@ -697,7 +697,12 @@ static int r500_hw_i2c_xfer(struct i2c_a
 		remaining = p->len;
 		buffer_offset = 0;
 		if (p->flags & I2C_M_RD) {
-			while (remaining) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (remaining) {
 				if (remaining > 15)
 					current_count = 15;
 				else
@@ -735,9 +740,20 @@ static int r500_hw_i2c_xfer(struct i2c_a
 					p->buf[buffer_offset + j] = RREG32(AVIVO_DC_I2C_DATA) & 0xff;
 				remaining -= current_count;
 				buffer_offset += current_count;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
-			while (remaining) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (remaining) {
 				if (remaining > 15)
 					current_count = 15;
 				else
@@ -776,6 +792,12 @@ static int r500_hw_i2c_xfer(struct i2c_a
 				}
 				remaining -= current_count;
 				buffer_offset += current_count;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
diff -u -p a/gpu/drm/radeon/evergreen_blit_kms.c b/gpu/drm/radeon/evergreen_blit_kms.c
--- a/gpu/drm/radeon/evergreen_blit_kms.c
+++ b/gpu/drm/radeon/evergreen_blit_kms.c
@@ -648,9 +648,20 @@ int evergreen_blit_init(struct radeon_de
 		rdev->r600_blit.state_len = cayman_default_size;
 
 	dwords = rdev->r600_blit.state_len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dwords & 0xf) {
 		packet2s[num_packet2s++] = cpu_to_le32(PACKET2(0));
 		dwords++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	obj_size = dwords * 4;
diff -u -p a/gpu/drm/radeon/r600_blit.c b/gpu/drm/radeon/r600_blit.c
--- a/gpu/drm/radeon/r600_blit.c
+++ b/gpu/drm/radeon/r600_blit.c
@@ -597,6 +597,11 @@ r600_blit_copy(struct drm_device *dev,
 	if ((size_bytes & 3) || (src_gpu_addr & 3) || (dst_gpu_addr & 3)) {
 		max_bytes = 8192;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (size_bytes) {
 			int cur_size = size_bytes;
 			int src_x = src_gpu_addr & 255;
@@ -682,10 +687,21 @@ r600_blit_copy(struct drm_device *dev,
 			src_gpu_addr += cur_size * h;
 			dst_gpu_addr += cur_size * h;
 			size_bytes -= cur_size * h;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	} else {
 		max_bytes = 8192 * 4;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (size_bytes) {
 			int cur_size = size_bytes;
 			int src_x = (src_gpu_addr & 255);
@@ -772,6 +788,12 @@ r600_blit_copy(struct drm_device *dev,
 			src_gpu_addr += cur_size * h;
 			dst_gpu_addr += cur_size * h;
 			size_bytes -= cur_size * h;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 }
diff -u -p a/gpu/drm/radeon/r100.c b/gpu/drm/radeon/r100.c
--- a/gpu/drm/radeon/r100.c
+++ b/gpu/drm/radeon/r100.c
@@ -736,6 +736,11 @@ int r100_irq_process(struct radeon_devic
 	if (rdev->shutdown) {
 		return IRQ_NONE;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status) {
 		/* SW interrupt */
 		if (status & RADEON_SW_INT_TEST) {
@@ -775,6 +780,12 @@ int r100_irq_process(struct radeon_devic
 			DRM_DEBUG("HPD2\n");
 		}
 		status = r100_irq_ack(rdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* reset gui idle ack.  the status bit is broken */
 	rdev->irq.gui_idle_acked = false;
diff -u -p a/gpu/drm/radeon/r600.c b/gpu/drm/radeon/r600.c
--- a/gpu/drm/radeon/r600.c
+++ b/gpu/drm/radeon/r600.c
@@ -3349,6 +3349,11 @@ restart_ih:
 	r600_irq_ack(rdev);
 
 	rdev->ih.wptr = wptr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rptr != wptr) {
 		/* wptr/rptr are in bytes! */
 		ring_index = rptr / 4;
@@ -3484,6 +3489,12 @@ restart_ih:
 		/* wptr/rptr are in bytes! */
 		rptr += 16;
 		rptr &= rdev->ih.ptr_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* make sure wptr hasn't changed while processing */
 	wptr = r600_get_ih_wptr(rdev);
diff -u -p a/gpu/drm/radeon/r600_cp.c b/gpu/drm/radeon/r600_cp.c
--- a/gpu/drm/radeon/r600_cp.c
+++ b/gpu/drm/radeon/r600_cp.c
@@ -2399,11 +2399,22 @@ int r600_cp_dispatch_indirect(struct drm
 		/* Indirect buffer data must be a multiple of 16 dwords.
 		 * pad the data with a Type-2 CP packet.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (dwords & 0xf) {
 			u32 *data = (u32 *)
 			    ((char *)dev->agp_buffer_map->handle
 			     + buf->offset + start);
 			data[dwords++] = RADEON_CP_PACKET2;
+			if (_cur < timeout) {
+			    rdstcll(_cur);
+			}
+			else {
+			    break;
+			}
 		}
 
 		/* Fire off the indirect buffer */
diff -u -p a/gpu/drm/radeon/radeon_combios.c b/gpu/drm/radeon/radeon_combios.c
--- a/gpu/drm/radeon/radeon_combios.c
+++ b/gpu/drm/radeon/radeon_combios.c
@@ -3008,6 +3008,11 @@ static void combios_parse_mmio_table(str
 	struct radeon_device *rdev = dev->dev_private;
 
 	if (offset) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (RBIOS16(offset)) {
 			uint16_t cmd = ((RBIOS16(offset) & 0xe000) >> 13);
 			uint32_t addr = (RBIOS16(offset) & 0x1fff);
@@ -3078,6 +3083,12 @@ static void combios_parse_mmio_table(str
 			default:
 				break;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -3087,6 +3098,11 @@ static void combios_parse_pll_table(stru
 	struct radeon_device *rdev = dev->dev_private;
 
 	if (offset) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (RBIOS8(offset)) {
 			uint8_t cmd = ((RBIOS8(offset) & 0xc0) >> 6);
 			uint8_t addr = (RBIOS8(offset) & 0x3f);
@@ -3168,6 +3184,12 @@ static void combios_parse_pll_table(stru
 			default:
 				break;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
diff -u -p a/gpu/drm/radeon/radeon_display.c b/gpu/drm/radeon/radeon_display.c
--- a/gpu/drm/radeon/radeon_display.c
+++ b/gpu/drm/radeon/radeon_display.c
@@ -964,6 +964,11 @@ void radeon_compute_pll_legacy(struct ra
 			if (pll_in < pll->pll_in_min || pll_in > pll->pll_in_max)
 				continue;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (min_feed_div < max_feed_div) {
 				uint32_t vco;
 				uint32_t min_frac_feed_div = min_fractional_feed_div;
@@ -984,6 +989,11 @@ void radeon_compute_pll_legacy(struct ra
 					continue;
 				}
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (min_frac_feed_div < max_frac_feed_div) {
 					frac_feedback_div = (min_frac_feed_div + max_frac_feed_div) / 2;
 					tmp = (uint64_t)pll->reference_freq * 10000 * feedback_div;
@@ -1038,11 +1048,23 @@ void radeon_compute_pll_legacy(struct ra
 						min_frac_feed_div = frac_feedback_div + 1;
 					else
 						max_frac_feed_div = frac_feedback_div;
+						if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (current_freq < freq)
 					min_feed_div = feedback_div + 1;
 				else
 					max_feed_div = feedback_div;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 		}
 	}
diff -u -p a/gpu/drm/radeon/evergreen.c b/gpu/drm/radeon/evergreen.c
--- a/gpu/drm/radeon/evergreen.c
+++ b/gpu/drm/radeon/evergreen.c
@@ -2798,6 +2798,11 @@ restart_ih:
 	evergreen_irq_ack(rdev);
 
 	rdev->ih.wptr = wptr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rptr != wptr) {
 		/* wptr/rptr are in bytes! */
 		ring_index = rptr / 4;
@@ -3033,6 +3038,12 @@ restart_ih:
 		/* wptr/rptr are in bytes! */
 		rptr += 16;
 		rptr &= rdev->ih.ptr_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* make sure wptr hasn't changed while processing */
 	wptr = evergreen_get_ih_wptr(rdev);
diff -u -p a/gpu/drm/nouveau/nv50_graph.c b/gpu/drm/nouveau/nv50_graph.c
--- a/gpu/drm/nouveau/nv50_graph.c
+++ b/gpu/drm/nouveau/nv50_graph.c
@@ -923,6 +923,11 @@ nv50_graph_isr(struct drm_device *dev)
 {
 	u32 stat;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((stat = nv_rd32(dev, 0x400100))) {
 		u64 inst = (u64)(nv_rd32(dev, 0x40032c) & 0x0fffffff) << 12;
 		u32 chid = nv50_graph_isr_chid(dev, inst);
@@ -974,6 +979,12 @@ nv50_graph_isr(struct drm_device *dev)
 				chid, inst, subc, class, mthd, data);
 			nv50_fb_vm_trap(dev, 1);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (nv_rd32(dev, 0x400824) & (1 << 31))
diff -u -p a/gpu/drm/nouveau/nv10_graph.c b/gpu/drm/nouveau/nv10_graph.c
--- a/gpu/drm/nouveau/nv10_graph.c
+++ b/gpu/drm/nouveau/nv10_graph.c
@@ -1080,6 +1080,11 @@ nv10_graph_isr(struct drm_device *dev)
 {
 	u32 stat;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -1120,6 +1125,12 @@ nv10_graph_isr(struct drm_device *dev)
 				     "mthd 0x%04x data 0x%08x\n",
 				chid, subc, class, mthd, data);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/nouveau/nv04_graph.c b/gpu/drm/nouveau/nv04_graph.c
--- a/gpu/drm/nouveau/nv04_graph.c
+++ b/gpu/drm/nouveau/nv04_graph.c
@@ -1031,6 +1031,11 @@ nv04_graph_isr(struct drm_device *dev)
 {
 	u32 stat;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -1071,6 +1076,12 @@ nv04_graph_isr(struct drm_device *dev)
 				     "mthd 0x%04x data 0x%08x\n",
 				chid, subc, class, mthd, data);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/nouveau/nv50_vram.c b/gpu/drm/nouveau/nv50_vram.c
--- a/gpu/drm/nouveau/nv50_vram.c
+++ b/gpu/drm/nouveau/nv50_vram.c
@@ -61,11 +61,22 @@ nv50_vram_del(struct drm_device *dev, st
 		return;
 
 	mutex_lock(&mm->mutex);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&mem->regions)) {
 		this = list_first_entry(&mem->regions, struct nouveau_mm_node, rl_entry);
 
 		list_del(&this->rl_entry);
 		nouveau_mm_put(mm, this);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (mem->tag) {
diff -u -p a/gpu/drm/nouveau/nouveau_dma.c b/gpu/drm/nouveau/nouveau_dma.c
--- a/gpu/drm/nouveau/nouveau_dma.c
+++ b/gpu/drm/nouveau/nouveau_dma.c
@@ -194,6 +194,11 @@ nv50_dma_push_wait(struct nouveau_channe
 {
 	uint32_t cnt = 0, prev_get = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (chan->dma.ib_free < count) {
 		uint32_t get = nvchan_rd32(chan, 0x88);
 		if (get != prev_get) {
@@ -210,6 +215,12 @@ nv50_dma_push_wait(struct nouveau_channe
 		chan->dma.ib_free = get - chan->dma.ib_put;
 		if (chan->dma.ib_free <= 0)
 			chan->dma.ib_free += chan->dma.ib_max;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/gpu/drm/nouveau/nouveau_util.c b/gpu/drm/nouveau/nouveau_util.c
--- a/gpu/drm/nouveau/nouveau_util.c
+++ b/gpu/drm/nouveau/nouveau_util.c
@@ -34,6 +34,11 @@ static DEFINE_RATELIMIT_STATE(nouveau_ra
 void
 nouveau_bitfield_print(const struct nouveau_bitfield *bf, u32 value)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bf->name) {
 		if (value & bf->mask) {
 			printk(" %s", bf->name);
@@ -41,6 +46,12 @@ nouveau_bitfield_print(const struct nouv
 		}
 
 		bf++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (value)
@@ -50,10 +61,21 @@ nouveau_bitfield_print(const struct nouv
 const struct nouveau_enum *
 nouveau_enum_find(const struct nouveau_enum *en, u32 value)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (en->name) {
 		if (en->value == value)
 			return en;
 		en++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/gpu/drm/nouveau/nouveau_volt.c b/gpu/drm/nouveau/nouveau_volt.c
--- a/gpu/drm/nouveau/nouveau_volt.c
+++ b/gpu/drm/nouveau/nouveau_volt.c
@@ -188,6 +188,11 @@ nouveau_volt_init(struct drm_device *dev
 		return;
 
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (vidmask) {
 		if (i > nr_vidtag) {
 			NV_DEBUG(dev, "vid bit %d unknown\n", i);
@@ -201,6 +206,12 @@ nouveau_volt_init(struct drm_device *dev
 
 		vidmask >>= 1;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* parse vbios entries into common format */
diff -u -p a/gpu/drm/nouveau/nouveau_bo.c b/gpu/drm/nouveau/nouveau_bo.c
--- a/gpu/drm/nouveau/nouveau_bo.c
+++ b/gpu/drm/nouveau/nouveau_bo.c
@@ -485,6 +485,11 @@ nvc0_bo_move_m2mf(struct nouveau_channel
 	int ret;
 
 	page_count = new_mem->num_pages;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (page_count) {
 		int line_count = (page_count > 2047) ? 2047 : page_count;
 
@@ -508,6 +513,12 @@ nvc0_bo_move_m2mf(struct nouveau_channel
 		page_count -= line_count;
 		src_offset += (PAGE_SIZE * line_count);
 		dst_offset += (PAGE_SIZE * line_count);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -524,6 +535,11 @@ nv50_bo_move_m2mf(struct nouveau_channel
 	u64 dst_offset = node->vma[1].offset;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (length) {
 		u32 amount, stride, height;
 
@@ -598,6 +614,12 @@ nv50_bo_move_m2mf(struct nouveau_channel
 		length -= amount;
 		src_offset += amount;
 		dst_offset += amount;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -630,7 +652,12 @@ nv04_bo_move_m2mf(struct nouveau_channel
 	OUT_RING  (chan, nouveau_bo_mem_ctxdma(bo, chan, new_mem));
 
 	page_count = new_mem->num_pages;
-	while (page_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (page_count) {
 		int line_count = (page_count > 2047) ? 2047 : page_count;
 
 		ret = RING_SPACE(chan, 11);
@@ -653,6 +680,12 @@ nv04_bo_move_m2mf(struct nouveau_channel
 		page_count -= line_count;
 		src_offset += (PAGE_SIZE * line_count);
 		dst_offset += (PAGE_SIZE * line_count);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
diff -u -p a/gpu/drm/nouveau/nouveau_dp.c b/gpu/drm/nouveau/nouveau_dp.c
--- a/gpu/drm/nouveau/nouveau_dp.c
+++ b/gpu/drm/nouveau/nouveau_dp.c
@@ -441,10 +441,21 @@ dp_link_train_commit(struct drm_device *
 
 		if (dp->table[0] < 0x30) {
 			u8 *last = conf + (dp->entry[4] * dp->table[5]);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (lvsw != conf[0] || lpre != conf[1]) {
 				conf += dp->table[5];
 				if (conf >= last)
 					return -EINVAL;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+				break;
+			}
 			}
 
 			conf += 2;
@@ -698,7 +709,12 @@ nouveau_dp_i2c_xfer(struct i2c_adapter *
 		u8 remaining = msg->len;
 		u8 *ptr = msg->buf;
 
-		while (remaining) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (remaining) {
 			u8 cnt = (remaining > 16) ? 16 : remaining;
 			u8 cmd;
 
@@ -716,6 +732,12 @@ nouveau_dp_i2c_xfer(struct i2c_adapter *
 
 			ptr += cnt;
 			remaining -= cnt;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		msg++;
diff -u -p a/gpu/drm/nouveau/nouveau_vm.c b/gpu/drm/nouveau/nouveau_vm.c
--- a/gpu/drm/nouveau/nouveau_vm.c
+++ b/gpu/drm/nouveau/nouveau_vm.c
@@ -45,6 +45,11 @@ nouveau_vm_map_at(struct nouveau_vma *vm
 		u64 phys = (u64)r->offset << 12;
 		u32 num  = r->length >> bits;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (num) {
 			struct nouveau_gpuobj *pgt = vm->pgt[pde].obj[big];
 
@@ -64,6 +69,12 @@ nouveau_vm_map_at(struct nouveau_vma *vm
 			}
 
 			delta += (u64)len << vma->node->type;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -90,6 +101,11 @@ nouveau_vm_map_sg(struct nouveau_vma *vm
 	u32 max  = 1 << (vm->pgt_bits - bits);
 	u32 end, len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num) {
 		struct nouveau_gpuobj *pgt = vm->pgt[pde].obj[big];
 
@@ -107,6 +123,12 @@ nouveau_vm_map_sg(struct nouveau_vma *vm
 			pde++;
 			pte = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	vm->flush(vm);
@@ -125,6 +147,11 @@ nouveau_vm_unmap_at(struct nouveau_vma *
 	u32 max  = 1 << (vm->pgt_bits - bits);
 	u32 end, len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num) {
 		struct nouveau_gpuobj *pgt = vm->pgt[pde].obj[big];
 
@@ -141,6 +168,12 @@ nouveau_vm_unmap_at(struct nouveau_vma *
 			pde++;
 			pte = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	vm->flush(vm);
diff -u -p a/gpu/drm/nouveau/nvc0_fifo.c b/gpu/drm/nouveau/nvc0_fifo.c
--- a/gpu/drm/nouveau/nvc0_fifo.c
+++ b/gpu/drm/nouveau/nvc0_fifo.c
@@ -470,10 +470,21 @@ nvc0_fifo_isr(struct drm_device *dev)
 		u32 units = nv_rd32(dev, 0x00259c);
 		u32 u = units;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (u) {
 			int i = ffs(u) - 1;
 			nvc0_fifo_isr_vm_fault(dev, i);
 			u &= ~(1 << i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		nv_wr32(dev, 0x00259c, units);
@@ -484,10 +495,21 @@ nvc0_fifo_isr(struct drm_device *dev)
 		u32 units = nv_rd32(dev, 0x0025a0);
 		u32 u = units;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (u) {
 			int i = ffs(u) - 1;
 			nvc0_fifo_isr_subfifo_intr(dev, i);
 			u &= ~(1 << i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		nv_wr32(dev, 0x0025a0, units);
diff -u -p a/gpu/drm/nouveau/nv20_graph.c b/gpu/drm/nouveau/nv20_graph.c
--- a/gpu/drm/nouveau/nv20_graph.c
+++ b/gpu/drm/nouveau/nv20_graph.c
@@ -671,6 +671,11 @@ nv20_graph_isr(struct drm_device *dev)
 {
 	u32 stat;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -704,6 +709,12 @@ nv20_graph_isr(struct drm_device *dev)
 				     "mthd 0x%04x data 0x%08x\n",
 				chid, subc, class, mthd, data);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/nouveau/nvc0_fbcon.c b/gpu/drm/nouveau/nvc0_fbcon.c
--- a/gpu/drm/nouveau/nvc0_fbcon.c
+++ b/gpu/drm/nouveau/nvc0_fbcon.c
@@ -134,6 +134,11 @@ nvc0_fbcon_imageblit(struct fb_info *inf
 	OUT_RING  (chan, 0);
 	OUT_RING  (chan, image->dy);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dwords) {
 		int push = dwords > 2047 ? 2047 : dwords;
 
@@ -146,6 +151,12 @@ nvc0_fbcon_imageblit(struct fb_info *inf
 		BEGIN_NVC0(chan, 6, NvSub2D, 0x0860, push);
 		OUT_RINGp(chan, data, push);
 		data += push;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	FIRE_RING(chan);
diff -u -p a/gpu/drm/nouveau/nvc0_fb.c b/gpu/drm/nouveau/nvc0_fb.c
--- a/gpu/drm/nouveau/nvc0_fb.c
+++ b/gpu/drm/nouveau/nvc0_fb.c
@@ -48,11 +48,22 @@ static void
 nvc0_mfb_isr(struct drm_device *dev)
 {
 	u32 units = nv_rd32(dev, 0x00017c);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (units) {
 		u32 subp, unit = ffs(units) - 1;
 		for (subp = 0; subp < 2; subp++)
 			nvc0_mfb_subp_isr(dev, unit, subp);
 		units &= ~(1 << unit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/nouveau/nouveau_connector.c b/gpu/drm/nouveau/nouveau_connector.c
--- a/gpu/drm/nouveau/nouveau_connector.c
+++ b/gpu/drm/nouveau/nouveau_connector.c
@@ -581,6 +581,11 @@ nouveau_connector_scaler_modes_add(struc
 	if (!native)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mode->hdisplay) {
 		if (mode->hdisplay <= native->hdisplay &&
 		    mode->vdisplay <= native->vdisplay) {
@@ -597,6 +602,12 @@ nouveau_connector_scaler_modes_add(struc
 		}
 
 		mode++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return modes;
diff -u -p a/gpu/drm/nouveau/nvc0_vram.c b/gpu/drm/nouveau/nvc0_vram.c
--- a/gpu/drm/nouveau/nvc0_vram.c
+++ b/gpu/drm/nouveau/nvc0_vram.c
@@ -117,6 +117,11 @@ nvc0_vram_init(struct drm_device *dev)
 
 	/* read amount of vram attached to each memory controller */
 	part = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (parts) {
 		u32 psize = nv_rd32(dev, 0x11020c + (part++ * 0x1000));
 		if (psize == 0)
@@ -131,6 +136,12 @@ nvc0_vram_init(struct drm_device *dev)
 
 		NV_DEBUG(dev, "%d: mem_amount 0x%08x\n", part, psize);
 		dev_priv->vram_size += (u64)psize << 20;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if all controllers have the same amount attached, there's no holes */
diff -u -p a/gpu/drm/nouveau/nv50_fbcon.c b/gpu/drm/nouveau/nv50_fbcon.c
--- a/gpu/drm/nouveau/nv50_fbcon.c
+++ b/gpu/drm/nouveau/nv50_fbcon.c
@@ -134,6 +134,11 @@ nv50_fbcon_imageblit(struct fb_info *inf
 	OUT_RING(chan, 0);
 	OUT_RING(chan, image->dy);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dwords) {
 		int push = dwords > 2047 ? 2047 : dwords;
 
@@ -146,6 +151,12 @@ nv50_fbcon_imageblit(struct fb_info *inf
 		BEGIN_RING(chan, NvSub2D, 0x40000860, push);
 		OUT_RINGp(chan, data, push);
 		data += push;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	FIRE_RING(chan);
diff -u -p a/gpu/drm/nouveau/nv50_vm.c b/gpu/drm/nouveau/nv50_vm.c
--- a/gpu/drm/nouveau/nv50_vm.c
+++ b/gpu/drm/nouveau/nv50_vm.c
@@ -93,6 +93,11 @@ nv50_vm_map(struct nouveau_vma *vma, str
 	pte <<= 3;
 	cnt <<= 3;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt) {
 		u32 offset_h = upper_32_bits(phys);
 		u32 offset_l = lower_32_bits(phys);
@@ -112,11 +117,28 @@ nv50_vm_map(struct nouveau_vma *vma, str
 			delta    += block << (vma->node->type - 3);
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (block) {
 			nv_wo32(pgt, pte + 0, offset_l);
 			nv_wo32(pgt, pte + 4, offset_h);
 			pte += 8;
 			block -= 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 }
diff -u -p a/gpu/drm/nouveau/nv04_fbcon.c b/gpu/drm/nouveau/nv04_fbcon.c
--- a/gpu/drm/nouveau/nv04_fbcon.c
+++ b/gpu/drm/nouveau/nv04_fbcon.c
@@ -120,6 +120,11 @@ nv04_fbcon_imageblit(struct fb_info *inf
 	OUT_RING(chan, (image->height << 16) | image->width);
 	OUT_RING(chan, (image->dy << 16) | (image->dx & 0xffff));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dsize) {
 		int iter_len = dsize > 128 ? 128 : dsize;
 
@@ -131,6 +136,12 @@ nv04_fbcon_imageblit(struct fb_info *inf
 		OUT_RINGp(chan, data, iter_len);
 		data += iter_len;
 		dsize -= iter_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	FIRE_RING(chan);
diff -u -p a/gpu/drm/nouveau/nvc0_grctx.c b/gpu/drm/nouveau/nvc0_grctx.c
--- a/gpu/drm/nouveau/nvc0_grctx.c
+++ b/gpu/drm/nouveau/nvc0_grctx.c
@@ -32,7 +32,18 @@ nv_icmd(struct drm_device *dev, u32 icmd
 {
 	nv_wr32(dev, 0x400204, data);
 	nv_wr32(dev, 0x400200, icmd);
-	while (nv_rd32(dev, 0x400700) & 2) {}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (nv_rd32(dev, 0x400700) & 2) {if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 }
 
 static void
@@ -1828,9 +1839,20 @@ nvc0_grctx_generate(struct nouveau_chann
 		/* and the second... */
 		shift = 0;
 		ntpcv = priv->tp_total;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(ntpcv & (1 << 4))) {
 			ntpcv <<= 1;
 			shift++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		data2[0]  = (ntpcv << 16);
diff -u -p a/gpu/drm/nouveau/nouveau_ramht.c b/gpu/drm/nouveau/nouveau_ramht.c
--- a/gpu/drm/nouveau/nouveau_ramht.c
+++ b/gpu/drm/nouveau/nouveau_ramht.c
@@ -297,10 +297,21 @@ nouveau_ramht_ref(struct nouveau_ramht *
 
 	ramht = *ptr;
 	if (ramht) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((entry = nouveau_ramht_remove_entry(chan, 0))) {
 			nouveau_ramht_remove_hash(chan, entry->handle);
 			nouveau_gpuobj_ref(NULL, &entry->gpuobj);
 			kfree(entry);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kref_put(&ramht->refcount, nouveau_ramht_del);
diff -u -p a/gpu/drm/nouveau/nv40_graph.c b/gpu/drm/nouveau/nv40_graph.c
--- a/gpu/drm/nouveau/nv40_graph.c
+++ b/gpu/drm/nouveau/nv40_graph.c
@@ -389,6 +389,11 @@ nv40_graph_isr(struct drm_device *dev)
 {
 	u32 stat;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((stat = nv_rd32(dev, NV03_PGRAPH_INTR))) {
 		u32 nsource = nv_rd32(dev, NV03_PGRAPH_NSOURCE);
 		u32 nstatus = nv_rd32(dev, NV03_PGRAPH_NSTATUS);
@@ -426,6 +431,12 @@ nv40_graph_isr(struct drm_device *dev)
 				     "class 0x%04x mthd 0x%04x data 0x%08x\n",
 				chid, inst, subc, class, mthd, data);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/nouveau/nv04_timer.c b/gpu/drm/nouveau/nv04_timer.c
--- a/gpu/drm/nouveau/nv04_timer.c
+++ b/gpu/drm/nouveau/nv04_timer.c
@@ -25,9 +25,20 @@ nv04_timer_init(struct drm_device *dev)
 	} else {
 		n = dev_priv->crystal;
 		m = 1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (n < (d * 2)) {
 			n += (n / m);
 			m++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		nv_wr32(dev, 0x009220, m - 1);
diff -u -p a/gpu/drm/nouveau/nv50_fifo.c b/gpu/drm/nouveau/nv50_fifo.c
--- a/gpu/drm/nouveau/nv50_fifo.c
+++ b/gpu/drm/nouveau/nv50_fifo.c
@@ -471,13 +471,24 @@ nv50_fifo_unload_context(struct drm_devi
 	put = (nv_rd32(dev, NV03_PFIFO_CACHE1_PUT) & 0x7ff) >> 2;
 	get = (nv_rd32(dev, NV03_PFIFO_CACHE1_GET) & 0x7ff) >> 2;
 	ptr = 0;
-	while (put != get) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (put != get) {
 		nv_wo32(cache, ptr + 0,
 			nv_rd32(dev, NV40_PFIFO_CACHE1_METHOD(get)));
 		nv_wo32(cache, ptr + 4,
 			nv_rd32(dev, NV40_PFIFO_CACHE1_DATA(get)));
 		get = (get + 1) & 0x1ff;
 		ptr += 8;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* guessing that all the 0x34xx regs aren't on NV50 */
diff -u -p a/gpu/drm/nouveau/nouveau_bios.c b/gpu/drm/nouveau/nouveau_bios.c
--- a/gpu/drm/nouveau/nouveau_bios.c
+++ b/gpu/drm/nouveau/nouveau_bios.c
@@ -3847,7 +3847,12 @@ parse_init_tables(struct nvbios *bios)
 		return;
 	}
 
-	while ((table = ROM16(bios->data[bios->init_script_tbls_ptr + i]))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((table = ROM16(bios->data[bios->init_script_tbls_ptr + i]))) {
 		NV_INFO(bios->dev,
 			"Parsing VBIOS init table %d at offset 0x%04X\n",
 			i / 2, table);
@@ -3855,6 +3860,12 @@ parse_init_tables(struct nvbios *bios)
 
 		parse_init_table(bios, table, &iexec);
 		i += 2;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -4758,10 +4769,21 @@ get_pll_register(struct drm_device *dev,
 			map = nv84_pll_mapping;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (map->reg) {
 		if (map->type == type)
 			return map->reg;
 		map++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/gpu/drm/nouveau/nouveau_calc.c b/gpu/drm/nouveau/nouveau_calc.c
--- a/gpu/drm/nouveau/nouveau_calc.c
+++ b/gpu/drm/nouveau/nouveau_calc.c
@@ -75,6 +75,11 @@ nv04_calc_arb(struct nv_fifo_info *fifo,
 	mclk_extra = 3;
 	found = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!found) {
 		found = 1;
 
@@ -103,6 +108,12 @@ nv04_calc_arb(struct nv_fifo_info *fifo,
 
 		fifo->lwm = clwm;
 		fifo->burst = cbs;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/vmwgfx/vmwgfx_fence.c b/gpu/drm/vmwgfx/vmwgfx_fence.c
--- a/gpu/drm/vmwgfx/vmwgfx_fence.c
+++ b/gpu/drm/vmwgfx/vmwgfx_fence.c
@@ -639,7 +639,12 @@ void vmw_fence_fifo_down(struct vmw_fenc
 
 	spin_lock_irqsave(&fman->lock, irq_flags);
 	fman->fifo_down = true;
-	while (!list_empty(&fman->fence_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&fman->fence_list)) {
 		struct vmw_fence_obj *fence =
 			list_entry(fman->fence_list.prev, struct vmw_fence_obj,
 				   head);
@@ -664,6 +669,12 @@ void vmw_fence_fifo_down(struct vmw_fenc
 
 		BUG_ON(!list_empty(&fence->head));
 		kref_put(&fence->kref, vmw_fence_obj_destroy_locked);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&fman->lock, irq_flags);
 }
diff -u -p a/gpu/drm/vmwgfx/vmwgfx_execbuf.c b/gpu/drm/vmwgfx/vmwgfx_execbuf.c
--- a/gpu/drm/vmwgfx/vmwgfx_execbuf.c
+++ b/gpu/drm/vmwgfx/vmwgfx_execbuf.c
@@ -967,10 +967,21 @@ static int vmw_resize_cmd_bounce(struct
 	if (sw_context->cmd_bounce_size == 0)
 		sw_context->cmd_bounce_size = VMWGFX_CMD_BOUNCE_INIT_SIZE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sw_context->cmd_bounce_size < size) {
 		sw_context->cmd_bounce_size =
 			PAGE_ALIGN(sw_context->cmd_bounce_size +
 				   (sw_context->cmd_bounce_size >> 1));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (sw_context->cmd_bounce != NULL)
diff -u -p a/gpu/drm/vmwgfx/vmwgfx_marker.c b/gpu/drm/vmwgfx/vmwgfx_marker.c
--- a/gpu/drm/vmwgfx/vmwgfx_marker.c
+++ b/gpu/drm/vmwgfx/vmwgfx_marker.c
@@ -148,6 +148,11 @@ int vmw_wait_lag(struct vmw_private *dev
 	uint32_t seqno;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!vmw_lag_lt(queue, us)) {
 		spin_lock(&queue->lock);
 		if (list_empty(&queue->head))
@@ -166,6 +171,12 @@ int vmw_wait_lag(struct vmw_private *dev
 			return ret;
 
 		(void) vmw_marker_pull(queue, seqno);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/gpu/drm/vmwgfx/vmwgfx_fifo.c b/gpu/drm/vmwgfx/vmwgfx_fifo.c
--- a/gpu/drm/vmwgfx/vmwgfx_fifo.c
+++ b/gpu/drm/vmwgfx/vmwgfx_fifo.c
@@ -318,6 +318,11 @@ void *vmw_fifo_reserve(struct vmw_privat
 
 	fifo_state->reserved_size = bytes;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		uint32_t stop = ioread32(fifo_mem + SVGA_FIFO_STOP);
 		bool need_bounce = false;
@@ -370,7 +375,13 @@ void *vmw_fifo_reserve(struct vmw_privat
 				return fifo_state->dynamic_buffer;
 			}
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out_err:
 	fifo_state->reserved_size = 0;
 	mutex_unlock(&fifo_state->fifo_mutex);
diff -u -p a/gpu/drm/drm_bufs.c b/gpu/drm/drm_bufs.c
--- a/gpu/drm/drm_bufs.c
+++ b/gpu/drm/drm_bufs.c
@@ -691,6 +691,11 @@ int drm_addbufs_agp(struct drm_device *
 
 	offset = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (entry->buf_count < count) {
 		buf = &entry->buflist[entry->buf_count];
 		buf->idx = dma->buf_count + entry->buf_count;
@@ -723,6 +728,12 @@ int drm_addbufs_agp(struct drm_device *
 		offset += alignment;
 		entry->buf_count++;
 		byte_count += PAGE_SIZE << page_order;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DRM_DEBUG("byte_count: %d\n", byte_count);
@@ -868,6 +879,11 @@ int drm_addbufs_pci(struct drm_device *
 	byte_count = 0;
 	page_count = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (entry->buf_count < count) {
 
 		dmah = drm_pci_alloc(dev, PAGE_SIZE << page_order, 0x1000);
@@ -925,6 +941,12 @@ int drm_addbufs_pci(struct drm_device *
 				  entry->buf_count, buf->address);
 		}
 		byte_count += PAGE_SIZE << page_order;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	temp_buflist = krealloc(dma->buflist,
@@ -1057,6 +1079,11 @@ static int drm_addbufs_sg(struct drm_dev
 
 	offset = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (entry->buf_count < count) {
 		buf = &entry->buflist[entry->buf_count];
 		buf->idx = dma->buf_count + entry->buf_count;
@@ -1090,6 +1117,12 @@ static int drm_addbufs_sg(struct drm_dev
 		offset += alignment;
 		entry->buf_count++;
 		byte_count += PAGE_SIZE << page_order;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DRM_DEBUG("byte_count: %d\n", byte_count);
@@ -1215,6 +1248,11 @@ static int drm_addbufs_fb(struct drm_dev
 
 	offset = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (entry->buf_count < count) {
 		buf = &entry->buflist[entry->buf_count];
 		buf->idx = dma->buf_count + entry->buf_count;
@@ -1247,6 +1285,12 @@ static int drm_addbufs_fb(struct drm_dev
 		offset += alignment;
 		entry->buf_count++;
 		byte_count += PAGE_SIZE << page_order;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DRM_DEBUG("byte_count: %d\n", byte_count);
diff -u -p a/gpu/vga/vgaarb.c b/gpu/vga/vgaarb.c
--- a/gpu/vga/vgaarb.c
+++ b/gpu/vga/vgaarb.c
@@ -462,6 +462,11 @@ static void vga_arbiter_check_bridge_sha
 
 	/* okay iterate the new devices bridge hierarachy */
 	new_bus = vgadev->pdev->bus;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (new_bus) {
 		new_bridge = new_bus->self;
 
@@ -481,6 +486,11 @@ static void vga_arbiter_check_bridge_sha
 			/* now iterate the previous devices bridge hierarchy */
 			/* if the new devices parent bridge is in the other devices
 			   hierarchy then we can't use it to control this device */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (bus) {
 				bridge = bus->self;
 				if (bridge) {
@@ -488,9 +498,21 @@ static void vga_arbiter_check_bridge_sha
 						vgadev->bridge_has_one_vga = false;
 				}
 				bus = bus->parent;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 		}
 		new_bus = new_bus->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/hid/hid-lg4ff.c b/hid/hid-lg4ff.c
--- a/hid/hid-lg4ff.c
+++ b/hid/hid-lg4ff.c
@@ -274,11 +274,22 @@ static void hid_lg4ff_switch_native(stru
 	__u8 i, j;
 
 	j = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j < 7*cmd->cmd_num) {
 		for (i = 0; i < 7; i++)
 			report->field[0]->value[i] = cmd->cmd[j++];
 
 		usbhid_submit_report(hid, report, USB_DIR_OUT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/hid/hid-wiimote.c b/hid/hid-wiimote.c
--- a/hid/hid-wiimote.c
+++ b/hid/hid-wiimote.c
@@ -212,13 +212,24 @@ static void wiimote_worker(struct work_s
 
 	spin_lock_irqsave(&wdata->qlock, flags);
 
-	while (wdata->head != wdata->tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (wdata->head != wdata->tail) {
 		spin_unlock_irqrestore(&wdata->qlock, flags);
 		wiimote_hid_send(wdata->hdev, wdata->outq[wdata->tail].data,
 						wdata->outq[wdata->tail].size);
 		spin_lock_irqsave(&wdata->qlock, flags);
 
 		wdata->tail = (wdata->tail + 1) % WIIMOTE_BUFSIZE;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock_irqrestore(&wdata->qlock, flags);
diff -u -p a/hid/usbhid/hiddev.c b/hid/usbhid/hiddev.c
--- a/hid/usbhid/hiddev.c
+++ b/hid/usbhid/hiddev.c
@@ -392,6 +392,11 @@ static ssize_t hiddev_read(struct file *
 		}
 
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (list->head != list->tail &&
 		       retval + event_size <= count) {
 			if ((list->flags & HIDDEV_FLAG_UREF) == 0) {
@@ -418,6 +423,12 @@ static ssize_t hiddev_read(struct file *
 				}
 			}
 			list->tail = (list->tail + 1) & (HIDDEV_BUFFER_SIZE - 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	}
diff -u -p a/hid/usbhid/hid-core.c b/hid/usbhid/hid-core.c
--- a/hid/usbhid/hid-core.c
+++ b/hid/usbhid/hid-core.c
@@ -713,6 +713,11 @@ void usbhid_init_reports(struct hid_devi
 
 	err = 0;
 	ret = usbhid_wait_io(hid);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ret) {
 		err |= ret;
 		if (test_bit(HID_CTRL_RUNNING, &usbhid->iofl))
@@ -720,6 +725,12 @@ void usbhid_init_reports(struct hid_devi
 		if (test_bit(HID_OUT_RUNNING, &usbhid->iofl))
 			usb_kill_urb(usbhid->urbout);
 		ret = usbhid_wait_io(hid);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (err)
diff -u -p a/hid/hid-debug.c b/hid/hid-debug.c
--- a/hid/hid-debug.c
+++ b/hid/hid-debug.c
@@ -547,6 +547,11 @@ void hid_dump_device(struct hid_device *
 	for (i = 0; i < HID_REPORT_TYPES; i++) {
 		report_enum = device->report_enum + i;
 		list = report_enum->report_list.next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (list != &report_enum->report_list) {
 			report = (struct hid_report *) list;
 			tab(2, f);
@@ -561,6 +566,12 @@ void hid_dump_device(struct hid_device *
 				hid_dump_field(report->field[k], 6, f);
 			}
 			list = list->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
diff -u -p a/ide/ide-proc.c b/ide/ide-proc.c
--- a/ide/ide-proc.c
+++ b/ide/ide-proc.c
@@ -292,6 +292,11 @@ static int ide_settings_proc_show(struct
 	d = drive->settings;
 	seq_printf(m, "name\t\t\tvalue\t\tmin\t\tmax\t\tmode\n");
 	seq_printf(m, "----\t\t\t-----\t\t---\t\t---\t\t----\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (g->name || (d && d->name)) {
 		/* read settings in the alphabetical order */
 		if (g->name && d && d->name) {
@@ -318,6 +323,12 @@ static int ide_settings_proc_show(struct
 		if (ds->set)
 			seq_printf(m, "w");
 		seq_printf(m, "\n");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&ide_setting_mtx);
 	return 0;
@@ -363,9 +374,20 @@ static ssize_t ide_settings_proc_write(s
 	/*
 	 * Skip over leading whitespace
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count && isspace(*s)) {
 		--count;
 		++s;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * Do one full pass to verify all parameters,
diff -u -p a/ide/ide-tape.c b/ide/ide-tape.c
--- a/ide/ide-tape.c
+++ b/ide/ide-tape.c
@@ -687,6 +687,11 @@ static int idetape_wait_ready(ide_drive_
 	/* Wait for the tape to become ready */
 	set_bit(ilog2(IDE_AFLAG_MEDIUM_PRESENT), &drive->atapi_flags);
 	timeout += jiffies;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, timeout)) {
 		if (ide_do_test_unit_ready(drive, disk) == 0)
 			return 0;
@@ -702,6 +707,12 @@ static int idetape_wait_ready(ide_drive_
 			     (tape->ascq == 1 || tape->ascq == 8)))
 			return -EIO;
 		msleep(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EIO;
 }
@@ -992,11 +1003,22 @@ static void idetape_pad_zeros(ide_drive_
 
 	memset(tape->buf, 0, tape->buffer_size);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bcount) {
 		unsigned int count = min(tape->buffer_size, bcount);
 
 		idetape_queue_rw_tail(drive, REQ_IDETAPE_WRITE, count);
 		bcount -= count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1199,7 +1221,12 @@ static ssize_t idetape_chrdev_write(stru
 	if (rc < 0)
 		return rc;
 
-	while (done < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (done < count) {
 		size_t todo;
 
 		/* flush if staging buffer is full */
@@ -1217,6 +1244,12 @@ static ssize_t idetape_chrdev_write(stru
 		tape->cur += todo;
 		tape->valid += todo;
 		done += todo;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret ? ret : done;
diff -u -p a/ide/ide-cd.c b/ide/ide-cd.c
--- a/ide/ide-cd.c
+++ b/ide/ide-cd.c
@@ -1481,12 +1481,23 @@ static unsigned int ide_cd_flags(u16 *id
 {
 	const struct cd_list_entry *cle = ide_cd_quirks_list;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cle->id_model) {
 		if (strcmp(cle->id_model, (char *)&id[ATA_ID_PROD]) == 0 &&
 		    (cle->id_firmware == NULL ||
 		     strstr((char *)&id[ATA_ID_FW_REV], cle->id_firmware)))
 			return cle->cd_flags;
 		cle++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/ide/ns87415.c b/ide/ns87415.c
--- a/ide/ns87415.c
+++ b/ide/ns87415.c
@@ -150,9 +150,20 @@ static void ns87415_prepare_drive (ide_d
 		 * are busy.
 		 */
 		(void) pci_read_config_byte(dev, 0x43, &stat);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (stat & 0x03) {
 			udelay(1);
 			(void) pci_read_config_byte(dev, 0x43, &stat);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		*old = new;
diff -u -p a/ide/tx4939ide.c b/ide/tx4939ide.c
--- a/ide/tx4939ide.c
+++ b/ide/tx4939ide.c
@@ -250,6 +250,11 @@ static int tx4939ide_build_dmatable(ide_
 		 * Fill in the DMA table, without crossing any 64kB boundaries.
 		 */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cur_len) {
 			if (count++ >= PRD_ENTRIES)
 				goto use_pio_instead;
@@ -267,6 +272,12 @@ static int tx4939ide_build_dmatable(ide_
 			*table++ = cur_addr;
 			cur_addr += bcount;
 			cur_len -= bcount;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/ide/ide-dma-sff.c b/ide/ide-dma-sff.c
--- a/ide/ide-dma-sff.c
+++ b/ide/ide-dma-sff.c
@@ -132,6 +132,11 @@ int ide_build_dmatable(ide_drive_t *driv
 		 * but the trm290 requires 32-bit alignment.
 		 */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cur_len) {
 			if (count++ >= PRD_ENTRIES)
 				goto use_pio_instead;
@@ -153,6 +158,12 @@ int ide_build_dmatable(ide_drive_t *driv
 			*table++ = cpu_to_le32(xcount);
 			cur_addr += bcount;
 			cur_len -= bcount;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/ide/ide-taskfile.c b/ide/ide-taskfile.c
--- a/ide/ide-taskfile.c
+++ b/ide/ide-taskfile.c
@@ -235,6 +235,11 @@ void ide_pio_bytes(ide_drive_t *drive, s
 	if (cursg == NULL)
 		cursg = cmd->cursg = sg;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		unsigned nr_bytes = min(len, cursg->length - cmd->cursg_ofs);
 		int page_is_high;
@@ -275,6 +280,12 @@ void ide_pio_bytes(ide_drive_t *drive, s
 			local_irq_restore(flags);
 
 		len -= nr_bytes;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(ide_pio_bytes);
diff -u -p a/ide/buddha.c b/ide/buddha.c
--- a/ide/buddha.c
+++ b/ide/buddha.c
@@ -163,6 +163,11 @@ static int __init buddha_init(void)
 	BuddhaType type;
 	int buddha_num_hwifs, i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((z = zorro_find_device(ZORRO_WILDCARD, z))) {
 		unsigned long board;
 		struct ide_hw hw[MAX_NUM_HWIFS], *hws[MAX_NUM_HWIFS];
@@ -228,6 +233,12 @@ fail_base2:
 		}
 
 		ide_host_add(&d, hws, i, NULL);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/ide/piix.c b/ide/piix.c
--- a/ide/piix.c
+++ b/ide/piix.c
@@ -275,6 +275,11 @@ static u8 piix_cable_detect(ide_hwif_t *
 	u8 reg54h = 0, mask = hwif->channel ? 0xc0 : 0x30;
 
 	/* check for specials */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lap->device) {
 		if (lap->device == pdev->device &&
 		    lap->subvendor == pdev->subsystem_vendor &&
@@ -282,6 +287,12 @@ static u8 piix_cable_detect(ide_hwif_t *
 			return ATA_CBL_PATA40_SHORT;
 		}
 		lap++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pci_read_config_byte(pdev, 0x54, &reg54h);
diff -u -p a/ide/pmac.c b/ide/pmac.c
--- a/ide/pmac.c
+++ b/ide/pmac.c
@@ -1487,6 +1487,11 @@ static int pmac_ide_build_dmatable(ide_d
 
 	/* Build DBDMA commands list */
 	sg = hwif->sg_table;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i && sg_dma_len(sg)) {
 		u32 cur_addr;
 		u32 cur_len;
@@ -1502,7 +1507,12 @@ static int pmac_ide_build_dmatable(ide_d
 			}
 			return 0;
 		}
-		while (cur_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (cur_len) {
 			unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
 
 			if (count++ >= MAX_DCMDS) {
@@ -1519,9 +1529,21 @@ static int pmac_ide_build_dmatable(ide_d
 			cur_addr += tc;
 			cur_len -= tc;
 			++table;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		sg = sg_next(sg);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* convert the last command to an input/output last command */
diff -u -p a/ide/sis5513.c b/ide/sis5513.c
--- a/ide/sis5513.c
+++ b/ide/sis5513.c
@@ -527,12 +527,23 @@ static u8 sis_cable_detect(ide_hwif_t *h
 	const struct sis_laptop *lap = &sis_laptop[0];
 	u8 ata66 = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lap->device) {
 		if (lap->device == pdev->device &&
 		    lap->subvendor == pdev->subsystem_vendor &&
 		    lap->subdevice == pdev->subsystem_device)
 			return ATA_CBL_PATA40_SHORT;
 		lap++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (chipset_family >= ATA_133) {
diff -u -p a/ide/au1xxx-ide.c b/ide/au1xxx-ide.c
--- a/ide/au1xxx-ide.c
+++ b/ide/au1xxx-ide.c
@@ -225,6 +225,11 @@ static int auide_build_dmatable(ide_driv
 
 	/* fill the descriptors */
 	sg = hwif->sg_table;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i && sg_dma_len(sg)) {
 		u32 cur_addr;
 		u32 cur_len;
@@ -232,7 +237,12 @@ static int auide_build_dmatable(ide_driv
 		cur_addr = sg_dma_address(sg);
 		cur_len = sg_dma_len(sg);
 
-		while (cur_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (cur_len) {
 			u32 flags = DDMA_FLAGS_NOIE;
 			unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
 
@@ -264,9 +274,21 @@ static int auide_build_dmatable(ide_driv
 
 			cur_addr += tc;
 			cur_len -= tc;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		sg = sg_next(sg);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (count)
diff -u -p a/ide/sgiioc4.c b/ide/sgiioc4.c
--- a/ide/sgiioc4.c
+++ b/ide/sgiioc4.c
@@ -419,13 +419,23 @@ static int sgiioc4_build_dmatable(ide_dr
 	unsigned int count = 0, i = cmd->sg_nents;
 	struct scatterlist *sg = hwif->sg_table;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i && sg_dma_len(sg)) {
 		dma_addr_t cur_addr;
 		int cur_len;
 		cur_addr = sg_dma_address(sg);
 		cur_len = sg_dma_len(sg);
 
-		while (cur_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (cur_len) {
 			if (count++ >= IOC4_PRD_ENTRIES) {
 				printk(KERN_WARNING
 				       "%s: DMA table too small\n",
@@ -455,10 +465,22 @@ static int sgiioc4_build_dmatable(ide_dr
 				cur_addr += bcount;
 				cur_len -= bcount;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		sg = sg_next(sg);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (count) {
diff -u -p a/ide/ide-iops.c b/ide/ide-iops.c
--- a/ide/ide-iops.c
+++ b/ide/ide-iops.c
@@ -81,9 +81,20 @@ void ide_fixstring(u8 *s, const int byte
 	while (s != end && *s == ' ')
 		++s;
 	/* compress internal blanks and strip trailing blanks */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (s != end && *s) {
 		if (*s++ != ' ' || (s != end && *s && *s != ' '))
 			*p++ = *(s-1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* wipe out trailing garbage */
 	while (p != end)
diff -u -p a/mfd/omap-usb-host.c b/mfd/omap-usb-host.c
--- a/mfd/omap-usb-host.c
+++ b/mfd/omap-usb-host.c
@@ -742,7 +742,12 @@ static int usbhs_enable(struct device *d
 
 	/* Wait for TLL reset to complete */
 	timeout = jiffies + msecs_to_jiffies(1000);
-	while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
 			& OMAP_USBTLL_SYSSTATUS_RESETDONE)) {
 		cpu_relax();
 
@@ -751,6 +756,12 @@ static int usbhs_enable(struct device *d
 			ret = -EINVAL;
 			goto err_tll;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev_dbg(dev, "TLL RESET DONE\n");
@@ -962,38 +973,82 @@ static void usbhs_disable(struct device
 			OMAP_UHH_SYSCONFIG_SOFTRESET);
 
 	timeout = jiffies + msecs_to_jiffies(100);
-	while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
 				& (1 << 0))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
-	while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
 				& (1 << 1))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
-	while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->uhh_base, OMAP_UHH_SYSSTATUS)
 				& (1 << 2))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	usbhs_write(omap->tll_base, OMAP_USBTLL_SYSCONFIG, (1 << 1));
 
-	while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(usbhs_read(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
 				& (1 << 0))) {
 		cpu_relax();
 
 		if (time_after(jiffies, timeout))
 			dev_dbg(dev, "operation timed out\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (is_omap_usbhs_rev2(omap)) {
diff -u -p a/mfd/menelaus.c b/mfd/menelaus.c
--- a/mfd/menelaus.c
+++ b/mfd/menelaus.c
@@ -812,6 +812,11 @@ static void menelaus_work(struct work_st
 		if (!isr)
 			break;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (isr) {
 			int irq = fls(isr) - 1;
 			isr &= ~(1 << irq);
@@ -824,6 +829,12 @@ static void menelaus_work(struct work_st
 				handler(menelaus);
 			menelaus_enable_irq(irq);
 			mutex_unlock(&menelaus->lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	enable_irq(menelaus->client->irq);
diff -u -p a/mfd/mc13xxx-core.c b/mfd/mc13xxx-core.c
--- a/mfd/mc13xxx-core.c
+++ b/mfd/mc13xxx-core.c
@@ -423,6 +423,11 @@ static int mc13xxx_irq_handle(struct mc1
 	if (ret)
 		return ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (stat & ~mask) {
 		int irq = __ffs(stat & ~mask);
 
@@ -443,6 +448,12 @@ static int mc13xxx_irq_handle(struct mc1
 
 			ret = mc13xxx_reg_write(mc13xxx, offmask, mask);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return num_handled;
diff -u -p a/mfd/wm831x-irq.c b/mfd/wm831x-irq.c
--- a/mfd/wm831x-irq.c
+++ b/mfd/wm831x-irq.c
@@ -521,10 +521,21 @@ static irqreturn_t wm831x_irq_thread(int
 		if (primary == WM831X_GP_INT &&
 		    wm831x->gpio_level[i - WM831X_IRQ_GPIO_1]) {
 			ret = wm831x_reg_read(wm831x, WM831X_GPIO_LEVEL);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (ret & 1 << (i - WM831X_IRQ_GPIO_1)) {
 				handle_nested_irq(wm831x->irq_base + i);
 				ret = wm831x_reg_read(wm831x,
 						      WM831X_GPIO_LEVEL);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
diff -u -p a/mfd/stmpe.c b/mfd/stmpe.c
--- a/mfd/stmpe.c
+++ b/mfd/stmpe.c
@@ -263,6 +263,11 @@ int stmpe_set_altfunc(struct stmpe *stmp
 
 	af = variant->get_altfunc(stmpe, block);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pins) {
 		int pin = __ffs(pins);
 		int regoffset = numregs - (pin / afperreg) - 1;
@@ -272,6 +277,12 @@ int stmpe_set_altfunc(struct stmpe *stmp
 		regs[regoffset] |= af << pos;
 
 		pins &= ~(1 << pin);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = __stmpe_block_write(stmpe, regaddr, numregs, regs);
@@ -685,12 +696,23 @@ static irqreturn_t stmpe_irq(int irq, vo
 			continue;
 
 		clear = status;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (status) {
 			int bit = __ffs(status);
 			int line = bank * 8 + bit;
 
 			handle_nested_irq(stmpe->irq_base + line);
 			status &= ~(1 << bit);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		stmpe_reg_write(stmpe, israddr + i, clear);
diff -u -p a/mfd/tc3589x.c b/mfd/tc3589x.c
--- a/mfd/tc3589x.c
+++ b/mfd/tc3589x.c
@@ -166,11 +166,22 @@ again:
 	if (status < 0)
 		return IRQ_NONE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status) {
 		int bit = __ffs(status);
 
 		handle_nested_irq(tc3589x->irq_base + bit);
 		status &= ~(1 << bit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/mfd/ucb1x00-ts.c b/mfd/ucb1x00-ts.c
--- a/mfd/ucb1x00-ts.c
+++ b/mfd/ucb1x00-ts.c
@@ -211,6 +211,11 @@ static int ucb1x00_thread(void *_ts)
 
 	set_freezable();
 	add_wait_queue(&ts->irq_wait, &wait);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		unsigned int x, y, p;
 		signed long timeout;
@@ -270,6 +275,12 @@ static int ucb1x00_thread(void *_ts)
 		try_to_freeze();
 
 		schedule_timeout(timeout);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	remove_wait_queue(&ts->irq_wait, &wait);
diff -u -p a/mfd/twl4030-power.c b/mfd/twl4030-power.c
--- a/mfd/twl4030-power.c
+++ b/mfd/twl4030-power.c
@@ -539,12 +539,23 @@ void __init twl4030_power_init(struct tw
 
 	resconfig = twl4030_scripts->resource_config;
 	if (resconfig) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (resconfig->resource) {
 			err = twl4030_configure_resource(resconfig);
 			if (err)
 				goto resource;
 			resconfig++;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/mfd/tps6586x.c b/mfd/tps6586x.c
--- a/mfd/tps6586x.c
+++ b/mfd/tps6586x.c
@@ -380,6 +380,11 @@ static irqreturn_t tps6586x_irq(int irq,
 
 	acks = le32_to_cpu(acks);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (acks) {
 		int i = __ffs(acks);
 
@@ -387,6 +392,12 @@ static irqreturn_t tps6586x_irq(int irq,
 			handle_nested_irq(tps6586x->irq_base + i);
 
 		acks &= ~(1 << i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return IRQ_HANDLED;
diff -u -p a/mfd/twl4030-irq.c b/mfd/twl4030-irq.c
--- a/mfd/twl4030-irq.c
+++ b/mfd/twl4030-irq.c
@@ -527,6 +527,11 @@ static void twl4030_sih_bus_sync_unlock(
 		}
 
 		/* Modify only the bits we know must change */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (edge_change) {
 			int		i = fls(edge_change) - 1;
 			struct irq_data	*idata;
@@ -545,6 +550,12 @@ static void twl4030_sih_bus_sync_unlock(
 				bytes[byte] |= BIT(off + 0);
 
 			edge_change &= ~BIT(i);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Write */
@@ -606,6 +617,11 @@ static irqreturn_t handle_twl4030_sih(in
 		return IRQ_HANDLED;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (isr) {
 		irq = fls(isr);
 		irq--;
@@ -616,6 +632,12 @@ static irqreturn_t handle_twl4030_sih(in
 		else
 			pr_err("twl4030: %s SIH, invalid ISR bit %d\n",
 				sih->name, irq);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return IRQ_HANDLED;
 }
diff -u -p a/mfd/ab5500-core.c b/mfd/ab5500-core.c
--- a/mfd/ab5500-core.c
+++ b/mfd/ab5500-core.c
@@ -1027,7 +1027,12 @@ static int get_register_page_interruptib
 	if (err)
 		return err;
 
-	while (numregs) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (numregs) {
 		/* The hardware limit for get page is 4 */
 		u8 curnum = min_t(u8, numregs, 4u);
 
@@ -1039,7 +1044,13 @@ static int get_register_page_interruptib
 		numregs -= curnum;
 		first_reg += curnum;
 		regvals += curnum;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	mutex_unlock(&ab->access_mutex);
diff -u -p a/mmc/card/mmc_test.c b/mmc/card/mmc_test.c
--- a/mmc/card/mmc_test.c
+++ b/mmc/card/mmc_test.c
@@ -455,9 +455,19 @@ static int mmc_test_map_sg_max_scatter(s
 	sg_init_table(sglist, max_segs);
 
 	*sg_len = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sz) {
 		base = page_address(mem->arr[--i].page);
 		cnt = 1 << mem->arr[i].order;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sz && cnt) {
 			addr = base + PAGE_SIZE * --cnt;
 			if (last_addr && last_addr + PAGE_SIZE == addr)
@@ -477,9 +487,21 @@ static int mmc_test_map_sg_max_scatter(s
 			sg_set_page(sg, virt_to_page(addr), len, 0);
 			sz -= len;
 			*sg_len += 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (i == 0)
 			i = mem->cnt;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (sg)
diff -u -p a/mmc/core/sdio_io.c b/mmc/core/sdio_io.c
--- a/mmc/core/sdio_io.c
+++ b/mmc/core/sdio_io.c
@@ -314,6 +314,11 @@ static int sdio_io_rw_ext_helper(struct
 			func->card->host->max_seg_size / func->cur_blksize);
 		max_blocks = min(max_blocks, 511u);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (remainder > func->cur_blksize) {
 			unsigned blocks;
 
@@ -332,6 +337,12 @@ static int sdio_io_rw_ext_helper(struct
 			buf += size;
 			if (incr_addr)
 				addr += size;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 
diff -u -p a/mmc/core/sdio_cis.c b/mmc/core/sdio_cis.c
--- a/mmc/core/sdio_cis.c
+++ b/mmc/core/sdio_cis.c
@@ -354,10 +354,21 @@ void sdio_free_common_cis(struct mmc_car
 
 	tuple = card->tuples;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tuple) {
 		victim = tuple;
 		tuple = tuple->next;
 		kfree(victim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	card->tuples = NULL;
@@ -395,10 +406,21 @@ void sdio_free_func_cis(struct sdio_func
 
 	tuple = func->tuples;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tuple && tuple != func->card->tuples) {
 		victim = tuple;
 		tuple = tuple->next;
 		kfree(victim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	func->tuples = NULL;
diff -u -p a/mmc/core/sdio_bus.c b/mmc/core/sdio_bus.c
--- a/mmc/core/sdio_bus.c
+++ b/mmc/core/sdio_bus.c
@@ -75,10 +75,21 @@ static const struct sdio_device_id *sdio
 	ids = sdrv->id_table;
 
 	if (ids) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ids->class || ids->vendor || ids->device) {
 			if (sdio_match_one(func, ids))
 				return ids;
 			ids++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/mmc/host/mmc_spi.c b/mmc/host/mmc_spi.c
--- a/mmc/host/mmc_spi.c
+++ b/mmc/host/mmc_spi.c
@@ -324,9 +324,20 @@ checkstatus:
 			end = cp+1;
 		}
 		rotator |= *cp++;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (rotator & 0x8000) {
 			bitshift++;
 			rotator <<= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		cmd->resp[0] = rotator >> 8;
 		leftover = rotator;
@@ -808,9 +819,20 @@ mmc_spi_readblock(struct mmc_spi_host *h
 	 * the first 0-bit precedes the data stream.
 	 */
 	bitshift = 7;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & 0x80) {
 		status <<= 1;
 		bitshift--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	leftover = status << 1;
 
diff -u -p a/mmc/host/dw_mmc.c b/mmc/host/dw_mmc.c
--- a/mmc/host/dw_mmc.c
+++ b/mmc/host/dw_mmc.c
@@ -533,10 +533,21 @@ static void mci_send_cmd(struct dw_mci_s
 	wmb();
 	mci_writel(host, CMD, SDMMC_CMD_START | cmd);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, timeout)) {
 		cmd_status = mci_readl(host, CMD);
 		if (!(cmd_status & SDMMC_CMD_START))
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	dev_err(&slot->mmc->class_dev,
 		"Timeout sending command (cmd %#x arg %#x status %#x)\n",
@@ -1551,7 +1562,12 @@ static void dw_mci_work_routine_card(str
 		u32 ctrl;
 
 		present = dw_mci_get_cd(mmc);
-		while (present != slot->last_detect_state) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (present != slot->last_detect_state) {
 			dev_dbg(&slot->mmc->class_dev, "card %s\n",
 				present ? "inserted" : "removed");
 
@@ -1645,6 +1661,12 @@ static void dw_mci_work_routine_card(str
 				host->pdata->setpower(slot->id, 0);
 
 			present = dw_mci_get_cd(mmc);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		mmc_detect_change(slot->mmc,
diff -u -p a/mmc/host/at91_mci.c b/mmc/host/at91_mci.c
--- a/mmc/host/at91_mci.c
+++ b/mmc/host/at91_mci.c
@@ -449,9 +449,20 @@ static void at91_mci_send_command(struct
 		pr_debug("Clearing timeout\n");
 		at91_mci_write(host, AT91_MCI_ARGR, 0);
 		at91_mci_write(host, AT91_MCI_CMDR, AT91_MCI_OPDCMD);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(at91_mci_read(host, AT91_MCI_SR) & AT91_MCI_CMDRDY)) {
 			/* spin */
 			pr_debug("Clearing: SR = %08X\n", at91_mci_read(host, AT91_MCI_SR));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/mmc/host/jz4740_mmc.c b/mmc/host/jz4740_mmc.c
--- a/mmc/host/jz4740_mmc.c
+++ b/mmc/host/jz4740_mmc.c
@@ -243,11 +243,21 @@ static bool jz4740_mmc_write_data(struct
 	bool timeout;
 	size_t i, j;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sg_miter_next(miter)) {
 		buf = miter->addr;
 		i = miter->length / 4;
 		j = i / 8;
 		i = i & 0x7;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (j) {
 			timeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_TXFIFO_WR_REQ);
 			if (unlikely(timeout))
@@ -263,19 +273,42 @@ static bool jz4740_mmc_write_data(struct
 			writel(buf[7], fifo_addr);
 			buf += 8;
 			--j;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (unlikely(i)) {
 			timeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_TXFIFO_WR_REQ);
 			if (unlikely(timeout))
 				goto poll_timeout;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (i) {
 				writel(*buf, fifo_addr);
 				++buf;
 				--i;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		data->bytes_xfered += miter->length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	sg_miter_stop(miter);
 
@@ -300,11 +333,21 @@ static bool jz4740_mmc_read_data(struct
 	size_t i, j;
 	unsigned int timeout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sg_miter_next(miter)) {
 		buf = miter->addr;
 		i = miter->length;
 		j = i / 32;
 		i = i & 0x1f;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (j) {
 			timeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_RXFIFO_RD_REQ);
 			if (unlikely(timeout))
@@ -321,6 +364,12 @@ static bool jz4740_mmc_read_data(struct
 
 			buf += 8;
 			--j;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (unlikely(i)) {
@@ -342,6 +391,12 @@ static bool jz4740_mmc_read_data(struct
 		/* This can go away once MIPS implements
 		 * flush_kernel_dcache_page */
 		flush_dcache_page(miter->page);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	sg_miter_stop(miter);
 
diff -u -p a/mmc/host/sdhci.c b/mmc/host/sdhci.c
--- a/mmc/host/sdhci.c
+++ b/mmc/host/sdhci.c
@@ -198,7 +198,12 @@ static void sdhci_reset(struct sdhci_hos
 	timeout = 100;
 
 	/* hw clears the bit when it's done */
-	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
 		if (timeout == 0) {
 			pr_err("%s: Reset 0x%x never completed.\n",
 				mmc_hostname(host->mmc), (int)mask);
@@ -207,6 +212,12 @@ static void sdhci_reset(struct sdhci_hos
 		}
 		timeout--;
 		mdelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (host->ops->platform_reset_exit)
@@ -303,6 +314,11 @@ static void sdhci_read_block_pio(struct
 
 	local_irq_save(flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (blksize) {
 		if (!sg_miter_next(&host->sg_miter))
 			BUG();
@@ -314,6 +330,11 @@ static void sdhci_read_block_pio(struct
 
 		buf = host->sg_miter.addr;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			if (chunk == 0) {
 				scratch = sdhci_readl(host, SDHCI_BUFFER);
@@ -326,6 +347,18 @@ static void sdhci_read_block_pio(struct
 			scratch >>= 8;
 			chunk--;
 			len--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -349,6 +382,11 @@ static void sdhci_write_block_pio(struct
 
 	local_irq_save(flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (blksize) {
 		if (!sg_miter_next(&host->sg_miter))
 			BUG();
@@ -360,6 +398,11 @@ static void sdhci_write_block_pio(struct
 
 		buf = host->sg_miter.addr;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			scratch |= (u32)*buf << (chunk * 8);
 
@@ -372,6 +415,18 @@ static void sdhci_write_block_pio(struct
 				chunk = 0;
 				scratch = 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -970,7 +1025,12 @@ static void sdhci_send_command(struct sd
 	if (host->mrq->data && (cmd == host->mrq->data->stop))
 		mask &= ~SDHCI_DATA_INHIBIT;
 
-	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
 		if (timeout == 0) {
 			pr_err("%s: Controller never released "
 				"inhibit bit(s).\n", mmc_hostname(host->mmc));
@@ -981,6 +1041,12 @@ static void sdhci_send_command(struct sd
 		}
 		timeout--;
 		mdelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mod_timer(&host->timer, jiffies + 10 * HZ);
@@ -1141,7 +1207,12 @@ static void sdhci_set_clock(struct sdhci
 
 	/* Wait max 20 ms */
 	timeout = 20;
-	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
 		& SDHCI_CLOCK_INT_STABLE)) {
 		if (timeout == 0) {
 			pr_err("%s: Internal clock never "
@@ -1151,6 +1222,12 @@ static void sdhci_set_clock(struct sdhci
 		}
 		timeout--;
 		mdelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	clk |= SDHCI_CLOCK_CARD_EN;
diff -u -p a/mmc/host/s3cmci.c b/mmc/host/s3cmci.c
--- a/mmc/host/s3cmci.c
+++ b/mmc/host/s3cmci.c
@@ -369,6 +369,11 @@ static void do_pio_read(struct s3cmci_ho
 
 	from_ptr = host->base + host->sdidata;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((fifo = fifo_count(host))) {
 		if (!host->pio_bytes) {
 			res = get_data_buffer(host, &host->pio_bytes,
@@ -421,6 +426,12 @@ static void do_pio_read(struct s3cmci_ho
 				data >>= 8;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!host->pio_bytes) {
@@ -988,7 +999,12 @@ static int s3cmci_setup_data(struct s3cm
 		}
 	}
 
-	while (readl(host->base + S3C2410_SDIDSTA) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (readl(host->base + S3C2410_SDIDSTA) &
 	       (S3C2410_SDIDSTA_TXDATAON | S3C2410_SDIDSTA_RXDATAON)) {
 
 		dbg(host, dbg_err,
@@ -1001,6 +1017,12 @@ static int s3cmci_setup_data(struct s3cm
 			dbg_dumpregs(host, "DRF");
 			return -EINVAL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dcon  = data->blocks & S3C2410_SDIDCON_BLKNUM_MASK;
diff -u -p a/mmc/host/tifm_sd.c b/mmc/host/tifm_sd.c
--- a/mmc/host/tifm_sd.c
+++ b/mmc/host/tifm_sd.c
@@ -174,6 +174,11 @@ static void tifm_sd_transfer_data(struct
 
 	if (host->sg_pos == host->sg_len)
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (t_size) {
 		cnt = sg[host->sg_pos].length - host->block_pos;
 		if (!cnt) {
@@ -205,6 +210,12 @@ static void tifm_sd_transfer_data(struct
 
 		t_size -= p_cnt;
 		host->block_pos += p_cnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -230,6 +241,11 @@ static void tifm_sd_bounce_block(struct
 	struct page *pg;
 
 	dev_dbg(&host->dev->dev, "bouncing block\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (t_size) {
 		cnt = sg[host->sg_pos].length - host->block_pos;
 		if (!cnt) {
@@ -257,6 +273,12 @@ static void tifm_sd_bounce_block(struct
 
 		t_size -= p_cnt;
 		host->block_pos += p_cnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mmc/host/omap.c b/mmc/host/omap.c
--- a/mmc/host/omap.c
+++ b/mmc/host/omap.c
@@ -472,21 +472,43 @@ mmc_omap_send_abort(struct mmc_omap_host
 	/* Sending abort takes 80 clocks. Have some extra and round up */
 	timeout = (120*1000000 + slot->fclk_freq - 1)/slot->fclk_freq;
 	restarts = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (restarts < maxloops) {
 		OMAP_MMC_WRITE(host, STAT, 0xFFFF);
 		OMAP_MMC_WRITE(host, CMD, (3 << 12) | (1 << 7));
 
 		passes = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (passes < timeout) {
 			stat = OMAP_MMC_READ(host, STAT);
 			if (stat & OMAP_MMC_STAT_END_OF_CMD)
 				goto out;
 			udelay(1);
 			passes++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		restarts++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	OMAP_MMC_WRITE(host, STAT, stat);
 }
diff -u -p a/mmc/host/sdricoh_cs.c b/mmc/host/sdricoh_cs.c
--- a/mmc/host/sdricoh_cs.c
+++ b/mmc/host/sdricoh_cs.c
@@ -226,15 +226,37 @@ static int sdricoh_blockio(struct sdrico
 			return -ETIMEDOUT;
 		sdricoh_writel(host, R21C_STATUS, 0x18);
 		/* read data */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			data = sdricoh_readl(host, R230_DATA);
 			size = min(len, 4);
 			len -= size;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (size) {
 				*buf = data & 0xFF;
 				buf++;
 				data >>= 8;
 				size--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
 			}
 		}
 	} else {
@@ -243,16 +265,38 @@ static int sdricoh_blockio(struct sdrico
 			return -ETIMEDOUT;
 		sdricoh_writel(host, R21C_STATUS, 0x18);
 		/* write data */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			size = min(len, 4);
 			len -= size;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (size) {
 				data >>= 8;
 				data |= (u32)*buf << 24;
 				buf++;
 				size--;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 			}
 			sdricoh_writel(host, R230_DATA, data);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -481,7 +525,12 @@ static int sdricoh_pcmcia_probe(struct p
 
 	/* search pci cardbus bridge that contains the mmc controller */
 	/* the io region is already claimed by yenta_socket... */
-	while ((pci_dev =
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((pci_dev =
 		pci_get_device(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C476,
 			       pci_dev))) {
 		/* try to init the device */
@@ -490,6 +539,12 @@ static int sdricoh_pcmcia_probe(struct p
 			return 0;
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_err(&pcmcia_dev->dev, "No MMC controller was found.\n");
 	return -ENODEV;
diff -u -p a/mmc/host/wbsd.c b/mmc/host/wbsd.c
--- a/mmc/host/wbsd.c
+++ b/mmc/host/wbsd.c
@@ -432,6 +432,11 @@ static void wbsd_empty_fifo(struct wbsd_
 	 * Drain the fifo. This has a tendency to loop longer
 	 * than the FIFO length (usually one block).
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_EMPTY)) {
 		/*
 		 * The size field in the FSR is broken so we have to
@@ -465,6 +470,12 @@ static void wbsd_empty_fifo(struct wbsd_
 				buffer = wbsd_sg_to_buffer(host);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -495,6 +506,11 @@ static void wbsd_fill_fifo(struct wbsd_h
 	 * Fill the fifo. This has a tendency to loop longer
 	 * than the FIFO length (usually one block).
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_FULL)) {
 		/*
 		 * The size field in the FSR is broken so we have to
@@ -528,6 +544,12 @@ static void wbsd_fill_fifo(struct wbsd_h
 				buffer = wbsd_sg_to_buffer(host);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/mmc/host/msm_sdcc.c b/mmc/host/msm_sdcc.c
--- a/mmc/host/msm_sdcc.c
+++ b/mmc/host/msm_sdcc.c
@@ -648,11 +648,22 @@ msmsdcc_pio_write(struct msmsdcc_host *h
 static int
 msmsdcc_spin_on_status(struct msmsdcc_host *host, uint32_t mask, int maxspin)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (maxspin) {
 		if ((msmsdcc_readl(host, MMCISTATUS) & mask))
 			return 0;
 		udelay(1);
 		--maxspin;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -ETIMEDOUT;
 }
diff -u -p a/mmc/host/imxmmc.c b/mmc/host/imxmmc.c
--- a/mmc/host/imxmmc.c
+++ b/mmc/host/imxmmc.c
@@ -202,7 +202,12 @@ static int imxmci_busy_wait_for_status(s
 {
 	int loops = 0;
 
-	while (!(*pstat & stat_mask)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(*pstat & stat_mask)) {
 		loops += 2;
 		if (loops >= timeout) {
 			dev_dbg(mmc_dev(host->mmc), "busy wait timeout in %s, STATUS = 0x%x (0x%x)\n",
@@ -211,6 +216,12 @@ static int imxmci_busy_wait_for_status(s
 		}
 		udelay(2);
 		*pstat |= readw(host->base + MMC_REG_STATUS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!loops)
 		return 0;
@@ -602,6 +613,11 @@ static int imxmci_cpu_driven_data(struct
 					    STATUS_APPL_BUFF_FE,
 					    20, "imxmci_cpu_driven_data write");
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((stat & STATUS_APPL_BUFF_FE) &&
 		       (host->data_cnt < host->dma_size)) {
 			if (burst_len >= host->dma_size - host->data_cnt) {
@@ -619,6 +635,12 @@ static int imxmci_cpu_driven_data(struct
 
 			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data write burst %d STATUS = 0x%x\n",
 				burst_len, stat);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/can/flexcan.c b/net/can/flexcan.c
--- a/net/can/flexcan.c
+++ b/net/can/flexcan.c
@@ -547,10 +547,21 @@ static int flexcan_poll(struct napi_stru
 
 	/* handle RX-FIFO */
 	reg_iflag1 = flexcan_read(&regs->iflag1);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE &&
 	       work_done < quota) {
 		work_done += flexcan_read_frame(dev);
 		reg_iflag1 = flexcan_read(&regs->iflag1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* report bus errors */
diff -u -p a/net/can/bfin_can.c b/net/can/bfin_can.c
--- a/net/can/bfin_can.c
+++ b/net/can/bfin_can.c
@@ -105,13 +105,24 @@ static void bfin_can_set_reset_mode(stru
 	SSYNC();
 	bfin_write(&reg->control, CCR);
 	SSYNC();
-	while (!(bfin_read(&reg->control) & CCA)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(bfin_read(&reg->control) & CCA)) {
 		udelay(10);
 		if (--timeout == 0) {
 			dev_err(dev->dev.parent,
 					"fail to enter configuration mode\n");
 			BUG();
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -162,13 +173,24 @@ static void bfin_can_set_normal_mode(str
 	 */
 	bfin_write(&reg->control, bfin_read(&reg->control) & ~CCR);
 
-	while (bfin_read(&reg->status) & CCA) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (bfin_read(&reg->status) & CCA) {
 		udelay(10);
 		if (--timeout == 0) {
 			dev_err(dev->dev.parent,
 					"fail to leave configuration mode\n");
 			BUG();
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -633,13 +655,24 @@ static int bfin_can_suspend(struct platf
 		/* enter sleep mode */
 		bfin_write(&reg->control, bfin_read(&reg->control) | SMR);
 		SSYNC();
-		while (!(bfin_read(&reg->intr) & SMACK)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!(bfin_read(&reg->intr) & SMACK)) {
 			udelay(10);
 			if (--timeout == 0) {
 				dev_err(dev->dev.parent,
 						"fail to enter sleep mode\n");
 				BUG();
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/can/c_can/c_can.c b/net/can/c_can/c_can.c
--- a/net/can/c_can/c_can.c
+++ b/net/can/c_can/c_can.c
@@ -234,11 +234,22 @@ static inline int c_can_msg_obj_is_busy(
 {
 	int count = MIN_TIMEOUT_VALUE;
 
-	while (count && priv->read_reg(priv,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count && priv->read_reg(priv,
 				&priv->regs->ifregs[iface].com_req) &
 				IF_COMR_BUSY) {
 		count--;
 		udelay(1);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (!count)
diff -u -p a/net/can/mcp251x.c b/net/can/mcp251x.c
--- a/net/can/mcp251x.c
+++ b/net/can/mcp251x.c
@@ -566,13 +566,24 @@ static int mcp251x_set_normal_mode(struc
 
 		/* Wait for the device to enter normal mode */
 		timeout = jiffies + HZ;
-		while (mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK) {
 			schedule();
 			if (time_after(jiffies, timeout)) {
 				dev_err(&spi->dev, "MCP251x didn't"
 					" enter in normal mode\n");
 				return -EBUSY;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	priv->can.state = CAN_STATE_ERROR_ACTIVE;
diff -u -p a/net/can/sja1000/sja1000.c b/net/can/sja1000/sja1000.c
--- a/net/can/sja1000/sja1000.c
+++ b/net/can/sja1000/sja1000.c
@@ -514,12 +514,23 @@ irqreturn_t sja1000_interrupt(int irq, v
 		}
 		if (isrc & IRQ_RI) {
 			/* receive interrupt */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (status & SR_RBS) {
 				sja1000_rx(dev);
 				status = priv->read_reg(priv, SJA1000_REG_SR);
 				/* check for absent controller */
 				if (status == 0xFF && sja1000_is_absent(priv))
 					goto out;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 			}
 		}
 		if (isrc & (IRQ_DOI | IRQ_EI | IRQ_BEI | IRQ_EPI | IRQ_ALI)) {
diff -u -p a/net/can/softing/softing_fw.c b/net/can/softing/softing_fw.c
--- a/net/can/softing/softing_fw.c
+++ b/net/can/softing/softing_fw.c
@@ -409,10 +409,21 @@ ktime_t softing_raw2ktime(struct softing
 	target = ktime_add_us(card->ts_ref, rawl);
 	/* test for overflows */
 	tmp = ktime_add(target, card->ts_overflow);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (unlikely(ktime_to_ns(tmp) > ktime_to_ns(now))) {
 		card->ts_ref = ktime_add(card->ts_ref, card->ts_overflow);
 		target = tmp;
 		tmp = ktime_add(target, card->ts_overflow);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return ktime_add(target, real_offset);
 }
diff -u -p a/net/ppp/ppp_generic.c b/net/ppp/ppp_generic.c
--- a/net/ppp/ppp_generic.c
+++ b/net/ppp/ppp_generic.c
@@ -1955,6 +1955,11 @@ ppp_receive_mp_frame(struct ppp *ppp, st
 	}
 
 	/* Pull completed packets off the queue and receive them. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = ppp_mp_reconstruct(ppp))) {
 		if (pskb_may_pull(skb, 2))
 			ppp_receive_nonmp_frame(ppp, skb);
@@ -1963,6 +1968,12 @@ ppp_receive_mp_frame(struct ppp *ppp, st
 			kfree_skb(skb);
 			ppp_receive_error(ppp);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return;
diff -u -p a/net/ppp/ppp_async.c b/net/ppp/ppp_async.c
--- a/net/ppp/ppp_async.c
+++ b/net/ppp/ppp_async.c
@@ -584,12 +584,23 @@ ppp_async_encode(struct asyncppp *ap)
 	 * of free space in the output buffer.
 	 */
 	buflim = ap->obuf + OBUFSIZE - 6;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < count && buf < buflim) {
 		c = data[i++];
 		if (i == 1 && c == 0 && (ap->flags & SC_COMP_PROT))
 			continue;	/* compress protocol field */
 		fcs = PPP_FCS(fcs, c);
 		PUT_BYTE(ap, buf, c, islcp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (i < count) {
diff -u -p a/net/ppp/ppp_mppe.c b/net/ppp/ppp_mppe.c
--- a/net/ppp/ppp_mppe.c
+++ b/net/ppp/ppp_mppe.c
@@ -548,9 +548,20 @@ mppe_decompress(void *arg, unsigned char
 
 	if (!state->stateful) {
 		/* RFC 3078, sec 8.1.  Rekey for every packet. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (state->ccount != ccount) {
 			mppe_rekey(state, 0);
 			state->ccount = (state->ccount + 1) % MPPE_CCOUNT_SPACE;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		/* RFC 3078, sec 8.2. */
@@ -573,12 +584,23 @@ mppe_decompress(void *arg, unsigned char
 				return DECOMP_ERROR;
 			} else {
 				/* Rekey for every missed "flag" packet. */
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while ((ccount & ~0xff) !=
 				       (state->ccount & ~0xff)) {
 					mppe_rekey(state, 0);
 					state->ccount =
 					    (state->ccount +
 					     256) % MPPE_CCOUNT_SPACE;
+					    if (_cur < timeout) {
+		rdstcll(_cur);
+					    }
+					    else {
+		break;
+					    }
 				}
 
 				/* reset */
diff -u -p a/net/ppp/pppoe.c b/net/ppp/pppoe.c
--- a/net/ppp/pppoe.c
+++ b/net/ppp/pppoe.c
@@ -170,12 +170,23 @@ static struct pppox_sock *__get_item(str
 	struct pppox_sock *ret;
 
 	ret = pn->hash_table[hash];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ret) {
 		if (cmp_addr(&ret->pppoe_pa, sid, addr) &&
 		    ret->pppoe_ifindex == ifindex)
 			return ret;
 
 		ret = ret->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
@@ -187,12 +198,23 @@ static int __set_item(struct pppoe_net *
 	struct pppox_sock *ret;
 
 	ret = pn->hash_table[hash];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ret) {
 		if (cmp_2_addr(&ret->pppoe_pa, &po->pppoe_pa) &&
 		    ret->pppoe_ifindex == po->pppoe_ifindex)
 			return -EALREADY;
 
 		ret = ret->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	po->next = pn->hash_table[hash];
@@ -295,8 +317,19 @@ static void pppoe_flush_dev(struct net_d
 		struct sock *sk;
 
 		while (po) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (po && po->pppoe_dev != dev) {
 				po = po->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			if (!po)
@@ -1024,10 +1057,21 @@ static inline struct pppox_sock *pppoe_g
 
 	for (i = 0; i < PPPOE_HASH_SIZE; i++) {
 		po = pn->hash_table[i];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (po) {
 			if (!pos--)
 				goto out;
 			po = po->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/usb/sierra_net.c b/net/usb/sierra_net.c
--- a/net/usb/sierra_net.c
+++ b/net/usb/sierra_net.c
@@ -851,6 +851,11 @@ static int sierra_net_rx_fixup(struct us
 	dev_dbg(&dev->udev->dev, "%s", __func__);
 
 	/* could contain multiple packets */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (likely(skb->len)) {
 		err = parse_hip(skb->data, skb->len, &hh);
 		if (err) {
@@ -887,6 +892,12 @@ static int sierra_net_rx_fixup(struct us
 		if (new_skb)
 			usbnet_skb_return(dev, new_skb);
 
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	} /* while */
 
 	return 0;
diff -u -p a/net/usb/hso.c b/net/usb/hso.c
--- a/net/usb/hso.c
+++ b/net/usb/hso.c
@@ -880,7 +880,12 @@ static void packetizeRx(struct hso_net *
 	D1("Rx %d bytes", count);
 	DUMP(ip_pkt, min(128, (int)count));
 
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (count) {
 		switch (odev->rx_parse_state) {
 		case WAIT_IP:
 			/* waiting for IP header. */
@@ -985,6 +990,12 @@ static void packetizeRx(struct hso_net *
 			count--;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Recovery mechanism for WAIT_SYNC state. */
@@ -1170,6 +1181,11 @@ static void put_rxbuf_data_and_resubmit_
 	int count;
 	struct urb *curr_urb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (serial->rx_urb_filled[serial->curr_rx_urb_idx]) {
 		curr_urb = serial->rx_urb[serial->curr_rx_urb_idx];
 		count = put_rxbuf_data(curr_urb, serial);
@@ -1181,6 +1197,12 @@ static void put_rxbuf_data_and_resubmit_
 				serial->curr_rx_urb_idx = 0;
 			hso_resubmit_rx_bulk_urb(serial, curr_urb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2061,7 +2083,12 @@ static int put_rxbuf_data(struct urb *ur
 		write_length_remaining = urb->actual_length -
 			serial->curr_rx_urb_offset;
 		D1("data to push to tty");
-		while (write_length_remaining) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (write_length_remaining) {
 			if (test_bit(TTY_THROTTLED, &tty->flags)) {
 				tty_kref_put(tty);
 				return -1;
@@ -2073,6 +2100,12 @@ static int put_rxbuf_data(struct urb *ur
 			serial->curr_rx_urb_offset += curr_write_len;
 			write_length_remaining -= curr_write_len;
 			tty_flip_buffer_push(tty);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (write_length_remaining == 0) {
diff -u -p a/net/usb/usbnet.c b/net/usb/usbnet.c
--- a/net/usb/usbnet.c
+++ b/net/usb/usbnet.c
@@ -660,6 +660,11 @@ static void usbnet_terminate_urbs(struct
 		unlink_urbs(dev, &dev->rxq);
 
 	/* maybe wait for deletions to finish. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!skb_queue_empty(&dev->rxq)
 		&& !skb_queue_empty(&dev->txq)
 		&& !skb_queue_empty(&dev->done)) {
@@ -667,6 +672,12 @@ static void usbnet_terminate_urbs(struct
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			netif_dbg(dev, ifdown, dev->net,
 				  "waited for %d urb completions\n", temp);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	set_current_state(TASK_RUNNING);
 	dev->wait = NULL;
@@ -1205,6 +1216,11 @@ static void usbnet_bh (unsigned long par
 	struct sk_buff		*skb;
 	struct skb_data		*entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue (&dev->done))) {
 		entry = (struct skb_data *) skb->cb;
 		switch (entry->state) {
@@ -1220,6 +1236,12 @@ static void usbnet_bh (unsigned long par
 		default:
 			netdev_dbg(dev->net, "bogus skb state %d\n", entry->state);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	// waiting for all pending urbs to complete?
@@ -1545,6 +1567,11 @@ int usbnet_resume (struct usb_interface
 			usb_submit_urb(dev->interrupt, GFP_NOIO);
 
 		spin_lock_irq(&dev->txq.lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((res = usb_get_from_anchor(&dev->deferred))) {
 
 			skb = (struct sk_buff *)res->context;
@@ -1557,6 +1584,12 @@ int usbnet_resume (struct usb_interface
 				dev->net->trans_start = jiffies;
 				__skb_queue_tail(&dev->txq, skb);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		smp_mb();
diff -u -p a/net/wan/n2.c b/net/wan/n2.c
--- a/net/wan/n2.c
+++ b/net/wan/n2.c
@@ -550,10 +550,21 @@ static void __exit n2_cleanup(void)
 {
 	card_t *card = first_card;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card) {
 		card_t *ptr = card;
 		card = card->next_card;
 		n2_destroy_card(ptr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wan/cycx_drv.c b/net/wan/cycx_drv.c
--- a/net/wan/cycx_drv.c
+++ b/net/wan/cycx_drv.c
@@ -202,11 +202,22 @@ int cycx_exec(void __iomem *addr)
 	u16 i = 0;
 	/* wait till addr content is zeroed */
 
-	while (readw(addr)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (readw(addr)) {
 		udelay(1000);
 
 		if (++i > 50)
 			return -1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/net/wan/cycx_x25.c b/net/wan/cycx_x25.c
--- a/net/wan/cycx_x25.c
+++ b/net/wan/cycx_x25.c
@@ -1588,13 +1588,24 @@ static void cycx_x25_dump_devs(struct wa
 	pr_info("name: addr:           txoff:  protocol:\n");
 	pr_info("---------------------------------------\n");
 
-	while(dev) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while(dev) {
 		struct cycx_x25_channel *chan = netdev_priv(dev);
 
 		pr_info("%-5.5s %-15.15s   %d     ETH_P_%s\n",
 			chan->name, chan->addr, netif_queue_stopped(dev),
 			chan->protocol == ETH_P_IP ? "IP" : "X25");
 		dev = chan->slave;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/net/wan/hdlc_fr.c b/net/wan/hdlc_fr.c
--- a/net/wan/hdlc_fr.c
+++ b/net/wan/hdlc_fr.c
@@ -178,12 +178,23 @@ static inline pvc_device* find_pvc(hdlc_
 {
 	pvc_device *pvc = state(hdlc)->first_pvc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pvc) {
 		if (pvc->dlci == dlci)
 			return pvc;
 		if (pvc->dlci > dlci)
 			return NULL; /* the list is sorted */
 		pvc = pvc->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
@@ -248,6 +259,11 @@ static inline void delete_unused_pvcs(hd
 {
 	pvc_device **pvc_p = &state(hdlc)->first_pvc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*pvc_p) {
 		if (!pvc_is_used(*pvc_p)) {
 			pvc_device *pvc = *pvc_p;
@@ -259,6 +275,12 @@ static inline void delete_unused_pvcs(hd
 			continue;
 		}
 		pvc_p = &(*pvc_p)->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -515,7 +537,12 @@ static void fr_lmi_send(struct net_devic
 	data[i++] = state(hdlc)->rxseq;
 
 	if (dce && fullrep) {
-		while (pvc) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (pvc) {
 			data[i++] = lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :
 				LMI_ANSI_CISCO_PVCSTAT;
 			data[i++] = stat_len;
@@ -550,6 +577,12 @@ static void fr_lmi_send(struct net_devic
 
 			i += stat_len;
 			pvc = pvc->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -575,15 +608,31 @@ static void fr_set_link_state(int reliab
 		state(hdlc)->dce_changed = 1;
 
 		if (state(hdlc)->settings.lmi == LMI_NONE) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (pvc) {	/* Activate all PVCs */
 				pvc_carrier(1, pvc);
 				pvc->state.exist = pvc->state.active = 1;
 				pvc->state.new = 0;
 				pvc = pvc->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	} else {
 		netif_dormant_on(dev);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (pvc) {		/* Deactivate all PVCs */
 			pvc_carrier(0, pvc);
 			pvc->state.exist = pvc->state.active = 0;
@@ -591,6 +640,12 @@ static void fr_set_link_state(int reliab
 			if (!state(hdlc)->settings.dce)
 				pvc->state.bandwidth = 0;
 			pvc = pvc->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -748,6 +803,11 @@ static int fr_lmi_recv(struct net_device
 /* Stop sending full report - the last one has been confirmed by DTE */
 			state(hdlc)->fullrep_sent = 0;
 			pvc = state(hdlc)->first_pvc;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (pvc) {
 				if (pvc->state.new) {
 					pvc->state.new = 0;
@@ -756,6 +816,12 @@ static int fr_lmi_recv(struct net_device
 					state(hdlc)->dce_changed = 1;
 				}
 				pvc = pvc->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
@@ -782,12 +848,28 @@ static int fr_lmi_recv(struct net_device
 
 	pvc = state(hdlc)->first_pvc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pvc) {
 		pvc->state.deleted = 1;
 		pvc = pvc->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	no_ram = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb->len >= i + 2 + stat_len) {
 		u16 dlci;
 		u32 bw;
@@ -843,10 +925,21 @@ static int fr_lmi_recv(struct net_device
 		}
 
 		i += stat_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pvc = state(hdlc)->first_pvc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pvc) {
 		if (pvc->state.deleted && pvc->state.exist) {
 			pvc_carrier(0, pvc);
@@ -856,6 +949,12 @@ static int fr_lmi_recv(struct net_device
 			fr_log_dlci_active(pvc);
 		}
 		pvc = pvc->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Next full report after N391 polls */
@@ -1030,12 +1129,23 @@ static void fr_close(struct net_device *
 	hdlc_device *hdlc = dev_to_hdlc(dev);
 	pvc_device *pvc = state(hdlc)->first_pvc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pvc) {		/* Shutdown all PVCs for this FRAD */
 		if (pvc->main)
 			dev_close(pvc->main);
 		if (pvc->ether)
 			dev_close(pvc->ether);
 		pvc = pvc->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1149,6 +1259,11 @@ static void fr_destroy(struct net_device
 	state(hdlc)->dce_pvc_count = 0;
 	state(hdlc)->dce_changed = 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pvc) {
 		pvc_device *next = pvc->next;
 		/* destructors will free_netdev() main and ether */
@@ -1160,6 +1275,12 @@ static void fr_destroy(struct net_device
 
 		kfree(pvc);
 		pvc = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wan/dscc4.c b/net/wan/dscc4.c
--- a/net/wan/dscc4.c
+++ b/net/wan/dscc4.c
@@ -1288,9 +1288,20 @@ static int dscc4_set_clock(struct net_de
 		} else if (divider) {
 			/* Extraction of the 6 highest weighted bits */
 			m = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (0xffffffc0 & divider) {
 				m++;
 				divider >>= 1;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 			n = divider;
 		}
@@ -1746,11 +1757,22 @@ try:
 			 * RX_RING_SIZE may help.
 			 */
 			//while (dpriv->rx_needs_refill) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (!(rx_fd->state1 & Hold)) {
 					rx_fd++;
 					cur++;
 					if (!(cur = cur%RX_RING_SIZE))
 						rx_fd = dpriv->rx_fd;
+						if (_cur < timeout) {
+				rdstcll(_cur);
+						}
+					else {
+				break;
+					}
 				}
 				//dpriv->rx_needs_refill--;
 				try_get_rx_skb(dpriv, dev);
diff -u -p a/net/wan/pc300_drv.c b/net/wan/pc300_drv.c
--- a/net/wan/pc300_drv.c
+++ b/net/wan/pc300_drv.c
@@ -447,6 +447,11 @@ static int dma_get_rx_frame_size(pc300_t
 	volatile u8 status;
 
 	ptdescr = (card->hw.rambase + RX_BD_ADDR(ch, first_bd));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = cpc_readb(&ptdescr->status)) & DST_OSB) {
 		rcvd += cpc_readw(&ptdescr->len);
 		first_bd = (first_bd + 1) & (N_DMA_RX_BUF - 1);
@@ -456,6 +461,12 @@ static int dma_get_rx_frame_size(pc300_t
 			return rcvd;
 		}
 		ptdescr = (card->hw.rambase + cpc_readl(&ptdescr->next));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -1;
 }
@@ -1886,6 +1897,11 @@ static void cpc_net_rx(struct net_device
 	int rxb;
 	struct sk_buff *skb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if ((rxb = dma_get_rx_frame_size(card, ch)) == -1)
 			return;
@@ -1954,6 +1970,12 @@ static void cpc_net_rx(struct net_device
 		dev->stats.rx_packets++;
 		skb->protocol = hdlc_type_trans(skb, dev);
 		netif_rx(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1970,6 +1992,11 @@ static void sca_tx_intr(pc300dev_t *dev)
     /* Clean up descriptors from previous transmission */
 	ptdescr = (card->hw.rambase +
 						TX_BD_ADDR(ch,chan->tx_first_bd));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cpc_readl(card->hw.scabase + DTX_REG(CDAL,ch)) !=
 		TX_BD_ADDR(ch,chan->tx_first_bd)) &&
 	       (cpc_readb(&ptdescr->status) & DST_OSB)) {
@@ -1980,7 +2007,13 @@ static void sca_tx_intr(pc300dev_t *dev)
 		chan->nfree_tx_bd++;
 		chan->tx_first_bd = (chan->tx_first_bd + 1) & (N_DMA_TX_BUF - 1);
 		ptdescr = (card->hw.rambase + TX_BD_ADDR(ch,chan->tx_first_bd));
-    }
+		if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+}
 
 #ifdef CONFIG_PC300_MLPPP
 	if (chan->conf.proto == PC300_PROTO_MLPPP) {
diff -u -p a/net/wan/farsync.c b/net/wan/farsync.c
--- a/net/wan/farsync.c
+++ b/net/wan/farsync.c
@@ -1563,6 +1563,11 @@ fst_intr(int dummy, void *dev_id)
 	/* Drain the event queue */
 	rdidx = FST_RDB(card, interruptEvent.rdindex) & 0x1f;
 	wridx = FST_RDB(card, interruptEvent.wrindex) & 0x1f;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rdidx != wridx) {
 		event = FST_RDB(card, interruptEvent.evntbuff[rdidx]);
 		port = &card->ports[event & 0x03];
@@ -1622,6 +1627,12 @@ fst_intr(int dummy, void *dev_id)
 		/* Bump and wrap the index */
 		if (++rdidx >= MAX_CIRBUFF)
 			rdidx = 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	FST_WRB(card, interruptEvent.rdindex, rdidx);
         return IRQ_HANDLED;
diff -u -p a/net/wan/pc300_tty.c b/net/wan/pc300_tty.c
--- a/net/wan/pc300_tty.c
+++ b/net/wan/pc300_tty.c
@@ -326,10 +326,21 @@ static int cpc_tty_open(struct tty_struc
 
 		if (cpc_tty_area[port].buf_rx.first) {
 			unsigned char * aux;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (cpc_tty_area[port].buf_rx.first) {
 				aux = (unsigned char *)cpc_tty_area[port].buf_rx.first;
 				cpc_tty_area[port].buf_rx.first = cpc_tty_area[port].buf_rx.first->next;
 				kfree(aux);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			cpc_tty_area[port].buf_rx.first = NULL;
 			cpc_tty_area[port].buf_rx.last = NULL;
@@ -395,10 +406,21 @@ static void cpc_tty_close(struct tty_str
 	
 	if (cpc_tty->buf_rx.first) {
 		unsigned char * aux;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cpc_tty->buf_rx.first) {
 			aux = (unsigned char *)cpc_tty->buf_rx.first;
 			cpc_tty->buf_rx.first = cpc_tty->buf_rx.first->next;
 			kfree(aux);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		cpc_tty->buf_rx.first = NULL;
 		cpc_tty->buf_rx.last = NULL;
@@ -757,6 +779,11 @@ void cpc_tty_receive(pc300dev_t *pc300de
 
 	cpc_tty = pc300dev->cpc_tty;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) { 
 		rx_len = 0;
 		ptdescr = (pcsca_bd_t  __iomem *)(card->hw.rambase + RX_BD_ADDR(ch, first_bd));
@@ -878,6 +905,12 @@ void cpc_tty_receive(pc300dev_t *pc300de
 			schedule_work(&(cpc_tty->tty_rx_work));
 			stats->rx_packets++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} 
 } 
 
diff -u -p a/net/wan/c101.c b/net/wan/c101.c
--- a/net/wan/c101.c
+++ b/net/wan/c101.c
@@ -437,11 +437,22 @@ static void __exit c101_cleanup(void)
 {
 	card_t *card = first_card;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card) {
 		card_t *ptr = card;
 		card = card->next_card;
 		unregister_hdlc_device(port_to_dev(ptr));
 		c101_destroy_card(ptr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wan/cosa.c b/net/wan/cosa.c
--- a/net/wan/cosa.c
+++ b/net/wan/cosa.c
@@ -805,6 +805,11 @@ static ssize_t cosa_read(struct file *fi
 	cosa_enable_rx(chan);
 	spin_lock_irqsave(&cosa->lock, flags);
 	add_wait_queue(&chan->rxwaitq, &wait);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!chan->rx_status) {
 		current->state = TASK_INTERRUPTIBLE;
 		spin_unlock_irqrestore(&cosa->lock, flags);
@@ -818,6 +823,12 @@ static ssize_t cosa_read(struct file *fi
 			mutex_unlock(&chan->rlock);
 			return -ERESTARTSYS;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	remove_wait_queue(&chan->rxwaitq, &wait);
 	current->state = TASK_RUNNING;
@@ -890,6 +901,11 @@ static ssize_t cosa_write(struct file *f
 
 	spin_lock_irqsave(&cosa->lock, flags);
 	add_wait_queue(&chan->txwaitq, &wait);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!chan->tx_status) {
 		current->state = TASK_INTERRUPTIBLE;
 		spin_unlock_irqrestore(&cosa->lock, flags);
@@ -904,6 +920,12 @@ static ssize_t cosa_write(struct file *f
 			up(&chan->wsem);
 			return -ERESTARTSYS;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	remove_wait_queue(&chan->txwaitq, &wait);
 	current->state = TASK_RUNNING;
diff -u -p a/net/wan/z85230.c b/net/wan/z85230.c
--- a/net/wan/z85230.c
+++ b/net/wan/z85230.c
@@ -408,6 +408,11 @@ static void z8530_rx(struct z8530_channe
  
 static void z8530_tx(struct z8530_channel *c)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(c->txcount) {
 		/* FIFO full ? */
 		if(!(read_zsreg(c, R0)&4))
@@ -424,6 +429,12 @@ static void z8530_tx(struct z8530_channe
 			write_zsctrl(c, RES_EOM_L);
 			write_zsreg(c, R10, c->regs[10]&~ABUNDER);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	
@@ -1500,10 +1511,21 @@ static void z8530_tx_begin(struct z8530_
 			write_zsreg(c, R10, c->regs[10]);
 			write_zsctrl(c, RES_Tx_CRC);
 	
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(c->txcount && (read_zsreg(c,R0)&Tx_BUF_EMP))
 			{		
 				write_zsreg(c, R8, *c->tx_ptr++);
 				c->txcount--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 		}
diff -u -p a/net/wan/hdlc.c b/net/wan/hdlc.c
--- a/net/wan/hdlc.c
+++ b/net/wan/hdlc.c
@@ -219,10 +219,21 @@ int hdlc_ioctl(struct net_device *dev, s
 
 	/* Not handled by currently attached protocol (if any) */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (proto) {
 		if ((result = proto->ioctl(dev, ifr)) != -EINVAL)
 			return result;
 		proto = proto->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EINVAL;
 }
@@ -324,9 +335,20 @@ void unregister_hdlc_protocol(struct hdl
 
 	rtnl_lock();
 	p = &first_proto;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*p != proto) {
 		BUG_ON(!*p);
 		p = &((*p)->next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*p = proto->next;
 	rtnl_unlock();
diff -u -p a/net/wan/ixp4xx_hss.c b/net/wan/ixp4xx_hss.c
--- a/net/wan/ixp4xx_hss.c
+++ b/net/wan/ixp4xx_hss.c
@@ -663,6 +663,11 @@ static int hss_hdlc_poll(struct napi_str
 	printk(KERN_DEBUG "%s: hss_hdlc_poll\n", dev->name);
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (received < budget) {
 		struct sk_buff *skb;
 		struct desc *desc;
@@ -779,7 +784,13 @@ static int hss_hdlc_poll(struct napi_str
 		desc->pkt_len = 0;
 		queue_put_desc(rxfreeq, rx_desc_phys(port, n), desc);
 		received++;
-	}
+		if (_cur < timeout) {
+rdstcll(_cur);
+		}
+		else {
+break;
+		}
+}
 #if DEBUG_RX
 	printk(KERN_DEBUG "hss_hdlc_poll: end, not all work done\n");
 #endif
diff -u -p a/net/wan/sdla.c b/net/wan/sdla.c
--- a/net/wan/sdla.c
+++ b/net/wan/sdla.c
@@ -87,6 +87,11 @@ static void __sdla_read(struct net_devic
 	int           offset, bytes;
 
 	temp = buf;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len)
 	{	
 		offset = addr & SDLA_ADDR_MASK;
@@ -99,6 +104,12 @@ static void __sdla_read(struct net_devic
 		addr += bytes;
 		temp += bytes;
 		len  -= bytes;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}  
 }
 
@@ -118,6 +129,11 @@ static void __sdla_write(struct net_devi
 	int           offset, bytes;
 
 	temp = buf;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len)
 	{
 		offset = addr & SDLA_ADDR_MASK;
@@ -130,6 +146,12 @@ static void __sdla_write(struct net_devi
 		addr += bytes;
 		temp += bytes;
 		len  -= bytes;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -156,6 +178,11 @@ static void sdla_clear(struct net_device
 	base = (void *) dev->mem_start;
 
 	spin_lock_irqsave(&sdla_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len)
 	{
 		SDLA_WINDOW(dev, addr);
@@ -163,6 +190,12 @@ static void sdla_clear(struct net_device
 
 		addr += bytes;
 		len  -= bytes;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&sdla_lock, flags);
 
@@ -260,6 +293,11 @@ static int sdla_z80_poll(struct net_devi
 	temp += z80_addr & SDLA_ADDR_MASK;
 	
 	resp = ~resp1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, done) && (resp != resp1) && (!resp2 || (resp != resp2)))
 	{
 		if (jiffies != now)
@@ -268,6 +306,12 @@ static int sdla_z80_poll(struct net_devi
 			now = jiffies;
 			resp = *temp;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return time_before(jiffies, done) ? jiffies - start : -1;
 }
@@ -461,6 +505,11 @@ static int sdla_cmd(struct net_device *d
 
 	waiting = 1;
 	len = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (waiting && time_before_eq(jiffies, jiffs))
 	{
 		if (waiting++ % 3) 
@@ -470,6 +519,12 @@ static int sdla_cmd(struct net_device *d
 			waiting = ((volatile int)(cmd_buf->opp_flag));
 			spin_unlock_irqrestore(&sdla_lock, pflags);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	if (!waiting)
diff -u -p a/net/wan/wanxl.c b/net/wan/wanxl.c
--- a/net/wan/wanxl.c
+++ b/net/wan/wanxl.c
@@ -163,6 +163,11 @@ static inline void wanxl_cable_intr(port
 static inline void wanxl_tx_intr(port_t *port)
 {
 	struct net_device *dev = port->dev;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
                 desc_t *desc = &get_status(port)->tx_descs[port->tx_in];
 		struct sk_buff *skb = port->tx_skbs[port->tx_in];
@@ -187,6 +192,12 @@ static inline void wanxl_tx_intr(port_t
 				 PCI_DMA_TODEVICE);
 		dev_kfree_skb_irq(skb);
                 port->tx_in = (port->tx_in + 1) % TX_BUFFERS;
+                if (_cur < timeout) {
+		rdstcll(_cur);
+                }
+                else {
+		break;
+                }
         }
 }
 
diff -u -p a/net/caif/caif_hsi.c b/net/caif/caif_hsi.c
--- a/net/caif/caif_hsi.c
+++ b/net/caif/caif_hsi.c
@@ -457,11 +457,22 @@ static int cfhsi_rx_pld(struct cfhsi_des
 	plen = desc->cffrm_len;
 
 	/* Skip already processed frames. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nfrms < cfhsi->rx_state.nfrms) {
 		pfrm += *plen;
 		rx_sz += *plen;
 		plen++;
 		nfrms++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Parse payload. */
diff -u -p a/net/caif/caif_spi.c b/net/caif/caif_spi.c
--- a/net/caif/caif_spi.c
+++ b/net/caif/caif_spi.c
@@ -399,9 +399,20 @@ int cfspi_xmitlen(struct cfspi *cfspi)
 	 * Decommit previously committed frames.
 	 * skb_queue_splice_tail(&cfspi->chead,&cfspi->qhead)
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb_peek(&cfspi->chead)) {
 		skb = skb_dequeue_tail(&cfspi->chead);
 		skb_queue_head(&cfspi->qhead, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	do {
diff -u -p a/net/caif/caif_shmcore.c b/net/caif/caif_shmcore.c
--- a/net/caif/caif_shmcore.c
+++ b/net/caif/caif_shmcore.c
@@ -687,53 +687,119 @@ void caif_shmcore_remove(struct net_devi
 
 	pshm_drv = netdev_priv(pshm_netdev);
 
-	while (!(list_empty(&pshm_drv->tx_pend_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->tx_pend_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_pend_list.next,
 					struct buf_list, list);
 
 		list_del(&pbuf->list);
 		kfree(pbuf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
-	while (!(list_empty(&pshm_drv->tx_full_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->tx_full_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_full_list.next,
 					struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
-	while (!(list_empty(&pshm_drv->tx_empty_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->tx_empty_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_empty_list.next,
 					struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
-	while (!(list_empty(&pshm_drv->rx_full_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->rx_full_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_full_list.next,
 				struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
-	while (!(list_empty(&pshm_drv->rx_pend_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->rx_pend_list))) {
 		pbuf =
 			list_entry(pshm_drv->tx_pend_list.next,
 				struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
-	while (!(list_empty(&pshm_drv->rx_empty_list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(list_empty(&pshm_drv->rx_empty_list))) {
 		pbuf =
 			list_entry(pshm_drv->rx_empty_list.next,
 				struct buf_list, list);
 		list_del(&pbuf->list);
 		kfree(pbuf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Destroy work queues. */
diff -u -p a/net/cris/eth_v10.c b/net/cris/eth_v10.c
--- a/net/cris/eth_v10.c
+++ b/net/cris/eth_v10.c
@@ -1070,10 +1070,21 @@ e100_tx_timeout(struct net_device *dev)
 	e100_reset_transceiver(dev);
 
 	/* and get rid of the packets that never got an interrupt */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (myFirstTxDesc != myNextTxDesc) {
 		dev_kfree_skb(myFirstTxDesc->skb);
 		myFirstTxDesc->skb = 0;
 		myFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Set up transmit DMA channel so it can be restarted later */
@@ -1150,6 +1161,11 @@ e100rxtx_interrupt(int irq, void *dev_id
 
 		/* check if one or more complete packets were indeed received */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((*R_DMA_CH1_FIRST != virt_to_phys(myNextRxDesc)) &&
 		       (myNextRxDesc != myLastRxDesc)) {
 			/* Take out the buffer and give it to the OS, then
@@ -1166,10 +1182,21 @@ e100rxtx_interrupt(int irq, void *dev_id
 
 			/* now, we might have gotten another packet
 			   so we have to loop back and check if so */
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
 	/* Report any packets that have been sent */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (virt_to_phys(myFirstTxDesc) != *R_DMA_CH0_FIRST &&
 	       (netif_queue_stopped(dev) || myFirstTxDesc != myNextTxDesc)) {
 		dev->stats.tx_bytes += myFirstTxDesc->skb->len;
@@ -1182,6 +1209,12 @@ e100rxtx_interrupt(int irq, void *dev_id
 		myFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);
                 /* Wake up queue. */
 		netif_wake_queue(dev);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (irqbits & IO_STATE(R_IRQ_MASK2_RD, dma0_eop, active)) {
diff -u -p a/net/fddi/skfp/smttimer.c b/net/fddi/skfp/smttimer.c
--- a/net/fddi/skfp/smttimer.c
+++ b/net/fddi/skfp/smttimer.c
@@ -128,6 +128,11 @@ static void timer_done(struct s_smc *smc
 	delta = hwt_read(smc) ;
 	last = &smc->t.st_queue ;
 	tm = smc->t.st_queue ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tm && !done) {
 		if (delta >= tm->tm_delta) {
 			tm->tm_active = FALSE ;
@@ -140,6 +145,12 @@ static void timer_done(struct s_smc *smc
 			delta = 0 ;
 			done = 1 ;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*last = NULL;
 	next = smc->t.st_queue ;
diff -u -p a/net/fddi/skfp/ecm.c b/net/fddi/skfp/ecm.c
--- a/net/fddi/skfp/ecm.c
+++ b/net/fddi/skfp/ecm.c
@@ -481,7 +481,12 @@ static void prop_actions(struct s_smc *s
 	int	p ;
 
 	RS_SET(smc,RS_EVENT) ;
-	while (smc->e.trace_prop) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (smc->e.trace_prop) {
 		DB_ECM("ECM : prop_actions - trace_prop %d\n",
 			smc->e.trace_prop,0) ;
 
@@ -511,6 +516,12 @@ static void prop_actions(struct s_smc *s
 			DB_ECM("ECM : propagate TRACE on PHY %d\n",upstream,0) ;
 			queue_event(smc,EVENT_PCM+upstream,PC_TRACE) ;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 #endif
diff -u -p a/net/fddi/skfp/smt.c b/net/fddi/skfp/smt.c
--- a/net/fddi/skfp/smt.c
+++ b/net/fddi/skfp/smt.c
@@ -1651,12 +1651,23 @@ int smt_check_para(struct s_smc *smc, st
 		   const u_short list[])
 {
 	const u_short		*p = list ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*p) {
 		if (!sm_to_para(smc,sm,(int) *p)) {
 			DB_SMT("SMT: smt_check_para - missing para %x\n",*p,0);
 			return -1;
 		}
 		p++ ;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/fddi/skfp/drvfbi.c b/net/fddi/skfp/drvfbi.c
--- a/net/fddi/skfp/drvfbi.c
+++ b/net/fddi/skfp/drvfbi.c
@@ -511,6 +511,11 @@ int set_oi_id_def(struct s_smc *smc)
 	smc->hw.oem_min_status = OI_STAT_ACTIVE ;
 	
 	/* check OEM data base */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (oem_ids[i].oi_status) {
 		switch (oem_ids[i].oi_status) {
 		case OI_STAT_ACTIVE:
@@ -524,6 +529,12 @@ int set_oi_id_def(struct s_smc *smc)
 		default:
 			return 1;		/* invalid oi_status */
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (i == 0)
diff -u -p a/net/fddi/skfp/hwmtm.c b/net/fddi/skfp/hwmtm.c
--- a/net/fddi/skfp/hwmtm.c
+++ b/net/fddi/skfp/hwmtm.c
@@ -846,15 +846,37 @@ void fddi_isr(struct s_smc *smc)
 		}
 
 #ifndef	NDIS_OS2
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((mb = get_llc_rx(smc))) {
 			smt_to_llc(smc,mb) ;
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+}
 #else
 		if (offDepth)
 			post_proc() ;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!offDepth && (mb = get_llc_rx(smc))) {
 			smt_to_llc(smc,mb) ;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (!offDepth && smc->os.hwm.rx_break) {
@@ -1141,12 +1163,23 @@ void process_receive(struct s_smc *smc)
 		/* may be next 2 DRV_BUF_FLUSH() can be skipped, because */
 		/* BMU_ST_BUF will not be changed by the ASIC */
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (rx_used && !(r->rxd_rbctrl & cpu_to_le32(BMU_ST_BUF))) {
 			DB_RX("Check STF bit in %x",(void *)r,0,5) ;
 			r = r->rxd_next ;
 			DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
 			frag_count++ ;
 			rx_used-- ;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		DB_RX("STF bit found",0,0,5) ;
 
@@ -1481,6 +1514,11 @@ void mac_drv_clear_rx_queue(struct s_smc
 	 * dma_complete and mac_drv_clear_rxd for all RxDs / receive buffers
 	 */
 	r = queue->rx_curr_get ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (queue->rx_used) {
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
 		DB_RX("switch OWN bit of RxD 0x%x ",r,0,5) ;
@@ -1489,6 +1527,11 @@ void mac_drv_clear_rx_queue(struct s_smc
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORDEV) ;
 		r = r->rxd_next ;
 		DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (r != queue->rx_curr_put &&
 			!(r->rxd_rbctrl & cpu_to_le32(BMU_ST_BUF))) {
 			DB_RX("Check STF bit in %x",(void *)r,0,5) ;
@@ -1497,6 +1540,12 @@ void mac_drv_clear_rx_queue(struct s_smc
 			r = r->rxd_next ;
 			DRV_BUF_FLUSH(r,DDI_DMA_SYNC_FORCPU) ;
 			frag_count++ ;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		DB_RX("STF bit found",0,0,5) ;
 		next_rxd = r ;
@@ -1513,6 +1562,12 @@ void mac_drv_clear_rx_queue(struct s_smc
 		queue->rx_curr_get = next_rxd ;
 		queue->rx_used -= frag_count ;
 		queue->rx_free += frag_count ;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1833,6 +1888,11 @@ void smt_send_mbuf(struct s_smc *smc, SM
 	 */
 	frag_count = 0 ;
 	len = mb->sm_len ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		n = SMT_PAGESIZE - ((long)data & (SMT_PAGESIZE-1)) ;
 		if (n >= len) {
@@ -1844,6 +1904,12 @@ void smt_send_mbuf(struct s_smc *smc, SM
 		frag_count++ ;
 		len -= n ;
 		data += n ;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -2050,6 +2116,11 @@ void mac_drv_clear_tx_queue(struct s_smc
 		 */
 		t = queue->tx_curr_get ;
 		tx_used = queue->tx_used ;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tx_used) {
 			DRV_BUF_FLUSH(t,DDI_DMA_SYNC_FORCPU) ;
 			DB_TX("switch OWN bit of TxD 0x%x ",t,0,5) ;
@@ -2057,6 +2128,12 @@ void mac_drv_clear_tx_queue(struct s_smc
 			DRV_BUF_FLUSH(t,DDI_DMA_SYNC_FORDEV) ;
 			t = t->txd_next ;
 			tx_used-- ;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/fddi/defxx.c b/net/fddi/defxx.c
--- a/net/fddi/defxx.c
+++ b/net/fddi/defxx.c
@@ -3385,7 +3385,12 @@ static int dfx_xmt_done(DFX_board_t *bp)
 	/* Service all consumed transmit frames */
 
 	p_type_2_cons = (PI_TYPE_2_CONSUMER *)(&bp->cons_block_virt->xmt_rcv_data);
-	while (bp->rcv_xmt_reg.index.xmt_comp != p_type_2_cons->index.xmt_cons)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bp->rcv_xmt_reg.index.xmt_comp != p_type_2_cons->index.xmt_cons)
 		{
 		/* Get pointer to the transmit driver descriptor block information */
 
@@ -3417,6 +3422,12 @@ static int dfx_xmt_done(DFX_board_t *bp)
 
 		bp->rcv_xmt_reg.index.xmt_comp += 1;
 		freed++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 		}
 	return freed;
 	}
@@ -3514,7 +3525,12 @@ static void dfx_xmt_flush( DFX_board_t *
 
 	/* Flush all outstanding transmit frames */
 
-	while (bp->rcv_xmt_reg.index.xmt_comp != bp->rcv_xmt_reg.index.xmt_prod)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bp->rcv_xmt_reg.index.xmt_comp != bp->rcv_xmt_reg.index.xmt_prod)
 		{
 		/* Get pointer to the transmit driver descriptor block information */
 
@@ -3544,6 +3560,12 @@ static void dfx_xmt_flush( DFX_board_t *
 		 */
 
 		bp->rcv_xmt_reg.index.xmt_comp += 1;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 		}
 
 	/* Update the transmit consumer index in the consumer block */
diff -u -p a/net/irda/donauboe.c b/net/irda/donauboe.c
--- a/net/irda/donauboe.c
+++ b/net/irda/donauboe.c
@@ -893,21 +893,43 @@ toshoboe_probe (struct toshoboe_cb *self
 
       i = 0;
       n = fir ? 1 : 4;
-      while (toshoboe_numvalidrcvs (self) != n)
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (toshoboe_numvalidrcvs (self) != n)
         {
           if (i > 4800)
               return toshoboe_probefail (self, "filter test");
           udelay ((9600*(TT_LEN+16))/self->speed);
           i++;
+          if (_cur < timeout) {
+              rdstcll(_cur);
+          }
+          else {
+              break;
+          }
         }
 
       n = fir ? 203 : 102;
-      while ((toshoboe_numrcvs(self) != self->int_rx) || (self->int_tx != n))
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while ((toshoboe_numrcvs(self) != self->int_rx) || (self->int_tx != n))
         {
           if (i > 4800)
               return toshoboe_probefail (self, "interrupt test");
           udelay ((9600*(TT_LEN+16))/self->speed);
           i++;
+          if (_cur < timeout) {
+              rdstcll(_cur);
+          }
+          else {
+              break;
+          }
         }
      toshoboe_dumprx (self,i);
 
@@ -1188,7 +1210,12 @@ toshoboe_interrupt (int irq, void *dev_i
         {
           txpc = txp;
 #ifdef OPTIMIZE_TX
-          while (self->ring->tx[txpc].control & OBOE_CTL_TX_HW_OWNS)
+          unsigned long long delta = (cpu / khz / HZ) * 2;
+          unsigned long long _start = 0;
+          unsigned long long _cur = 0;
+            unsigned long long timeout;
+            timeout = rdstcll(start) + delta;
+            while (self->ring->tx[txpc].control & OBOE_CTL_TX_HW_OWNS)
             {
               txp = txpc;
               txpc++;
@@ -1196,6 +1223,12 @@ toshoboe_interrupt (int irq, void *dev_i
               self->netdev->stats.tx_packets++;
               if (self->ring->tx[txpc].control & OBOE_CTL_TX_HW_OWNS)
                   self->ring->tx[txp].control &= ~OBOE_CTL_TX_RTCENTX;
+                  if (_cur < timeout) {
+                          rdstcll(_cur);
+                  }
+                  else {
+                          break;
+                  }
             }
           self->netdev->stats.tx_packets--;
 #else
@@ -1219,7 +1252,12 @@ toshoboe_interrupt (int irq, void *dev_i
 
   if (irqstat & OBOE_INT_RXDONE)
     {
-      while (!(self->ring->rx[self->rxs].control & OBOE_CTL_RX_HW_OWNS))
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while (!(self->ring->rx[self->rxs].control & OBOE_CTL_RX_HW_OWNS))
         {
           int len = self->ring->rx[self->rxs].len;
           skb = NULL;
@@ -1313,6 +1351,12 @@ dumpbufs(self->rx_bufs[self->rxs],len,'<
           if (skb)
               netif_rx (skb);
 
+              if (_cur < timeout) {
+            rdstcll(_cur);
+              }
+              else {
+            break;
+              }
         }
     }
 
diff -u -p a/net/irda/bfin_sir.c b/net/irda/bfin_sir.c
--- a/net/irda/bfin_sir.c
+++ b/net/irda/bfin_sir.c
@@ -67,9 +67,20 @@ static void bfin_sir_stop_tx(struct bfin
 	disable_dma(port->tx_dma_channel);
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(UART_GET_LSR(port) & THRE)) {
 		cpu_relax();
 		continue;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	UART_CLEAR_IER(port, ETBEI);
diff -u -p a/net/irda/w83977af_ir.c b/net/irda/w83977af_ir.c
--- a/net/irda/w83977af_ir.c
+++ b/net/irda/w83977af_ir.c
@@ -804,6 +804,11 @@ static int w83977af_dma_receive_complete
 
 	/* Read status FIFO */
 	switch_bank(iobase, SET5);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = inb(iobase+FS_FO)) & FS_FO_FSFDR) {
 		st_fifo->entries[st_fifo->tail].status = status;
 		
@@ -812,8 +817,19 @@ static int w83977af_dma_receive_complete
 		
 		st_fifo->tail++;
 		st_fifo->len++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (st_fifo->len) {
 		/* Get first entry */
 		status = st_fifo->entries[st_fifo->head].status;
@@ -890,6 +906,12 @@ static int w83977af_dma_receive_complete
 			skb->protocol = htons(ETH_P_IRDA);
 			netif_rx(skb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Restore set register */
 	outb(set, iobase+SSR);
diff -u -p a/net/irda/nsc-ircc.c b/net/irda/nsc-ircc.c
--- a/net/irda/nsc-ircc.c
+++ b/net/irda/nsc-ircc.c
@@ -1779,6 +1779,11 @@ static int nsc_ircc_dma_receive_complete
 	
 	/* Read all entries in status FIFO */
 	switch_bank(iobase, BANK5);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = inb(iobase+FRM_ST)) & FRM_ST_VLD) {
 		/* We must empty the status FIFO no matter what */
 		len = inb(iobase+RFLFL) | ((inb(iobase+RFLFH) & 0x1f) << 8);
@@ -1793,6 +1798,12 @@ static int nsc_ircc_dma_receive_complete
 		st_fifo->pending_bytes += len;
 		st_fifo->tail++;
 		st_fifo->len++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Try to process all entries in status FIFO */
 	while (st_fifo->len > 0) {
diff -u -p a/net/irda/smsc-ircc2.c b/net/irda/smsc-ircc2.c
--- a/net/irda/smsc-ircc2.c
+++ b/net/irda/smsc-ircc2.c
@@ -2150,6 +2150,11 @@ static int __init smsc_ircc_look_for_chi
 	found = 0;
 	address = possible_addresses;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (address->cfg_base) {
 		cfg_base = address->cfg_base;
 
@@ -2176,6 +2181,12 @@ static int __init smsc_ircc_look_for_chi
 					found++;
 		}
 		address++;
+		if (_cur < timeout) {
+					rdstcll(_cur);
+		}
+		else {
+					break;
+		}
 	}
 	return found;
 }
@@ -2333,12 +2344,23 @@ static const struct smsc_chip * __init s
 
 	/* Check for expected device ID; are there others? */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (chip->devid != devid) {
 
 		chip++;
 
 		if (chip->name == NULL)
 			return NULL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	IRDA_MESSAGE("found SMC SuperIO Chip (devid=0x%02x rev=%02X base=0x%04x): %s%s\n",
diff -u -p a/net/irda/pxaficp_ir.c b/net/irda/pxaficp_ir.c
--- a/net/irda/pxaficp_ir.c
+++ b/net/irda/pxaficp_ir.c
@@ -273,6 +273,11 @@ static irqreturn_t pxa_irda_sir_irq(int
 	switch  (iir & 0x0F) {
 	case 0x06: /* Receiver Line Status */
 	  	lsr = STLSR;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (lsr & LSR_FIFOE) {
 			data = STRBR;
 			if (lsr & (LSR_OE | LSR_PE | LSR_FE | LSR_BI)) {
@@ -288,6 +293,12 @@ static irqreturn_t pxa_irda_sir_irq(int
 						  &si->rx_buff, data);
 			}
 			lsr = STLSR;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		si->last_oscr = OSCR;
 		break;
@@ -304,10 +315,21 @@ static irqreturn_t pxa_irda_sir_irq(int
 	  	break;
 
 	case 0x02: /* Transmit FIFO Data Request */
-	    	while ((si->tx_buff.len) && (STLSR & LSR_TDRQ)) {
+	    	unsigned long long delta = (cpu / khz / HZ) * 2;
+	    	unsigned long long _start = 0;
+	    	unsigned long long _cur = 0;
+	    	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((si->tx_buff.len) && (STLSR & LSR_TDRQ)) {
 	    		STTHR = *si->tx_buff.data++;
 			si->tx_buff.len -= 1;
-	    	}
+			if (_cur < timeout) {
+	    		rdstcll(_cur);
+			}
+			else {
+	    		break;
+			}
+			}
 
 		if (si->tx_buff.len == 0) {
 			dev->stats.tx_packets++;
diff -u -p a/net/irda/sa1100_ir.c b/net/irda/sa1100_ir.c
--- a/net/irda/sa1100_ir.c
+++ b/net/irda/sa1100_ir.c
@@ -370,6 +370,11 @@ static void sa1100_irda_hpsir_irq(struct
 	 * Deal with any receive errors first.  The bytes in error may be
 	 * the only bytes in the receive FIFO, so we do this first.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & UTSR0_EIF) {
 		int stat, data;
 
@@ -386,6 +391,12 @@ static void sa1100_irda_hpsir_irq(struct
 			async_unwrap_char(dev, &dev->stats, &si->rx_buff, data);
 
 		status = Ser2UTSR0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/net/irda/au1k_ir.c b/net/irda/au1k_ir.c
--- a/net/irda/au1k_ir.c
+++ b/net/irda/au1k_ir.c
@@ -437,7 +437,12 @@ static void au1k_tx_ack(struct net_devic
 	volatile ring_dest_t *ptxd;
 
 	ptxd = aup->tx_ring[aup->tx_tail];
-	while (!(ptxd->flags & AU_OWN) && (aup->tx_tail != aup->tx_head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(ptxd->flags & AU_OWN) && (aup->tx_tail != aup->tx_head)) {
 		update_tx_stats(dev, ptxd->flags, 
 				ptxd->count_1<<8 | ptxd->count_0);
 		ptxd->count_0 = 0;
@@ -451,6 +456,12 @@ static void au1k_tx_ack(struct net_devic
 			aup->tx_full = 0;
 			netif_wake_queue(dev);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (aup->tx_tail == aup->tx_head) {
@@ -585,6 +596,11 @@ static int au1k_irda_rx(struct net_devic
 	prxd = aup->rx_ring[aup->rx_head];
 	flags = prxd->flags;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(flags & AU_OWN))  {
 		pDB = aup->rx_db_inuse[aup->rx_head];
 		count = prxd->count_1<<8 | prxd->count_0;
@@ -618,6 +634,12 @@ static int au1k_irda_rx(struct net_devic
 		prxd = aup->rx_ring[aup->rx_head];
 		flags = prxd->flags;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/hippi/rrunner.c b/net/hippi/rrunner.c
--- a/net/hippi/rrunner.c
+++ b/net/hippi/rrunner.c
@@ -489,6 +489,11 @@ static unsigned int write_eeprom(struct
 			ready = 0;
 			j = 0;
 			mb();
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(!ready){
 				udelay(20);
 				if ((readl(&regs->WinData) & 0xff000000) ==
@@ -502,6 +507,12 @@ static unsigned int write_eeprom(struct
 					ready = 1;
 					error = 1;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -744,6 +755,11 @@ static u32 rr_handle_event(struct net_de
 	rrpriv = netdev_priv(dev);
 	regs = rrpriv->regs;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (prodidx != eidx){
 		switch (rrpriv->evt_ring[eidx].code){
 		case E_NIC_UP:
@@ -930,6 +946,12 @@ static u32 rr_handle_event(struct net_de
 			       dev->name, rrpriv->evt_ring[eidx].code);
 		}
 		eidx = (eidx + 1) % EVT_RING_ENTRIES;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rrpriv->info->evt_ctrl.pi = eidx;
diff -u -p a/net/wimax/i2400m/usb-fw.c b/net/wimax/i2400m/usb-fw.c
--- a/net/wimax/i2400m/usb-fw.c
+++ b/net/wimax/i2400m/usb-fw.c
@@ -298,7 +298,12 @@ ssize_t i2400mu_bus_bm_wait_for_ack(stru
 	usb_init_urb(&notif_urb);	/* ready notifications */
 	usb_get_urb(&notif_urb);
 	offset = 0;
-	while (offset < ack_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < ack_size) {
 		init_completion(&notif_completion);
 		result = i2400mu_notif_submit(i2400mu, &notif_urb,
 					      &notif_completion);
@@ -344,6 +349,12 @@ ssize_t i2400mu_bus_bm_wait_for_ack(stru
 		len = min(ack_size - offset, (size_t) notif_urb.actual_length);
 		memcpy(ack + offset, i2400m->bm_ack_buf, len);
 		offset += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	result = offset;
 error_notif_urb_submit:
diff -u -p a/net/appletalk/cops.c b/net/appletalk/cops.c
--- a/net/appletalk/cops.c
+++ b/net/appletalk/cops.c
@@ -626,11 +626,22 @@ static int cops_nodeid (struct net_devic
 	if(lp->board == TANGENT)
         {
                 /* Empty any pending adapter responses. */
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                timeout = rdstcll(start) + delta;
                 while(inb(ioaddr+TANG_CARD_STATUS)&TANG_RX_READY)
                 {
 			outb(0, ioaddr+COPS_CLEAR_INT);	/* Clear interrupt. */
                 	cops_rx(dev);          	/* Kick out packets waiting. */
 			schedule();
+			if (_cur < timeout) {
+                		rdstcll(_cur);
+			}
+                	else {
+                		break;
+                	}
                 }
 
 		/* Not sure what Tangent does if nodeid picked is used. */
diff -u -p a/net/appletalk/ipddp.c b/net/appletalk/ipddp.c
--- a/net/appletalk/ipddp.c
+++ b/net/appletalk/ipddp.c
@@ -324,10 +324,21 @@ static void __exit ipddp_cleanup_module(
 	unregister_netdev(dev_ipddp);
         free_netdev(dev_ipddp);
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (ipddp_route_list) {
                 p = ipddp_route_list->next;
                 kfree(ipddp_route_list);
                 ipddp_route_list = p;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
         }
 }
 
diff -u -p a/net/macvtap.c b/net/macvtap.c
--- a/net/macvtap.c
+++ b/net/macvtap.c
@@ -489,10 +489,21 @@ static int zerocopy_sg_from_iovec(struct
 	int i = 0;
 
 	/* Skip over from offset */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count && (offset >= from->iov_len)) {
 		offset -= from->iov_len;
 		++from;
 		--count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* copy up to skb headlen */
@@ -543,6 +554,11 @@ static int zerocopy_sg_from_iovec(struct
 		skb->len += len;
 		skb->truesize += truesize;
 		atomic_add(truesize, &skb->sk->sk_wmem_alloc);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			int off = base & ~PAGE_MASK;
 			int size = min_t(int, len, PAGE_SIZE - off);
@@ -552,6 +568,12 @@ static int zerocopy_sg_from_iovec(struct
 			base += size;
 			len -= size;
 			i++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		offset = 0;
 		++from;
@@ -647,10 +669,21 @@ static unsigned long iov_pages(const str
 	unsigned long seg, base;
 	int pages = 0, len, size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nr_segs && (offset >= iv->iov_len)) {
 		offset -= iv->iov_len;
 		++iv;
 		--nr_segs;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (seg = 0; seg < nr_segs; seg++) {
diff -u -p a/net/ethernet/hp/hp100.c b/net/ethernet/hp/hp100.c
--- a/net/ethernet/hp/hp100.c
+++ b/net/ethernet/hp/hp100.c
@@ -1899,6 +1899,11 @@ static void hp100_rx_bm(struct net_devic
 	}
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((lp->rxrcommit > hp100_inb(RX_PDL))) {
 		/*
 		 * The packet was received into the pdl pointed to by lp->rxrhead (
@@ -1972,6 +1977,12 @@ static void hp100_rx_bm(struct net_devic
 			lp->rxrtail = lp->rxrtail->next;
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/ti/davinci_cpdma.c b/net/ethernet/ti/davinci_cpdma.c
--- a/net/ethernet/ti/davinci_cpdma.c
+++ b/net/ethernet/ti/davinci_cpdma.c
@@ -845,6 +845,11 @@ int cpdma_chan_stop(struct cpdma_chan *c
 	spin_lock_irqsave(&chan->lock, flags);
 
 	/* remaining packets haven't been tx/rx'ed, clean them up */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (chan->head) {
 		struct cpdma_desc __iomem *desc = chan->head;
 		dma_addr_t next_dma;
@@ -858,6 +863,12 @@ int cpdma_chan_stop(struct cpdma_chan *c
 		spin_unlock_irqrestore(&chan->lock, flags);
 		__cpdma_chan_free(chan, desc, 0, -ENOSYS);
 		spin_lock_irqsave(&chan->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	chan->state = CPDMA_STATE_IDLE;
diff -u -p a/net/ethernet/ti/tlan.c b/net/ethernet/ti/tlan.c
--- a/net/ethernet/ti/tlan.c
+++ b/net/ethernet/ti/tlan.c
@@ -627,6 +627,11 @@ static void tlan_eisa_cleanup(void)
 	struct net_device *dev;
 	struct tlan_priv *priv;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tlan_have_eisa) {
 		dev = tlan_eisa_devices;
 		priv = netdev_priv(dev);
@@ -640,6 +645,12 @@ static void tlan_eisa_cleanup(void)
 		tlan_eisa_devices = priv->next_device;
 		free_netdev(dev);
 		tlan_have_eisa--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/ti/davinci_emac.c b/net/ethernet/ti/davinci_emac.c
--- a/net/ethernet/ti/davinci_emac.c
+++ b/net/ethernet/ti/davinci_emac.c
@@ -1552,6 +1552,11 @@ static int emac_dev_open(struct net_devi
 
 	/* Request IRQ */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, k))) {
 		for (i = res->start; i <= res->end; i++) {
 			if (request_irq(i, emac_irq, IRQF_DISABLED,
@@ -1559,6 +1564,12 @@ static int emac_dev_open(struct net_devi
 				goto rollback;
 		}
 		k++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/* Start/Enable EMAC hardware */
@@ -1668,10 +1679,21 @@ static int emac_dev_stop(struct net_devi
 		phy_disconnect(priv->phydev);
 
 	/* Free IRQ */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, i))) {
 		for (irq_num = res->start; irq_num <= res->end; irq_num++)
 			free_irq(irq_num, priv->ndev);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (netif_msg_drv(priv))
diff -u -p a/net/ethernet/ti/davinci_mdio.c b/net/ethernet/ti/davinci_mdio.c
--- a/net/ethernet/ti/davinci_mdio.c
+++ b/net/ethernet/ti/davinci_mdio.c
@@ -163,6 +163,11 @@ static inline int wait_for_user_access(s
 	unsigned long timeout = jiffies + msecs_to_jiffies(MDIO_TIMEOUT);
 	u32 reg;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_after(timeout, jiffies)) {
 		reg = __raw_readl(&regs->user[0].access);
 		if ((reg & USERACCESS_GO) == 0)
@@ -180,6 +185,12 @@ static inline int wait_for_user_access(s
 		dev_warn(data->dev, "resetting idled controller\n");
 		__davinci_mdio_reset(data);
 		return -EAGAIN;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	reg = __raw_readl(&regs->user[0].access);
@@ -196,9 +207,20 @@ static inline int wait_for_idle(struct d
 	struct davinci_mdio_regs __iomem *regs = data->regs;
 	unsigned long timeout = jiffies + msecs_to_jiffies(MDIO_TIMEOUT);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_after(timeout, jiffies)) {
 		if (__raw_readl(&regs->control) & CONTROL_IDLE)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	dev_err(data->dev, "timed out waiting for idle\n");
 	return -ETIMEDOUT;
diff -u -p a/net/ethernet/adi/bfin_mac.c b/net/ethernet/adi/bfin_mac.c
--- a/net/ethernet/adi/bfin_mac.c
+++ b/net/ethernet/adi/bfin_mac.c
@@ -255,12 +255,23 @@ static int bfin_mdio_poll(void)
 	int timeout_cnt = MAX_TIMEOUT_CNT;
 
 	/* poll the STABUSY bit */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((bfin_read_EMAC_STAADD()) & STABUSY) {
 		udelay(1);
 		if (timeout_cnt-- < 0) {
 			pr_err("wait MDC/MDIO transaction to complete timeout\n");
 			return -ETIMEDOUT;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1269,6 +1280,11 @@ static void bfin_mac_timeout(struct net_
 	del_timer(&lp->tx_reclaim_timer);
 
 	/* reset tx queue and free skb */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tx_list_head != current_tx_ptr) {
 		tx_list_head->desc_a.config &= ~DMAEN;
 		tx_list_head->status.status_word = 0;
@@ -1277,6 +1293,12 @@ static void bfin_mac_timeout(struct net_
 			tx_list_head->skb = NULL;
 		}
 		tx_list_head = tx_list_head->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (netif_queue_stopped(lp->ndev))
diff -u -p a/net/ethernet/amd/declance.c b/net/ethernet/amd/declance.c
--- a/net/ethernet/amd/declance.c
+++ b/net/ethernet/amd/declance.c
@@ -1042,10 +1042,21 @@ static int __devinit dec_lance_probe(str
 	else {
 		i = 0;
 		dev = root_lance_dev;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (dev) {
 			i++;
 			lp = netdev_priv(dev);
 			dev = lp->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		snprintf(name, sizeof(name), fmt, i);
 	}
@@ -1314,6 +1325,11 @@ static int __init dec_lance_platform_pro
 
 static void __exit dec_lance_platform_remove(void)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (root_lance_dev) {
 		struct net_device *dev = root_lance_dev;
 		struct lance_private *lp = netdev_priv(dev);
@@ -1321,6 +1337,12 @@ static void __exit dec_lance_platform_re
 		unregister_netdev(dev);
 		root_lance_dev = lp->next;
 		free_netdev(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/amd/au1000_eth.c b/net/ethernet/amd/au1000_eth.c
--- a/net/ethernet/amd/au1000_eth.c
+++ b/net/ethernet/amd/au1000_eth.c
@@ -176,12 +176,23 @@ static int au1000_mdio_read(struct net_d
 	u32 timedout = 20;
 	u32 mii_control;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (readl(mii_control_reg) & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			netdev_err(dev, "read_MII busy timeout!!\n");
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mii_control = MAC_SET_MII_SELECT_REG(reg) |
@@ -190,12 +201,23 @@ static int au1000_mdio_read(struct net_d
 	writel(mii_control, mii_control_reg);
 
 	timedout = 20;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (readl(mii_control_reg) & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			netdev_err(dev, "mdio_read busy timeout!!\n");
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return readl(mii_data_reg);
 }
@@ -209,12 +231,23 @@ static void au1000_mdio_write(struct net
 	u32 timedout = 20;
 	u32 mii_control;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (readl(mii_control_reg) & MAC_MII_BUSY) {
 		mdelay(1);
 		if (--timedout == 0) {
 			netdev_err(dev, "mdio_write busy timeout!!\n");
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mii_control = MAC_SET_MII_SELECT_REG(reg) |
@@ -716,6 +749,11 @@ static int au1000_rx(struct net_device *
 
 	prxd = aup->rx_dma_ring[aup->rx_head];
 	buff_stat = prxd->buff_stat;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (buff_stat & RX_T_DONE)  {
 		status = prxd->status;
 		pDB = aup->rx_db_inuse[aup->rx_head];
@@ -768,6 +806,12 @@ static int au1000_rx(struct net_device *
 		/* next descriptor */
 		prxd = aup->rx_dma_ring[aup->rx_head];
 		buff_stat = prxd->buff_stat;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -807,6 +851,11 @@ static void au1000_tx_ack(struct net_dev
 
 	ptxd = aup->tx_dma_ring[aup->tx_tail];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ptxd->buff_stat & TX_T_DONE) {
 		au1000_update_tx_stats(dev, ptxd->status);
 		ptxd->buff_stat &= ~TX_T_DONE;
@@ -820,6 +869,12 @@ static void au1000_tx_ack(struct net_dev
 			aup->tx_full = 0;
 			netif_wake_queue(dev);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/amd/nmclan_cs.c b/net/ethernet/amd/nmclan_cs.c
--- a/net/ethernet/amd/nmclan_cs.c
+++ b/net/ethernet/amd/nmclan_cs.c
@@ -544,6 +544,11 @@ static int mace_init(mace_private *lp, u
 
   /* MACE Software reset */
   mace_write(lp, ioaddr, MACE_BIUCC, 1);
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (mace_read(lp, ioaddr, MACE_BIUCC) & 0x01) {
     /* Wait for reset bit to be cleared automatically after <= 200ns */;
     if(++ct > 500)
@@ -552,6 +557,12 @@ static int mace_init(mace_private *lp, u
     	return -1;
     }
     udelay(1);
+    if (_cur < timeout) {
+    	rdstcll(_cur);
+    }
+    else {
+    	break;
+    }
   }
   mace_write(lp, ioaddr, MACE_BIUCC, 0);
 
@@ -591,6 +602,11 @@ static int mace_init(mace_private *lp, u
   mace_write(lp, ioaddr, MACE_IAC, MACE_IAC_ADDRCHG | MACE_IAC_PHYADDR);
   /* Poll ADDRCHG bit */
   ct = 0;
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (mace_read(lp, ioaddr, MACE_IAC) & MACE_IAC_ADDRCHG)
   {
   	if(++ ct > 500)
@@ -598,6 +614,12 @@ static int mace_init(mace_private *lp, u
 		pr_err("ADDRCHG timeout, card removed?\n");
   		return -1;
   	}
+  	if (_cur < timeout) {
+  		rdstcll(_cur);
+  	}
+  	else {
+  		break;
+    }
   }
   /* Set PADR register */
   for (i = 0; i < ETHER_ADDR_LEN; i++)
diff -u -p a/net/ethernet/amd/pcnet32.c b/net/ethernet/amd/pcnet32.c
--- a/net/ethernet/amd/pcnet32.c
+++ b/net/ethernet/amd/pcnet32.c
@@ -985,6 +985,11 @@ static int pcnet32_loopback_test(struct
 
 	x = 0;
 	rc = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (x < numbuffs && !rc) {
 		skb = lp->rx_skbuff[x];
 		packet = lp->tx_skbuff[x]->data;
@@ -998,7 +1003,13 @@ static int pcnet32_loopback_test(struct
 			}
 		}
 		x++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 clean_up:
 	*data1 = rc;
@@ -1081,7 +1092,12 @@ static int pcnet32_suspend(struct net_de
 
 	/* poll waiting for bit to be set */
 	ticks = 0;
-	while (!(a->read_csr(ioaddr, CSR5) & CSR5_SUSPEND)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(a->read_csr(ioaddr, CSR5) & CSR5_SUSPEND)) {
 		spin_unlock_irqrestore(&lp->lock, *flags);
 		if (can_sleep)
 			msleep(1);
@@ -1094,6 +1110,12 @@ static int pcnet32_suspend(struct net_de
 				     "Error getting into suspend!\n");
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 1;
 }
@@ -2910,6 +2932,11 @@ static void __exit pcnet32_cleanup_modul
 {
 	struct net_device *next_dev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pcnet32_dev) {
 		struct pcnet32_private *lp = netdev_priv(pcnet32_dev);
 		next_dev = lp->next;
@@ -2920,6 +2947,12 @@ static void __exit pcnet32_cleanup_modul
 				    lp->init_block, lp->init_dma_addr);
 		free_netdev(pcnet32_dev);
 		pcnet32_dev = next_dev;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (pcnet32_have_pci)
diff -u -p a/net/ethernet/amd/ni65.c b/net/ethernet/amd/ni65.c
--- a/net/ethernet/amd/ni65.c
+++ b/net/ethernet/amd/ni65.c
@@ -1056,6 +1056,11 @@ static void ni65_recv_intr(struct net_de
 	struct priv *p = dev->ml_priv;
 
 	rmdp = p->rmdhead + p->rmdnum;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(!( (rmdstat = rmdp->u.s.status) & RCV_OWN))
 	{
 		cnt++;
@@ -1133,6 +1138,12 @@ static void ni65_recv_intr(struct net_de
 		rmdp->u.s.status = RCV_OWN; /* change owner */
 		p->rmdnum = (p->rmdnum + 1) & (RMDNUM-1);
 		rmdp = p->rmdhead + p->rmdnum;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/dec/tulip/uli526x.c b/net/ethernet/dec/tulip/uli526x.c
--- a/net/ethernet/dec/tulip/uli526x.c
+++ b/net/ethernet/dec/tulip/uli526x.c
@@ -1252,10 +1252,21 @@ static void uli526x_free_rxbuffer(struct
 	ULI526X_DBUG(0, "uli526x_free_rxbuffer()", 0);
 
 	/* free allocated rx buffer */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (db->rx_avail_cnt) {
 		dev_kfree_skb(db->rx_ready_ptr->rx_skb_ptr);
 		db->rx_ready_ptr = db->rx_ready_ptr->next_rx_desc;
 		db->rx_avail_cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/dec/tulip/dmfe.c b/net/ethernet/dec/tulip/dmfe.c
--- a/net/ethernet/dec/tulip/dmfe.c
+++ b/net/ethernet/dec/tulip/dmfe.c
@@ -1329,10 +1329,21 @@ static void dmfe_free_rxbuffer(struct dm
 	DMFE_DBUG(0, "dmfe_free_rxbuffer()", 0);
 
 	/* free allocated rx buffer */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (db->rx_avail_cnt) {
 		dev_kfree_skb(db->rx_ready_ptr->rx_skb_ptr);
 		db->rx_ready_ptr = db->rx_ready_ptr->next_rx_desc;
 		db->rx_avail_cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/dec/tulip/de4x5.c b/net/ethernet/dec/tulip/de4x5.c
--- a/net/ethernet/dec/tulip/de4x5.c
+++ b/net/ethernet/dec/tulip/de4x5.c
@@ -1585,8 +1585,19 @@ de4x5_interrupt(int irq, void *dev_id)
 
     /* Load the TX ring with any locally stored packets */
     if (!test_and_set_bit(0, (void *)&lp->cache.lock)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!skb_queue_empty(&lp->cache.queue) && !netif_queue_stopped(dev) && lp->tx_enable) {
 	    de4x5_queue_pkt(de4x5_get_cache(dev), dev);
+	    if (_cur < timeout) {
+	    rdstcll(_cur);
+	    }
+	    else {
+	    break;
+	    }
 	}
 	lp->cache.lock = 0;
     }
diff -u -p a/net/ethernet/ibm/ehea/ehea_qmr.c b/net/ethernet/ibm/ehea/ehea_qmr.c
--- a/net/ethernet/ibm/ehea/ehea_qmr.c
+++ b/net/ethernet/ibm/ehea/ehea_qmr.c
@@ -78,6 +78,11 @@ static int hw_queue_ctor(struct hw_queue
 	 * inner loop divides a kernel page into smaller hea queue pages
 	 */
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < nr_of_pages) {
 		u8 *kpage = (u8 *)get_zeroed_page(GFP_KERNEL);
 		if (!kpage)
@@ -87,6 +92,12 @@ static int hw_queue_ctor(struct hw_queue
 			kpage += pagesize;
 			i++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	queue->current_q_offset = 0;
@@ -726,6 +737,11 @@ static int ehea_create_busmap_callback(u
 	end_pfn = initial_pfn + total_nr_pages;
 	pfn = start_pfn;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pfn < end_pfn) {
 		if (ehea_is_hugepage(pfn)) {
 			/* Add mem found in front of the hugepage */
@@ -740,6 +756,12 @@ static int ehea_create_busmap_callback(u
 			start_pfn = pfn;
 		} else
 			pfn += (EHEA_SECTSIZE / PAGE_SIZE);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* Add mem found behind the hugepage(s)  */
diff -u -p a/net/ethernet/ibm/ehea/ehea_main.c b/net/ethernet/ibm/ehea/ehea_main.c
--- a/net/ethernet/ibm/ehea/ehea_main.c
+++ b/net/ethernet/ibm/ehea/ehea_main.c
@@ -887,6 +887,11 @@ static int ehea_poll(struct napi_struct
 	cqe_skb = ehea_proc_cqes(pr, EHEA_POLL_MAX_CQES);
 	rx += ehea_proc_rwqes(dev, pr, budget - rx);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rx != budget) {
 		napi_complete(napi);
 		ehea_reset_cq_ep(pr->recv_cq);
@@ -905,6 +910,12 @@ static int ehea_poll(struct napi_struct
 
 		cqe_skb = ehea_proc_cqes(pr, EHEA_POLL_MAX_CQES);
 		rx += ehea_proc_rwqes(dev, pr, budget - rx);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return rx;
@@ -941,7 +952,12 @@ static irqreturn_t ehea_qp_aff_irq_handl
 
 	eqe = ehea_poll_eq(port->qp_eq);
 
-	while (eqe) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (eqe) {
 		qp_token = EHEA_BMASK_GET(EHEA_EQE_QP_TOKEN, eqe->entry);
 		pr_err("QP aff_err: entry=0x%llx, token=0x%x\n",
 		       eqe->entry, qp_token);
@@ -959,6 +975,12 @@ static irqreturn_t ehea_qp_aff_irq_handl
 			reset_port = 1;   /* Reset in case of CQ or EQ error */
 
 		eqe = ehea_poll_eq(port->qp_eq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (reset_port) {
@@ -1237,11 +1259,22 @@ static void ehea_neq_tasklet(unsigned lo
 	eqe = ehea_poll_eq(adapter->neq);
 	pr_debug("eqe=%p\n", eqe);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (eqe) {
 		pr_debug("*eqe=%lx\n", (unsigned long) eqe->entry);
 		ehea_parse_eqe(adapter, eqe->entry);
 		eqe = ehea_poll_eq(adapter->neq);
 		pr_debug("next eqe=%p\n", eqe);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		   }
+		   else {
+		   	break;
+		   }
 	}
 
 	event_mask = EHEA_BMASK_SET(NELR_PORTSTATE_CHG, 1)
@@ -3084,7 +3117,12 @@ static int ehea_setup_ports(struct ehea_
 	int i = 0;
 
 	lhea_dn = adapter->ofdev->dev.of_node;
-	while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
 
 		dn_log_port_id = of_get_property(eth_dn, "ibm,hea-port-no",
 						 NULL);
@@ -3110,6 +3148,12 @@ static int ehea_setup_ports(struct ehea_
 			ehea_remove_adapter_mr(adapter);
 
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -3122,13 +3166,24 @@ static struct device_node *ehea_get_eth_
 	const u32 *dn_log_port_id;
 
 	lhea_dn = adapter->ofdev->dev.of_node;
-	while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {
 
 		dn_log_port_id = of_get_property(eth_dn, "ibm,hea-port-no",
 						 NULL);
 		if (dn_log_port_id)
 			if (*dn_log_port_id == logical_port_id)
 				return eth_dn;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 	}
 
 	return NULL;
diff -u -p a/net/ethernet/ibm/emac/core.c b/net/ethernet/ibm/emac/core.c
--- a/net/ethernet/ibm/emac/core.c
+++ b/net/ethernet/ibm/emac/core.c
@@ -241,9 +241,20 @@ static void emac_tx_disable(struct emac_
 	if (r & EMAC_MR0_TXE) {
 		int n = dev->stop_timeout;
 		out_be32(&p->mr0, r & ~EMAC_MR0_TXE);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(in_be32(&p->mr0) & EMAC_MR0_TXI) && n) {
 			udelay(1);
 			--n;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (unlikely(!n))
 			emac_report_timeout_error(dev, "TX disable timeout");
@@ -265,9 +276,20 @@ static void emac_rx_enable(struct emac_i
 		if (unlikely(!(r & EMAC_MR0_RXI))) {
 			/* Wait if previous async disable is still in progress */
 			int n = dev->stop_timeout;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (!(r = in_be32(&p->mr0) & EMAC_MR0_RXI) && n) {
 				udelay(1);
 				--n;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if (unlikely(!n))
 				emac_report_timeout_error(dev,
@@ -290,9 +312,20 @@ static void emac_rx_disable(struct emac_
 	if (r & EMAC_MR0_RXE) {
 		int n = dev->stop_timeout;
 		out_be32(&p->mr0, r & ~EMAC_MR0_RXE);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(in_be32(&p->mr0) & EMAC_MR0_RXI) && n) {
 			udelay(1);
 			--n;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (unlikely(!n))
 			emac_report_timeout_error(dev, "RX disable timeout");
@@ -775,12 +808,23 @@ static int __emac_mdio_read(struct emac_
 
 	/* Wait for management interface to become idle */
 	n = 20;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!emac_phy_done(dev, in_be32(&p->stacr))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait idle\n");
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Issue read command */
@@ -800,12 +844,23 @@ static int __emac_mdio_read(struct emac_
 
 	/* Wait for read to complete */
 	n = 200;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!emac_phy_done(dev, (r = in_be32(&p->stacr)))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait complete\n");
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (unlikely(r & EMAC_STACR_PHYE)) {
@@ -847,12 +902,23 @@ static void __emac_mdio_write(struct ema
 
 	/* Wait for management interface to be idle */
 	n = 20;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!emac_phy_done(dev, in_be32(&p->stacr))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait idle\n");
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Issue write command */
@@ -873,12 +939,23 @@ static void __emac_mdio_write(struct ema
 
 	/* Wait for write to complete */
 	n = 200;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!emac_phy_done(dev, in_be32(&p->stacr))) {
 		udelay(1);
 		if (!--n) {
 			DBG2(dev, " -> timeout wait complete\n");
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	err = 0;
  bail:
@@ -1483,11 +1560,22 @@ static int emac_start_xmit_sg(struct sk_
 	/* Well, too bad. Our previous estimation was overly optimistic.
 	 * Undo everything.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (slot != dev->tx_slot) {
 		dev->tx_desc[slot].ctrl = 0;
 		--dev->tx_cnt;
 		if (--slot < 0)
 			slot = NUM_TX_BUFF - 1;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	++dev->estats.tx_undo;
 
@@ -1793,6 +1881,11 @@ static int emac_peek_rx_sg(void *param)
 	struct emac_instance *dev = param;
 
 	int slot = dev->rx_slot;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		u16 ctrl = dev->rx_desc[slot].ctrl;
 		if (ctrl & MAL_RX_CTRL_EMPTY)
@@ -1805,6 +1898,12 @@ static int emac_peek_rx_sg(void *param)
 		/* I'm just being paranoid here :) */
 		if (unlikely(slot == dev->rx_slot))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/net/ethernet/ibm/iseries_veth.c b/net/ethernet/ibm/iseries_veth.c
--- a/net/ethernet/ibm/iseries_veth.c
+++ b/net/ethernet/ibm/iseries_veth.c
@@ -1377,11 +1377,22 @@ static inline void veth_build_dma_list(s
 			   PAGE_SIZE - ((unsigned long)p & ~PAGE_MASK));
 
 	done = list[0].size;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (done < length) {
 		list[i].addr = iseries_hv_addr(p + done);
 		list[i].size = min(length-done, PAGE_SIZE);
 		done += list[i].size;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/rdc/r6040.c b/net/ethernet/rdc/r6040.c
--- a/net/ethernet/rdc/r6040.c
+++ b/net/ethernet/rdc/r6040.c
@@ -529,6 +529,11 @@ static int r6040_rx(struct net_device *d
 	u16 err;
 
 	/* Limit not reached and the descriptor belongs to the CPU */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count < limit && !(descptr->status & DSC_OWNER_MAC)) {
 		/* Read the descriptor status */
 		err = descptr->status;
@@ -586,6 +591,12 @@ next_descr:
 		descptr->status = DSC_OWNER_MAC;
 		descptr = descptr->vndescp;
 		count++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	priv->rx_remove_ptr = descptr;
 
diff -u -p a/net/ethernet/sfc/tx.c b/net/ethernet/sfc/tx.c
--- a/net/ethernet/sfc/tx.c
+++ b/net/ethernet/sfc/tx.c
@@ -285,12 +285,23 @@ netdev_tx_t efx_enqueue_skb(struct efx_t
 
  unwind:
 	/* Work backwards until we hit the original insert pointer value */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tx_queue->insert_count != tx_queue->write_count) {
 		--tx_queue->insert_count;
 		insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
 		buffer = &tx_queue->buffer[insert_ptr];
 		efx_dequeue_buffer(tx_queue, buffer);
 		buffer->len = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Free the fragment we were mid-way through pushing */
@@ -320,6 +331,11 @@ static void efx_dequeue_buffers(struct e
 	stop_index = (index + 1) & tx_queue->ptr_mask;
 	read_ptr = tx_queue->read_count & tx_queue->ptr_mask;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (read_ptr != stop_index) {
 		struct efx_tx_buffer *buffer = &tx_queue->buffer[read_ptr];
 		if (unlikely(buffer->len == 0)) {
@@ -336,6 +352,12 @@ static void efx_dequeue_buffers(struct e
 
 		++tx_queue->read_count;
 		read_ptr = tx_queue->read_count & tx_queue->ptr_mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -533,6 +555,11 @@ void efx_release_tx_buffers(struct efx_t
 		return;
 
 	/* Free any buffers left in the ring */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tx_queue->read_count != tx_queue->write_count) {
 		buffer = &tx_queue->buffer[tx_queue->read_count & tx_queue->ptr_mask];
 		efx_dequeue_buffer(tx_queue, buffer);
@@ -540,6 +567,12 @@ void efx_release_tx_buffers(struct efx_t
 		buffer->len = 0;
 
 		++tx_queue->read_count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -890,7 +923,12 @@ static void efx_enqueue_unwind(struct ef
 	dma_addr_t unmap_addr;
 
 	/* Work backwards until we hit the original insert pointer value */
-	while (tx_queue->insert_count != tx_queue->write_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tx_queue->insert_count != tx_queue->write_count) {
 		--tx_queue->insert_count;
 		buffer = &tx_queue->buffer[tx_queue->insert_count &
 					   tx_queue->ptr_mask];
@@ -911,6 +949,12 @@ static void efx_enqueue_unwind(struct ef
 		}
 		buffer->len = 0;
 		buffer->continuation = true;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/sfc/nic.c b/net/ethernet/sfc/nic.c
--- a/net/ethernet/sfc/nic.c
+++ b/net/ethernet/sfc/nic.c
@@ -560,11 +560,22 @@ void efx_nic_notify_rx_desc(struct efx_r
 	efx_dword_t reg;
 	unsigned write_ptr;
 
-	while (rx_queue->notified_count != rx_queue->added_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rx_queue->notified_count != rx_queue->added_count) {
 		efx_build_rx_desc(
 			rx_queue,
 			rx_queue->notified_count & rx_queue->ptr_mask);
 		++rx_queue->notified_count;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	wmb();
diff -u -p a/net/ethernet/sfc/mtd.c b/net/ethernet/sfc/mtd.c
--- a/net/ethernet/sfc/mtd.c
+++ b/net/ethernet/sfc/mtd.c
@@ -276,9 +276,20 @@ static int efx_mtd_probe_device(struct e
 	return 0;
 
 fail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (part != &efx_mtd->part[0]) {
 		--part;
 		efx_mtd_remove_partition(part);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* mtd_device_register() returns 1 if the MTD table is full */
 	return -ENOMEM;
@@ -468,7 +479,12 @@ static int siena_mtd_read(struct mtd_inf
 	size_t chunk;
 	int rc = 0;
 
-	while (offset < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset < end) {
 		chunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);
 		rc = efx_mcdi_nvram_read(efx, part->mcdi.nvram_type, offset,
 					 buffer, chunk);
@@ -476,7 +492,13 @@ static int siena_mtd_read(struct mtd_inf
 			goto out;
 		offset += chunk;
 		buffer += chunk;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	*retlen = offset - start;
 	return rc;
@@ -502,13 +524,24 @@ static int siena_mtd_erase(struct mtd_in
 	/* The MCDI interface can in fact do multiple erase blocks at once;
 	 * but erasing may be slow, so we make multiple calls here to avoid
 	 * tripping the MCDI RPC timeout. */
-	while (offset < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < end) {
 		rc = efx_mcdi_nvram_erase(efx, part->mcdi.nvram_type, offset,
 					  chunk);
 		if (rc)
 			goto out;
 		offset += chunk;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	return rc;
 }
@@ -531,7 +564,12 @@ static int siena_mtd_write(struct mtd_in
 		part->mcdi.updating = 1;
 	}
 
-	while (offset < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset < end) {
 		chunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);
 		rc = efx_mcdi_nvram_write(efx, part->mcdi.nvram_type, offset,
 					  buffer, chunk);
@@ -539,7 +577,13 @@ static int siena_mtd_write(struct mtd_in
 			goto out;
 		offset += chunk;
 		buffer += chunk;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	*retlen = offset - start;
 	return rc;
diff -u -p a/net/ethernet/sfc/filter.c b/net/ethernet/sfc/filter.c
--- a/net/ethernet/sfc/filter.c
+++ b/net/ethernet/sfc/filter.c
@@ -702,6 +702,11 @@ bool __efx_filter_rfs_expire(struct efx_
 	index = state->rps_expire_index;
 	stop = (index + quota) & mask;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (index != stop) {
 		if (test_bit(index, table->used_bitmap) &&
 		    table->spec[index].priority == EFX_FILTER_PRI_HINT &&
@@ -714,6 +719,12 @@ bool __efx_filter_rfs_expire(struct efx_
 			efx_filter_table_clear_entry(efx, table, index);
 		}
 		index = (index + 1) & mask;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	state->rps_expire_index = stop;
diff -u -p a/net/ethernet/sfc/mdio_10g.c b/net/ethernet/sfc/mdio_10g.c
--- a/net/ethernet/sfc/mdio_10g.c
+++ b/net/ethernet/sfc/mdio_10g.c
@@ -84,6 +84,11 @@ int efx_mdio_wait_reset_mmds(struct efx_
 		int mmd = 0;
 		int stat;
 		in_reset = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (mask) {
 			if (mask & 1) {
 				stat = efx_mdio_read(efx, mmd, MDIO_CTRL1);
@@ -98,6 +103,12 @@ int efx_mdio_wait_reset_mmds(struct efx_
 			}
 			mask = mask >> 1;
 			mmd++;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		if (!in_reset)
 			break;
@@ -142,11 +153,22 @@ int efx_mdio_check_mmds(struct efx_nic *
 	netif_vdbg(efx, hw, efx->net_dev, "Devices present: %x\n", devices);
 
 	/* Check all required MMDs are responding and happy. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mmd_mask) {
 		if ((mmd_mask & 1) && efx_mdio_check_mmd(efx, mmd))
 			return -EIO;
 		mmd_mask = mmd_mask >> 1;
 		mmd++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -217,11 +239,22 @@ void efx_mdio_set_mmds_lpower(struct efx
 {
 	int mmd = 0;
 	mmd_mask &= ~MDIO_DEVS_AN;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mmd_mask) {
 		if (mmd_mask & 1)
 			efx_mdio_set_mmd_lpower(efx, low_power, mmd);
 		mmd_mask = (mmd_mask >> 1);
 		mmd++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/sfc/falcon_boards.c b/net/ethernet/sfc/falcon_boards.c
--- a/net/ethernet/sfc/falcon_boards.c
+++ b/net/ethernet/sfc/falcon_boards.c
@@ -68,12 +68,23 @@
 
 static int efx_poke_lm87(struct i2c_client *client, const u8 *reg_values)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*reg_values) {
 		u8 reg = *reg_values++;
 		u8 value = *reg_values++;
 		int rc = i2c_smbus_write_byte_data(client, reg, value);
 		if (rc)
 			return rc;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/sfc/falcon_xmac.c b/net/ethernet/sfc/falcon_xmac.c
--- a/net/ethernet/sfc/falcon_xmac.c
+++ b/net/ethernet/sfc/falcon_xmac.c
@@ -256,6 +256,11 @@ static bool falcon_xmac_link_ok_retry(st
 
 	falcon_stop_nic_stats(efx);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!mac_up && tries) {
 		netif_dbg(efx, hw, efx->net_dev, "bashing xaui\n");
 		falcon_reset_xaui(efx);
@@ -263,6 +268,12 @@ static bool falcon_xmac_link_ok_retry(st
 
 		mac_up = falcon_xmac_link_ok(efx);
 		--tries;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	falcon_start_nic_stats(efx);
diff -u -p a/net/ethernet/sgi/ioc3-eth.c b/net/ethernet/sgi/ioc3-eth.c
--- a/net/ethernet/sgi/ioc3-eth.c
+++ b/net/ethernet/sgi/ioc3-eth.c
@@ -591,6 +591,11 @@ static inline void ioc3_rx(struct net_de
 	rxb = (struct ioc3_erxbuf *) (skb->data - RX_OFFSET);
 	w0 = be32_to_cpu(rxb->w0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (w0 & ERXBUF_V) {
 		err = be32_to_cpu(rxb->err);		/* It's valid ...  */
 		if (err & ERXBUF_GOODPKT) {
@@ -644,6 +649,12 @@ next:
 		skb = ip->rx_skbs[rx_entry];
 		rxb = (struct ioc3_erxbuf *) (skb->data - RX_OFFSET);
 		w0 = be32_to_cpu(rxb->w0);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	ioc3_w_erpir((n_entry << 3) | ERPIR_ARM);
 	ip->rx_pi = n_entry;
@@ -667,6 +678,11 @@ static inline void ioc3_tx(struct net_de
 	packets = 0;
 	bytes = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (o_entry != tx_entry) {
 		packets++;
 		skb = ip->tx_skbs[o_entry];
@@ -678,6 +694,12 @@ static inline void ioc3_tx(struct net_de
 
 		etcir = ioc3_r_etcir();			/* More pkts sent?  */
 		tx_entry = (etcir >> 7) & 127;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev->stats.tx_packets += packets;
@@ -881,12 +903,23 @@ static void ioc3_free_rings(struct ioc3_
 		n_entry = ip->rx_ci;
 		rx_entry = ip->rx_pi;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (n_entry != rx_entry) {
 			skb = ip->rx_skbs[n_entry];
 			if (skb)
 				dev_kfree_skb_any(skb);
 
 			n_entry = (n_entry + 1) & 511;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		free_page((unsigned long)ip->rxr);
 		ip->rxr = NULL;
diff -u -p a/net/ethernet/sgi/meth.c b/net/ethernet/sgi/meth.c
--- a/net/ethernet/sgi/meth.c
+++ b/net/ethernet/sgi/meth.c
@@ -105,9 +105,20 @@ static inline void load_eaddr(struct net
  * Waits for BUSY status of mdio bus to clear
  */
 #define WAIT_FOR_PHY(___rval)					\
-	while ((___rval = mace->eth.phy_data) & MDIO_BUSY) {	\
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+unsigned long long _start = 0;
+unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while ((___rval = mace->eth.phy_data) & MDIO_BUSY) {	\
 		udelay(25);					\
+	if (_cur < timeout) {
+		rdstcll(_cur);
 	}
+	else {
+		break;
+	}
+}
 /*read phy register, return value read */
 static unsigned long mdio_read(struct meth_private *priv, unsigned long phyreg)
 {
@@ -382,7 +393,12 @@ static void meth_rx(struct net_device* d
 	if (int_status & METH_INT_RX_UNDERFLOW) {
 		fifo_rptr = (fifo_rptr - 1) & 0x0f;
 	}
-	while (priv->rx_write != fifo_rptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (priv->rx_write != fifo_rptr) {
 		dma_unmap_single(NULL, priv->rx_ring_dmas[priv->rx_write],
 				 METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);
 		status = priv->rx_ring[priv->rx_write]->status.raw;
@@ -448,6 +464,12 @@ static void meth_rx(struct net_device* d
 				       METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);
 		mace->eth.rx_fifo = priv->rx_ring_dmas[priv->rx_write];
 		ADVANCE_RX_PTR(priv->rx_write);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_lock_irqsave(&priv->meth_lock, flags);
 	/* In case there was underflow, and Rx DMA was disabled */
diff -u -p a/net/ethernet/sis/sis900.c b/net/ethernet/sis/sis900.c
--- a/net/ethernet/sis/sis900.c
+++ b/net/ethernet/sis/sis900.c
@@ -621,11 +621,22 @@ static int __devinit sis900_mii_probe(st
 		if ((mii_phy = kmalloc(sizeof(struct mii_phy), GFP_KERNEL)) == NULL) {
 			printk(KERN_WARNING "Cannot allocate mem for struct mii_phy\n");
 			mii_phy = sis_priv->first_mii;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (mii_phy) {
 				struct mii_phy *phy;
 				phy = mii_phy;
 				mii_phy = mii_phy->next;
 				kfree(phy);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			return 0;
 		}
@@ -680,7 +691,12 @@ static int __devinit sis900_mii_probe(st
             	mdio_write(net_dev, sis_priv->cur_phy, 0x0018, 0xD200);
 
 	if(status & MII_STAT_LINK){
-		while (poll_bit) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (poll_bit) {
 			yield();
 
 			poll_bit ^= (mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS) & poll_bit);
@@ -689,6 +705,12 @@ static int __devinit sis900_mii_probe(st
 				       dev_name);
 				return -ETIME;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -2390,10 +2412,21 @@ static void __devexit sis900_remove(stru
 	struct sis900_private *sis_priv = netdev_priv(net_dev);
 	struct mii_phy *phy = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sis_priv->first_mii) {
 		phy = sis_priv->first_mii;
 		sis_priv->first_mii = phy->next;
 		kfree(phy);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pci_free_consistent(pci_dev, RX_TOTAL_SIZE, sis_priv->rx_ring,
diff -u -p a/net/ethernet/sun/sungem.c b/net/ethernet/sun/sungem.c
--- a/net/ethernet/sun/sungem.c
+++ b/net/ethernet/sun/sungem.c
@@ -721,6 +721,11 @@ static __inline__ void gem_post_rxds(str
 	count = 0;
 	kick = -1;
 	wmb();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (curr != limit) {
 		curr = NEXT_RX(curr);
 		if (++count == 4) {
@@ -736,6 +741,12 @@ static __inline__ void gem_post_rxds(str
 			kick = curr;
 			count = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (kick >= 0) {
 		mb();
diff -u -p a/net/ethernet/sun/sunhme.c b/net/ethernet/sun/sunhme.c
--- a/net/ethernet/sun/sunhme.c
+++ b/net/ethernet/sun/sunhme.c
@@ -1993,6 +1993,11 @@ static void happy_meal_rx(struct happy_m
 
 	RXD(("RX<"));
 	this = &rxbase[elem];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((flags = hme_read_desc32(hp, &this->rx_flags)) & RXFLAG_OWN)) {
 		struct sk_buff *skb;
 		int len = flags >> 16;
@@ -2076,6 +2081,12 @@ static void happy_meal_rx(struct happy_m
 	next:
 		elem = NEXT_RX(elem);
 		this = &rxbase[elem];
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	hp->rx_new = elem;
 	if (drops)
@@ -2859,6 +2870,11 @@ static int is_quattro_p(struct pci_dev *
 
 	n_hmes = 0;
 	tmp = pdev->bus->devices.next;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmp != &pdev->bus->devices) {
 		struct pci_dev *this_pdev = pci_dev_b(tmp);
 
@@ -2867,6 +2883,12 @@ static int is_quattro_p(struct pci_dev *
 			n_hmes++;
 
 		tmp = tmp->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (n_hmes != 4)
@@ -3212,6 +3234,11 @@ static void happy_meal_pci_exit(void)
 {
 	pci_unregister_driver(&hme_pci_driver);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qfe_pci_list) {
 		struct quattro *qfe = qfe_pci_list;
 		struct quattro *next = qfe->next;
@@ -3219,6 +3246,12 @@ static void happy_meal_pci_exit(void)
 		kfree(qfe);
 
 		qfe_pci_list = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -3313,6 +3346,11 @@ static void happy_meal_sbus_exit(void)
 	platform_driver_unregister(&hme_sbus_driver);
 	quattro_sbus_free_irqs();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qfe_sbus_list) {
 		struct quattro *qfe = qfe_sbus_list;
 		struct quattro *next = qfe->next;
@@ -3320,6 +3358,12 @@ static void happy_meal_sbus_exit(void)
 		kfree(qfe);
 
 		qfe_sbus_list = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 #endif
diff -u -p a/net/ethernet/sun/sunbmac.c b/net/ethernet/sun/sunbmac.c
--- a/net/ethernet/sun/sunbmac.c
+++ b/net/ethernet/sun/sunbmac.c
@@ -808,6 +808,11 @@ static void bigmac_rx(struct bigmac *bp)
 	u32 flags;
 
 	this = &rxbase[elem];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((flags = this->rx_flags) & RXD_OWN)) {
 		struct sk_buff *skb;
 		int len = (flags & RXD_LENGTH); /* FCS not included */
@@ -884,6 +889,12 @@ static void bigmac_rx(struct bigmac *bp)
 	next:
 		elem = NEXT_RX(elem);
 		this = &rxbase[elem];
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	bp->rx_new = elem;
 	if (drops)
diff -u -p a/net/ethernet/sun/sunqe.c b/net/ethernet/sun/sunqe.c
--- a/net/ethernet/sun/sunqe.c
+++ b/net/ethernet/sun/sunqe.c
@@ -419,7 +419,12 @@ static void qe_rx(struct sunqe *qep)
 	u32 flags;
 
 	this = &rxbase[elem];
-	while (!((flags = this->rx_flags) & RXD_OWN)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!((flags = this->rx_flags) & RXD_OWN)) {
 		struct sk_buff *skb;
 		unsigned char *this_qbuf =
 			&qbufs->rx_buf[elem & (RX_RING_SIZE - 1)][0];
@@ -455,6 +460,12 @@ static void qe_rx(struct sunqe *qep)
 
 		elem = NEXT_RX(elem);
 		this = &rxbase[elem];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	qep->rx_new = elem;
 	if (drops)
@@ -990,6 +1001,11 @@ static void __exit qec_exit(void)
 {
 	platform_driver_unregister(&qec_sbus_driver);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (root_qec_dev) {
 		struct sunqec *next = root_qec_dev->next_module;
 		struct platform_device *op = root_qec_dev->op;
@@ -1000,6 +1016,12 @@ static void __exit qec_exit(void)
 		kfree(root_qec_dev);
 
 		root_qec_dev = next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/via/via-rhine.c b/net/ethernet/via/via-rhine.c
--- a/net/ethernet/via/via-rhine.c
+++ b/net/ethernet/via/via-rhine.c
@@ -815,6 +815,11 @@ static int __devinit rhine_init_one(stru
 
 	/* Check that selected MMIO registers match the PIO ones */
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mmio_verify_registers[i]) {
 		int reg = mmio_verify_registers[i++];
 		unsigned char a = inb(pioaddr+reg);
@@ -826,7 +831,13 @@ static int __devinit rhine_init_one(stru
 				reg, a, b);
 			goto err_out_unmap;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 #endif /* USE_MMIO */
 
 	dev->base_addr = (unsigned long)ioaddr;
diff -u -p a/net/ethernet/3com/typhoon.c b/net/ethernet/3com/typhoon.c
--- a/net/ethernet/3com/typhoon.c
+++ b/net/ethernet/3com/typhoon.c
@@ -491,6 +491,11 @@ typhoon_process_response(struct typhoon
 
 	cleared = le32_to_cpu(indexes->respCleared);
 	ready = le32_to_cpu(indexes->respReady);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(cleared != ready) {
 		resp = (struct resp_desc *)(base + cleared);
 		count = resp->numDesc + 1;
@@ -530,6 +535,12 @@ typhoon_process_response(struct typhoon
 
 cleanup:
 		typhoon_inc_resp_index(&cleared, count);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	indexes->respCleared = cpu_to_le32(cleared);
@@ -1410,6 +1421,11 @@ typhoon_download_firmware(struct typhoon
 		load_addr = le32_to_cpu(sHdr->startAddr);
 		section_len = le32_to_cpu(sHdr->len);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(section_len) {
 			len = min_t(u32, section_len, PAGE_SIZE);
 
@@ -1443,6 +1459,12 @@ typhoon_download_firmware(struct typhoon
 			image_data += len;
 			load_addr += len;
 			section_len -= len;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -1519,6 +1541,11 @@ typhoon_clean_tx(struct typhoon *tp, str
 	int dma_len;
 	int type;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(lastRead != le32_to_cpu(*index)) {
 		tx = (struct tx_desc *) (txRing->ringBase + lastRead);
 		type = tx->flags & TYPHOON_TYPE_MASK;
@@ -1540,6 +1567,12 @@ typhoon_clean_tx(struct typhoon *tp, str
 
 		tx->flags = 0;
 		typhoon_inc_tx_index(&lastRead, 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return lastRead;
diff -u -p a/net/ethernet/3com/3c515.c b/net/ethernet/3com/3c515.c
--- a/net/ethernet/3com/3c515.c
+++ b/net/ethernet/3com/3c515.c
@@ -507,7 +507,12 @@ static struct net_device *corkscrew_scan
 	for(i=0; corkscrew_isapnp_adapters[i].vendor != 0; i++) {
 		struct pnp_dev *idev = NULL;
 		int irq;
-		while((idev = pnp_find_dev(NULL,
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while((idev = pnp_find_dev(NULL,
 					   corkscrew_isapnp_adapters[i].vendor,
 					   corkscrew_isapnp_adapters[i].function,
 					   idev))) {
@@ -541,6 +546,12 @@ static struct net_device *corkscrew_scan
 			if (!err)
 				return dev;
 			cleanup_card(dev);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 no_pnp:
@@ -1338,6 +1349,11 @@ static int boomerang_rx(struct net_devic
 	if (corkscrew_debug > 5)
 		pr_debug("   In boomerang_rx(), status %4.4x, rx_status %4.4x.\n",
 			inw(ioaddr + EL3_STATUS), inw(ioaddr + RxStatus));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((rx_status = vp->rx_ring[entry].status) & RxDComplete) {
 		if (rx_status & RxDError) {	/* Error, update stats. */
 			unsigned char rx_error = rx_status >> 16;
@@ -1397,6 +1413,12 @@ static int boomerang_rx(struct net_devic
 			dev->stats.rx_packets++;
 		}
 		entry = (++vp->cur_rx) % RX_RING_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Refill the Rx ring buffers. */
 	for (; vp->cur_rx - vp->dirty_rx > 0; vp->dirty_rx++) {
@@ -1569,7 +1591,12 @@ static const struct ethtool_ops netdev_e
 #ifdef MODULE
 void cleanup_module(void)
 {
-	while (!list_empty(&root_corkscrew_dev)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&root_corkscrew_dev)) {
 		struct net_device *dev;
 		struct corkscrew_private *vp;
 
@@ -1579,6 +1606,12 @@ void cleanup_module(void)
 		unregister_netdev(dev);
 		cleanup_card(dev);
 		free_netdev(dev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 #endif				/* MODULE */
diff -u -p a/net/ethernet/8390/ne.c b/net/ethernet/8390/ne.c
--- a/net/ethernet/8390/ne.c
+++ b/net/ethernet/8390/ne.c
@@ -966,10 +966,21 @@ struct net_device * __init ne_probe(int
 
 	/* Find an empty slot, that is no net_device and zero io port. */
 	this_dev = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((pdev_ne[this_dev] && platform_get_drvdata(pdev_ne[this_dev])) ||
 		io[this_dev]) {
 		if (++this_dev == MAX_NE_CARDS)
 			return ERR_PTR(-ENOMEM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	/* Get irq, io from kernel command line */
diff -u -p a/net/ethernet/seeq/sgiseeq.c b/net/ethernet/seeq/sgiseeq.c
--- a/net/ethernet/seeq/sgiseeq.c
+++ b/net/ethernet/seeq/sgiseeq.c
@@ -348,7 +348,12 @@ static inline void sgiseeq_rx(struct net
 	/* Service every received packet. */
 	rd = &sp->rx_desc[sp->rx_new];
 	dma_sync_desc_cpu(dev, rd);
-	while (!(rd->rdma.cntinfo & HPCDMA_OWN)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(rd->rdma.cntinfo & HPCDMA_OWN)) {
 		len = PKT_BUF_SZ - (rd->rdma.cntinfo & HPCDMA_BCNT) - 3;
 		dma_unmap_single(dev->dev.parent, rd->rdma.pbuf,
 				 PKT_BUF_SZ, DMA_FROM_DEVICE);
@@ -404,6 +409,12 @@ memory_squeeze:
 		dma_sync_desc_dev(dev, rd);
 		rd = &sp->rx_desc[sp->rx_new];
 		dma_sync_desc_cpu(dev, rd);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	dma_sync_desc_cpu(dev, &sp->rx_desc[orig_end]);
 	sp->rx_desc[orig_end].rdma.cntinfo &= ~(HPCDMA_EOR);
@@ -438,11 +449,22 @@ static inline void kick_tx(struct net_de
 	 */
 	td = &sp->tx_desc[i];
 	dma_sync_desc_cpu(dev, td);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((td->tdma.cntinfo & (HPCDMA_XIU | HPCDMA_ETXD)) ==
 	      (HPCDMA_XIU | HPCDMA_ETXD)) {
 		i = NEXT_TX(i);
 		td = &sp->tx_desc[i];
 		dma_sync_desc_cpu(dev, td);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (td->tdma.cntinfo & HPCDMA_XIU) {
 		hregs->tx_ndptr = VIRT_TO_DMA(sp, td);
@@ -682,11 +704,22 @@ static inline void setup_tx_ring(struct
 	struct sgiseeq_private *sp = netdev_priv(dev);
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < (nbufs - 1)) {
 		buf[i].tdma.pnext = VIRT_TO_DMA(sp, buf + i + 1);
 		buf[i].tdma.pbuf = 0;
 		dma_sync_desc_dev(dev, &buf[i]);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	buf[i].tdma.pnext = VIRT_TO_DMA(sp, buf);
 	dma_sync_desc_dev(dev, &buf[i]);
@@ -699,11 +732,22 @@ static inline void setup_rx_ring(struct
 	struct sgiseeq_private *sp = netdev_priv(dev);
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < (nbufs - 1)) {
 		buf[i].rdma.pnext = VIRT_TO_DMA(sp, buf + i + 1);
 		buf[i].rdma.pbuf = 0;
 		dma_sync_desc_dev(dev, &buf[i]);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	buf[i].rdma.pbuf = 0;
 	buf[i].rdma.pnext = VIRT_TO_DMA(sp, buf);
diff -u -p a/net/ethernet/tile/tilepro.c b/net/ethernet/tile/tilepro.c
--- a/net/ethernet/tile/tilepro.c
+++ b/net/ethernet/tile/tilepro.c
@@ -523,9 +523,20 @@ static unsigned int tile_net_lepp_grab_c
 	unsigned int comp_head = eq->comp_head;
 	unsigned int comp_busy = eq->comp_busy;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (comp_head != comp_busy && n < comps_size) {
 		comps[n++] = eq->comps[comp_head];
 		LEPP_QINC(comp_head);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (n < min_size)
@@ -728,10 +739,21 @@ static void tile_net_discard_packets(str
 	netio_queue_impl_t *qsp = queue->__system_part;
 	netio_queue_user_impl_t *qup = &queue->__user_part;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qup->__packet_receive_read !=
 	       qsp->__packet_receive_queue.__packet_write) {
 		int index = qup->__packet_receive_read;
 		tile_net_discard_aux(info, index);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/realtek/atp.c b/net/ethernet/realtek/atp.c
--- a/net/ethernet/realtek/atp.c
+++ b/net/ethernet/realtek/atp.c
@@ -926,6 +926,11 @@ static int __init atp_init_module(void)
 static void __exit atp_cleanup_module(void) {
 	struct net_device *next_dev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (root_atp_dev) {
 		struct net_local *atp_local = netdev_priv(root_atp_dev);
 		next_dev = atp_local->next_module;
@@ -933,6 +938,12 @@ static void __exit atp_cleanup_module(vo
 		/* No need to release_region(), since we never snarf it. */
 		free_netdev(root_atp_dev);
 		root_atp_dev = next_dev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/realtek/8139cp.c b/net/ethernet/realtek/8139cp.c
--- a/net/ethernet/realtek/8139cp.c
+++ b/net/ethernet/realtek/8139cp.c
@@ -1775,11 +1775,22 @@ static int cp_get_eeprom(struct net_devi
 		offset++;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len - 1) {
 		val = read_eeprom(cp->regs, offset, addr_len);
 		data[i++] = (u8)val;
 		data[i++] = (u8)(val >> 8);
 		offset++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (i < len) {
@@ -1815,11 +1826,22 @@ static int cp_set_eeprom(struct net_devi
 		offset++;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len - 1) {
 		val = (u16)data[i++];
 		val |= (u16)data[i++] << 8;
 		write_eeprom(cp->regs, offset, val, addr_len);
 		offset++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (i < len) {
diff -u -p a/net/ethernet/apple/macmace.c b/net/ethernet/apple/macmace.c
--- a/net/ethernet/apple/macmace.c
+++ b/net/ethernet/apple/macmace.c
@@ -709,10 +709,21 @@ static irqreturn_t mace_dma_intr(int irq
 
 		/* Loop through the ring buffer and process new packages */
 
-		while (mp->rx_tail < head) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (mp->rx_tail < head) {
 			mace_dma_rx_frame(dev, (struct mace_frame*) (mp->rx_ring
 				+ (mp->rx_tail * MACE_BUFF_SIZE)));
 			mp->rx_tail++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		/* If we're out of buffers in this ring then switch to */
diff -u -p a/net/ethernet/apple/mace.c b/net/ethernet/apple/mace.c
--- a/net/ethernet/apple/mace.c
+++ b/net/ethernet/apple/mace.c
@@ -677,6 +677,11 @@ static irqreturn_t mace_interrupt(int ir
     mace_handle_misc_intrs(mp, intr, dev);
 
     i = mp->tx_empty;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (in_8(&mb->pr) & XMTSV) {
 	del_timer(&mp->tx_timeout);
 	mp->timeout_active = 0;
@@ -778,6 +783,12 @@ static irqreturn_t mace_interrupt(int ir
 	mace_last_fs = fs;
 	mace_last_xcount = xcount;
 #endif
+if (_cur < timeout) {
+	    rdstcll(_cur);
+}
+else {
+	    break;
+	}
     }
 
     if (i != mp->tx_empty) {
diff -u -p a/net/ethernet/cisco/enic/enic_main.c b/net/ethernet/cisco/enic/enic_main.c
--- a/net/ethernet/cisco/enic/enic_main.c
+++ b/net/ethernet/cisco/enic/enic_main.c
@@ -696,7 +696,12 @@ static inline void enic_queue_wq_skb_tso
 	/* Queue WQ_ENET_MAX_DESC_LEN length descriptors
 	 * for the main skb fragment
 	 */
-	while (frag_len_left) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (frag_len_left) {
 		len = min(frag_len_left, (unsigned int)WQ_ENET_MAX_DESC_LEN);
 		dma_addr = pci_map_single(enic->pdev, skb->data + offset,
 				len, PCI_DMA_TODEVICE);
@@ -708,6 +713,12 @@ static inline void enic_queue_wq_skb_tso
 			eop && (len == frag_len_left), loopback);
 		frag_len_left -= len;
 		offset += len;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (eop)
@@ -721,7 +732,12 @@ static inline void enic_queue_wq_skb_tso
 		frag_len_left = skb_frag_size(frag);
 		offset = 0;
 
-		while (frag_len_left) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (frag_len_left) {
 			len = min(frag_len_left,
 				(unsigned int)WQ_ENET_MAX_DESC_LEN);
 			dma_addr = skb_frag_dma_map(&enic->pdev->dev, frag,
@@ -735,6 +751,12 @@ static inline void enic_queue_wq_skb_tso
 				loopback);
 			frag_len_left -= len;
 			offset += len;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 }
diff -u -p a/net/ethernet/intel/igb/e1000_nvm.c b/net/ethernet/intel/igb/e1000_nvm.c
--- a/net/ethernet/intel/igb/e1000_nvm.c
+++ b/net/ethernet/intel/igb/e1000_nvm.c
@@ -458,7 +458,12 @@ s32 igb_write_nvm_spi(struct e1000_hw *h
 
 	msleep(10);
 
-	while (widx < words) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (widx < words) {
 		u8 write_opcode = NVM_WRITE_OPCODE_SPI;
 
 		ret_val = igb_ready_nvm_eeprom(hw);
@@ -497,6 +502,12 @@ s32 igb_write_nvm_spi(struct e1000_hw *h
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	msleep(10);
diff -u -p a/net/ethernet/intel/igb/igb_ethtool.c b/net/ethernet/intel/igb/igb_ethtool.c
--- a/net/ethernet/intel/igb/igb_ethtool.c
+++ b/net/ethernet/intel/igb/igb_ethtool.c
@@ -772,9 +772,20 @@ static int igb_set_ringparam(struct net_
 			temp_ring[i].count = new_tx_count;
 			err = igb_setup_tx_resources(&temp_ring[i]);
 			if (err) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (i) {
 					i--;
 					igb_free_tx_resources(&temp_ring[i]);
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
 				}
 				goto err_setup;
 			}
@@ -798,9 +809,20 @@ static int igb_set_ringparam(struct net_
 			temp_ring[i].count = new_rx_count;
 			err = igb_setup_rx_resources(&temp_ring[i]);
 			if (err) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (i) {
 					i--;
 					igb_free_rx_resources(&temp_ring[i]);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 				}
 				goto err_setup;
 			}
@@ -1108,6 +1130,11 @@ static int igb_reg_test(struct igb_adapt
 	/* Perform the remainder of the register test, looping through
 	 * the test table until we either fail or reach the null entry.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (test->reg) {
 		for (i = 0; i < test->array_len; i++) {
 			switch (test->test_type) {
@@ -1146,6 +1173,12 @@ static int igb_reg_test(struct igb_adapt
 			}
 		}
 		test++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*data = 0;
@@ -1584,7 +1617,12 @@ static int igb_clean_test_rings(struct i
 	tx_ntc = tx_ring->next_to_clean;
 	rx_desc = IGB_RX_DESC(rx_ring, rx_ntc);
 
-	while (igb_test_staterr(rx_desc, E1000_RXD_STAT_DD)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (igb_test_staterr(rx_desc, E1000_RXD_STAT_DD)) {
 		/* check rx buffer */
 		rx_buffer_info = &rx_ring->rx_buffer_info[rx_ntc];
 
@@ -1613,6 +1651,12 @@ static int igb_clean_test_rings(struct i
 
 		/* fetch next descriptor */
 		rx_desc = IGB_RX_DESC(rx_ring, rx_ntc);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* re-map buffers to ring, store next to clean values */
diff -u -p a/net/ethernet/intel/igb/igb_main.c b/net/ethernet/intel/igb/igb_main.c
--- a/net/ethernet/intel/igb/igb_main.c
+++ b/net/ethernet/intel/igb/igb_main.c
@@ -4976,6 +4976,11 @@ static int igb_find_enabled_vfs(struct i
 
 	vf_devfn = pdev->devfn + 0x80;
 	pvfdev = pci_get_device(hw->vendor_id, device_id, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pvfdev) {
 		if (pvfdev->devfn == vf_devfn &&
 		    (pvfdev->bus->number >= pdev->bus->number))
@@ -4983,6 +4988,12 @@ static int igb_find_enabled_vfs(struct i
 		vf_devfn += vf_stride;
 		pvfdev = pci_get_device(hw->vendor_id,
 					device_id, pvfdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return vfs_found;
@@ -5758,6 +5769,11 @@ static bool igb_clean_tx_irq(struct igb_
 				 DMA_TO_DEVICE);
 
 		/* clear last DMA location and unmap remaining buffers */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tx_desc != eop_desc) {
 			tx_buffer->dma = 0;
 
@@ -5777,6 +5793,12 @@ static bool igb_clean_tx_irq(struct igb_
 					       tx_buffer->length,
 					       DMA_TO_DEVICE);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* clear last DMA location */
diff -u -p a/net/ethernet/intel/ixgb/ixgb_main.c b/net/ethernet/intel/ixgb/ixgb_main.c
--- a/net/ethernet/intel/ixgb/ixgb_main.c
+++ b/net/ethernet/intel/ixgb/ixgb_main.c
@@ -1353,6 +1353,11 @@ ixgb_tx_map(struct ixgb_adapter *adapter
 
 	i = tx_ring->next_to_use;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		buffer_info = &tx_ring->buffer_info[i];
 		size = min(len, IXGB_MAX_DATA_PER_TXD);
@@ -1380,6 +1385,12 @@ ixgb_tx_map(struct ixgb_adapter *adapter
 			if (i == tx_ring->count)
 				i = 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	for (f = 0; f < nr_frags; f++) {
@@ -1389,6 +1400,11 @@ ixgb_tx_map(struct ixgb_adapter *adapter
 		len = skb_frag_size(frag);
 		offset = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			i++;
 			if (i == tx_ring->count)
@@ -1416,6 +1432,12 @@ ixgb_tx_map(struct ixgb_adapter *adapter
 			len -= size;
 			offset += size;
 			count++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	tx_ring->buffer_info[i].skb = skb;
@@ -1871,6 +1893,11 @@ ixgb_clean_tx_irq(struct ixgb_adapter *a
 	eop = tx_ring->buffer_info[i].next_to_watch;
 	eop_desc = IXGB_TX_DESC(*tx_ring, eop);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (eop_desc->status & IXGB_TX_DESC_STATUS_DD) {
 
 		rmb(); /* read buffer_info after eop_desc */
@@ -1893,6 +1920,12 @@ ixgb_clean_tx_irq(struct ixgb_adapter *a
 
 		eop = tx_ring->buffer_info[i].next_to_watch;
 		eop_desc = IXGB_TX_DESC(*tx_ring, eop);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tx_ring->next_to_clean = i;
diff -u -p a/net/ethernet/intel/ixgbevf/vf.c b/net/ethernet/intel/ixgbevf/vf.c
--- a/net/ethernet/intel/ixgbevf/vf.c
+++ b/net/ethernet/intel/ixgbevf/vf.c
@@ -82,9 +82,20 @@ static s32 ixgbevf_reset_hw_vf(struct ix
 	IXGBE_WRITE_FLUSH(hw);
 
 	/* we cannot reset while the RSTI / RSTD bits are asserted */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!mbx->ops.check_for_rst(hw) && timeout) {
 		timeout--;
 		udelay(5);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!timeout)
diff -u -p a/net/ethernet/intel/ixgbevf/mbx.c b/net/ethernet/intel/ixgbevf/mbx.c
--- a/net/ethernet/intel/ixgbevf/mbx.c
+++ b/net/ethernet/intel/ixgbevf/mbx.c
@@ -38,9 +38,20 @@ static s32 ixgbevf_poll_for_msg(struct i
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
 	int countdown = mbx->timeout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (countdown && mbx->ops.check_for_msg(hw)) {
 		countdown--;
 		udelay(mbx->udelay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if we failed, all future posted messages fail until reset */
@@ -61,9 +72,20 @@ static s32 ixgbevf_poll_for_ack(struct i
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
 	int countdown = mbx->timeout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (countdown && mbx->ops.check_for_ack(hw)) {
 		countdown--;
 		udelay(mbx->udelay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if we failed, all future posted messages fail until reset */
diff -u -p a/net/ethernet/intel/ixgbevf/ethtool.c b/net/ethernet/intel/ixgbevf/ethtool.c
--- a/net/ethernet/intel/ixgbevf/ethtool.c
+++ b/net/ethernet/intel/ixgbevf/ethtool.c
@@ -349,10 +349,21 @@ static int ixgbevf_set_ringparam(struct
 		tx_ring[i].count = new_tx_count;
 		err = ixgbevf_setup_tx_resources(adapter, &tx_ring[i]);
 		if (err) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (i) {
 				i--;
 				ixgbevf_free_tx_resources(adapter,
 							  &tx_ring[i]);
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
+		break;
+				}
 			}
 			goto err_tx_ring_setup;
 		}
@@ -365,11 +376,22 @@ static int ixgbevf_set_ringparam(struct
 		rx_ring[i].count = new_rx_count;
 		err = ixgbevf_setup_rx_resources(adapter, &rx_ring[i]);
 		if (err) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (i) {
 				i--;
 				ixgbevf_free_rx_resources(adapter,
 							  &rx_ring[i]);
-			}
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+				}
 				goto err_rx_ring_setup;
 		}
 		rx_ring[i].v_idx = adapter->rx_ring[i].v_idx;
@@ -569,6 +591,11 @@ static int ixgbevf_reg_test(struct ixgbe
 	 * Perform the register test, looping through the test table
 	 * until we either fail or reach the null entry.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (test->reg) {
 		for (i = 0; i < test->array_len; i++) {
 			switch (test->test_type) {
@@ -605,6 +632,12 @@ static int ixgbevf_reg_test(struct ixgbe
 			}
 		}
 		test++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*data = 0;
diff -u -p a/net/ethernet/intel/ixgbevf/ixgbevf_main.c b/net/ethernet/intel/ixgbevf/ixgbevf_main.c
--- a/net/ethernet/intel/ixgbevf/ixgbevf_main.c
+++ b/net/ethernet/intel/ixgbevf/ixgbevf_main.c
@@ -199,6 +199,11 @@ static bool ixgbevf_clean_tx_irq(struct
 	eop = tx_ring->tx_buffer_info[i].next_to_watch;
 	eop_desc = IXGBE_TX_DESC_ADV(*tx_ring, eop);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((eop_desc->wb.status & cpu_to_le32(IXGBE_TXD_STAT_DD)) &&
 	       (count < tx_ring->work_limit)) {
 		bool cleaned = false;
@@ -238,6 +243,12 @@ static bool ixgbevf_clean_tx_irq(struct
 cont_loop:
 		eop = tx_ring->tx_buffer_info[i].next_to_watch;
 		eop_desc = IXGBE_TX_DESC_ADV(*tx_ring, eop);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	tx_ring->next_to_clean = i;
@@ -2059,12 +2070,23 @@ static int ixgbevf_alloc_q_vectors(struc
 	return 0;
 
 err_out:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q_idx) {
 		q_idx--;
 		q_vector = adapter->q_vector[q_idx];
 		netif_napi_del(&q_vector->napi);
 		kfree(q_vector);
 		adapter->q_vector[q_idx] = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -ENOMEM;
 }
@@ -2888,6 +2910,11 @@ static int ixgbevf_tx_map(struct ixgbevf
 	i = tx_ring->next_to_use;
 
 	len = min(skb_headlen(skb), total);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		tx_buffer_info = &tx_ring->tx_buffer_info[i];
 		size = min(len, (unsigned int)IXGBE_MAX_DATA_PER_TXD);
@@ -2909,6 +2936,12 @@ static int ixgbevf_tx_map(struct ixgbevf
 		i++;
 		if (i == tx_ring->count)
 			i = 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	for (f = 0; f < nr_frags; f++) {
@@ -2918,6 +2951,11 @@ static int ixgbevf_tx_map(struct ixgbevf
 		len = min((unsigned int)skb_frag_size(frag), total);
 		offset = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			tx_buffer_info = &tx_ring->tx_buffer_info[i];
 			size = min(len, (unsigned int)IXGBE_MAX_DATA_PER_TXD);
@@ -2939,6 +2977,12 @@ static int ixgbevf_tx_map(struct ixgbevf
 			i++;
 			if (i == tx_ring->count)
 				i = 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (total == 0)
 			break;
diff -u -p a/net/ethernet/intel/e1000/e1000_hw.c b/net/ethernet/intel/e1000/e1000_hw.c
--- a/net/ethernet/intel/e1000/e1000_hw.c
+++ b/net/ethernet/intel/e1000/e1000_hw.c
@@ -2744,7 +2744,12 @@ static void e1000_shift_out_mdi_bits(str
 	/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
 	ctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);
 
-	while (mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (mask) {
 		/* A "1" is shifted out to the PHY by setting the MDIO bit to "1" and
 		 * then raising and lowering the Management Data Clock. A "0" is
 		 * shifted out to the PHY by setting the MDIO bit to "0" and then
@@ -2764,6 +2769,12 @@ static void e1000_shift_out_mdi_bits(str
 		e1000_lower_mdi_clk(hw, &ctrl);
 
 		mask = mask >> 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4147,7 +4158,12 @@ static s32 e1000_write_eeprom_spi(struct
 
 	e_dbg("e1000_write_eeprom_spi");
 
-	while (widx < words) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (widx < words) {
 		u8 write_opcode = EEPROM_WRITE_OPCODE_SPI;
 
 		if (e1000_spi_eeprom_ready(hw))
@@ -4189,6 +4205,12 @@ static s32 e1000_write_eeprom_spi(struct
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return E1000_SUCCESS;
@@ -4225,7 +4247,12 @@ static s32 e1000_write_eeprom_microwire(
 	/* Prepare the EEPROM */
 	e1000_standby_eeprom(hw);
 
-	while (words_written < words) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (words_written < words) {
 		/* Send the Write command (3-bit opcode + addr) */
 		e1000_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE_MICROWIRE,
 					eeprom->opcode_bits);
@@ -4260,6 +4287,12 @@ static s32 e1000_write_eeprom_microwire(
 		e1000_standby_eeprom(hw);
 
 		words_written++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Send the write disable command to the EEPROM (3-bit opcode plus
diff -u -p a/net/ethernet/intel/e1000/e1000_main.c b/net/ethernet/intel/e1000/e1000_main.c
--- a/net/ethernet/intel/e1000/e1000_main.c
+++ b/net/ethernet/intel/e1000/e1000_main.c
@@ -2845,6 +2845,11 @@ static int e1000_tx_map(struct e1000_ada
 
 	i = tx_ring->next_to_use;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		buffer_info = &tx_ring->buffer_info[i];
 		size = min(len, max_per_txd);
@@ -2897,6 +2902,12 @@ static int e1000_tx_map(struct e1000_ada
 			if (unlikely(i == tx_ring->count))
 				i = 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	for (f = 0; f < nr_frags; f++) {
@@ -2906,6 +2917,11 @@ static int e1000_tx_map(struct e1000_ada
 		len = skb_frag_size(frag);
 		offset = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			unsigned long bufend;
 			i++;
@@ -2941,6 +2957,12 @@ static int e1000_tx_map(struct e1000_ada
 			len -= size;
 			offset += size;
 			count++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -3614,6 +3636,11 @@ static bool e1000_clean_tx_irq(struct e1
 	eop = tx_ring->buffer_info[i].next_to_watch;
 	eop_desc = E1000_TX_DESC(*tx_ring, eop);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&
 	       (count < tx_ring->count)) {
 		bool cleaned = false;
@@ -3635,6 +3662,12 @@ static bool e1000_clean_tx_irq(struct e1
 
 		eop = tx_ring->buffer_info[i].next_to_watch;
 		eop_desc = E1000_TX_DESC(*tx_ring, eop);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tx_ring->next_to_clean = i;
diff -u -p a/net/ethernet/intel/igbvf/vf.c b/net/ethernet/intel/igbvf/vf.c
--- a/net/ethernet/intel/igbvf/vf.c
+++ b/net/ethernet/intel/igbvf/vf.c
@@ -135,9 +135,20 @@ static s32 e1000_reset_hw_vf(struct e100
 	ew32(CTRL, ctrl | E1000_CTRL_RST);
 
 	/* we cannot initialize while the RSTI / RSTD bits are asserted */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!mbx->ops.check_for_rst(hw) && timeout) {
 		timeout--;
 		udelay(5);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout) {
diff -u -p a/net/ethernet/intel/igbvf/mbx.c b/net/ethernet/intel/igbvf/mbx.c
--- a/net/ethernet/intel/igbvf/mbx.c
+++ b/net/ethernet/intel/igbvf/mbx.c
@@ -41,9 +41,20 @@ static s32 e1000_poll_for_msg(struct e10
 	if (!mbx->ops.check_for_msg)
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (countdown && mbx->ops.check_for_msg(hw)) {
 		countdown--;
 		udelay(mbx->usec_delay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if we failed, all future posted messages fail until reset */
@@ -67,9 +78,20 @@ static s32 e1000_poll_for_ack(struct e10
 	if (!mbx->ops.check_for_ack)
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (countdown && mbx->ops.check_for_ack(hw)) {
 		countdown--;
 		udelay(mbx->usec_delay);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if we failed, all future posted messages fail until reset */
diff -u -p a/net/ethernet/intel/igbvf/netdev.c b/net/ethernet/intel/igbvf/netdev.c
--- a/net/ethernet/intel/igbvf/netdev.c
+++ b/net/ethernet/intel/igbvf/netdev.c
@@ -755,6 +755,11 @@ static bool igbvf_clean_tx_irq(struct ig
 	eop = tx_ring->buffer_info[i].next_to_watch;
 	eop_desc = IGBVF_TX_DESC_ADV(*tx_ring, eop);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((eop_desc->wb.status & cpu_to_le32(E1000_TXD_STAT_DD)) &&
 	       (count < tx_ring->count)) {
 		rmb();	/* read buffer_info after eop_desc status */
@@ -785,6 +790,12 @@ static bool igbvf_clean_tx_irq(struct ig
 		}
 		eop = tx_ring->buffer_info[i].next_to_watch;
 		eop_desc = IGBVF_TX_DESC_ADV(*tx_ring, eop);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	tx_ring->next_to_clean = i;
diff -u -p a/net/ethernet/intel/ixgbe/ixgbe_ethtool.c b/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
--- a/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+++ b/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
@@ -975,9 +975,20 @@ static int ixgbe_set_ringparam(struct ne
 			temp_tx_ring[i].count = new_tx_count;
 			err = ixgbe_setup_tx_resources(&temp_tx_ring[i]);
 			if (err) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (i) {
 					i--;
 					ixgbe_free_tx_resources(&temp_tx_ring[i]);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				goto clear_reset;
 			}
@@ -998,9 +1009,20 @@ static int ixgbe_set_ringparam(struct ne
 			temp_rx_ring[i].count = new_rx_count;
 			err = ixgbe_setup_rx_resources(&temp_rx_ring[i]);
 			if (err) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (i) {
 					i--;
 					ixgbe_free_rx_resources(&temp_rx_ring[i]);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 				}
 				goto err_setup;
 			}
@@ -1355,6 +1377,11 @@ static int ixgbe_reg_test(struct ixgbe_a
 	 * Perform the remainder of the register test, looping through
 	 * the test table until we either fail or reach the null entry.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (test->reg) {
 		for (i = 0; i < test->array_len; i++) {
 			switch (test->test_type) {
@@ -1391,6 +1418,12 @@ static int ixgbe_reg_test(struct ixgbe_a
 			}
 		}
 		test++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*data = 0;
@@ -1732,7 +1765,12 @@ static u16 ixgbe_clean_test_rings(struct
 	rx_desc = IXGBE_RX_DESC_ADV(rx_ring, rx_ntc);
 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
 
-	while (staterr & IXGBE_RXD_STAT_DD) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (staterr & IXGBE_RXD_STAT_DD) {
 		/* check Rx buffer */
 		rx_buffer_info = &rx_ring->rx_buffer_info[rx_ntc];
 
@@ -1762,6 +1800,12 @@ static u16 ixgbe_clean_test_rings(struct
 		/* fetch next descriptor */
 		rx_desc = IXGBE_RX_DESC_ADV(rx_ring, rx_ntc);
 		staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* re-map buffers to ring, store next to clean values */
diff -u -p a/net/ethernet/intel/ixgbe/ixgbe_phy.c b/net/ethernet/intel/ixgbe/ixgbe_phy.c
--- a/net/ethernet/intel/ixgbe/ixgbe_phy.c
+++ b/net/ethernet/intel/ixgbe/ixgbe_phy.c
@@ -772,7 +772,12 @@ s32 ixgbe_reset_phy_nl(struct ixgbe_hw *
 
 	ret_val = hw->eeprom.ops.read(hw, data_offset, &block_crc);
 	data_offset++;
-	while (!end_data) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!end_data) {
 		/*
 		 * Read control word from PHY init contents offset
 		 */
@@ -820,7 +825,13 @@ s32 ixgbe_reset_phy_nl(struct ixgbe_hw *
 			ret_val = IXGBE_ERR_PHY;
 			goto out;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	return ret_val;
diff -u -p a/net/ethernet/intel/ixgbe/ixgbe_fcoe.c b/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
--- a/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
+++ b/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
@@ -198,6 +198,11 @@ static int ixgbe_fcoe_ddp_setup(struct n
 	for_each_sg(sgl, sg, dmacount, i) {
 		addr = sg_dma_address(sg);
 		len = sg_dma_len(sg);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			/* max number of buffers allowed in one DDP context */
 			if (j >= IXGBE_BUFFCNT_MAX) {
@@ -230,6 +235,12 @@ static int ixgbe_fcoe_ddp_setup(struct n
 			len -= thislen;
 			addr += thislen;
 			j++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	/* only the last buffer may have non-full bufflen */
diff -u -p a/net/ethernet/intel/ixgbe/ixgbe_sriov.c b/net/ethernet/intel/ixgbe/ixgbe_sriov.c
--- a/net/ethernet/intel/ixgbe/ixgbe_sriov.c
+++ b/net/ethernet/intel/ixgbe/ixgbe_sriov.c
@@ -66,6 +66,11 @@ static int ixgbe_find_enabled_vfs(struct
 
 	vf_devfn = pdev->devfn + 0x80;
 	pvfdev = pci_get_device(IXGBE_INTEL_VENDOR_ID, device_id, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pvfdev) {
 		if (pvfdev->devfn == vf_devfn &&
 		    (pvfdev->bus->number >= pdev->bus->number))
@@ -73,6 +78,12 @@ static int ixgbe_find_enabled_vfs(struct
 		vf_devfn += 2;
 		pvfdev = pci_get_device(IXGBE_INTEL_VENDOR_ID,
 					device_id, pvfdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return vfs_found;
diff -u -p a/net/ethernet/intel/e100.c b/net/ethernet/intel/e100.c
--- a/net/ethernet/intel/e100.c
+++ b/net/ethernet/intel/e100.c
@@ -1815,6 +1815,11 @@ static int e100_tx_clean(struct nic *nic
 static void e100_clean_cbs(struct nic *nic)
 {
 	if (nic->cbs) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (nic->cbs_avail != nic->params.cbs.count) {
 			struct cb *cb = nic->cb_to_clean;
 			if (cb->skb) {
@@ -1826,6 +1831,12 @@ static void e100_clean_cbs(struct nic *n
 			}
 			nic->cb_to_clean = nic->cb_to_clean->next;
 			nic->cbs_avail++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		pci_pool_free(nic->cbs_pool, nic->cbs, nic->cbs_dma_addr);
 		nic->cbs = NULL;
diff -u -p a/net/ethernet/intel/e1000e/lib.c b/net/ethernet/intel/e1000e/lib.c
--- a/net/ethernet/intel/e1000e/lib.c
+++ b/net/ethernet/intel/e1000e/lib.c
@@ -2089,6 +2089,11 @@ s32 e1000e_write_nvm_spi(struct e1000_hw
 	if (ret_val)
 		return ret_val;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (widx < words) {
 		u8 write_opcode = NVM_WRITE_OPCODE_SPI;
 
@@ -2130,6 +2135,12 @@ s32 e1000e_write_nvm_spi(struct e1000_hw
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	usleep_range(10000, 20000);
diff -u -p a/net/ethernet/intel/e1000e/netdev.c b/net/ethernet/intel/e1000e/netdev.c
--- a/net/ethernet/intel/e1000e/netdev.c
+++ b/net/ethernet/intel/e1000e/netdev.c
@@ -4669,6 +4669,11 @@ static int e1000_tx_map(struct e1000_ada
 
 	i = tx_ring->next_to_use;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		buffer_info = &tx_ring->buffer_info[i];
 		size = min(len, max_per_txd);
@@ -4692,6 +4697,12 @@ static int e1000_tx_map(struct e1000_ada
 			if (i == tx_ring->count)
 				i = 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	for (f = 0; f < nr_frags; f++) {
@@ -4701,6 +4712,11 @@ static int e1000_tx_map(struct e1000_ada
 		len = skb_frag_size(frag);
 		offset = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			i++;
 			if (i == tx_ring->count)
@@ -4721,6 +4737,12 @@ static int e1000_tx_map(struct e1000_ada
 			len -= size;
 			offset += size;
 			count++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/ethernet/jme.c b/net/ethernet/jme.c
--- a/net/ethernet/jme.c
+++ b/net/ethernet/jme.c
@@ -1297,11 +1297,22 @@ jme_link_change_tasklet(unsigned long ar
 	struct net_device *netdev = jme->dev;
 	int rc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!atomic_dec_and_test(&jme->link_changing)) {
 		atomic_inc(&jme->link_changing);
 		netif_info(jme, intr, jme->dev, "Get link change lock failed\n");
 		while (atomic_read(&jme->link_changing) != 1)
 			netif_info(jme, intr, jme->dev, "Waiting link change lock\n");
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	if (jme_check_link(netdev, 1) && jme->old_mtu == netdev->mtu)
diff -u -p a/net/ethernet/faraday/ftgmac100.c b/net/ethernet/faraday/ftgmac100.c
--- a/net/ethernet/faraday/ftgmac100.c
+++ b/net/ethernet/faraday/ftgmac100.c
@@ -334,6 +334,11 @@ ftgmac100_rx_locate_first_segment(struct
 {
 	struct ftgmac100_rxdes *rxdes = ftgmac100_current_rxdes(priv);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ftgmac100_rxdes_packet_ready(rxdes)) {
 		if (ftgmac100_rxdes_first_segment(rxdes))
 			return rxdes;
@@ -341,6 +346,12 @@ ftgmac100_rx_locate_first_segment(struct
 		ftgmac100_rxdes_set_dma_own(rxdes);
 		ftgmac100_rx_pointer_advance(priv);
 		rxdes = ftgmac100_current_rxdes(priv);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/net/ethernet/faraday/ftmac100.c b/net/ethernet/faraday/ftmac100.c
--- a/net/ethernet/faraday/ftmac100.c
+++ b/net/ethernet/faraday/ftmac100.c
@@ -315,6 +315,11 @@ ftmac100_rx_locate_first_segment(struct
 {
 	struct ftmac100_rxdes *rxdes = ftmac100_current_rxdes(priv);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!ftmac100_rxdes_owned_by_dma(rxdes)) {
 		if (ftmac100_rxdes_first_segment(rxdes))
 			return rxdes;
@@ -322,6 +327,12 @@ ftmac100_rx_locate_first_segment(struct
 		ftmac100_rxdes_set_dma_own(rxdes);
 		ftmac100_rx_pointer_advance(priv);
 		rxdes = ftmac100_current_rxdes(priv);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/net/ethernet/korina.c b/net/ethernet/korina.c
--- a/net/ethernet/korina.c
+++ b/net/ethernet/korina.c
@@ -532,6 +532,11 @@ static void korina_tx(struct net_device
 	spin_lock(&lp->lock);
 
 	/* Process all desc that are done */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (IS_DMA_FINISHED(td->control)) {
 		if (lp->tx_full == 1) {
 			netif_wake_queue(dev);
@@ -592,6 +597,12 @@ static void korina_tx(struct net_device
 		lp->tx_next_done = (lp->tx_next_done + 1) & KORINA_TDS_MASK;
 		td = &lp->td_ring[lp->tx_next_done];
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Clear the DMA status register */
diff -u -p a/net/ethernet/marvell/mv643xx_eth.c b/net/ethernet/marvell/mv643xx_eth.c
--- a/net/ethernet/marvell/mv643xx_eth.c
+++ b/net/ethernet/marvell/mv643xx_eth.c
@@ -654,6 +654,11 @@ static int rxq_refill(struct rx_queue *r
 	int refilled;
 
 	refilled = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (refilled < budget && rxq->rx_desc_count < rxq->rx_ring_size) {
 		struct sk_buff *skb;
 		int rx;
@@ -697,6 +702,12 @@ static int rxq_refill(struct rx_queue *r
 		 * IP header ends up 16-byte aligned.
 		 */
 		skb_reserve(skb, 2);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (refilled < budget)
diff -u -p a/net/ethernet/marvell/sky2.c b/net/ethernet/marvell/sky2.c
--- a/net/ethernet/marvell/sky2.c
+++ b/net/ethernet/marvell/sky2.c
@@ -3039,11 +3039,22 @@ static int sky2_poll(struct napi_struct
 	if (status & Y2_IS_PHY_QLNK)
 		sky2_qlink_intr(hw);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((idx = sky2_read16(hw, STAT_PUT_IDX)) != hw->st_idx) {
 		work_done += sky2_status_intr(hw, work_limit - work_done, idx);
 
 		if (work_done >= work_limit)
 			goto done;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	napi_complete(napi);
@@ -4246,6 +4257,11 @@ static int sky2_vpd_wait(const struct sk
 {
 	unsigned long start = jiffies;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ( (sky2_pci_read16(hw, cap + PCI_VPD_ADDR) & PCI_VPD_ADDR_F) == busy) {
 		/* Can take up to 10.6 ms for write */
 		if (time_after(jiffies, start + HZ/4)) {
@@ -4253,6 +4269,12 @@ static int sky2_vpd_wait(const struct sk
 			return -ETIMEDOUT;
 		}
 		mdelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c b/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c
@@ -1430,7 +1430,12 @@ static int bnx2x_dcbx_join_pgs(
 		return -EINVAL;
 	}
 
-	while (required_num_of_pg < pg_help_data->num_of_pg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (required_num_of_pg < pg_help_data->num_of_pg) {
 		entry_joined = pg_help_data->num_of_pg - 2;
 		entry_removed = entry_joined + 1;
 		/* protect index */
@@ -1459,6 +1464,12 @@ static int bnx2x_dcbx_join_pgs(
 		}
 		/* Joined the entries */
 		pg_help_data->num_of_pg--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_sp.c b/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
@@ -149,12 +149,23 @@ static inline void __bnx2x_exe_queue_res
 {
 	struct bnx2x_exeq_elem *elem;
 
-	while (!list_empty(&o->pending_comp)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&o->pending_comp)) {
 		elem = list_first_entry(&o->pending_comp,
 					struct bnx2x_exeq_elem, link);
 
 		list_del(&elem->link);
 		bnx2x_exe_queue_free_elem(bp, elem);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_link.c b/net/ethernet/broadcom/bnx2x/bnx2x_link.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_link.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_link.c
@@ -2773,11 +2773,22 @@ static int bnx2x_pbf_update(struct link_
 	crd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);
 	DP(NETIF_MSG_LINK, "init_crd 0x%x  crd 0x%x\n", init_crd, crd);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((init_crd != crd) && count) {
 		msleep(5);
 
 		crd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	crd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);
 	if (init_crd != crd) {
diff -u -p a/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/net/ethernet/broadcom/bnx2x/bnx2x_main.c
--- a/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@ -557,11 +557,22 @@ static void bnx2x_write_dmae_phys_len(st
 	int dmae_wr_max = DMAE_LEN32_WR_MAX(bp);
 	int offset = 0;
 
-	while (len > dmae_wr_max) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len > dmae_wr_max) {
 		bnx2x_write_dmae(bp, phys_addr + offset,
 				 addr + offset, dmae_wr_max);
 		offset += dmae_wr_max * 4;
 		len -= dmae_wr_max;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	bnx2x_write_dmae(bp, phys_addr + offset, addr + offset, len);
@@ -8333,6 +8344,11 @@ static void bnx2x_parity_recover(struct
 	bool global = false;
 
 	DP(NETIF_MSG_HW, "Handling parity\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		switch (bp->recovery_state) {
 		case BNX2X_RECOVERY_INIT:
@@ -8467,6 +8483,12 @@ static void bnx2x_parity_recover(struct
 		default:
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -9491,9 +9513,20 @@ static int __devinit bnx2x_get_hwinfo(st
 			REG_WR(bp, IGU_REG_BLOCK_CONFIGURATION, val);
 			REG_WR(bp, IGU_REG_RESET_MEMORIES, 0x7f);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (tout && REG_RD(bp, IGU_REG_RESET_MEMORIES)) {
 				tout--;
 				usleep_range(1000, 1000);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			if (REG_RD(bp, IGU_REG_RESET_MEMORIES)) {
diff -u -p a/net/ethernet/broadcom/tg3.c b/net/ethernet/broadcom/tg3.c
--- a/net/ethernet/broadcom/tg3.c
+++ b/net/ethernet/broadcom/tg3.c
@@ -5368,6 +5368,11 @@ static void tg3_tx(struct tg3_napi *tnap
 
 	txq = netdev_get_tx_queue(tp->dev, index);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sw_idx != hw_idx) {
 		struct tg3_tx_ring_info *ri = &tnapi->tx_buffers[sw_idx];
 		struct sk_buff *skb = ri->skb;
@@ -5385,10 +5390,21 @@ static void tg3_tx(struct tg3_napi *tnap
 
 		ri->skb = NULL;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ri->fragmented) {
 			ri->fragmented = false;
 			sw_idx = NEXT_TX(sw_idx);
 			ri = &tnapi->tx_buffers[sw_idx];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		sw_idx = NEXT_TX(sw_idx);
@@ -5403,10 +5419,21 @@ static void tg3_tx(struct tg3_napi *tnap
 				       skb_frag_size(&skb_shinfo(skb)->frags[i]),
 				       PCI_DMA_TODEVICE);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (ri->fragmented) {
 				ri->fragmented = false;
 				sw_idx = NEXT_TX(sw_idx);
 				ri = &tnapi->tx_buffers[sw_idx];
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 
 			sw_idx = NEXT_TX(sw_idx);
@@ -5418,6 +5445,12 @@ static void tg3_tx(struct tg3_napi *tnap
 			tg3_tx_recover(tp);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tnapi->tx_cons = sw_idx;
@@ -6556,10 +6589,21 @@ static void tg3_tx_skb_unmap(struct tg3_
 			 skb_headlen(skb),
 			 PCI_DMA_TODEVICE);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (txb->fragmented) {
 		txb->fragmented = false;
 		entry = NEXT_TX(entry);
 		txb = &tnapi->tx_buffers[entry];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i <= last; i++) {
@@ -6572,10 +6616,21 @@ static void tg3_tx_skb_unmap(struct tg3_
 			       dma_unmap_addr(txb, mapping),
 			       skb_frag_size(frag), PCI_DMA_TODEVICE);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (txb->fragmented) {
 			txb->fragmented = false;
 			entry = NEXT_TX(entry);
 			txb = &tnapi->tx_buffers[entry];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -11631,6 +11686,11 @@ static int tg3_run_loopback(struct tg3 *
 		goto out;
 
 	val = data_off;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rx_idx != rx_start_idx) {
 		desc = &rnapi->rx_rcb[rx_start_idx++];
 		desc_idx = desc->opaque & RXD_OPAQUE_INDEX_MASK;
@@ -11678,6 +11738,12 @@ static int tg3_run_loopback(struct tg3 *
 			if (*(rx_skb->data + i) != (u8) (val & 0xff))
 				goto out;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	err = 0;
diff -u -p a/net/ethernet/broadcom/bnx2.c b/net/ethernet/broadcom/bnx2.c
--- a/net/ethernet/broadcom/bnx2.c
+++ b/net/ethernet/broadcom/bnx2.c
@@ -2589,6 +2589,11 @@ bnx2_init_context(struct bnx2 *bp)
 	u32 vcid;
 
 	vcid = 96;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (vcid) {
 		u32 vcid_addr, pcid_addr, offset;
 		int i;
@@ -2623,6 +2628,12 @@ bnx2_init_context(struct bnx2 *bp)
 			for (offset = 0; offset < PHY_CTX_SIZE; offset += 4)
 				bnx2_ctx_wr(bp, vcid_addr, offset, 0);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -2646,7 +2657,12 @@ bnx2_alloc_bad_rbuf(struct bnx2 *bp)
 
 	/* Allocate a bunch of mbufs and save the good ones in an array. */
 	val = bnx2_reg_rd_ind(bp, BNX2_RBUF_STATUS1);
-	while (val & BNX2_RBUF_STATUS1_FREE_COUNT) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (val & BNX2_RBUF_STATUS1_FREE_COUNT) {
 		bnx2_reg_wr_ind(bp, BNX2_RBUF_COMMAND,
 				BNX2_RBUF_COMMAND_ALLOC_REQ);
 
@@ -2661,10 +2677,21 @@ bnx2_alloc_bad_rbuf(struct bnx2 *bp)
 		}
 
 		val = bnx2_reg_rd_ind(bp, BNX2_RBUF_STATUS1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Free the good ones back to the mbuf pool thus discarding
 	 * all the bad ones. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (good_mbuf_cnt) {
 		good_mbuf_cnt--;
 
@@ -2672,6 +2699,12 @@ bnx2_alloc_bad_rbuf(struct bnx2 *bp)
 		val = (val << 9) | val | 1;
 
 		bnx2_reg_wr_ind(bp, BNX2_RBUF_FW_BUF_FREE, val);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(good_mbuf);
 	return 0;
diff -u -p a/net/ethernet/broadcom/cnic.c b/net/ethernet/broadcom/cnic.c
--- a/net/ethernet/broadcom/cnic.c
+++ b/net/ethernet/broadcom/cnic.c
@@ -2658,6 +2658,11 @@ static void service_kcqes(struct cnic_de
 
 	i = 0;
 	j = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num_cqes) {
 		struct cnic_ulp_ops *ulp_ops;
 		int ulp_type;
@@ -2705,6 +2710,12 @@ end:
 		num_cqes -= j;
 		i += j;
 		j = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (unlikely(comp))
 		cnic_spq_completion(dev, DRV_CTL_RET_L5_SPQ_CREDIT_CMD, comp);
@@ -2754,6 +2765,11 @@ static int cnic_l2_completion(struct cni
 		hw_cons++;
 
 	sw_cons = cp->rx_cons;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sw_cons != hw_cons) {
 		u8 cqe_fp_flags;
 
@@ -2767,6 +2783,12 @@ static int cnic_l2_completion(struct cni
 				comp++;
 		}
 		sw_cons = BNX2X_NEXT_RCQE(sw_cons);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return comp;
 }
@@ -2805,6 +2827,11 @@ static u32 cnic_service_bnx2_queues(stru
 	rmb();
 	cp->kwq_con_idx = *cp->kwq_con_idx_ptr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((kcqe_cnt = cnic_get_kcqes(dev, &cp->kcq1))) {
 
 		service_kcqes(dev, kcqe_cnt);
@@ -2815,6 +2842,12 @@ static u32 cnic_service_bnx2_queues(stru
 		/* status block index must be read first */
 		rmb();
 		cp->kwq_con_idx = *cp->kwq_con_idx_ptr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	CNIC_WR16(dev, cp->kcq1.io_addr, cp->kcq1.sw_prod_idx);
@@ -2932,6 +2965,11 @@ static u32 cnic_service_bnx2x_kcq(struct
 
 	/* status block index must be read before reading the KCQ */
 	rmb();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((kcqe_cnt = cnic_get_kcqes(dev, info))) {
 
 		service_kcqes(dev, kcqe_cnt);
@@ -2942,6 +2980,12 @@ static u32 cnic_service_bnx2x_kcq(struct
 		last_status = *info->status_idx_ptr;
 		/* status block index must be read before reading the KCQ */
 		rmb();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return last_status;
 }
@@ -5440,6 +5484,11 @@ static void cnic_release(void)
 	struct cnic_dev *dev;
 	struct cnic_uio_dev *udev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&cnic_dev_list)) {
 		dev = list_entry(cnic_dev_list.next, struct cnic_dev, list);
 		if (test_bit(CNIC_F_CNIC_UP, &dev->flags)) {
@@ -5451,11 +5500,28 @@ static void cnic_release(void)
 		cnic_unregister_netdev(dev);
 		list_del_init(&dev->list);
 		cnic_free_dev(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
-	while (!list_empty(&cnic_udev_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cnic_udev_list)) {
 		udev = list_entry(cnic_udev_list.next, struct cnic_uio_dev,
 				  list);
 		cnic_free_uio(udev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/lantiq_etop.c b/net/ethernet/lantiq_etop.c
--- a/net/ethernet/lantiq_etop.c
+++ b/net/ethernet/lantiq_etop.c
@@ -161,6 +161,11 @@ ltq_etop_poll_rx(struct napi_struct *nap
 	int rx = 0;
 	int complete = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((rx < budget) && !complete) {
 		struct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];
 
@@ -170,6 +175,12 @@ ltq_etop_poll_rx(struct napi_struct *nap
 		} else {
 			complete = 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (complete || !rx) {
 		napi_complete(&ch->napi);
diff -u -p a/net/ethernet/alteon/acenic.c b/net/ethernet/alteon/acenic.c
--- a/net/ethernet/alteon/acenic.c
+++ b/net/ethernet/alteon/acenic.c
@@ -1834,7 +1834,12 @@ static u32 ace_handle_event(struct net_d
 
 	ap = netdev_priv(dev);
 
-	while (evtcsm != evtprd) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (evtcsm != evtprd) {
 		switch (ap->evt_ring[evtcsm].evt) {
 		case E_FW_RUNNING:
 			printk(KERN_INFO "%s: Firmware up and running\n",
@@ -1927,6 +1932,12 @@ static u32 ace_handle_event(struct net_d
 			       ap->name, ap->evt_ring[evtcsm].evt);
 		}
 		evtcsm = (evtcsm + 1) % EVT_RING_ENTRIES;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return evtcsm;
@@ -1944,6 +1955,11 @@ static void ace_rx_int(struct net_device
 	prefetchw(&ap->cur_rx_bufs);
 	prefetchw(&ap->cur_mini_bufs);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (idx != rxretprd) {
 		struct ring_info *rip;
 		struct sk_buff *skb;
@@ -2030,6 +2046,12 @@ static void ace_rx_int(struct net_device
 		dev->stats.rx_bytes += retdesc->size;
 
 		idx = (idx + 1) % RX_RETURN_RING_ENTRIES;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	atomic_sub(std_count, &ap->cur_rx_bufs);
diff -u -p a/net/ethernet/cirrus/mac89x0.c b/net/ethernet/cirrus/mac89x0.c
--- a/net/ethernet/cirrus/mac89x0.c
+++ b/net/ethernet/cirrus/mac89x0.c
@@ -435,6 +435,11 @@ static irqreturn_t net_interrupt(int irq
            course, if you're on a slow machine, and packets are arriving
            faster than you can read them off, you're screwed.  Hasta la
            vista, baby!  */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = swab16(nubus_readw(dev->base_addr + ISQ_PORT)))) {
 		if (net_debug > 4)printk("%s: event=%04x\n", dev->name, status);
 		switch(status & ISQ_EVENT_MASK) {
@@ -479,6 +484,12 @@ static irqreturn_t net_interrupt(int irq
 			dev->stats.collisions += (status >> 6);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return IRQ_HANDLED;
 }
diff -u -p a/net/ethernet/cirrus/cs89x0.c b/net/ethernet/cirrus/cs89x0.c
--- a/net/ethernet/cirrus/cs89x0.c
+++ b/net/ethernet/cirrus/cs89x0.c
@@ -1507,6 +1507,11 @@ static irqreturn_t net_interrupt(int irq
            course, if you're on a slow machine, and packets are arriving
            faster than you can read them off, you're screwed.  Hasta la
            vista, baby!  */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = readword(dev->base_addr, ISQ_PORT))) {
 		if (net_debug > 4)printk("%s: event=%04x\n", dev->name, status);
 		handled = 1;
@@ -1559,6 +1564,11 @@ static irqreturn_t net_interrupt(int irq
 #if ALLOW_DMA
 			if (lp->use_dma && (status & RX_DMA)) {
 				int count = readreg(dev, PP_DmaFrameCnt);
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while(count) {
 					if (net_debug > 5)
 						printk("%s: receiving %d DMA frames\n", dev->name, count);
@@ -1569,6 +1579,12 @@ static irqreturn_t net_interrupt(int irq
 						count = readreg(dev, PP_DmaFrameCnt);
 					if (net_debug > 2 && count > 0)
 						printk("%s: continuing with %d DMA frames\n", dev->name, count);
+						if (_cur < timeout) {
+										rdstcll(_cur);
+						}
+						else {
+										break;
+						}
 				}
 			}
 #endif
@@ -1580,6 +1596,12 @@ static irqreturn_t net_interrupt(int irq
 			dev->stats.collisions += (status >> 6);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return IRQ_RETVAL(handled);
 }
diff -u -p a/net/ethernet/natsemi/ns83820.c b/net/ethernet/natsemi/ns83820.c
--- a/net/ethernet/natsemi/ns83820.c
+++ b/net/ethernet/natsemi/ns83820.c
@@ -979,6 +979,11 @@ static void do_tx_done(struct net_device
 
 	dprintk("tx_done_idx=%d free_idx=%d cmdsts=%08x\n",
 		tx_done_idx, dev->tx_free_idx, le32_to_cpu(desc[DESC_CMDSTS]));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((tx_done_idx != dev->tx_free_idx) &&
 	       !(CMDSTS_OWN & (cmdsts = le32_to_cpu(desc[DESC_CMDSTS]))) ) {
 		struct sk_buff *skb;
@@ -1018,6 +1023,12 @@ static void do_tx_done(struct net_device
 		desc[DESC_CMDSTS] = cpu_to_le32(0);
 		mb();
 		desc = dev->tx_descs + (tx_done_idx * DESC_SIZE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Allow network stack to resume queueing packets after we've
diff -u -p a/net/ethernet/natsemi/ibmlana.c b/net/ethernet/natsemi/ibmlana.c
--- a/net/ethernet/natsemi/ibmlana.c
+++ b/net/ethernet/natsemi/ibmlana.c
@@ -845,9 +845,20 @@ static netdev_tx_t ibmlana_tx(struct sk_
 		char *fill = "NetBSD is a nice OS too! ";
 		unsigned int destoffs = skb->len, l = strlen(fill);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (destoffs < tmplen) {
 			memcpy_toio(priv->base + baddr + destoffs, fill, l);
 			destoffs += l;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/ethernet/i825xx/lp486e.c b/net/ethernet/i825xx/lp486e.c
--- a/net/ethernet/i825xx/lp486e.c
+++ b/net/ethernet/i825xx/lp486e.c
@@ -391,7 +391,12 @@ i596_timeout(struct net_device *dev, cha
 	int boguscnt = ct;
 
 	lp = netdev_priv(dev);
-	while (lp->scb.command) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (lp->scb.command) {
 		if (--boguscnt == 0) {
 			printk("%s: %s timed out - stat %4.4x, cmd %4.4x\n",
 			       dev->name, msg,
@@ -400,6 +405,12 @@ i596_timeout(struct net_device *dev, cha
 		}
 		udelay(5);
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -600,7 +611,12 @@ i596_scp_setup(struct net_device *dev) {
 	 * The ISCP busy is cleared by the 82596 after the SCB address is read.
 	 */
 	boguscnt = 100;
-	while (lp->iscp.busy) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (lp->iscp.busy) {
 		if (--boguscnt == 0) {
 			/* No i82596 present? */
 			printk("%s: i82596 initialization timed out\n",
@@ -609,6 +625,12 @@ i596_scp_setup(struct net_device *dev) {
 		}
 		udelay(5);
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* I find here boguscnt==100, so no delay was required. */
 
@@ -738,6 +760,11 @@ i596_cleanup_cmd(struct net_device *dev)
 	struct i596_cmd *cmd;
 
 	lp = netdev_priv(dev);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lp->cmd_head) {
 		cmd = (struct i596_cmd *)lp->cmd_head;
 
@@ -773,6 +800,12 @@ i596_cleanup_cmd(struct net_device *dev)
 			}
 		}
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (lp->scb.command && i596_timeout(dev, "i596_cleanup_cmd", 100))
@@ -1052,6 +1085,11 @@ i596_handle_CU_completion(struct net_dev
 	spin_lock_irqsave(&lp->cmd_lock, flags);
 	cmd = lp->cmd_head;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lp->cmd_head && (lp->cmd_head->status & CMD_STAT_C)) {
 		cmd = lp->cmd_head;
 
@@ -1132,13 +1170,30 @@ i596_handle_CU_completion(struct net_dev
 
 		}
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	cmd = lp->cmd_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cmd && (cmd != lp->cmd_tail)) {
 		cmd->command &= 0x1fff;
 		cmd = pa_to_va(cmd->pa_next);
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (lp->cmd_head)
diff -u -p a/net/ethernet/i825xx/lib82596.c b/net/ethernet/i825xx/lib82596.c
--- a/net/ethernet/i825xx/lib82596.c
+++ b/net/ethernet/i825xx/lib82596.c
@@ -661,6 +661,11 @@ static inline int i596_rx(struct net_dev
 	rfd = lp->rfd_head;		/* Ref next frame to check */
 
 	DMA_INV(dev, rfd, sizeof(struct i596_rfd));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rfd->stat & SWAP16(STAT_C)) {	/* Loop while complete frames */
 		if (rfd->rbd == I596_NULL)
 			rbd = NULL;
@@ -789,6 +794,12 @@ memory_squeeze:
 		DMA_WBACK_INV(dev, rfd->v_prev, sizeof(struct i596_rfd));
 		rfd = lp->rfd_head;
 		DMA_INV(dev, rfd, sizeof(struct i596_rfd));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DEB(DEB_RXFRAME, printk(KERN_DEBUG "frames %d\n", frames));
diff -u -p a/net/ethernet/i825xx/3c527.c b/net/ethernet/i825xx/3c527.c
--- a/net/ethernet/i825xx/3c527.c
+++ b/net/ethernet/i825xx/3c527.c
@@ -487,6 +487,11 @@ static int __init mc32_probe1(struct net
 	{
 		int n=0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(!(inb(dev->base_addr+2)&(1<<5)))
 		{
 			n++;
@@ -497,6 +502,12 @@ static int __init mc32_probe1(struct net
 				err = -ENODEV;
 				goto err_exit_irq;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		base|=(inb(dev->base_addr)<<(8*i));
diff -u -p a/net/ethernet/i825xx/eexpress.c b/net/ethernet/i825xx/eexpress.c
--- a/net/ethernet/i825xx/eexpress.c
+++ b/net/ethernet/i825xx/eexpress.c
@@ -555,6 +555,11 @@ static void unstick_cu(struct net_device
 				scb_wrcbl(dev, lp->tx_link);
 				scb_command(dev, SCB_CUstart);
 				outb(0,ioaddr+SIGNAL_CA);
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (!SCB_complete(rsst=scb_status(dev)))
 				{
 					if (!--boguscount)
@@ -566,6 +571,12 @@ static void unstick_cu(struct net_device
 						scb_command(dev, SCB_CUstart);
 						outb(0,ioaddr+SIGNAL_CA);
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				netif_wake_queue(dev);
 			}
@@ -1316,6 +1327,11 @@ static void eexp_hw_txrestart(struct net
 
 	{
 		unsigned short boguscount=50,failcount=5;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!scb_status(dev))
 		{
 			if (!--boguscount)
@@ -1336,6 +1352,12 @@ static void eexp_hw_txrestart(struct net
 					return;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -1516,6 +1538,11 @@ static void eexp_hw_init586(struct net_d
 
 	{
 		unsigned short rboguscount=50,rfailcount=5;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (inw(ioaddr+0x4000))
 		{
 			if (!--rboguscount)
@@ -1532,6 +1559,12 @@ static void eexp_hw_init586(struct net_d
 					return;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1541,6 +1574,11 @@ static void eexp_hw_init586(struct net_d
 
 	{
 		unsigned short iboguscount=50,ifailcount=5;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!scb_status(dev))
 		{
 			if (!--iboguscount)
@@ -1560,6 +1598,12 @@ static void eexp_hw_init586(struct net_d
 					return;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/ethernet/i825xx/82596.c b/net/ethernet/i825xx/82596.c
--- a/net/ethernet/i825xx/82596.c
+++ b/net/ethernet/i825xx/82596.c
@@ -780,6 +780,11 @@ static inline int i596_rx(struct net_dev
 
 	rfd = lp->rfd_head;		/* Ref next frame to check */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((rfd->stat) & STAT_C) {	/* Loop while complete frames */
 		if (rfd->rbd == I596_NULL)
 			rbd = I596_NULL;
@@ -894,6 +899,12 @@ memory_squeeze:
 		lp->scb.rfd = rfd->b_next;
 		lp->rfd_head = rfd->v_next;
 		rfd = lp->rfd_head;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DEB(DEB_RXFRAME,printk(KERN_DEBUG "frames %d\n", frames));
diff -u -p a/net/ethernet/dnet.c b/net/ethernet/dnet.c
--- a/net/ethernet/dnet.c
+++ b/net/ethernet/dnet.c
@@ -400,6 +400,11 @@ static int dnet_poll(struct napi_struct
 	u32 cmd_word;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (npackets < budget) {
 		/*
 		 * break out of while loop if there are no more
@@ -438,6 +443,12 @@ static int dnet_poll(struct napi_struct
 			printk(KERN_NOTICE
 			       "%s: No memory to allocate a sk_buff of "
 			       "size %u.\n", dev->name, pkt_len);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	budget -= npackets;
diff -u -p a/net/ethernet/emulex/benet/be_cmds.c b/net/ethernet/emulex/benet/be_cmds.c
--- a/net/ethernet/emulex/benet/be_cmds.c
+++ b/net/ethernet/emulex/benet/be_cmds.c
@@ -238,6 +238,11 @@ int be_process_mcc(struct be_adapter *ad
 	struct be_mcc_obj *mcc_obj = &adapter->mcc_obj;
 
 	spin_lock_bh(&adapter->mcc_cq_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((compl = be_mcc_compl_get(adapter))) {
 		if (compl->flags & CQE_FLAGS_ASYNC_MASK) {
 			/* Interpret flags as an async trailer */
@@ -253,6 +258,12 @@ int be_process_mcc(struct be_adapter *ad
 		}
 		be_mcc_compl_use(compl);
 		num++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	spin_unlock_bh(&adapter->mcc_cq_lock);
@@ -1362,6 +1373,11 @@ void be_cmd_get_regs(struct be_adapter *
 
 	spin_lock_bh(&adapter->mcc_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (total_size) {
 		buf_size = min(total_size, (u32)60*1024);
 		total_size -= buf_size;
@@ -1395,7 +1411,13 @@ void be_cmd_get_regs(struct be_adapter *
 		}
 		offset += buf_size;
 		log_offset += buf_size;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 err:
 	pci_free_consistent(adapter->pdev, get_fat_cmd.size,
 			get_fat_cmd.va,
diff -u -p a/net/ethernet/emulex/benet/be_main.c b/net/ethernet/emulex/benet/be_main.c
--- a/net/ethernet/emulex/benet/be_main.c
+++ b/net/ethernet/emulex/benet/be_main.c
@@ -672,12 +672,23 @@ static int make_tx_wrbs(struct be_adapte
 	return copied;
 dma_err:
 	txq->head = map_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (copied) {
 		wrb = queue_head_node(txq);
 		unmap_tx_frag(dev, wrb, map_single);
 		map_single = false;
 		copied -= wrb->frag_len;
 		queue_head_inc(txq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1531,11 +1542,22 @@ static void be_tx_compl_clean(struct be_
 
 	/* Wait for a max of 200ms for all the tx-completions to arrive. */
 	do {
-		while ((txcp = be_tx_compl_get(tx_cq))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((txcp = be_tx_compl_get(tx_cq))) {
 			end_idx = AMAP_GET_BITS(struct amap_eth_tx_compl,
 					wrb_index, txcp);
 			num_wrbs += be_tx_compl_process(adapter, txo, end_idx);
 			cmpl++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if (cmpl) {
 			be_cq_notify(adapter, tx_cq->id, false, cmpl);
@@ -1555,7 +1577,12 @@ static void be_tx_compl_clean(struct be_
 			atomic_read(&txq->used));
 
 	/* free posted tx for which compls will never arrive */
-	while (atomic_read(&txq->used)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (atomic_read(&txq->used)) {
 		sent_skb = sent_skbs[txq->tail];
 		end_idx = txq->tail;
 		index_adv(&end_idx,
@@ -1563,6 +1590,12 @@ static void be_tx_compl_clean(struct be_
 			txq->len);
 		num_wrbs = be_tx_compl_process(adapter, txo, end_idx);
 		atomic_sub(num_wrbs, &txq->used);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1939,11 +1972,22 @@ static int be_poll_tx_mcc(struct napi_st
 	for_all_tx_queues(adapter, txo, i) {
 		tx_compl = 0;
 		num_wrbs = 0;
-		while ((txcp = be_tx_compl_get(&txo->cq))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((txcp = be_tx_compl_get(&txo->cq))) {
 			num_wrbs += be_tx_compl_process(adapter, txo,
 				AMAP_GET_BITS(struct amap_eth_tx_compl,
 					wrb_index, txcp));
 			tx_compl++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if (tx_compl) {
 			be_cq_notify(adapter, txo->cq.id, true, tx_compl);
diff -u -p a/net/ethernet/freescale/gianfar.c b/net/ethernet/freescale/gianfar.c
--- a/net/ethernet/freescale/gianfar.c
+++ b/net/ethernet/freescale/gianfar.c
@@ -2843,6 +2843,11 @@ static int gfar_poll(struct napi_struct
 	 * because of the packets that have already arrived */
 	gfar_write(&regs->ievent, IEVENT_RTX_MASK);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num_queues && left_over_budget) {
 
 		budget_per_queue = left_over_budget/num_queues;
@@ -2865,6 +2870,12 @@ static int gfar_poll(struct napi_struct
 				num_queues--;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (tx_cleaned)
diff -u -p a/net/ethernet/freescale/fec.c b/net/ethernet/freescale/fec.c
--- a/net/ethernet/freescale/fec.c
+++ b/net/ethernet/freescale/fec.c
@@ -649,6 +649,11 @@ fec_enet_rx(struct net_device *ndev)
 	 */
 	bdp = fep->cur_rx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) {
 
 		/* Since we have allocated space to hold a complete frame,
@@ -738,6 +743,12 @@ rx_processing_done:
 		 * able to keep up at the expense of system resources.
 		 */
 		writel(0, fep->hwp + FEC_R_DES_ACTIVE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	fep->cur_rx = bdp;
 
diff -u -p a/net/ethernet/freescale/fec_mpc52xx.c b/net/ethernet/freescale/fec_mpc52xx.c
--- a/net/ethernet/freescale/fec_mpc52xx.c
+++ b/net/ethernet/freescale/fec_mpc52xx.c
@@ -131,7 +131,12 @@ static int mpc52xx_fec_set_mac_address(s
 
 static void mpc52xx_fec_free_rx_buffers(struct net_device *dev, struct bcom_task *s)
 {
-	while (!bcom_queue_empty(s)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!bcom_queue_empty(s)) {
 		struct bcom_fec_bd *bd;
 		struct sk_buff *skb;
 
@@ -139,6 +144,12 @@ static void mpc52xx_fec_free_rx_buffers(
 		dma_unmap_single(dev->dev.parent, bd->skb_pa, skb->len,
 				 DMA_FROM_DEVICE);
 		kfree_skb(skb);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -159,6 +170,11 @@ static int mpc52xx_fec_alloc_rx_buffers(
 {
 	struct sk_buff *skb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!bcom_queue_full(rxtsk)) {
 		skb = dev_alloc_skb(FEC_RX_BUFFER_SIZE);
 		if (!skb)
@@ -167,6 +183,12 @@ static int mpc52xx_fec_alloc_rx_buffers(
 		/* zero out the initial receive buffers to aid debugging */
 		memset(skb->data, 0, FEC_RX_BUFFER_SIZE);
 		mpc52xx_fec_rx_submit(dev, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -371,7 +393,12 @@ static irqreturn_t mpc52xx_fec_tx_interr
 	struct mpc52xx_fec_priv *priv = netdev_priv(dev);
 
 	spin_lock(&priv->lock);
-	while (bcom_buffer_done(priv->tx_dmatsk)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (bcom_buffer_done(priv->tx_dmatsk)) {
 		struct sk_buff *skb;
 		struct bcom_fec_bd *bd;
 		skb = bcom_retrieve_buffer(priv->tx_dmatsk, NULL,
@@ -380,6 +407,12 @@ static irqreturn_t mpc52xx_fec_tx_interr
 				 DMA_TO_DEVICE);
 
 		dev_kfree_skb_irq(skb);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock(&priv->lock);
 
@@ -400,7 +433,12 @@ static irqreturn_t mpc52xx_fec_rx_interr
 
 	spin_lock(&priv->lock);
 
-	while (bcom_buffer_done(priv->rx_dmatsk)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bcom_buffer_done(priv->rx_dmatsk)) {
 
 		rskb = bcom_retrieve_buffer(priv->rx_dmatsk, &status,
 					    (struct bcom_bd **)&bd);
@@ -441,6 +479,12 @@ static irqreturn_t mpc52xx_fec_rx_interr
 			netif_rx(rskb);
 
 		spin_lock(&priv->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock(&priv->lock);
diff -u -p a/net/ethernet/freescale/gianfar_ethtool.c b/net/ethernet/freescale/gianfar_ethtool.c
--- a/net/ethernet/freescale/gianfar_ethtool.c
+++ b/net/ethernet/freescale/gianfar_ethtool.c
@@ -1181,16 +1181,38 @@ static int gfar_trim_filer_entries(u32 b
 	length = end - begin;
 
 	/* Copy */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (end < tab->index) {
 		tab->fe[begin].ctrl = tab->fe[end].ctrl;
 		tab->fe[begin++].prop = tab->fe[end++].prop;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Fill up with don't cares */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (begin < tab->index) {
 		tab->fe[begin].ctrl = 0x60;
 		tab->fe[begin].prop = 0xFFFFFFFF;
 		begin++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tab->index -= length;
diff -u -p a/net/ethernet/icplus/ipg.c b/net/ethernet/icplus/ipg.c
--- a/net/ethernet/icplus/ipg.c
+++ b/net/ethernet/icplus/ipg.c
@@ -432,10 +432,21 @@ static int ipg_reset(struct net_device *
 	/* Delay added to account for problem with 10Mbps reset. */
 	mdelay(IPG_AC_RESETWAIT);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (IPG_AC_RESET_BUSY & ipg_r32(ASIC_CTRL)) {
 		mdelay(IPG_AC_RESETWAIT);
 		if (++timeout_count > IPG_AC_RESET_TIMEOUT)
 			return -ETIME;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	/* Set LED Mode in Asic Control */
 	ipg_set_led_mode(dev);
@@ -1506,7 +1517,12 @@ static int ipg_nic_rx(struct net_device
 	if (!i)
 		sp->EmptyRFDListCount++;
 #endif
-	while ((le64_to_cpu(rxfd->rfs) & IPG_RFS_RFDDONE) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((le64_to_cpu(rxfd->rfs) & IPG_RFS_RFDDONE) &&
 	       !((le64_to_cpu(rxfd->rfs) & IPG_RFS_FRAMESTART) &&
 		 (le64_to_cpu(rxfd->rfs) & IPG_RFS_FRAMEEND))) {
 		unsigned int entry = curr++ % IPG_RFDLIST_LENGTH;
@@ -1533,6 +1549,12 @@ static int ipg_nic_rx(struct net_device
 
 		/* Assure RX buffer is not reused by IPG. */
 		sp->rx_buff[entry] = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sp->rx_current = curr;
diff -u -p a/net/ethernet/toshiba/tc35815.c b/net/ethernet/toshiba/tc35815.c
--- a/net/ethernet/toshiba/tc35815.c
+++ b/net/ethernet/toshiba/tc35815.c
@@ -510,10 +510,21 @@ static int tc_mdio_read(struct mii_bus *
 
 	tc_writel(MD_CA_Busy | (mii_id << 5) | (regnum & 0x1f), &tr->MD_CA);
 	udelay(12); /* it takes 32 x 400ns at least */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tc_readl(&tr->MD_CA) & MD_CA_Busy) {
 		if (time_after(jiffies, timeout))
 			return -EIO;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return tc_readl(&tr->MD_Data) & 0xffff;
 }
@@ -529,10 +540,21 @@ static int tc_mdio_write(struct mii_bus
 	tc_writel(MD_CA_Busy | MD_CA_Wr | (mii_id << 5) | (regnum & 0x1f),
 		  &tr->MD_CA);
 	udelay(12); /* it takes 32 x 400ns at least */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tc_readl(&tr->MD_CA) & MD_CA_Busy) {
 		if (time_after(jiffies, timeout))
 			return -EIO;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/toshiba/ps3_gelic_wireless.c b/net/ethernet/toshiba/ps3_gelic_wireless.c
--- a/net/ethernet/toshiba/ps3_gelic_wireless.c
+++ b/net/ethernet/toshiba/ps3_gelic_wireless.c
@@ -615,7 +615,12 @@ static char *gelic_wl_translate_scan(str
 	j = 0;
 	pr_debug("%s: rates=%d rate=%d\n", __func__,
 		 network->rate_len, network->rate_ext_len);
-	while (i < network->rate_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < network->rate_len) {
 		if (j < network->rate_ext_len &&
 		    ((scan->ext_rate[j] & 0x7f) < (scan->rate[i] & 0x7f)))
 		    rate = scan->ext_rate[j++] & 0x7f;
@@ -624,11 +629,28 @@ static char *gelic_wl_translate_scan(str
 		iwe.u.bitrate.value = rate * 500000; /* 500kbps unit */
 		tmp = iwe_stream_add_value(info, ev, tmp, stop, &iwe,
 					   IW_EV_PARAM_LEN);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j < network->rate_ext_len) {
 		iwe.u.bitrate.value = (scan->ext_rate[j++] & 0x7f) * 500000;
 		tmp = iwe_stream_add_value(info, ev, tmp, stop, &iwe,
 					   IW_EV_PARAM_LEN);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 	/* Check if we added any rate */
 	if (iwe_stream_lcp_len(info) < (tmp - ev))
@@ -2151,7 +2173,12 @@ static void gelic_wl_event_worker(struct
 	pr_debug("%s:start\n", __func__);
 	wl = container_of(work, struct gelic_wl_info, event_work.work);
 	port = wl_port(wl);
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		status = lv1_net_control(bus_id(port->card), dev_id(port->card),
 					 GELIC_LV1_GET_WLAN_EVENT, 0, 0, 0,
 					 &event, &tmp);
@@ -2179,6 +2206,12 @@ static void gelic_wl_event_worker(struct
 		default:
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} /* while */
 }
 /*
diff -u -p a/net/ethernet/toshiba/spider_net.c b/net/ethernet/toshiba/spider_net.c
--- a/net/ethernet/toshiba/spider_net.c
+++ b/net/ethernet/toshiba/spider_net.c
@@ -805,6 +805,11 @@ spider_net_release_tx_chain(struct spide
 	unsigned long flags;
 	int status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		spin_lock_irqsave(&chain->lock, flags);
 		if (chain->tail == chain->head) {
@@ -861,6 +866,12 @@ spider_net_release_tx_chain(struct spide
 					PCI_DMA_TODEVICE);
 			dev_kfree_skb(skb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1798,9 +1809,20 @@ spider_net_enable_card(struct spider_net
 	};
 
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (regs[i][0]) {
 		spider_net_write_reg(card, regs[i][0], regs[i][1]);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* clear unicast filter table entries 1 to 14 */
diff -u -p a/net/ethernet/micrel/ks8695net.c b/net/ethernet/micrel/ks8695net.c
--- a/net/ethernet/micrel/ks8695net.c
+++ b/net/ethernet/micrel/ks8695net.c
@@ -466,7 +466,12 @@ static int ks8695_rx(struct ks8695_priv
 	int received = 0;
 
 	buff_n = ksp->next_rx_desc_read;
-	while (received < budget
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (received < budget
 			&& ksp->rx_buffers[buff_n].skb
 			&& (!(ksp->rx_ring[buff_n].status &
 					cpu_to_le32(RDES_OWN)))) {
@@ -536,6 +541,12 @@ rx_failure:
 rx_finished:
 			received++;
 			buff_n = (buff_n + 1) & MAX_RX_DESC_MASK;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* And note which RX descriptor we last did */
diff -u -p a/net/ethernet/micrel/ks8842.c b/net/ethernet/micrel/ks8842.c
--- a/net/ethernet/micrel/ks8842.c
+++ b/net/ethernet/micrel/ks8842.c
@@ -709,9 +709,20 @@ void ks8842_handle_rx(struct net_device
 {
 	u16 rx_data = ks8842_read16(adapter, 16, REG_RXMIR) & 0x1fff;
 	netdev_dbg(netdev, "%s Entry - rx_data: %d\n", __func__, rx_data);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rx_data) {
 		ks8842_rx_frame(netdev, adapter);
 		rx_data = ks8842_read16(adapter, 16, REG_RXMIR) & 0x1fff;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/micrel/ks8851.c b/net/ethernet/micrel/ks8851.c
--- a/net/ethernet/micrel/ks8851.c
+++ b/net/ethernet/micrel/ks8851.c
@@ -721,6 +721,11 @@ static void ks8851_tx_work(struct work_s
 
 	mutex_lock(&ks->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!last) {
 		txb = skb_dequeue(&ks->txq);
 		last = skb_queue_empty(&ks->txq);
@@ -733,6 +738,12 @@ static void ks8851_tx_work(struct work_s
 
 			ks8851_done_tx(ks, txb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&ks->lock);
@@ -872,13 +883,24 @@ static int ks8851_net_stop(struct net_de
 	ks8851_set_powermode(ks, PMECR_PM_SOFTDOWN);
 
 	/* ensure any queued tx buffers are dumped */
-	while (!skb_queue_empty(&ks->txq)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!skb_queue_empty(&ks->txq)) {
 		struct sk_buff *txb = skb_dequeue(&ks->txq);
 
 		netif_dbg(ks, ifdown, ks->netdev,
 			  "%s: freeing txb %p\n", __func__, txb);
 
 		dev_kfree_skb(txb);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	mutex_unlock(&ks->lock);
diff -u -p a/net/ethernet/micrel/ksz884x.c b/net/ethernet/micrel/ksz884x.c
--- a/net/ethernet/micrel/ksz884x.c
+++ b/net/ethernet/micrel/ksz884x.c
@@ -3823,15 +3823,37 @@ static void ksz_check_desc_num(struct ks
 	int shift;
 
 	shift = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(alloc & 1)) {
 		shift++;
 		alloc >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (alloc != 1 || shift < MIN_DESC_SHIFT) {
 		pr_alert("Hardware descriptor numbers not right!\n");
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (alloc) {
 			shift++;
 			alloc >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (shift < MIN_DESC_SHIFT)
 			shift = MIN_DESC_SHIFT;
@@ -4522,9 +4544,20 @@ static int ksz_alloc_mem(struct dev_info
 	hw->tx_int_mask = NUM_OF_TX_DESC / 4;
 	if (hw->tx_int_mask > 8)
 		hw->tx_int_mask = 8;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hw->tx_int_mask) {
 		hw->tx_int_cnt++;
 		hw->tx_int_mask >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (hw->tx_int_cnt) {
 		hw->tx_int_mask = (1 << (hw->tx_int_cnt - 1)) - 1;
@@ -6124,9 +6157,20 @@ static int netdev_get_regs_len(struct ne
 	struct hw_regs *range = hw_regs_range;
 	int regs_len = 0x10 * sizeof(u32);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (range->end > range->start) {
 		regs_len += (range->end - range->start + 3) / 4 * 4;
 		range++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return regs_len;
 }
@@ -6155,12 +6199,23 @@ static void netdev_get_regs(struct net_d
 		pci_read_config_dword(hw_priv->pdev, len, buf);
 		buf++;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (range->end > range->start) {
 		for (len = range->start; len < range->end; len += 4) {
 			*buf = readl(hw->io + len);
 			buf++;
 		}
 		range++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&hw_priv->lock);
 }
diff -u -p a/net/ethernet/octeon/octeon_mgmt.c b/net/ethernet/octeon/octeon_mgmt.c
--- a/net/ethernet/octeon/octeon_mgmt.c
+++ b/net/ethernet/octeon/octeon_mgmt.c
@@ -393,6 +393,11 @@ static int octeon_mgmt_receive_packets(s
 	int rc;
 
 	mix_ircnt.u64 = cvmx_read_csr(CVMX_MIXX_IRCNT(port));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (work_done < budget && mix_ircnt.s.ircnt) {
 
 		rc = octeon_mgmt_receive_one(p);
@@ -401,6 +406,12 @@ static int octeon_mgmt_receive_packets(s
 
 		/* Check for more packets. */
 		mix_ircnt.u64 = cvmx_read_csr(CVMX_MIXX_IRCNT(port));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	octeon_mgmt_rx_fill_ring(p->netdev);
diff -u -p a/net/ethernet/nvidia/forcedeth.c b/net/ethernet/nvidia/forcedeth.c
--- a/net/ethernet/nvidia/forcedeth.c
+++ b/net/ethernet/nvidia/forcedeth.c
@@ -1160,12 +1160,23 @@ static int phy_reset(struct net_device *
 	msleep(500);
 
 	/* must wait till reset is deasserted */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (miicontrol & BMCR_RESET) {
 		usleep_range(10000, 20000);
 		miicontrol = mii_rw(dev, np->phyaddr, MII_BMCR, MII_READ);
 		/* FIXME: 100 tries seem excessive */
 		if (tries++ > 100)
 			return -1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
@@ -1743,6 +1754,11 @@ static int nv_alloc_rx(struct net_device
 	if (less_rx-- == np->first_rx.orig)
 		less_rx = np->last_rx.orig;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (np->put_rx.orig != less_rx) {
 		struct sk_buff *skb = dev_alloc_skb(np->rx_buf_sz + NV_RX_ALLOC_PAD);
 		if (skb) {
@@ -1761,6 +1777,12 @@ static int nv_alloc_rx(struct net_device
 				np->put_rx_ctx = np->first_rx_ctx;
 		} else
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
@@ -1774,6 +1796,11 @@ static int nv_alloc_rx_optimized(struct
 	if (less_rx-- == np->first_rx.ex)
 		less_rx = np->last_rx.ex;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (np->put_rx.ex != less_rx) {
 		struct sk_buff *skb = dev_alloc_skb(np->rx_buf_sz + NV_RX_ALLOC_PAD);
 		if (skb) {
@@ -1793,6 +1820,12 @@ static int nv_alloc_rx_optimized(struct
 				np->put_rx_ctx = np->first_rx_ctx;
 		} else
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
@@ -2376,6 +2409,11 @@ static int nv_tx_done(struct net_device
 	int tx_work = 0;
 	struct ring_desc *orig_get_tx = np->get_tx.orig;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((np->get_tx.orig != np->put_tx.orig) &&
 	       !((flags = le32_to_cpu(np->get_tx.orig->flaglen)) & NV_TX_VALID) &&
 	       (tx_work < limit)) {
@@ -2413,6 +2451,12 @@ static int nv_tx_done(struct net_device
 			np->get_tx.orig = np->first_tx.orig;
 		if (unlikely(np->get_tx_ctx++ == np->last_tx_ctx))
 			np->get_tx_ctx = np->first_tx_ctx;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+		}
 	}
 	if (unlikely((np->tx_stop == 1) && (np->get_tx.orig != orig_get_tx))) {
 		np->tx_stop = 0;
@@ -2428,6 +2472,11 @@ static int nv_tx_done_optimized(struct n
 	int tx_work = 0;
 	struct ring_desc_ex *orig_get_tx = np->get_tx.ex;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((np->get_tx.ex != np->put_tx.ex) &&
 	       !((flags = le32_to_cpu(np->get_tx.ex->flaglen)) & NV_TX2_VALID) &&
 	       (tx_work < limit)) {
@@ -2458,6 +2507,12 @@ static int nv_tx_done_optimized(struct n
 			np->get_tx.ex = np->first_tx.ex;
 		if (unlikely(np->get_tx_ctx++ == np->last_tx_ctx))
 			np->get_tx_ctx = np->first_tx_ctx;
+			if (_cur < timeout) {
+						rdstcll(_cur);
+			}
+			else {
+						break;
+		}
 	}
 	if (unlikely((np->tx_stop == 1) && (np->get_tx.ex != orig_get_tx))) {
 		np->tx_stop = 0;
@@ -2615,6 +2670,11 @@ static int nv_rx_process(struct net_devi
 	struct sk_buff *skb;
 	int len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((np->get_rx.orig != np->put_rx.orig) &&
 	      !((flags = le32_to_cpu(np->get_rx.orig->flaglen)) & NV_RX_AVAIL) &&
 		(rx_work < limit)) {
@@ -2702,6 +2762,12 @@ next_pkt:
 			np->get_rx_ctx = np->first_rx_ctx;
 
 		rx_work++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return rx_work;
@@ -2716,6 +2782,11 @@ static int nv_rx_process_optimized(struc
 	struct sk_buff *skb;
 	int len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((np->get_rx.ex != np->put_rx.ex) &&
 	      !((flags = le32_to_cpu(np->get_rx.ex->flaglen)) & NV_RX2_AVAIL) &&
 	      (rx_work < limit)) {
@@ -2789,6 +2860,12 @@ next_pkt:
 			np->get_rx_ctx = np->first_rx_ctx;
 
 		rx_work++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return rx_work;
diff -u -p a/net/ethernet/myricom/myri10ge/myri10ge.c b/net/ethernet/myricom/myri10ge/myri10ge.c
--- a/net/ethernet/myricom/myri10ge/myri10ge.c
+++ b/net/ethernet/myricom/myri10ge/myri10ge.c
@@ -1247,6 +1247,11 @@ myri10ge_alloc_rx_pages(struct myri10ge_
 		return;
 
 	/* try to refill entire ring */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rx->fill_cnt != (rx->cnt + rx->mask + 1)) {
 		idx = rx->fill_cnt & rx->mask;
 		if (rx->page_offset + bytes <= MYRI10GE_ALLOC_SIZE) {
@@ -1294,6 +1299,12 @@ myri10ge_alloc_rx_pages(struct myri10ge_
 			myri10ge_submit_8rx(&rx->lanai[idx - 7],
 					    &rx->shadow[idx - 7]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1411,6 +1422,11 @@ myri10ge_tx_done(struct myri10ge_slice_s
 	struct sk_buff *skb;
 	int idx, len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tx->pkt_done != mcp_index) {
 		idx = tx->done & tx->mask;
 		skb = tx->info[idx].skb;
@@ -1440,6 +1456,12 @@ myri10ge_tx_done(struct myri10ge_slice_s
 							      bus), len,
 					       PCI_DMA_TODEVICE);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	dev_queue = netdev_get_tx_queue(ss->dev, ss - ss->mgp->ss);
@@ -2152,6 +2174,11 @@ static void myri10ge_free_rings(struct m
 		put_page(ss->rx_small.info[idx].page);
 	}
 	tx = &ss->tx;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tx->done != tx->req) {
 		idx = tx->done & tx->mask;
 		skb = tx->info[idx].skb;
@@ -2176,6 +2203,12 @@ static void myri10ge_free_rings(struct m
 							      bus), len,
 					       PCI_DMA_TODEVICE);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	kfree(ss->rx_big.info);
 
@@ -2579,9 +2612,20 @@ static int myri10ge_open(struct net_devi
 	return 0;
 
 abort_with_rings:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (slice) {
 		slice--;
 		napi_disable(&mgp->ss[slice].napi);
+		if (_cur < timeout) {
+	    rdstcll(_cur);
+		}
+		else {
+	    break;
+		}
 	}
 	for (i = 0; i < mgp->num_slices; i++)
 		myri10ge_free_rings(&mgp->ss[i]);
@@ -2857,7 +2901,12 @@ again:
 		 * do not cross mgp->tx_boundary */
 		low = MYRI10GE_LOWPART_TO_U32(bus);
 		high_swapped = htonl(MYRI10GE_HIGHPART_TO_U32(bus));
-		while (len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (len) {
 			u8 flags_next;
 			int cum_len_next;
 
@@ -2919,6 +2968,12 @@ again:
 				else
 					cksum_offset = 0;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		if (frag_idx == frag_cnt)
 			break;
@@ -3015,6 +3070,11 @@ static netdev_tx_t myri10ge_sw_tso(struc
 	if (IS_ERR(segs))
 		goto drop;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (segs) {
 		curr = segs;
 		segs = segs->next;
@@ -3030,6 +3090,12 @@ static netdev_tx_t myri10ge_sw_tso(struc
 			}
 			goto drop;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_kfree_skb_any(skb);
 	return NETDEV_TX_OK;
diff -u -p a/net/ethernet/qlogic/qlge/qlge_main.c b/net/ethernet/qlogic/qlge/qlge_main.c
--- a/net/ethernet/qlogic/qlge/qlge_main.c
+++ b/net/ethernet/qlogic/qlge/qlge_main.c
@@ -168,7 +168,12 @@ int ql_wait_reg_rdy(struct ql_adapter *q
 	u32 temp;
 	int count = UDELAY_COUNT;
 
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count) {
 		temp = ql_read32(qdev, reg);
 
 		/* check for errors */
@@ -181,6 +186,12 @@ int ql_wait_reg_rdy(struct ql_adapter *q
 			return 0;
 		udelay(UDELAY_DELAY);
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	netif_alert(qdev, probe, qdev->ndev,
 		    "Timed out waiting for reg %x to come ready.\n", reg);
@@ -195,6 +206,11 @@ static int ql_wait_cfg(struct ql_adapter
 	int count = UDELAY_COUNT;
 	u32 temp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		temp = ql_read32(qdev, CFG);
 		if (temp & CFG_LE)
@@ -203,6 +219,12 @@ static int ql_wait_cfg(struct ql_adapter
 			return 0;
 		udelay(UDELAY_DELAY);
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -ETIMEDOUT;
 }
@@ -2177,7 +2199,12 @@ static int ql_clean_outbound_rx_ring(str
 
 	struct tx_ring *tx_ring;
 	/* While there are entries in the completion queue. */
-	while (prod != rx_ring->cnsmr_idx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (prod != rx_ring->cnsmr_idx) {
 
 		netif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,
 			     "cq_id = %d, prod = %d, cnsmr = %d.\n.",
@@ -2199,6 +2226,12 @@ static int ql_clean_outbound_rx_ring(str
 		count++;
 		ql_update_cq(rx_ring);
 		prod = ql_read_sh_reg(rx_ring->prod_idx_sh_reg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!net_rsp)
 		return 0;
@@ -2751,6 +2784,11 @@ static void ql_free_lbq_buffers(struct q
 
 	curr_idx = rx_ring->lbq_curr_idx;
 	clean_idx = rx_ring->lbq_clean_idx;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (curr_idx != clean_idx) {
 		lbq_desc = &rx_ring->lbq[curr_idx];
 
@@ -2768,6 +2806,12 @@ static void ql_free_lbq_buffers(struct q
 		if (++curr_idx == rx_ring->lbq_len)
 			curr_idx = 0;
 
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/net/ethernet/qlogic/qlge/qlge_dbg.c b/net/ethernet/qlogic/qlge/qlge_dbg.c
--- a/net/ethernet/qlogic/qlge/qlge_dbg.c
+++ b/net/ethernet/qlogic/qlge/qlge_dbg.c
@@ -45,6 +45,11 @@ static int ql_wait_other_func_reg_rdy(st
 	u32 temp;
 	int count = 10;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		temp = ql_read_other_func_reg(qdev, reg);
 
@@ -55,6 +60,12 @@ static int ql_wait_other_func_reg_rdy(st
 			return 0;
 		mdelay(10);
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -1;
 }
diff -u -p a/net/ethernet/qlogic/netxen/netxen_nic_hw.c b/net/ethernet/qlogic/netxen/netxen_nic_hw.c
--- a/net/ethernet/qlogic/netxen/netxen_nic_hw.c
+++ b/net/ethernet/qlogic/netxen/netxen_nic_hw.c
@@ -721,13 +721,24 @@ static void netxen_p3_nic_set_multi(stru
 send_fw_cmd:
 	adapter->set_promisc(adapter, mode);
 	head = &del_list;
-	while (!list_empty(head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(head)) {
 		cur = list_entry(head->next, nx_mac_list_t, list);
 
 		nx_p3_sre_macaddr_change(adapter,
 				cur->mac_addr, NETXEN_MAC_DEL);
 		list_del(&cur->list);
 		kfree(cur);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -755,12 +766,23 @@ void netxen_p3_free_mac_list(struct netx
 	nx_mac_list_t *cur;
 	struct list_head *head = &adapter->mac_list;
 
-	while (!list_empty(head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(head)) {
 		cur = list_entry(head->next, nx_mac_list_t, list);
 		nx_p3_sre_macaddr_change(adapter,
 				cur->mac_addr, NETXEN_MAC_DEL);
 		list_del(&cur->list);
 		kfree(cur);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/net/ethernet/qlogic/netxen/netxen_nic_main.c b/net/ethernet/qlogic/netxen/netxen_nic_main.c
--- a/net/ethernet/qlogic/netxen/netxen_nic_main.c
+++ b/net/ethernet/qlogic/netxen/netxen_nic_main.c
@@ -1864,7 +1864,12 @@ netxen_tso_check(struct net_device *netd
 		producer = get_next_index(producer, tx_ring->num_desc);
 	}
 
-	while (copied < hdr_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (copied < hdr_len) {
 
 		copy_len = min((int)sizeof(struct cmd_desc_type0) - offset,
 				(hdr_len - copied));
@@ -1879,6 +1884,12 @@ netxen_tso_check(struct net_device *netd
 		offset = 0;
 
 		producer = get_next_index(producer, tx_ring->num_desc);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	tx_ring->producer = producer;
@@ -2923,11 +2934,22 @@ netxen_free_vlan_ip_list(struct netxen_a
 	struct nx_vlan_ip_list  *cur;
 	struct list_head *head = &adapter->vlan_ip_list;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(head)) {
 		cur = list_entry(head->next, struct nx_vlan_ip_list, list);
 		netxen_config_ipaddr(adapter, cur->ip_addr, NX_IP_DOWN);
 		list_del(&cur->list);
 		kfree(cur);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
diff -u -p a/net/ethernet/qlogic/qlcnic/qlcnic_hw.c b/net/ethernet/qlogic/qlcnic/qlcnic_hw.c
--- a/net/ethernet/qlogic/qlcnic/qlcnic_hw.c
+++ b/net/ethernet/qlogic/qlcnic/qlcnic_hw.c
@@ -480,12 +480,23 @@ void qlcnic_free_mac_list(struct qlcnic_
 	struct qlcnic_mac_list_s *cur;
 	struct list_head *head = &adapter->mac_list;
 
-	while (!list_empty(head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(head)) {
 		cur = list_entry(head->next, struct qlcnic_mac_list_s, list);
 		qlcnic_sre_macaddr_change(adapter,
 				cur->mac_addr, 0, QLCNIC_MAC_DEL);
 		list_del(&cur->list);
 		kfree(cur);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1539,11 +1550,22 @@ qlcnic_dump_l1_cache(struct qlcnic_adapt
 		QLCNIC_WR_DUMP_REG(l1->ctrl_addr, base, LSW(l1->ctrl_val));
 		addr = l1->read_addr;
 		cnt = l1->read_addr_num;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cnt) {
 			QLCNIC_RD_DUMP_REG(addr, base, &data);
 			*buffer++ = cpu_to_le32(data);
 			addr += l1->read_addr_stride;
 			cnt--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		val += l1->stride;
 	}
@@ -1588,11 +1610,22 @@ qlcnic_dump_l2_cache(struct qlcnic_adapt
 skip_poll:
 		addr = l2->read_addr;
 		cnt = l2->read_addr_num;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cnt) {
 			QLCNIC_RD_DUMP_REG(addr, base, &data);
 			*buffer++ = cpu_to_le32(data);
 			addr += l2->read_addr_stride;
 			cnt--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		val += l2->stride;
 	}
diff -u -p a/net/ethernet/qlogic/qlcnic/qlcnic_main.c b/net/ethernet/qlogic/qlcnic/qlcnic_main.c
--- a/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@ -2064,7 +2064,12 @@ set_flags:
 			producer = get_next_index(producer, tx_ring->num_desc);
 		}
 
-		while (copied < hdr_len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (copied < hdr_len) {
 
 			copy_len = min((int)sizeof(struct cmd_desc_type0) -
 				offset, (hdr_len - copied));
@@ -2079,6 +2084,12 @@ set_flags:
 			offset = 0;
 
 			producer = get_next_index(producer, tx_ring->num_desc);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		tx_ring->producer = producer;
diff -u -p a/net/ethernet/qlogic/qla3xxx.c b/net/ethernet/qlogic/qla3xxx.c
--- a/net/ethernet/qlogic/qla3xxx.c
+++ b/net/ethernet/qlogic/qla3xxx.c
@@ -570,12 +570,23 @@ static int ql_wait_for_mii_ready(struct
 	u32 temp;
 	int count = 1000;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		temp = ql_read_page0_reg(qdev, &port_regs->macMIIStatusReg);
 		if (!(temp & MAC_MII_STATUS_BSY))
 			return 0;
 		udelay(10);
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -1;
 }
@@ -2121,6 +2132,11 @@ static int ql_tx_rx_clean(struct ql3_ada
 	int work_done = 0;
 
 	/* While there are entries in the completion queue. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((le32_to_cpu(*(qdev->prsp_producer_index)) !=
 		qdev->rsp_consumer_index) && (work_done < work_to_do)) {
 
@@ -2178,6 +2194,12 @@ static int ql_tx_rx_clean(struct ql3_ada
 		}
 
 		work_done = *tx_cleaned + *rx_cleaned;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return work_done;
diff -u -p a/net/ethernet/fealnx.c b/net/ethernet/fealnx.c
--- a/net/ethernet/fealnx.c
+++ b/net/ethernet/fealnx.c
@@ -736,6 +736,11 @@ static ulong m80x_send_cmd_to_phy(void _
 
 	/* sent out */
 	mask = 0x8000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mask) {
 		/* low MDC, prepare MDO */
 		miir &= ~(MASK_MIIR_MII_MDC + MASK_MIIR_MII_MDO);
@@ -752,6 +757,12 @@ static ulong m80x_send_cmd_to_phy(void _
 		mask >>= 1;
 		if (mask == 0x2 && opcode == OP_READ)
 			miir &= ~MASK_MIIR_MII_WRITE;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return miir;
 }
@@ -769,6 +780,11 @@ static int mdio_read(struct net_device *
 	/* read data */
 	mask = 0x8000;
 	data = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mask) {
 		/* low MDC */
 		miir &= ~MASK_MIIR_MII_MDC;
@@ -786,6 +802,12 @@ static int mdio_read(struct net_device *
 
 		/* next */
 		mask >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* low MDC */
@@ -807,6 +829,11 @@ static void mdio_write(struct net_device
 
 	/* write data */
 	mask = 0x8000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mask) {
 		/* low MDC, prepare MDO */
 		miir &= ~(MASK_MIIR_MII_MDC + MASK_MIIR_MII_MDO);
@@ -820,6 +847,12 @@ static void mdio_write(struct net_device
 
 		/* next */
 		mask >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* low MDC */
diff -u -p a/net/ethernet/tehuti/tehuti.c b/net/ethernet/tehuti/tehuti.c
--- a/net/ethernet/tehuti/tehuti.c
+++ b/net/ethernet/tehuti/tehuti.c
@@ -1713,6 +1713,11 @@ static void bdx_tx_cleanup(struct bdx_pr
 	f->m.wptr = READ_REG(priv, f->m.reg_WPTR) & TXF_WPTR_MASK;
 	BDX_ASSERT(f->m.rptr >= f->m.memsz);	/* started with valid rptr */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (f->m.wptr != f->m.rptr) {
 		f->m.rptr += BDX_TXF_DESC_SZ;
 		f->m.rptr &= f->m.size_mask;
@@ -1731,6 +1736,12 @@ static void bdx_tx_cleanup(struct bdx_pr
 		/* now should come skb pointer - free it */
 		dev_kfree_skb_irq(db->rptr->addr.skb);
 		bdx_tx_db_inc_rptr(db);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* let h/w know which TXF descriptors were cleaned */
@@ -1768,13 +1779,24 @@ static void bdx_tx_free_skbs(struct bdx_
 	struct txdb *db = &priv->txdb;
 
 	ENTER;
-	while (db->rptr != db->wptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (db->rptr != db->wptr) {
 		if (likely(db->rptr->len))
 			pci_unmap_page(priv->pdev, db->rptr->addr.dma,
 				       db->rptr->len, PCI_DMA_TODEVICE);
 		else
 			dev_kfree_skb(db->rptr->addr.skb);
 		bdx_tx_db_inc_rptr(db);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	RET();
 }
diff -u -p a/net/ethernet/tundra/tsi108_eth.c b/net/ethernet/tundra/tsi108_eth.c
--- a/net/ethernet/tundra/tsi108_eth.c
+++ b/net/ethernet/tundra/tsi108_eth.c
@@ -1417,6 +1417,11 @@ static int tsi108_close(struct net_devic
 
 	/* Check for any pending TX packets, and drop them. */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!data->txfree || data->txhead != data->txtail) {
 		int tx = data->txtail;
 		struct sk_buff *skb;
@@ -1424,12 +1429,23 @@ static int tsi108_close(struct net_devic
 		data->txtail = (data->txtail + 1) % TSI108_TXRING_LEN;
 		data->txfree++;
 		dev_kfree_skb(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	free_irq(data->irq_num, dev);
 
 	/* Discard the RX ring. */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (data->rxfree) {
 		int rx = data->rxtail;
 		struct sk_buff *skb;
@@ -1438,6 +1454,12 @@ static int tsi108_close(struct net_devic
 		data->rxtail = (data->rxtail + 1) % TSI108_RXRING_LEN;
 		data->rxfree--;
 		dev_kfree_skb(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dma_free_coherent(0,
diff -u -p a/net/ethernet/xilinx/ll_temac_main.c b/net/ethernet/xilinx/ll_temac_main.c
--- a/net/ethernet/xilinx/ll_temac_main.c
+++ b/net/ethernet/xilinx/ll_temac_main.c
@@ -74,12 +74,23 @@ int temac_indirect_busywait(struct temac
 {
 	long end = jiffies + 2;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(temac_ior(lp, XTE_RDY0_OFFSET) & XTE_RDY0_HARD_ACS_RDY_MASK)) {
 		if (end - jiffies <= 0) {
 			WARN_ON(1);
 			return -ETIMEDOUT;
 		}
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -497,12 +508,23 @@ static u32 temac_setoptions(struct net_d
 	int reg;
 
 	mutex_lock(&lp->indirect_mutex);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tp->opt) {
 		reg = temac_indirect_in32(lp, tp->reg) & ~tp->m_or;
 		if (options & tp->opt)
 			reg |= tp->m_or;
 		temac_indirect_out32(lp, tp->reg, reg);
 		tp++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	lp->options |= options;
 	mutex_unlock(&lp->indirect_mutex);
@@ -632,7 +654,12 @@ static void temac_start_xmit_done(struct
 	cur_p = &lp->tx_bd_v[lp->tx_bd_ci];
 	stat = cur_p->app0;
 
-	while (stat & STS_CTRL_APP0_CMPLT) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (stat & STS_CTRL_APP0_CMPLT) {
 		dma_unmap_single(ndev->dev.parent, cur_p->phys, cur_p->len,
 				 DMA_TO_DEVICE);
 		if (cur_p->app4)
@@ -652,6 +679,12 @@ static void temac_start_xmit_done(struct
 
 		cur_p = &lp->tx_bd_v[lp->tx_bd_ci];
 		stat = cur_p->app0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	netif_wake_queue(ndev);
@@ -763,7 +796,12 @@ static void ll_temac_recv(struct net_dev
 	cur_p = &lp->rx_bd_v[lp->rx_bd_ci];
 
 	bdstat = cur_p->app0;
-	while ((bdstat & STS_CTRL_APP0_CMPLT)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((bdstat & STS_CTRL_APP0_CMPLT)) {
 
 		skb = lp->rx_skb[lp->rx_bd_ci];
 		length = cur_p->app4 & 0x3FFF;
@@ -813,6 +851,12 @@ static void ll_temac_recv(struct net_dev
 
 		cur_p = &lp->rx_bd_v[lp->rx_bd_ci];
 		bdstat = cur_p->app0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	lp->dma_out(lp, RX_TAILDESC_PTR, tail_p);
 
diff -u -p a/net/ethernet/xilinx/xilinx_emaclite.c b/net/ethernet/xilinx/xilinx_emaclite.c
--- a/net/ethernet/xilinx/xilinx_emaclite.c
+++ b/net/ethernet/xilinx/xilinx_emaclite.c
@@ -726,13 +726,24 @@ static int xemaclite_mdio_wait(struct ne
 	/* wait for the MDIO interface to not be busy or timeout
 	   after some time.
 	*/
-	while (in_be32(lp->base_addr + XEL_MDIOCTRL_OFFSET) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (in_be32(lp->base_addr + XEL_MDIOCTRL_OFFSET) &
 			XEL_MDIOCTRL_MDIOSTS_MASK) {
 		if (end - jiffies <= 0) {
 			WARN_ON(1);
 			return -ETIMEDOUT;
 		}
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/xircom/xirc2ps_cs.c b/net/ethernet/xircom/xirc2ps_cs.c
--- a/net/ethernet/xircom/xirc2ps_cs.c
+++ b/net/ethernet/xircom/xirc2ps_cs.c
@@ -1024,6 +1024,11 @@ xirc2ps_interrupt(int irq, void *dev_id)
 
     /***** receive section ******/
     SelectPage(0);
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (eth_status & FullPktRcvd) {
 	rsr = GetByte(XIRCREG0_RSR);
 	if (bytes_rcvd > maxrx_bytes && (rsr & PktRxOk)) {
@@ -1124,6 +1129,12 @@ xirc2ps_interrupt(int irq, void *dev_id)
 
 	/* get the new ethernet status */
 	eth_status = GetByte(XIRCREG_ESR);
+	if (_cur < timeout) {
+	    rdstcll(_cur);
+	}
+	else {
+	    break;
+	}
     }
     if (rx_status & 0x10) { /* Receive overrun */
 	dev->stats.rx_over_errors++;
diff -u -p a/net/ethernet/nuvoton/w90p910_ether.c b/net/ethernet/nuvoton/w90p910_ether.c
--- a/net/ethernet/nuvoton/w90p910_ether.c
+++ b/net/ethernet/nuvoton/w90p910_ether.c
@@ -671,6 +671,11 @@ static irqreturn_t w90p910_tx_interrupt(
 	entry = ether->tdesc_phys +
 		offsetof(struct tran_pdesc, desclist[ether->finish_tx]);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (entry != cur_entry) {
 		txbd = &ether->tdesc->desclist[ether->finish_tx];
 
@@ -692,6 +697,12 @@ static irqreturn_t w90p910_tx_interrupt(
 
 		entry = ether->tdesc_phys +
 			offsetof(struct tran_pdesc, desclist[ether->finish_tx]);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (status & MISTA_EXDEF) {
diff -u -p a/net/ethernet/s6gmac.c b/net/ethernet/s6gmac.c
--- a/net/ethernet/s6gmac.c
+++ b/net/ethernet/s6gmac.c
@@ -387,7 +387,12 @@ static void s6gmac_rx_interrupt(struct n
 	struct s6gmac *pd = netdev_priv(dev);
 	u32 pfx;
 	struct sk_buff *skb;
-	while (((u8)(pd->rx_skb_i - pd->rx_skb_o)) >
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (((u8)(pd->rx_skb_i - pd->rx_skb_o)) >
 			s6dmac_pending_count(pd->rx_dma, pd->rx_chan)) {
 		skb = pd->rx_skb[(pd->rx_skb_o++) % S6_NUM_RX_SKB];
 		pfx = readl(pd->reg + S6_GMAC_BURST_POSTRD);
@@ -400,15 +405,32 @@ static void s6gmac_rx_interrupt(struct n
 			skb->ip_summed = CHECKSUM_UNNECESSARY;
 			netif_rx(skb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
 static void s6gmac_tx_interrupt(struct net_device *dev)
 {
 	struct s6gmac *pd = netdev_priv(dev);
-	while (((u8)(pd->tx_skb_i - pd->tx_skb_o)) >
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (((u8)(pd->tx_skb_i - pd->tx_skb_o)) >
 			s6dmac_pending_count(pd->tx_dma, pd->tx_chan)) {
 		dev_kfree_skb_irq(pd->tx_skb[(pd->tx_skb_o++) % S6_NUM_TX_SKB]);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (!s6dmac_fifo_full(pd->tx_dma, pd->tx_chan))
 		netif_wake_queue(dev);
@@ -481,10 +503,21 @@ static void s6gmac_stats_carry(struct s6
 		const struct s6gmac_statinf *inf, u32 mask)
 {
 	int b;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mask) {
 		b = fls(mask) - 1;
 		mask &= ~(1 << b);
 		pd->carry[inf[b].net_index] += (1 << inf[b].reg_size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -653,10 +686,21 @@ static void s6mii_enable(struct s6gmac *
 
 static int s6mii_busy(struct s6gmac *pd, int tmo)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (readl(pd->reg + S6_GMAC_MACMIIINDI)) {
 		if (--tmo == 0)
 			return -ETIME;
 		udelay(64);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/xscale/ixp2000/ixpdev.c b/net/ethernet/xscale/ixp2000/ixpdev.c
--- a/net/ethernet/xscale/ixp2000/ixpdev.c
+++ b/net/ethernet/xscale/ixp2000/ixpdev.c
@@ -77,6 +77,11 @@ static int ixpdev_xmit(struct sk_buff *s
 
 static int ixpdev_rx(struct net_device *dev, int processed, int budget)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (processed < budget) {
 		struct ixpdev_rx_desc *desc;
 		struct sk_buff *skb;
@@ -121,6 +126,12 @@ static int ixpdev_rx(struct net_device *
 err:
 		ixp2000_reg_write(RING_RX_PENDING, _desc);
 		processed++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return processed;
diff -u -p a/net/ethernet/xscale/ixp4xx_eth.c b/net/ethernet/xscale/ixp4xx_eth.c
--- a/net/ethernet/xscale/ixp4xx_eth.c
+++ b/net/ethernet/xscale/ixp4xx_eth.c
@@ -674,6 +674,11 @@ static int eth_poll(struct napi_struct *
 	printk(KERN_DEBUG "%s: eth_poll\n", dev->name);
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (received < budget) {
 		struct sk_buff *skb;
 		struct desc *desc;
@@ -764,7 +769,13 @@ static int eth_poll(struct napi_struct *
 		desc->pkt_len = 0;
 		queue_put_desc(rxfreeq, rx_desc_phys(port, n), desc);
 		received++;
-	}
+		if (_cur < timeout) {
+rdstcll(_cur);
+		}
+		else {
+break;
+		}
+}
 
 #if DEBUG_RX
 	printk(KERN_DEBUG "eth_poll(): end, not all work done\n");
diff -u -p a/net/ethernet/atheros/atlx/atl1.c b/net/ethernet/atheros/atlx/atl1.c
--- a/net/ethernet/atheros/atlx/atl1.c
+++ b/net/ethernet/atheros/atlx/atl1.c
@@ -1778,11 +1778,22 @@ static void atl1_clean_alloc_flag(struct
 {
 	struct atl1_rfd_ring *rfd_ring = &adapter->rfd_ring;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rfd_ring->next_to_clean != (rrd->buf_indx + offset)) {
 		rfd_ring->buffer_info[rfd_ring->next_to_clean].alloced = 0;
 		if (++rfd_ring->next_to_clean == rfd_ring->count) {
 			rfd_ring->next_to_clean = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2074,7 +2085,12 @@ static void atl1_intr_tx(struct atl1_ada
 	sw_tpd_next_to_clean = atomic_read(&tpd_ring->next_to_clean);
 	cmb_tpd_next_to_clean = le16_to_cpu(adapter->cmb.cmb->tpd_cons_idx);
 
-	while (cmb_tpd_next_to_clean != sw_tpd_next_to_clean) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cmb_tpd_next_to_clean != sw_tpd_next_to_clean) {
 		buffer_info = &tpd_ring->buffer_info[sw_tpd_next_to_clean];
 		if (buffer_info->dma) {
 			pci_unmap_page(adapter->pdev, buffer_info->dma,
@@ -2089,6 +2105,12 @@ static void atl1_intr_tx(struct atl1_ada
 
 		if (++sw_tpd_next_to_clean == tpd_ring->count)
 			sw_tpd_next_to_clean = 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	atomic_set(&tpd_ring->next_to_clean, sw_tpd_next_to_clean);
 
diff -u -p a/net/ethernet/atheros/atl1c/atl1c_main.c b/net/ethernet/atheros/atl1c/atl1c_main.c
--- a/net/ethernet/atheros/atl1c/atl1c_main.c
+++ b/net/ethernet/atheros/atl1c/atl1c_main.c
@@ -1641,12 +1641,23 @@ static bool atl1c_clean_tx_irq(struct at
 	AT_READ_REG(&adapter->hw, REG_MB_PRIO_CONS_IDX, &data);
 	hw_next_to_clean = (data >> shift) & MB_PRIO_PROD_IDX_MASK;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_to_clean != hw_next_to_clean) {
 		buffer_info = &tpd_ring->buffer_info[next_to_clean];
 		atl1c_clean_buffer(pdev, buffer_info, 1);
 		if (++next_to_clean == tpd_ring->count)
 			next_to_clean = 0;
 		atomic_set(&tpd_ring->next_to_clean, next_to_clean);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (netif_queue_stopped(adapter->netdev) &&
diff -u -p a/net/ethernet/atheros/atl1e/atl1e_main.c b/net/ethernet/atheros/atl1e/atl1e_main.c
--- a/net/ethernet/atheros/atl1e/atl1e_main.c
+++ b/net/ethernet/atheros/atl1e/atl1e_main.c
@@ -1227,6 +1227,11 @@ static bool atl1e_clean_tx_irq(struct at
 	u16 hw_next_to_clean = AT_READ_REGW(&adapter->hw, REG_TPD_CONS_IDX);
 	u16 next_to_clean = atomic_read(&tx_ring->next_to_clean);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_to_clean != hw_next_to_clean) {
 		tx_buffer = &tx_ring->tx_buffer[next_to_clean];
 		if (tx_buffer->dma) {
@@ -1246,6 +1251,12 @@ static bool atl1e_clean_tx_irq(struct at
 
 		if (++next_to_clean == tx_ring->count)
 			next_to_clean = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	atomic_set(&tx_ring->next_to_clean, next_to_clean);
@@ -1722,6 +1733,11 @@ static int atl1e_tx_map(struct atl1e_ada
 			TPD_BUFLEN_MASK) << TPD_BUFLEN_SHIFT);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mapped_len < buf_len) {
 		/* mapped_len == 0, means we should use the first tpd,
 		   which is given by caller  */
@@ -1745,11 +1761,22 @@ static int atl1e_tx_map(struct atl1e_ada
 			/* We need to unwind the mappings we've done */
 			ring_end = adapter->tx_ring.next_to_use;
 			adapter->tx_ring.next_to_use = ring_start;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (adapter->tx_ring.next_to_use != ring_end) {
 				tpd = atl1e_get_tpd(adapter);
 				tx_buffer = atl1e_get_tx_buffer(adapter, tpd);
 				pci_unmap_single(adapter->pdev, tx_buffer->dma,
 						 tx_buffer->length, PCI_DMA_TODEVICE);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 			}
 			/* Reset the tx rings next pointer */
 			adapter->tx_ring.next_to_use = ring_start;
@@ -1762,6 +1789,12 @@ static int atl1e_tx_map(struct atl1e_ada
 		use_tpd->word2 = (use_tpd->word2 & (~TPD_BUFLEN_MASK)) |
 			((cpu_to_le32(tx_buffer->length) &
 			TPD_BUFLEN_MASK) << TPD_BUFLEN_SHIFT);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (f = 0; f < nr_frags; f++) {
@@ -1796,11 +1829,22 @@ static int atl1e_tx_map(struct atl1e_ada
 				/* We need to unwind the mappings we've done */
 				ring_end = adapter->tx_ring.next_to_use;
 				adapter->tx_ring.next_to_use = ring_start;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (adapter->tx_ring.next_to_use != ring_end) {
 					tpd = atl1e_get_tpd(adapter);
 					tx_buffer = atl1e_get_tx_buffer(adapter, tpd);
 					dma_unmap_page(&adapter->pdev->dev, tx_buffer->dma,
 						       tx_buffer->length, DMA_TO_DEVICE);
+					if (_cur < timeout) {
+				rdstcll(_cur);
+					}
+					else {
+				break;
+					}
 				}
 
 				/* Reset the ring next to use pointer */
diff -u -p a/net/ethernet/cadence/at91_ether.c b/net/ethernet/cadence/at91_ether.c
--- a/net/ethernet/cadence/at91_ether.c
+++ b/net/ethernet/cadence/at91_ether.c
@@ -882,6 +882,11 @@ static void at91ether_rx(struct net_devi
 	unsigned int pktlen;
 
 	dlist = lp->dlist;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dlist->descriptors[lp->rxBuffIndex].addr & EMAC_DESC_DONE) {
 		p_recv = dlist->recv_buf[lp->rxBuffIndex];
 		pktlen = dlist->descriptors[lp->rxBuffIndex].size & 0x7ff;	/* Length of frame including FCS */
@@ -907,6 +912,12 @@ static void at91ether_rx(struct net_devi
 			lp->rxBuffIndex = 0;
 		else
 			lp->rxBuffIndex++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/net/ethernet/microchip/enc28j60.c b/net/ethernet/microchip/enc28j60.c
--- a/net/ethernet/microchip/enc28j60.c
+++ b/net/ethernet/microchip/enc28j60.c
@@ -422,6 +422,11 @@ static int poll_ready(struct enc28j60_ne
 	unsigned long timeout = jiffies + msec20_to_jiffies;
 
 	/* 20 msec timeout read */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((nolock_regb_read(priv, reg) & mask) != val) {
 		if (time_after(jiffies, timeout)) {
 			if (netif_msg_drv(priv))
@@ -430,6 +435,12 @@ static int poll_ready(struct enc28j60_ne
 			return -ETIMEDOUT;
 		}
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/aeroflex/greth.c b/net/ethernet/aeroflex/greth.c
--- a/net/ethernet/aeroflex/greth.c
+++ b/net/ethernet/aeroflex/greth.c
@@ -1169,9 +1169,20 @@ static struct net_device_ops greth_netde
 static inline int wait_for_mdio(struct greth_private *greth)
 {
 	unsigned long timeout = jiffies + 4*HZ/100;
-	while (GRETH_REGLOAD(greth->regs->mdio) & GRETH_MII_BUSY) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (GRETH_REGLOAD(greth->regs->mdio) & GRETH_MII_BUSY) {
 		if (time_after(jiffies, timeout))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 1;
 }
@@ -1361,7 +1372,18 @@ static int greth_mdio_init(struct greth_
 	if (greth->edcl && greth_edcl == 1) {
 		phy_start_aneg(greth->phy);
 		timeout = jiffies + 6*HZ;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!phy_aneg_done(greth->phy) && time_before(jiffies, timeout)) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		genphy_read_status(greth->phy);
 		greth_link_change(greth->netdev);
@@ -1429,6 +1451,11 @@ static int __devinit greth_of_probe(stru
 
 	/* Wait for MAC to reset itself */
 	timeout = jiffies + HZ/100;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (GRETH_REGLOAD(regs->control) & GRETH_RESET) {
 		if (time_after(jiffies, timeout)) {
 			err = -EIO;
@@ -1436,6 +1463,12 @@ static int __devinit greth_of_probe(stru
 				dev_err(greth->dev, "timeout when waiting for reset.\n");
 			goto error2;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Get default PHY address  */
diff -u -p a/net/ethernet/brocade/bna/bfa_msgq.c b/net/ethernet/brocade/bna/bfa_msgq.c
--- a/net/ethernet/brocade/bna/bfa_msgq.c
+++ b/net/ethernet/brocade/bna/bfa_msgq.c
@@ -66,10 +66,21 @@ cmdq_sm_stopped_entry(struct bfa_msgq_cm
 	cmdq->token = 0;
 	cmdq->offset = 0;
 	cmdq->bytes_to_copy = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&cmdq->pending_q)) {
 		bfa_q_deq(&cmdq->pending_q, &cmdq_ent);
 		bfa_q_qe_init(&cmdq_ent->qe);
 		call_cmdq_ent_cbfn(cmdq_ent, BFA_STATUS_FAILED);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -218,7 +229,12 @@ __cmd_copy(struct bfa_msgq_cmdq *cmdq, s
 	dst = (u8 *)cmdq->addr.kva;
 	dst += (cmdq->producer_index * BFI_MSGQ_CMD_ENTRY_SIZE);
 
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		to_copy = (len < BFI_MSGQ_CMD_ENTRY_SIZE) ?
 				len : BFI_MSGQ_CMD_ENTRY_SIZE;
 		memcpy(dst, src, to_copy);
@@ -228,6 +244,12 @@ __cmd_copy(struct bfa_msgq_cmdq *cmdq, s
 		dst = (u8 *)cmdq->addr.kva;
 		dst += (cmdq->producer_index * BFI_MSGQ_CMD_ENTRY_SIZE);
 		num_entries++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 }
@@ -656,7 +678,12 @@ bfa_msgq_rsp_copy(struct bfa_msgq *msgq,
 	src += (ci * BFI_MSGQ_RSP_ENTRY_SIZE);
 	dst = buf;
 
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		to_copy = (len < BFI_MSGQ_RSP_ENTRY_SIZE) ?
 				len : BFI_MSGQ_RSP_ENTRY_SIZE;
 		memcpy(dst, src, to_copy);
@@ -665,5 +692,11 @@ bfa_msgq_rsp_copy(struct bfa_msgq *msgq,
 		BFA_MSGQ_INDX_ADD(ci, 1, rspq->depth);
 		src = (u8 *)rspq->addr.kva;
 		src += (ci * BFI_MSGQ_RSP_ENTRY_SIZE);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
diff -u -p a/net/ethernet/brocade/bna/bnad.c b/net/ethernet/brocade/bna/bnad.c
--- a/net/ethernet/brocade/bna/bnad.c
+++ b/net/ethernet/brocade/bna/bnad.c
@@ -195,6 +195,11 @@ bnad_free_txbufs(struct bnad *bnad,
 	unmap_cons = unmap_q->consumer_index;
 
 	prefetch(&unmap_array[unmap_cons + 1]);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (wis) {
 		skb = unmap_array[unmap_cons].skb;
 
@@ -207,6 +212,12 @@ bnad_free_txbufs(struct bnad *bnad,
 				skb_shinfo(skb)->nr_frags);
 
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Update consumer pointers. */
@@ -440,7 +451,12 @@ bnad_poll_cq(struct bnad *bnad, struct b
 	BNA_CQ_QPGE_PTR_GET(ccb->producer_index, ccb->sw_qpt, cmpl,
 			    wi_range);
 	BUG_ON(!(wi_range <= ccb->q_depth));
-	while (cmpl->valid && packets < budget) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cmpl->valid && packets < budget) {
 		packets++;
 		BNA_UPDATE_PKT_CNT(pkt_rt, ntohs(cmpl->length));
 
@@ -516,6 +532,12 @@ bnad_poll_cq(struct bnad *bnad, struct b
 next:
 		cmpl->valid = 0;
 		cmpl = next_cmpl;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	BNA_QE_INDX_ADD(ccb->producer_index, wis, ccb->q_depth);
diff -u -p a/net/ethernet/brocade/bna/bna_tx_rx.c b/net/ethernet/brocade/bna/bna_tx_rx.c
--- a/net/ethernet/brocade/bna/bna_tx_rx.c
+++ b/net/ethernet/brocade/bna/bna_tx_rx.c
@@ -534,6 +534,11 @@ bna_rxf_mcast_cfg_apply(struct bna_rxf *
 	int ret;
 
 	/* Delete multicast entries previousely added */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rxf->mcast_pending_del_q)) {
 		bfa_q_deq(&rxf->mcast_pending_del_q, &qe);
 		bfa_q_qe_init(qe);
@@ -542,6 +547,12 @@ bna_rxf_mcast_cfg_apply(struct bna_rxf *
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	/* Add multicast entries */
@@ -565,9 +576,20 @@ bna_rxf_vlan_cfg_apply(struct bna_rxf *r
 
 	if (rxf->vlan_pending_bitmask) {
 		vlan_pending_bitmask = rxf->vlan_pending_bitmask;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(vlan_pending_bitmask & 0x1)) {
 			block_idx++;
 			vlan_pending_bitmask >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		rxf->vlan_pending_bitmask &= ~(1 << block_idx);
 		bna_bfi_rx_vlan_filter_set(rxf, block_idx);
@@ -585,6 +607,11 @@ bna_rxf_mcast_cfg_reset(struct bna_rxf *
 	int ret;
 
 	/* Throw away delete pending mcast entries */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rxf->mcast_pending_del_q)) {
 		bfa_q_deq(&rxf->mcast_pending_del_q, &qe);
 		bfa_q_qe_init(qe);
@@ -593,9 +620,20 @@ bna_rxf_mcast_cfg_reset(struct bna_rxf *
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* Move active mcast entries to pending_add_q */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rxf->mcast_active_q)) {
 		bfa_q_deq(&rxf->mcast_active_q, &qe);
 		bfa_q_qe_init(qe);
@@ -603,6 +641,12 @@ bna_rxf_mcast_cfg_reset(struct bna_rxf *
 		mac = (struct bna_mac *)qe;
 		if (bna_rxf_mcast_del(rxf, mac, cleanup))
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -782,10 +826,21 @@ bna_rxf_uninit(struct bna_rxf *rxf)
 	rxf->ucast_pending_set = 0;
 	rxf->ucast_active_set = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rxf->ucast_pending_add_q)) {
 		bfa_q_deq(&rxf->ucast_pending_add_q, &mac);
 		bfa_q_qe_init(&mac->qe);
 		bna_ucam_mod_mac_put(&rxf->rx->bna->ucam_mod, mac);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (rxf->ucast_pending_mac) {
@@ -795,10 +850,21 @@ bna_rxf_uninit(struct bna_rxf *rxf)
 		rxf->ucast_pending_mac = NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rxf->mcast_pending_add_q)) {
 		bfa_q_deq(&rxf->mcast_pending_add_q, &mac);
 		bfa_q_qe_init(&mac->qe);
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	rxf->rxmode_pending = 0;
@@ -929,27 +995,60 @@ bna_rx_mcast_listset(struct bna_rx *rx,
 	}
 
 	/* Purge the pending_add_q */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rxf->mcast_pending_add_q)) {
 		bfa_q_deq(&rxf->mcast_pending_add_q, &qe);
 		bfa_q_qe_init(qe);
 		mac = (struct bna_mac *)qe;
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Schedule active_q entries for deletion */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rxf->mcast_active_q)) {
 		bfa_q_deq(&rxf->mcast_active_q, &qe);
 		mac = (struct bna_mac *)qe;
 		bfa_q_qe_init(&mac->qe);
 		list_add_tail(&mac->qe, &rxf->mcast_pending_del_q);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Add the new entries */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&list_head)) {
 		bfa_q_deq(&list_head, &qe);
 		mac = (struct bna_mac *)qe;
 		bfa_q_qe_init(&mac->qe);
 		list_add_tail(&mac->qe, &rxf->mcast_pending_add_q);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rxf->cam_fltr_cbfn = cbfn;
@@ -959,11 +1058,22 @@ bna_rx_mcast_listset(struct bna_rx *rx,
 	return BNA_CB_SUCCESS;
 
 err_return:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&list_head)) {
 		bfa_q_deq(&list_head, &qe);
 		mac = (struct bna_mac *)qe;
 		bfa_q_qe_init(&mac->qe);
 		bna_mcam_mod_mac_put(&rxf->rx->bna->mcam_mod, mac);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return BNA_CB_MCAST_LIST_FULL;
@@ -1046,6 +1156,11 @@ bna_rxf_ucast_cfg_reset(struct bna_rxf *
 	struct bna_mac *mac;
 
 	/* Throw away delete pending ucast entries */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rxf->ucast_pending_del_q)) {
 		bfa_q_deq(&rxf->ucast_pending_del_q, &qe);
 		bfa_q_qe_init(qe);
@@ -1058,9 +1173,20 @@ bna_rxf_ucast_cfg_reset(struct bna_rxf *
 			bna_ucam_mod_mac_put(&rxf->rx->bna->ucam_mod, mac);
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Move active ucast entries to pending_add_q */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rxf->ucast_active_q)) {
 		bfa_q_deq(&rxf->ucast_active_q, &qe);
 		bfa_q_qe_init(qe);
@@ -1071,6 +1197,12 @@ bna_rxf_ucast_cfg_reset(struct bna_rxf *
 				BFI_ENET_H2I_MAC_UCAST_DEL_REQ);
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (rxf->ucast_active_set) {
@@ -2547,6 +2679,11 @@ bna_rx_destroy(struct bna_rx *rx)
 
 	bna_rxf_uninit(&rx->rxf);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rx->rxp_q)) {
 		bfa_q_deq(&rx->rxp_q, &rxp);
 		GET_RXQS(rxp, q0, q1);
@@ -2573,6 +2710,12 @@ bna_rx_destroy(struct bna_rx *rx)
 		rxp->cq.ccb = NULL;
 		rxp->rx = NULL;
 		bna_rxp_put(rx_mod, rxp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	list_for_each(qe, &rx_mod->rx_active_q) {
@@ -3285,12 +3428,23 @@ bna_tx_free(struct bna_tx *tx)
 	struct list_head *prev_qe;
 	struct list_head *qe;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&tx->txq_q)) {
 		bfa_q_deq(&tx->txq_q, &txq);
 		bfa_q_qe_init(&txq->qe);
 		txq->tcb = NULL;
 		txq->tx = NULL;
 		list_add_tail(&txq->qe, &tx_mod->txq_free_q);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	list_for_each(qe, &tx_mod->tx_active_q) {
diff -u -p a/net/ethernet/chelsio/cxgb/sge.c b/net/ethernet/chelsio/cxgb/sge.c
--- a/net/ethernet/chelsio/cxgb/sge.c
+++ b/net/ethernet/chelsio/cxgb/sge.c
@@ -1487,6 +1487,11 @@ static int process_responses(struct adap
 	unsigned int flags = 0;
 	unsigned int cmdq_processed[SGE_CMDQ_N] = {0, 0};
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (done < budget && e->GenerationBit == q->genbit) {
 		flags |= e->Qsleeping;
 
@@ -1544,6 +1549,12 @@ static int process_responses(struct adap
 			writel(q->credits, adapter->regs + A_SG_RSPQUEUECREDIT);
 			q->credits = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	flags = update_tx_info(adapter, flags, cmdq_processed[0]);
diff -u -p a/net/ethernet/chelsio/cxgb/subr.c b/net/ethernet/chelsio/cxgb/subr.c
--- a/net/ethernet/chelsio/cxgb/subr.c
+++ b/net/ethernet/chelsio/cxgb/subr.c
@@ -62,6 +62,11 @@
 static int t1_wait_op_done(adapter_t *adapter, int reg, u32 mask, int polarity,
 			   int attempts, int delay)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		u32 val = readl(adapter->regs + reg) & mask;
 
@@ -71,6 +76,12 @@ static int t1_wait_op_done(adapter_t *ad
 			return 1;
 		if (delay)
 			udelay(delay);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/net/ethernet/chelsio/cxgb3/sge.c b/net/ethernet/chelsio/cxgb3/sge.c
--- a/net/ethernet/chelsio/cxgb3/sge.c
+++ b/net/ethernet/chelsio/cxgb3/sge.c
@@ -1834,6 +1834,11 @@ static int ofld_poll(struct napi_struct
 	struct adapter *adapter = qs->adap;
 	int work_done = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (work_done < budget) {
 		struct sk_buff *skb, *tmp, *skbs[RX_BUNDLE_SIZE];
 		struct sk_buff_head queue;
@@ -1872,6 +1877,12 @@ static int ofld_poll(struct napi_struct
 			spin_unlock_irq(&q->lock);
 		}
 		deliver_partial_bundle(&adapter->tdev, q, skbs, ngathered);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return work_done;
diff -u -p a/net/ethernet/chelsio/cxgb3/t3_hw.c b/net/ethernet/chelsio/cxgb3/t3_hw.c
--- a/net/ethernet/chelsio/cxgb3/t3_hw.c
+++ b/net/ethernet/chelsio/cxgb3/t3_hw.c
@@ -55,6 +55,11 @@ static void t3_port_intr_clear(struct ad
 int t3_wait_op_done_val(struct adapter *adapter, int reg, u32 mask,
 			int polarity, int attempts, int delay, u32 *valp)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		u32 val = t3_read_reg(adapter, reg);
 
@@ -67,6 +72,12 @@ int t3_wait_op_done_val(struct adapter *
 			return -EAGAIN;
 		if (delay)
 			udelay(delay);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -816,6 +827,11 @@ static int flash_wait_op(struct adapter
 	int ret;
 	u32 status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if ((ret = sf1_write(adapter, 1, 1, SF_RD_STATUS)) != 0 ||
 		    (ret = sf1_read(adapter, 1, 0, &status)) != 0)
@@ -826,6 +842,12 @@ static int flash_wait_op(struct adapter
 			return -EAGAIN;
 		if (delay)
 			msleep(delay);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -1063,6 +1085,11 @@ int t3_check_fw_version(struct adapter *
  */
 static int t3_flash_erase_sectors(struct adapter *adapter, int start, int end)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start <= end) {
 		int ret;
 
@@ -1072,6 +1099,12 @@ static int t3_flash_erase_sectors(struct
 		    (ret = flash_wait_op(adapter, 5, 500)) != 0)
 			return ret;
 		start++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/ethernet/chelsio/cxgb3/cxgb3_main.c b/net/ethernet/chelsio/cxgb3/cxgb3_main.c
--- a/net/ethernet/chelsio/cxgb3/cxgb3_main.c
+++ b/net/ethernet/chelsio/cxgb3/cxgb3_main.c
@@ -441,10 +441,21 @@ static int await_mgmt_replies(struct ada
 {
 	int attempts = 10;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (adap->sge.qs[0].rspq.offload_pkts < init_cnt + n) {
 		if (!--attempts)
 			return -ETIMEDOUT;
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -2404,7 +2415,12 @@ static int cxgb_extension_ioctl(struct n
 		 * want to use huge intermediate buffers.
 		 */
 		useraddr += sizeof(t);	/* advance to start of buffer */
-		while (t.len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (t.len) {
 			unsigned int chunk =
 				min_t(unsigned int, t.len, sizeof(buf));
 
@@ -2418,6 +2434,12 @@ static int cxgb_extension_ioctl(struct n
 			useraddr += chunk;
 			t.addr += chunk;
 			t.len -= chunk;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -2740,12 +2762,23 @@ static void t3_adap_check_task(struct wo
 		v = (t3_read_reg(adapter, A_SG_RSPQ_FL_STATUS) >> S_FL0EMPTY) &
 		    0xffff;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (v) {
 			qs->fl[i].empty += (v & 1);
 			if (i)
 				qs++;
 			i ^= 1;
 			v >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/ethernet/chelsio/cxgb4/l2t.c b/net/ethernet/chelsio/cxgb4/l2t.c
--- a/net/ethernet/chelsio/cxgb4/l2t.c
+++ b/net/ethernet/chelsio/cxgb4/l2t.c
@@ -171,12 +171,23 @@ static int write_l2e(struct adapter *ada
  */
 static void send_pending(struct adapter *adap, struct l2t_entry *e)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (e->arpq_head) {
 		struct sk_buff *skb = e->arpq_head;
 
 		e->arpq_head = skb->next;
 		skb->next = NULL;
 		t4_ofld_send(adap, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	e->arpq_tail = NULL;
 }
@@ -313,11 +324,22 @@ static void t4_l2e_free(struct l2t_entry
 			neigh_release(e->neigh);
 			e->neigh = NULL;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (e->arpq_head) {
 			struct sk_buff *skb = e->arpq_head;
 
 			e->arpq_head = skb->next;
 			kfree_skb(skb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		e->arpq_tail = NULL;
 	}
@@ -418,6 +440,11 @@ EXPORT_SYMBOL(cxgb4_l2t_get);
  */
 static void handle_failed_resolution(struct adapter *adap, struct sk_buff *arpq)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (arpq) {
 		struct sk_buff *skb = arpq;
 		const struct l2t_skb_cb *cb = L2T_SKB_CB(skb);
@@ -428,6 +455,12 @@ static void handle_failed_resolution(str
 			cb->arp_err_handler(cb->handle, skb);
 		else
 			t4_ofld_send(adap, skb);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/net/ethernet/chelsio/cxgb4/cxgb4_main.c
--- a/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -2020,6 +2020,11 @@ static ssize_t mem_read(struct file *fil
 	if (count > avail - pos)
 		count = avail - pos;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		size_t len;
 		int ret, ofst;
@@ -2040,6 +2045,12 @@ static ssize_t mem_read(struct file *fil
 		buf += len;
 		pos += len;
 		count -= len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	count = pos - *ppos;
 	*ppos = pos;
@@ -2217,6 +2228,11 @@ static void process_tid_release_list(str
 	adap = container_of(work, struct adapter, tid_release_task);
 
 	spin_lock_bh(&adap->tid_release_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (adap->tid_release_head) {
 		void **p = adap->tid_release_head;
 		unsigned int chan = (uintptr_t)p & 3;
@@ -2233,6 +2249,12 @@ static void process_tid_release_list(str
 		mk_tid_release(skb, chan, p - adap->tids.tid_tab);
 		t4_ofld_send(adap, skb);
 		spin_lock_bh(&adap->tid_release_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	adap->tid_release_task_busy = false;
 	spin_unlock_bh(&adap->tid_release_lock);
diff -u -p a/net/ethernet/chelsio/cxgb4/t4_hw.c b/net/ethernet/chelsio/cxgb4/t4_hw.c
--- a/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -56,6 +56,11 @@
 static int t4_wait_op_done_val(struct adapter *adapter, int reg, u32 mask,
 			       int polarity, int attempts, int delay, u32 *valp)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		u32 val = t4_read_reg(adapter, reg);
 
@@ -68,6 +73,12 @@ static int t4_wait_op_done_val(struct ad
 			return -EAGAIN;
 		if (delay)
 			udelay(delay);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -507,6 +518,11 @@ static int flash_wait_op(struct adapter
 	int ret;
 	u32 status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if ((ret = sf1_write(adapter, 1, 1, 1, SF_RD_STATUS)) != 0 ||
 		    (ret = sf1_read(adapter, 1, 0, 1, &status)) != 0)
@@ -517,6 +533,12 @@ static int flash_wait_op(struct adapter
 			return -EAGAIN;
 		if (delay)
 			msleep(delay);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c b/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
--- a/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
+++ b/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c
@@ -824,11 +824,22 @@ int t4vf_config_rss_range(struct adapter
 
 			nq -= nqbuf;
 			qbuf[0] = qbuf[1] = qbuf[2] = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (nqbuf) {
 				nqbuf--;
 				*qbp++ = *rsp++;
 				if (rsp >= rsp_end)
 					rsp = rspq;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 			}
 			*qp++ = cpu_to_be32(FW_RSS_IND_TBL_CMD_IQ0(qbuf[0]) |
 					    FW_RSS_IND_TBL_CMD_IQ1(qbuf[1]) |
@@ -1197,6 +1208,11 @@ int t4vf_get_port_stats(struct adapter *
 	 * commands.  We could use a Work Request and get all of them at once
 	 * but that's an asynchronous interface which is awkward to use.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rem) {
 		unsigned int ix = VI_VF_NUM_STATS - rem;
 		unsigned int nstats = min(6U, rem);
@@ -1223,6 +1239,12 @@ int t4vf_get_port_stats(struct adapter *
 
 		rem -= nstats;
 		fwsp += nstats;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/net/ethernet/mellanox/mlx4/eq.c b/net/ethernet/mellanox/mlx4/eq.c
--- a/net/ethernet/mellanox/mlx4/eq.c
+++ b/net/ethernet/mellanox/mlx4/eq.c
@@ -170,6 +170,11 @@ static int mlx4_eq_int(struct mlx4_dev *
 	int set_ci = 0;
 	int port;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((eqe = next_eqe_sw(eq))) {
 		/*
 		 * Make sure we read EQ entry contents after we've
@@ -257,6 +262,12 @@ static int mlx4_eq_int(struct mlx4_dev *
 			eq_set_ci(eq, 0);
 			set_ci = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	eq_set_ci(eq, 1);
diff -u -p a/net/ethernet/mellanox/mlx4/mr.c b/net/ethernet/mellanox/mlx4/mr.c
--- a/net/ethernet/mellanox/mlx4/mr.c
+++ b/net/ethernet/mellanox/mlx4/mr.c
@@ -98,11 +98,22 @@ static u32 mlx4_buddy_alloc(struct mlx4_
 	clear_bit(seg, buddy->bits[o]);
 	--buddy->num_free[o];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (o > order) {
 		--o;
 		seg <<= 1;
 		set_bit(seg ^ 1, buddy->bits[o]);
 		++buddy->num_free[o];
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock(&buddy->lock);
@@ -118,11 +129,22 @@ static void mlx4_buddy_free(struct mlx4_
 
 	spin_lock(&buddy->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (test_bit(seg ^ 1, buddy->bits[order])) {
 		clear_bit(seg ^ 1, buddy->bits[order]);
 		--buddy->num_free[order];
 		seg >>= 1;
 		++order;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	set_bit(seg, buddy->bits[order]);
diff -u -p a/net/ethernet/mellanox/mlx4/cmd.c b/net/ethernet/mellanox/mlx4/cmd.c
--- a/net/ethernet/mellanox/mlx4/cmd.c
+++ b/net/ethernet/mellanox/mlx4/cmd.c
@@ -166,10 +166,21 @@ static int mlx4_cmd_post(struct mlx4_dev
 	if (event)
 		end += msecs_to_jiffies(GO_BIT_TIMEOUT_MSECS);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cmd_pending(dev)) {
 		if (time_after_eq(jiffies, end))
 			goto out;
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/net/ethernet/mellanox/mlx4/icm.c b/net/ethernet/mellanox/mlx4/icm.c
--- a/net/ethernet/mellanox/mlx4/icm.c
+++ b/net/ethernet/mellanox/mlx4/icm.c
@@ -339,9 +339,20 @@ int mlx4_table_get_range(struct mlx4_dev
 	return 0;
 
 fail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i > start) {
 		i -= inc;
 		mlx4_table_put(dev, table, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return err;
diff -u -p a/net/ethernet/mellanox/mlx4/en_rx.c b/net/ethernet/mellanox/mlx4/en_rx.c
--- a/net/ethernet/mellanox/mlx4/en_rx.c
+++ b/net/ethernet/mellanox/mlx4/en_rx.c
@@ -234,10 +234,21 @@ static int mlx4_en_fill_rx_buffers(struc
 reduce_rings:
 	for (ring_ind = 0; ring_ind < priv->rx_ring_num; ring_ind++) {
 		ring = &priv->rx_ring[ring_ind];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ring->actual_size > new_size) {
 			ring->actual_size--;
 			ring->prod--;
 			mlx4_en_free_rx_desc(priv, ring, ring->actual_size);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -254,11 +265,22 @@ static void mlx4_en_free_rx_buf(struct m
 
 	/* Unmap and free Rx buffers */
 	BUG_ON((u32) (ring->prod - ring->cons) > ring->actual_size);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ring->cons != ring->prod) {
 		index = ring->cons & ring->size_mask;
 		en_dbg(DRV, priv, "Processing descriptor:%d\n", index);
 		mlx4_en_free_rx_desc(priv, ring, index);
 		++ring->cons;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -552,7 +574,12 @@ int mlx4_en_process_rx_cq(struct net_dev
 	cqe = &cq->buf[index];
 
 	/* Process all completed CQEs */
-	while (XNOR(cqe->owner_sr_opcode & MLX4_CQE_OWNER_MASK,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (XNOR(cqe->owner_sr_opcode & MLX4_CQE_OWNER_MASK,
 		    cq->mcq.cons_index & cq->size)) {
 
 		skb_frags = ring->rx_info + (index << priv->log_rx_info);
@@ -673,7 +700,13 @@ next:
 			 * flush only pending LRO sessions */
 			goto out;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	AVG_PERF_COUNTER(priv->pstats.rx_coal_avg, polled);
@@ -746,7 +779,12 @@ void mlx4_en_calc_rx_buf(struct net_devi
 	int buf_size = 0;
 	int i = 0;
 
-	while (buf_size < eff_mtu) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (buf_size < eff_mtu) {
 		priv->frag_info[i].frag_size =
 			(eff_mtu > buf_size + frag_sizes[i]) ?
 				frag_sizes[i] : eff_mtu - buf_size;
@@ -765,6 +803,12 @@ void mlx4_en_calc_rx_buf(struct net_devi
 						priv->frag_info[i].frag_align);
 		buf_size += priv->frag_info[i].frag_size;
 		i++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	priv->num_frags = i;
diff -u -p a/net/ethernet/mellanox/mlx4/en_tx.c b/net/ethernet/mellanox/mlx4/en_tx.c
--- a/net/ethernet/mellanox/mlx4/en_tx.c
+++ b/net/ethernet/mellanox/mlx4/en_tx.c
@@ -293,12 +293,23 @@ int mlx4_en_free_tx_buf(struct net_devic
 		return 0;
 	}
 
-	while (ring->cons != ring->prod) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ring->cons != ring->prod) {
 		ring->last_nr_txbb = mlx4_en_free_tx_desc(priv, ring,
 						ring->cons & ring->size_mask,
 						!!(ring->cons & ring->size));
 		ring->cons += ring->last_nr_txbb;
 		cnt++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (cnt)
diff -u -p a/net/ethernet/mellanox/mlx4/alloc.c b/net/ethernet/mellanox/mlx4/alloc.c
--- a/net/ethernet/mellanox/mlx4/alloc.c
+++ b/net/ethernet/mellanox/mlx4/alloc.c
@@ -183,9 +183,20 @@ int mlx4_buf_alloc(struct mlx4_dev *dev,
 
 		buf->direct.map = t;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (t & ((1 << buf->page_shift) - 1)) {
 			--buf->page_shift;
 			buf->npages *= 2;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 
 		memset(buf->direct.buf, 0, size);
diff -u -p a/net/ethernet/netx-eth.c b/net/ethernet/netx-eth.c
--- a/net/ethernet/netx-eth.c
+++ b/net/ethernet/netx-eth.c
@@ -182,6 +182,11 @@ netx_eth_interrupt(int irq, void *dev_id
 	spin_lock_irqsave(&priv->lock, flags);
 
 	status = readl(NETX_PFIFO_XPEC_ISR(priv->id));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status) {
 		int fill_level;
 		writel(status, NETX_PFIFO_XPEC_ISR(priv->id));
@@ -202,6 +207,12 @@ netx_eth_interrupt(int irq, void *dev_id
 			mii_check_media(&priv->mii, netif_msg_link(priv), 1);
 
 		status = readl(NETX_PFIFO_XPEC_ISR(priv->id));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&priv->lock, flags);
 	return IRQ_HANDLED;
diff -u -p a/net/sb1000.c b/net/sb1000.c
--- a/net/sb1000.c
+++ b/net/sb1000.c
@@ -266,7 +266,12 @@ card_wait_for_busy_clear(const int ioadd
 
 	a = inb(ioaddr[0] + 7);
 	timeout = jiffies + TimeOutJiffies;
-	while (a & 0x80 || a & 0x40) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (a & 0x80 || a & 0x40) {
 		/* a little sleep */
 		yield();
 
@@ -276,6 +281,12 @@ card_wait_for_busy_clear(const int ioadd
 				name);
 			return -ETIME;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -290,7 +301,12 @@ card_wait_for_ready(const int ioaddr[],
 
 	a = inb(ioaddr[1] + 6);
 	timeout = jiffies + TimeOutJiffies;
-	while (a & 0x80 || !(a & 0x40)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (a & 0x80 || !(a & 0x40)) {
 		/* a little sleep */
 		yield();
 
@@ -300,6 +316,12 @@ card_wait_for_ready(const int ioaddr[],
 				name);
 			return -ETIME;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	in[1] = inb(ioaddr[0] + 1);
@@ -368,20 +390,42 @@ sb1000_wait_for_ready(const int ioaddr[]
 	unsigned long timeout;
 
 	timeout = jiffies + Sb1000TimeOutJiffies;
-	while (inb(ioaddr[1] + 6) & 0x80) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb(ioaddr[1] + 6) & 0x80) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready timeout\n",
 				name);
 			return -ETIME;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	timeout = jiffies + Sb1000TimeOutJiffies;
-	while (!(inb(ioaddr[1] + 6) & 0x40)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(inb(ioaddr[1] + 6) & 0x40)) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready timeout\n",
 				name);
 			return -ETIME;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	inb(ioaddr[0] + 7);
 	return 0;
@@ -394,20 +438,42 @@ sb1000_wait_for_ready_clear(const int io
 	unsigned long timeout;
 
 	timeout = jiffies + Sb1000TimeOutJiffies;
-	while (inb(ioaddr[1] + 6) & 0x80) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb(ioaddr[1] + 6) & 0x80) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready_clear timeout\n",
 				name);
 			return -ETIME;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	timeout = jiffies + Sb1000TimeOutJiffies;
-	while (inb(ioaddr[1] + 6) & 0x40) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (inb(ioaddr[1] + 6) & 0x40) {
 		if (time_after_eq(jiffies, timeout)) {
 			printk(KERN_WARNING "%s: sb1000_wait_for_ready_clear timeout\n",
 				name);
 			return -ETIME;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/net/hamradio/baycom_epp.c b/net/hamradio/baycom_epp.c
--- a/net/hamradio/baycom_epp.c
+++ b/net/hamradio/baycom_epp.c
@@ -879,6 +879,11 @@ static int epp_open(struct net_device *d
 	/* autoprobe baud rate */
 	tstart = jiffies;
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, tstart + HZ/3)) {
 		if (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)
 			goto epptimeout;
@@ -891,6 +896,12 @@ static int epp_open(struct net_device *d
 		if (pp->ops->epp_read_data(pp, tmp, 128, 0) != 128)
 			goto epptimeout;
 		i += 256;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	for (j = 0; j < 256; j++) {
 		if (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)
diff -u -p a/net/hamradio/yam.c b/net/hamradio/yam.c
--- a/net/hamradio/yam.c
+++ b/net/hamradio/yam.c
@@ -393,12 +393,23 @@ static unsigned char *add_mcs(unsigned c
 
 	/* If it already exists, replace the bit data */
 	p = yam_data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		if (p->bitrate == bitrate) {
 			memcpy(p->bits, bits, YAM_FPGA_SIZE);
 			goto out;
 		}
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Allocate a new mcs */
@@ -421,10 +432,21 @@ static unsigned char *get_mcs(int bitrat
 	struct yam_mcs *p;
 
 	p = yam_data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		if (p->bitrate == bitrate)
 			return p->bits;
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+	}
+	else {
+			break;
+	}
 	}
 
 	/* Load predefined mcs data */
@@ -1196,10 +1218,21 @@ static void __exit yam_cleanup_driver(vo
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (yam_data) {
 		p = yam_data;
 		yam_data = yam_data->next;
 		kfree(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	proc_net_remove(&init_net, "yam");
diff -u -p a/net/hamradio/hdlcdrv.c b/net/hamradio/hdlcdrv.c
--- a/net/hamradio/hdlcdrv.c
+++ b/net/hamradio/hdlcdrv.c
@@ -175,7 +175,12 @@ void hdlcdrv_receiver(struct net_device
 	if (test_and_set_bit(0, &s->hdlcrx.in_hdlc_rx))
 		return;
 
-	while (!hdlcdrv_hbuf_empty(&s->hdlcrx.hbuf)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!hdlcdrv_hbuf_empty(&s->hdlcrx.hbuf)) {
 		word = hdlcdrv_hbuf_get(&s->hdlcrx.hbuf);	
 
 #ifdef HDLCDRV_DEBUG
@@ -215,6 +220,12 @@ void hdlcdrv_receiver(struct net_device
 		}
 		s->hdlcrx.numbits -= hdlc_rx_add_bytes(s, s->hdlcrx.bitbuf,
 						       s->hdlcrx.numbits);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	clear_bit(0, &s->hdlcrx.in_hdlc_rx);
 }
diff -u -p a/net/hamradio/baycom_ser_fdx.c b/net/hamradio/baycom_ser_fdx.c
--- a/net/hamradio/baycom_ser_fdx.c
+++ b/net/hamradio/baycom_ser_fdx.c
@@ -238,6 +238,11 @@ static __inline__ void ser12_rx(struct n
 	timediff = 1000000 + tv->tv_usec - bc->modem.ser12.pll_time;
 	while (timediff >= 500000)
 		timediff -= 1000000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (timediff >= bdus2) {
 		timediff -= bc->baud_us;
 		bc->modem.ser12.pll_time += bc->baud_us;
@@ -249,6 +254,12 @@ static __inline__ void ser12_rx(struct n
 		}
 		/* add a one bit */
 		bc->modem.shreg >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (bc->modem.ser12.dcd_time <= 0) {
 		if (!bc->opt_dcd)
diff -u -p a/net/hamradio/6pack.c b/net/hamradio/6pack.c
--- a/net/hamradio/6pack.c
+++ b/net/hamradio/6pack.c
@@ -475,6 +475,11 @@ static void sixpack_receive_buf(struct t
 	/* Read the characters out of the buffer */
 
 	count1 = count;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		count--;
 		if (fp && *fp++) {
@@ -482,6 +487,12 @@ static void sixpack_receive_buf(struct t
 				sp->dev->stats.rx_errors++;
 			continue;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	sixpack_decode(sp, buf, count1);
 
diff -u -p a/net/hamradio/dmascc.c b/net/hamradio/dmascc.c
--- a/net/hamradio/dmascc.c
+++ b/net/hamradio/dmascc.c
@@ -282,6 +282,11 @@ static void __exit dmascc_exit(void)
 	int i;
 	struct scc_info *info;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (first) {
 		info = first;
 
@@ -302,6 +307,12 @@ static void __exit dmascc_exit(void)
 		/* Free memory */
 		first = info->next;
 		kfree(info);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1142,6 +1153,11 @@ static irqreturn_t scc_isr(int irq, void
 
 	if (info->priv[0].type == TYPE_TWIN) {
 		int is, card_base = info->priv[0].card_base;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((is = ~inb(card_base + TWIN_INT_REG)) &
 		       TWIN_INT_MSK) {
 			if (is & TWIN_SCC_MSK) {
@@ -1153,6 +1169,12 @@ static irqreturn_t scc_isr(int irq, void
 				inb(card_base + TWIN_CLR_TMR2);
 				tm_isr(&info->priv[1]);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else
 		z8530_isr(info);
@@ -1171,7 +1193,12 @@ static void rx_isr(struct scc_priv *priv
 		/* Check special condition for each character. Error reset not necessary.
 		   Same algorithm for SCC and ESCC. See 2.4.7.1 and 2.4.7.4. */
 		int rc;
-		while (read_scc(priv, R0) & Rx_CH_AV) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (read_scc(priv, R0) & Rx_CH_AV) {
 			rc = read_scc(priv, R1);
 			if (priv->rx_ptr < BUF_SIZE)
 				priv->rx_buf[priv->rx_head][priv->
@@ -1182,6 +1209,12 @@ static void rx_isr(struct scc_priv *priv
 				read_scc_data(priv);
 			}
 			special_condition(priv, rc);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -1263,6 +1296,11 @@ static void rx_bh(struct work_struct *ug
 	unsigned char *data;
 
 	spin_lock_irqsave(&priv->ring_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (priv->rx_count) {
 		spin_unlock_irqrestore(&priv->ring_lock, flags);
 		cb = priv->rx_len[i];
@@ -1285,6 +1323,12 @@ static void rx_bh(struct work_struct *ug
 		/* Move tail */
 		priv->rx_tail = i = (i + 1) % NUM_RX_BUF;
 		priv->rx_count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&priv->ring_lock, flags);
 }
@@ -1302,8 +1346,19 @@ static void tx_isr(struct scc_priv *priv
 	}
 
 	/* Write characters */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((read_scc(priv, R0) & Tx_BUF_EMP) && p < priv->tx_len[i]) {
 		write_scc_data(priv, priv->tx_buf[i][p++], 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Reset EOM latch of Z8530 */
diff -u -p a/net/hamradio/bpqether.c b/net/hamradio/bpqether.c
--- a/net/hamradio/bpqether.c
+++ b/net/hamradio/bpqether.c
@@ -614,9 +614,20 @@ static void __exit bpq_cleanup_driver(vo
 	proc_net_remove(&init_net, "bpqether");
 
 	rtnl_lock();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&bpq_devices)) {
 		bpq = list_entry(bpq_devices.next, struct bpqdev, bpq_list);
 		bpq_free_device(bpq->axdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	rtnl_unlock();
 }
diff -u -p a/net/xen-netfront.c b/net/xen-netfront.c
--- a/net/xen-netfront.c
+++ b/net/xen-netfront.c
@@ -424,6 +424,11 @@ static void xennet_make_frags(struct sk_
 
 	/* While the header overlaps a page boundary (including being
 	   larger than a page), split it it into page-sized chunks. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len > PAGE_SIZE - offset) {
 		tx->size = PAGE_SIZE - offset;
 		tx->flags |= XEN_NETTXF_more_data;
@@ -446,6 +451,12 @@ static void xennet_make_frags(struct sk_
 		tx->offset = offset;
 		tx->size = len;
 		tx->flags = 0;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Grant backend access to each skb fragment page. */
@@ -774,7 +785,12 @@ static RING_IDX xennet_fill_frags(struct
 	RING_IDX cons = np->rx.rsp_cons;
 	struct sk_buff *nskb;
 
-	while ((nskb = __skb_dequeue(list))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((nskb = __skb_dequeue(list))) {
 		struct xen_netif_rx_response *rx =
 			RING_GET_RESPONSE(&np->rx, ++cons);
 		skb_frag_t *nfrag = &skb_shinfo(nskb)->frags[0];
@@ -789,6 +805,12 @@ static RING_IDX xennet_fill_frags(struct
 		kfree_skb(nskb);
 
 		nr_frags++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	shinfo->nr_frags = nr_frags;
@@ -935,6 +957,11 @@ static int xennet_poll(struct napi_struc
 
 	i = np->rx.rsp_cons;
 	work_done = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((i != rp) && (work_done < budget)) {
 		memcpy(rx, RING_GET_RESPONSE(&np->rx, i), sizeof(*rx));
 		memset(extras, 0, sizeof(rinfo.extras));
@@ -1019,6 +1046,12 @@ err:
 
 		np->rx.rsp_cons = ++i;
 		work_done++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	__skb_queue_purge(&errq);
diff -u -p a/net/virtio_net.c b/net/virtio_net.c
--- a/net/virtio_net.c
+++ b/net/virtio_net.c
@@ -206,10 +206,21 @@ static struct sk_buff *page_to_skb(struc
 		return NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		set_skb_frag(skb, page, offset, &len);
 		page = (struct page *)page->private;
 		offset = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (page)
diff -u -p a/net/tokenring/smctr.c b/net/tokenring/smctr.c
--- a/net/tokenring/smctr.c
+++ b/net/tokenring/smctr.c
@@ -771,6 +771,11 @@ static int smctr_decode_firmware(struct
                         + (tsize * sizeof(DECODE_TREE_NODE)));
         mem     = (__u16 *)(tp->ram_access);
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while(weight)
         {
                 branch = ROOT;
@@ -798,6 +803,12 @@ static int smctr_decode_firmware(struct
                         buff    = 0;
                         shift   = 12;
                 }
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
         }
 
         /* The following assumes the Control Store Memory has
diff -u -p a/net/tokenring/ibmtr.c b/net/tokenring/ibmtr.c
--- a/net/tokenring/ibmtr.c
+++ b/net/tokenring/ibmtr.c
@@ -525,11 +525,22 @@ static int __devinit ibmtr_probe1(struct
 		} else
 			irq=t_irq;
 		timeout = jiffies + TR_SPIN_INTERVAL;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!readb(ti->mmio + ACA_OFFSET + ACA_RW + RRR_EVEN)){
 			if (!time_after(jiffies, timeout)) continue;
 			DPRINTK( "Hardware timeout during initialization.\n");
 			iounmap(t_mmio);
 			return -ENODEV;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		ti->sram_phys =
 		     ((__u32)readb(ti->mmio+ACA_OFFSET+ACA_RW+RRR_EVEN)<<12);
diff -u -p a/net/tokenring/3c359.c b/net/tokenring/3c359.c
--- a/net/tokenring/3c359.c
+++ b/net/tokenring/3c359.c
@@ -437,12 +437,23 @@ static int xl_hw_reset(struct net_device
 	 */
 
 	t=jiffies;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) { 
 		schedule();		
 		if (time_after(jiffies, t + 40 * HZ)) {
 			printk(KERN_ERR "%s: 3COM 3C359 Velocity XL  card not responding to global reset.\n", dev->name);
 			return -ENODEV;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -553,12 +564,23 @@ static int xl_hw_reset(struct net_device
 	writew(SETINDENABLE | 0xFFF, xl_mmio + MMIO_COMMAND) ; 
 
 	t=jiffies;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ( !(readw(xl_mmio + MMIO_INTSTATUS_AUTO) & INTSTAT_SRB) ) { 
 		schedule();		
 		if (time_after(jiffies, t + 15 * HZ)) {
 			printk(KERN_ERR "3COM 3C359 Velocity XL  card not responding.\n");
 			return -ENODEV; 
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -931,6 +953,11 @@ static void xl_rx(struct net_device *dev
   	 * have been received.
 	 */ 	 
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].framestatus & (RXUPDCOMPLETE | RXUPDFULL) ) { /* Descriptor to process */
 
 		if (xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].framestatus & RXUPDFULL ) { /* UpdFull, Multiple Descriptors used for the frame */
@@ -942,9 +969,20 @@ static void xl_rx(struct net_device *dev
 
 			temp_ring_loc = xl_priv->rx_ring_tail ; 
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (xl_priv->xl_rx_ring[temp_ring_loc].framestatus & RXUPDFULL ) {
 				temp_ring_loc++ ; 
 				temp_ring_loc &= (XL_RX_RING_SIZE-1) ; 
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			frame_length = le32_to_cpu(xl_priv->xl_rx_ring[temp_ring_loc].framestatus) & 0x7FFF;
@@ -963,6 +1001,11 @@ static void xl_rx(struct net_device *dev
 				return ; 				
 			}
 	
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (xl_priv->rx_ring_tail != temp_ring_loc) { 
 				copy_len = le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfraglen) & 0x7FFF;
 				frame_length -= copy_len ;  
@@ -972,6 +1015,12 @@ static void xl_rx(struct net_device *dev
 							  copy_len);
 				pci_dma_sync_single_for_device(xl_priv->pdev,le32_to_cpu(xl_priv->xl_rx_ring[xl_priv->rx_ring_tail].upfragaddr),xl_priv->pkt_buf_sz,PCI_DMA_FROMDEVICE);
 				adv_rx_ring(dev) ; 
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			} 
 
 			/* Now we have found the last fragment */
@@ -1012,6 +1061,12 @@ static void xl_rx(struct net_device *dev
 
 			netif_rx(skb2) ; 		
 		 } /* if multiple buffers */
+		 if (_cur < timeout) {
+			rdstcll(_cur);
+		 }
+		 else {
+			break;
+		 }
 	} /* while packet to do */
 
 	/* Clear the updComplete interrupt */
@@ -1123,10 +1178,21 @@ static irqreturn_t xl_interrupt(int irq,
 
 			if (intstatus & TXUNDERRUN) { /* Issue DnReset command */
 				writel(DNRESET, xl_mmio + MMIO_MAC_ACCESS_CMD) ; 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (readw(xl_mmio + MMIO_INTSTATUS) & INTSTAT_CMD_IN_PROGRESS) { /* Wait for command to run */
 					/* !!! FIX-ME !!!! 
 					Must put a timeout check here ! */
 					/* Empty Loop */
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				} 
 				printk(KERN_WARNING "%s: TX Underrun received\n",dev->name);
 				writel(ACK_INTERRUPT | LATCH_ACK, xl_mmio + MMIO_COMMAND) ; 
@@ -1267,6 +1333,11 @@ static void xl_dn_comp(struct net_device
 		xl_priv->tx_ring_tail = 1 ; 
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (xl_priv->xl_tx_ring[xl_priv->tx_ring_tail].framestartheader & TXDNCOMPLETE ) { 
 		txd = &(xl_priv->xl_tx_ring[xl_priv->tx_ring_tail]) ;
 		pci_unmap_single(xl_priv->pdev, le32_to_cpu(txd->buffer), xl_priv->tx_ring_skb[xl_priv->tx_ring_tail]->len, PCI_DMA_TODEVICE);
@@ -1277,6 +1348,12 @@ static void xl_dn_comp(struct net_device
 		xl_priv->tx_ring_tail++ ; 
 		xl_priv->tx_ring_tail &= (XL_TX_RING_SIZE - 1) ; 
 		xl_priv->free_ring_entries++ ; 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	netif_wake_queue(dev) ; 
diff -u -p a/net/tokenring/lanstreamer.c b/net/tokenring/lanstreamer.c
--- a/net/tokenring/lanstreamer.c
+++ b/net/tokenring/lanstreamer.c
@@ -510,6 +510,11 @@ static int streamer_reset(struct net_dev
 	/* start solo init */
 	writew(SISR_MI, streamer_mmio + SISR_MASK_SUM);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((readw(streamer_mmio + SISR)) & SISR_SRB_REPLY)) {
 		msleep_interruptible(100);
 		if (time_after(jiffies, t + 40 * HZ)) {
@@ -520,6 +525,12 @@ static int streamer_reset(struct net_dev
 				dev_kfree_skb(skb);
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	writew(~SISR_SRB_REPLY, streamer_mmio + SISR_RUM);
 	misr = readw(streamer_mmio + MISR_RUM);
@@ -909,6 +920,11 @@ static void streamer_rx(struct net_devic
 	rx_desc = &streamer_priv->streamer_rx_ring[(streamer_priv->rx_ring_last_received + 1) & (STREAMER_RX_RING_SIZE - 1)];
 	rx_ring_last_received = streamer_priv->rx_ring_last_received;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rx_desc->status & 0x01000000) {	/* While processed descriptors are available */
 		if (rx_ring_last_received != streamer_priv->rx_ring_last_received) 
 		{
@@ -1016,6 +1032,12 @@ static void streamer_rx(struct net_devic
 
 		/* try the next one */
 		rx_desc = &streamer_priv->streamer_rx_ring[(rx_ring_last_received + 1) & (STREAMER_RX_RING_SIZE - 1)];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}			/* end for all completed rx descriptors */
 }
 
@@ -1050,6 +1072,11 @@ static irqreturn_t streamer_interrupt(in
 			misr = readw(streamer_mmio + MISR_RUM);
 
 		if (misr & MISR_TX2_EOF) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while(streamer_priv->streamer_tx_ring[(streamer_priv->tx_ring_last_status + 1) & (STREAMER_TX_RING_SIZE - 1)].status) {
 				streamer_priv->tx_ring_last_status = (streamer_priv->tx_ring_last_status + 1) & (STREAMER_TX_RING_SIZE - 1);
 				streamer_priv->free_tx_ring_entries++;
@@ -1063,6 +1090,12 @@ static irqreturn_t streamer_interrupt(in
 				streamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].rsvd1 = 0;
 				streamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].rsvd2 = 0;
 				streamer_priv->streamer_tx_ring[streamer_priv->tx_ring_last_status].rsvd3 = 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			netif_wake_queue(dev);
 		}
@@ -1580,11 +1613,22 @@ static void streamer_arb_cmd(struct net_
 				break;
 
 			i = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (i < buffer_len) {
 				rx_word=ntohs(readw(streamer_mmio+LAPDINC));
 				frame_data[i]=rx_word >> 8;
 				frame_data[i+1]=rx_word & 0xff;
 				i += 2;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 
 			memcpy(skb_put(mac_frame, buffer_len),
diff -u -p a/net/tokenring/olympic.c b/net/tokenring/olympic.c
--- a/net/tokenring/olympic.c
+++ b/net/tokenring/olympic.c
@@ -308,12 +308,23 @@ static int olympic_init(struct net_devic
 
 	writel(readl(olympic_mmio+BCTL) | BCTL_SOFTRESET,olympic_mmio+BCTL);
 	t=jiffies;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while((readl(olympic_mmio+BCTL)) & BCTL_SOFTRESET) {
 		schedule();		
 		if(time_after(jiffies, t + 40*HZ)) {
 			printk(KERN_ERR "IBM PCI tokenring card not responding.\n");
 			return -ENODEV;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 
@@ -360,12 +371,23 @@ static int olympic_init(struct net_devic
 
 	if(!(readl(olympic_mmio+BCTL) & BCTL_MODE_INDICATOR)) { 
 		t=jiffies;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(readl(olympic_mmio+CLKCTL) & CLKCTL_PAUSE)) {
 			schedule() ; 
 			if(time_after(jiffies, t + 2*HZ)) {
 				printk(KERN_ERR "IBM Cardbus tokenring adapter not responsing.\n") ; 
 				return -ENODEV;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		writel(readl(olympic_mmio+CLKCTL) & ~CLKCTL_PAUSE, olympic_mmio+CLKCTL) ; 
 	}
@@ -374,12 +396,23 @@ static int olympic_init(struct net_devic
 	writel((1<<15),olympic_mmio+SISR_MASK_SUM);
 
 	t=jiffies;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(!((readl(olympic_mmio+SISR_RR)) & SISR_SRB_REPLY)) {
 		schedule();		
 		if(time_after(jiffies, t + 15*HZ)) {
 			printk(KERN_ERR "IBM PCI tokenring card not responding.\n");
 			return -ENODEV;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	writel(readw(olympic_mmio+LAPWWO),olympic_mmio+LAPA);
@@ -754,6 +787,11 @@ static void olympic_rx(struct net_device
 
 	rx_status=&(olympic_priv->olympic_rx_status_ring[(olympic_priv->rx_status_last_received + 1) & (OLYMPIC_RX_RING_SIZE - 1)]) ; 
  
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rx_status->status_buffercnt) { 
                 u32 l_status_buffercnt;
 
@@ -879,6 +917,12 @@ static void olympic_rx(struct net_device
 		rx_status = &(olympic_priv->olympic_rx_status_ring[(olympic_priv->rx_status_last_received+1) & (OLYMPIC_RX_RING_SIZE -1) ]);
 
 		writew((((readw(olympic_mmio+RXENQ)) & 0x8000) ^ 0x8000) |  buffer_cnt , olympic_mmio+RXENQ); 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} /* while */
 
 }
@@ -969,6 +1013,11 @@ static irqreturn_t olympic_interrupt(int
 		/* We shouldn't ever miss the Tx interrupt, but the you never know, hence the loop to ensure
 		   we get all tx completions. */
 		if (sisr & SISR_TX1_EOF) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(olympic_priv->olympic_tx_status_ring[(olympic_priv->tx_ring_last_status + 1) & (OLYMPIC_TX_RING_SIZE-1)].status) { 
 				olympic_priv->tx_ring_last_status++;
 				olympic_priv->tx_ring_last_status &= (OLYMPIC_TX_RING_SIZE-1);
@@ -981,6 +1030,12 @@ static irqreturn_t olympic_interrupt(int
 				dev_kfree_skb_irq(olympic_priv->tx_ring_skb[olympic_priv->tx_ring_last_status]);
 				olympic_priv->olympic_tx_ring[olympic_priv->tx_ring_last_status].buffer=cpu_to_le32(0xdeadbeef);
 				olympic_priv->olympic_tx_status_ring[olympic_priv->tx_ring_last_status].status=0;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			netif_wake_queue(dev);
 		} /* SISR_TX1_EOF */
diff -u -p a/net/netconsole.c b/net/netconsole.c
--- a/net/netconsole.c
+++ b/net/netconsole.c
@@ -732,6 +732,11 @@ static int __init init_netconsole(void)
 	char *input = config;
 
 	if (strnlen(input, MAX_PARAM_LENGTH)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((target_config = strsep(&input, ";"))) {
 			nt = alloc_param_target(target_config);
 			if (IS_ERR(nt)) {
@@ -744,6 +749,12 @@ static int __init init_netconsole(void)
 			spin_lock_irqsave(&target_list_lock, flags);
 			list_add(&nt->list, &target_list);
 			spin_unlock_irqrestore(&target_list_lock, flags);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/rionet.c b/net/rionet.c
--- a/net/rionet.c
+++ b/net/rionet.c
@@ -276,6 +276,11 @@ static void rionet_outb_msg_event(struct
 		       "%s: outbound message event, mbox %d slot %d\n",
 		       DRV_NAME, mbox, slot);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rnet->tx_cnt && (rnet->ack_slot != slot)) {
 		/* dma unmap single */
 		dev_kfree_skb_irq(rnet->tx_skb[rnet->ack_slot]);
@@ -283,6 +288,12 @@ static void rionet_outb_msg_event(struct
 		++rnet->ack_slot;
 		rnet->ack_slot &= (RIONET_TX_RING_SIZE - 1);
 		rnet->tx_cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (rnet->tx_cnt < RIONET_TX_RING_SIZE)
diff -u -p a/net/wireless/b43/phy_lp.c b/net/wireless/b43/phy_lp.c
--- a/net/wireless/b43/phy_lp.c
+++ b/net/wireless/b43/phy_lp.c
@@ -2582,9 +2582,20 @@ static int lpphy_b2063_tune(struct b43_w
 
 	tmp1 = ((val3 * 62500) / freqref) << 4;
 	tmp2 = ((val3 * 62500) % freqref) << 4;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmp2 >= freqref) {
 		tmp1++;
 		tmp2 -= freqref;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG1, 0xFFE0, tmp1 >> 4);
 	b43_radio_maskset(dev, B2063_PLL_JTAG_PLL_SG2, 0xFE0F, tmp1 << 4);
diff -u -p a/net/wireless/b43/main.c b/net/wireless/b43/main.c
--- a/net/wireless/b43/main.c
+++ b/net/wireless/b43/main.c
@@ -3380,7 +3380,12 @@ static void b43_tx_work(struct work_stru
 		return;
 	}
 
-	while (skb_queue_len(&wl->tx_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (skb_queue_len(&wl->tx_queue)) {
 		skb = skb_dequeue(&wl->tx_queue);
 
 		if (b43_using_pio_transfers(dev))
@@ -3389,7 +3394,13 @@ static void b43_tx_work(struct work_stru
 			err = b43_dma_tx(dev, skb);
 		if (unlikely(err))
 			dev_kfree_skb(skb); /* Drop it */
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+}
 
 #if B43_DEBUG
 	dev->tx_count++;
diff -u -p a/net/wireless/b43/sdio.c b/net/wireless/b43/sdio.c
--- a/net/wireless/b43/sdio.c
+++ b/net/wireless/b43/sdio.c
@@ -103,6 +103,11 @@ static int __devinit b43_sdio_probe(stru
 
 	/* Look for the card chip identifier. */
 	tuple = func->tuples;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tuple) {
 		switch (tuple->code) {
 		case 0x80:
@@ -123,6 +128,12 @@ static int __devinit b43_sdio_probe(stru
 			break;
 		}
 		tuple = tuple->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!vendor || !device) {
 		error = -ENODEV;
diff -u -p a/net/wireless/ath/ath5k/phy.c b/net/wireless/ath/ath5k/phy.c
--- a/net/wireless/ath/ath5k/phy.c
+++ b/net/wireless/ath/ath5k/phy.c
@@ -2719,12 +2719,23 @@ ath5k_combine_pwr_to_pdadc_curves(struct
 			pwr_step = 1;
 
 		/* Extrapolate above */
-		while ((pdadc_0 < (s16) pdadc_n) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((pdadc_0 < (s16) pdadc_n) &&
 		(pdadc_i < AR5K_EEPROM_POWER_TABLE_SIZE * 2)) {
 			s16 tmp = pdadc_tmp[table_size - 1] +
 					(pdadc_0 - max_idx) * pwr_step;
 			pdadc_out[pdadc_i++] = (tmp > 127) ? 127 : (u8) tmp;
 			pdadc_0++;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
@@ -2733,9 +2744,20 @@ ath5k_combine_pwr_to_pdadc_curves(struct
 		pdg++;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pdadc_i < AR5K_EEPROM_POWER_TABLE_SIZE * 2) {
 		pdadc_out[pdadc_i] = pdadc_out[pdadc_i - 1];
 		pdadc_i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Set gain boundaries */
diff -u -p a/net/wireless/ath/ath9k/hw.c b/net/wireless/ath/ath9k/hw.c
--- a/net/wireless/ath/ath9k/hw.c
+++ b/net/wireless/ath/ath9k/hw.c
@@ -2337,6 +2337,11 @@ int ath9k_hw_fill_cap_info(struct ath_hw
 
 	tx_chainmask = pCap->tx_chainmask;
 	rx_chainmask = pCap->rx_chainmask;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tx_chainmask || rx_chainmask) {
 		if (tx_chainmask & BIT(0))
 			pCap->max_txchains++;
@@ -2345,6 +2350,12 @@ int ath9k_hw_fill_cap_info(struct ath_hw
 
 		tx_chainmask >>= 1;
 		rx_chainmask >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (AR_SREV_9300_20_OR_LATER(ah)) {
@@ -2878,22 +2889,44 @@ void ath_gen_timer_isr(struct ath_hw *ah
 
 	trigger_mask &= ~thresh_mask;
 
-	while (thresh_mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (thresh_mask) {
 		index = rightmost_index(timer_table, &thresh_mask);
 		timer = timer_table->timers[index];
 		BUG_ON(!timer);
 		ath_dbg(common, ATH_DBG_HWTIMER,
 			"TSF overflow for Gen timer %d\n", index);
 		timer->overflow(timer->arg);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
-	while (trigger_mask) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (trigger_mask) {
 		index = rightmost_index(timer_table, &trigger_mask);
 		timer = timer_table->timers[index];
 		BUG_ON(!timer);
 		ath_dbg(common, ATH_DBG_HWTIMER,
 			"Gen timer[%d] trigger\n", index);
 		timer->trigger(timer->arg);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 EXPORT_SYMBOL(ath_gen_timer_isr);
diff -u -p a/net/wireless/ath/ath9k/rc.c b/net/wireless/ath/ath9k/rc.c
--- a/net/wireless/ath/ath9k/rc.c
+++ b/net/wireless/ath/ath9k/rc.c
@@ -388,8 +388,19 @@ static int ath_rc_get_rateindex(const st
 	if (!(rate->flags & IEEE80211_TX_RC_MCS))
 		return rate->idx;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < ARRAY_SIZE(mcs_rix_off) && rate->idx > mcs_rix_off[i]) {
 		rix++; i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rix += rate->idx + rate_table->mcs_start;
diff -u -p a/net/wireless/ath/ath9k/hif_usb.c b/net/wireless/ath/ath9k/hif_usb.c
--- a/net/wireless/ath/ath9k/hif_usb.c
+++ b/net/wireless/ath/ath9k/hif_usb.c
@@ -553,6 +553,11 @@ static void ath9k_hif_usb_rx_stream(stru
 
 	spin_unlock(&hif_dev->rx_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (index < len) {
 		u16 pkt_len;
 		u16 pkt_tag;
@@ -613,7 +618,13 @@ static void ath9k_hif_usb_rx_stream(stru
 			skb_put(nskb, pkt_len);
 			skb_pool[pool_index++] = nskb;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 err:
 	for (i = 0; i < pool_index; i++) {
@@ -981,6 +992,11 @@ static int ath9k_hif_usb_download_fw(str
 	if (!buf)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		transfer = min_t(int, len, 4096);
 		memcpy(buf, data, transfer);
@@ -997,6 +1013,12 @@ static int ath9k_hif_usb_download_fw(str
 		len -= transfer;
 		data += transfer;
 		addr += transfer;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(buf);
 
diff -u -p a/net/wireless/ath/ath9k/beacon.c b/net/wireless/ath/ath9k/beacon.c
--- a/net/wireless/ath/ath9k/beacon.c
+++ b/net/wireless/ath/ath9k/beacon.c
@@ -213,9 +213,20 @@ static struct ath_buf *ath_beacon_genera
 
 	ath_beacon_setup(sc, avp, bf, info->control.rates[0].idx);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb) {
 		ath_tx_cabq(hw, skb);
 		skb = ieee80211_get_buffered_bc(hw, vif);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return bf;
diff -u -p a/net/wireless/ath/ath9k/eeprom.c b/net/wireless/ath/ath9k/eeprom.c
--- a/net/wireless/ath/ath9k/eeprom.c
+++ b/net/wireless/ath/ath9k/eeprom.c
@@ -483,8 +483,19 @@ void ath9k_hw_get_gain_boundaries_pdadcs
 		maxIndex = (tgtIndex < sizeCurrVpdTable) ?
 			tgtIndex : sizeCurrVpdTable;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((ss < maxIndex) && (k < (AR5416_NUM_PDADC_VALUES - 1))) {
 			pPDADCValues[k++] = vpdTableI[i][ss++];
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 
 		vpdStep = (int16_t)(vpdTableI[i][sizeCurrVpdTable - 1] -
@@ -492,13 +503,24 @@ void ath9k_hw_get_gain_boundaries_pdadcs
 		vpdStep = (int16_t)((vpdStep < 1) ? 1 : vpdStep);
 
 		if (tgtIndex >= maxIndex) {
-			while ((ss <= tgtIndex) &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((ss <= tgtIndex) &&
 			       (k < (AR5416_NUM_PDADC_VALUES - 1))) {
 				tmpVal = (int16_t)((vpdTableI[i][sizeCurrVpdTable - 1] +
 						    (ss - maxIndex + 1) * vpdStep));
 				pPDADCValues[k++] = (u8)((tmpVal > 255) ?
 							 255 : tmpVal);
 				ss++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
diff -u -p a/net/wireless/ath/ath9k/ar9003_eeprom.c b/net/wireless/ath/ath9k/ar9003_eeprom.c
--- a/net/wireless/ath/ath9k/ar9003_eeprom.c
+++ b/net/wireless/ath/ath9k/ar9003_eeprom.c
@@ -3854,11 +3854,22 @@ static bool is_pmu_set(struct ath_hw *ah
 {
 	int timeout = 100;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pmu_set != REG_READ(ah, pmu_reg)) {
 		if (timeout-- == 0)
 			return false;
 		REG_WRITE(ah, pmu_reg, pmu_set);
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return true;
diff -u -p a/net/wireless/ath/ath9k/init.c b/net/wireless/ath/ath9k/init.c
--- a/net/wireless/ath/ath9k/init.c
+++ b/net/wireless/ath/ath9k/init.c
@@ -348,11 +348,22 @@ int ath_descdma_setup(struct ath_softc *
 			ATH_DESC_4KB_BOUND_NUM_SKIPPED(dd->dd_desc_len);
 		u32 dma_len;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ndesc_skipped) {
 			dma_len = ndesc_skipped * desc_len;
 			dd->dd_desc_len += dma_len;
 
 			ndesc_skipped = ATH_DESC_4KB_BOUND_NUM_SKIPPED(dma_len);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 	}
 
@@ -388,7 +399,12 @@ int ath_descdma_setup(struct ath_softc *
 			 * boundary crossing (addr + length) with a 32 dword
 			 * descriptor fetch.
 			 */
-			while (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {
 				BUG_ON((caddr_t) bf->bf_desc >=
 				       ((caddr_t) dd->dd_desc +
 					dd->dd_desc_len));
@@ -396,6 +412,12 @@ int ath_descdma_setup(struct ath_softc *
 				ds += (desc_len * ndesc);
 				bf->bf_desc = ds;
 				bf->bf_daddr = DS2PHYS(dd, ds);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 		list_add_tail(&bf->list, head);
diff -u -p a/net/wireless/ath/ath9k/htc_drv_beacon.c b/net/wireless/ath/ath9k/htc_drv_beacon.c
--- a/net/wireless/ath/ath9k/htc_drv_beacon.c
+++ b/net/wireless/ath/ath9k/htc_drv_beacon.c
@@ -307,6 +307,11 @@ static void ath9k_htc_send_buffered(stru
 
 	skb = ieee80211_get_buffered_bc(priv->hw, vif);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(skb) {
 		hdr = (struct ieee80211_hdr *) skb->data;
 
@@ -342,6 +347,12 @@ static void ath9k_htc_send_buffered(stru
 		}
 	next:
 		skb = ieee80211_get_buffered_bc(priv->hw, vif);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock_bh(&priv->beacon_lock);
diff -u -p a/net/wireless/ath/ath9k/xmit.c b/net/wireless/ath/ath9k/xmit.c
--- a/net/wireless/ath/ath9k/xmit.c
+++ b/net/wireless/ath/ath9k/xmit.c
@@ -165,6 +165,11 @@ static void ath_tx_flush_tid(struct ath_
 	memset(&ts, 0, sizeof(ts));
 	spin_lock_bh(&txq->axq_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = __skb_dequeue(&tid->buf_q))) {
 		fi = get_frame_info(skb);
 		bf = fi->bf;
@@ -178,6 +183,12 @@ static void ath_tx_flush_tid(struct ath_
 			ath_tx_send_normal(sc, txq, NULL, skb);
 		}
 		spin_lock_bh(&txq->axq_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_bh(&txq->axq_lock);
@@ -193,9 +204,20 @@ static void ath_tx_update_baw(struct ath
 
 	__clear_bit(cindex, tid->tx_buf);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tid->baw_head != tid->baw_tail && !test_bit(tid->baw_head, tid->tx_buf)) {
 		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
 		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -234,6 +256,11 @@ static void ath_tid_drain(struct ath_sof
 	memset(&ts, 0, sizeof(ts));
 	INIT_LIST_HEAD(&bf_head);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = __skb_dequeue(&tid->buf_q))) {
 		fi = get_frame_info(skb);
 		bf = fi->bf;
@@ -253,6 +280,12 @@ static void ath_tid_drain(struct ath_sof
 		spin_unlock(&txq->axq_lock);
 		ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0, 0);
 		spin_lock(&txq->axq_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tid->seq_next = tid->seq_start;
@@ -340,6 +373,11 @@ static void ath_tx_count_frames(struct a
 		memcpy(ba, &ts->ba_low, WME_BA_BMP_SIZE >> 3);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bf) {
 		fi = get_frame_info(bf->bf_mpdu);
 		ba_index = ATH_BA_INDEX(seq_st, bf->bf_state.seqno);
@@ -349,6 +387,12 @@ static void ath_tx_count_frames(struct a
 			(*nbad)++;
 
 		bf = bf->bf_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -391,7 +435,12 @@ static void ath_tx_complete_aggr(struct
 		rcu_read_unlock();
 
 		INIT_LIST_HEAD(&bf_head);
-		while (bf) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bf) {
 			bf_next = bf->bf_next;
 
 			if (!bf->bf_stale || bf_next != NULL)
@@ -401,6 +450,12 @@ static void ath_tx_complete_aggr(struct
 				0, 0);
 
 			bf = bf_next;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		return;
 	}
@@ -1028,6 +1083,11 @@ static void ath_tx_fill_desc(struct ath_
 		info.flags |= (u32) bf->bf_state.bfs_paprd << ATH9K_TXDESC_PAPRD_S;
 
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bf) {
 		struct sk_buff *skb = bf->bf_mpdu;
 		struct ath_frame_info *fi = get_frame_info(skb);
@@ -1058,6 +1118,12 @@ static void ath_tx_fill_desc(struct ath_
 
 		ath9k_hw_set_txdesc(ah, bf->bf_desc, &info);
 		bf = bf->bf_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1416,6 +1482,11 @@ static void ath_drain_txq_list(struct at
 	ts.ts_status = ATH9K_TX_FLUSH;
 	INIT_LIST_HEAD(&bf_head);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(list)) {
 		bf = list_first_entry(list, struct ath_buf, list);
 
@@ -1440,6 +1511,12 @@ static void ath_drain_txq_list(struct at
 		else
 			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0, 0);
 		spin_lock_bh(&txq->axq_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1455,11 +1532,22 @@ void ath_draintxq(struct ath_softc *sc,
 	if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {
 		int idx = txq->txq_tailidx;
 
-		while (!list_empty(&txq->txq_fifo[idx])) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&txq->txq_fifo[idx])) {
 			ath_drain_txq_list(sc, txq, &txq->txq_fifo[idx],
 					   retry_tx);
 
 			INCR(idx, ATH_TXFIFO_DEPTH);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		txq->txq_tailidx = idx;
 	}
diff -u -p a/net/wireless/ath/ath6kl/debug.c b/net/wireless/ath/ath6kl/debug.c
--- a/net/wireless/ath/ath6kl/debug.c
+++ b/net/wireless/ath/ath6kl/debug.c
@@ -320,7 +320,12 @@ static ssize_t ath6kl_fwlog_read(struct
 
 	spin_lock_bh(&ar->debug.fwlog_lock);
 
-	while (len < buf_len && !ath6kl_debug_fwlog_empty(ar)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len < buf_len && !ath6kl_debug_fwlog_empty(ar)) {
 		ccnt = CIRC_CNT_TO_END(fwlog->head, fwlog->tail,
 				       ATH6KL_FWLOG_SIZE);
 
@@ -332,6 +337,12 @@ static ssize_t ath6kl_fwlog_read(struct
 
 		fwlog->tail = (fwlog->tail + ccnt) &
 			(ATH6KL_FWLOG_SIZE - 1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	spin_unlock_bh(&ar->debug.fwlog_lock);
diff -u -p a/net/wireless/ath/ath6kl/bmi.c b/net/wireless/ath/ath6kl/bmi.c
--- a/net/wireless/ath/ath6kl/bmi.c
+++ b/net/wireless/ath/ath6kl/bmi.c
@@ -31,7 +31,12 @@ static int ath6kl_get_bmi_cmd_credits(st
 	addr = COUNT_DEC_ADDRESS + (HTC_MAILBOX_NUM_MAX + ENDPOINT1) * 4;
 
 	timeout = jiffies + msecs_to_jiffies(BMI_COMMUNICATION_TIMEOUT);
-	while (time_before(jiffies, timeout) && !ar->bmi.cmd_credits) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, timeout) && !ar->bmi.cmd_credits) {
 
 		/*
 		 * Hit the credit counter with a 4-byte access, the first byte
@@ -52,6 +57,12 @@ static int ath6kl_get_bmi_cmd_credits(st
 		 * Ignore anything in the upper 3 bytes
 		 */
 		ar->bmi.cmd_credits &= 0xFF;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!ar->bmi.cmd_credits) {
@@ -69,7 +80,12 @@ static int ath6kl_bmi_get_rx_lkahd(struc
 	int ret = 0;
 
 	timeout = jiffies + msecs_to_jiffies(BMI_COMMUNICATION_TIMEOUT);
-	while (time_before(jiffies, timeout) && !rx_word) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, timeout) && !rx_word) {
 		ret = hif_read_write_sync(ar, RX_LOOKAHEAD_VALID_ADDRESS,
 					  (u8 *)&rx_word, sizeof(rx_word),
 					  HIF_RD_SYNC_BYTE_INC);
@@ -80,6 +96,12 @@ static int ath6kl_bmi_get_rx_lkahd(struc
 
 		 /* all we really want is one bit */
 		rx_word &= (1 << ENDPOINT1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!rx_word) {
@@ -291,7 +313,12 @@ int ath6kl_bmi_read(struct ath6kl *ar, u
 
 	len_remain = len;
 
-	while (len_remain) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len_remain) {
 		rx_len = (len_remain < BMI_DATASZ_MAX) ?
 					len_remain : BMI_DATASZ_MAX;
 		offset = 0;
@@ -316,6 +343,12 @@ int ath6kl_bmi_read(struct ath6kl *ar, u
 		}
 		memcpy(&buf[len - len_remain], ar->bmi.cmd_buf, rx_len);
 		len_remain -= rx_len; addr += rx_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -347,6 +380,11 @@ int ath6kl_bmi_write(struct ath6kl *ar,
 		  "bmi write memory: addr: 0x%x, len: %d\n", addr, len);
 
 	len_remain = len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len_remain) {
 		src = &buf[len - len_remain];
 
@@ -380,6 +418,12 @@ int ath6kl_bmi_write(struct ath6kl *ar,
 			return ret;
 		}
 		len_remain -= tx_len; addr += tx_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -576,7 +620,12 @@ int ath6kl_bmi_lz_data(struct ath6kl *ar
 		   len);
 
 	len_remain = len;
-	while (len_remain) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len_remain) {
 		tx_len = (len_remain < (BMI_DATASZ_MAX - header)) ?
 			  len_remain : (BMI_DATASZ_MAX - header);
 
@@ -597,6 +646,12 @@ int ath6kl_bmi_lz_data(struct ath6kl *ar
 		}
 
 		len_remain -= tx_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/net/wireless/ath/ath6kl/htc.c b/net/wireless/ath/ath6kl/htc.c
--- a/net/wireless/ath/ath6kl/htc.c
+++ b/net/wireless/ath/ath6kl/htc.c
@@ -1688,6 +1688,11 @@ static int ath6kl_htc_rx_fetch(struct ht
 	int status = 0;
 
 	/* now go fetch the list of HTC packets */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(rx_pktq)) {
 		fetched_pkts = 0;
 
@@ -1736,6 +1741,12 @@ static int ath6kl_htc_rx_fetch(struct ht
 
 			list_add_tail(&packet->list, comp_pktq);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return status;
diff -u -p a/net/wireless/ath/ath6kl/sdio.c b/net/wireless/ath/ath6kl/sdio.c
--- a/net/wireless/ath/ath6kl/sdio.c
+++ b/net/wireless/ath/ath6kl/sdio.c
@@ -565,10 +565,21 @@ static void ath6kl_sdio_irq_disable(stru
 	sdio_claim_host(ar_sdio->func);
 
 	/* Mask our function IRQ */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (atomic_read(&ar_sdio->irq_handling)) {
 		sdio_release_host(ar_sdio->func);
 		schedule_timeout(HZ / 10);
 		sdio_claim_host(ar_sdio->func);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = sdio_release_irq(ar_sdio->func);
diff -u -p a/net/wireless/ath/ath6kl/txrx.c b/net/wireless/ath/ath6kl/txrx.c
--- a/net/wireless/ath/ath6kl/txrx.c
+++ b/net/wireless/ath/ath6kl/txrx.c
@@ -531,7 +531,12 @@ void ath6kl_tx_complete(void *context, s
 	spin_lock_bh(&ar->lock);
 
 	/* reap completed packets */
-	while (!list_empty(packet_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(packet_queue)) {
 
 		packet = list_first_entry(packet_queue, struct htc_packet,
 					  list);
@@ -599,6 +604,12 @@ void ath6kl_tx_complete(void *context, s
 
 		if (test_bit(NETQ_STOPPED, &ar->flag))
 			clear_bit(NETQ_STOPPED, &ar->flag);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	spin_unlock_bh(&ar->lock);
@@ -655,6 +666,11 @@ static void ath6kl_alloc_netbufs(struct
 {
 	struct sk_buff *skb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num) {
 		skb = ath6kl_buf_alloc(ATH6KL_BUFFER_SIZE);
 		if (!skb) {
@@ -663,6 +679,12 @@ static void ath6kl_alloc_netbufs(struct
 		}
 		skb_queue_tail(q, skb);
 		num--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -721,6 +743,11 @@ void ath6kl_refill_amsdu_rxbufs(struct a
 	struct htc_packet *packet;
 	struct sk_buff *skb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		skb = ath6kl_buf_alloc(ATH6KL_AMSDU_BUFFER_SIZE);
 		if (!skb)
@@ -735,6 +762,12 @@ void ath6kl_refill_amsdu_rxbufs(struct a
 		list_add_tail(&packet->list, &ar->amsdu_rx_buffer_queue);
 		spin_unlock_bh(&ar->lock);
 		count--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/ath/carl9170/fw.c b/net/wireless/ath/carl9170/fw.c
--- a/net/wireless/ath/carl9170/fw.c
+++ b/net/wireless/ath/carl9170/fw.c
@@ -70,6 +70,11 @@ static int carl9170_fw_verify_descs(stru
 	pos_addr = (unsigned long) pos;
 	end_addr = pos_addr + max_len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos_addr < end_addr) {
 		if (pos_addr + sizeof(*head) > end_addr)
 			return -E2BIG;
@@ -93,6 +98,12 @@ static int carl9170_fw_verify_descs(stru
 		pos_addr += pos_length;
 		pos = (void *)pos_addr;
 		max_len -= pos_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EINVAL;
 }
diff -u -p a/net/wireless/ath/carl9170/rx.c b/net/wireless/ath/carl9170/rx.c
--- a/net/wireless/ath/carl9170/rx.c
+++ b/net/wireless/ath/carl9170/rx.c
@@ -497,6 +497,11 @@ static u8 *carl9170_find_ie(u8 *data, un
 
 	pos = (u8 *)mgmt->u.beacon.variable;
 	end = data + len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -505,6 +510,12 @@ static u8 *carl9170_find_ie(u8 *data, un
 			return pos;
 
 		pos += 2 + pos[1];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/net/wireless/ath/carl9170/usb.c b/net/wireless/ath/carl9170/usb.c
--- a/net/wireless/ath/carl9170/usb.c
+++ b/net/wireless/ath/carl9170/usb.c
@@ -359,12 +359,23 @@ void carl9170_usb_handle_tx_err(struct a
 {
 	struct urb *urb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((urb = usb_get_from_anchor(&ar->tx_err))) {
 		struct sk_buff *skb = (void *)urb->context;
 
 		carl9170_tx_drop(ar, skb);
 		carl9170_tx_callback(ar, skb);
 		usb_free_urb(urb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -549,11 +560,22 @@ static int carl9170_usb_flush(struct ar9
 	struct urb *urb;
 	int ret, err = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((urb = usb_get_from_anchor(&ar->tx_wait))) {
 		struct sk_buff *skb = (void *)urb->context;
 		carl9170_tx_drop(ar, skb);
 		carl9170_tx_callback(ar, skb);
 		usb_free_urb(urb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = usb_wait_anchor_empty_timeout(&ar->tx_cmd, 1000);
@@ -806,6 +828,11 @@ static int carl9170_usb_load_firmware(st
 	data += ar->fw.offset;
 	len -= ar->fw.offset;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		transfer = min_t(unsigned int, len, 4096u);
 		memcpy(buf, data, transfer);
@@ -822,6 +849,12 @@ static int carl9170_usb_load_firmware(st
 		len -= transfer;
 		data += transfer;
 		addr += transfer;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(buf);
 
diff -u -p a/net/wireless/ath/carl9170/main.c b/net/wireless/ath/carl9170/main.c
--- a/net/wireless/ath/carl9170/main.c
+++ b/net/wireless/ath/carl9170/main.c
@@ -204,7 +204,12 @@ static void carl9170_ampdu_gc(struct ar9
 
 	synchronize_rcu();
 
-	while (!list_empty(&tid_gc)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&tid_gc)) {
 		struct sk_buff *skb;
 		tid_info = list_first_entry(&tid_gc, struct carl9170_sta_tid,
 					    tmp_list);
@@ -214,6 +219,12 @@ static void carl9170_ampdu_gc(struct ar9
 
 		list_del_init(&tid_info->tmp_list);
 		kfree(tid_info);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -230,6 +241,11 @@ static void carl9170_flush(struct ar9170
 		for (i = 0; i < ar->hw->queues; i++) {
 			struct sk_buff *skb;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while ((skb = skb_dequeue(&ar->tx_pending[i]))) {
 				struct ieee80211_tx_info *info;
 
@@ -238,6 +254,12 @@ static void carl9170_flush(struct ar9170
 					atomic_dec(&ar->tx_ampdu_upload);
 
 				carl9170_tx_status(ar, skb, false);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -286,6 +308,11 @@ static void carl9170_zap_queues(struct a
 
 	for (i = 0; i < ar->hw->queues; i++) {
 		spin_lock_bh(&ar->tx_status[i].lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!skb_queue_empty(&ar->tx_status[i])) {
 			struct sk_buff *skb;
 
@@ -295,6 +322,12 @@ static void carl9170_zap_queues(struct a
 			carl9170_tx_drop(ar, skb);
 			spin_lock_bh(&ar->tx_status[i].lock);
 			carl9170_tx_put_skb(skb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		spin_unlock_bh(&ar->tx_status[i].lock);
 	}
@@ -1493,7 +1526,12 @@ static int carl9170_rng_get(struct ar917
 		return -EAGAIN;
 
 	count = ARRAY_SIZE(ar->rng.cache);
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		err = carl9170_exec_cmd(ar, CARL9170_CMD_RREG,
 					RB, (u8 *) rng_load,
 					RB, (u8 *) buf);
@@ -1506,6 +1544,12 @@ static int carl9170_rng_get(struct ar917
 
 		off += transfer;
 		count -= transfer;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ar->rng.cache_idx = 0;
diff -u -p a/net/wireless/p54/p54pci.c b/net/wireless/p54/p54pci.c
--- a/net/wireless/p54/p54pci.c
+++ b/net/wireless/p54/p54pci.c
@@ -93,6 +93,11 @@ static int p54p_upload_firmware(struct i
 	data = (__le32 *) priv->firmware->data;
 	remains = priv->firmware->size;
 	device_addr = ISL38XX_DEV_FIRMWARE_ADDR;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (remains) {
 		u32 i = 0;
 		left = min((u32)0x1000, remains);
@@ -100,13 +105,30 @@ static int p54p_upload_firmware(struct i
 		P54P_READ(int_enable);
 
 		device_addr += 0x1000;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (i < left) {
 			P54P_WRITE(direct_mem_win[i], *data++);
 			i += sizeof(u32);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		remains -= left;
 		P54P_READ(int_enable);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	reg = P54P_READ(ctrl_stat);
@@ -197,6 +219,11 @@ static void p54p_check_rx_ring(struct ie
 	i = (*index) % ring_limit;
 	(*index) = idx = le32_to_cpu(ring_control->device_idx[ring_index]);
 	idx %= ring_limit;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i != idx) {
 		u16 len;
 		struct sk_buff *skb;
@@ -237,6 +264,12 @@ static void p54p_check_rx_ring(struct ie
 
 		i++;
 		i %= ring_limit;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	p54p_refill_rx_ring(dev, ring_index, ring, ring_limit, rx_buf, *index);
@@ -256,7 +289,12 @@ static void p54p_check_tx_ring(struct ie
 	(*index) = idx = le32_to_cpu(ring_control->device_idx[ring_index]);
 	idx %= ring_limit;
 
-	while (i != idx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i != idx) {
 		desc = &ring[i];
 
 		skb = tx_buf[i];
@@ -275,6 +313,12 @@ static void p54p_check_tx_ring(struct ie
 
 		i++;
 		i %= ring_limit;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/p54/p54spi.c b/net/wireless/p54/p54spi.c
--- a/net/wireless/p54/p54spi.c
+++ b/net/wireless/p54/p54spi.c
@@ -443,7 +443,12 @@ static int p54spi_wq_tx(struct p54s_priv
 
 	spin_lock_irqsave(&priv->tx_lock, flags);
 
-	while (!list_empty(&priv->tx_pending)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&priv->tx_pending)) {
 		entry = list_entry(priv->tx_pending.next,
 				   struct p54s_tx_info, tx_list);
 
@@ -467,6 +472,12 @@ static int p54spi_wq_tx(struct p54s_priv
 		}
 
 		spin_lock_irqsave(&priv->tx_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&priv->tx_lock, flags);
 	return ret;
diff -u -p a/net/wireless/p54/p54usb.c b/net/wireless/p54/p54usb.c
--- a/net/wireless/p54/p54usb.c
+++ b/net/wireless/p54/p54usb.c
@@ -517,6 +517,11 @@ static int p54u_upload_firmware_3887(str
 	left -= sizeof(*hdr);
 	tmp += sizeof(*hdr);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (remains) {
 		while (left--) {
 			if (carry) {
@@ -551,6 +556,12 @@ static int p54u_upload_firmware_3887(str
 
 		tmp = buf;
 		left = block_size = min((unsigned int)P54U_FW_BLOCK, remains);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*((__le32 *)buf) = cpu_to_le32(~crc32_le(~0, priv->fw->data,
@@ -730,6 +741,11 @@ static int p54u_upload_firmware_net2280(
 	data = priv->fw->data;
 	offset = ISL38XX_DEV_FIRMWARE_ADDR;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (remains) {
 		unsigned int block_len = min(remains, (unsigned int)512);
 		memcpy(buf, data, block_len);
@@ -781,6 +797,12 @@ static int p54u_upload_firmware_net2280(
 		remains -= block_len;
 		data += block_len;
 		offset += block_len;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* do ramboot */
diff -u -p a/net/wireless/p54/eeprom.c b/net/wireless/p54/eeprom.c
--- a/net/wireless/p54/eeprom.c
+++ b/net/wireless/p54/eeprom.c
@@ -747,11 +747,22 @@ int p54_parse_eeprom(struct ieee80211_hw
 			break;
 		case PDR_INTERFACE_LIST:
 			tmp = entry->data;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while ((u8 *)tmp < entry->data + data_len) {
 				struct exp_if *exp_if = tmp;
 				if (exp_if->if_id == cpu_to_le16(IF_ID_ISL39000))
 					synth = le16_to_cpu(exp_if->variant);
 				tmp += sizeof(*exp_if);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			break;
 		case PDR_HARDWARE_PLATFORM_COMPONENT_ID:
@@ -903,7 +914,12 @@ int p54_read_eeprom(struct ieee80211_hw
 	if (unlikely(!eeprom))
 		goto free;
 
-	while (eeprom_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (eeprom_size) {
 		blocksize = min(eeprom_size, maxblocksize);
 		ret = p54_download_eeprom(priv, (void *) (eeprom + offset),
 					  offset, blocksize);
@@ -912,6 +928,12 @@ int p54_read_eeprom(struct ieee80211_hw
 
 		offset += blocksize;
 		eeprom_size -= blocksize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = p54_parse_eeprom(dev, eeprom, offset);
diff -u -p a/net/wireless/p54/fwio.c b/net/wireless/p54/fwio.c
--- a/net/wireless/p54/fwio.c
+++ b/net/wireless/p54/fwio.c
@@ -51,6 +51,11 @@ int p54_parse_firmware(struct ieee80211_
 
 	bootrec = (struct bootrec *) data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bootrec->data <= end_data && (bootrec->data +
 	       (len = le32_to_cpu(bootrec->len))) <= end_data) {
 		u32 code = le32_to_cpu(bootrec->code);
@@ -122,6 +127,12 @@ int p54_parse_firmware(struct ieee80211_
 			break;
 		}
 		bootrec = (struct bootrec *)&bootrec->data[len];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (fw_version) {
diff -u -p a/net/wireless/p54/main.c b/net/wireless/p54/main.c
--- a/net/wireless/p54/main.c
+++ b/net/wireless/p54/main.c
@@ -85,6 +85,11 @@ u8 *p54_find_ie(struct sk_buff *skb, u8
 
 	pos = (u8 *)mgmt->u.beacon.variable;
 	end = skb->data + skb->len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -93,6 +98,12 @@ u8 *p54_find_ie(struct sk_buff *skb, u8
 			return pos;
 
 		pos += 2 + pos[1];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/net/wireless/iwlwifi/iwl-trans-pcie-rx.c b/net/wireless/iwlwifi/iwl-trans-pcie-rx.c
--- a/net/wireless/iwlwifi/iwl-trans-pcie-rx.c
+++ b/net/wireless/iwlwifi/iwl-trans-pcie-rx.c
@@ -256,6 +256,11 @@ static void iwlagn_rx_allocate(struct iw
 	unsigned long flags;
 	gfp_t gfp_mask = priority;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		spin_lock_irqsave(&rxq->lock, flags);
 		if (list_empty(&rxq->rx_used)) {
@@ -330,6 +335,12 @@ static void iwlagn_rx_allocate(struct iw
 		rxq->free_count++;
 
 		spin_unlock_irqrestore(&rxq->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -406,6 +417,11 @@ static void iwl_rx_handle(struct iwl_tra
 	if (total_empty > (RX_QUEUE_SIZE / 2))
 		fill_rx = 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i != r) {
 		int len, err;
 		u16 sequence;
@@ -526,6 +542,12 @@ static void iwl_rx_handle(struct iwl_tra
 				count = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Backtrack one entry */
@@ -1389,7 +1411,12 @@ irqreturn_t iwl_isr_ict(int irq, void *d
 	}
 
 	/* read all entries that not 0 start with ict_index */
-	while (trans_pcie->ict_tbl[trans_pcie->ict_index]) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (trans_pcie->ict_tbl[trans_pcie->ict_index]) {
 
 		val |= le32_to_cpu(trans_pcie->ict_tbl[trans_pcie->ict_index]);
 		IWL_DEBUG_ISR(trans, "ICT index %d value 0x%08X\n",
@@ -1400,6 +1427,12 @@ irqreturn_t iwl_isr_ict(int irq, void *d
 		trans_pcie->ict_index =
 			iwl_queue_inc_wrap(trans_pcie->ict_index, ICT_COUNT);
 
+			if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* We should not get this value, just ignore it. */
diff -u -p a/net/wireless/iwlwifi/iwl-scan.c b/net/wireless/iwlwifi/iwl-scan.c
--- a/net/wireless/iwlwifi/iwl-scan.c
+++ b/net/wireless/iwlwifi/iwl-scan.c
@@ -237,10 +237,21 @@ void iwl_scan_cancel_timeout(struct iwl_
 
 	iwl_do_scan_abort(priv);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before_eq(jiffies, timeout)) {
 		if (!test_bit(STATUS_SCAN_HW, &priv->shrd->status))
 			goto finished;
 		msleep(20);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return;
diff -u -p a/net/wireless/iwlwifi/iwl-trans-pcie.c b/net/wireless/iwlwifi/iwl-trans-pcie.c
--- a/net/wireless/iwlwifi/iwl-trans-pcie.c
+++ b/net/wireless/iwlwifi/iwl-trans-pcie.c
@@ -424,11 +424,22 @@ static void iwl_tx_queue_unmap(struct iw
 	}
 
 	spin_lock_irqsave(lock, flags);
-	while (q->write_ptr != q->read_ptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (q->write_ptr != q->read_ptr) {
 		/* The read_ptr needs to bound by q->n_window */
 		iwlagn_txq_free_tfd(trans, txq, get_cmd_index(q, q->read_ptr),
 				    dma_dir);
 		q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irqrestore(lock, flags);
 }
diff -u -p a/net/wireless/iwlwifi/iwl-agn-rs.c b/net/wireless/iwlwifi/iwl-agn-rs.c
--- a/net/wireless/iwlwifi/iwl-agn-rs.c
+++ b/net/wireless/iwlwifi/iwl-agn-rs.c
@@ -267,6 +267,11 @@ static void rs_tl_rm_old_stats(struct iw
 	/* The oldest age we want to keep */
 	u32 oldest_time = curr_time - TID_MAX_TIME_DIFF;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tl->queue_count &&
 	       (tl->time_stamp < oldest_time)) {
 		tl->total -= tl->packet_count[tl->head];
@@ -276,6 +281,12 @@ static void rs_tl_rm_old_stats(struct iw
 		tl->head++;
 		if (tl->head >= TID_QUEUE_MAX_SIZE)
 			tl->head = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/net/wireless/iwlwifi/iwl-agn-tx.c b/net/wireless/iwlwifi/iwl-agn-tx.c
--- a/net/wireless/iwlwifi/iwl-agn-tx.c
+++ b/net/wireless/iwlwifi/iwl-agn-tx.c
@@ -785,6 +785,11 @@ int iwlagn_rx_reply_tx(struct iwl_priv *
 		iwl_trans_reclaim(trans(priv), sta_id, tid, txq_id,
 				  ssn, status, &skbs);
 		freed = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!skb_queue_empty(&skbs)) {
 			skb = __skb_dequeue(&skbs);
 			hdr = (struct ieee80211_hdr *)skb->data;
@@ -830,6 +835,12 @@ int iwlagn_rx_reply_tx(struct iwl_priv *
 			ieee80211_tx_status_irqsafe(priv->hw, skb);
 
 			freed++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		WARN_ON(!is_agg && freed != 1);
@@ -938,6 +949,11 @@ int iwlagn_rx_reply_compressed_ba(struct
 	iwl_trans_reclaim(trans(priv), sta_id, tid, scd_flow, ba_resp_scd_ssn,
 			  0, &reclaimed_skbs);
 	freed = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!skb_queue_empty(&reclaimed_skbs)) {
 		struct ieee80211_hdr *hdr;
 		struct ieee80211_tx_info *info;
@@ -973,6 +989,12 @@ int iwlagn_rx_reply_compressed_ba(struct
 		}
 
 		ieee80211_tx_status_irqsafe(priv->hw, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);
diff -u -p a/net/wireless/wl3501_cs.c b/net/wireless/wl3501_cs.c
--- a/net/wireless/wl3501_cs.c
+++ b/net/wireless/wl3501_cs.c
@@ -301,7 +301,12 @@ static u16 wl3501_get_tx_buffer(struct w
 	if (full_len > this->tx_buffer_cnt * 254)
 		goto out;
 	ret = this->tx_buffer_head;
-	while (full_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (full_len) {
 		if (full_len < 254)
 			full_len = 0;
 		else
@@ -319,6 +324,12 @@ static u16 wl3501_get_tx_buffer(struct w
 			ret = 0;
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	this->tx_buffer_cnt -= blk_cnt;
 out:
@@ -336,6 +347,11 @@ static void wl3501_free_tx_buffer(struct
 	else
 		wl3501_set_to_wla(this, this->tx_buffer_tail,
 				  &ptr, sizeof(ptr));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ptr) {
 		u16 next;
 
@@ -343,6 +359,12 @@ static void wl3501_free_tx_buffer(struct
 		wl3501_get_from_wla(this, ptr, &next, sizeof(next));
 		this->tx_buffer_tail = ptr;
 		ptr = next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1197,11 +1219,22 @@ static int wl3501_init_firmware(struct w
 	this->tx_buffer_cnt = 1;
 	ptr = this->tx_buffer_head;
 	next = ptr + WL3501_BLKSZ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((next - this->tx_buffer_head) < this->tx_buffer_size) {
 		this->tx_buffer_cnt++;
 		wl3501_set_to_wla(this, ptr, &next, sizeof(next));
 		ptr = next;
 		next = ptr + WL3501_BLKSZ;
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	rc = 0;
 	next = 0;
diff -u -p a/net/wireless/iwlegacy/iwl-4965-rs.c b/net/wireless/iwlegacy/iwl-4965-rs.c
--- a/net/wireless/iwlegacy/iwl-4965-rs.c
+++ b/net/wireless/iwlegacy/iwl-4965-rs.c
@@ -251,6 +251,11 @@ iwl4965_rs_tl_rm_old_stats(struct iwl_tr
 	/* The oldest age we want to keep */
 	u32 oldest_time = curr_time - TID_MAX_TIME_DIFF;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tl->queue_count &&
 	       (tl->time_stamp < oldest_time)) {
 		tl->total -= tl->packet_count[tl->head];
@@ -260,6 +265,12 @@ iwl4965_rs_tl_rm_old_stats(struct iwl_tr
 		tl->head++;
 		if (tl->head >= TID_QUEUE_MAX_SIZE)
 			tl->head = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/net/wireless/iwlegacy/iwl-4965-tx.c b/net/wireless/iwlegacy/iwl-4965-tx.c
--- a/net/wireless/iwlegacy/iwl-4965-tx.c
+++ b/net/wireless/iwlegacy/iwl-4965-tx.c
@@ -1198,7 +1198,12 @@ static int iwl4965_tx_status_reply_compr
 	/* For each frame attempted in aggregation,
 	 * update driver's record of tx frame's status. */
 	i = 0;
-	while (sent_bitmap) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sent_bitmap) {
 		ack = sent_bitmap & 1ULL;
 		successes += ack;
 		IWL_DEBUG_TX_REPLY(priv, "%s ON i=%d idx=%d raw=%d\n",
@@ -1207,6 +1212,12 @@ static int iwl4965_tx_status_reply_compr
 			agg->start_idx + i);
 		sent_bitmap >>= 1;
 		++i;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	IWL_DEBUG_TX_REPLY(priv, "Bitmap %llx\n",
diff -u -p a/net/wireless/iwlegacy/iwl-tx.c b/net/wireless/iwlegacy/iwl-tx.c
--- a/net/wireless/iwlegacy/iwl-tx.c
+++ b/net/wireless/iwlegacy/iwl-tx.c
@@ -93,9 +93,20 @@ void iwl_legacy_tx_queue_unmap(struct iw
 	if (q->n_bd == 0)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->write_ptr != q->read_ptr) {
 		priv->cfg->ops->lib->txq_free_tfd(priv, txq);
 		q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL(iwl_legacy_tx_queue_unmap);
@@ -152,6 +163,11 @@ void iwl_legacy_cmd_queue_unmap(struct i
 	if (q->n_bd == 0)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->read_ptr != q->write_ptr) {
 		i = iwl_legacy_get_cmd_index(q, q->read_ptr, 0);
 
@@ -164,6 +180,12 @@ void iwl_legacy_cmd_queue_unmap(struct i
 		}
 
 		q->read_ptr = iwl_legacy_queue_inc_wrap(q->read_ptr, q->n_bd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	i = q->n_window;
diff -u -p a/net/wireless/iwlegacy/iwl-4965-lib.c b/net/wireless/iwlegacy/iwl-4965-lib.c
--- a/net/wireless/iwlegacy/iwl-4965-lib.c
+++ b/net/wireless/iwlegacy/iwl-4965-lib.c
@@ -285,6 +285,11 @@ static void iwl4965_rx_allocate(struct i
 	unsigned long flags;
 	gfp_t gfp_mask = priority;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		spin_lock_irqsave(&rxq->lock, flags);
 		if (list_empty(&rxq->rx_used)) {
@@ -352,6 +357,12 @@ static void iwl4965_rx_allocate(struct i
 		priv->alloc_rxb_page++;
 
 		spin_unlock_irqrestore(&rxq->lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/iwlegacy/iwl4965-base.c b/net/wireless/iwlegacy/iwl4965-base.c
--- a/net/wireless/iwlegacy/iwl4965-base.c
+++ b/net/wireless/iwlegacy/iwl4965-base.c
@@ -107,11 +107,22 @@ static void iwl4965_clear_free_frames(st
 	IWL_DEBUG_INFO(priv, "%d frames on pre-allocated heap on clear.\n",
 		       priv->frames_count);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&priv->free_frames)) {
 		element = priv->free_frames.next;
 		list_del(element);
 		kfree(list_entry(element, struct iwl_frame, list));
 		priv->frames_count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (priv->frames_count) {
@@ -660,6 +671,11 @@ void iwl4965_rx_handle(struct iwl_priv *
 	if (total_empty > (RX_QUEUE_SIZE / 2))
 		fill_rx = 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i != r) {
 		int len;
 
@@ -755,6 +771,12 @@ void iwl4965_rx_handle(struct iwl_priv *
 				count = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Backtrack one entry */
diff -u -p a/net/wireless/iwlegacy/iwl3945-base.c b/net/wireless/iwlegacy/iwl3945-base.c
--- a/net/wireless/iwlegacy/iwl3945-base.c
+++ b/net/wireless/iwlegacy/iwl3945-base.c
@@ -273,11 +273,22 @@ static void iwl3945_clear_free_frames(st
 	IWL_DEBUG_INFO(priv, "%d frames on pre-allocated heap on clear.\n",
 		       priv->frames_count);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&priv->free_frames)) {
 		element = priv->free_frames.next;
 		list_del(element);
 		kfree(list_entry(element, struct iwl3945_frame, list));
 		priv->frames_count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (priv->frames_count) {
@@ -1227,6 +1238,11 @@ static void iwl3945_rx_handle(struct iwl
 	if (i == r)
 		IWL_DEBUG_RX(priv, "r = %d, i = %d\n", r, i);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i != r) {
 		int len;
 
@@ -1317,6 +1333,12 @@ static void iwl3945_rx_handle(struct iwl
 				count = 0;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Backtrack one entry */
@@ -3296,7 +3318,12 @@ static ssize_t iwl3945_show_measurement(
 	priv->measurement_status = 0;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	while (size && (PAGE_SIZE - len)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size && (PAGE_SIZE - len)) {
 		hex_dump_to_buffer(data + ofs, size, 16, 1, buf + len,
 				   PAGE_SIZE - len, 1);
 		len = strlen(buf);
@@ -3305,6 +3332,12 @@ static ssize_t iwl3945_show_measurement(
 
 		ofs += 16;
 		size -= min(size, 16U);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return len;
diff -u -p a/net/wireless/rtl818x/rtl8180/dev.c b/net/wireless/rtl818x/rtl8180/dev.c
--- a/net/wireless/rtl818x/rtl8180/dev.c
+++ b/net/wireless/rtl818x/rtl8180/dev.c
@@ -177,6 +177,11 @@ static void rtl8180_handle_tx(struct iee
 	struct rtl8180_priv *priv = dev->priv;
 	struct rtl8180_tx_ring *ring = &priv->tx_ring[prio];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl8180_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb;
@@ -204,6 +209,12 @@ static void rtl8180_handle_tx(struct iee
 		ieee80211_tx_status_irqsafe(dev, skb);
 		if (ring->entries - skb_queue_len(&ring->queue) == 2)
 			ieee80211_wake_queue(dev, prio);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -526,6 +537,11 @@ static void rtl8180_free_tx_ring(struct
 	struct rtl8180_priv *priv = dev->priv;
 	struct rtl8180_tx_ring *ring = &priv->tx_ring[prio];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl8180_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb = __skb_dequeue(&ring->queue);
@@ -534,6 +550,12 @@ static void rtl8180_free_tx_ring(struct
 				 skb->len, PCI_DMA_TODEVICE);
 		kfree_skb(skb);
 		ring->idx = (ring->idx + 1) % ring->entries;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	pci_free_consistent(priv->pdev, sizeof(*ring->desc)*ring->entries,
diff -u -p a/net/wireless/rtlwifi/pci.c b/net/wireless/rtlwifi/pci.c
--- a/net/wireless/rtlwifi/pci.c
+++ b/net/wireless/rtlwifi/pci.c
@@ -520,6 +520,11 @@ static void _rtl_pci_tx_isr(struct ieee8
 
 	struct rtl8192_tx_ring *ring = &rtlpci->tx_ring[prio];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb;
@@ -605,6 +610,12 @@ static void _rtl_pci_tx_isr(struct ieee8
 		}
 tx_status_ok:
 		skb = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (((rtlpriv->link_info.num_rx_inperiod +
@@ -1149,6 +1160,11 @@ static void _rtl_pci_free_tx_ring(struct
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 	struct rtl8192_tx_ring *ring = &rtlpci->tx_ring[prio];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb_queue_len(&ring->queue)) {
 		struct rtl_tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb = __skb_dequeue(&ring->queue);
@@ -1160,6 +1176,12 @@ static void _rtl_pci_free_tx_ring(struct
 				 skb->len, PCI_DMA_TODEVICE);
 		kfree_skb(skb);
 		ring->idx = (ring->idx + 1) % ring->entries;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (ring->desc) {
@@ -1285,7 +1307,12 @@ int rtl_pci_reset_trx_ring(struct ieee80
 		if (rtlpci->tx_ring[i].desc) {
 			struct rtl8192_tx_ring *ring = &rtlpci->tx_ring[i];
 
-			while (skb_queue_len(&ring->queue)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (skb_queue_len(&ring->queue)) {
 				struct rtl_tx_desc *entry =
 				    &ring->desc[ring->idx];
 				struct sk_buff *skb =
@@ -1300,6 +1327,12 @@ int rtl_pci_reset_trx_ring(struct ieee80
 						 skb->len, PCI_DMA_TODEVICE);
 				kfree_skb(skb);
 				ring->idx = (ring->idx + 1) % ring->entries;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			ring->idx = 0;
 		}
diff -u -p a/net/wireless/rtlwifi/usb.c b/net/wireless/rtlwifi/usb.c
--- a/net/wireless/rtlwifi/usb.c
+++ b/net/wireless/rtlwifi/usb.c
@@ -513,10 +513,21 @@ static void _rtl_rx_pre_process(struct i
 	if (rtlusb->usb_rx_segregate_hdl)
 		rtlusb->usb_rx_segregate_hdl(hw, skb, &rx_queue);
 	WARN_ON(skb_queue_empty(&rx_queue));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!skb_queue_empty(&rx_queue)) {
 		_skb = skb_dequeue(&rx_queue);
 		_rtl_usb_rx_process_agg(hw, _skb);
 		ieee80211_rx_irqsafe(hw, _skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -668,12 +679,23 @@ static void rtl_usb_cleanup(struct ieee8
 
 	/* clean up tx stuff */
 	for (i = 0; i < RTL_USB_MAX_EP_NUM; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((_skb = skb_dequeue(&rtlusb->tx_skb_queue[i]))) {
 			rtlusb->usb_tx_cleanup(hw, _skb);
 			txinfo = IEEE80211_SKB_CB(_skb);
 			ieee80211_tx_info_clear_status(txinfo);
 			txinfo->flags |= IEEE80211_TX_STAT_ACK;
 			ieee80211_tx_status_irqsafe(hw, _skb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		usb_kill_anchored_urbs(&rtlusb->tx_pending[i]);
 	}
diff -u -p a/net/wireless/rtlwifi/rtl8192c/fw_common.c b/net/wireless/rtlwifi/rtl8192c/fw_common.c
--- a/net/wireless/rtlwifi/rtl8192c/fw_common.c
+++ b/net/wireless/rtlwifi/rtl8192c/fw_common.c
@@ -301,7 +301,12 @@ static void _rtl92c_fill_h2c_command(str
 				 ("H2C set in progress! Wait to set.."
 				  "element_id(%d).\n", element_id));
 
-			while (rtlhal->h2c_setinprogress) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (rtlhal->h2c_setinprogress) {
 				spin_unlock_irqrestore(&rtlpriv->locks.h2c_lock,
 						       flag);
 				h2c_waitcounter++;
@@ -314,6 +319,12 @@ static void _rtl92c_fill_h2c_command(str
 					return;
 				spin_lock_irqsave(&rtlpriv->locks.h2c_lock,
 						  flag);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			spin_unlock_irqrestore(&rtlpriv->locks.h2c_lock, flag);
 		} else {
diff -u -p a/net/wireless/rtlwifi/efuse.c b/net/wireless/rtlwifi/efuse.c
--- a/net/wireless/rtlwifi/efuse.c
+++ b/net/wireless/rtlwifi/efuse.c
@@ -950,6 +950,11 @@ static int efuse_pg_packet_write(struct
 
 	RTPRINT(rtlpriv, FEEPROM, EFUSE_PG, ("efuse Power ON\n"));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (continual && (efuse_addr <
 	       (EFUSE_MAX_SIZE - EFUSE_OOB_PROTECT_BYTES))) {
 
@@ -1002,6 +1007,12 @@ static int efuse_pg_packet_write(struct
 					("efuse PG_STATE_HEADER-3\n"));
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (efuse_addr >= (EFUSE_MAX_SIZE - EFUSE_OOB_PROTECT_BYTES)) {
diff -u -p a/net/wireless/rtlwifi/base.c b/net/wireless/rtlwifi/base.c
--- a/net/wireless/rtlwifi/base.c
+++ b/net/wireless/rtlwifi/base.c
@@ -1244,6 +1244,11 @@ u8 *rtl_find_ie(u8 *data, unsigned int l
 
 	pos = (u8 *)mgmt->u.beacon.variable;
 	end = data + len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -1252,6 +1257,12 @@ u8 *rtl_find_ie(u8 *data, unsigned int l
 			return pos;
 
 		pos += 2 + pos[1];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -1392,6 +1403,11 @@ static bool rtl_find_221_ie(struct ieee8
 
 	pos = (u8 *)mgmt->u.beacon.variable;
 	end = data + len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos < end) {
 		if (pos[0] == 221) {
 			vendor_ie.length = pos[1];
@@ -1404,6 +1420,12 @@ static bool rtl_find_221_ie(struct ieee8
 			return false;
 
 		pos += 2 + pos[1];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return false;
 }
diff -u -p a/net/wireless/rtlwifi/rtl8192de/fw.c b/net/wireless/rtlwifi/rtl8192de/fw.c
--- a/net/wireless/rtlwifi/rtl8192de/fw.c
+++ b/net/wireless/rtlwifi/rtl8192de/fw.c
@@ -392,7 +392,12 @@ static void _rtl92d_fill_h2c_command(str
 				 ("H2C set in progress! Wait to set.."
 				 "element_id(%d).\n", element_id));
 
-			while (rtlhal->h2c_setinprogress) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (rtlhal->h2c_setinprogress) {
 				spin_unlock_irqrestore(&rtlpriv->locks.h2c_lock,
 						       flag);
 				h2c_waitcounter++;
@@ -406,6 +411,12 @@ static void _rtl92d_fill_h2c_command(str
 
 				spin_lock_irqsave(&rtlpriv->locks.h2c_lock,
 						  flag);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			spin_unlock_irqrestore(&rtlpriv->locks.h2c_lock, flag);
 		} else {
diff -u -p a/net/wireless/rtlwifi/rtl8192de/phy.c b/net/wireless/rtlwifi/rtl8192de/phy.c
--- a/net/wireless/rtlwifi/rtl8192de/phy.c
+++ b/net/wireless/rtlwifi/rtl8192de/phy.c
@@ -2829,11 +2829,22 @@ static void _rtl92d_phy_lc_calibrate_sw(
 		}
 		u4tmp = rtl_get_rfreg(hw, (enum radio_path)index, RF_SYN_G6,
 				  BRFREGOFFSETMASK);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((!(u4tmp & BIT(11))) && timecount <= timeout) {
 			mdelay(50);
 			timecount += 50;
 			u4tmp = rtl_get_rfreg(hw, (enum radio_path)index,
 					      RF_SYN_G6, BRFREGOFFSETMASK);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		RTPRINT(rtlpriv, FINIT, INIT_IQK,
 			("PHY_LCK finish delay for %d ms=2\n", timecount));
@@ -2910,9 +2921,20 @@ void rtl92d_phy_lc_calibrate(struct ieee
 	struct rtl_hal *rtlhal = &(rtlpriv->rtlhal);
 	u32 timeout = 2000, timecount = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rtlpriv->mac80211.act_scanning && timecount < timeout) {
 		udelay(50);
 		timecount += 50;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rtlphy->lck_inprogress = true;
@@ -3114,9 +3136,20 @@ u8 rtl92d_phy_sw_chnl(struct ieee80211_h
 			 ("sw_chnl_inprogress false driver sleep or unload\n"));
 		return 0;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rtlphy->lck_inprogress && timecount < timeout) {
 		mdelay(50);
 		timecount += 50;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (rtlhal->macphymode == SINGLEMAC_SINGLEPHY &&
 	    rtlhal->bandset == BAND_ON_BOTH) {
diff -u -p a/net/wireless/airo.c b/net/wireless/airo.c
--- a/net/wireless/airo.c
+++ b/net/wireless/airo.c
@@ -3019,7 +3019,12 @@ static void airo_process_scan_results (s
 
 	/* Read and parse all entries */
 	tmp_net = NULL;
-	while((!rc) && (bss.index != cpu_to_le16(0xffff))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while((!rc) && (bss.index != cpu_to_le16(0xffff))) {
 		/* Grab a network off the free list */
 		if (!list_empty(&ai->network_free_list)) {
 			tmp_net = list_entry(ai->network_free_list.next,
@@ -3036,7 +3041,13 @@ static void airo_process_scan_results (s
 		/* Read next entry */
 		rc = PC4500_readrid(ai, ai->bssListNext,
 				    &bss, ai->bssListRidLen, 0);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	ai->scan_timeout = 0;
@@ -3986,6 +3997,11 @@ static int bap_setup(struct airo_info *a
 
 	OUT4500(ai, SELECT0+whichbap, rid);
 	OUT4500(ai, OFFSET0+whichbap, offset);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		int status = IN4500(ai, OFFSET0+whichbap);
 		if (status & BAP_BUSY) {
@@ -4011,6 +4027,12 @@ static int bap_setup(struct airo_info *a
 		OUT4500(ai, SELECT0+whichbap, rid);
 		OUT4500(ai, OFFSET0+whichbap, offset);
 		timeout = 50;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4819,6 +4841,11 @@ static void proc_config_on_close(struct
 	set_bit (FLAG_COMMIT, &ai->flags);
 
 	line = data->wbuffer;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( line[0] ) {
 /*** Mode processing */
 		if ( !strncmp( line, "Mode: ", 6 ) ) {
@@ -5003,6 +5030,12 @@ static void proc_config_on_close(struct
 		}
 		while( line[0] && line[0] != '\n' ) line++;
 		if ( line[0] ) line++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	airo_config_commit(dev, NULL, NULL, NULL);
 }
@@ -5732,11 +5765,22 @@ static int __init airo_init_module( void
 static void __exit airo_cleanup_module( void )
 {
 	struct airo_info *ai;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(!list_empty(&airo_devices)) {
 		ai = list_entry(airo_devices.next, struct airo_info, dev_list);
 		airo_print_info(ai->dev->name, "Unregistering...");
 		stop_airo_card(ai->dev, 1);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 #ifdef CONFIG_PCI
 	pci_unregister_driver(&airo_driver);
 #endif
diff -u -p a/net/wireless/hostap/hostap_download.c b/net/wireless/hostap/hostap_download.c
--- a/net/wireless/hostap/hostap_download.c
+++ b/net/wireless/hostap/hostap_download.c
@@ -156,6 +156,11 @@ static int prism2_pda_ok(u8 *buf)
 		return 0;
 
 	pos = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos + 1 < PRISM2_PDA_SIZE / 2) {
 		len = le16_to_cpu(pda[pos]);
 		pdr = le16_to_cpu(pda[pos + 1]);
@@ -168,6 +173,12 @@ static int prism2_pda_ok(u8 *buf)
 		}
 
 		pos += len + 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/net/wireless/hostap/hostap_ap.c b/net/wireless/hostap/hostap_ap.c
--- a/net/wireless/hostap/hostap_ap.c
+++ b/net/wireless/hostap/hostap_ap.c
@@ -1067,6 +1067,11 @@ static void handle_add_proc_queue(struct
 	entry = ap->add_sta_proc_entries;
 	ap->add_sta_proc_entries = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (entry) {
 		spin_lock_bh(&ap->sta_table_lock);
 		sta = ap_get_sta(ap, entry->addr);
@@ -1086,6 +1091,12 @@ static void handle_add_proc_queue(struct
 		prev = entry;
 		entry = entry->next;
 		kfree(prev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1959,7 +1970,12 @@ static void handle_wds_oper_queue(struct
 	local->ap->wds_oper_entries = NULL;
 	spin_unlock_bh(&local->lock);
 
-	while (entry) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (entry) {
 		PDEBUG(DEBUG_AP, "%s: %s automatic WDS connection "
 		       "to AP %pM\n",
 		       local->dev->name,
@@ -1973,6 +1989,12 @@ static void handle_wds_oper_queue(struct
 		prev = entry;
 		entry = entry->next;
 		kfree(prev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/iwmc3200wifi/fw.c b/net/wireless/iwmc3200wifi/fw.c
--- a/net/wireless/iwmc3200wifi/fw.c
+++ b/net/wireless/iwmc3200wifi/fw.c
@@ -280,7 +280,12 @@ static int iwm_init_calib(struct iwm_pri
 	iwm_send_prio_table(iwm);
 	iwm_send_init_calib_cfg(iwm, cfg_bitmap);
 
-	while (iwm->calib_done_map != expected_bitmap) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (iwm->calib_done_map != expected_bitmap) {
 		if (iwm_notif_handle(iwm, CALIBRATION_RES_NOTIFICATION,
 				     IWM_SRC_LMAC, WAIT_NOTIF_TIMEOUT)) {
 			IWM_DBG_FW(iwm, DBG, "Initial calibration timeout\n");
@@ -290,6 +295,12 @@ static int iwm_init_calib(struct iwm_pri
 		IWM_DBG_FW(iwm, DBG, "Got calibration result. calib_done_map: "
 			   "0x%lx, expected calibrations: 0x%lx\n",
 			   iwm->calib_done_map, expected_bitmap);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/net/wireless/iwmc3200wifi/rx.c b/net/wireless/iwmc3200wifi/rx.c
--- a/net/wireless/iwmc3200wifi/rx.c
+++ b/net/wireless/iwmc3200wifi/rx.c
@@ -1579,6 +1579,11 @@ static void iwm_rx_process_amsdu(struct
 	ieee80211_amsdu_to_8023s(skb, &list, ndev->dev_addr, wdev->iftype, 0,
 									true);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((frame = __skb_dequeue(&list))) {
 		ndev->stats.rx_packets++;
 		ndev->stats.rx_bytes += frame->len;
@@ -1591,6 +1596,12 @@ static void iwm_rx_process_amsdu(struct
 			IWM_ERR(iwm, "Packet dropped\n");
 			ndev->stats.rx_dropped++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/iwmc3200wifi/sdio.c b/net/wireless/iwmc3200wifi/sdio.c
--- a/net/wireless/iwmc3200wifi/sdio.c
+++ b/net/wireless/iwmc3200wifi/sdio.c
@@ -88,6 +88,11 @@ static void iwm_sdio_isr_worker(struct w
 	hw = container_of(work, struct iwm_sdio_priv, isr_worker);
 	iwm = hw_to_iwm(hw);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!skb_queue_empty(&iwm->rx_list)) {
 		skb = skb_dequeue(&iwm->rx_list);
 		rx_info = skb_to_rx_info(skb);
@@ -99,6 +104,12 @@ static void iwm_sdio_isr_worker(struct w
 			IWM_WARN(iwm, "RX error\n");
 
 		kfree_skb(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/mwifiex/join.c b/net/wireless/mwifiex/join.c
--- a/net/wireless/mwifiex/join.c
+++ b/net/wireless/mwifiex/join.c
@@ -170,12 +170,23 @@ static int mwifiex_get_common_rates(stru
 						priv->data_rate);
 
 	if (!priv->is_data_rate_auto) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (*ptr) {
 			if ((*ptr & 0x7f) == priv->data_rate) {
 				ret = 0;
 				goto done;
 			}
 			ptr++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		dev_err(priv->adapter->dev, "previously set fixed data rate %#x"
 			" is not compatible with the network\n",
diff -u -p a/net/wireless/mwifiex/pcie.c b/net/wireless/mwifiex/pcie.c
--- a/net/wireless/mwifiex/pcie.c
+++ b/net/wireless/mwifiex/pcie.c
@@ -849,6 +849,11 @@ static int mwifiex_pcie_process_recv_dat
 		goto done;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (((wrptr & MWIFIEX_RXBD_MASK) !=
 		(card->rxbd_rdptr & MWIFIEX_RXBD_MASK)) ||
 	       ((wrptr & MWIFIEX_BD_FLAG_ROLLOVER_IND) ==
@@ -903,7 +908,13 @@ static int mwifiex_pcie_process_recv_dat
 		dev_dbg(adapter->dev, "info: RECV DATA: Received packet from "
 				      "firmware successfully\n");
 		mwifiex_handle_rx_packet(adapter, skb_tmp);
-	}
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+}
 
 done:
 	if (ret && skb_tmp)
@@ -1596,6 +1607,11 @@ static int mwifiex_process_int_status(st
 	adapter->int_status &= HOST_INTR_MASK;
 	spin_unlock_irqrestore(&adapter->int_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (adapter->int_status & HOST_INTR_MASK) {
 		if (adapter->int_status & HOST_INTR_DNLD_DONE) {
 			adapter->int_status &= ~HOST_INTR_DNLD_DONE;
@@ -1650,6 +1666,12 @@ static int mwifiex_process_int_status(st
 			}
 
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_dbg(adapter->dev, "info: cmd_sent=%d data_sent=%d\n",
 	       adapter->cmd_sent, adapter->data_sent);
diff -u -p a/net/wireless/mwifiex/sta_cmdresp.c b/net/wireless/mwifiex/sta_cmdresp.c
--- a/net/wireless/mwifiex/sta_cmdresp.c
+++ b/net/wireless/mwifiex/sta_cmdresp.c
@@ -378,6 +378,11 @@ static int mwifiex_get_power_level(struc
 			min_power = pg->power_min;
 			length -= sizeof(struct mwifiex_power_group);
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (length) {
 			pg++;
 			if (max_power < pg->power_max)
@@ -387,6 +392,12 @@ static int mwifiex_get_power_level(struc
 				min_power = pg->power_min;
 
 			length -= sizeof(struct mwifiex_power_group);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (pg_tlv_hdr->length > 0) {
 			priv->min_tx_power_level = (u8) min_power;
diff -u -p a/net/wireless/mwifiex/scan.c b/net/wireless/mwifiex/scan.c
--- a/net/wireless/mwifiex/scan.c
+++ b/net/wireless/mwifiex/scan.c
@@ -93,6 +93,11 @@ mwifiex_search_oui_in_ie(struct ie_body
 	   1) Take the length.
 	   2) Check all the OUIs for AES.
 	   3) If one of them is AES then pass success. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		if (!memcmp(iebody->ptk_body, oui, sizeof(iebody->ptk_body)))
 			return MWIFIEX_OUI_PRESENT;
@@ -101,6 +106,12 @@ mwifiex_search_oui_in_ie(struct ie_body
 		if (count)
 			iebody = (struct ie_body *) ((u8 *) iebody +
 						sizeof(iebody->ptk_body));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	pr_debug("info: %s: OUI is not found in PTK\n", __func__);
@@ -604,6 +615,11 @@ mwifiex_scan_channel_list(struct mwifiex
 		 *   - done_early is set (controlling individual scanning of
 		 *     1,6,11)
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tlv_idx < max_chan_per_scan
 		       && tmp_chan_list->chan_number && !done_early) {
 
@@ -674,6 +690,12 @@ mwifiex_scan_channel_list(struct mwifiex
 				|| tmp_chan_list->chan_number == 6
 				|| tmp_chan_list->chan_number == 11))
 				done_early = true;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* The total scan time should be less than scan command timeout
diff -u -p a/net/wireless/mwifiex/sta_rx.c b/net/wireless/mwifiex/sta_rx.c
--- a/net/wireless/mwifiex/sta_rx.c
+++ b/net/wireless/mwifiex/sta_rx.c
@@ -154,11 +154,22 @@ int mwifiex_process_sta_rx_packet(struct
 		ieee80211_amsdu_to_8023s(skb, &list, priv->curr_addr,
 				priv->wdev->iftype, 0, false);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!skb_queue_empty(&list)) {
 			rx_skb = __skb_dequeue(&list);
 			ret = mwifiex_recv_packet(adapter, rx_skb);
 			if (ret == -1)
 				dev_err(adapter->dev, "Rx of A-MSDU failed");
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		return 0;
 	}
diff -u -p a/net/wireless/b43legacy/pio.c b/net/wireless/b43legacy/pio.c
--- a/net/wireless/b43legacy/pio.c
+++ b/net/wireless/b43legacy/pio.c
@@ -89,10 +89,21 @@ static void tx_data(struct b43legacy_pio
 	b43legacy_pio_write(queue, B43legacy_PIO_TXCTL,
 			    B43legacy_PIO_TXCTL_WRITELO |
 			    B43legacy_PIO_TXCTL_WRITEHI);
-	while (i < octets - 1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i < octets - 1) {
 		data = tx_get_next_word(txhdr, packet,
 					sizeof(struct b43legacy_txhdr_fw3), &i);
 		b43legacy_pio_write(queue, B43legacy_PIO_TXDATA, data);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (octets % 2)
 		tx_octet(queue, packet[octets -
diff -u -p a/net/wireless/rt2x00/rt61pci.c b/net/wireless/rt2x00/rt61pci.c
--- a/net/wireless/rt2x00/rt61pci.c
+++ b/net/wireless/rt2x00/rt61pci.c
@@ -2202,7 +2202,12 @@ static void rt61pci_txdone(struct rt2x00
 			return;
 
 		entry_done = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
-		while (entry != entry_done) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (entry != entry_done) {
 			/* Catch up.
 			 * Just report any entries we missed as failed.
 			 */
@@ -2212,6 +2217,12 @@ static void rt61pci_txdone(struct rt2x00
 
 			rt2x00lib_txdone_noinfo(entry_done, TXDONE_UNKNOWN);
 			entry_done = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 		}
 
 		/*
diff -u -p a/net/wireless/rt2x00/rt2x00dev.c b/net/wireless/rt2x00/rt2x00dev.c
--- a/net/wireless/rt2x00/rt2x00dev.c
+++ b/net/wireless/rt2x00/rt2x00dev.c
@@ -189,9 +189,20 @@ static void rt2x00lib_bc_buffer_iter(voi
 	 * Send out buffered broad- and multicast frames
 	 */
 	skb = ieee80211_get_buffered_bc(rt2x00dev->hw, vif);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb) {
 		rt2x00mac_tx(rt2x00dev->hw, skb);
 		skb = ieee80211_get_buffered_bc(rt2x00dev->hw, vif);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -456,6 +467,11 @@ static u8 *rt2x00lib_find_ie(u8 *data, u
 
 	pos = (u8 *)mgmt->u.beacon.variable;
 	end = data + len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos < end) {
 		if (pos + 2 + pos[1] > end)
 			return NULL;
@@ -464,6 +480,12 @@ static u8 *rt2x00lib_find_ie(u8 *data, u
 			return pos;
 
 		pos += 2 + pos[1];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/net/wireless/rt2x00/rt2x00usb.c b/net/wireless/rt2x00/rt2x00usb.c
--- a/net/wireless/rt2x00/rt2x00usb.c
+++ b/net/wireless/rt2x00/rt2x00usb.c
@@ -123,7 +123,12 @@ int rt2x00usb_vendor_request_buff(struct
 	tb  = (char *)buffer;
 	off = offset;
 	len = buffer_length;
-	while (len && !status) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (len && !status) {
 		bsize = min_t(u16, CSR_CACHE_SIZE, len);
 		status = rt2x00usb_vendor_req_buff_lock(rt2x00dev, request,
 							requesttype, off, tb,
@@ -132,6 +137,12 @@ int rt2x00usb_vendor_request_buff(struct
 		tb  += bsize;
 		len -= bsize;
 		off += bsize;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	mutex_unlock(&rt2x00dev->csr_mutex);
diff -u -p a/net/wireless/rt2x00/rt2800lib.c b/net/wireless/rt2x00/rt2800lib.c
--- a/net/wireless/rt2x00/rt2800lib.c
+++ b/net/wireless/rt2x00/rt2800lib.c
@@ -371,11 +371,22 @@ int rt2800_check_firmware(struct rt2x00_
 	 * 8kb firmware files must be checked as if it were
 	 * 2 separate firmware files.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (offset < len) {
 		if (!rt2800_check_firmware_crc(data + offset, fw_len))
 			return FW_BAD_CRC;
 
 		offset += fw_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return FW_OK;
diff -u -p a/net/wireless/rt2x00/rt2800usb.c b/net/wireless/rt2x00/rt2800usb.c
--- a/net/wireless/rt2x00/rt2800usb.c
+++ b/net/wireless/rt2x00/rt2800usb.c
@@ -516,7 +516,12 @@ static void rt2800usb_txdone(struct rt2x
 	u32 reg;
 	u8 qid;
 
-	while (kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
 
 		/* TX_STA_FIFO_PID_QUEUE is a 2-bit field, thus
 		 * qid is guaranteed to be one of the TX QIDs
@@ -544,6 +549,12 @@ static void rt2800usb_txdone(struct rt2x
 		if (entry)
 			rt2800_txdone_entry(entry, reg,
 					    rt2800usb_get_txwi(entry));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/net/wireless/wl1251/ps.c b/net/wireless/wl1251/ps.c
--- a/net/wireless/wl1251/ps.c
+++ b/net/wireless/wl1251/ps.c
@@ -87,6 +87,11 @@ int wl1251_ps_elp_wakeup(struct wl1251 *
 	 * FIXME: we should wait for irq from chip but, as a temporary
 	 * solution to simplify locking, let's poll instead
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(elp_reg & ELPCTRL_WLAN_READY)) {
 		if (time_after(jiffies, timeout)) {
 			wl1251_error("elp wakeup timeout");
@@ -94,6 +99,12 @@ int wl1251_ps_elp_wakeup(struct wl1251 *
 		}
 		msleep(1);
 		elp_reg = wl1251_read_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	wl1251_debug(DEBUG_PSM, "wakeup time: %u ms",
diff -u -p a/net/wireless/wl1251/tx.c b/net/wireless/wl1251/tx.c
--- a/net/wireless/wl1251/tx.c
+++ b/net/wireless/wl1251/tx.c
@@ -324,6 +324,11 @@ void wl1251_tx_work(struct work_struct *
 	if (unlikely(wl->state == WL1251_STATE_OFF))
 		goto out;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&wl->tx_queue))) {
 		if (!woken_up) {
 			ret = wl1251_ps_elp_wakeup(wl);
@@ -340,7 +345,13 @@ void wl1251_tx_work(struct work_struct *
 			dev_kfree_skb(skb);
 			goto out;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	if (woken_up)
@@ -535,6 +546,11 @@ void wl1251_tx_flush(struct wl1251 *wl)
 	/* TX failure */
 /* 	control->flags = 0; FIXME */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&wl->tx_queue))) {
 		info = IEEE80211_SKB_CB(skb);
 
@@ -544,6 +560,12 @@ void wl1251_tx_flush(struct wl1251 *wl)
 				continue;
 
 		ieee80211_tx_status(wl->hw, skb);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)
diff -u -p a/net/wireless/wl1251/cmd.c b/net/wireless/wl1251/cmd.c
--- a/net/wireless/wl1251/cmd.c
+++ b/net/wireless/wl1251/cmd.c
@@ -38,6 +38,11 @@ int wl1251_cmd_send(struct wl1251 *wl, u
 	timeout = jiffies + msecs_to_jiffies(WL1251_COMMAND_TIMEOUT);
 
 	intr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(intr & WL1251_ACX_INTR_CMD_COMPLETE)) {
 		if (time_after(jiffies, timeout)) {
 			wl1251_error("command complete timeout");
@@ -48,6 +53,12 @@ int wl1251_cmd_send(struct wl1251 *wl, u
 		msleep(1);
 
 		intr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	wl1251_reg_write32(wl, ACX_REG_INTERRUPT_ACK,
diff -u -p a/net/wireless/wl1251/boot.c b/net/wireless/wl1251/boot.c
--- a/net/wireless/wl1251/boot.c
+++ b/net/wireless/wl1251/boot.c
@@ -351,7 +351,12 @@ static int wl1251_boot_upload_firmware(s
 	chunk_num = 0;
 	partition_limit = WL1251_PART_DOWN_MEM_SIZE;
 
-	while (chunk_num < fw_data_len / CHUNK_SIZE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (chunk_num < fw_data_len / CHUNK_SIZE) {
 		/* 10.2 update partition, if needed */
 		addr = WL1251_PART_DOWN_MEM_START +
 			(chunk_num + 2) * CHUNK_SIZE;
@@ -379,6 +384,12 @@ static int wl1251_boot_upload_firmware(s
 		wl1251_mem_write(wl, addr, buf, len);
 
 		chunk_num++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* 10.4 upload the last chunk */
@@ -423,6 +434,11 @@ static int wl1251_boot_upload_nvs(struct
 	 * This is ended by a 0 length, then the NVS tables.
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nvs_ptr[0]) {
 		burst_len = nvs_ptr[0];
 		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));
@@ -442,6 +458,12 @@ static int wl1251_boot_upload_nvs(struct
 			nvs_ptr += 4;
 			dest_addr += 4;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -460,7 +482,12 @@ static int wl1251_boot_upload_nvs(struct
 
 	/* And finally we upload the NVS tables */
 	nvs_bytes_written = 0;
-	while (nvs_bytes_written < nvs_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nvs_bytes_written < nvs_len) {
 		val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
 		       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));
 
@@ -474,6 +501,12 @@ static int wl1251_boot_upload_nvs(struct
 		nvs_ptr += 4;
 		nvs_bytes_written += 4;
 		nvs_start += 4;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
diff -u -p a/net/wireless/wl12xx/ps.c b/net/wireless/wl12xx/ps.c
--- a/net/wireless/wl12xx/ps.c
+++ b/net/wireless/wl12xx/ps.c
@@ -202,6 +202,11 @@ static void wl1271_ps_filter_frames(stru
 	/* filter all frames currently in the low level queues for this hlid */
 	for (i = 0; i < NUM_TX_QUEUES; i++) {
 		filtered[i] = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((skb = skb_dequeue(&wl->links[hlid].tx_queue[i]))) {
 			filtered[i]++;
 
@@ -212,6 +217,12 @@ static void wl1271_ps_filter_frames(stru
 			info->flags |= IEEE80211_TX_STAT_TX_FILTERED;
 			info->status.rates[0].idx = -1;
 			ieee80211_tx_status_ni(wl->hw, skb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/wireless/wl12xx/rx.c b/net/wireless/wl12xx/rx.c
--- a/net/wireless/wl12xx/rx.c
+++ b/net/wireless/wl12xx/rx.c
@@ -239,7 +239,12 @@ void wl12xx_rx(struct wl1271 *wl, struct
 
 		/* Split data into separate packets */
 		pkt_offset = 0;
-		while (pkt_offset < buf_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (pkt_offset < buf_size) {
 			pkt_length = wl12xx_rx_get_buf_size(status,
 					drv_rx_counter);
 
@@ -260,6 +265,12 @@ void wl12xx_rx(struct wl1271 *wl, struct
 			drv_rx_counter++;
 			drv_rx_counter &= NUM_RX_PKT_DESC_MOD_MASK;
 			pkt_offset += pkt_length;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/net/wireless/wl12xx/tx.c b/net/wireless/wl12xx/tx.c
--- a/net/wireless/wl12xx/tx.c
+++ b/net/wireless/wl12xx/tx.c
@@ -651,6 +651,11 @@ void wl1271_tx_work_locked(struct wl1271
 	if (unlikely(wl->state == WL1271_STATE_OFF))
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = wl1271_skb_dequeue(wl))) {
 		if (wl1271_tx_is_data_present(skb))
 			had_data = true;
@@ -682,7 +687,13 @@ void wl1271_tx_work_locked(struct wl1271
 		}
 		buf_offset += ret;
 		wl->tx_packets_count++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out_ack:
 	if (buf_offset) {
@@ -863,6 +874,11 @@ void wl1271_tx_reset_link_queues(struct
 
 	for (i = 0; i < NUM_TX_QUEUES; i++) {
 		total[i] = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((skb = skb_dequeue(&wl->links[hlid].tx_queue[i]))) {
 			wl1271_debug(DEBUG_TX, "link freeing skb 0x%p", skb);
 
@@ -874,6 +890,12 @@ void wl1271_tx_reset_link_queues(struct
 			}
 
 			total[i]++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -904,7 +926,12 @@ void wl1271_tx_reset(struct wl1271 *wl,
 		wl->last_tx_hlid = 0;
 	} else {
 		for (i = 0; i < NUM_TX_QUEUES; i++) {
-			while ((skb = skb_dequeue(&wl->tx_queue[i]))) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while ((skb = skb_dequeue(&wl->tx_queue[i]))) {
 				wl1271_debug(DEBUG_TX, "freeing skb 0x%p",
 					     skb);
 
@@ -914,6 +941,12 @@ void wl1271_tx_reset(struct wl1271 *wl,
 					info->status.rates[0].count = 0;
 					ieee80211_tx_status_ni(wl->hw, skb);
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
@@ -973,7 +1006,12 @@ void wl1271_tx_flush(struct wl1271 *wl)
 	unsigned long timeout;
 	timeout = jiffies + usecs_to_jiffies(WL1271_TX_FLUSH_TIMEOUT);
 
-	while (!time_after(jiffies, timeout)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!time_after(jiffies, timeout)) {
 		mutex_lock(&wl->mutex);
 		wl1271_debug(DEBUG_TX, "flushing tx buffer: %d %d",
 			     wl->tx_frames_cnt,
@@ -985,6 +1023,12 @@ void wl1271_tx_flush(struct wl1271 *wl)
 		}
 		mutex_unlock(&wl->mutex);
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	wl1271_warning("Unable to flush all TX buffers, timed out.");
diff -u -p a/net/wireless/wl12xx/cmd.c b/net/wireless/wl12xx/cmd.c
--- a/net/wireless/wl12xx/cmd.c
+++ b/net/wireless/wl12xx/cmd.c
@@ -71,6 +71,11 @@ int wl1271_cmd_send(struct wl1271 *wl, u
 	timeout = jiffies + msecs_to_jiffies(WL1271_COMMAND_TIMEOUT);
 
 	intr = wl1271_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(intr & WL1271_ACX_INTR_CMD_COMPLETE)) {
 		if (time_after(jiffies, timeout)) {
 			wl1271_error("command complete timeout");
@@ -85,6 +90,12 @@ int wl1271_cmd_send(struct wl1271 *wl, u
 			msleep(1);
 
 		intr = wl1271_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* read back the status code of the command */
diff -u -p a/net/wireless/wl12xx/spi.c b/net/wireless/wl12xx/spi.c
--- a/net/wireless/wl12xx/spi.c
+++ b/net/wireless/wl12xx/spi.c
@@ -186,6 +186,11 @@ static int wl1271_spi_read_busy(struct w
 
 	num_busy_bytes = WL1271_BUSY_WORD_TIMEOUT;
 	busy_buf = wl->buffer_busyword;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num_busy_bytes) {
 		num_busy_bytes--;
 		spi_message_init(&m);
@@ -198,6 +203,12 @@ static int wl1271_spi_read_busy(struct w
 
 		if (*busy_buf & 0x1)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* The SPI bus is unresponsive, the read failed. */
diff -u -p a/net/wireless/wl12xx/boot.c b/net/wireless/wl12xx/boot.c
--- a/net/wireless/wl12xx/boot.c
+++ b/net/wireless/wl12xx/boot.c
@@ -188,6 +188,11 @@ static int wl1271_boot_upload_firmware_c
 	chunk_num = 0;
 	partition_limit = part_table[PART_DOWN].mem.size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (chunk_num < fw_data_len / CHUNK_SIZE) {
 		/* 10.2 update partition, if needed */
 		addr = dest + (chunk_num + 2) * CHUNK_SIZE;
@@ -208,6 +213,12 @@ static int wl1271_boot_upload_firmware_c
 		wl1271_write(wl, addr, chunk, CHUNK_SIZE, false);
 
 		chunk_num++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* 10.4 upload the last chunk */
@@ -333,6 +344,11 @@ static int wl1271_boot_upload_nvs(struct
 	 */
 
 	/* FIXME: Do we need to check here whether the LSB is 1? */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nvs_ptr[0]) {
 		burst_len = nvs_ptr[0];
 		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));
@@ -364,6 +380,12 @@ static int wl1271_boot_upload_nvs(struct
 
 		if (nvs_ptr >= (u8 *) wl->nvs + nvs_len)
 			goto out_badnvs;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/*
diff -u -p a/net/wireless/wl12xx/main.c b/net/wireless/wl12xx/main.c
--- a/net/wireless/wl12xx/main.c
+++ b/net/wireless/wl12xx/main.c
@@ -1391,6 +1391,11 @@ int wl1271_plt_start(struct wl1271 *wl)
 
 	wl->bss_type = BSS_TYPE_STA_BSS;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retries) {
 		retries--;
 		ret = wl1271_chip_wakeup(wl);
@@ -1431,6 +1436,12 @@ irq_disable:
 		mutex_lock(&wl->mutex);
 power_off:
 		wl1271_power_off(wl);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	wl1271_error("firmware boot in PLT mode failed despite %d retries",
diff -u -p a/net/wireless/wl12xx/sdio_test.c b/net/wireless/wl12xx/sdio_test.c
--- a/net/wireless/wl12xx/sdio_test.c
+++ b/net/wireless/wl12xx/sdio_test.c
@@ -368,6 +368,11 @@ static int tester(void *data)
 	/* write something in data area so we can read it back */
 	wl1271_write(wl, addr, tx_buf, test_size, false);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		if (rx && !rx_started) {
 			dev_info(pdev, "starting rx test\n");
@@ -393,7 +398,13 @@ static int tester(void *data)
 
 		if (!rx_started && !tx_started)
 			msleep(100);
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+}
 
 free:
 	kfree(tx_buf);
diff -u -p a/net/wireless/atmel.c b/net/wireless/atmel.c
--- a/net/wireless/atmel.c
+++ b/net/wireless/atmel.c
@@ -1187,6 +1187,11 @@ static irqreturn_t service_interrupt(int
 
 	atmel_clear_gcr(dev, GCR_ENINT); /* disable interrupts */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (!atmel_lock_mac(priv)) {
 			/* failed to contact card */
@@ -1260,6 +1265,12 @@ static irqreturn_t service_interrupt(int
 			printk(KERN_INFO "%s: Generic_irq received.\n", dev->name);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/libertas/cfg.c b/net/wireless/libertas/cfg.c
--- a/net/wireless/libertas/cfg.c
+++ b/net/wireless/libertas/cfg.c
@@ -215,7 +215,12 @@ static int lbs_add_channel_list_tlv(stru
 		     last_channel); */
 	memset(tlv, 0, chanscanparamsize);
 
-	while (priv->scan_channel < last_channel) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (priv->scan_channel < last_channel) {
 		struct chanscanparamset *param = (void *) tlv;
 
 		param->radiotype = CMD_SCAN_RADIO_TYPE_BG;
@@ -229,6 +234,12 @@ static int lbs_add_channel_list_tlv(stru
 		}
 		tlv += sizeof(struct chanscanparamset);
 		priv->scan_channel++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return sizeof(struct mrvl_ie_header) + chanscanparamsize;
 }
diff -u -p a/net/wireless/libertas/if_sdio.c b/net/wireless/libertas/if_sdio.c
--- a/net/wireless/libertas/if_sdio.c
+++ b/net/wireless/libertas/if_sdio.c
@@ -494,6 +494,11 @@ static int if_sdio_prog_helper(struct if
 	firmware = fw->data;
 	size = fw->size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		ret = if_sdio_wait_status(card, FW_DL_READY_STATUS);
 		if (ret)
@@ -518,6 +523,12 @@ static int if_sdio_prog_helper(struct if
 
 		firmware += chunk_size;
 		size -= chunk_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* an empty block marks the end of the transfer */
@@ -593,6 +604,11 @@ static int if_sdio_prog_real(struct if_s
 	firmware = fw->data;
 	size = fw->size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		ret = if_sdio_wait_status(card, FW_DL_READY_STATUS);
 		if (ret)
@@ -623,7 +639,12 @@ static int if_sdio_prog_real(struct if_s
 		if (req_size > size)
 			req_size = size;
 
-		while (req_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (req_size) {
 			chunk_size = min(req_size, (size_t)512);
 
 			memcpy(chunk_buffer, firmware, chunk_size);
@@ -639,6 +660,18 @@ static int if_sdio_prog_real(struct if_s
 			firmware += chunk_size;
 			size -= chunk_size;
 			req_size -= chunk_size;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -1238,10 +1271,21 @@ err_activate_card:
 	lbs_remove_card(priv);
 free:
 	destroy_workqueue(card->workqueue);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card->packets) {
 		packet = card->packets;
 		card->packets = card->packets->next;
 		kfree(packet);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (card->helper_allocated)
@@ -1289,10 +1333,21 @@ static void if_sdio_remove(struct sdio_f
 	flush_workqueue(card->workqueue);
 	destroy_workqueue(card->workqueue);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card->packets) {
 		packet = card->packets;
 		card->packets = card->packets->next;
 		kfree(packet);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (card->helper_allocated)
diff -u -p a/net/wireless/libertas/debugfs.c b/net/wireless/libertas/debugfs.c
--- a/net/wireless/libertas/debugfs.c
+++ b/net/wireless/libertas/debugfs.c
@@ -213,6 +213,11 @@ static void *lbs_tlv_find(uint16_t tlv_t
 	uint16_t length;
 	ssize_t pos = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos < size) {
 		tlv_h = (struct mrvl_ie_header *) tlv;
 		if (!tlv_h->len)
@@ -222,6 +227,12 @@ static void *lbs_tlv_find(uint16_t tlv_t
 		length = le16_to_cpu(tlv_h->len) + sizeof(*tlv_h);
 		pos += length;
 		tlv += length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/net/wireless/libertas/if_spi.c b/net/wireless/libertas/if_spi.c
--- a/net/wireless/libertas/if_spi.c
+++ b/net/wireless/libertas/if_spi.c
@@ -295,6 +295,11 @@ static int spu_wait_for_u16(struct if_sp
 {
 	int err;
 	unsigned long timeout = jiffies + 5*HZ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		u16 val;
 		err = spu_read_u16(card, reg, &val);
@@ -313,6 +318,12 @@ static int spu_wait_for_u16(struct if_sp
 			       __func__, val, target_mask, target);
 			return -ETIMEDOUT;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/libertas/main.c b/net/wireless/libertas/main.c
--- a/net/wireless/libertas/main.c
+++ b/net/wireless/libertas/main.c
@@ -320,11 +320,22 @@ int lbs_set_mac_address(struct net_devic
 static inline int mac_in_list(unsigned char *list, int list_len,
 			      unsigned char *mac)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (list_len) {
 		if (!memcmp(list, mac, ETH_ALEN))
 			return 1;
 		list += ETH_ALEN;
 		list_len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1231,6 +1242,11 @@ int lbs_get_firmware(struct device *dev,
 	 * fw_table.
 	 */
 	iter = fw_table;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (iter && iter->helper) {
 		if (iter->model != card_model)
 			goto next;
@@ -1265,7 +1281,13 @@ int lbs_get_firmware(struct device *dev,
 
   next:
 		iter++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
   fail:
 	/* Failed */
diff -u -p a/net/wireless/orinoco/hermes.c b/net/wireless/orinoco/hermes.c
--- a/net/wireless/orinoco/hermes.c
+++ b/net/wireless/orinoco/hermes.c
@@ -111,10 +111,21 @@ static int hermes_issue_cmd(struct herme
 
 	/* First wait for the command register to unbusy */
 	reg = hermes_read_regn(hw, CMD);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((reg & HERMES_CMD_BUSY) && k) {
 		k--;
 		udelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (reg & HERMES_CMD_BUSY)
 		return -EBUSY;
@@ -146,10 +157,21 @@ static int hermes_doicmd_wait(struct her
 
 	reg = hermes_read_regn(hw, EVSTAT);
 	k = CMD_INIT_TIMEOUT;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((!(reg & HERMES_EV_CMD)) && k) {
 		k--;
 		udelay(10);
 		reg = hermes_read_regn(hw, EVSTAT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	hermes_write_regn(hw, SWSUPPORT0, HERMES_MAGIC);
@@ -215,6 +237,11 @@ static int hermes_init(struct hermes *hw
 	   will unbusy itself here. */
 	k = CMD_BUSY_TIMEOUT;
 	reg = hermes_read_regn(hw, CMD);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (k && (reg & HERMES_CMD_BUSY)) {
 		if (reg == 0xffff) /* Special case - the card has probably been
 				      removed, so don't wait for the timeout */
@@ -223,6 +250,12 @@ static int hermes_init(struct hermes *hw
 		k--;
 		udelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* No need to explicitly handle the timeout - if we've timed
@@ -276,10 +309,21 @@ static int hermes_docmd_wait(struct herm
 
 	reg = hermes_read_regn(hw, EVSTAT);
 	k = CMD_COMPL_TIMEOUT;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((!(reg & HERMES_EV_CMD)) && k) {
 		k--;
 		udelay(10);
 		reg = hermes_read_regn(hw, EVSTAT);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (!hermes_present(hw)) {
@@ -329,10 +373,21 @@ static int hermes_allocate(struct hermes
 
 	reg = hermes_read_regn(hw, EVSTAT);
 	k = ALLOC_COMPL_TIMEOUT;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((!(reg & HERMES_EV_ALLOC)) && k) {
 		k--;
 		udelay(10);
 		reg = hermes_read_regn(hw, EVSTAT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!hermes_present(hw)) {
@@ -377,10 +432,21 @@ static int hermes_bap_seek(struct hermes
 
 	k = HERMES_BAP_BUSY_TIMEOUT;
 	reg = hermes_read_reg(hw, oreg);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((reg & HERMES_OFFSET_BUSY) && k) {
 		k--;
 		udelay(1);
 		reg = hermes_read_reg(hw, oreg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (reg & HERMES_OFFSET_BUSY)
@@ -393,10 +459,21 @@ static int hermes_bap_seek(struct hermes
 	/* Wait for the BAP to be ready */
 	k = HERMES_BAP_BUSY_TIMEOUT;
 	reg = hermes_read_reg(hw, oreg);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((reg & (HERMES_OFFSET_BUSY | HERMES_OFFSET_ERR)) && k) {
 		k--;
 		udelay(1);
 		reg = hermes_read_reg(hw, oreg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (reg != offset) {
diff -u -p a/net/wireless/orinoco/orinoco_pci.c b/net/wireless/orinoco/orinoco_pci.c
--- a/net/wireless/orinoco/orinoco_pci.c
+++ b/net/wireless/orinoco/orinoco_pci.c
@@ -96,9 +96,20 @@ static int orinoco_pci_cor_reset(struct
 	/* The card is ready when it's no longer busy */
 	timeout = jiffies + (HERMES_PCI_COR_BUSYT * HZ / 1000);
 	reg = hermes_read_regn(hw, CMD);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {
 		mdelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Still busy? */
diff -u -p a/net/wireless/orinoco/orinoco_plx.c b/net/wireless/orinoco/orinoco_plx.c
--- a/net/wireless/orinoco/orinoco_plx.c
+++ b/net/wireless/orinoco/orinoco_plx.c
@@ -123,9 +123,20 @@ static int orinoco_plx_cor_reset(struct
 	/* Just in case, wait more until the card is no longer busy */
 	timeout = jiffies + (PLX_RESET_TIME * HZ / 1000);
 	reg = hermes_read_regn(hw, CMD);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {
 		mdelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Still busy? */
diff -u -p a/net/wireless/orinoco/orinoco_tmd.c b/net/wireless/orinoco/orinoco_tmd.c
--- a/net/wireless/orinoco/orinoco_tmd.c
+++ b/net/wireless/orinoco/orinoco_tmd.c
@@ -73,9 +73,20 @@ static int orinoco_tmd_cor_reset(struct
 	/* Just in case, wait more until the card is no longer busy */
 	timeout = jiffies + (TMD_RESET_TIME * HZ / 1000);
 	reg = hermes_read_regn(hw, CMD);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {
 		mdelay(1);
 		reg = hermes_read_regn(hw, CMD);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Still busy? */
diff -u -p a/net/wireless/zd1211rw/zd_mac.c b/net/wireless/zd1211rw/zd_mac.c
--- a/net/wireless/zd1211rw/zd_mac.c
+++ b/net/wireless/zd1211rw/zd_mac.c
@@ -744,6 +744,11 @@ static int zd_mac_config_beacon(struct i
 
 	end_jiffies = jiffies + HZ / 2; /*~500ms*/
 	message_jiffies = jiffies + HZ / 10; /*~100ms*/
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmp & 0x2) {
 		r = zd_ioread32_locked(&mac->chip, &tmp, CR_BCN_FIFO_SEMAPHORE);
 		if (r < 0)
@@ -760,6 +765,12 @@ static int zd_mac_config_beacon(struct i
 			}
 		}
 		msleep(20);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ioreqs[req_pos].addr = CR_BCN_FIFO;
diff -u -p a/net/wireless/rndis_wlan.c b/net/wireless/rndis_wlan.c
--- a/net/wireless/rndis_wlan.c
+++ b/net/wireless/rndis_wlan.c
@@ -2098,6 +2098,11 @@ resize_buf:
 	/* Device returns incorrect 'num_items'. Workaround by ignoring the
 	 * received 'num_items' and walking through full bssid buffer instead.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (check_bssid_list_item(bssid, bssid_len, buf, len)) {
 		if (rndis_bss_info_update(usbdev, bssid) && match_bssid &&
 		    matched) {
@@ -2107,6 +2112,12 @@ resize_buf:
 
 		real_count++;
 		bssid = next_bssid_list_item(bssid, &bssid_len, buf, len);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	netdev_dbg(usbdev->net, "%s(): num_items from device: %d, really found:"
diff -u -p a/net/wireless/libertas_tf/main.c b/net/wireless/libertas_tf/main.c
--- a/net/wireless/libertas_tf/main.c
+++ b/net/wireless/libertas_tf/main.c
@@ -721,9 +721,20 @@ void lbtf_bcn_sent(struct lbtf_private *
 	if (skb_queue_empty(&priv->bc_ps_buf)) {
 		bool tx_buff_bc = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((skb = ieee80211_get_buffered_bc(priv->hw, priv->vif))) {
 			skb_queue_tail(&priv->bc_ps_buf, skb);
 			tx_buff_bc = 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (tx_buff_bc) {
 			ieee80211_stop_queues(priv->hw);
diff -u -p a/net/wireless/ipw2x00/ipw2100.c b/net/wireless/ipw2x00/ipw2100.c
--- a/net/wireless/ipw2x00/ipw2100.c
+++ b/net/wireless/ipw2x00/ipw2100.c
@@ -676,12 +676,23 @@ static void printk_buf(int level, const
 	if (!(ipw2100_debug_level & level))
 		return;
 
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		printk(KERN_DEBUG "%s\n",
 		       snprint_line(line, sizeof(line), &data[ofs],
 				    min(len, 16U), ofs));
 		ofs += 16;
 		len -= min(len, 16U);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -2720,7 +2731,12 @@ static void __ipw2100_rx_process(struct
 
 	i = (rxq->next + 1) % rxq->entries;
 	s = i;
-	while (i != r) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i != r) {
 		/* IPW_DEBUG_RX("r = %d : w = %d : processing = %d\n",
 		   r, rxq->next, i); */
 
@@ -2793,6 +2809,12 @@ static void __ipw2100_rx_process(struct
 		rxq->drv[i].status.info.field = 0;
 
 		i = (i + 1) % rxq->entries;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (i != s) {
@@ -4000,7 +4022,12 @@ static ssize_t show_ordinals(struct devi
 		loop = 0;
 
 	/* sysfs provides us PAGE_SIZE buffer */
-	while (len < PAGE_SIZE - 128 && loop < ARRAY_SIZE(ord_data)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (len < PAGE_SIZE - 128 && loop < ARRAY_SIZE(ord_data)) {
 		val_len = sizeof(u32);
 
 		if (ipw2100_get_ordinal(priv, ord_data[loop].index, &val,
@@ -4013,6 +4040,12 @@ static ssize_t show_ordinals(struct devi
 				       ord_data[loop].index, val,
 				       ord_data[loop].desc);
 		loop++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return len;
@@ -5886,6 +5919,11 @@ static int ipw2100_close(struct net_devi
 	netif_stop_queue(dev);
 
 	/* Flush the TX queue ... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&priv->tx_pend_list)) {
 		element = priv->tx_pend_list.next;
 		packet = list_entry(element, struct ipw2100_tx_packet, list);
@@ -5898,6 +5936,12 @@ static int ipw2100_close(struct net_devi
 
 		list_add_tail(element, &priv->tx_free_list);
 		INC_STAT(&priv->tx_free_stat);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&priv->low_lock, flags);
 
diff -u -p a/net/wireless/ipw2x00/ipw2200.c b/net/wireless/ipw2x00/ipw2200.c
--- a/net/wireless/ipw2x00/ipw2200.c
+++ b/net/wireless/ipw2x00/ipw2200.c
@@ -265,12 +265,23 @@ static void printk_buf(int level, const
 	if (!(ipw_debug_level & level))
 		return;
 
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		snprint_line(line, sizeof(line), &data[ofs],
 			     min(len, 16U), ofs);
 		printk(KERN_DEBUG "%s\n", line);
 		ofs += 16;
 		len -= min(len, 16U);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -280,7 +291,12 @@ static int snprintk_buf(u8 * output, siz
 	u32 ofs = 0;
 	int total = 0;
 
-	while (size && len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size && len) {
 		out = snprint_line(output, size, &data[ofs],
 				   min_t(size_t, len, 16U), ofs);
 
@@ -289,6 +305,12 @@ static int snprintk_buf(u8 * output, siz
 		size -= out;
 		len -= min_t(size_t, len, 16U);
 		total += out;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return total;
 }
@@ -2959,6 +2981,11 @@ static int ipw_fw_dma_wait(struct ipw_pr
 	IPW_DEBUG_FW_INFO("sram_desc.last_cb_index:0x%08X\n",
 			  (int)priv->sram_desc.last_cb_index);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (current_index < priv->sram_desc.last_cb_index) {
 		udelay(50);
 		previous_index = current_index;
@@ -2974,6 +3001,12 @@ static int ipw_fw_dma_wait(struct ipw_pr
 			ipw_fw_dma_abort(priv);
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ipw_fw_dma_abort(priv);
diff -u -p a/net/wireless/brcm80211/brcmfmac/dhd_linux.c b/net/wireless/brcm80211/brcmfmac/dhd_linux.c
--- a/net/wireless/brcm80211/brcmfmac/dhd_linux.c
+++ b/net/wireless/brcm80211/brcmfmac/dhd_linux.c
@@ -1307,6 +1307,11 @@ int brcmf_netdev_wait_pend8021x(struct n
 	int ntimes = MAX_WAIT_FOR_8021X_TX;
 	int pend = brcmf_get_pend_8021x_cnt(drvr_priv);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ntimes && pend) {
 		if (pend) {
 			set_current_state(TASK_INTERRUPTIBLE);
@@ -1315,6 +1320,12 @@ int brcmf_netdev_wait_pend8021x(struct n
 			ntimes--;
 		}
 		pend = brcmf_get_pend_8021x_cnt(drvr_priv);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return pend;
 }
diff -u -p a/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c b/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c
--- a/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c
@@ -3351,11 +3351,22 @@ static void brcmf_flush_eq(struct brcmf_
 	struct brcmf_cfg80211_event_q *e;
 
 	spin_lock_irq(&cfg_priv->evt_q_lock);
-	while (!list_empty(&cfg_priv->evt_q_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cfg_priv->evt_q_list)) {
 		e = list_first_entry(&cfg_priv->evt_q_list,
 				     struct brcmf_cfg80211_event_q, evt_q_list);
 		list_del(&e->evt_q_list);
 		kfree(e);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irq(&cfg_priv->evt_q_lock);
 }
diff -u -p a/net/wireless/brcm80211/brcmfmac/dhd_sdio.c b/net/wireless/brcm80211/brcmfmac/dhd_sdio.c
--- a/net/wireless/brcm80211/brcmfmac/dhd_sdio.c
+++ b/net/wireless/brcm80211/brcmfmac/dhd_sdio.c
@@ -2861,6 +2861,11 @@ static int brcmf_sdbrcm_readconsole(stru
 	if (rv < 0)
 		return rv;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (c->last != idx) {
 		for (n = 0; n < CONSOLE_LINE_MAX - 2; n++) {
 			if (c->last == idx) {
@@ -2888,7 +2893,13 @@ static int brcmf_sdbrcm_readconsole(stru
 			line[n] = 0;
 			printk(KERN_DEBUG "CONSOLE: %s\n", line);
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 break2:
 
 	return 0;
@@ -3429,6 +3440,11 @@ static int brcmf_sdbrcm_download_code_fi
 			   ((u32)(unsigned long)memblock % BRCMF_SDALIGN));
 
 	/* Download image */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((len =
 		brcmf_sdbrcm_get_image((char *)memptr, MEMBLOCK, bus))) {
 		ret = brcmf_sdbrcm_membytes(bus, true, offset, memptr, len);
@@ -3439,7 +3455,13 @@ static int brcmf_sdbrcm_download_code_fi
 		}
 
 		offset += MEMBLOCK;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 err:
 	kfree(memblock);
diff -u -p a/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c b/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c
--- a/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c
+++ b/net/wireless/brcm80211/brcmsmac/phy/phy_lcn.c
@@ -1214,6 +1214,11 @@ wlc_lcnphy_rx_iq_est(struct brcms_phy *p
 
 	mod_phy_reg(pi, 0x481, (0x1 << 9), (1) << 9);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (read_phy_reg(pi, 0x481) & (0x1 << 9)) {
 
 		if (wait_count > (10 * 500)) {
@@ -1222,6 +1227,12 @@ wlc_lcnphy_rx_iq_est(struct brcms_phy *p
 		}
 		udelay(100);
 		wait_count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	iq_est->iq_prod = ((u32) read_phy_reg(pi, 0x483) << 16) |
@@ -1732,9 +1743,20 @@ wlc_lcnphy_radio_2064_channel_tune_4313(
 	div_int = ((fvco3 * (PLL_2064_MHZ >> 4)) / fref3) << 4;
 
 	div_frac = ((fvco3 * (PLL_2064_MHZ >> 4)) % fref3) << 4;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (div_frac >= fref3) {
 		div_int++;
 		div_frac -= fref3;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	div_frac = wlc_lcnphy_qdiv_roundup(div_frac, fref3, 20);
 
diff -u -p a/net/wireless/brcm80211/brcmsmac/phy/phy_qmath.c b/net/wireless/brcm80211/brcmsmac/phy/phy_qmath.c
--- a/net/wireless/brcm80211/brcmsmac/phy/phy_qmath.c
+++ b/net/wireless/brcm80211/brcmsmac/phy/phy_qmath.c
@@ -171,9 +171,20 @@ s16 qm_norm32(s32 op)
 		return 31;
 	} else {
 		u16extraSignBits = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((op >> 31) == (op >> 30)) {
 			u16extraSignBits++;
 			op = op << 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return u16extraSignBits;
diff -u -p a/net/wireless/brcm80211/brcmsmac/nicpci.c b/net/wireless/brcm80211/brcmsmac/nicpci.c
--- a/net/wireless/brcm80211/brcmsmac/nicpci.c
+++ b/net/wireless/brcm80211/brcmsmac/nicpci.c
@@ -437,6 +437,11 @@ pcie_mdioop(struct pcicore_info *pi, uin
 	pr28829_delay();
 
 	/* retry till the transaction is complete */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < pcie_serdes_spinwait) {
 		if (R_REG(&pcieregs->mdiocontrol) & MDIOCTL_ACCESS_DONE) {
 			if (!write) {
@@ -450,6 +455,12 @@ pcie_mdioop(struct pcicore_info *pi, uin
 		}
 		udelay(1000);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Timed out. Disable mdio access to SERDES. */
diff -u -p a/net/wireless/brcm80211/brcmsmac/dma.c b/net/wireless/brcm80211/brcmsmac/dma.c
--- a/net/wireless/brcm80211/brcmsmac/dma.c
+++ b/net/wireless/brcm80211/brcmsmac/dma.c
@@ -1178,10 +1178,21 @@ void dma_txreclaim(struct dma_pub *pub,
 	if (di->txin == di->txout)
 		return;
 
-	while ((p = dma_getnexttxp(pub, range))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while ((p = dma_getnexttxp(pub, range))) {
 		/* For unframed data, we don't have any packets to free */
 		if (!(di->dma.dmactrlflags & DMA_CTRL_UNFRAMED))
 			brcmu_pkt_buf_free_skb(p);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1415,6 +1426,11 @@ void dma_walk_packets(struct dma_pub *dm
 	struct sk_buff *skb;
 	struct ieee80211_tx_info *tx_info;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i != end) {
 		skb = (struct sk_buff *)di->txp[i];
 		if (skb != NULL) {
@@ -1422,5 +1438,11 @@ void dma_walk_packets(struct dma_pub *dm
 			(callback_fnc)(tx_info, arg_a);
 		}
 		i = nexttxd(di, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
diff -u -p a/net/wireless/brcm80211/brcmsmac/mac80211_if.c b/net/wireless/brcm80211/brcmsmac/mac80211_if.c
--- a/net/wireless/brcm80211/brcmsmac/mac80211_if.c
+++ b/net/wireless/brcm80211/brcmsmac/mac80211_if.c
@@ -1532,6 +1532,11 @@ void brcms_free_timer(struct brcms_timer
 	}
 
 	tmp = wl->timers;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmp) {
 		if (tmp->next == t) {
 			tmp->next = t->next;
@@ -1542,6 +1547,12 @@ void brcms_free_timer(struct brcms_timer
 			return;
 		}
 		tmp = tmp->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
diff -u -p a/net/wireless/brcm80211/brcmsmac/srom.c b/net/wireless/brcm80211/brcmsmac/srom.c
--- a/net/wireless/brcm80211/brcmsmac/srom.c
+++ b/net/wireless/brcm80211/brcmsmac/srom.c
@@ -975,7 +975,12 @@ _initvars_srom_pci(u8 sromrev, u16 *srom
 			val = (w & srv->mask) >> mask_shift(srv->mask);
 			width = mask_width(srv->mask);
 
-			while (srv->flags & SRFL_MORE) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				    while (srv->flags & SRFL_MORE) {
 				srv++;
 				if (srv->off == 0)
 					continue;
@@ -986,6 +991,12 @@ _initvars_srom_pci(u8 sromrev, u16 *srom
 								   mask)) <<
 				    width;
 				width += mask_width(srv->mask);
+				if (_cur < timeout) {
+				    rdstcll(_cur);
+				}
+				else {
+				    break;
+				}
 			}
 
 			if ((flags & SRFL_NOFFS)
diff -u -p a/net/wireless/brcm80211/brcmutil/utils.c b/net/wireless/brcm80211/brcmutil/utils.c
--- a/net/wireless/brcm80211/brcmutil/utils.c
+++ b/net/wireless/brcm80211/brcmutil/utils.c
@@ -44,7 +44,12 @@ void brcmu_pkt_buf_free_skb(struct sk_bu
 	int nest = 0;
 
 	/* perversion: we use skb->next to chain multi-skb packets */
-	while (skb) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (skb) {
 		nskb = skb->next;
 		skb->next = NULL;
 
@@ -61,6 +66,12 @@ void brcmu_pkt_buf_free_skb(struct sk_bu
 
 		nest++;
 		skb = nskb;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL(brcmu_pkt_buf_free_skb);
@@ -227,6 +238,11 @@ brcmu_pktq_pflush(struct pktq *pq, int p
 
 	q = &pq->q[prec];
 	p = q->head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		if (fn == NULL || (*fn) (p, arg)) {
 			bool head = (p == q->head);
@@ -243,6 +259,12 @@ brcmu_pktq_pflush(struct pktq *pq, int p
 			prev = p;
 			p = p->prev;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (q->head == NULL)
diff -u -p a/net/wireless/prism54/islpci_eth.c b/net/wireless/prism54/islpci_eth.c
--- a/net/wireless/prism54/islpci_eth.c
+++ b/net/wireless/prism54/islpci_eth.c
@@ -43,7 +43,12 @@ islpci_eth_cleanup_transmit(islpci_priva
 	u32 index;
 
 	/* compare the control block read pointer with the free pointer */
-	while (priv->free_data_tx !=
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (priv->free_data_tx !=
 	       le32_to_cpu(control_block->
 			   device_curr_frag[ISL38XX_CB_TX_DATA_LQ])) {
 		/* read the index of the first fragment to be freed */
@@ -70,6 +75,12 @@ islpci_eth_cleanup_transmit(islpci_priva
 		}
 		/* increment the free data low queue pointer */
 		priv->free_data_tx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/prism54/islpci_mgt.c b/net/wireless/prism54/islpci_mgt.c
--- a/net/wireless/prism54/islpci_mgt.c
+++ b/net/wireless/prism54/islpci_mgt.c
@@ -87,6 +87,11 @@ pimfor_decode_header(void *data, int len
 {
 	pimfor_header_t *h = data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((void *) h < data + len) {
 		if (h->flags & PIMFOR_FLAG_LITTLE_ENDIAN) {
 			le32_to_cpus(&h->oid);
@@ -98,6 +103,12 @@ pimfor_decode_header(void *data, int len
 		if (h->oid != OID_INL_TUNNEL)
 			return h;
 		h++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/net/wireless/prism54/isl_ioctl.c b/net/wireless/prism54/isl_ioctl.c
--- a/net/wireless/prism54/isl_ioctl.c
+++ b/net/wireless/prism54/isl_ioctl.c
@@ -2224,7 +2224,12 @@ prism54_process_bss_data(islpci_private
 	hdr = (struct ieee80211_beacon_phdr *) payload;
 	pos = (u8 *) (hdr + 1);
 	end = payload + len;
-	while (pos < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (pos < end) {
 		if (pos + 2 + pos[1] > end) {
 			printk(KERN_DEBUG "Parsing Beacon/ProbeResp failed "
 			       "for %pM\n", addr);
@@ -2236,6 +2241,12 @@ prism54_process_bss_data(islpci_private
 			return;
 		}
 		pos += 2 + pos[1];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/net/wireless/prism54/oid_mgt.c b/net/wireless/prism54/oid_mgt.c
--- a/net/wireless/prism54/oid_mgt.c
+++ b/net/wireless/prism54/oid_mgt.c
@@ -601,7 +601,12 @@ mgt_commit_list(islpci_private *priv, en
 		int j = 0;
 		u32 oid = t->oid;
 		BUG_ON(data == NULL);
-		while (j <= t->range) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (j <= t->range) {
 			int r = islpci_mgt_transaction(priv->ndev, PIMFOR_OP_SET,
 						      oid, data, t->size,
 						      &response);
@@ -617,6 +622,12 @@ mgt_commit_list(islpci_private *priv, en
 			j++;
 			oid++;
 			data += t->size;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return ret;
diff -u -p a/net/vmxnet3/vmxnet3_drv.c b/net/vmxnet3/vmxnet3_drv.c
--- a/net/vmxnet3/vmxnet3_drv.c
+++ b/net/vmxnet3/vmxnet3_drv.c
@@ -349,7 +349,12 @@ vmxnet3_unmap_pkt(u32 eop_idx, struct vm
 
 	VMXNET3_INC_RING_IDX_ONLY(eop_idx, tq->tx_ring.size);
 
-	while (tq->tx_ring.next2comp != eop_idx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tq->tx_ring.next2comp != eop_idx) {
 		vmxnet3_unmap_tx_buf(tq->buf_info + tq->tx_ring.next2comp,
 				     pdev);
 
@@ -360,6 +365,12 @@ vmxnet3_unmap_pkt(u32 eop_idx, struct vm
 		 */
 		vmxnet3_cmd_ring_adv_next2comp(&tq->tx_ring);
 		entries++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	dev_kfree_skb_any(skb);
@@ -375,13 +386,24 @@ vmxnet3_tq_tx_complete(struct vmxnet3_tx
 	union Vmxnet3_GenericDesc *gdesc;
 
 	gdesc = tq->comp_ring.base + tq->comp_ring.next2proc;
-	while (VMXNET3_TCD_GET_GEN(&gdesc->tcd) == tq->comp_ring.gen) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (VMXNET3_TCD_GET_GEN(&gdesc->tcd) == tq->comp_ring.gen) {
 		completed += vmxnet3_unmap_pkt(VMXNET3_TCD_GET_TXIDX(
 					       &gdesc->tcd), tq, adapter->pdev,
 					       adapter);
 
 		vmxnet3_comp_ring_adv_next2proc(&tq->comp_ring);
 		gdesc = tq->comp_ring.base + tq->comp_ring.next2proc;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (completed) {
@@ -404,6 +426,11 @@ vmxnet3_tq_cleanup(struct vmxnet3_tx_que
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tq->tx_ring.next2comp != tq->tx_ring.next2fill) {
 		struct vmxnet3_tx_buf_info *tbi;
 
@@ -415,6 +442,12 @@ vmxnet3_tq_cleanup(struct vmxnet3_tx_que
 			tbi->skb = NULL;
 		}
 		vmxnet3_cmd_ring_adv_next2comp(&tq->tx_ring);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* sanity check, verify all buffers are indeed unmapped and freed */
@@ -708,6 +741,11 @@ vmxnet3_map_pkt(struct sk_buff *skb, str
 	/* linear part can use multiple tx desc if it's big */
 	len = skb_headlen(skb) - ctx->copy_size;
 	buf_offset = ctx->copy_size;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		u32 buf_size;
 
@@ -743,6 +781,12 @@ vmxnet3_map_pkt(struct sk_buff *skb, str
 
 		len -= buf_size;
 		buf_offset += buf_size;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
@@ -1295,7 +1339,12 @@ rcd_done:
 		ring->next2comp = idx;
 		num_to_alloc = vmxnet3_cmd_ring_desc_avail(ring);
 		ring = rq->rx_ring + ring_idx;
-		while (num_to_alloc) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (num_to_alloc) {
 			vmxnet3_getRxDesc(rxd, &ring->base[ring->next2fill].rxd,
 					  &rxCmdDesc);
 			BUG_ON(!rxd->addr);
@@ -1304,6 +1353,12 @@ rcd_done:
 			rxd->gen = ring->gen;
 			vmxnet3_cmd_ring_adv_next2fill(ring);
 			num_to_alloc--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		/* if needed, update the register */
diff -u -p a/mtd/ubi/wl.c b/mtd/ubi/wl.c
--- a/mtd/ubi/wl.c
+++ b/mtd/ubi/wl.c
@@ -188,6 +188,11 @@ static void wl_tree_add(struct ubi_wl_en
 	struct rb_node **p, *parent = NULL;
 
 	p = &root->rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*p) {
 		struct ubi_wl_entry *e1;
 
@@ -205,6 +210,12 @@ static void wl_tree_add(struct ubi_wl_en
 			else
 				p = &(*p)->rb_right;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	rb_link_node(&e->u.rb, parent, p);
@@ -272,6 +283,11 @@ static int produce_free_peb(struct ubi_d
 	int err;
 
 	spin_lock(&ubi->wl_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!ubi->free.rb_node) {
 		spin_unlock(&ubi->wl_lock);
 
@@ -281,6 +297,12 @@ static int produce_free_peb(struct ubi_d
 			return err;
 
 		spin_lock(&ubi->wl_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock(&ubi->wl_lock);
 
@@ -300,6 +322,11 @@ static int in_wl_tree(struct ubi_wl_entr
 	struct rb_node *p;
 
 	p = root->rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		struct ubi_wl_entry *e1;
 
@@ -321,6 +348,12 @@ static int in_wl_tree(struct ubi_wl_entr
 			else
 				p = p->rb_right;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return 0;
@@ -364,6 +397,11 @@ static struct ubi_wl_entry *find_wl_entr
 	max += e->ec;
 
 	p = root->rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		struct ubi_wl_entry *e1;
 
@@ -374,6 +412,12 @@ static struct ubi_wl_entry *find_wl_entr
 			p = p->rb_right;
 			e = e1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return e;
@@ -1287,10 +1331,21 @@ int ubi_wl_flush(struct ubi_device *ubi)
 	 * the number of currently pending works.
 	 */
 	dbg_wl("flush (%d pending works)", ubi->works_count);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ubi->works_count) {
 		err = do_work(ubi);
 		if (err)
 			return err;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/*
@@ -1304,11 +1359,22 @@ int ubi_wl_flush(struct ubi_device *ubi)
 	 * And in case last was the WL worker and it canceled the LEB
 	 * movement, flush again.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ubi->works_count) {
 		dbg_wl("flush more (%d pending works)", ubi->works_count);
 		err = do_work(ubi);
 		if (err)
 			return err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -1324,6 +1390,11 @@ static void tree_destroy(struct rb_root
 	struct ubi_wl_entry *e;
 
 	rb = root->rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rb) {
 		if (rb->rb_left)
 			rb = rb->rb_left;
@@ -1342,6 +1413,12 @@ static void tree_destroy(struct rb_root
 
 			kmem_cache_free(ubi_wl_entry_slab, e);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1408,6 +1485,11 @@ int ubi_thread(void *u)
  */
 static void cancel_pending(struct ubi_device *ubi)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ubi->works)) {
 		struct ubi_work *wrk;
 
@@ -1416,6 +1498,12 @@ static void cancel_pending(struct ubi_de
 		wrk->func(ubi, wrk, 1);
 		ubi->works_count -= 1;
 		ubi_assert(ubi->works_count >= 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/ubi/eba.c b/mtd/ubi/eba.c
--- a/mtd/ubi/eba.c
+++ b/mtd/ubi/eba.c
@@ -99,6 +99,11 @@ static struct ubi_ltree_entry *ltree_loo
 	struct rb_node *p;
 
 	p = ubi->ltree.rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		struct ubi_ltree_entry *le;
 
@@ -116,6 +121,12 @@ static struct ubi_ltree_entry *ltree_loo
 			else
 				return le;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return NULL;
@@ -166,6 +177,11 @@ static struct ubi_ltree_entry *ltree_add
 		le_free = NULL;
 
 		p = &ubi->ltree.rb_node;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (*p) {
 			parent = *p;
 			le1 = rb_entry(parent, struct ubi_ltree_entry, rb);
@@ -181,6 +197,12 @@ static struct ubi_ltree_entry *ltree_add
 				else
 					p = &(*p)->rb_right;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 
 		rb_link_node(&le->rb, parent, p);
diff -u -p a/mtd/ubi/scan.c b/mtd/ubi/scan.c
--- a/mtd/ubi/scan.c
+++ b/mtd/ubi/scan.c
@@ -258,6 +258,11 @@ static struct ubi_scan_volume *add_volum
 	ubi_assert(vol_id == be32_to_cpu(vid_hdr->vol_id));
 
 	/* Walk the volume RB-tree to look if this volume is already present */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*p) {
 		parent = *p;
 		sv = rb_entry(parent, struct ubi_scan_volume, rb);
@@ -269,6 +274,12 @@ static struct ubi_scan_volume *add_volum
 			p = &(*p)->rb_left;
 		else
 			p = &(*p)->rb_right;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	/* The volume is absent - add it */
@@ -473,6 +484,11 @@ int ubi_scan_add_used(struct ubi_device
 	 * if this is the first instance of this logical eraseblock or not.
 	 */
 	p = &sv->root.rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*p) {
 		int cmp_res;
 
@@ -556,6 +572,12 @@ int ubi_scan_add_used(struct ubi_device
 			return add_to_list(si, pnum, ec, cmp_res & 4,
 					   &si->erase);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -603,6 +625,11 @@ struct ubi_scan_volume *ubi_scan_find_sv
 	struct ubi_scan_volume *sv;
 	struct rb_node *p = si->volumes.rb_node;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		sv = rb_entry(p, struct ubi_scan_volume, rb);
 
@@ -613,6 +640,12 @@ struct ubi_scan_volume *ubi_scan_find_sv
 			p = p->rb_left;
 		else
 			p = p->rb_right;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return NULL;
@@ -632,6 +665,11 @@ struct ubi_scan_leb *ubi_scan_find_seb(c
 	struct ubi_scan_leb *seb;
 	struct rb_node *p = sv->root.rb_node;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		seb = rb_entry(p, struct ubi_scan_leb, u.rb);
 
@@ -642,6 +680,12 @@ struct ubi_scan_leb *ubi_scan_find_seb(c
 			p = p->rb_left;
 		else
 			p = p->rb_right;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return NULL;
@@ -659,10 +703,21 @@ void ubi_scan_rm_volume(struct ubi_scan_
 
 	dbg_bld("remove scanning information about volume %d", sv->vol_id);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((rb = rb_first(&sv->root))) {
 		seb = rb_entry(rb, struct ubi_scan_leb, u.rb);
 		rb_erase(&seb->u.rb, &sv->root);
 		list_add_tail(&seb->u.list, &si->erase);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rb_erase(&sv->rb, &si->volumes);
@@ -1253,6 +1308,11 @@ static void destroy_sv(struct ubi_scan_i
 	struct ubi_scan_leb *seb;
 	struct rb_node *this = sv->root.rb_node;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (this) {
 		if (this->rb_left)
 			this = this->rb_left;
@@ -1270,6 +1330,12 @@ static void destroy_sv(struct ubi_scan_i
 
 			kmem_cache_free(si->scan_leb_slab, seb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(sv);
 }
@@ -1303,6 +1369,11 @@ void ubi_scan_destroy_si(struct ubi_scan
 
 	/* Destroy the volume RB-tree */
 	rb = si->volumes.rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rb) {
 		if (rb->rb_left)
 			rb = rb->rb_left;
@@ -1321,6 +1392,12 @@ void ubi_scan_destroy_si(struct ubi_scan
 
 			destroy_sv(si, sv);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (si->scan_leb_slab)
diff -u -p a/mtd/maps/vmax301.c b/mtd/maps/vmax301.c
--- a/mtd/maps/vmax301.c
+++ b/mtd/maps/vmax301.c
@@ -64,6 +64,11 @@ static map_word vmax301_read8(struct map
 
 static void vmax301_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
@@ -75,6 +80,12 @@ static void vmax301_copy_from(struct map
 		to += thislen;
 		from += thislen;
 		len -= thislen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -88,6 +99,11 @@ static void vmax301_write8(struct map_in
 
 static void vmax301_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
@@ -100,6 +116,12 @@ static void vmax301_copy_to(struct map_i
 		to += thislen;
 		from += thislen;
 		len -= thislen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/maps/octagon-5066.c b/mtd/maps/octagon-5066.c
--- a/mtd/maps/octagon-5066.c
+++ b/mtd/maps/octagon-5066.c
@@ -72,6 +72,11 @@ static map_word oct5066_read8(struct map
 
 static void oct5066_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
@@ -84,6 +89,12 @@ static void oct5066_copy_from(struct map
 		to += thislen;
 		from += thislen;
 		len -= thislen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -97,6 +108,11 @@ static void oct5066_write8(struct map_in
 
 static void oct5066_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
@@ -109,6 +125,12 @@ static void oct5066_copy_to(struct map_i
 		to += thislen;
 		from += thislen;
 		len -= thislen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/maps/pcmciamtd.c b/mtd/maps/pcmciamtd.c
--- a/mtd/maps/pcmciamtd.c
+++ b/mtd/maps/pcmciamtd.c
@@ -142,6 +142,11 @@ static void pcmcia_copy_from_remap(struc
 	unsigned long win_size = dev->win_size;
 
 	pr_debug("to = %p from = %lu len = %zd\n", to, from, len);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len) {
 		int toread = win_size - (from & (win_size-1));
 		caddr_t addr;
@@ -158,6 +163,12 @@ static void pcmcia_copy_from_remap(struc
 		len -= toread;
 		to += toread;
 		from += toread;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -191,6 +202,11 @@ static void pcmcia_copy_to_remap(struct
 	unsigned long win_size = dev->win_size;
 
 	pr_debug("to = %lu from = %p len = %zd\n", to, from, len);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len) {
 		int towrite = win_size - (to & (win_size-1));
 		caddr_t addr;
@@ -207,6 +223,12 @@ static void pcmcia_copy_to_remap(struct
 		len -= towrite;
 		to += towrite;
 		from += towrite;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/maps/pxa2xx-flash.c b/mtd/maps/pxa2xx-flash.c
--- a/mtd/maps/pxa2xx-flash.c
+++ b/mtd/maps/pxa2xx-flash.c
@@ -33,10 +33,21 @@ static void pxa2xx_map_inval_cache(struc
 	unsigned long end = start + len;
 
 	start &= ~(CACHELINESIZE - 1);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start < end) {
 		/* invalidate D cache line */
 		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (start));
 		start += CACHELINESIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/maps/sbc_gxx.c b/mtd/maps/sbc_gxx.c
--- a/mtd/maps/sbc_gxx.c
+++ b/mtd/maps/sbc_gxx.c
@@ -123,6 +123,11 @@ static map_word sbc_gxx_read8(struct map
 
 static void sbc_gxx_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
@@ -135,6 +140,12 @@ static void sbc_gxx_copy_from(struct map
 		to += thislen;
 		from += thislen;
 		len -= thislen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -148,6 +159,11 @@ static void sbc_gxx_write8(struct map_in
 
 static void sbc_gxx_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len) {
 		unsigned long thislen = len;
 		if (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))
@@ -160,6 +176,12 @@ static void sbc_gxx_copy_to(struct map_i
 		to += thislen;
 		from += thislen;
 		len -= thislen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/nand/gpmi-nand/gpmi-lib.c b/mtd/nand/gpmi-nand/gpmi-lib.c
--- a/mtd/nand/gpmi-nand/gpmi-lib.c
+++ b/mtd/nand/gpmi-nand/gpmi-lib.c
@@ -441,6 +441,11 @@ static int gpmi_nfc_compute_hardware_tim
 		 * the sample delay until we've satisified the constraints or
 		 * can't do any better.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&
 			(data_setup_in_cycles < nfc->max_data_setup_cycles)) {
 
@@ -450,6 +455,12 @@ static int gpmi_nfc_compute_hardware_tim
 			if (ideal_sample_delay_in_ns < 0)
 				ideal_sample_delay_in_ns = 0;
 
+				if (_cur < timeout) {
+	rdstcll(_cur);
+				}
+				else {
+	break;
+				}
 		}
 
 		/*
@@ -583,7 +594,12 @@ static int gpmi_nfc_compute_hardware_tim
 	 * Extend the data setup as needed to reduce the ideal sample delay
 	 * below the maximum permitted by the NFC.
 	 */
-	while ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((ideal_sample_delay_in_ns > max_sample_delay_in_ns) &&
 			(data_setup_in_cycles < nfc->max_data_setup_cycles)) {
 
 		/* Give a cycle to data setup. */
@@ -602,6 +618,12 @@ static int gpmi_nfc_compute_hardware_tim
 		/* Jam a negative ideal sample delay to zero. */
 		if (ideal_sample_delay_in_ns < 0)
 			ideal_sample_delay_in_ns = 0;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	/*
@@ -641,7 +663,12 @@ static int gpmi_nfc_compute_hardware_tim
 	 * toward the eye. Do not allow the number of data setup cycles to
 	 * exceed the maximum allowed by the NFC.
 	 */
-	while (SAMPLE_IS_NOT_WITHIN_THE_EYE &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (SAMPLE_IS_NOT_WITHIN_THE_EYE &&
 			(data_setup_in_cycles < nfc->max_data_setup_cycles)) {
 		/*
 		 * If control arrives here, the quantized sample delay falls
@@ -696,7 +723,13 @@ static int gpmi_nfc_compute_hardware_tim
 
 		if (sample_delay_factor > nfc->max_sample_delay_factor)
 			sample_delay_factor = nfc->max_sample_delay_factor;
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+}
 
 	/* Control arrives here when we're ready to return our results. */
 return_results:
diff -u -p a/mtd/nand/orion_nand.c b/mtd/nand/orion_nand.c
--- a/mtd/nand/orion_nand.c
+++ b/mtd/nand/orion_nand.c
@@ -50,11 +50,27 @@ static void orion_nand_read_buf(struct m
 	uint64_t *buf64;
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len && (unsigned long)buf & 7) {
 		*buf++ = readb(io_base);
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	buf64 = (uint64_t *)buf;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len/8) {
 		/*
 		 * Since GCC has no proper constraint (PR 43518)
@@ -65,6 +81,12 @@ static void orion_nand_read_buf(struct m
 
 		asm volatile ("ldrd\t%0, [%1]" : "=&r" (x) : "r" (io_base));
 		buf64[i++] = x;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	i *= 8;
 	while (i < len)
diff -u -p a/mtd/nand/cs553x_nand.c b/mtd/nand/cs553x_nand.c
--- a/mtd/nand/cs553x_nand.c
+++ b/mtd/nand/cs553x_nand.c
@@ -130,9 +130,20 @@ static void cs553x_write_byte(struct mtd
 	struct nand_chip *this = mtd->priv;
 	int i = 100000;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i && readb(this->IO_ADDR_R + MM_NAND_STS) & CS_NAND_CTLR_BUSY) {
 		udelay(1);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	writeb(byte, this->IO_ADDR_W + 0x801);
 }
diff -u -p a/mtd/nand/diskonchip.c b/mtd/nand/diskonchip.c
--- a/mtd/nand/diskonchip.c
+++ b/mtd/nand/diskonchip.c
@@ -258,6 +258,11 @@ static int _DoC_WaitReady(struct doc_pri
 			cond_resched();
 		}
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {
 			if (time_after(jiffies, timeo)) {
 				printk("_DoC_WaitReady timed out.\n");
@@ -265,6 +270,12 @@ static int _DoC_WaitReady(struct doc_pri
 			}
 			udelay(1);
 			cond_resched();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1150,10 +1161,21 @@ static inline int __init nftl_partscan(s
 		   virtual blocks (because MediaHeader+BBT must fit in 1).
 		 */
 		mh->UnitSizeFactor = 0xff;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (blocks > maxblocks) {
 			blocks >>= 1;
 			maxblocks = min(32768U, (maxblocks << 1) + psize);
 			mh->UnitSizeFactor--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		printk(KERN_WARNING "UnitSizeFactor=0x00 detected.  Correct value is assumed to be 0x%02x.\n", mh->UnitSizeFactor);
 	}
diff -u -p a/mtd/nand/nand_base.c b/mtd/nand/nand_base.c
--- a/mtd/nand/nand_base.c
+++ b/mtd/nand/nand_base.c
@@ -2587,7 +2587,12 @@ int nand_erase_nand(struct mtd_info *mtd
 
 	instr->state = MTD_ERASING;
 
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (len) {
 		/* Heck if we have a bad block, we do not erase bad blocks! */
 		if (nand_block_checkbad(mtd, ((loff_t) page) <<
 					chip->page_shift, 0, allowbbt)) {
@@ -2655,6 +2660,12 @@ int nand_erase_nand(struct mtd_info *mtd
 				bbt_masked_page = chip->bbt_td->pages[chipnr] &
 					BBT_PAGE_MASK;
 		}
+		if (_cur < timeout) {
+					rdstcll(_cur);
+		}
+		else {
+					break;
+		}
 	}
 	instr->state = MTD_ERASE_DONE;
 
diff -u -p a/mtd/nand/r852.c b/mtd/nand/r852.c
--- a/mtd/nand/r852.c
+++ b/mtd/nand/r852.c
@@ -245,12 +245,23 @@ void r852_write_buf(struct mtd_info *mtd
 	}
 
 	/* write DWORD chinks - faster */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		reg = buf[0] | buf[1] << 8 | buf[2] << 16 | buf[3] << 24;
 		r852_write_reg_dword(dev, R852_DATALINE, reg);
 		buf += 4;
 		len -= 4;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* write rest */
diff -u -p a/mtd/nand/alauda.c b/mtd/nand/alauda.c
--- a/mtd/nand/alauda.c
+++ b/mtd/nand/alauda.c
@@ -397,6 +397,11 @@ static int alauda_bounce_read(struct mtd
 		return -ENOMEM;
 
 	*retlen = len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		u8 oob[16];
 		size_t byte = from & al->bytemask;
@@ -411,6 +416,12 @@ static int alauda_bounce_read(struct mtd
 		buf += cplen;
 		from += cplen;
 		len -= cplen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	err = 0;
 	if (corrected)
@@ -432,7 +443,12 @@ static int alauda_read(struct mtd_info *
 		return alauda_bounce_read(mtd, from, len, retlen, buf);
 
 	*retlen = len;
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		u8 oob[16];
 
 		err = alauda_read_page(mtd, from, buf, oob,
@@ -443,6 +459,12 @@ static int alauda_read(struct mtd_info *
 		buf += mtd->writesize;
 		from += mtd->writesize;
 		len -= mtd->writesize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	err = 0;
 	if (corrected)
@@ -462,6 +484,11 @@ static int alauda_write(struct mtd_info
 		return -EINVAL;
 
 	*retlen = len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		u32 page = (to >> al->card->pageshift) & al->pagemask;
 		u8 oob[16] = {	'h', 'e', 'l', 'l', 'o', 0xff, 0xff, 0xff,
@@ -484,6 +511,12 @@ static int alauda_write(struct mtd_info
 		buf += mtd->writesize;
 		to += mtd->writesize;
 		len -= mtd->writesize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -498,6 +531,11 @@ static int __alauda_erase(struct mtd_inf
 	if ((ofs & al->blockmask) || (len & al->blockmask))
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		/* don't erase bad blocks */
 		err = alauda_isbad(mtd, ofs);
@@ -512,6 +550,12 @@ static int __alauda_erase(struct mtd_inf
 
 		ofs += mtd->erasesize;
 		len -= mtd->erasesize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/mtd/nand/omap2.c b/mtd/nand/omap2.c
--- a/mtd/nand/omap2.c
+++ b/mtd/nand/omap2.c
@@ -308,11 +308,22 @@ static void omap_write_buf_pref(struct m
 		else
 			omap_write_buf8(mtd, (u_char *)p, len);
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			w_count = gpmc_read_status(GPMC_PREFETCH_FIFO_CNT);
 			w_count = w_count >> 1;
 			for (i = 0; (i < w_count) && len; i++, len -= 2)
 				iowrite16(*p++, info->nand.IO_ADDR_W);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		/* wait for data to flushed-out before reset the prefetch */
 		tim = 0;
diff -u -p a/mtd/nand/mpc5121_nfc.c b/mtd/nand/mpc5121_nfc.c
--- a/mtd/nand/mpc5121_nfc.c
+++ b/mtd/nand/mpc5121_nfc.c
@@ -427,6 +427,11 @@ static void mpc5121_nfc_copy_spare(struc
 	/* Calculate number of valid bytes in each spare buffer */
 	sbsize = (mtd->oobsize / (mtd->writesize / 512)) & ~1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		/* Calculate spare buffer number */
 		s = offset / sbsize;
@@ -450,6 +455,12 @@ static void mpc5121_nfc_copy_spare(struc
 		buffer += blksize;
 		offset += blksize;
 		size -= blksize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	};
 }
 
@@ -513,6 +524,11 @@ static int mpc5121_nfc_verify_buf(struct
 	u_char tmp[256];
 	uint bsize;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		bsize = min(len, 256);
 		mpc5121_nfc_read_buf(mtd, tmp, bsize);
@@ -522,6 +538,12 @@ static int mpc5121_nfc_verify_buf(struct
 
 		buf += bsize;
 		len -= bsize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -764,6 +786,11 @@ static int __devinit mpc5121_nfc_probe(s
 
 	/* Reset NAND Flash controller */
 	nfc_set(mtd, NFC_CONFIG1, NFC_RESET);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nfc_read(mtd, NFC_CONFIG1) & NFC_RESET) {
 		if (resettime++ >= NFC_RESET_TIMEOUT) {
 			dev_err(dev, "Timeout while resetting NFC!\n");
@@ -772,6 +799,12 @@ static int __devinit mpc5121_nfc_probe(s
 		}
 
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Enable write to NFC memory */
diff -u -p a/mtd/nand/nand_bbt.c b/mtd/nand/nand_bbt.c
--- a/mtd/nand/nand_bbt.c
+++ b/mtd/nand/nand_bbt.c
@@ -190,6 +190,11 @@ static int read_bbt(struct mtd_info *mtd
 	marker_len = add_marker_len(td);
 	from = ((loff_t)page) << this->page_shift;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (totlen) {
 		len = min(totlen, (size_t)(1 << this->bbt_erase_shift));
 		if (marker_len) {
@@ -247,6 +252,12 @@ static int read_bbt(struct mtd_info *mtd
 		}
 		totlen -= len;
 		from += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return ret;
 }
diff -u -p a/mtd/devices/slram.c b/mtd/devices/slram.c
--- a/mtd/devices/slram.c
+++ b/mtd/devices/slram.c
@@ -161,8 +161,19 @@ static int register_device(char *name, u
 	slram_mtd_list_t **curmtd;
 
 	curmtd = &slram_mtdlist;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*curmtd) {
 		curmtd = &(*curmtd)->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*curmtd = kmalloc(sizeof(slram_mtd_list_t), GFP_KERNEL);
@@ -229,6 +240,11 @@ static void unregister_devices(void)
 {
 	slram_mtd_list_t *nextitem;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (slram_mtdlist) {
 		nextitem = slram_mtdlist->next;
 		mtd_device_unregister(slram_mtdlist->mtdinfo);
@@ -237,6 +253,12 @@ static void unregister_devices(void)
 		kfree(slram_mtdlist->mtdinfo);
 		kfree(slram_mtdlist);
 		slram_mtdlist = nextitem;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/devices/doc2000.c b/mtd/devices/doc2000.c
--- a/mtd/devices/doc2000.c
+++ b/mtd/devices/doc2000.c
@@ -85,6 +85,11 @@ static int _DoC_WaitReady(struct DiskOnC
 	pr_debug("_DoC_WaitReady called for out-of-line wait\n");
 
 	/* Out-of-line routine to wait for chip response */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {
 		/* issue 2 read from NOP register after reading from CDSNControl register
 	   	see Software Requirement 11.4 item 2. */
@@ -96,6 +101,12 @@ static int _DoC_WaitReady(struct DiskOnC
 		}
 		udelay(1);
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -516,7 +527,12 @@ void DoC2k_init(struct mtd_info *mtd)
 	if (doc2klist)
 		old = doc2klist->priv;
 
-	while (old) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (old) {
 		if (DoC2k_is_alias(old, this)) {
 			printk(KERN_NOTICE
 			       "Ignoring DiskOnChip 2000 at 0x%lX - already configured\n",
@@ -529,6 +545,12 @@ void DoC2k_init(struct mtd_info *mtd)
 			old = old->nextdoc->priv;
 		else
 			old = NULL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+	}
+	else {
+			break;
+	}
 	}
 
 
@@ -618,6 +640,11 @@ static int doc_read(struct mtd_info *mtd
 	mutex_lock(&this->lock);
 
 	*retlen = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (left) {
 		len = left;
 
@@ -737,6 +764,12 @@ static int doc_read(struct mtd_info *mtd
 		from += len;
 		left -= len;
 		buf += len;
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 
 	mutex_unlock(&this->lock);
@@ -764,6 +797,11 @@ static int doc_write(struct mtd_info *mt
 	mutex_lock(&this->lock);
 
 	*retlen = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (left) {
 		len = left;
 
@@ -912,6 +950,12 @@ static int doc_write(struct mtd_info *mt
 		to += len;
 		left -= len;
 		buf += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&this->lock);
@@ -1121,6 +1165,11 @@ static int doc_erase(struct mtd_info *mt
 	instr->state = MTD_ERASING;
 
 	/* FIXME: Do this in the background. Use timers or schedule_task() */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len) {
 		mychip = &this->chips[ofs >> this->chipshift];
 
@@ -1156,6 +1205,12 @@ static int doc_erase(struct mtd_info *mt
 		}
 		ofs += mtd->erasesize;
 		len -= mtd->erasesize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	instr->state = MTD_ERASE_DONE;
 
@@ -1178,6 +1233,11 @@ static void __exit cleanup_doc2000(void)
 	struct mtd_info *mtd;
 	struct DiskOnChip *this;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((mtd = doc2klist)) {
 		this = mtd->priv;
 		doc2klist = this->nextdoc;
@@ -1187,6 +1247,12 @@ static void __exit cleanup_doc2000(void)
 		iounmap(this->virtadr);
 		kfree(this->chips);
 		kfree(mtd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/devices/doc2001.c b/mtd/devices/doc2001.c
--- a/mtd/devices/doc2001.c
+++ b/mtd/devices/doc2001.c
@@ -323,7 +323,12 @@ void DoCMil_init(struct mtd_info *mtd)
 	if (docmillist)
 		old = docmillist->priv;
 
-	while (old) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (old) {
 		if (DoCMil_is_alias(this, old)) {
 			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium at "
 			       "0x%lX - already configured\n", this->physadr);
@@ -335,6 +340,12 @@ void DoCMil_init(struct mtd_info *mtd)
 			old = old->nextdoc->priv;
 		else
 			old = NULL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	mtd->name = "DiskOnChip Millennium";
@@ -821,6 +832,11 @@ static void __exit cleanup_doc2001(void)
 	struct mtd_info *mtd;
 	struct DiskOnChip *this;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((mtd=docmillist)) {
 		this = mtd->priv;
 		docmillist = this->nextdoc;
@@ -830,6 +846,12 @@ static void __exit cleanup_doc2001(void)
 		iounmap(this->virtadr);
 		kfree(this->chips);
 		kfree(mtd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/devices/block2mtd.c b/mtd/devices/block2mtd.c
--- a/mtd/devices/block2mtd.c
+++ b/mtd/devices/block2mtd.c
@@ -51,6 +51,11 @@ static int _block2mtd_erase(struct block
 	u_long *p;
 	u_long *max;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pages) {
 		page = page_read(mapping, index);
 		if (!page)
@@ -71,6 +76,12 @@ static int _block2mtd_erase(struct block
 		page_cache_release(page);
 		pages--;
 		index++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -113,7 +124,12 @@ static int block2mtd_read(struct mtd_inf
 	if (retlen)
 		*retlen = 0;
 
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		if ((offset + len) > PAGE_SIZE)
 			cpylen = PAGE_SIZE - offset;	// multiple pages
 		else
@@ -134,6 +150,12 @@ static int block2mtd_read(struct mtd_inf
 		buf += cpylen;
 		offset = 0;
 		index++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -151,7 +173,12 @@ static int _block2mtd_write(struct block
 
 	if (retlen)
 		*retlen = 0;
-	while (len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len) {
 		if ((offset+len) > PAGE_SIZE)
 			cpylen = PAGE_SIZE - offset;	// multiple pages
 		else
@@ -178,6 +205,12 @@ static int _block2mtd_write(struct block
 		buf += cpylen;
 		offset = 0;
 		index++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/mtd/devices/lart.c b/mtd/devices/lart.c
--- a/mtd/devices/lart.c
+++ b/mtd/devices/lart.c
@@ -414,7 +414,12 @@ static int flash_erase (struct mtd_info
    i = first;
 
    /* now erase those blocks */
-   while (len)
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
+	 while (len)
 	 {
 		if (!erase_block (addr))
 		  {
@@ -426,6 +431,12 @@ static int flash_erase (struct mtd_info
 		len -= mtd->eraseregions[i].erasesize;
 
 		if (addr == mtd->eraseregions[i].offset + (mtd->eraseregions[i].erasesize * mtd->eraseregions[i].numblocks)) i++;
+		if (_cur < timeout) {
+		  rdstcll(_cur);
+		}
+		else {
+		  break;
+		}
 	 }
 
    instr->state = MTD_ERASE_DONE;
diff -u -p a/mtd/devices/doc2001plus.c b/mtd/devices/doc2001plus.c
--- a/mtd/devices/doc2001plus.c
+++ b/mtd/devices/doc2001plus.c
@@ -446,7 +446,12 @@ void DoCMilPlus_init(struct mtd_info *mt
 	if (docmilpluslist)
 		old = docmilpluslist->priv;
 
-	while (old) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (old) {
 		if (DoCMilPlus_is_alias(this, old)) {
 			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium "
 				"Plus at 0x%lX - already configured\n",
@@ -459,6 +464,12 @@ void DoCMilPlus_init(struct mtd_info *mt
 			old = old->nextdoc->priv;
 		else
 			old = NULL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	mtd->name = "DiskOnChip Millennium Plus";
@@ -1086,6 +1097,11 @@ static void __exit cleanup_doc2001plus(v
 	struct mtd_info *mtd;
 	struct DiskOnChip *this;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((mtd=docmilpluslist)) {
 		this = mtd->priv;
 		docmilpluslist = this->nextdoc;
@@ -1095,6 +1111,12 @@ static void __exit cleanup_doc2001plus(v
 		iounmap(this->virtadr);
 		kfree(this->chips);
 		kfree(mtd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/mtd/devices/sst25l.c b/mtd/devices/sst25l.c
--- a/mtd/devices/sst25l.c
+++ b/mtd/devices/sst25l.c
@@ -195,6 +195,11 @@ static int sst25l_erase(struct mtd_info
 		return err;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (addr < end) {
 		err = sst25l_erase_sector(flash, addr);
 		if (err) {
@@ -205,6 +210,12 @@ static int sst25l_erase(struct mtd_info
 		}
 
 		addr += mtd->erasesize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&flash->lock);
diff -u -p a/mtd/devices/m25p80.c b/mtd/devices/m25p80.c
--- a/mtd/devices/m25p80.c
+++ b/mtd/devices/m25p80.c
@@ -315,6 +315,11 @@ static int m25p80_erase(struct mtd_info
 
 	/* "sector"-at-a-time erase */
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			if (erase_sector(flash, addr)) {
 				instr->state = MTD_ERASE_FAILED;
@@ -324,6 +329,12 @@ static int m25p80_erase(struct mtd_info
 
 			addr += mtd->erasesize;
 			len -= mtd->erasesize;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/mtd/devices/pmc551.c b/mtd/devices/pmc551.c
--- a/mtd/devices/pmc551.c
+++ b/mtd/devices/pmc551.c
@@ -141,6 +141,11 @@ static int pmc551_erase(struct mtd_info
 	} else {
 		/* We have to do multiple writes to get all the data
 		   written. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (soff_hi != eoff_hi) {
 #ifdef CONFIG_MTD_PMC551_DEBUG
 			printk(KERN_DEBUG "pmc551_erase() soff_hi: %ld, "
@@ -154,6 +159,12 @@ static int pmc551_erase(struct mtd_info
 			pmc551_point(mtd, (priv->base_map0 | soff_hi),
 				     priv->asize, &retlen,
 				     (void **)&ptr, NULL);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		memset(ptr, 0xff, eoff_lo);
 	}
@@ -254,6 +265,11 @@ static int pmc551_read(struct mtd_info *
 	} else {
 		/* We have to do multiple writes to get all the data
 		   written. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (soff_hi != eoff_hi) {
 #ifdef CONFIG_MTD_PMC551_DEBUG
 			printk(KERN_DEBUG "pmc551_read() soff_hi: %ld, "
@@ -267,6 +283,12 @@ static int pmc551_read(struct mtd_info *
 			soff_hi += priv->asize;
 			pmc551_point(mtd, soff_hi, priv->asize, retlen,
 				     (void **)&ptr, NULL);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		memcpy(copyto, ptr, eoff_lo);
 		copyto += eoff_lo;
@@ -321,6 +343,11 @@ static int pmc551_write(struct mtd_info
 	} else {
 		/* We have to do multiple writes to get all the data
 		   written. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (soff_hi != eoff_hi) {
 #ifdef CONFIG_MTD_PMC551_DEBUG
 			printk(KERN_DEBUG "pmc551_write() soff_hi: %ld, "
@@ -334,6 +361,12 @@ static int pmc551_write(struct mtd_info
 			soff_hi += priv->asize;
 			pmc551_point(mtd, soff_hi, priv->asize, retlen,
 				     (void **)&ptr, NULL);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		memcpy(ptr, copyfrom, eoff_lo);
 		copyfrom += eoff_lo;
@@ -844,6 +877,11 @@ static void __exit cleanup_pmc551(void)
 	struct mtd_info *mtd;
 	struct mypriv *priv;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((mtd = pmc551list)) {
 		priv = mtd->priv;
 		pmc551list = priv->nextpmc551;
@@ -859,6 +897,12 @@ static void __exit cleanup_pmc551(void)
 		mtd_device_unregister(mtd);
 		kfree(mtd);
 		found++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_NOTICE "pmc551: %d pmc551 devices unloaded\n", found);
diff -u -p a/mtd/ar7part.c b/mtd/ar7part.c
--- a/mtd/ar7part.c
+++ b/mtd/ar7part.c
@@ -93,18 +93,40 @@ static int create_mtd_partitions(struct
 
 	switch (header.checksum) {
 	case LOADER_MAGIC1:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (header.length) {
 			offset += sizeof(header) + header.length;
 			master->read(master, offset, sizeof(header),
 				     &len, (uint8_t *)&header);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		root_offset = offset + sizeof(header) + 4;
 		break;
 	case LOADER_MAGIC2:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (header.length) {
 			offset += sizeof(header) + header.length;
 			master->read(master, offset, sizeof(header),
 				     &len, (uint8_t *)&header);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		root_offset = offset + sizeof(header) + 4 + 0xff;
 		root_offset &= ~(uint32_t)0xff;
diff -u -p a/mtd/inftlcore.c b/mtd/inftlcore.c
--- a/mtd/inftlcore.c
+++ b/mtd/inftlcore.c
@@ -276,6 +276,11 @@ static u16 INFTL_foldchain(struct INFTLr
 	 * 512-byte block within the Chain.
 	 */
 	silly = MAX_LOOPS;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (thisEUN < inftl->nb_blocks) {
 		for (block = 0; block < inftl->EraseSize/SECTORSIZE; block ++) {
 			if ((BlockMap[block] != BLOCK_NIL) ||
@@ -314,6 +319,12 @@ static u16 INFTL_foldchain(struct INFTLr
 		}
 
 		thisEUN = inftl->PUtable[thisEUN];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -660,6 +671,11 @@ static void INFTL_trydeletechain(struct
 	 * each of the 512-byte blocks within the Chain.
 	 */
 	silly = MAX_LOOPS;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (thisEUN < inftl->nb_blocks) {
 		for (block = 0; block < inftl->EraseSize/SECTORSIZE; block++) {
 			if (BlockUsed[block] || BlockDeleted[block])
@@ -696,6 +712,12 @@ static void INFTL_trydeletechain(struct
 		}
 
 		thisEUN = inftl->PUtable[thisEUN];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (block = 0; block < inftl->EraseSize/SECTORSIZE; block++)
@@ -765,7 +787,12 @@ static int INFTL_deleteblock(struct INFT
 	pr_debug("INFTL: INFTL_deleteblock(inftl=%p,"
 		"block=%d)\n", inftl, block);
 
-	while (thisEUN < inftl->nb_blocks) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (thisEUN < inftl->nb_blocks) {
 		if (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +
 				   blockofs, 8, &retlen, (char *)&bci) < 0)
 			status = SECTOR_IGNORE;
@@ -795,7 +822,13 @@ static int INFTL_deleteblock(struct INFT
 			return 1;
 		}
 		thisEUN = inftl->PUtable[thisEUN];
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 foundit:
 	if (thisEUN != BLOCK_NIL) {
@@ -874,7 +907,12 @@ static int inftl_readblock(struct mtd_bl
 	pr_debug("INFTL: inftl_readblock(inftl=%p,block=%ld,"
 		"buffer=%p)\n", inftl, block, buffer);
 
-	while (thisEUN < inftl->nb_blocks) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (thisEUN < inftl->nb_blocks) {
 		if (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +
 				  blockofs, 8, &retlen, (char *)&bci) < 0)
 			status = SECTOR_IGNORE;
@@ -905,7 +943,13 @@ static int inftl_readblock(struct mtd_bl
 		}
 
 		thisEUN = inftl->PUtable[thisEUN];
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 foundit:
 	if (thisEUN == BLOCK_NIL) {
diff -u -p a/mtd/chips/cfi_cmdset_0001.c b/mtd/chips/cfi_cmdset_0001.c
--- a/mtd/chips/cfi_cmdset_0001.c
+++ b/mtd/chips/cfi_cmdset_0001.c
@@ -1151,6 +1151,11 @@ static int __xipram xip_wait_for_operati
 			 * until it's done.
 			 */
 			mutex_lock(&chip->mutex);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (chip->state != newstate) {
 				DECLARE_WAITQUEUE(wait, current);
 				set_current_state(TASK_UNINTERRUPTIBLE);
@@ -1159,6 +1164,12 @@ static int __xipram xip_wait_for_operati
 				schedule();
 				remove_wait_queue(&chip->wq, &wait);
 				mutex_lock(&chip->mutex);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			/* Disallow XIP again */
 			local_irq_disable();
@@ -1601,7 +1612,12 @@ static int cfi_intelext_write_words (str
 		}
 	}
 
-	while(len >= map_bankwidth(map)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while(len >= map_bankwidth(map)) {
 		map_word datum = map_word_load(map, buf);
 
 		ret = do_write_oneword(map, &cfi->chips[chipnum],
@@ -1620,6 +1636,12 @@ static int cfi_intelext_write_words (str
 			if (chipnum == cfi->numchips)
 				return 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (len & (map_bankwidth(map)-1)) {
@@ -2191,6 +2213,11 @@ do_otp_write(struct map_info *map, struc
 {
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		unsigned long bus_ofs = offset & ~(map_bankwidth(map)-1);
 		int gap = offset - bus_ofs;
@@ -2205,6 +2232,12 @@ do_otp_write(struct map_info *map, struc
 		offset += n;
 		buf += n;
 		size -= n;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/mtd/chips/cfi_cmdset_0002.c b/mtd/chips/cfi_cmdset_0002.c
--- a/mtd/chips/cfi_cmdset_0002.c
+++ b/mtd/chips/cfi_cmdset_0002.c
@@ -1309,7 +1309,12 @@ static int cfi_amdstd_write_words(struct
 	}
 
 	/* We are now aligned, write as much as possible */
-	while(len >= map_bankwidth(map)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while(len >= map_bankwidth(map)) {
 		map_word datum;
 
 		datum = map_word_load(map, buf);
@@ -1331,6 +1336,12 @@ static int cfi_amdstd_write_words(struct
 				return 0;
 			chipstart = cfi->chips[chipnum].start;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Write the trailing bytes if any */
@@ -1417,12 +1428,23 @@ static int __xipram do_write_buffer(stru
 	map_write(map, CMD(words - 1), cmd_adr);
 	/* Write data */
 	z = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(z < words * map_bankwidth(map)) {
 		datum = map_word_load(map, buf);
 		map_write(map, datum, adr + z);
 
 		z += map_bankwidth(map);
 		buf += map_bankwidth(map);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	z -= map_bankwidth(map);
 
@@ -1522,6 +1544,11 @@ static int cfi_amdstd_write_buffers(stru
 	}
 
 	/* Write buffer is worth it only if more than one word to write... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len >= map_bankwidth(map) * 2) {
 		/* We must not cross write block boundaries */
 		int size = wbufsize - (ofs & (wbufsize-1));
@@ -1547,6 +1574,12 @@ static int cfi_amdstd_write_buffers(stru
 			if (chipnum == cfi->numchips)
 				return 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (len) {
diff -u -p a/mtd/chips/cfi_cmdset_0020.c b/mtd/chips/cfi_cmdset_0020.c
--- a/mtd/chips/cfi_cmdset_0020.c
+++ b/mtd/chips/cfi_cmdset_0020.c
@@ -1304,10 +1304,21 @@ static int cfi_staa_unlock(struct mtd_in
 		unsigned long temp_len = len;
 
 		cfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);
-                while (temp_len) {
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (temp_len) {
 			printk("before unlock %x: block status register is %x\n",temp_adr,cfi_read_query(map, temp_adr+(2*ofs_factor)));
 			temp_adr += mtd->erasesize;
 			temp_len -= mtd->erasesize;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		cfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);
 	}
diff -u -p a/mtd/ftl.c b/mtd/ftl.c
--- a/mtd/ftl.c
+++ b/mtd/ftl.c
@@ -912,10 +912,21 @@ static int ftl_write(partition_t *part,
 	return -EIO;
     }
     /* See if we need to reclaim space, before we start */
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (part->FreeTotal < nblocks) {
 	ret = reclaim_block(part);
 	if (ret)
 	    return ret;
+	    if (_cur < timeout) {
+	    rdstcll(_cur);
+	    }
+	    else {
+	    break;
+	    }
     }
 
     bsize = 1 << part->header.EraseUnitSize;
@@ -1014,6 +1025,11 @@ static int ftl_discardsect(struct mtd_bl
 	pr_debug("FTL erase sector %ld for %d sectors\n",
 	      sector, nr_sects);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nr_sects) {
 		uint32_t old_addr = part->VirtualBlockMap[sector];
 		if (old_addr != 0xffffffff) {
@@ -1024,6 +1040,12 @@ static int ftl_discardsect(struct mtd_bl
 		}
 		nr_sects--;
 		sector++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return 0;
diff -u -p a/mtd/mtd_blkdevs.c b/mtd/mtd_blkdevs.c
--- a/mtd/mtd_blkdevs.c
+++ b/mtd/mtd_blkdevs.c
@@ -138,6 +138,11 @@ static int mtd_blktrans_thread(void *arg
 
 	spin_lock_irq(rq->queue_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		int res;
 
@@ -179,6 +184,12 @@ static int mtd_blktrans_thread(void *arg
 			req = NULL;
 
 		background_done = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (req)
diff -u -p a/mtd/lpddr/lpddr_cmds.c b/mtd/lpddr/lpddr_cmds.c
--- a/mtd/lpddr/lpddr_cmds.c
+++ b/mtd/lpddr/lpddr_cmds.c
@@ -161,6 +161,11 @@ static int wait_for_ready(struct map_inf
 		}
 		mutex_lock(&chip->mutex);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (chip->state != chip_state) {
 			/* Someone's suspended the operation: sleep */
 			DECLARE_WAITQUEUE(wait, current);
@@ -170,6 +175,12 @@ static int wait_for_ready(struct map_inf
 			schedule();
 			remove_wait_queue(&chip->wq, &wait);
 			mutex_lock(&chip->mutex);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if (chip->erase_suspended || chip->write_suspended)  {
 			/* Suspend has occurred while sleep: reset timeout */
diff -u -p a/mtd/tests/mtd_stresstest.c b/mtd/tests/mtd_stresstest.c
--- a/mtd/tests/mtd_stresstest.c
+++ b/mtd/tests/mtd_stresstest.c
@@ -201,9 +201,20 @@ static int do_write(void)
 		return err;
 	}
 	offs += len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (offs > mtd->erasesize) {
 		offsets[eb++] = mtd->erasesize;
 		offs -= mtd->erasesize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	offsets[eb] = offs;
 	return 0;
diff -u -p a/mtd/tests/mtd_torturetest.c b/mtd/tests/mtd_torturetest.c
--- a/mtd/tests/mtd_torturetest.c
+++ b/mtd/tests/mtd_torturetest.c
@@ -477,6 +477,11 @@ static void print_bufs(unsigned char *re
 	char *diff;
 
 	printk("Offset       Read                          Written\n");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len) {
 		printk("0x%08x: ", start + i);
 		diff = "   ";
@@ -497,6 +502,12 @@ static void print_bufs(unsigned char *re
 			printk(" %02x", written[start + i + j2]);
 		printk("\n");
 		i += 8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -517,6 +528,11 @@ static int countdiffs(unsigned char *buf
 			break;
 		}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < offset + len) {
 		if (buf[i] != check_buf[i]) {
 			(*bytesp)++;
@@ -528,6 +544,12 @@ static int countdiffs(unsigned char *buf
 			}
 		}
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return first;
diff -u -p a/mtd/ofpart.c b/mtd/ofpart.c
--- a/mtd/ofpart.c
+++ b/mtd/ofpart.c
@@ -52,6 +52,11 @@ static int parse_ofpart_partitions(struc
 
 	pp = NULL;
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((pp = of_get_next_child(node, pp))) {
 		const __be32 *reg;
 		int len;
@@ -74,6 +79,12 @@ static int parse_ofpart_partitions(struc
 			(*pparts)[i].mask_flags = MTD_WRITEABLE;
 
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!i) {
diff -u -p a/mtd/mtdchar.c b/mtd/mtdchar.c
--- a/mtd/mtdchar.c
+++ b/mtd/mtdchar.c
@@ -207,6 +207,11 @@ static ssize_t mtd_read(struct file *fil
 	if (!kbuf)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		len = min_t(size_t, count, size);
 
@@ -261,6 +266,12 @@ static ssize_t mtd_read(struct file *fil
 			return ret;
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(kbuf);
@@ -293,6 +304,11 @@ static ssize_t mtd_write(struct file *fi
 	if (!kbuf)
 		return -ENOMEM;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		len = min_t(size_t, count, size);
 
@@ -341,6 +357,12 @@ static ssize_t mtd_write(struct file *fi
 			kfree(kbuf);
 			return ret;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(kbuf);
diff -u -p a/mtd/mtdcore.c b/mtd/mtdcore.c
--- a/mtd/mtdcore.c
+++ b/mtd/mtdcore.c
@@ -743,6 +743,11 @@ void *mtd_kmalloc_up_to(const struct mtd
 
 	*size = min_t(size_t, *size, KMALLOC_MAX_SIZE);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*size > min_alloc) {
 		kbuf = kmalloc(*size, flags);
 		if (kbuf)
@@ -750,6 +755,12 @@ void *mtd_kmalloc_up_to(const struct mtd
 
 		*size >>= 1;
 		*size = ALIGN(*size, mtd->writesize);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/mtd/nftlcore.c b/mtd/nftlcore.c
--- a/mtd/nftlcore.c
+++ b/mtd/nftlcore.c
@@ -278,6 +278,11 @@ static u16 NFTL_foldchain (struct NFTLre
 	*/
 	silly = MAX_LOOPS;
 	targetEUN = BLOCK_NIL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (thisEUN <= nftl->lastEUN ) {
 		unsigned int status, foldmark;
 
@@ -340,6 +345,12 @@ static u16 NFTL_foldchain (struct NFTLre
 		}
 
 		thisEUN = nftl->ReplUnitTable[thisEUN];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (inplace) {
@@ -458,6 +469,11 @@ static u16 NFTL_foldchain (struct NFTLre
 
 	/* For each block in the old chain (except the targetEUN of course),
 	   free it and make it available for future use */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (thisEUN <= nftl->lastEUN && thisEUN != targetEUN) {
 		unsigned int EUNtmp;
 
@@ -473,6 +489,12 @@ static u16 NFTL_foldchain (struct NFTLre
 			nftl->numfreeEUNs++;
 		}
 		thisEUN = EUNtmp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Make this the new start of chain for thisVUC */
@@ -556,6 +578,11 @@ static inline u16 NFTL_findwriteunit(str
 		lastEUN = BLOCK_NIL;
 		writeEUN = nftl->EUNtable[thisVUC];
 		silly = MAX_LOOPS;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (writeEUN <= nftl->lastEUN) {
 			struct nftl_bci bci;
 			size_t retlen;
@@ -593,6 +620,12 @@ static inline u16 NFTL_findwriteunit(str
 
 			/* Skip to next block in chain */
 			writeEUN = nftl->ReplUnitTable[writeEUN];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* OK. We didn't find one in the existing chain, or there
@@ -729,7 +762,12 @@ static int nftl_readblock(struct mtd_blk
 	lastgoodEUN = BLOCK_NIL;
 
 	if (thisEUN != BLOCK_NIL) {
-		while (thisEUN < nftl->nb_blocks) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while (thisEUN < nftl->nb_blocks) {
 			if (nftl_read_oob(mtd, (thisEUN * nftl->EraseSize) +
 					  blockofs, 8, &retlen,
 					  (char *)&bci) < 0)
@@ -761,6 +799,12 @@ static int nftl_readblock(struct mtd_blk
 				return 1;
 			}
 			thisEUN = nftl->ReplUnitTable[thisEUN];
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/mtd/mtdpart.c b/mtd/mtdpart.c
--- a/mtd/mtdpart.c
+++ b/mtd/mtdpart.c
@@ -558,11 +558,22 @@ static struct mtd_part *allocate_partiti
 	if (master->block_isbad) {
 		uint64_t offs = 0;
 
-		while (offs < slave->mtd.size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (offs < slave->mtd.size) {
 			if (master->block_isbad(master,
 						offs + slave->offset))
 				slave->mtd.ecc_stats.badblocks++;
 			offs += slave->mtd.erasesize;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/mtd/mtdswap.c b/mtd/mtdswap.c
--- a/mtd/mtdswap.c
+++ b/mtd/mtdswap.c
@@ -221,6 +221,11 @@ static void __mtdswap_rb_add(struct rb_r
 	struct swap_eb *cur;
 
 	p = &root->rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*p) {
 		parent = *p;
 		cur = rb_entry(parent, struct swap_eb, rb);
@@ -228,6 +233,12 @@ static void __mtdswap_rb_add(struct rb_r
 			p = &(*p)->rb_right;
 		else
 			p = &(*p)->rb_left;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	rb_link_node(&eb->rb, parent, p);
@@ -255,9 +266,20 @@ static struct rb_node *mtdswap_rb_index(
 
 	p = rb_first(root);
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < idx && p) {
 		p = rb_next(p);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return p;
@@ -1027,10 +1049,21 @@ static void mtdswap_background(struct mt
 	struct mtdswap_dev *d = MTDSWAP_MBD_TO_MTDSWAP(dev);
 	int ret;
 
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (1) {
 		ret = mtdswap_gc(d, 1);
 		if (ret || mtd_blktrans_cease_background(dev))
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/pci/pcie/aer/aerdrv_core.c b/pci/pcie/aer/aerdrv_core.c
--- a/pci/pcie/aer/aerdrv_core.c
+++ b/pci/pcie/aer/aerdrv_core.c
@@ -627,7 +627,12 @@ static void aer_recover_work_func(struct
 	struct aer_recover_entry entry;
 	struct pci_dev *pdev;
 
-	while (kfifo_get(&aer_recover_ring, &entry)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (kfifo_get(&aer_recover_ring, &entry)) {
 		pdev = pci_get_domain_bus_and_slot(entry.domain, entry.bus,
 						   entry.devfn);
 		if (!pdev) {
@@ -638,6 +643,12 @@ static void aer_recover_work_func(struct
 		}
 		do_recovery(pdev, entry.severity);
 		pci_dev_put(pdev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 #endif
diff -u -p a/pci/pcie/aer/aer_inject.c b/pci/pcie/aer/aer_inject.c
--- a/pci/pcie/aer/aer_inject.c
+++ b/pci/pcie/aer/aer_inject.c
@@ -519,9 +519,20 @@ static void __exit aer_inject_exit(void)
 
 	misc_deregister(&aer_inject_device);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((bus_ops = pci_bus_ops_pop())) {
 		pci_bus_set_ops(bus_ops->bus, bus_ops->ops);
 		kfree(bus_ops);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_lock_irqsave(&inject_lock, flags);
diff -u -p a/pci/pcie/aspm.c b/pci/pcie/aspm.c
--- a/pci/pcie/aspm.c
+++ b/pci/pcie/aspm.c
@@ -324,6 +324,11 @@ static void pcie_aspm_check_latency(stru
 	link = endpoint->bus->self->link_state;
 	acceptable = &link->acceptable[PCI_FUNC(endpoint->devfn)];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (link) {
 		/* Check upstream direction L0s latency */
 		if ((link->aspm_capable & ASPM_STATE_L0S_UP) &&
@@ -346,6 +351,12 @@ static void pcie_aspm_check_latency(stru
 		l1_switch_latency += 1000;
 
 		link = link->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -482,9 +493,20 @@ static void pcie_config_aspm_link(struct
 
 static void pcie_config_aspm_path(struct pcie_link_state *link)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (link) {
 		pcie_config_aspm_link(link, policy_to_aspm_state(link));
 		link = link->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/pci/pci.c b/pci/pci.c
--- a/pci/pci.c
+++ b/pci/pci.c
@@ -374,6 +374,11 @@ static int __pci_find_next_ht_cap(struct
 
 	pos = __pci_find_next_cap_ttl(dev->bus, dev->devfn, pos,
 				      PCI_CAP_ID_HT, &ttl);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos) {
 		rc = pci_read_config_byte(dev, pos + 3, &cap);
 		if (rc != PCIBIOS_SUCCESSFUL)
@@ -385,6 +390,12 @@ static int __pci_find_next_ht_cap(struct
 		pos = __pci_find_next_cap_ttl(dev->bus, dev->devfn,
 					      pos + PCI_CAP_LIST_NEXT,
 					      PCI_CAP_ID_HT, &ttl);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1042,6 +1053,11 @@ int pci_load_saved_state(struct pci_dev
 	       sizeof(state->config_space));
 
 	cap = state->cap;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cap->size) {
 		struct pci_cap_saved_state *tmp;
 
@@ -1052,6 +1068,12 @@ int pci_load_saved_state(struct pci_dev
 		memcpy(tmp->cap.data, cap->data, tmp->cap.size);
 		cap = (struct pci_cap_saved_data *)((u8 *)cap +
 		       sizeof(struct pci_cap_saved_data) + cap->size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev->state_saved = true;
@@ -1763,6 +1785,11 @@ bool pci_dev_run_wake(struct pci_dev *de
 	if (!dev->pme_support)
 		return false;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bus->parent) {
 		struct pci_dev *bridge = bus->self;
 
@@ -1770,6 +1797,12 @@ bool pci_dev_run_wake(struct pci_dev *de
 			return true;
 
 		bus = bus->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* We have reached the root bus. */
@@ -2330,9 +2363,20 @@ pci_get_interrupt_pin(struct pci_dev *de
 	if (!pin)
 		return -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!pci_is_root_bus(dev->bus)) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*bridge = dev;
 	return pin;
@@ -2350,9 +2394,20 @@ u8 pci_common_swizzle(struct pci_dev *de
 {
 	u8 pin = *pinp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!pci_is_root_bus(dev->bus)) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*pinp = pin;
 	return PCI_SLOT(dev->devfn);
@@ -3412,7 +3467,12 @@ int pci_set_vga_state(struct pci_dev *de
 		return 0;
 
 	bus = dev->bus;
-	while (bus) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (bus) {
 		bridge = bus->self;
 		if (bridge) {
 			pci_read_config_word(bridge, PCI_BRIDGE_CONTROL,
@@ -3425,6 +3485,12 @@ int pci_set_vga_state(struct pci_dev *de
 					      cmd);
 		}
 		bus = bus->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -3571,6 +3637,11 @@ EXPORT_SYMBOL(pci_fixup_cardbus);
 
 static int __init pci_setup(char *str)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (str) {
 		char *k = strchr(str, ',');
 		if (k)
@@ -3611,6 +3682,12 @@ static int __init pci_setup(char *str)
 			}
 		}
 		str = k;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/pci/xen-pcifront.c b/pci/xen-pcifront.c
--- a/pci/xen-pcifront.c
+++ b/pci/xen-pcifront.c
@@ -135,7 +135,12 @@ static int do_pci_op(struct pcifront_dev
 
 	xen_clear_irq_pending(irq);
 
-	while (test_bit(_XEN_PCIF_active,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (test_bit(_XEN_PCIF_active,
 			(unsigned long *)&pdev->sh_info->flags)) {
 		xen_poll_irq_timeout(irq, jiffies + 3*HZ);
 		xen_clear_irq_pending(irq);
@@ -149,6 +154,12 @@ static int do_pci_op(struct pcifront_dev
 			err = XEN_PCI_ERR_dev_not_found;
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -540,11 +551,22 @@ static void free_root_bus_devs(struct pc
 {
 	struct pci_dev *dev;
 
-	while (!list_empty(&bus->devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&bus->devices)) {
 		dev = container_of(bus->devices.next, struct pci_dev,
 				   bus_list);
 		dev_dbg(&dev->dev, "removing device\n");
 		pci_remove_bus_device(dev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/pci/pci-acpi.c b/pci/pci-acpi.c
--- a/pci/pci-acpi.c
+++ b/pci/pci-acpi.c
@@ -253,10 +253,21 @@ static bool acpi_pci_can_wakeup(struct p
 
 static void acpi_pci_propagate_wakeup_enable(struct pci_bus *bus, bool enable)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bus->parent) {
 		if (!acpi_pm_device_sleep_wake(&bus->self->dev, enable))
 			return;
 		bus = bus->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* We have reached the root bus. */
@@ -309,6 +320,11 @@ static int acpi_dev_run_wake(struct devi
 
 static void acpi_pci_propagate_run_wake(struct pci_bus *bus, bool enable)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bus->parent) {
 		struct pci_dev *bridge = bus->self;
 
@@ -317,6 +333,12 @@ static void acpi_pci_propagate_run_wake(
 		if (!acpi_dev_run_wake(&bridge->dev, enable))
 			return;
 		bus = bus->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* We have reached the root bus. */
diff -u -p a/pci/search.c b/pci/search.c
--- a/pci/search.c
+++ b/pci/search.c
@@ -336,12 +336,23 @@ int pci_dev_present(const struct pci_dev
 	struct pci_dev *found = NULL;
 
 	WARN_ON(in_interrupt());
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ids->vendor || ids->subvendor || ids->class_mask) {
 		found = pci_get_dev_by_id(ids, NULL);
 		if (found)
 			goto exit;
 		ids++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 exit:
 	if (found)
 		return 1;
diff -u -p a/pci/quirks.c b/pci/quirks.c
--- a/pci/quirks.c
+++ b/pci/quirks.c
@@ -125,6 +125,11 @@ static void quirk_passive_release(struct
 
 	/* We have to make sure a particular bit is set in the PIIX3
 	   ISA bridge, so we have to go out and find it. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((d = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371SB_0, d))) {
 		pci_read_config_byte(d, 0x82, &dlc);
 		if (!(dlc & 1<<1)) {
@@ -132,6 +137,12 @@ static void quirk_passive_release(struct
 			dlc |= 1<<1;
 			pci_write_config_byte(d, 0x82, dlc);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82441,	quirk_passive_release);
@@ -2948,6 +2959,11 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
 static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
 			  struct pci_fixup *end)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (f < end) {
 		if ((f->vendor == dev->vendor || f->vendor == (u16) PCI_ANY_ID) &&
 		    (f->device == dev->device || f->device == (u16) PCI_ANY_ID)) {
@@ -2955,6 +2971,12 @@ static void pci_do_fixups(struct pci_dev
 			f->hook(dev);
 		}
 		f++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/pci/pci-stub.c b/pci/pci-stub.c
--- a/pci/pci-stub.c
+++ b/pci/pci-stub.c
@@ -53,7 +53,12 @@ static int __init pci_stub_init(void)
 
 	/* add ids specified in the module parameter */
 	p = ids;
-	while ((id = strsep(&p, ","))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((id = strsep(&p, ","))) {
 		unsigned int vendor, device, subvendor = PCI_ANY_ID,
 			subdevice = PCI_ANY_ID, class=0, class_mask=0;
 		int fields;
@@ -80,6 +85,12 @@ static int __init pci_stub_init(void)
 		if (rc)
 			printk(KERN_WARNING
 			       "pci-stub: failed to add dynamic id (%d)\n", rc);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	return 0;
diff -u -p a/pci/hotplug/cpqphp_core.c b/pci/hotplug/cpqphp_core.c
--- a/pci/hotplug/cpqphp_core.c
+++ b/pci/hotplug/cpqphp_core.c
@@ -144,11 +144,22 @@ static int init_SERR(struct controller *
 
 	number_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0F;
 	/* Loop through slots */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (number_of_slots) {
 		physical_slot = tempdword;
 		writeb(0, ctrl->hpc_reg + SLOT_SERR);
 		tempdword++;
 		number_of_slots--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -223,6 +234,11 @@ static void __iomem *get_subsequent_smbi
 	p_temp = curr;
 	p_temp += readb(curr + SMBIOS_GENERIC_LENGTH);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((p_temp < p_max) && !bail) {
 		/* Look for the double NULL terminator
 		 * The first condition is the previous byte
@@ -233,6 +249,12 @@ static void __iomem *get_subsequent_smbi
 
 		previous_byte = readb(p_temp);
 		p_temp++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (p_temp < p_max)
@@ -298,11 +320,22 @@ static int ctrl_slot_cleanup (struct con
 	old_slot = ctrl->slot;
 	ctrl->slot = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (old_slot) {
 		/* memory will be freed by the release_slot callback */
 		next_slot = old_slot->next;
 		pci_hp_deregister (old_slot->hotplug_slot);
 		old_slot = next_slot;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	cpqhp_remove_debugfs_files(ctrl);
@@ -621,7 +654,12 @@ static int ctrl_slot_setup(struct contro
 	slot_device = readb(ctrl->hpc_reg + SLOT_MASK) >> 4;
 	slot_number = ctrl->first_slot;
 
-	while (number_of_slots) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (number_of_slots) {
 		slot = kzalloc(sizeof(*slot), GFP_KERNEL);
 		if (!slot)
 			goto error;
@@ -647,10 +685,21 @@ static int ctrl_slot_setup(struct contro
 		slot_entry = get_SMBIOS_entry(smbios_start, smbios_table, 9,
 					slot_entry);
 
-		while (slot_entry && (readw(slot_entry + SMBIOS_SLOT_NUMBER) !=
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (slot_entry && (readw(slot_entry + SMBIOS_SLOT_NUMBER) !=
 				slot->number)) {
 			slot_entry = get_SMBIOS_entry(smbios_start,
 						smbios_table, 9, slot_entry);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 
 		slot->p_sm_slot = slot_entry;
@@ -720,6 +769,12 @@ static int ctrl_slot_setup(struct contro
 		number_of_slots--;
 		slot_device++;
 		slot_number++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1315,6 +1370,11 @@ static void __exit unload_cpqphpd(void)
 
 	ctrl = cpqhp_ctrl_list;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ctrl) {
 		if (ctrl->hpc_reg) {
 			u16 misc;
@@ -1331,31 +1391,75 @@ static void __exit unload_cpqphpd(void)
 		ctrl_slot_cleanup(ctrl);
 
 		res = ctrl->io_head;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		res = ctrl->mem_head;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		res = ctrl->p_mem_head;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		res = ctrl->bus_head;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (res) {
 			tres = res;
 			res = res->next;
 			kfree(tres);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kfree (ctrl->pci_bus);
@@ -1363,37 +1467,87 @@ static void __exit unload_cpqphpd(void)
 		tctrl = ctrl;
 		ctrl = ctrl->next;
 		kfree(tctrl);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (loop = 0; loop < 256; loop++) {
 		next = cpqhp_slot_list[loop];
 		while (next != NULL) {
 			res = next->io_head;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			res = next->mem_head;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			res = next->p_mem_head;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			res = next->bus_head;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (res) {
 				tres = res;
 				res = res->next;
 				kfree(tres);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			TempSlot = next;
diff -u -p a/pci/hotplug/cpqphp_ctrl.c b/pci/hotplug/cpqphp_ctrl.c
--- a/pci/hotplug/cpqphp_ctrl.c
+++ b/pci/hotplug/cpqphp_ctrl.c
@@ -321,6 +321,11 @@ static int sort_by_size(struct pci_resou
 	if (!((*head)->next))
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (out_of_order) {
 		out_of_order = 0;
 
@@ -336,6 +341,11 @@ static int sort_by_size(struct pci_resou
 
 		current_res = *head;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (current_res->next && current_res->next->next) {
 			if (current_res->next->length > current_res->next->next->length) {
 				out_of_order++;
@@ -346,6 +356,18 @@ static int sort_by_size(struct pci_resou
 				current_res->next = next_res;
 			} else
 				current_res = current_res->next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}  /* End of out_of_order loop */
 
@@ -369,6 +391,11 @@ static int sort_by_max_size(struct pci_r
 	if (!((*head)->next))
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (out_of_order) {
 		out_of_order = 0;
 
@@ -384,6 +411,11 @@ static int sort_by_max_size(struct pci_r
 
 		current_res = *head;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (current_res->next && current_res->next->next) {
 			if (current_res->next->length < current_res->next->next->length) {
 				out_of_order++;
@@ -394,6 +426,18 @@ static int sort_by_max_size(struct pci_r
 				current_res->next = next_res;
 			} else
 				current_res = current_res->next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}  /* End of out_of_order loop */
 
@@ -498,10 +542,21 @@ static struct pci_resource *do_bridge_re
 
 	node = *head;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (node->next) {
 		prevnode = node;
 		node = node->next;
 		kfree(prevnode);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (node->length < alignment)
@@ -705,8 +760,19 @@ static struct pci_resource *get_max_reso
 		if (temp == max) {
 			*head = max->next;
 		} else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (temp && temp->next != max) {
 				temp = temp->next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 
 			temp->next = max->next;
@@ -842,6 +908,11 @@ int cpqhp_resource_sort_and_combine(stru
 
 	dbg("*head->base = 0x%x\n",(*head)->base);
 	dbg("*head->next->base = 0x%x\n",(*head)->next->base);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (out_of_order) {
 		out_of_order = 0;
 
@@ -857,6 +928,11 @@ int cpqhp_resource_sort_and_combine(stru
 
 		node1 = (*head);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (node1->next && node1->next->next) {
 			if (node1->next->base > node1->next->next->base) {
 				out_of_order++;
@@ -867,11 +943,28 @@ int cpqhp_resource_sort_and_combine(stru
 				node1->next = node2;
 			} else
 				node1 = node1->next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
 		}
 	}  /* End of out_of_order loop */
 
 	node1 = *head;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (node1 && node1->next) {
 		if ((node1->base + node1->length) == node1->next->base) {
 			/* Combine */
@@ -882,6 +975,12 @@ int cpqhp_resource_sort_and_combine(stru
 			kfree(node2);
 		} else
 			node1 = node1->next;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
@@ -1689,6 +1788,11 @@ static u32 remove_board(struct pci_func
 	mutex_unlock(&ctrl->crit_sect);
 
 	if (!replace_flag && ctrl->add_support) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (func) {
 			res_lists.io_head = ctrl->io_head;
 			res_lists.mem_head = ctrl->mem_head;
@@ -1713,6 +1817,12 @@ static u32 remove_board(struct pci_func
 				slot_remove(func);
 
 			func = cpqhp_slot_find(ctrl->bus, device, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Setup slot structure with entry for empty slot */
@@ -1807,6 +1917,11 @@ static void interrupt_event_handler(stru
 	u8 hp_slot;
 	struct slot *p_slot;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (change) {
 		change = 0;
 
@@ -1909,6 +2024,12 @@ static void interrupt_event_handler(stru
 				change = 1;
 			}
 		}		/* End of FOR loop */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return;
@@ -2100,6 +2221,11 @@ int cpqhp_process_SS(struct controller *
 	}
 
 	/* Make sure there are no video controllers here */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (func && !rc) {
 		pci_bus->number = func->bus;
 		devfn = PCI_DEVFN(func->device, func->function);
@@ -2132,6 +2258,12 @@ int cpqhp_process_SS(struct controller *
 		}
 
 		func = cpqhp_slot_find(ctrl->bus, device, index++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	func = cpqhp_slot_find(ctrl->bus, device, 0);
@@ -2304,11 +2436,22 @@ static u32 configure_new_device(struct c
 			dbg("configure_new_function failed %d\n",rc);
 			index = 0;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (new_slot) {
 				new_slot = cpqhp_slot_find(new_slot->bus, new_slot->device, index++);
 
 				if (new_slot)
 					cpqhp_return_board_resources(new_slot, resources);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 
 			return rc;
@@ -2321,6 +2464,11 @@ static u32 configure_new_device(struct c
 		/* The following loop skips to the next present function
 		 * and creates a board structure */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((function < max_functions) && (!stop_it)) {
 			pci_bus_read_config_dword (ctrl->pci_bus, PCI_DEVFN(func->device, function), 0x00, &ID);
 
@@ -2341,6 +2489,12 @@ static u32 configure_new_device(struct c
 
 				stop_it++;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	} while (function < max_functions);
diff -u -p a/pci/hotplug/acpiphp_glue.c b/pci/hotplug/acpiphp_glue.c
--- a/pci/hotplug/acpiphp_glue.c
+++ b/pci/hotplug/acpiphp_glue.c
@@ -540,6 +540,11 @@ static void cleanup_bridge(struct acpiph
 	}
 
 	slot = bridge->slots;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (slot) {
 		next = slot->next;
 		list_for_each_entry_safe(func, tmp, &slot->funcs, sibling) {
@@ -561,6 +566,12 @@ static void cleanup_bridge(struct acpiph
 		list_del(&slot->funcs);
 		kfree(slot);
 		slot = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/pci/hotplug/ibmphp_hpc.c b/pci/hotplug/ibmphp_hpc.c
--- a/pci/hotplug/ibmphp_hpc.c
+++ b/pci/hotplug/ibmphp_hpc.c
@@ -737,7 +737,12 @@ int ibmphp_hpc_writeslot (struct slot *
 		//--------------------------------------------------------------------
 		timeout = CMD_COMPLETE_TOUT_SEC;
 		done = 0;
-		while (!done) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!done) {
 			rc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar,
 							&status);
 			if (!rc) {
@@ -756,6 +761,12 @@ int ibmphp_hpc_writeslot (struct slot *
 				} else
 					timeout--;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		ctlr_ptr->status = status;
 	}
@@ -830,6 +841,11 @@ static int poll_hpc(void *data)
 
 	debug ("%s - Entry\n", __func__);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		/* try to get the lock to do some kind of hardware access */
 		down (&semOperations);
@@ -907,6 +923,12 @@ static int poll_hpc(void *data)
 		/* sleep for a short time just for good measure */
 out_sleep:
 		msleep(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	up (&sem_exit);
 	debug ("%s - Exit\n", __func__);
@@ -1109,6 +1131,11 @@ static int hpc_wait_ctlr_notworking (int
 
 	debug_polling ("hpc_wait_ctlr_notworking - Entry timeout[%d]\n", timeout);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!done) {
 		*pstatus = ctrl_read (ctlr_ptr, wpg_bbar, WPG_CTLR_INDEX);
 		if (*pstatus == HPC_ERROR) {
@@ -1126,6 +1153,12 @@ static int hpc_wait_ctlr_notworking (int
 			} else
 				timeout--;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	debug_polling ("hpc_wait_ctlr_notworking - Exit rc[%x] status[%x]\n", rc, *pstatus);
 	return rc;
diff -u -p a/pci/hotplug/ibmphp_pci.c b/pci/hotplug/ibmphp_pci.c
--- a/pci/hotplug/ibmphp_pci.c
+++ b/pci/hotplug/ibmphp_pci.c
@@ -1276,6 +1276,11 @@ static int unconfigure_boot_device (u8 b
 			start_address = io->end + 1;
 			ibmphp_remove_resource (io);
 			/* This is needed b/c of the old I/O restrictions in the BIOS */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (temp_end < end_address) {
 				if (ibmphp_find_resource (bus, start_address, &io, IO) < 0) {
 					err ("cannot find corresponding IO resource to remove\n");
@@ -1285,6 +1290,12 @@ static int unconfigure_boot_device (u8 b
 				temp_end = io->end;
 				start_address = io->end + 1;
 				ibmphp_remove_resource (io);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			/* ????????? DO WE NEED TO WRITE ANYTHING INTO THE PCI CONFIG SPACE BACK ?????????? */
@@ -1586,6 +1597,11 @@ int ibmphp_unconfigure_card (struct slot
 
 	if (sl->func) {
 		cur_func = sl->func;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cur_func) {
 			/* TO DO: WILL MOST LIKELY NEED TO GET RID OF THE BUS STRUCTURE FROM RESOURCES AS WELL */
 			if (cur_func->bus) {
@@ -1619,6 +1635,12 @@ int ibmphp_unconfigure_card (struct slot
 			temp_func = cur_func->next;
 			kfree (cur_func);
 			cur_func = temp_func;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/pci/hotplug/ibmphp_core.c b/pci/hotplug/ibmphp_core.c
--- a/pci/hotplug/ibmphp_core.c
+++ b/pci/hotplug/ibmphp_core.c
@@ -676,12 +676,23 @@ static struct pci_func *ibm_slot_find(u8
 		slot_cur = list_entry(tmp, struct slot, ibm_slot_list);
 		if (slot_cur->func) {
 			func_cur = slot_cur->func;
-			while (func_cur) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (func_cur) {
 				if ((func_cur->busno == busno) &&
 						(func_cur->device == device) &&
 						(func_cur->function == function))
 					return func_cur;
 				func_cur = func_cur->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -822,6 +833,11 @@ static int is_bus_empty(struct slot * sl
 	struct slot * tmp_slot;
 	u8 i = slot_cur->bus_on->slot_min;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i <= slot_cur->bus_on->slot_max) {
 		if (i == slot_cur->number) {
 			i++;
@@ -837,6 +853,12 @@ static int is_bus_empty(struct slot * sl
 					SLOT_PWRGD(tmp_slot->status))
 			return 0;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 1;
 }
diff -u -p a/pci/pci-driver.c b/pci/pci-driver.c
--- a/pci/pci-driver.c
+++ b/pci/pci-driver.c
@@ -245,10 +245,21 @@ const struct pci_device_id *pci_match_id
 					 struct pci_dev *dev)
 {
 	if (ids) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ids->vendor || ids->subvendor || ids->class_mask) {
 			if (pci_match_one_device(ids, dev))
 				return ids;
 			ids++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return NULL;
diff -u -p a/pci/probe.c b/pci/probe.c
--- a/pci/probe.c
+++ b/pci/probe.c
@@ -617,10 +617,21 @@ static void pci_fixup_parent_subordinate
 	if (!pcibios_assign_all_busses())
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (parent->parent && parent->subordinate < max) {
 		parent->subordinate = max;
 		pci_write_config_byte(parent->self, PCI_SUBORDINATE_BUS, max);
 		parent = parent->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -779,6 +790,11 @@ int __devinit pci_scan_bridge(struct pci
 				if (pci_find_bus(pci_domain_nr(bus),
 							max+i+1))
 					break;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (parent->parent) {
 					if ((!pcibios_assign_all_busses()) &&
 					    (parent->subordinate > max) &&
@@ -786,6 +802,12 @@ int __devinit pci_scan_bridge(struct pci
 						j = 1;
 					}
 					parent = parent->parent;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if (j) {
 					/*
@@ -812,6 +834,11 @@ int __devinit pci_scan_bridge(struct pci
 		pci_domain_nr(bus), child->number);
 
 	/* Has only triggered on CardBus, fixup is in yenta_socket */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bus->parent) {
 		if ((child->subordinate > bus->subordinate) ||
 		    (child->number > bus->subordinate) ||
@@ -828,7 +855,13 @@ int __devinit pci_scan_bridge(struct pci
 				bus->number, bus->subordinate);
 		}
 		bus = bus->parent;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, bctl);
diff -u -p a/ps3/ps3-sys-manager.c b/ps3/ps3-sys-manager.c
--- a/ps3/ps3-sys-manager.c
+++ b/ps3/ps3-sys-manager.c
@@ -593,14 +593,36 @@ static void ps3_sys_manager_fin(struct p
 
 	pr_emerg("System Halted, OK to turn off power\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ps3_sys_manager_handle_msg(dev)) {
 		/* pause until next DEC interrupt */
 		lv1_pause(0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		/* pause, ignoring DEC interrupt */
 		lv1_pause(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/ps3/ps3-lpm.c b/ps3/ps3-lpm.c
--- a/ps3/ps3-lpm.c
+++ b/ps3/ps3-lpm.c
@@ -941,7 +941,12 @@ int ps3_lpm_copy_tb(unsigned long offset
 
 	count = min_t(u64, count, lpm_priv->tb_count - offset);
 
-	while (*bytes_copied < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*bytes_copied < count) {
 		const unsigned long request = count - *bytes_copied;
 		u64 tmp;
 
@@ -961,6 +966,12 @@ int ps3_lpm_copy_tb(unsigned long offset
 		buf += tmp;
 		*bytes_copied += tmp;
 		offset += tmp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_dbg(sbd_core(), "%s:%u: copied %lxh bytes\n", __func__, __LINE__,
 		*bytes_copied);
@@ -996,7 +1007,12 @@ int ps3_lpm_copy_tb_to_user(unsigned lon
 
 	count = min_t(u64, count, lpm_priv->tb_count - offset);
 
-	while (*bytes_copied < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*bytes_copied < count) {
 		const unsigned long request = count - *bytes_copied;
 		u64 tmp;
 
@@ -1024,6 +1040,12 @@ int ps3_lpm_copy_tb_to_user(unsigned lon
 		buf += tmp;
 		*bytes_copied += tmp;
 		offset += tmp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_dbg(sbd_core(), "%s:%u: copied %lxh bytes\n", __func__, __LINE__,
 		*bytes_copied);
diff -u -p a/ps3/ps3-vuart.c b/ps3/ps3-vuart.c
--- a/ps3/ps3-vuart.c
+++ b/ps3/ps3-vuart.c
@@ -628,6 +628,11 @@ int ps3_vuart_read(struct ps3_system_bus
 
 	/* Queue rx bytes here for polled reads. */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (priv->rx_list.bytes_held < bytes) {
 		u64 tmp;
 
@@ -639,6 +644,12 @@ int ps3_vuart_read(struct ps3_system_bus
 			spin_unlock_irqrestore(&priv->rx_list.lock, flags);
 			return -EAGAIN;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	list_for_each_entry_safe(lb, n, &priv->rx_list.head, link) {
diff -u -p a/pnp/interface.c b/pnp/interface.c
--- a/pnp/interface.c
+++ b/pnp/interface.c
@@ -411,9 +411,20 @@ static ssize_t pnp_show_current_ids(stru
 	struct pnp_dev *dev = to_pnp_dev(dmdev);
 	struct pnp_id *pos = dev->id;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos) {
 		str += sprintf(str, "%s\n", pos->id);
 		pos = pos->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (str - buf);
 }
diff -u -p a/pnp/card.c b/pnp/card.c
--- a/pnp/card.c
+++ b/pnp/card.c
@@ -19,6 +19,11 @@ static const struct pnp_card_device_id *
 {
 	const struct pnp_card_device_id *drv_id = drv->id_table;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*drv_id->id) {
 		if (compare_pnp_id(card->id, drv_id->id)) {
 			int i = 0;
@@ -44,6 +49,12 @@ static const struct pnp_card_device_id *
 			}
 		}
 		drv_id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -137,10 +148,21 @@ static void pnp_free_card_ids(struct pnp
 	struct pnp_id *next;
 
 	id = card->id;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (id) {
 		next = id->next;
 		kfree(id);
 		id = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -198,9 +220,20 @@ static ssize_t pnp_show_card_ids(struct
 	struct pnp_card *card = to_pnp_card(dmdev);
 	struct pnp_id *pos = card->id;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos) {
 		str += sprintf(str, "%s\n", pos->id);
 		pos = pos->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (str - buf);
 }
@@ -342,11 +375,22 @@ struct pnp_dev *pnp_request_card_device(
 			return NULL;
 		pos = from->card_list.next;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos != &card->devices) {
 		dev = card_to_pnp_dev(pos);
 		if ((!dev->card_link) && compare_pnp_id(dev->id, id))
 			goto found;
 		pos = pos->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/pnp/core.c b/pnp/core.c
--- a/pnp/core.c
+++ b/pnp/core.c
@@ -92,10 +92,21 @@ static void pnp_free_ids(struct pnp_dev
 	struct pnp_id *next;
 
 	id = dev->id;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (id) {
 		next = id->next;
 		kfree(id);
 		id = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/pnp/driver.c b/pnp/driver.c
--- a/pnp/driver.c
+++ b/pnp/driver.c
@@ -31,11 +31,22 @@ int compare_pnp_id(struct pnp_id *pos, c
 		return 0;
 	if (memcmp(id, "ANYDEVS", 7) == 0)
 		return 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos) {
 		if (memcmp(pos->id, id, 3) == 0)
 			if (compare_func(pos->id, id) == 1)
 				return 1;
 		pos = pos->next;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return 0;
 }
@@ -48,10 +59,21 @@ static const struct pnp_device_id *match
 	if (!drv_id)
 		return NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*drv_id->id) {
 		if (compare_pnp_id(dev->id, drv_id->id))
 			return drv_id;
 		drv_id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/pnp/manager.c b/pnp/manager.c
--- a/pnp/manager.c
+++ b/pnp/manager.c
@@ -44,6 +44,11 @@ static int pnp_assign_port(struct pnp_de
 	res->start = rule->min;
 	res->end = res->start + rule->size - 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!pnp_check_port(dev, res)) {
 		res->start += rule->align;
 		res->end = res->start + rule->size - 1;
@@ -54,7 +59,13 @@ static int pnp_assign_port(struct pnp_de
 				(unsigned long long) rule->max);
 			return -EBUSY;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 __add:
 	pnp_add_io_resource(dev, res->start, res->end, res->flags);
@@ -96,6 +107,11 @@ static int pnp_assign_mem(struct pnp_dev
 	res->start = rule->min;
 	res->end = res->start + rule->size - 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!pnp_check_mem(dev, res)) {
 		res->start += rule->align;
 		res->end = res->start + rule->size - 1;
@@ -106,7 +122,13 @@ static int pnp_assign_mem(struct pnp_dev
 				(unsigned long long) rule->max);
 			return -EBUSY;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 __add:
 	pnp_add_mem_resource(dev, res->start, res->end, res->flags);
diff -u -p a/pnp/isapnp/compat.c b/pnp/isapnp/compat.c
--- a/pnp/isapnp/compat.c
+++ b/pnp/isapnp/compat.c
@@ -32,12 +32,23 @@ struct pnp_card *pnp_find_card(unsigned
 
 	list = from ? from->global_list.next : pnp_cards.next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (list != &pnp_cards) {
 		struct pnp_card *card = global_to_pnp_card(list);
 
 		if (compare_pnp_id(card->id, id) || (memcmp(id, any, 7) == 0))
 			return card;
 		list = list->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -57,6 +68,11 @@ struct pnp_dev *pnp_find_dev(struct pnp_
 		if (from)
 			list = from->global_list.next;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (list != &pnp_global) {
 			struct pnp_dev *dev = global_to_pnp_dev(list);
 
@@ -64,6 +80,12 @@ struct pnp_dev *pnp_find_dev(struct pnp_
 			    (memcmp(id, any, 7) == 0))
 				return dev;
 			list = list->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		struct list_head *list;
@@ -74,12 +96,23 @@ struct pnp_dev *pnp_find_dev(struct pnp_
 			if (from->card != card)	/* something is wrong */
 				return NULL;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (list != &card->devices) {
 			struct pnp_dev *dev = card_to_pnp_dev(list);
 
 			if (compare_pnp_id(dev->id, id))
 				return dev;
 			list = list->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return NULL;
diff -u -p a/pnp/quirks.c b/pnp/quirks.c
--- a/pnp/quirks.c
+++ b/pnp/quirks.c
@@ -189,6 +189,11 @@ static void quirk_add_irq_optional_depen
 			return;
 
 		set = pnp_option_set(new_option);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (new_option && pnp_option_set(new_option) == set) {
 			if (new_option->type == IORESOURCE_IRQ) {
 				irq = &new_option->u.irq;
@@ -197,6 +202,12 @@ static void quirk_add_irq_optional_depen
 			dbg_pnp_show_option(dev, new_option);
 			new_option = list_entry(new_option->list.next,
 						struct pnp_option, list);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		dev_info(&dev->dev, "added dependent option set %d (same as "
diff -u -p a/pnp/pnpacpi/rsparser.c b/pnp/pnpacpi/rsparser.c
--- a/pnp/pnpacpi/rsparser.c
+++ b/pnp/pnpacpi/rsparser.c
@@ -1097,7 +1097,12 @@ int pnpacpi_encode_resources(struct pnp_
 	int port = 0, irq = 0, dma = 0, mem = 0;
 
 	pnp_dbg(&dev->dev, "encode %d resources\n", res_cnt);
-	while (i < res_cnt) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < res_cnt) {
 		switch (resource->type) {
 		case ACPI_RESOURCE_TYPE_IRQ:
 			pnpacpi_encode_irq(dev, resource,
@@ -1156,6 +1161,12 @@ int pnpacpi_encode_resources(struct pnp_
 		}
 		resource++;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/pnp/pnpbios/core.c b/pnp/pnpbios/core.c
--- a/pnp/pnpbios/core.c
+++ b/pnp/pnpbios/core.c
@@ -157,6 +157,11 @@ static int pnp_dock_thread(void *unused)
 	int docked = -1, d = 0;
 
 	set_freezable();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		int status;
 
@@ -196,6 +201,12 @@ static int pnp_dock_thread(void *unused)
 #endif
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	complete_and_exit(&unload_sem, 0);
 }
@@ -259,6 +270,11 @@ static void pnpbios_zero_data_stream(str
 	unsigned int len;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((char *)p < (char *)end) {
 		if (p[0] & 0x80) {	/* large tag */
 			len = (p[2] << 8) | p[1];
@@ -272,6 +288,12 @@ static void pnpbios_zero_data_stream(str
 		for (i = 0; i < len; i++)
 			p[i] = 0;
 		p += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR
 	       "PnPBIOS: Resource structure did not contain an end tag.\n");
diff -u -p a/rtc/rtc-tx4939.c b/rtc/rtc-tx4939.c
--- a/rtc/rtc-tx4939.c
+++ b/rtc/rtc-tx4939.c
@@ -33,11 +33,22 @@ static int tx4939_rtc_cmd(struct tx4939_
 
 	__raw_writel(cmd, &rtcreg->ctl);
 	/* This might take 30us (next 32.768KHz clock) */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (__raw_readl(&rtcreg->ctl) & TX4939_RTCCTL_BUSY) {
 		/* timeout on approx. 100us (@ GBUS200MHz) */
 		if (i++ > 200 * 100)
 			return -EBUSY;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/rtc/rtc-tegra.c b/rtc/rtc-tegra.c
--- a/rtc/rtc-tegra.c
+++ b/rtc/rtc-tegra.c
@@ -89,10 +89,21 @@ static int tegra_rtc_wait_while_busy(str
 
 	/* first wait for the RTC to become busy. this is when it
 	 * posts its updated seconds+msec registers to AHB side. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tegra_rtc_check_busy(info)) {
 		if (!retries--)
 			goto retry_failed;
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* now we have about 250 us to manipulate registers */
diff -u -p a/rtc/rtc-msm6242.c b/rtc/rtc-msm6242.c
--- a/rtc/rtc-msm6242.c
+++ b/rtc/rtc-msm6242.c
@@ -103,11 +103,22 @@ static void msm6242_lock(struct msm6242_
 
 	msm6242_set(priv, MSM6242_CD_HOLD, MSM6242_CD);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((msm6242_read(priv, MSM6242_CD) & MSM6242_CD_BUSY) && cnt) {
 		msm6242_clear(priv, MSM6242_CD_HOLD, MSM6242_CD);
 		udelay(70);
 		msm6242_set(priv, MSM6242_CD_HOLD, MSM6242_CD);
 		cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!cnt)
diff -u -p a/spi/spi-stmp.c b/spi/spi-stmp.c
--- a/spi/spi-stmp.c
+++ b/spi/spi-stmp.c
@@ -392,6 +392,11 @@ static void stmp_spi_handle(struct work_
 	struct spi_message *m;
 
 	spin_lock_irqsave(&ss->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ss->queue)) {
 		m = list_entry(ss->queue.next, struct spi_message, queue);
 		list_del_init(&m->queue);
@@ -401,6 +406,12 @@ static void stmp_spi_handle(struct work_
 		m->complete(m->context);
 
 		spin_lock_irqsave(&ss->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&ss->lock, flags);
 
diff -u -p a/spi/spi-omap2-mcspi.c b/spi/spi-omap2-mcspi.c
--- a/spi/spi-omap2-mcspi.c
+++ b/spi/spi-omap2-mcspi.c
@@ -281,10 +281,21 @@ static int mcspi_wait_for_reg_bit(void _
 	unsigned long timeout;
 
 	timeout = jiffies + msecs_to_jiffies(1000);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(__raw_readl(reg) & bit)) {
 		if (time_after(jiffies, timeout))
 			return -1;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -866,6 +877,11 @@ static void omap2_mcspi_work(struct work
 	 * channel" master mode.  As a side effect, we need to manage the
 	 * chipselect with the FORCE bit ... CS != channel enable.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&mcspi->msg_queue)) {
 		struct spi_message		*m;
 		struct spi_device		*spi;
@@ -969,6 +985,12 @@ static void omap2_mcspi_work(struct work
 		m->complete(m->context);
 
 		spin_lock_irq(&mcspi->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irq(&mcspi->lock);
diff -u -p a/spi/spi-txx9.c b/spi/spi-txx9.c
--- a/spi/spi-txx9.c
+++ b/spi/spi-txx9.c
@@ -212,6 +212,11 @@ static void txx9spi_work_one(struct txx9
 		if (cs_change)
 			txx9spi_cs_func(spi, c, 1, cs_delay);
 		cs_change = t->cs_change;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			unsigned int count = SPI_FIFO_SIZE;
 			int i;
@@ -254,6 +259,12 @@ static void txx9spi_work_one(struct txx9
 				}
 			}
 			len -= count * wsize;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		m->actual_length += t->len;
 		if (t->delay_usecs)
@@ -290,6 +301,11 @@ static void txx9spi_work(struct work_str
 	unsigned long flags;
 
 	spin_lock_irqsave(&c->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&c->queue)) {
 		struct spi_message *m;
 
@@ -300,6 +316,12 @@ static void txx9spi_work(struct work_str
 		txx9spi_work_one(c, m);
 
 		spin_lock_irqsave(&c->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&c->lock, flags);
 }
diff -u -p a/spi/spi-fsl-lib.c b/spi/spi-fsl-lib.c
--- a/spi/spi-fsl-lib.c
+++ b/spi/spi-fsl-lib.c
@@ -65,7 +65,12 @@ void mpc8xxx_spi_work(struct work_struct
 						       work);
 
 	spin_lock_irq(&mpc8xxx_spi->lock);
-	while (!list_empty(&mpc8xxx_spi->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mpc8xxx_spi->queue)) {
 		struct spi_message *m = container_of(mpc8xxx_spi->queue.next,
 						   struct spi_message, queue);
 
@@ -76,6 +81,12 @@ void mpc8xxx_spi_work(struct work_struct
 			mpc8xxx_spi->spi_do_one_msg(m);
 
 		spin_lock_irq(&mpc8xxx_spi->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irq(&mpc8xxx_spi->lock);
 }
diff -u -p a/spi/spi-sh.c b/spi/spi-sh.c
--- a/spi/spi-sh.c
+++ b/spi/spi-sh.c
@@ -135,10 +135,21 @@ static int spi_sh_wait_receive_buffer(st
 {
 	int timeout = 100000;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_RBE) {
 		udelay(10);
 		if (timeout-- < 0)
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
@@ -147,10 +158,21 @@ static int spi_sh_wait_write_buffer_empt
 {
 	int timeout = 100000;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(spi_sh_read(ss, SPI_SH_CR1) & SPI_SH_TBE)) {
 		udelay(10);
 		if (timeout-- < 0)
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
@@ -293,6 +315,11 @@ static void spi_sh_work(struct work_stru
 	pr_debug("%s: enter\n", __func__);
 
 	spin_lock_irqsave(&ss->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ss->queue)) {
 		mesg = list_entry(ss->queue.next, struct spi_message, queue);
 		list_del_init(&mesg->queue);
@@ -320,6 +347,12 @@ static void spi_sh_work(struct work_stru
 
 		mesg->status = 0;
 		mesg->complete(mesg->context);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	clear_fifo(ss);
diff -u -p a/spi/spi.c b/spi/spi.c
--- a/spi/spi.c
+++ b/spi/spi.c
@@ -63,10 +63,21 @@ static struct device_attribute spi_dev_a
 static const struct spi_device_id *spi_match_id(const struct spi_device_id *id,
 						const struct spi_device *sdev)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (id->name[0]) {
 		if (!strcmp(sdev->modalias, id->name))
 			return id;
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/spi/spi-ti-ssp.c b/spi/spi-ti-ssp.c
--- a/spi/spi-ti-ssp.c
+++ b/spi/spi-ti-ssp.c
@@ -183,7 +183,12 @@ static void ti_ssp_spi_work(struct work_
 
 	spin_lock(&hw->lock);
 
-	 while (!list_empty(&hw->msg_queue)) {
+	 unsigned long long delta = (cpu / khz / HZ) * 2;
+	 unsigned long long _start = 0;
+	 unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
+		while (!list_empty(&hw->msg_queue)) {
 		struct spi_message	*m;
 		struct spi_device	*spi;
 		struct spi_transfer	*t = NULL;
@@ -229,6 +234,12 @@ static void ti_ssp_spi_work(struct work_
 		m->complete(m->context);
 
 		spin_lock(&hw->lock);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (hw->shutdown)
@@ -363,12 +374,23 @@ static int __devexit ti_ssp_spi_remove(s
 	int error;
 
 	hw->shutdown = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&hw->msg_queue)) {
 		error = wait_for_completion_interruptible(&hw->complete);
 		if (error < 0) {
 			hw->shutdown = 0;
 			return error;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	destroy_workqueue(hw->workqueue);
 	spi_unregister_master(hw->master);
diff -u -p a/spi/spi-mpc512x-psc.c b/spi/spi-mpc512x-psc.c
--- a/spi/spi-mpc512x-psc.c
+++ b/spi/spi-mpc512x-psc.c
@@ -148,6 +148,11 @@ static int mpc512x_psc_spi_transfer_rxtx
 	in_8(&psc->mode);
 	out_8(&psc->mode, 0x0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		int count;
 		int i;
@@ -201,12 +206,29 @@ static int mpc512x_psc_spi_transfer_rxtx
 			if (rx_buf)
 				*rx_buf++ = data;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (in_be32(&fifo->rxcnt)) {
 			in_8(&fifo->rxdata_8);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		out_8(&psc->command,
 		      MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* disable transmiter/receiver and fifo interrupt */
 	out_8(&psc->command, MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);
@@ -222,6 +244,11 @@ static void mpc512x_psc_spi_work(struct
 
 	spin_lock_irq(&mps->lock);
 	mps->busy = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&mps->queue)) {
 		struct spi_message *m;
 		struct spi_device *spi;
@@ -268,6 +295,12 @@ static void mpc512x_psc_spi_work(struct
 		mpc512x_psc_spi_transfer_setup(spi, NULL);
 
 		spin_lock_irq(&mps->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mps->busy = 0;
 	spin_unlock_irq(&mps->lock);
diff -u -p a/spi/spi-ep93xx.c b/spi/spi-ep93xx.c
--- a/spi/spi-ep93xx.c
+++ b/spi/spi-ep93xx.c
@@ -506,9 +506,20 @@ static int ep93xx_spi_read_write(struct
 	struct spi_transfer *t = msg->state;
 
 	/* read as long as RX FIFO has frames in it */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ep93xx_spi_read_u8(espi, SSPSR) & SSPSR_RNE)) {
 		ep93xx_do_read(espi, t);
 		espi->fifo_level--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* write as long as TX FIFO has room */
@@ -834,7 +845,12 @@ static void ep93xx_spi_process_message(s
 	 * Just to be sure: flush any data from RX FIFO.
 	 */
 	timeout = jiffies + msecs_to_jiffies(SPI_TIMEOUT);
-	while (ep93xx_spi_read_u16(espi, SSPSR) & SSPSR_RNE) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ep93xx_spi_read_u16(espi, SSPSR) & SSPSR_RNE) {
 		if (time_after(jiffies, timeout)) {
 			dev_warn(&espi->pdev->dev,
 				 "timeout while flushing RX FIFO\n");
@@ -842,6 +858,12 @@ static void ep93xx_spi_process_message(s
 			return;
 		}
 		ep93xx_spi_read_u16(espi, SSPDR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -1167,7 +1189,12 @@ static int __devexit ep93xx_spi_remove(s
 	 * Complete remaining messages with %-ESHUTDOWN status.
 	 */
 	spin_lock_irq(&espi->lock);
-	while (!list_empty(&espi->msg_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&espi->msg_queue)) {
 		struct spi_message *msg;
 
 		msg = list_first_entry(&espi->msg_queue,
@@ -1177,6 +1204,12 @@ static int __devexit ep93xx_spi_remove(s
 		spin_unlock_irq(&espi->lock);
 		msg->complete(msg->context);
 		spin_lock_irq(&espi->lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irq(&espi->lock);
 
diff -u -p a/spi/spi-bfin5xx.c b/spi/spi-bfin5xx.c
--- a/spi/spi-bfin5xx.c
+++ b/spi/spi-bfin5xx.c
@@ -228,6 +228,11 @@ static void bfin_spi_u8_writer(struct bf
 	/* clear RXS (we check for RXS inside the loop) */
 	bfin_spi_dummy_read(drv_data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u8 *) (drv_data->tx++)));
 		/* wait until transfer finished.
@@ -236,6 +241,12 @@ static void bfin_spi_u8_writer(struct bf
 			cpu_relax();
 		/* discard RX data and clear RXS */
 		bfin_spi_dummy_read(drv_data);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -246,11 +257,22 @@ static void bfin_spi_u8_reader(struct bf
 	/* discard old RX data and clear RXS */
 	bfin_spi_dummy_read(drv_data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, tx_val);
 		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
 			cpu_relax();
 		*(u8 *) (drv_data->rx++) = bfin_read(&drv_data->regs->rdbr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -259,11 +281,22 @@ static void bfin_spi_u8_duplex(struct bf
 	/* discard old RX data and clear RXS */
 	bfin_spi_dummy_read(drv_data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u8 *) (drv_data->tx++)));
 		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
 			cpu_relax();
 		*(u8 *) (drv_data->rx++) = bfin_read(&drv_data->regs->rdbr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -278,6 +311,11 @@ static void bfin_spi_u16_writer(struct b
 	/* clear RXS (we check for RXS inside the loop) */
 	bfin_spi_dummy_read(drv_data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u16 *) (drv_data->tx)));
 		drv_data->tx += 2;
@@ -287,6 +325,12 @@ static void bfin_spi_u16_writer(struct b
 			cpu_relax();
 		/* discard RX data and clear RXS */
 		bfin_spi_dummy_read(drv_data);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -297,12 +341,23 @@ static void bfin_spi_u16_reader(struct b
 	/* discard old RX data and clear RXS */
 	bfin_spi_dummy_read(drv_data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, tx_val);
 		while (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))
 			cpu_relax();
 		*(u16 *) (drv_data->rx) = bfin_read(&drv_data->regs->rdbr);
 		drv_data->rx += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -311,6 +366,11 @@ static void bfin_spi_u16_duplex(struct b
 	/* discard old RX data and clear RXS */
 	bfin_spi_dummy_read(drv_data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tdbr, (*(u16 *) (drv_data->tx)));
 		drv_data->tx += 2;
@@ -318,6 +378,12 @@ static void bfin_spi_u16_duplex(struct b
 			cpu_relax();
 		*(u16 *) (drv_data->rx) = bfin_read(&drv_data->regs->rdbr);
 		drv_data->rx += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/spi/spi-pl022.c b/spi/spi-pl022.c
--- a/spi/spi-pl022.c
+++ b/spi/spi-pl022.c
@@ -669,6 +669,11 @@ static void readwriter(struct pl022 *pl0
 		__func__, pl022->rx, pl022->rx_end, pl022->tx, pl022->tx_end);
 
 	/* Read as much as you can */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
 	       && (pl022->rx < pl022->rx_end)) {
 		switch (pl022->read) {
@@ -690,10 +695,21 @@ static void readwriter(struct pl022 *pl0
 		}
 		pl022->rx += (pl022->cur_chip->n_bytes);
 		pl022->exp_fifo_level--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * Write as much as possible up to the RX FIFO size
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((pl022->exp_fifo_level < pl022->vendor->fifodepth)
 	       && (pl022->tx < pl022->tx_end)) {
 		switch (pl022->write) {
@@ -718,6 +734,11 @@ static void readwriter(struct pl022 *pl0
 		 * clock starts running when you put things into the TX FIFO,
 		 * and then things are continuously clocked into the RX FIFO.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
 		       && (pl022->rx < pl022->rx_end)) {
 			switch (pl022->read) {
@@ -739,6 +760,18 @@ static void readwriter(struct pl022 *pl0
 			}
 			pl022->rx += (pl022->cur_chip->n_bytes);
 			pl022->exp_fifo_level--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 	/*
@@ -1459,6 +1492,11 @@ static void do_polling_transfer(struct p
 		dev_dbg(&pl022->adev->dev, "polling transfer ongoing ...\n");
 
 		timeout = jiffies + msecs_to_jiffies(SPI_POLLING_TIMEOUT);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (pl022->tx < pl022->tx_end || pl022->rx < pl022->rx_end) {
 			time = jiffies;
 			readwriter(pl022);
@@ -1469,6 +1507,12 @@ static void do_polling_transfer(struct p
 				goto out;
 			}
 			cpu_relax();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Update total byte transferred */
diff -u -p a/spi/spi-orion.c b/spi/spi-orion.c
--- a/spi/spi-orion.c
+++ b/spi/spi-orion.c
@@ -282,6 +282,11 @@ static void orion_spi_work(struct work_s
 		container_of(work, struct orion_spi, work);
 
 	spin_lock_irq(&orion_spi->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&orion_spi->msg_queue)) {
 		struct spi_message *m;
 		struct spi_device *spi;
@@ -340,6 +345,12 @@ msg_done:
 		m->complete(m->context);
 
 		spin_lock_irq(&orion_spi->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irq(&orion_spi->lock);
diff -u -p a/spi/spi-fsl-espi.c b/spi/spi-fsl-espi.c
--- a/spi/spi-fsl-espi.c
+++ b/spi/spi-fsl-espi.c
@@ -513,9 +513,20 @@ void fsl_espi_cpu_irq(struct mpc8xxx_spi
 		u8 rx_data_8;
 
 		/* Spin until RX is done */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (SPIE_RXCNT(events) < min(4, mspi->len)) {
 			cpu_relax();
 			events = mpc8xxx_spi_read_reg(&reg_base->event);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (mspi->len >= 4) {
diff -u -p a/spi/spi-coldfire-qspi.c b/spi/spi-coldfire-qspi.c
--- a/spi/spi-coldfire-qspi.c
+++ b/spi/spi-coldfire-qspi.c
@@ -309,7 +309,12 @@ static void mcfqspi_work(struct work_str
 	unsigned long flags;
 
 	spin_lock_irqsave(&mcfqspi->lock, flags);
-	while (!list_empty(&mcfqspi->msgq)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&mcfqspi->msgq)) {
 		struct spi_message *msg;
 		struct spi_device *spi;
 		struct spi_transfer *xfer;
@@ -376,6 +381,12 @@ static void mcfqspi_work(struct work_str
 		msg->complete(msg->context);
 
 		spin_lock_irqsave(&mcfqspi->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&mcfqspi->lock, flags);
 }
diff -u -p a/spi/spi-bfin-sport.c b/spi/spi-bfin-sport.c
--- a/spi/spi-bfin-sport.c
+++ b/spi/spi-bfin-sport.c
@@ -172,10 +172,21 @@ bfin_sport_spi_u8_writer(struct bfin_spo
 {
 	u16 dummy;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx8++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		dummy = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -184,20 +195,42 @@ bfin_sport_spi_u8_reader(struct bfin_spo
 {
 	u16 tx_val = drv_data->cur_chip->idle_tx_val;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, tx_val);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx8++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
 static void
 bfin_sport_spi_u8_duplex(struct bfin_sport_spi_master_data *drv_data)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx8++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx8++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -212,10 +245,21 @@ bfin_sport_spi_u16_writer(struct bfin_sp
 {
 	u16 dummy;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->tx < drv_data->tx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx16++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		dummy = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -224,20 +268,42 @@ bfin_sport_spi_u16_reader(struct bfin_sp
 {
 	u16 tx_val = drv_data->cur_chip->idle_tx_val;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, tx_val);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx16++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
 static void
 bfin_sport_spi_u16_duplex(struct bfin_sport_spi_master_data *drv_data)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drv_data->rx < drv_data->rx_end) {
 		bfin_write(&drv_data->regs->tx16, *drv_data->tx16++);
 		bfin_sport_spi_stat_poll_complete(drv_data);
 		*drv_data->rx16++ = bfin_read(&drv_data->regs->rx16);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/spi/spi-bitbang.c b/spi/spi-bitbang.c
--- a/spi/spi-bitbang.c
+++ b/spi/spi-bitbang.c
@@ -263,6 +263,11 @@ static void bitbang_work(struct work_str
 
 	spin_lock_irqsave(&bitbang->lock, flags);
 	bitbang->busy = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&bitbang->queue)) {
 		struct spi_message	*m;
 		struct spi_device	*spi;
@@ -373,6 +378,12 @@ static void bitbang_work(struct work_str
 		}
 
 		spin_lock_irqsave(&bitbang->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	bitbang->busy = 0;
 	spin_unlock_irqrestore(&bitbang->lock, flags);
diff -u -p a/spi/spi-pxa2xx.c b/spi/spi-pxa2xx.c
--- a/spi/spi-pxa2xx.c
+++ b/spi/spi-pxa2xx.c
@@ -235,8 +235,19 @@ static int flush(struct driver_data *drv
 	void __iomem *reg = drv_data->ioaddr;
 
 	do {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (read_SSSR(reg) & SSSR_RNE) {
 			read_SSDR(reg);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} while ((read_SSSR(reg) & SSSR_BSY) && --limit);
 	write_SSSR_CS(drv_data, SSSR_ROR);
@@ -264,10 +275,21 @@ static int null_reader(struct driver_dat
 	void __iomem *reg = drv_data->ioaddr;
 	u8 n_bytes = drv_data->n_bytes;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		read_SSDR(reg);
 		drv_data->rx += n_bytes;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return drv_data->rx == drv_data->rx_end;
@@ -291,10 +313,21 @@ static int u8_reader(struct driver_data
 {
 	void __iomem *reg = drv_data->ioaddr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		*(u8 *)(drv_data->rx) = read_SSDR(reg);
 		++drv_data->rx;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return drv_data->rx == drv_data->rx_end;
@@ -318,10 +351,21 @@ static int u16_reader(struct driver_data
 {
 	void __iomem *reg = drv_data->ioaddr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		*(u16 *)(drv_data->rx) = read_SSDR(reg);
 		drv_data->rx += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return drv_data->rx == drv_data->rx_end;
@@ -345,10 +389,21 @@ static int u32_reader(struct driver_data
 {
 	void __iomem *reg = drv_data->ioaddr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((read_SSSR(reg) & SSSR_RNE)
 		&& (drv_data->rx < drv_data->rx_end)) {
 		*(u32 *)(drv_data->rx) = read_SSDR(reg);
 		drv_data->rx += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return drv_data->rx == drv_data->rx_end;
diff -u -p a/spi/spi-imx.c b/spi/spi-imx.c
--- a/spi/spi-imx.c
+++ b/spi/spi-imx.c
@@ -646,9 +646,20 @@ static irqreturn_t spi_imx_isr(int irq,
 {
 	struct spi_imx_data *spi_imx = dev_id;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (spi_imx->devtype_data->rx_available(spi_imx)) {
 		spi_imx->rx(spi_imx);
 		spi_imx->txfifo--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (spi_imx->count) {
diff -u -p a/spi/spi-s3c64xx.c b/spi/spi-s3c64xx.c
--- a/spi/spi-s3c64xx.c
+++ b/spi/spi-s3c64xx.c
@@ -782,7 +782,12 @@ static void s3c64xx_spi_work(struct work
 
 	spin_lock_irqsave(&sdd->lock, flags);
 
-	while (!list_empty(&sdd->queue)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&sdd->queue)
 				&& !(sdd->state & SUSPND)) {
 
 		struct spi_message *msg;
@@ -801,6 +806,12 @@ static void s3c64xx_spi_work(struct work
 		spin_lock_irqsave(&sdd->lock, flags);
 
 		sdd->state &= ~SPIBUSY;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock_irqrestore(&sdd->lock, flags);
diff -u -p a/spi/spi-omap-uwire.c b/spi/spi-omap-uwire.c
--- a/spi/spi-omap-uwire.c
+++ b/spi/spi-omap-uwire.c
@@ -278,7 +278,12 @@ static int uwire_txrx(struct spi_device
 		u8		*buf = t->rx_buf;
 
 		/* read one or two bytes at a time */
-		while (len) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (len) {
 			if (bits > 8) {
 				bytes = 2;
 			} else
@@ -310,6 +315,12 @@ static int uwire_txrx(struct spi_device
 					dev_name(&spi->dev), bits, val);
 #endif
 
+if (_cur < timeout) {
+				rdstcll(_cur);
+}
+else {
+				break;
+}
 		}
 	}
 	return status;
diff -u -p a/spi/spi-mpc52xx-psc.c b/spi/spi-mpc52xx-psc.c
--- a/spi/spi-mpc52xx-psc.c
+++ b/spi/spi-mpc52xx-psc.c
@@ -149,6 +149,11 @@ static int mpc52xx_psc_spi_transfer_rxtx
 
 	/* enable transmiter/receiver */
 	out_8(&psc->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rb < t->len) {
 		if (t->len - rb > MPC52xx_PSC_BUFSIZE) {
 			rfalarm = MPC52xx_PSC_RFALARM;
@@ -196,6 +201,12 @@ static int mpc52xx_psc_spi_transfer_rxtx
 			for (; recv_at_once; rb++, recv_at_once--)
 				in_8(&psc->mpc52xx_psc_buffer_8);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* disable transmiter/receiver */
 	out_8(&psc->command, MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);
@@ -210,6 +221,11 @@ static void mpc52xx_psc_spi_work(struct
 
 	spin_lock_irq(&mps->lock);
 	mps->busy = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&mps->queue)) {
 		struct spi_message *m;
 		struct spi_device *spi;
@@ -256,6 +272,12 @@ static void mpc52xx_psc_spi_work(struct
 		mpc52xx_psc_spi_transfer_setup(spi, NULL);
 
 		spin_lock_irq(&mps->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mps->busy = 0;
 	spin_unlock_irq(&mps->lock);
diff -u -p a/spi/spi-omap-100k.c b/spi/spi-omap-100k.c
--- a/spi/spi-omap-100k.c
+++ b/spi/spi-omap-100k.c
@@ -346,6 +346,11 @@ static void omap1_spi100k_work(struct wo
 	 * channel" master mode.  As a side effect, we need to manage the
 	 * chipselect with the FORCE bit ... CS != channel enable.
 	 */
+	 unsigned long long delta = (cpu / khz / HZ) * 2;
+	 unsigned long long _start = 0;
+	 unsigned long long _cur = 0;
+	 unsigned long long timeout;
+	 timeout = rdstcll(start) + delta;
 	 while (!list_empty(&spi100k->msg_queue)) {
 		struct spi_message              *m;
 		struct spi_device               *spi;
@@ -418,6 +423,12 @@ static void omap1_spi100k_work(struct wo
 		m->complete(m->context);
 
 		spin_lock_irq(&spi100k->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	clk_disable(spi100k->ick);
diff -u -p a/ssb/sprom.c b/ssb/sprom.c
--- a/ssb/sprom.c
+++ b/ssb/sprom.c
@@ -51,6 +51,11 @@ static int hex2sprom(u16 *sprom, const c
 	if (len != sprom_size_words * 4)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt < sprom_size_words) {
 		memcpy(tmp, dump, 4);
 		dump += 4;
@@ -58,6 +63,12 @@ static int hex2sprom(u16 *sprom, const c
 		if (err)
 			return err;
 		sprom[cnt++] = swab16((u16)parsed);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/ssb/main.c b/ssb/main.c
--- a/ssb/main.c
+++ b/ssb/main.c
@@ -630,10 +630,21 @@ static void ssb_ssb_block_read(struct ss
 	case sizeof(u8): {
 		u8 *buf = buffer;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			*buf = __raw_readb(addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -641,10 +652,21 @@ static void ssb_ssb_block_read(struct ss
 		__le16 *buf = buffer;
 
 		SSB_WARN_ON(count & 1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -652,10 +674,21 @@ static void ssb_ssb_block_read(struct ss
 		__le32 *buf = buffer;
 
 		SSB_WARN_ON(count & 3);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			*buf = (__force __le32)__raw_readl(addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -703,10 +736,21 @@ static void ssb_ssb_block_write(struct s
 	case sizeof(u8): {
 		const u8 *buf = buffer;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			__raw_writeb(*buf, addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -714,10 +758,21 @@ static void ssb_ssb_block_write(struct s
 		const __le16 *buf = buffer;
 
 		SSB_WARN_ON(count & 1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -725,10 +780,21 @@ static void ssb_ssb_block_write(struct s
 		const __le32 *buf = buffer;
 
 		SSB_WARN_ON(count & 3);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			__raw_writel((__force u32)(*buf), addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
diff -u -p a/ssb/pcmcia.c b/ssb/pcmcia.c
--- a/ssb/pcmcia.c
+++ b/ssb/pcmcia.c
@@ -292,10 +292,21 @@ static void ssb_pcmcia_block_read(struct
 	case sizeof(u8): {
 		u8 *buf = buffer;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			*buf = __raw_readb(addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -303,10 +314,21 @@ static void ssb_pcmcia_block_read(struct
 		__le16 *buf = buffer;
 
 		SSB_WARN_ON(count & 1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -314,12 +336,23 @@ static void ssb_pcmcia_block_read(struct
 		__le16 *buf = buffer;
 
 		SSB_WARN_ON(count & 3);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			*buf = (__force __le16)__raw_readw(addr + 2);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -392,10 +425,21 @@ static void ssb_pcmcia_block_write(struc
 	case sizeof(u8): {
 		const u8 *buf = buffer;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			__raw_writeb(*buf, addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -403,10 +447,21 @@ static void ssb_pcmcia_block_write(struc
 		const __le16 *buf = buffer;
 
 		SSB_WARN_ON(count & 1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -414,12 +469,23 @@ static void ssb_pcmcia_block_write(struc
 		const __le16 *buf = buffer;
 
 		SSB_WARN_ON(count & 3);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			__raw_writew((__force u16)(*buf), addr + 2);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
diff -u -p a/ssb/sdio.c b/ssb/sdio.c
--- a/ssb/sdio.c
+++ b/ssb/sdio.c
@@ -483,6 +483,11 @@ int ssb_sdio_get_invariants(struct ssb_b
 	sprom->boardflags_hi = 0;
 
 	tuple = bus->host_sdio->tuples;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tuple) {
 		switch (tuple->code) {
 		case 0x22: /* extended function */
@@ -583,6 +588,12 @@ int ssb_sdio_get_invariants(struct ssb_b
 			break;
 		}
 		tuple = tuple->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/uio/uio_pdrv_genirq.c b/uio/uio_pdrv_genirq.c
--- a/uio/uio_pdrv_genirq.c
+++ b/uio/uio_pdrv_genirq.c
@@ -167,9 +167,20 @@ static int uio_pdrv_genirq_probe(struct
 		++uiomem;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {
 		uiomem->size = 0;
 		++uiomem;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* This driver requires no hardware specific kernel code to handle
diff -u -p a/uio/uio_pdrv.c b/uio/uio_pdrv.c
--- a/uio/uio_pdrv.c
+++ b/uio/uio_pdrv.c
@@ -63,9 +63,20 @@ static int uio_pdrv_probe(struct platfor
 		++uiomem;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {
 		uiomem->size = 0;
 		++uiomem;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pdata->uioinfo->priv = pdata;
diff -u -p a/tty/vt/vc_screen.c b/tty/vt/vc_screen.c
--- a/tty/vt/vc_screen.c
+++ b/tty/vt/vc_screen.c
@@ -343,6 +343,11 @@ vcs_read(struct file *file, char __user
 				 */
 				this_round = (this_round + 1) >> 1;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (this_round) {
 					*tmp_buf++ = vcs_scr_readw(vc, org++);
 					this_round --;
@@ -351,6 +356,12 @@ vcs_read(struct file *file, char __user
 						col = 0;
 						p += maxcol;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 		}
diff -u -p a/tty/vt/selection.c b/tty/vt/selection.c
--- a/tty/vt/selection.c
+++ b/tty/vt/selection.c
@@ -325,6 +325,11 @@ int paste_selection(struct tty_struct *t
 	}
 
 	add_wait_queue(&vc->paste_wait, &wait);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sel_buffer && sel_buffer_lth > pasted) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (test_bit(TTY_THROTTLED, &tty->flags)) {
@@ -336,6 +341,12 @@ int paste_selection(struct tty_struct *t
 		tty->ldisc->ops->receive_buf(tty, sel_buffer + pasted,
 								NULL, count);
 		pasted += count;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	remove_wait_queue(&vc->paste_wait, &wait);
 	__set_current_state(TASK_RUNNING);
diff -u -p a/tty/vt/keyboard.c b/tty/vt/keyboard.c
--- a/tty/vt/keyboard.c
+++ b/tty/vt/keyboard.c
@@ -330,9 +330,20 @@ static void puts_queue(struct vc_data *v
 	if (!tty)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*cp) {
 		tty_insert_flip_char(tty, *cp, 0);
 		cp++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	con_schedule_flip(tty);
 }
diff -u -p a/tty/hvc/hvc_iucv.c b/tty/hvc/hvc_iucv.c
--- a/tty/hvc/hvc_iucv.c
+++ b/tty/hvc/hvc_iucv.c
@@ -1115,7 +1115,12 @@ static int hvc_iucv_setup_filter(const c
 
 	count = size;
 	residual = val;
-	while (*residual && count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*residual && count) {
 		residual = hvc_iucv_parse_filter(residual,
 						 array + ((size - count) * 8));
 		if (IS_ERR(residual)) {
@@ -1124,7 +1129,13 @@ static int hvc_iucv_setup_filter(const c
 			goto out_err;
 		}
 		count--;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out_replace_filter:
 	write_lock_bh(&hvc_iucv_filter_lock);
diff -u -p a/tty/hvc/hvc_console.c b/tty/hvc/hvc_console.c
--- a/tty/hvc/hvc_console.c
+++ b/tty/hvc/hvc_console.c
@@ -438,10 +438,21 @@ static void hvc_hangup(struct tty_struct
 	if (hp->ops->notifier_hangup)
 		hp->ops->notifier_hangup(hp, hp->data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(temp_open_count) {
 		--temp_open_count;
 		tty_kref_put(tty);
 		kref_put(&hp->kref, destroy_hvc_struct);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/hvc/hvcs.c b/tty/hvc/hvcs.c
--- a/tty/hvc/hvcs.c
+++ b/tty/hvc/hvcs.c
@@ -1301,6 +1301,11 @@ static void hvcs_hangup(struct tty_struc
 	 * tty_hangup() function doesn't invoke a close per open connection on a
 	 * non-console device.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(temp_open_count) {
 		--temp_open_count;
 		/*
@@ -1309,6 +1314,12 @@ static void hvcs_hangup(struct tty_struc
 		 * final put will never happen.
 		 */
 		kref_put(&hvcsd->kref, destroy_hvcs_struct);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/hvc/hvsi.c b/tty/hvc/hvsi.c
--- a/tty/hvc/hvsi.c
+++ b/tty/hvc/hvsi.c
@@ -502,6 +502,11 @@ static irqreturn_t hvsi_interrupt(int ir
 
 	pr_debug("%s\n", __func__);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (again) {
 		spin_lock_irqsave(&hp->lock, flags);
 		again = hvsi_load_chunk(hp, &flip, &hangup, &handshake);
@@ -527,6 +532,12 @@ static irqreturn_t hvsi_interrupt(int ir
 			pr_debug("hvsi%i: attempting re-handshake\n", handshake->index);
 			schedule_work(&handshake->handshaker);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_lock_irqsave(&hp->lock, flags);
diff -u -p a/tty/hvc/hvc_xen.c b/tty/hvc/hvc_xen.c
--- a/tty/hvc/hvc_xen.c
+++ b/tty/hvc/hvc_xen.c
@@ -89,6 +89,11 @@ static int domU_write_console(uint32_t v
 	 * because the most interesting console output is when the
 	 * kernel is crippled.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		int sent = __write_console(data, len);
 		
@@ -97,6 +102,12 @@ static int domU_write_console(uint32_t v
 
 		if (unlikely(len))
 			HYPERVISOR_sched_op(SCHEDOP_yield, NULL);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return ret;
diff -u -p a/tty/synclinkmp.c b/tty/synclinkmp.c
--- a/tty/synclinkmp.c
+++ b/tty/synclinkmp.c
@@ -1421,9 +1421,20 @@ static int synclinkmp_proc_show(struct s
 	seq_printf(m, "synclinkmp driver:%s\n", driver_version);
 
 	info = synclinkmp_device_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -2169,6 +2180,11 @@ static void isr_rxrdy(SLMP_INFO * info)
 		printk("%s(%d):%s isr_rxrdy\n",
 			__FILE__,__LINE__,info->device_name);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while((status = read_reg(info,CST0)) & BIT0)
 	{
 		int flag = 0;
@@ -2215,6 +2231,12 @@ static void isr_rxrdy(SLMP_INFO * info)
 			if (over)
 				tty_insert_flip_char(tty, 0, TTY_OVERRUN);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if ( debug_level >= DEBUG_LEVEL_ISR ) {
@@ -3924,13 +3946,29 @@ static void synclinkmp_cleanup(void)
 
 	/* reset devices */
 	info = synclinkmp_device_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(info) {
 		reset_port(info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* release devices */
 	info = synclinkmp_device_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(info) {
 #if SYNCLINK_GENERIC_HDLC
 		hdlcdev_exit(info);
@@ -3945,6 +3983,12 @@ static void synclinkmp_cleanup(void)
 		tmp = info;
 		info = info->next_device;
 		kfree(tmp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pci_unregister_driver(&synclinkmp_pci_driver);
@@ -4301,6 +4345,11 @@ static void tx_load_fifo(SLMP_INFO *info
 
 	/* load the Transmit FIFO until FIFOs full or all data sent */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( info->tx_count && (read_reg(info,SR0) & BIT1) ) {
 
 		/* there is more space in the transmit FIFO and */
@@ -4334,6 +4383,12 @@ static void tx_load_fifo(SLMP_INFO *info
 			}
 			info->icount.tx++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4809,6 +4864,11 @@ static void rx_free_frame_buffers(SLMP_I
 {
 	bool done = false;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(!done) {
 	        /* reset current buffer for reuse */
 		info->rx_buf_list[first].status = 0xff;
@@ -4822,6 +4882,12 @@ static void rx_free_frame_buffers(SLMP_I
 	        first++;
 		if (first == info->rx_buf_count)
 			first = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* set current buffer to next buffer after last buffer of frame */
@@ -4964,7 +5030,12 @@ CheckAgain:
 
 			info->icount.rxok++;
 
-			while(copy_count) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while(copy_count) {
 				int partial_count = min(copy_count,SCABUFSIZE);
 				memcpy( ptmp,
 					info->rx_buf_list_ex[index].virt_addr,
@@ -4974,7 +5045,13 @@ CheckAgain:
 
 				if ( ++index == info->rx_buf_count )
 					index = 0;
-			}
+					if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
+}
 
 #if SYNCLINK_GENERIC_HDLC
 			if (info->netcount)
@@ -5444,7 +5521,12 @@ static void trace_block(SLMP_INFO *info,
 	else
 		printk("%s rx data:\n",info->device_name);
 
-	while(count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(count) {
 		if (count > 16)
 			linecount = 16;
 		else
@@ -5464,6 +5546,12 @@ static void trace_block(SLMP_INFO *info,
 
 		data  += linecount;
 		count -= linecount;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }	/* end of trace_block() */
 
diff -u -p a/tty/nozomi.c b/tty/nozomi.c
--- a/tty/nozomi.c
+++ b/tty/nozomi.c
@@ -455,6 +455,11 @@ static void read_mem32(u32 *buf, const v
 		break;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < size_bytes) {
 		if (size_bytes - i == 2) {
 			/* Handle 2 bytes in the end */
@@ -468,7 +473,13 @@ static void read_mem32(u32 *buf, const v
 		}
 		buf++;
 		ptr++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	return;
 }
@@ -505,6 +516,11 @@ static u32 write_mem32(void __iomem *mem
 		break;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < size_bytes) {
 		if (size_bytes - i == 2) {
 			/* 2 bytes */
@@ -518,6 +534,12 @@ static u32 write_mem32(void __iomem *mem
 		}
 		buf++;
 		ptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return i;
 }
diff -u -p a/tty/ehv_bytechan.c b/tty/ehv_bytechan.c
--- a/tty/ehv_bytechan.c
+++ b/tty/ehv_bytechan.c
@@ -257,6 +257,11 @@ static int ehv_bc_console_byte_channel_s
 	unsigned int len;
 	int ret = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		len = min_t(unsigned int, count, EV_BYTE_CHANNEL_MAX_BYTES);
 		do {
@@ -264,6 +269,12 @@ static int ehv_bc_console_byte_channel_s
 		} while (ret == EV_EAGAIN);
 		count -= len;
 		s += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
diff -u -p a/tty/amiserial.c b/tty/amiserial.c
--- a/tty/amiserial.c
+++ b/tty/amiserial.c
@@ -1339,6 +1339,11 @@ static int rs_ioctl(struct tty_struct *t
 			/* note the counters on entry */
 			cprev = info->state->icount;
 			local_irq_restore(flags);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (1) {
 				interruptible_sleep_on(&info->delta_msr_wait);
 				/* see if a signal did it */
@@ -1357,6 +1362,12 @@ static int rs_ioctl(struct tty_struct *t
 					return 0;
 				}
 				cprev = cnow;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			/* NOTREACHED */
 
diff -u -p a/tty/bfin_jtag_comm.c b/tty/bfin_jtag_comm.c
--- a/tty/bfin_jtag_comm.c
+++ b/tty/bfin_jtag_comm.c
@@ -72,6 +72,11 @@ bfin_jc_emudat_manager(void *arg)
 {
 	uint32_t inbound_len = 0, outbound_len = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		/* no one left to give data to, so sleep */
 		if (bfin_jc_tty == NULL && circ_empty(&bfin_jc_write_buf)) {
@@ -140,6 +145,12 @@ bfin_jc_emudat_manager(void *arg)
 				pr_debug("  outgoing data: 0x%08x (pushing %zu)\n", emudat, ate);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	__set_current_state(TASK_RUNNING);
@@ -300,11 +311,22 @@ bfin_jc_straight_buffer_write(const char
 	while (bfin_read_DBGSTAT() & EMUDOF)
 		continue;
 	bfin_write_emudat(count);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ate < count) {
 		while (bfin_read_DBGSTAT() & EMUDOF)
 			continue;
 		bfin_write_emudat_chars(buf[ate], buf[ate+1], buf[ate+2], buf[ate+3]);
 		ate += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 #endif
diff -u -p a/tty/rocket.c b/tty/rocket.c
--- a/tty/rocket.c
+++ b/tty/rocket.c
@@ -355,6 +355,11 @@ static void rp_do_receive(struct r_port
 		printk(KERN_INFO "Ignore %x, read %x...\n",
 			info->ignore_status_mask, info->read_status_mask);
 #endif
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ToRecv) {
 			char flag;
 
@@ -381,6 +386,12 @@ static void rp_do_receive(struct r_port
 				flag = TTY_NORMAL;
 			tty_insert_flip_char(tty, CharNStat & 0xff, flag);
 			ToRecv--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+}
 		}
 
 		/*
@@ -2074,9 +2085,20 @@ static int __init init_PCI(int boards_fo
 	int count = 0;
 
 	/*  Work through the PCI device list, pulling out ours */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((dev = pci_get_device(PCI_VENDOR_ID_RP, PCI_ANY_ID, dev))) {
 		if (register_PCI(count + boards_found, dev))
 			count++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return (count);
 }
diff -u -p a/tty/cyclades.c b/tty/cyclades.c
--- a/tty/cyclades.c
+++ b/tty/cyclades.c
@@ -1073,7 +1073,12 @@ static void cyz_handle_tx(struct cyclade
 					(SERIAL_XMIT_SIZE - 1);
 		}
 #else
-		while (info->xmit_cnt && char_count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+unsigned long long _start = 0;
+unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+			while (info->xmit_cnt && char_count) {
 			data = info->port.xmit_buf[info->xmit_tail];
 			info->xmit_cnt--;
 			info->xmit_tail = (info->xmit_tail + 1) &
@@ -1083,7 +1088,13 @@ static void cyz_handle_tx(struct cyclade
 			tx_put = (tx_put + 1) & (tx_bufsize - 1);
 			char_count--;
 			info->icount.tx++;
-		}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
+}
 #endif
 		tty_wakeup(tty);
 ztxdone:
diff -u -p a/tty/n_gsm.c b/tty/n_gsm.c
--- a/tty/n_gsm.c
+++ b/tty/n_gsm.c
@@ -808,6 +808,11 @@ static int gsm_dlci_data_output(struct g
 	int h = dlci->adaption - 1;
 
 	total_size = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(1) {
 		len = kfifo_len(dlci->fifo);
 		if (len == 0)
@@ -836,6 +841,12 @@ static int gsm_dlci_data_output(struct g
 		WARN_ON(kfifo_out_locked(dlci->fifo, dp , len, &dlci->lock) != len);
 		__gsm_data_queue(dlci, msg);
 		total_size += size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Bytes of data we used up */
 	return total_size;
diff -u -p a/tty/moxa.c b/tty/moxa.c
--- a/tty/moxa.c
+++ b/tty/moxa.c
@@ -572,6 +572,11 @@ static int moxa_real_load_code(struct mo
 	do {
 		wlen = len >> 1;
 		j = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (wlen) {
 			len2 = (wlen > 2048) ? 2048 : wlen;
 			wlen -= len2;
@@ -587,6 +592,12 @@ static int moxa_real_load_code(struct mo
 			}
 			if (readw(baseAddr + key) != keycode)
 				return -EIO;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		writew(0, baseAddr + loadlen);
 		writew(usum, baseAddr + checksum);
diff -u -p a/tty/tty_io.c b/tty/tty_io.c
--- a/tty/tty_io.c
+++ b/tty/tty_io.c
@@ -3271,9 +3271,20 @@ void __init console_init(void)
 	 * inform about problems etc..
 	 */
 	call = __con_initcall_start;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (call < __con_initcall_end) {
 		(*call)();
 		call++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/ipwireless/hardware.c b/tty/ipwireless/hardware.c
--- a/tty/ipwireless/hardware.c
+++ b/tty/ipwireless/hardware.c
@@ -931,6 +931,11 @@ static int get_packets_from_hw(struct ip
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hw->rx_ready && !hw->blocking_rx) {
 		received = 1;
 		hw->rx_ready--;
@@ -939,6 +944,12 @@ static int get_packets_from_hw(struct ip
 		do_receive_packet(hw);
 
 		spin_lock_irqsave(&hw->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&hw->lock, flags);
 
diff -u -p a/tty/serial/dz.c b/tty/serial/dz.c
--- a/tty/serial/dz.c
+++ b/tty/serial/dz.c
@@ -195,6 +195,11 @@ static inline void dz_receive_chars(stru
 	u16 status;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = dz_in(dport, DZ_RBUF)) & DZ_DVAL) {
 		dport = &mux->dport[LINE(status)];
 		uport = &dport->port;
@@ -247,6 +252,12 @@ static inline void dz_receive_chars(stru
 
 		uart_insert_char(uport, status, DZ_OERR, ch, flag);
 		lines_rx[LINE(status)] = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	for (i = 0; i < DZ_NB_PORT; i++)
 		if (lines_rx[i])
diff -u -p a/tty/serial/ioc3_serial.c b/tty/serial/ioc3_serial.c
--- a/tty/serial/ioc3_serial.c
+++ b/tty/serial/ioc3_serial.c
@@ -1185,11 +1185,22 @@ static inline int do_read(struct uart_po
 		 */
 		if (prod_ptr == cons_ptr) {
 			loop_counter = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (readl(&port->ip_serial_regs->sscr) &
 			       SSCR_RX_DRAIN) {
 				loop_counter++;
 				if (loop_counter > MAXITER)
 					return -1;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+			    else {
+					break;
+			    }
 			}
 
 			/* SIGH. We have to reload the prod_ptr *again* since
diff -u -p a/tty/serial/vt8500_serial.c b/tty/serial/vt8500_serial.c
--- a/tty/serial/vt8500_serial.c
+++ b/tty/serial/vt8500_serial.c
@@ -145,6 +145,11 @@ static void handle_rx(struct uart_port *
 	}
 
 	/* and now the main RX loop */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (vt8500_read(port, VT8500_URFIDX) & 0x1f00) {
 		unsigned int c;
 		char flag = TTY_NORMAL;
@@ -165,6 +170,12 @@ static void handle_rx(struct uart_port *
 
 		if (!uart_handle_sysrq_char(port, c))
 			tty_insert_flip_char(tty, c, flag);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	tty_flip_buffer_push(tty);
diff -u -p a/tty/serial/atmel_serial.c b/tty/serial/atmel_serial.c
--- a/tty/serial/atmel_serial.c
+++ b/tty/serial/atmel_serial.c
@@ -489,6 +489,11 @@ static void atmel_rx_chars(struct uart_p
 	unsigned int status, ch;
 
 	status = UART_GET_CSR(port);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & ATMEL_US_RXRDY) {
 		ch = UART_GET_CHAR(port);
 
@@ -523,6 +528,12 @@ static void atmel_rx_chars(struct uart_p
 
 		atmel_buffer_rx_char(port, status, ch);
 		status = UART_GET_CSR(port);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tasklet_schedule(&atmel_port->tasklet);
@@ -714,6 +725,11 @@ static void atmel_rx_from_ring(struct ua
 	unsigned int flg;
 	unsigned int status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ring->head != ring->tail) {
 		struct atmel_uart_char c;
 
@@ -764,6 +780,12 @@ static void atmel_rx_from_ring(struct ua
 			continue;
 
 		uart_insert_char(port, status, ATMEL_US_OVRE, c.ch, flg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/tty/serial/altera_uart.c b/tty/serial/altera_uart.c
--- a/tty/serial/altera_uart.c
+++ b/tty/serial/altera_uart.c
@@ -193,6 +193,11 @@ static void altera_uart_rx_chars(struct
 	unsigned char ch, flag;
 	unsigned short status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = altera_uart_readl(port, ALTERA_UART_STATUS_REG)) &
 	       ALTERA_UART_STATUS_RRDY_MSK) {
 		ch = altera_uart_readl(port, ALTERA_UART_RXDATA_REG);
@@ -229,6 +234,12 @@ static void altera_uart_rx_chars(struct
 			continue;
 		uart_insert_char(port, status, ALTERA_UART_STATUS_ROE_MSK, ch,
 				 flag);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tty_flip_buffer_push(port->state->port.tty);
diff -u -p a/tty/serial/imx.c b/tty/serial/imx.c
--- a/tty/serial/imx.c
+++ b/tty/serial/imx.c
@@ -385,7 +385,12 @@ static inline void imx_transmit_buffer(s
 {
 	struct circ_buf *xmit = &sport->port.state->xmit;
 
-	while (!uart_circ_empty(xmit) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!uart_circ_empty(xmit) &&
 			!(readl(sport->port.membase + uts_reg(sport))
 				& UTS_TXFULL)) {
 		/* send xmit->buf[xmit->tail]
@@ -393,6 +398,12 @@ static inline void imx_transmit_buffer(s
 		writel(xmit->buf[xmit->tail], sport->port.membase + URTX0);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		sport->port.icount.tx++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
@@ -493,6 +504,11 @@ static irqreturn_t imx_rxint(int irq, vo
 
 	spin_lock_irqsave(&sport->port.lock,flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (readl(sport->port.membase + USR2) & USR2_RDR) {
 		flg = TTY_NORMAL;
 		sport->port.icount.rx++;
@@ -542,7 +558,13 @@ static irqreturn_t imx_rxint(int irq, vo
 		}
 
 		tty_insert_flip_char(tty, rx, flg);
-	}
+		if (_cur < timeout) {
+rdstcll(_cur);
+		}
+		else {
+break;
+		}
+}
 
 out:
 	spin_unlock_irqrestore(&sport->port.lock,flags);
diff -u -p a/tty/serial/mcf.c b/tty/serial/mcf.c
--- a/tty/serial/mcf.c
+++ b/tty/serial/mcf.c
@@ -274,6 +274,11 @@ static void mcf_rx_chars(struct mcf_uart
 	struct uart_port *port = &pp->port;
 	unsigned char status, ch, flag;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = readb(port->membase + MCFUART_USR)) & MCFUART_USR_RXREADY) {
 		ch = readb(port->membase + MCFUART_URB);
 		flag = TTY_NORMAL;
@@ -308,6 +313,12 @@ static void mcf_rx_chars(struct mcf_uart
 		if (uart_handle_sysrq_char(port, ch))
 			continue;
 		uart_insert_char(port, status, MCFUART_USR_RXOVERRUN, ch, flag);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tty_flip_buffer_push(port->state->port.tty);
diff -u -p a/tty/serial/pnx8xxx_uart.c b/tty/serial/pnx8xxx_uart.c
--- a/tty/serial/pnx8xxx_uart.c
+++ b/tty/serial/pnx8xxx_uart.c
@@ -186,6 +186,11 @@ static void pnx8xxx_rx_chars(struct pnx8
 
 	status = FIFO_TO_SM(serial_in(sport, PNX8XXX_FIFO)) |
 		 ISTAT_TO_SM(serial_in(sport, PNX8XXX_ISTAT));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & FIFO_TO_SM(PNX8XXX_UART_FIFO_RXFIFO)) {
 		ch = serial_in(sport, PNX8XXX_FIFO) & 0xff;
 
@@ -237,6 +242,12 @@ static void pnx8xxx_rx_chars(struct pnx8
 				PNX8XXX_UART_LCR_RX_NEXT);
 		status = FIFO_TO_SM(serial_in(sport, PNX8XXX_FIFO)) |
 			 ISTAT_TO_SM(serial_in(sport, PNX8XXX_ISTAT));
+			 if (_cur < timeout) {
+		rdstcll(_cur);
+			 }
+			 else {
+		break;
+			 }
 	}
 	tty_flip_buffer_push(tty);
 }
diff -u -p a/tty/serial/clps711x.c b/tty/serial/clps711x.c
--- a/tty/serial/clps711x.c
+++ b/tty/serial/clps711x.c
@@ -95,6 +95,11 @@ static irqreturn_t clps711xuart_int_rx(i
 	unsigned int status, ch, flg;
 
 	status = clps_readl(SYSFLG(port));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(status & SYSFLG_URXFE)) {
 		ch = clps_readl(UARTDR(port));
 
@@ -137,6 +142,12 @@ static irqreturn_t clps711xuart_int_rx(i
 
 	ignore_char:
 		status = clps_readl(SYSFLG(port));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	tty_flip_buffer_push(tty);
 	return IRQ_HANDLED;
diff -u -p a/tty/serial/ip22zilog.c b/tty/serial/ip22zilog.c
--- a/tty/serial/ip22zilog.c
+++ b/tty/serial/ip22zilog.c
@@ -435,7 +435,12 @@ static irqreturn_t ip22zilog_interrupt(i
 {
 	struct uart_ip22zilog_port *up = dev_id;
 
-	while (up) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (up) {
 		struct zilog_channel *channel
 			= ZILOG_CHANNEL_FROM_PORT(&up->port);
 		struct tty_struct *tty;
@@ -487,6 +492,12 @@ static irqreturn_t ip22zilog_interrupt(i
 			tty_flip_buffer_push(tty);
 
 		up = up->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return IRQ_HANDLED;
diff -u -p a/tty/serial/sa1100.c b/tty/serial/sa1100.c
--- a/tty/serial/sa1100.c
+++ b/tty/serial/sa1100.c
@@ -192,6 +192,11 @@ sa1100_rx_chars(struct sa1100_port *spor
 
 	status = UTSR1_TO_SM(UART_GET_UTSR1(sport)) |
 		 UTSR0_TO_SM(UART_GET_UTSR0(sport));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & UTSR1_TO_SM(UTSR1_RNE)) {
 		ch = UART_GET_CHAR(sport);
 
@@ -231,6 +236,12 @@ sa1100_rx_chars(struct sa1100_port *spor
 	ignore_char:
 		status = UTSR1_TO_SM(UART_GET_UTSR1(sport)) |
 			 UTSR0_TO_SM(UART_GET_UTSR0(sport));
+			 if (_cur < timeout) {
+		rdstcll(_cur);
+			 }
+			 else {
+		break;
+			 }
 	}
 	tty_flip_buffer_push(tty);
 }
diff -u -p a/tty/serial/apbuart.c b/tty/serial/apbuart.c
--- a/tty/serial/apbuart.c
+++ b/tty/serial/apbuart.c
@@ -391,10 +391,21 @@ static int apbuart_scan_fifo_size(struct
 	 */
 
 	status = UART_GET_STATUS(port);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (((status >> 20) & 0x3F) == fifosize) {
 		fifosize++;
 		UART_PUT_CHAR(port, 0);
 		status = UART_GET_STATUS(port);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	fifosize--;
diff -u -p a/tty/serial/max3107.c b/tty/serial/max3107.c
--- a/tty/serial/max3107.c
+++ b/tty/serial/max3107.c
@@ -179,6 +179,11 @@ static void max3107_handlerx(struct max3
 	}
 	buf = s->rxbuf;
 	valid_str = s->rxstr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rxlvl) {
 		pr_debug("rxlvl %d\n", rxlvl);
 		/* Clear buffer */
@@ -215,6 +220,12 @@ static void max3107_handlerx(struct max3
 		put_data_to_circ_buf(s, valid_str, rxlvl);
 		/* Get new RX level */
 		rxlvl = (buf[len - 1] & MAX3107_SPI_RX_DATA_MASK);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (s->rx_enabled) {
diff -u -p a/tty/serial/timbuart.c b/tty/serial/timbuart.c
--- a/tty/serial/timbuart.c
+++ b/tty/serial/timbuart.c
@@ -93,10 +93,21 @@ static void timbuart_rx_chars(struct uar
 {
 	struct tty_struct *tty = port->state->port.tty;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ioread32(port->membase + TIMBUART_ISR) & RXDP) {
 		u8 ch = ioread8(port->membase + TIMBUART_RXFIFO);
 		port->icount.rx++;
 		tty_insert_flip_char(tty, ch, TTY_NORMAL);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock(&port->lock);
@@ -111,12 +122,23 @@ static void timbuart_tx_chars(struct uar
 {
 	struct circ_buf *xmit = &port->state->xmit;
 
-	while (!(ioread32(port->membase + TIMBUART_ISR) & TXBF) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(ioread32(port->membase + TIMBUART_ISR) & TXBF) &&
 		!uart_circ_empty(xmit)) {
 		iowrite8(xmit->buf[xmit->tail],
 			port->membase + TIMBUART_TXFIFO);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		port->icount.tx++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	dev_dbg(port->dev,
diff -u -p a/tty/serial/mrst_max3110.c b/tty/serial/mrst_max3110.c
--- a/tty/serial/mrst_max3110.c
+++ b/tty/serial/mrst_max3110.c
@@ -275,8 +275,18 @@ static void send_circ_buf(struct uart_ma
 	obuf = buf;
 	ibuf = buf + dma_size/2;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!uart_circ_empty(xmit)) {
 		left = uart_circ_chars_pending(xmit);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (left) {
 			len = min(left, WORDS_PER_XFER);
 			blen = len * sizeof(u16);
@@ -299,6 +309,18 @@ static void send_circ_buf(struct uart_ma
 
 			max->port.icount.tx += len;
 			left -= len;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
diff -u -p a/tty/serial/bfin_uart.c b/tty/serial/bfin_uart.c
--- a/tty/serial/bfin_uart.c
+++ b/tty/serial/bfin_uart.c
@@ -356,10 +356,21 @@ static void bfin_serial_tx_chars(struct
 		uart->port.x_char = 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((UART_GET_LSR(uart) & THRE) && xmit->tail != xmit->head) {
 		UART_PUT_CHAR(uart, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		uart->port.icount.tx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
diff -u -p a/tty/serial/ioc4_serial.c b/tty/serial/ioc4_serial.c
--- a/tty/serial/ioc4_serial.c
+++ b/tty/serial/ioc4_serial.c
@@ -2135,11 +2135,22 @@ static inline int do_read(struct uart_po
 		 */
 		if (prod_ptr == cons_ptr) {
 			loop_counter = 0;
-			while (readl(&port->ip_serial_regs->sscr) &
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (readl(&port->ip_serial_regs->sscr) &
 						IOC4_SSCR_RX_DRAIN) {
 				loop_counter++;
 				if (loop_counter > MAXITER)
 					return -1;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+							else {
+								break;
+							}
 			}
 
 			/* SIGH. We have to reload the prod_ptr *again* since
diff -u -p a/tty/serial/pmac_zilog.c b/tty/serial/pmac_zilog.c
--- a/tty/serial/pmac_zilog.c
+++ b/tty/serial/pmac_zilog.c
@@ -857,10 +857,21 @@ static void pmz_fix_zero_bug_scc(struct
 	write_zsreg(uap, 4, X16CLK | SB_MASK);
 	write_zsreg(uap, 3, Rx8);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (read_zsreg(uap, 0) & Rx_CH_AV) {
 		(void)read_zsreg(uap, 8);
 		write_zsreg(uap, 0, RES_EXT_INT);
 		write_zsreg(uap, 0, ERR_RES);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1222,6 +1233,11 @@ static void pmz_irda_setup(struct uart_p
 	(void)read_zsdata(uap);
 	(void)read_zsdata(uap);
 	mdelay(10);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (read_zsreg(uap, R0) & Rx_CH_AV) {
 		read_zsdata(uap);
 		mdelay(10);
@@ -1229,6 +1245,12 @@ static void pmz_irda_setup(struct uart_p
 			pmz_error("receiver didn't drain\n");
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Switch to command mode */
@@ -1409,11 +1431,22 @@ static int pmz_poll_get_char(struct uart
 	struct uart_pmac_port *uap = (struct uart_pmac_port *)port;
 	int tries = 2;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tries) {
 		if ((read_zsreg(uap, R0) & Rx_CH_AV) != 0)
 			return read_zsdata(uap);
 		if (tries--)
 			udelay(5);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return NO_POLL_CHAR;
@@ -1798,6 +1831,11 @@ static int __init pmz_probe(void)
 	 * Find all escc chips in the system
 	 */
 	node_p = of_find_node_by_name(NULL, "escc");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (node_p) {
 		/*
 		 * First get channel A/B node pointers
@@ -1846,6 +1884,12 @@ static int __init pmz_probe(void)
 		count += 2;
 next:
 		node_p = of_find_node_by_name(node_p, "escc");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	pmz_ports_count = count;
 
diff -u -p a/tty/serial/netx-serial.c b/tty/serial/netx-serial.c
--- a/tty/serial/netx-serial.c
+++ b/tty/serial/netx-serial.c
@@ -201,6 +201,11 @@ static void netx_rxint(struct uart_port
 	unsigned char rx, flg, status;
 	struct tty_struct *tty = port->state->port.tty;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(readl(port->membase + UART_FR) & FR_RXFE)) {
 		rx = readl(port->membase + UART_DR);
 		flg = TTY_NORMAL;
@@ -235,6 +240,12 @@ static void netx_rxint(struct uart_port
 			continue;
 
 		uart_insert_char(port, status, SR_OE, rx, flg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tty_flip_buffer_push(tty);
@@ -250,6 +261,11 @@ static irqreturn_t netx_int(int irq, voi
 	spin_lock_irqsave(&port->lock,flags);
 
 	status = readl(port->membase + UART_IIR) & IIR_MASK;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status) {
 		if (status & IIR_RIS)
 			netx_rxint(port);
@@ -263,6 +279,12 @@ static irqreturn_t netx_int(int irq, voi
 		}
 		writel(0, port->membase + UART_IIR);
 		status = readl(port->membase + UART_IIR) & IIR_MASK;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	spin_unlock_irqrestore(&port->lock,flags);
diff -u -p a/tty/serial/altera_jtaguart.c b/tty/serial/altera_jtaguart.c
--- a/tty/serial/altera_jtaguart.c
+++ b/tty/serial/altera_jtaguart.c
@@ -128,6 +128,11 @@ static void altera_jtaguart_rx_chars(str
 	unsigned char ch, flag;
 	unsigned long status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = readl(port->membase + ALTERA_JTAGUART_DATA_REG)) &
 	       ALTERA_JTAGUART_DATA_RVALID_MSK) {
 		ch = status & ALTERA_JTAGUART_DATA_DATA_MSK;
@@ -137,6 +142,12 @@ static void altera_jtaguart_rx_chars(str
 		if (uart_handle_sysrq_char(port, ch))
 			continue;
 		uart_insert_char(port, 0, 0, ch, flag);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tty_flip_buffer_push(port->state->port.tty);
diff -u -p a/tty/serial/nwpserial.c b/tty/serial/nwpserial.c
--- a/tty/serial/nwpserial.c
+++ b/tty/serial/nwpserial.c
@@ -270,9 +270,20 @@ static void nwpserial_start_tx(struct ua
 		port->x_char = 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(uart_circ_empty(xmit) || uart_tx_stopped(&up->port))) {
 		nwpserial_putchar(up, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE-1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/serial/icom.c b/tty/serial/icom.c
--- a/tty/serial/icom.c
+++ b/tty/serial/icom.c
@@ -745,6 +745,11 @@ static void recv_interrupt(u16 port_int_
 	rcv_buff = icom_port->next_rcv;
 
 	status = cpu_to_le16(icom_port->statStg->rcv[rcv_buff].flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & SA_FL_RCV_DONE) {
 		int first = -1;
 
@@ -833,6 +838,12 @@ ignore_char:
 			rcv_buff = 0;
 
 		status = cpu_to_le16(icom_port->statStg->rcv[rcv_buff].flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	icom_port->next_rcv = rcv_buff;
 	tty_flip_buffer_push(tty);
diff -u -p a/tty/serial/68328serial.c b/tty/serial/68328serial.c
--- a/tty/serial/68328serial.c
+++ b/tty/serial/68328serial.c
@@ -693,6 +693,11 @@ static int rs_write(struct tty_struct *
 		/* Enable transmitter */
 		local_irq_disable();		
 #ifndef USE_INTS
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(info->xmit_cnt) {
 #endif
 
@@ -709,7 +714,13 @@ static int rs_write(struct tty_struct *
 		}
 
 #ifndef USE_INTS
-		}
+if (_cur < timeout) {
+			rdstcll(_cur);
+}
+else {
+			break;
+}
+}
 #endif
 		local_irq_restore(flags);
 	}
diff -u -p a/tty/serial/crisv10.c b/tty/serial/crisv10.c
--- a/tty/serial/crisv10.c
+++ b/tty/serial/crisv10.c
@@ -2660,6 +2660,11 @@ ser_interrupt(int irq, void *dev_id)
 				 IO_MASK(R_IRQ_MASK1_RD, ser1_ready) |
 				 IO_MASK(R_IRQ_MASK1_RD, ser2_ready) |
 				 IO_MASK(R_IRQ_MASK1_RD, ser3_ready));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (irq_mask1_rd) {
 			/* Disable those we are about to handle */
 			*R_IRQ_MASK1_CLR = irq_mask1_rd;
@@ -2682,6 +2687,12 @@ ser_interrupt(int irq, void *dev_id)
 			local_irq_disable();
 			/* Handle reentered TX interrupt */
 			irq_mask1_rd = reentered_ready_mask;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		local_irq_disable();
 		tx_started = 0;
diff -u -p a/tty/serial/mpsc.c b/tty/serial/mpsc.c
--- a/tty/serial/mpsc.c
+++ b/tty/serial/mpsc.c
@@ -958,7 +958,12 @@ static int mpsc_rx_intr(struct mpsc_port
 	/*
 	 * Loop through Rx descriptors handling ones that have been completed.
 	 */
-	while (!((cmdstat = be32_to_cpu(rxre->cmdstat))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!((cmdstat = be32_to_cpu(rxre->cmdstat))
 				& SDMA_DESC_CMDSTAT_O)) {
 		bytes_in = be16_to_cpu(rxre->bytecnt);
 #ifdef CONFIG_CONSOLE_POLL
@@ -1075,6 +1080,12 @@ next_frame:
 					(ulong)rxre + MPSC_RXRE_SIZE);
 #endif
 		rc = 1;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/* Restart rx engine, if its stopped */
@@ -1115,7 +1126,12 @@ static void mpsc_copy_tx_data(struct mps
 	u32 i;
 
 	/* Make sure the desc ring isn't full */
-	while (CIRC_CNT(pi->txr_head, pi->txr_tail, MPSC_TXR_ENTRIES)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (CIRC_CNT(pi->txr_head, pi->txr_tail, MPSC_TXR_ENTRIES)
 			< (MPSC_TXR_ENTRIES - 1)) {
 		if (pi->port.x_char) {
 			/*
@@ -1157,6 +1173,12 @@ static void mpsc_copy_tx_data(struct mps
 
 		/* Advance to next descriptor */
 		pi->txr_head = (pi->txr_head + 1) & (MPSC_TXR_ENTRIES - 1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1704,11 +1726,22 @@ static void mpsc_console_write(struct co
 
 	spin_lock_irqsave(&pi->tx_lock, iflags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pi->txr_head != pi->txr_tail) {
 		while (mpsc_sdma_tx_active(pi))
 			udelay(100);
 		mpsc_sdma_intr_ack(pi);
 		mpsc_tx_intr(pi);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	while (mpsc_sdma_tx_active(pi))
diff -u -p a/tty/serial/cpm_uart/cpm_uart_core.c b/tty/serial/cpm_uart/cpm_uart_core.c
--- a/tty/serial/cpm_uart/cpm_uart_core.c
+++ b/tty/serial/cpm_uart/cpm_uart_core.c
@@ -457,9 +457,20 @@ static void cpm_uart_shutdown(struct uar
 	/* If the port is not the console, disable Rx and Tx. */
 	if (!(pinfo->flags & FLAG_CONSOLE)) {
 		/* Wait for all the BDs marked sent */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(!cpm_uart_tx_empty(port)) {
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			schedule_timeout(2);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (pinfo->wait_closing)
@@ -700,6 +711,11 @@ static int cpm_uart_tx_pump(struct uart_
 	/* Pick next descriptor and fill from buffer */
 	bdp = pinfo->tx_cur;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(in_be16(&bdp->cbd_sc) & BD_SC_READY) &&
 	       xmit->tail != xmit->head) {
 		count = 0;
@@ -719,6 +735,12 @@ static int cpm_uart_tx_pump(struct uart_
 			bdp = pinfo->tx_bd_base;
 		else
 			bdp++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	pinfo->tx_cur = bdp;
 
diff -u -p a/tty/serial/msm_serial.c b/tty/serial/msm_serial.c
--- a/tty/serial/msm_serial.c
+++ b/tty/serial/msm_serial.c
@@ -160,6 +160,11 @@ static void handle_rx(struct uart_port *
 	}
 
 	/* and now the main RX loop */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((sr = msm_read(port, UART_SR)) & UART_SR_RX_READY) {
 		unsigned int c;
 		char flag = TTY_NORMAL;
@@ -187,6 +192,12 @@ static void handle_rx(struct uart_port *
 
 		if (!uart_handle_sysrq_char(port, c))
 			tty_insert_flip_char(tty, c, flag);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	tty_flip_buffer_push(tty);
diff -u -p a/tty/serial/ucc_uart.c b/tty/serial/ucc_uart.c
--- a/tty/serial/ucc_uart.c
+++ b/tty/serial/ucc_uart.c
@@ -256,6 +256,11 @@ static unsigned int qe_uart_tx_empty(str
 		container_of(port, struct uart_qe_port, port);
 	struct qe_bd *bdp = qe_port->tx_bd_base;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (in_be16(&bdp->status) & BD_SC_READY)
 			/* This BD is not done, so return "not done" */
@@ -269,6 +274,12 @@ static unsigned int qe_uart_tx_empty(str
 			return 1;
 
 		bdp++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	};
 }
 
@@ -364,6 +375,11 @@ static int qe_uart_tx_pump(struct uart_q
 	/* Pick next descriptor and fill from buffer */
 	bdp = qe_port->tx_cur;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(in_be16(&bdp->status) & BD_SC_READY) &&
 	       (xmit->tail != xmit->head)) {
 		count = 0;
@@ -385,6 +401,12 @@ static int qe_uart_tx_pump(struct uart_q
 			bdp = qe_port->tx_bd_base;
 		else
 			bdp++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	qe_port->tx_cur = bdp;
 
diff -u -p a/tty/serial/mpc52xx_uart.c b/tty/serial/mpc52xx_uart.c
--- a/tty/serial/mpc52xx_uart.c
+++ b/tty/serial/mpc52xx_uart.c
@@ -941,6 +941,11 @@ mpc52xx_uart_int_rx_chars(struct uart_po
 	unsigned short status;
 
 	/* While we can read, do so ! */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (psc_ops->raw_rx_rdy(port)) {
 		/* Get the char */
 		ch = psc_ops->read_char(port);
@@ -991,6 +996,12 @@ mpc52xx_uart_int_rx_chars(struct uart_po
 			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
 			port->icount.overrun++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock(&port->lock);
diff -u -p a/tty/serial/sunzilog.c b/tty/serial/sunzilog.c
--- a/tty/serial/sunzilog.c
+++ b/tty/serial/sunzilog.c
@@ -535,7 +535,12 @@ static irqreturn_t sunzilog_interrupt(in
 {
 	struct uart_sunzilog_port *up = dev_id;
 
-	while (up) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (up) {
 		struct zilog_channel __iomem *channel
 			= ZILOG_CHANNEL_FROM_PORT(&up->port);
 		struct tty_struct *tty;
@@ -587,6 +592,12 @@ static irqreturn_t sunzilog_interrupt(in
 			tty_flip_buffer_push(tty);
 
 		up = up->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return IRQ_HANDLED;
@@ -1588,6 +1599,11 @@ static int __init sunzilog_init(void)
 			goto out_unregister_driver;
 
 		/* Enable Interrupts */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (up) {
 			struct zilog_channel __iomem *channel;
 
@@ -1597,6 +1613,12 @@ static int __init sunzilog_init(void)
 			up->curregs[R9] |= MIE;
 			write_zsreg(channel, R9, up->curregs[R9]);
 			up = up->next;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -1625,6 +1647,11 @@ static void __exit sunzilog_exit(void)
 		struct uart_sunzilog_port *up = sunzilog_irq_chain;
 
 		/* Disable Interrupts */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (up) {
 			struct zilog_channel __iomem *channel;
 
@@ -1634,6 +1661,12 @@ static void __exit sunzilog_exit(void)
 			up->curregs[R9] &= ~MIE;
 			write_zsreg(channel, R9, up->curregs[R9]);
 			up = up->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		free_irq(zilog_irq, sunzilog_irq_chain);
diff -u -p a/tty/serial/bfin_sport_uart.c b/tty/serial/bfin_sport_uart.c
--- a/tty/serial/bfin_sport_uart.c
+++ b/tty/serial/bfin_sport_uart.c
@@ -154,12 +154,23 @@ static irqreturn_t sport_uart_rx_irq(int
 
 	spin_lock(&up->port.lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (SPORT_GET_STAT(up) & RXNE) {
 		ch = rx_one_byte(up);
 		up->port.icount.rx++;
 
 		if (!uart_handle_sysrq_char(&up->port, ch))
 			tty_insert_flip_char(tty, ch, TTY_NORMAL);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	tty_flip_buffer_push(tty);
 
@@ -343,10 +354,21 @@ static int sport_uart_tx_chars(struct sp
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(!(SPORT_GET_STAT(up) & TXF) && !uart_circ_empty(xmit)) {
 		tx_one_byte(up, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE -1);
 		up->port.icount.tx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
diff -u -p a/tty/n_r3964.c b/tty/n_r3964.c
--- a/tty/n_r3964.c
+++ b/tty/n_r3964.c
@@ -763,6 +763,11 @@ static int enable_signals(struct r3964_i
 				TRACE_PS("removing client %d from client list",
 					 pid_nr(pid));
 				*ppClient = pClient->next;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (pClient->msg_count) {
 					pMsg = remove_msg(pInfo, pClient);
 					if (pMsg) {
@@ -770,6 +775,12 @@ static int enable_signals(struct r3964_i
 						TRACE_M("enable_signals - msg "
 							"kfree %p", pMsg);
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				put_pid(pClient->pid);
 				kfree(pClient);
@@ -1018,19 +1029,41 @@ static void r3964_close(struct tty_struc
 
 	/* Remove client-structs and message queues: */
 	pClient = pInfo->firstClient;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pClient) {
 		pNext = pClient->next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (pClient->msg_count) {
 			pMsg = remove_msg(pInfo, pClient);
 			if (pMsg) {
 				kfree(pMsg);
 				TRACE_M("r3964_close - msg kfree %p", pMsg);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		put_pid(pClient->pid);
 		kfree(pClient);
 		TRACE_M("r3964_close - client kfree %p", pClient);
 		pClient = pNext;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Remove jobs from tx_queue: */
 	spin_lock_irqsave(&pInfo->lock, flags);
@@ -1038,10 +1071,21 @@ static void r3964_close(struct tty_struc
 	pInfo->tx_first = pInfo->tx_last = NULL;
 	spin_unlock_irqrestore(&pInfo->lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pHeader) {
 		pNextHeader = pHeader->next;
 		kfree(pHeader);
 		pHeader = pNextHeader;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Free buffers: */
diff -u -p a/tty/tty_ldisc.c b/tty/tty_ldisc.c
--- a/tty/tty_ldisc.c
+++ b/tty/tty_ldisc.c
@@ -622,13 +622,24 @@ int tty_set_ldisc(struct tty_struct *tty
 	 *	dropped the lock during processing. If so we need to wait.
 	 */
 
-	while (test_bit(TTY_LDISC_CHANGING, &tty->flags)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (test_bit(TTY_LDISC_CHANGING, &tty->flags)) {
 		mutex_unlock(&tty->ldisc_mutex);
 		tty_unlock();
 		wait_event(tty_ldisc_wait,
 			test_bit(TTY_LDISC_CHANGING, &tty->flags) == 0);
 		tty_lock();
 		mutex_lock(&tty->ldisc_mutex);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	set_bit(TTY_LDISC_CHANGING, &tty->flags);
diff -u -p a/tty/synclink.c b/tty/synclink.c
--- a/tty/synclink.c
+++ b/tty/synclink.c
@@ -1459,7 +1459,12 @@ static void mgsl_isr_receive_data( struc
 
 	/* flush the receive FIFO */
 
-	while( (Fifocount = (usc_InReg(info,RICR) >> 8)) ) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while( (Fifocount = (usc_InReg(info,RICR) >> 8)) ) {
 		int flag;
 
 		/* read one byte from RxFIFO */
@@ -1517,6 +1522,12 @@ static void mgsl_isr_receive_data( struc
 			 */
 			work += tty_insert_flip_char(tty, 0, TTY_OVERRUN);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if ( debug_level >= DEBUG_LEVEL_ISR ) {
@@ -3556,9 +3567,20 @@ static int mgsl_proc_show(struct seq_fil
 	seq_printf(m, "synclink driver:%s\n", driver_version);
 	
 	info = mgsl_device_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -4412,6 +4434,11 @@ static void synclink_cleanup(void)
 	}
 
 	info = mgsl_device_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(info) {
 #if SYNCLINK_GENERIC_HDLC
 		hdlcdev_exit(info);
@@ -4420,6 +4447,12 @@ static void synclink_cleanup(void)
 		tmp = info;
 		info = info->next_device;
 		kfree(tmp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	if (pci_registered)
@@ -5712,6 +5745,11 @@ static void usc_load_txfifo( struct mgsl
 
 	/* load the Transmit FIFO until FIFOs full or all data sent */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( (Fifocount = usc_InReg(info, TICR) >> 8) && info->xmit_cnt ) {
 		/* there is more space in the transmit FIFO and */
 		/* there is more data in transmit buffer */
@@ -5745,6 +5783,12 @@ static void usc_load_txfifo( struct mgsl
 			}
 			info->icount.tx++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }	/* end of usc_load_txfifo() */
@@ -6480,6 +6524,11 @@ static void mgsl_free_rx_frame_buffers(
 
 	Index = StartIndex;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( !Done ) {
 		pBufEntry = &(info->rx_buffer_list[Index]);
 
@@ -6497,6 +6546,12 @@ static void mgsl_free_rx_frame_buffers(
 		Index++;
 		if ( Index == info->rx_buffer_count )
 			Index = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* set current buffer to next buffer after last buffer of frame */
@@ -6532,6 +6587,11 @@ static bool mgsl_get_rx_frame(struct mgs
 
 	StartIndex = EndIndex = info->current_rx_buffer;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( !info->rx_buffer_list[EndIndex].status ) {
 		/*
 		 * If the count field of the buffer entry is non-zero then
@@ -6562,6 +6622,12 @@ static bool mgsl_get_rx_frame(struct mgs
 			}
 			goto Cleanup;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 
@@ -6630,7 +6696,12 @@ static bool mgsl_get_rx_frame(struct mgs
 			if ( !(status & RXSTATUS_CRC_ERROR))
 			info->icount.rxok++;
 			
-			while(copy_count) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while(copy_count) {
 				int partial_count;
 				if ( copy_count > DMABUFFERSIZE )
 					partial_count = DMABUFFERSIZE;
@@ -6644,6 +6715,12 @@ static bool mgsl_get_rx_frame(struct mgs
 				
 				if ( ++index == info->rx_buffer_count )
 					index = 0;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+				}
 			}
 
 			if ( info->params.crc_type & HDLC_CRC_RETURN_EX ) {
@@ -6909,6 +6986,11 @@ static void mgsl_load_tx_dma_buffer(stru
 	/* Copy frame data from 1st source buffer to the DMA buffers. */
 	/* The frame data may span multiple DMA buffers. */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( BufferSize ){
 		/* Get a pointer to next DMA buffer entry. */
 		pBufEntry = &info->tx_buffer_list[i++];
@@ -6937,6 +7019,12 @@ static void mgsl_load_tx_dma_buffer(stru
 		BufferSize -= Copycount;
 
 		++info->tx_dma_buffers_used;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* remember next available tx dma buffer */
@@ -7506,7 +7594,12 @@ static void mgsl_trace_block(struct mgsl
 	else
 		printk("%s rx data:\n",info->device_name);
 		
-	while(count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(count) {
 		if (count > 16)
 			linecount = 16;
 		else
@@ -7526,6 +7619,12 @@ static void mgsl_trace_block(struct mgsl
 		
 		data  += linecount;
 		count -= linecount;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }	/* end of mgsl_trace_block() */
 
diff -u -p a/tty/synclink_gt.c b/tty/synclink_gt.c
--- a/tty/synclink_gt.c
+++ b/tty/synclink_gt.c
@@ -556,6 +556,11 @@ static void trace_block(struct slgt_info
 	int i;
 	int linecount;
 	printk("%s %s data:\n",info->device_name, label);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(count) {
 		linecount = (count > 16) ? 16 : count;
 		for(i=0; i < linecount; i++)
@@ -571,6 +576,12 @@ static void trace_block(struct slgt_info
 		printk("\n");
 		data  += linecount;
 		count -= linecount;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 #else
@@ -1326,9 +1337,20 @@ static int synclink_gt_proc_show(struct
 	seq_puts(m, "synclink_gt driver\n");
 
 	info = slgt_device_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1966,6 +1988,11 @@ static void bh_handler(struct work_struc
 		return;
 	info->bh_running = true;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while((action = bh_action(info))) {
 		switch (action) {
 		case BH_RECEIVE:
@@ -2002,6 +2029,12 @@ static void bh_handler(struct work_struc
 			DBGBH(("%s unknown action\n", info->device_name));
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	DBGBH(("%s bh_handler exit\n", info->device_name));
 }
@@ -2133,6 +2166,11 @@ static void isr_rxdata(struct slgt_info
 	unsigned int i = info->rbuf_fill_index;
 	unsigned short reg;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rd_reg16(info, SSR) & IRQ_RXDATA) {
 		reg = rd_reg16(info, RDR);
 		DBGISR(("isr_rxdata %s RDR=%04X\n", info->device_name, reg));
@@ -2155,6 +2193,12 @@ static void isr_rxdata(struct slgt_info
 				i = 0;
 			info->pending_bh |= BH_RECEIVE;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	info->rbuf_fill_index = i;
@@ -2380,6 +2424,11 @@ static irqreturn_t slgt_interrupt(int du
 
 	DBGISR(("slgt_interrupt irq=%d entry\n", info->irq_level));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while((gsr = rd_reg32(info, GSR) & 0xffffff00)) {
 		DBGISR(("%s gsr=%08x\n", info->device_name, gsr));
 		info->irq_occurred = true;
@@ -2395,6 +2444,12 @@ static irqreturn_t slgt_interrupt(int du
 				isr_tdma(info->port_array[i]);
 			spin_unlock(&info->port_array[i]->lock);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (info->gpio_present) {
@@ -3754,13 +3809,29 @@ static void slgt_cleanup(void)
 
 	/* reset devices */
 	info = slgt_device_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(info) {
 		reset_port(info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* release devices */
 	info = slgt_device_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(info) {
 #if SYNCLINK_GENERIC_HDLC
 		hdlcdev_exit(info);
@@ -3772,6 +3843,12 @@ static void slgt_cleanup(void)
 		tmp = info;
 		info = info->next_device;
 		kfree(tmp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (pci_registered)
@@ -4612,6 +4689,11 @@ static void free_rbufs(struct slgt_info
 {
 	int done = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(!done) {
 		/* reset current buffer for reuse */
 		info->rbufs[i].status = 0;
@@ -4620,6 +4702,12 @@ static void free_rbufs(struct slgt_info
 			done = 1;
 		if (++i == info->rbuf_count)
 			i = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	info->rbuf_current = i;
 }
@@ -4743,6 +4831,11 @@ check_again:
 
 			info->icount.rxok++;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(copy_count) {
 				int partial_count = min_t(int, copy_count, info->rbuf_fill_level);
 				memcpy(p, info->rbufs[i].buf, partial_count);
@@ -4750,6 +4843,12 @@ check_again:
 				copy_count -= partial_count;
 				if (++i == info->rbuf_count)
 					i = 0;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+				else {
+					break;
+				}
 			}
 
 			if (info->params.crc_type & HDLC_CRC_RETURN_EX) {
@@ -4915,6 +5014,11 @@ static bool tx_load(struct slgt_info *in
 
 	info->tbuf_start = i = info->tbuf_current;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		d = &info->tbufs[i];
 
@@ -4941,6 +5045,12 @@ static bool tx_load(struct slgt_info *in
 
 		if (++i == info->tbuf_count)
 			i = 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	info->tbuf_current = i;
diff -u -p a/usb/atm/ueagle-atm.c b/usb/atm/ueagle-atm.c
--- a/usb/atm/ueagle-atm.c
+++ b/usb/atm/ueagle-atm.c
@@ -1909,6 +1909,11 @@ static int uea_kthread(void *data)
 
 	set_freezable();
 	uea_enters(INS_TO_USBDEV(sc));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		if (ret < 0 || sc->reset)
 			ret = uea_start_reset(sc);
@@ -1917,6 +1922,12 @@ static int uea_kthread(void *data)
 		if (ret != -EAGAIN)
 			uea_wait(sc, 0, msecs_to_jiffies(1000));
 		try_to_freeze();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	uea_leaves(INS_TO_USBDEV(sc));
 	return ret;
diff -u -p a/usb/atm/cxacru.c b/usb/atm/cxacru.c
--- a/usb/atm/cxacru.c
+++ b/usb/atm/cxacru.c
@@ -465,6 +465,11 @@ static ssize_t cxacru_sysfs_store_adsl_c
 
 	pos = 0;
 	num = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos < len) {
 		int tmp;
 		u32 index;
@@ -507,6 +512,12 @@ static ssize_t cxacru_sysfs_store_adsl_c
 			atm_info(instance->usbatm, "config%s\n", log);
 			num = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return len;
diff -u -p a/usb/atm/usbatm.c b/usb/atm/usbatm.c
--- a/usb/atm/usbatm.c
+++ b/usb/atm/usbatm.c
@@ -533,6 +533,11 @@ static void usbatm_rx_process(unsigned l
 	struct usbatm_data *instance = (struct usbatm_data *)data;
 	struct urb *urb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((urb = usbatm_pop_urb(&instance->rx_channel))) {
 		vdbg("%s: processing urb 0x%p", __func__, urb);
 
@@ -574,6 +579,12 @@ static void usbatm_rx_process(unsigned l
 
 		if (usbatm_submit_urb(urb))
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/usb/mon/mon_text.c b/usb/mon/mon_text.c
--- a/usb/mon/mon_text.c
+++ b/usb/mon/mon_text.c
@@ -630,12 +630,23 @@ static int mon_text_release(struct inode
 	 * So, we better not touch mbus.
 	 */
 	/* spin_lock_irqsave(&mbus->lock, flags); */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rp->e_list)) {
 		p = rp->e_list.next;
 		ep = list_entry(p, struct mon_event_text, e_link);
 		list_del(p);
 		--rp->nevents;
 		kmem_cache_free(rp->e_slab, ep);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* spin_unlock_irqrestore(&mbus->lock, flags); */
 
diff -u -p a/usb/mon/mon_bin.c b/usb/mon/mon_bin.c
--- a/usb/mon/mon_bin.c
+++ b/usb/mon/mon_bin.c
@@ -230,6 +230,11 @@ static unsigned int mon_copy_to_buff(con
 	unsigned char *buf;
 	unsigned int in_page;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (length) {
 		/*
 		 * Determine step_len.
@@ -247,6 +252,12 @@ static unsigned int mon_copy_to_buff(con
 		if ((off += step_len) >= this->b_size) off = 0;
 		from += step_len;
 		length -= step_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return off;
 }
@@ -262,6 +273,11 @@ static int copy_from_buf(const struct mo
 	unsigned char *buf;
 	unsigned int in_page;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (length) {
 		/*
 		 * Determine step_len.
@@ -280,6 +296,12 @@ static int copy_from_buf(const struct mo
 		if ((off += step_len) >= this->b_size) off = 0;
 		to += step_len;
 		length -= step_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -960,6 +982,11 @@ static int mon_bin_queued(struct mon_rea
 	cur_out = rp->b_out;
 	nevents = 0;
 	bytes = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bytes < avail) {
 		ep = MON_OFF2HDR(rp, cur_out);
 
@@ -969,6 +996,12 @@ static int mon_bin_queued(struct mon_rea
 		if ((cur_out += size) >= rp->b_size)
 			cur_out -= rp->b_size;
 		bytes += size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&rp->fetch_lock);
@@ -1277,6 +1310,11 @@ static int mon_bin_wait_event(struct fil
 	set_current_state(TASK_INTERRUPTIBLE);
 
 	spin_lock_irqsave(&rp->b_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (MON_RING_EMPTY(rp)) {
 		spin_unlock_irqrestore(&rp->b_lock, flags);
 
@@ -1293,6 +1331,12 @@ static int mon_bin_wait_event(struct fil
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		spin_lock_irqsave(&rp->b_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&rp->b_lock, flags);
 
diff -u -p a/usb/mon/mon_main.c b/usb/mon/mon_main.c
--- a/usb/mon/mon_main.c
+++ b/usb/mon/mon_main.c
@@ -387,6 +387,11 @@ static void __exit mon_exit(void)
 
 	mutex_lock(&mon_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&mon_buses)) {
 		p = mon_buses.next;
 		mbus = list_entry(p, struct mon_bus, bus_link);
@@ -411,6 +416,12 @@ static void __exit mon_exit(void)
 
 		mon_dissolve(mbus, mbus->u_bus);
 		kref_put(&mbus->ref, mon_bus_drop);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mbus = &mon_bus0;
diff -u -p a/usb/core/devices.c b/usb/core/devices.c
--- a/usb/core/devices.c
+++ b/usb/core/devices.c
@@ -453,9 +453,20 @@ static char *usb_dump_hub_descriptor(cha
 	if (start > end)
 		return start;
 	start += sprintf(start, "Interface:");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (leng && start <= end) {
 		start += sprintf(start, " %02x", *ptr);
 		ptr++; leng--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*start++ = '\n';
 	return start;
diff -u -p a/usb/core/devio.c b/usb/core/devio.c
--- a/usb/core/devio.c
+++ b/usb/core/devio.c
@@ -440,6 +440,11 @@ static void destroy_async(struct dev_sta
 	unsigned long flags;
 
 	spin_lock_irqsave(&ps->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(list)) {
 		as = list_entry(list->next, struct async, asynclist);
 		list_del_init(&as->asynclist);
@@ -451,6 +456,12 @@ static void destroy_async(struct dev_sta
 		usb_kill_urb(urb);
 		usb_put_urb(urb);
 		spin_lock_irqsave(&ps->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&ps->lock, flags);
 }
@@ -790,9 +801,20 @@ static int usbdev_release(struct inode *
 	put_cred(ps->cred);
 
 	as = async_getcompleted(ps);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (as) {
 		free_async(as);
 		as = async_getcompleted(ps);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(ps);
 	return 0;
@@ -2025,6 +2047,11 @@ static void usbdev_remove(struct usb_dev
 	struct dev_state *ps;
 	struct siginfo sinfo;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&udev->filelist)) {
 		ps = list_entry(udev->filelist.next, struct dev_state, list);
 		destroy_all_async(ps);
@@ -2038,6 +2065,12 @@ static void usbdev_remove(struct usb_dev
 			kill_pid_info_as_cred(ps->discsignr, &sinfo,
 					ps->disc_pid, ps->cred, ps->secid);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/core/hcd.c b/usb/core/hcd.c
--- a/usb/core/hcd.c
+++ b/usb/core/hcd.c
@@ -1671,6 +1671,11 @@ rescan:
 	spin_unlock_irq(&hcd_urb_list_lock);
 
 	/* Wait until the endpoint queue is completely empty */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty (&ep->urb_list)) {
 		spin_lock_irq(&hcd_urb_list_lock);
 
@@ -1687,6 +1692,12 @@ rescan:
 			usb_kill_urb (urb);
 			usb_put_urb (urb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/core/urb.c b/usb/core/urb.c
--- a/usb/core/urb.c
+++ b/usb/core/urb.c
@@ -685,7 +685,12 @@ void usb_kill_anchored_urbs(struct usb_a
 	struct urb *victim;
 
 	spin_lock_irq(&anchor->lock);
-	while (!list_empty(&anchor->urb_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
 		/* we must make sure the URB isn't freed before we kill it*/
@@ -695,6 +700,12 @@ void usb_kill_anchored_urbs(struct usb_a
 		usb_kill_urb(victim);
 		usb_put_urb(victim);
 		spin_lock_irq(&anchor->lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irq(&anchor->lock);
 }
@@ -718,7 +729,12 @@ void usb_poison_anchored_urbs(struct usb
 
 	spin_lock_irq(&anchor->lock);
 	anchor->poisoned = 1;
-	while (!list_empty(&anchor->urb_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
 		/* we must make sure the URB isn't freed before we kill it*/
@@ -728,6 +744,12 @@ void usb_poison_anchored_urbs(struct usb
 		usb_poison_urb(victim);
 		usb_put_urb(victim);
 		spin_lock_irq(&anchor->lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irq(&anchor->lock);
 }
@@ -832,10 +854,21 @@ void usb_scuttle_anchored_urbs(struct us
 	unsigned long flags;
 
 	spin_lock_irqsave(&anchor->lock, flags);
-	while (!list_empty(&anchor->urb_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
 		__usb_unanchor_urb(victim, anchor);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irqrestore(&anchor->lock, flags);
 }
diff -u -p a/usb/core/usb.c b/usb/core/usb.c
--- a/usb/core/usb.c
+++ b/usb/core/usb.c
@@ -578,6 +578,11 @@ int usb_lock_device_for_reset(struct usb
 			iface->condition == USB_INTERFACE_UNBOUND))
 		return -EINTR;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!usb_trylock_device(udev)) {
 
 		/* If we can't acquire the lock after waiting one second,
@@ -593,6 +598,12 @@ int usb_lock_device_for_reset(struct usb
 		if (iface && (iface->condition == USB_INTERFACE_UNBINDING ||
 				iface->condition == USB_INTERFACE_UNBOUND))
 			return -EINTR;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	return 0;
 }
diff -u -p a/usb/core/message.c b/usb/core/message.c
--- a/usb/core/message.c
+++ b/usb/core/message.c
@@ -509,6 +509,11 @@ void usb_sg_wait(struct usb_sg_request *
 	/* queue the urbs.  */
 	spin_lock_irq(&io->lock);
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < entries && !io->status) {
 		int retval;
 
@@ -549,6 +554,12 @@ void usb_sg_wait(struct usb_sg_request *
 		spin_lock_irq(&io->lock);
 		if (retval && (io->status == 0 || io->status == -ECONNRESET))
 			io->status = retval;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	io->count -= entries - i;
 	if (io->count == 0)
diff -u -p a/usb/dwc3/gadget.c b/usb/dwc3/gadget.c
--- a/usb/dwc3/gadget.c
+++ b/usb/dwc3/gadget.c
@@ -377,10 +377,21 @@ static void dwc3_remove_requests(struct
 	if (!list_empty(&dep->req_queued))
 		dwc3_stop_active_transfer(dwc, dep->number);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&dep->request_list)) {
 		req = next_request(&dep->request_list);
 
 		dwc3_gadget_giveback(dep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/host/whci/qset.c b/usb/host/whci/qset.c
--- a/usb/host/whci/qset.c
+++ b/usb/host/whci/qset.c
@@ -273,6 +273,11 @@ static void qset_copy_bounce_to_sg(struc
 	sg = std->bounce_sg;
 	offset = std->bounce_offset;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (remaining) {
 		size_t len;
 
@@ -287,6 +292,12 @@ static void qset_copy_bounce_to_sg(struc
 			sg = sg_next(sg);
 			offset = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -456,6 +467,11 @@ static int qset_add_urb_sg(struct whc *w
 		dma_addr = sg_dma_address(sg);
 		dma_remaining = min_t(size_t, sg_dma_len(sg), remaining);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (dma_remaining) {
 			size_t dma_len;
 
@@ -521,6 +537,12 @@ static int qset_add_urb_sg(struct whc *w
 			prev_end = dma_addr = ep;
 			dma_remaining -= dma_len;
 			remaining -= dma_len;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -573,6 +595,11 @@ static int qset_add_urb_sg_linearize(str
 		sg_remaining = min_t(size_t, remaining, sg->length);
 		orig = sg_virt(sg);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sg_remaining) {
 			if (!std || std->len == max_std_len) {
 				std = qset_new_std(whc, qset, urb, mem_flags);
@@ -599,6 +626,12 @@ static int qset_add_urb_sg_linearize(str
 			orig += len;
 			sg_remaining -= len;
 			remaining -= len;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -661,6 +694,11 @@ int qset_add_urb(struct whc *whc, struct
 	if (ntds_remaining == 0)
 		ntds_remaining = 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ntds_remaining) {
 		struct whc_std *std;
 		size_t std_len;
@@ -683,6 +721,12 @@ int qset_add_urb(struct whc *whc, struct
 		ntds_remaining--;
 		remaining -= std_len;
 		transfer_dma += std_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/usb/host/uhci-q.c b/usb/host/uhci-q.c
--- a/usb/host/uhci-q.c
+++ b/usb/host/uhci-q.c
@@ -1155,12 +1155,23 @@ static int uhci_fixup_short_transfer(str
 	}
 
 	/* Remove all the TDs we skipped over, from tmp back to the start */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmp != &urbp->td_list) {
 		td = list_entry(tmp, struct uhci_td, list);
 		tmp = tmp->prev;
 
 		uhci_remove_td_from_urbp(td);
 		uhci_free_td(uhci, td);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return ret;
 }
@@ -1759,7 +1770,12 @@ rescan:
 	for (i = 0; i < UHCI_NUM_SKELQH - 1; ++i) {
 		uhci->next_qh = list_entry(uhci->skelqh[i]->node.next,
 				struct uhci_qh, node);
-		while ((qh = uhci->next_qh) != uhci->skelqh[i]) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((qh = uhci->next_qh) != uhci->skelqh[i]) {
 			uhci->next_qh = list_entry(qh->node.next,
 					struct uhci_qh, node);
 
@@ -1770,6 +1786,12 @@ rescan:
 	list_entry(qh->queue.next, struct urb_priv, node));
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/usb/host/xhci-ring.c b/usb/host/xhci-ring.c
--- a/usb/host/xhci-ring.c
+++ b/usb/host/xhci-ring.c
@@ -270,9 +270,20 @@ static int room_on_ring(struct xhci_hcd
 
 	/* If we are currently pointing to a link TRB, advance the
 	 * enqueue pointer before checking for space */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (last_trb(xhci, ring, enq_seg, enq)) {
 		enq_seg = enq_seg->next;
 		enq = enq_seg->trbs;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Check if ring is empty */
@@ -298,9 +309,20 @@ static int room_on_ring(struct xhci_hcd
 		if (enq == ring->dequeue)
 			return 0;
 		enq++;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (last_trb(xhci, ring, enq_seg, enq)) {
 			enq_seg = enq_seg->next;
 			enq = enq_seg->trbs;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 	return 1;
@@ -489,7 +511,12 @@ static struct xhci_segment *find_trb_seg
 	struct xhci_segment *cur_seg = start_seg;
 	struct xhci_generic_trb *generic_trb;
 
-	while (cur_seg->trbs > trb ||
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cur_seg->trbs > trb ||
 			&cur_seg->trbs[TRBS_PER_SEGMENT - 1] < trb) {
 		generic_trb = &cur_seg->trbs[TRBS_PER_SEGMENT - 1].generic;
 		if (generic_trb->field[3] & cpu_to_le32(LINK_TOGGLE))
@@ -498,6 +525,12 @@ static struct xhci_segment *find_trb_seg
 		if (cur_seg == start_seg)
 			/* Looped over the entire list.  Oops! */
 			return NULL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return cur_seg;
 }
@@ -601,7 +634,12 @@ void xhci_find_new_dequeue_state(struct
 	/* Find virtual address and segment of hardware dequeue pointer */
 	state->new_deq_seg = ep_ring->deq_seg;
 	state->new_deq_ptr = ep_ring->dequeue;
-	while (xhci_trb_virt_to_dma(state->new_deq_seg, state->new_deq_ptr)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (xhci_trb_virt_to_dma(state->new_deq_seg, state->new_deq_ptr)
 			!= (dma_addr_t)(hw_dequeue & ~0xf)) {
 		next_trb(xhci, ep_ring, &state->new_deq_seg,
 					&state->new_deq_ptr);
@@ -609,6 +647,12 @@ void xhci_find_new_dequeue_state(struct
 			WARN_ON(1);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * Find cycle state for last_trb, starting at old cycle state of
@@ -1008,7 +1052,12 @@ void xhci_stop_endpoint_command_watchdog
 				continue;
 			xhci_dbg(xhci, "Killing URBs for slot ID %u, "
 					"ep index %u\n", i, j);
-			while (!list_empty(&ring->td_list)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&ring->td_list)) {
 				cur_td = list_first_entry(&ring->td_list,
 						struct xhci_td,
 						td_list);
@@ -1017,8 +1066,19 @@ void xhci_stop_endpoint_command_watchdog
 					list_del_init(&cur_td->cancelled_td_list);
 				xhci_giveback_urb_in_irq(xhci, cur_td,
 						-ESHUTDOWN, "killed");
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
-			while (!list_empty(&temp_ep->cancelled_td_list)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&temp_ep->cancelled_td_list)) {
 				cur_td = list_first_entry(
 						&temp_ep->cancelled_td_list,
 						struct xhci_td,
@@ -1026,6 +1086,12 @@ void xhci_stop_endpoint_command_watchdog
 				list_del_init(&cur_td->cancelled_td_list);
 				xhci_giveback_urb_in_irq(xhci, cur_td,
 						-ESHUTDOWN, "killed");
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
@@ -2803,7 +2869,12 @@ static int prepare_ring(struct xhci_hcd
 
 		next = ring->enqueue;
 
-		while (last_trb(xhci, ring, ring->enq_seg, next)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+				while (last_trb(xhci, ring, ring->enq_seg, next)) {
 			/* If we're not dealing with 0.95 hardware or isoc rings
 			 * on AMD 0.96 host, clear the chain bit.
 			 */
@@ -2828,6 +2899,12 @@ static int prepare_ring(struct xhci_hcd
 			ring->enq_seg = ring->enq_seg->next;
 			ring->enqueue = ring->enq_seg->trbs;
 			next = ring->enqueue;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -2909,9 +2986,20 @@ static unsigned int count_sg_trbs_needed
 			num_trbs++;
 
 		/* How many more 64KB chunks to transfer, how many more TRBs? */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (running_total < sg_dma_len(sg) && running_total < temp) {
 			num_trbs++;
 			running_total += TRB_MAX_BUFF_SIZE;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		xhci_dbg(xhci, " sg #%d: dma = %#llx, len = %#x (%d), num_trbs = %d\n",
 				i, (unsigned long long)sg_dma_address(sg),
@@ -3255,9 +3343,20 @@ int xhci_queue_bulk_tx(struct xhci_hcd *
 	if (running_total != 0 || urb->transfer_buffer_length == 0)
 		num_trbs++;
 	/* How many more 64KB chunks to transfer, how many more TRBs? */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (running_total < urb->transfer_buffer_length) {
 		num_trbs++;
 		running_total += TRB_MAX_BUFF_SIZE;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* FIXME: this doesn't deal with URB_ZERO_PACKET - need one more */
 
diff -u -p a/usb/host/ohci-q.c b/usb/host/ohci-q.c
--- a/usb/host/ohci-q.c
+++ b/usb/host/ohci-q.c
@@ -261,9 +261,20 @@ static void periodic_unlink (struct ohci
 		struct ed	**prev = &ohci->periodic [i];
 		__hc32		*prev_p = &ohci->hcca->int_table [i];
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (*prev && (temp = *prev) != ed) {
 			prev_p = &temp->hwNextED;
 			prev = &temp->ed_next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (*prev) {
 			*prev_p = ed->hwNextED;
@@ -1128,6 +1139,11 @@ dl_done_list (struct ohci_hcd *ohci)
 {
 	struct td	*td = dl_reverse_done_list (ohci);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (td) {
 		struct td	*td_next = td->next_dl_td;
 		struct ed	*ed = td->ed;
@@ -1151,5 +1167,11 @@ dl_done_list (struct ohci_hcd *ohci)
 
 		takeback_td(ohci, td);
 		td = td_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
diff -u -p a/usb/host/ohci-dbg.c b/usb/host/ohci-dbg.c
--- a/usb/host/ohci-dbg.c
+++ b/usb/host/ohci-dbg.c
@@ -453,6 +453,11 @@ show_list (struct ohci_hcd *ohci, char *
 		ed = ed->ed_prev;
 
 	/* dump a snapshot of the bulk or control schedule */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ed) {
 		u32		info = hc32_to_cpu (ohci, ed->hwINFO);
 		u32		headp = hc32_to_cpu (ohci, ed->hwHeadP);
@@ -502,6 +507,12 @@ show_list (struct ohci_hcd *ohci, char *
 		buf += temp;
 
 		ed = ed->ed_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return count - size;
 }
diff -u -p a/usb/host/ehci-q.c b/usb/host/ehci-q.c
--- a/usb/host/ehci-q.c
+++ b/usb/host/ehci-q.c
@@ -1264,7 +1264,12 @@ static void scan_async (struct ehci_hcd
 	stopped = (ehci->rh_state != EHCI_RH_RUNNING);
 
 	ehci->qh_scan_next = ehci->async->qh_next.qh;
-	while (ehci->qh_scan_next) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+ timeout = rdstcll(start) + delta;
+ while (ehci->qh_scan_next) {
 		qh = ehci->qh_scan_next;
 		ehci->qh_scan_next = qh->qh_next.qh;
  rescan:
@@ -1303,6 +1308,12 @@ static void scan_async (struct ehci_hcd
 			else
 				action = TIMER_ASYNC_SHRINK;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (action == TIMER_ASYNC_SHRINK)
 		timer_action (ehci, TIMER_ASYNC_SHRINK);
diff -u -p a/usb/host/ohci-hcd.c b/usb/host/ohci-hcd.c
--- a/usb/host/ohci-hcd.c
+++ b/usb/host/ohci-hcd.c
@@ -523,13 +523,24 @@ static int ohci_init (struct ohci_hcd *o
 
 		ohci_writel (ohci, OHCI_INTR_OC, &ohci->regs->intrenable);
 		ohci_writel (ohci, OHCI_OCR, &ohci->regs->cmdstatus);
-		while (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {
 			msleep (10);
 			if (--temp == 0) {
 				ohci_err (ohci, "USB HC takeover failed!"
 					"  (BIOS/SMM bug)\n");
 				return -EBUSY;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		ohci_usb_reset (ohci);
 	}
diff -u -p a/usb/host/isp1760-hcd.c b/usb/host/isp1760-hcd.c
--- a/usb/host/isp1760-hcd.c
+++ b/usb/host/isp1760-hcd.c
@@ -945,6 +945,11 @@ void schedule_ptds(struct usb_hcd *hcd)
 	 * check finished/retired xfers, transfer payloads, call urb_done()
 	 */
 	ep_queue = &priv->interruptqhs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ep_queue) {
 		list_for_each_entry_safe(qh, qh_next, ep_queue, qh_list) {
 			ep = list_entry(qh->qtd_list.next, struct isp1760_qtd,
@@ -966,6 +971,12 @@ void schedule_ptds(struct usb_hcd *hcd)
 			ep_queue = &priv->bulkqhs;
 		else
 			ep_queue = NULL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	list_for_each_entry_safe(urb_listitem, urb_listitem_next, &urb_list,
@@ -999,6 +1010,11 @@ void schedule_ptds(struct usb_hcd *hcd)
 	 * I'm sure this scheme could be improved upon!
 	 */
 	ep_queue = &priv->controlqhs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ep_queue) {
 		list_for_each_entry_safe(qh, qh_next, ep_queue, qh_list)
 			enqueue_qtds(hcd, qh);
@@ -1009,6 +1025,12 @@ void schedule_ptds(struct usb_hcd *hcd)
 			ep_queue = &priv->bulkqhs;
 		else
 			ep_queue = NULL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1125,6 +1147,11 @@ static void handle_done_ptds(struct usb_
 
 	modified = priv->int_done_map || priv->atl_done_map;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (priv->int_done_map || priv->atl_done_map) {
 		if (priv->int_done_map) {
 			/* INT ptd */
@@ -1237,6 +1264,12 @@ static void handle_done_ptds(struct usb_
 			start_bus_transfer(hcd, ptd_offset, slot, slots, qtd,
 				qh, &ptd);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (modified)
diff -u -p a/usb/host/isp1362-hcd.c b/usb/host/isp1362-hcd.c
--- a/usb/host/isp1362-hcd.c
+++ b/usb/host/isp1362-hcd.c
@@ -2371,12 +2371,23 @@ static int isp1362_hc_reset(struct usb_h
 
 	/* chip has been reset. First we need to see a clock */
 	t = jiffies + msecs_to_jiffies(timeout);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!clkrdy && time_before_eq(jiffies, t)) {
 		spin_lock_irqsave(&isp1362_hcd->lock, flags);
 		clkrdy = isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_CLKRDY;
 		spin_unlock_irqrestore(&isp1362_hcd->lock, flags);
 		if (!clkrdy)
 			msleep(4);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	spin_lock_irqsave(&isp1362_hcd->lock, flags);
diff -u -p a/usb/host/ehci-sched.c b/usb/host/ehci-sched.c
--- a/usb/host/ehci-sched.c
+++ b/usb/host/ehci-sched.c
@@ -103,12 +103,23 @@ static void periodic_unlink (struct ehci
 	union ehci_shadow	here = *prev_p;
 
 	/* find predecessor of "ptr"; hw and shadow lists are in sync */
-	while (here.ptr && here.ptr != ptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (here.ptr && here.ptr != ptr) {
 		prev_p = periodic_next_shadow(ehci, prev_p,
 				Q_NEXT_TYPE(ehci, *hw_p));
 		hw_p = shadow_next_periodic(ehci, &here,
 				Q_NEXT_TYPE(ehci, *hw_p));
 		here = *prev_p;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* an interrupt entry (at list end) could have been shared */
 	if (!here.ptr)
@@ -138,6 +149,11 @@ periodic_usecs (struct ehci_hcd *ehci, u
 	unsigned		usecs = 0;
 	struct ehci_qh_hw	*hw;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->ptr) {
 		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
 		case Q_TYPE_QH:
@@ -191,7 +207,13 @@ periodic_usecs (struct ehci_hcd *ehci, u
 			q = &q->sitd->sitd_next;
 			break;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 #ifdef	DEBUG
 	if (usecs > ehci->uframe_periodic_max)
 		ehci_err (ehci, "uframe %d sched overrun: %d usecs\n",
@@ -274,6 +296,11 @@ periodic_tt_usecs (
 
 	memset(tt_usecs, 0, 16);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->ptr) {
 		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
 		case Q_TYPE_ITD:
@@ -303,6 +330,12 @@ periodic_tt_usecs (
 			hw_p = &q->fstn->hw_next;
 			q = &q->fstn->fstn_next;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	carryover_tt_bandwidth(tt_usecs);
@@ -424,6 +457,11 @@ static int tt_no_collision (
 
 		here = ehci->pshadow [frame];
 		type = Q_NEXT_TYPE(ehci, ehci->periodic [frame]);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (here.ptr) {
 			switch (hc32_to_cpu(ehci, type)) {
 			case Q_TYPE_ITD:
@@ -468,6 +506,12 @@ static int tt_no_collision (
 
 			/* collision or error */
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -1071,6 +1115,11 @@ iso_stream_put(struct ehci_hcd *ehci, st
 	if (stream->refcount == 1) {
 		// BUG_ON (!list_empty(&stream->td_list));
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!list_empty (&stream->free_list)) {
 			struct list_head	*entry;
 
@@ -1093,6 +1142,12 @@ iso_stream_put(struct ehci_hcd *ehci, st
 				dma_pool_free (ehci->sitd_pool, sitd,
 						sitd->sitd_dma);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		stream->bEndpointAddress &= 0x0f;
diff -u -p a/usb/host/uhci-debug.c b/usb/host/uhci-debug.c
--- a/usb/host/uhci-debug.c
+++ b/usb/host/uhci-debug.c
@@ -26,6 +26,11 @@ static void lprintk(char *buf)
 	char *p;
 
 	/* Just write one line at a time */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (buf) {
 		p = strchr(buf, '\n');
 		if (p)
@@ -34,6 +39,12 @@ static void lprintk(char *buf)
 		buf = p;
 		if (buf)
 			buf++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -457,6 +468,11 @@ check_link:
 		head = &qh->node;
 		tmp = head->next;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tmp != head) {
 			qh = list_entry(tmp, struct uhci_qh, node);
 			tmp = tmp->next;
@@ -465,6 +481,12 @@ check_link:
 						len - (out - buf), 4);
 			if (!fsbr_link && qh->skel >= SKEL_FSBR)
 				fsbr_link = LINK_TO_QH(uhci, qh);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		if ((cnt -= 10) > 0)
 			out += sprintf(out, "    Skipped %d QHs\n", cnt);
diff -u -p a/usb/host/xhci-mem.c b/usb/host/xhci-mem.c
--- a/usb/host/xhci-mem.c
+++ b/usb/host/xhci-mem.c
@@ -118,10 +118,21 @@ void xhci_ring_free(struct xhci_hcd *xhc
 		first_seg = ring->first_seg;
 		seg = first_seg->next;
 		xhci_dbg(xhci, "Freeing ring at %p\n", ring);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (seg != first_seg) {
 			struct xhci_segment *next = seg->next;
 			xhci_segment_free(xhci, seg);
 			seg = next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		xhci_segment_free(xhci, first_seg);
 		ring->first_seg = NULL;
@@ -180,10 +191,21 @@ static struct xhci_ring *xhci_ring_alloc
 		next = xhci_segment_alloc(xhci, flags);
 		if (!next) {
 			prev = ring->first_seg;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (prev) {
 				next = prev->next;
 				xhci_segment_free(xhci, prev);
 				prev = next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			goto fail;
 		}
diff -u -p a/usb/host/oxu210hp-hcd.c b/usb/host/oxu210hp-hcd.c
--- a/usb/host/oxu210hp-hcd.c
+++ b/usb/host/oxu210hp-hcd.c
@@ -1826,10 +1826,21 @@ static void periodic_unlink(struct oxu_h
 	union ehci_shadow here = *prev_p;
 
 	/* find predecessor of "ptr"; hw and shadow lists are in sync */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (here.ptr && here.ptr != ptr) {
 		prev_p = periodic_next_shadow(prev_p, Q_NEXT_TYPE(*hw_p));
 		hw_p = here.hw_next;
 		here = *prev_p;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* an interrupt entry (at list end) could have been shared */
 	if (!here.ptr)
@@ -1850,6 +1861,11 @@ static unsigned short periodic_usecs(str
 	union ehci_shadow *q = &oxu->pshadow[frame];
 	unsigned usecs = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->ptr) {
 		switch (Q_NEXT_TYPE(*hw_p)) {
 		case Q_TYPE_QH:
@@ -1864,7 +1880,13 @@ static unsigned short periodic_usecs(str
 			q = &q->qh->qh_next;
 			break;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 #ifdef DEBUG
 	if (usecs > 100)
 		oxu_err(oxu, "uframe %d sched overrun: %d usecs\n",
diff -u -p a/usb/host/ehci-pxa168.c b/usb/host/ehci-pxa168.c
--- a/usb/host/ehci-pxa168.c
+++ b/usb/host/ehci-pxa168.c
@@ -180,12 +180,23 @@ static int pxa168_usb_phy_init(struct pl
 	writel(reg_val, usb_phy_reg_base + USB_PHY_PLL_REG);
 
 	/* Make sure PHY PLL is ready */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(readl(usb_phy_reg_base + USB_PHY_PLL_REG) & PLL_READY)) {
 		if (!(pll_retry_cont--)) {
 			dev_dbg(&pdev->dev, "USB PHY PLL not ready\n");
 			err = -EIO;
 			goto err2;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Toggle VCOCAL_START bit of U2PLL for PLL calibration */
@@ -206,12 +217,23 @@ static int pxa168_usb_phy_init(struct pl
 
 	/* Make sure PHY PLL is ready again */
 	pll_retry_cont = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(readl(usb_phy_reg_base + USB_PHY_PLL_REG) & PLL_READY)) {
 		if (!(pll_retry_cont--)) {
 			dev_dbg(&pdev->dev, "USB PHY PLL not ready\n");
 			err = -EIO;
 			goto err2;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/usb/misc/legousbtower.c b/usb/misc/legousbtower.c
--- a/usb/misc/legousbtower.c
+++ b/usb/misc/legousbtower.c
@@ -708,6 +708,11 @@ static ssize_t tower_write (struct file
 	}
 
 	/* wait until previous transfer is finished */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dev->interrupt_out_busy) {
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EAGAIN;
@@ -717,6 +722,12 @@ static ssize_t tower_write (struct file
 		if (retval) {
 			goto unlock_exit;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* write the data into interrupt_out_buffer from userspace */
diff -u -p a/usb/misc/emi26.c b/usb/misc/emi26.c
--- a/usb/misc/emi26.c
+++ b/usb/misc/emi26.c
@@ -122,7 +122,12 @@ static int emi26_load_firmware (struct u
 
 	rec = (const struct ihex_binrec *)loader_fw->data;
 	/* 1. We need to put the loader for the FPGA into the EZ-USB */
-	while (rec) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rec) {
 		err = emi26_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
 					ANCHOR_LOAD_INTERNAL);
@@ -131,6 +136,12 @@ static int emi26_load_firmware (struct u
 			goto wraperr;
 		}
 		rec = ihex_next_binrec(rec);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
diff -u -p a/usb/misc/emi62.c b/usb/misc/emi62.c
--- a/usb/misc/emi62.c
+++ b/usb/misc/emi62.c
@@ -129,7 +129,12 @@ static int emi62_load_firmware (struct u
 	rec = (const struct ihex_binrec *)loader_fw->data;
 
 	/* 1. We need to put the loader for the FPGA into the EZ-USB */
-	while (rec) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rec) {
 		err = emi62_writememory(dev, be32_to_cpu(rec->addr),
 					rec->data, be16_to_cpu(rec->len),
 					ANCHOR_LOAD_INTERNAL);
@@ -138,6 +143,12 @@ static int emi62_load_firmware (struct u
 			goto wraperr;
 		}
 		rec = ihex_next_binrec(rec);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* De-assert reset (let the CPU run) */
diff -u -p a/usb/misc/rio500.c b/usb/misc/rio500.c
--- a/usb/misc/rio500.c
+++ b/usb/misc/rio500.c
@@ -159,7 +159,12 @@ static long ioctl_rio(struct file *file,
 		     rio_cmd.index, rio_cmd.length);
 		/* Send rio control message */
 		retries = 3;
-		while (retries) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (retries) {
 			result = usb_control_msg(rio->rio_dev,
 						 usb_rcvctrlpipe(rio-> rio_dev, 0),
 						 rio_cmd.request,
@@ -192,6 +197,12 @@ static long ioctl_rio(struct file *file,
 			   will be little_endian and will potentially need to
 			   be swapped at the app level */
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		free_page((unsigned long) buffer);
 		break;
@@ -226,7 +237,12 @@ static long ioctl_rio(struct file *file,
 		     rio_cmd.index, rio_cmd.length);
 		/* Send rio control message */
 		retries = 3;
-		while (retries) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (retries) {
 			result = usb_control_msg(rio->rio_dev,
 						 usb_sndctrlpipe(rio-> rio_dev, 0),
 						 rio_cmd.request,
@@ -246,6 +262,12 @@ static long ioctl_rio(struct file *file,
 
 			}
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		free_page((unsigned long) buffer);
 		break;
diff -u -p a/usb/misc/adutux.c b/usb/misc/adutux.c
--- a/usb/misc/adutux.c
+++ b/usb/misc/adutux.c
@@ -429,7 +429,12 @@ static ssize_t adu_read(struct file *fil
 
 	timeout = COMMAND_TIMEOUT;
 	dbg(2," %s : about to start looping", __func__);
-	while (bytes_to_read) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (bytes_to_read) {
 		int data_in_secondary = dev->secondary_tail - dev->secondary_head;
 		dbg(2," %s : while, data_in_secondary=%d, status=%d",
 		    __func__, data_in_secondary,
@@ -524,6 +529,12 @@ static ssize_t adu_read(struct file *fil
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	retval = bytes_read;
diff -u -p a/usb/musb/musb_core.c b/usb/musb/musb_core.c
--- a/usb/musb/musb_core.c
+++ b/usb/musb/musb_core.c
@@ -151,12 +151,23 @@ static int musb_ulpi_read(struct otg_tra
 	musb_writeb(addr, MUSB_ULPI_REG_CONTROL,
 			MUSB_ULPI_REG_REQ | MUSB_ULPI_RDN_WR);
 
-	while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
 				& MUSB_ULPI_REG_CMPLT)) {
 		i++;
 		if (i == 10000)
 			return -ETIMEDOUT;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	r = musb_readb(addr, MUSB_ULPI_REG_CONTROL);
 	r &= ~MUSB_ULPI_REG_CMPLT;
@@ -182,11 +193,22 @@ static int musb_ulpi_write(struct otg_tr
 	musb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)data);
 	musb_writeb(addr, MUSB_ULPI_REG_CONTROL, MUSB_ULPI_REG_REQ);
 
-	while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
 				& MUSB_ULPI_REG_CMPLT)) {
 		i++;
 		if (i == 10000)
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	r = musb_readb(addr, MUSB_ULPI_REG_CONTROL);
@@ -1544,6 +1566,11 @@ irqreturn_t musb_interrupt(struct musb *
 	/* RX on endpoints 1-15 */
 	reg = musb->int_rx >> 1;
 	ep_num = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg) {
 		if (reg & 1) {
 			/* musb_ep_select(musb->mregs, ep_num); */
@@ -1560,11 +1587,22 @@ irqreturn_t musb_interrupt(struct musb *
 
 		reg >>= 1;
 		ep_num++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* TX on endpoints 1-15 */
 	reg = musb->int_tx >> 1;
 	ep_num = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg) {
 		if (reg & 1) {
 			/* musb_ep_select(musb->mregs, ep_num); */
@@ -1580,6 +1618,12 @@ irqreturn_t musb_interrupt(struct musb *
 		}
 		reg >>= 1;
 		ep_num++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return retval;
diff -u -p a/usb/musb/cppi_dma.c b/usb/musb/cppi_dma.c
--- a/usb/musb/cppi_dma.c
+++ b/usb/musb/cppi_dma.c
@@ -1541,11 +1541,22 @@ static int cppi_channel_abort(struct dma
 		cppi_bd_free(cppi_ch, cppi_ch->last_processed);
 		cppi_ch->last_processed = NULL;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (queue) {
 			struct cppi_descriptor	*tmp = queue->next;
 
 			cppi_bd_free(cppi_ch, queue);
 			queue = tmp;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
diff -u -p a/usb/musb/musb_host.c b/usb/musb/musb_host.c
--- a/usb/musb/musb_host.c
+++ b/usb/musb/musb_host.c
@@ -113,6 +113,11 @@ static void musb_h_tx_flush_fifo(struct
 	int		retries = 1000;
 
 	csr = musb_readw(epio, MUSB_TXCSR);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (csr & MUSB_TXCSR_FIFONOTEMPTY) {
 		if (csr != lastcsr)
 			dev_dbg(musb->controller, "Host TX FIFONOTEMPTY csr: %02x\n", csr);
@@ -125,6 +130,12 @@ static void musb_h_tx_flush_fifo(struct
 				ep->epnum, csr))
 			return;
 		mdelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2219,10 +2230,21 @@ musb_h_disable(struct usb_hcd *hcd, stru
 		/* Then nuke all the others ... and advance the
 		 * queue on hw_ep (e.g. bulk ring) when we're done.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!list_empty(&hep->urb_list)) {
 			urb = next_urb(qh);
 			urb->status = -ESHUTDOWN;
 			musb_advance_schedule(musb, urb, qh->hw_ep, is_in);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		/* Just empty the queue; the hardware is busy with
diff -u -p a/usb/musb/musb_gadget.c b/usb/musb/musb_gadget.c
--- a/usb/musb/musb_gadget.c
+++ b/usb/musb/musb_gadget.c
@@ -254,9 +254,20 @@ static void nuke(struct musb_ep *ep, con
 		ep->dma = NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->req_list)) {
 		req = list_first_entry(&ep->req_list, struct musb_request, list);
 		musb_g_giveback(ep, &req->request, status);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/usb/class/usblp.c b/usb/class/usblp.c
--- a/usb/class/usblp.c
+++ b/usb/class/usblp.c
@@ -716,6 +716,11 @@ static ssize_t usblp_write(struct file *
 	if ((rv = usblp_wwait(usblp, !!(file->f_flags & O_NONBLOCK))) < 0)
 		goto raise_wait;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (writecount < count) {
 		/*
 		 * Step 1: Submit next block.
@@ -777,6 +782,12 @@ static ssize_t usblp_write(struct file *
 		 * The wmut exists mainly to cover us here.
 		 */
 		writecount += usblp->wstatus;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&usblp->wmut);
diff -u -p a/usb/early/ehci-dbgp.c b/usb/early/ehci-dbgp.c
--- a/usb/early/ehci-dbgp.c
+++ b/usb/early/ehci-dbgp.c
@@ -1061,6 +1061,11 @@ static int kgdbdbgp_reader_thread(void *
 {
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (readl(&ehci_debug->control) & DBGP_ENABLED) {
 		kgdbdbgp_loop_cnt = 1;
 		ret = kgdbdbgp_read_char();
@@ -1074,6 +1079,12 @@ static int kgdbdbgp_reader_thread(void *
 			continue;
 		}
 		schedule_timeout_interruptible(kgdbdbgp_wait_time * HZ);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/usb/c67x00/c67x00-sched.c b/usb/c67x00/c67x00-sched.c
--- a/usb/c67x00/c67x00-sched.c
+++ b/usb/c67x00/c67x00-sched.c
@@ -337,6 +337,11 @@ void c67x00_endpoint_disable(struct usb_
 	spin_lock_irqsave(&c67x00->lock, flags);
 
 	/* loop waiting for all transfers in the endpoint queue to complete */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (c67x00_ep_data_free(ep)) {
 		/* Drop the lock so we can sleep waiting for the hardware */
 		spin_unlock_irqrestore(&c67x00->lock, flags);
@@ -349,6 +354,12 @@ void c67x00_endpoint_disable(struct usb_
 		wait_for_completion_timeout(&c67x00->endpoint_disable, 1 * HZ);
 
 		spin_lock_irqsave(&c67x00->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&c67x00->lock, flags);
@@ -914,6 +925,11 @@ static inline void c67x00_clear_pipe(str
 	struct c67x00_td *td, *tmp;
 	td = last_td;
 	tmp = last_td;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (td->td_list.next != &c67x00->td_list) {
 		td = list_entry(td->td_list.next, struct c67x00_td, td_list);
 		if (td->pipe == last_td->pipe) {
@@ -921,6 +937,12 @@ static inline void c67x00_clear_pipe(str
 			td = tmp;
 		}
 		tmp = td;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/storage/protocol.c b/usb/storage/protocol.c
--- a/usb/storage/protocol.c
+++ b/usb/storage/protocol.c
@@ -156,7 +156,12 @@ unsigned int usb_stor_access_xfer_buf(un
 	 * the *offset and **sgptr values for the next loop.
 	 */
 	cnt = 0;
-	while (cnt < buflen && sg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt < buflen && sg) {
 		struct page *page = sg_page(sg) +
 				((sg->offset + *offset) >> PAGE_SHIFT);
 		unsigned int poff = (sg->offset + *offset) & (PAGE_SIZE-1);
@@ -194,6 +199,12 @@ unsigned int usb_stor_access_xfer_buf(un
 			cnt += plen;
 			sglen -= plen;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*sgptr = sg;
 
diff -u -p a/usb/storage/freecom.c b/usb/storage/freecom.c
--- a/usb/storage/freecom.c
+++ b/usb/storage/freecom.c
@@ -274,6 +274,11 @@ static int freecom_transport(struct scsi
 	 * NOTE: There is some indication that a data transfer after a timeout
 	 * may not work, but that is a condition that should never happen.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fst->Status & FCM_STATUS_BUSY) {
 		US_DEBUGP("20 second USB/ATAPI bridge TIMEOUT occurred!\n");
 		US_DEBUGP("fst->Status is %x\n", fst->Status);
@@ -306,6 +311,12 @@ static int freecom_transport(struct scsi
 			return USB_STOR_TRANSPORT_ERROR;
 
 		US_DEBUG(pdump ((void *) fst, partial));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (partial != 4)
diff -u -p a/usb/wusbcore/wa-nep.c b/usb/wusbcore/wa-nep.c
--- a/usb/wusbcore/wa-nep.c
+++ b/usb/wusbcore/wa-nep.c
@@ -110,6 +110,11 @@ static void wa_notif_dispatch(struct wor
 	size = nw->size;
 	itr = nw->data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		if (size < sizeof(*notif_hdr)) {
 			missing = sizeof(*notif_hdr) - size;
@@ -146,7 +151,13 @@ static void wa_notif_dispatch(struct wor
 				(size_t)notif_hdr->bLength);
 			break;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	wa_put(wa);
 	kfree(nw);
diff -u -p a/usb/gadget/r8a66597-udc.c b/usb/gadget/r8a66597-udc.c
--- a/usb/gadget/r8a66597-udc.c
+++ b/usb/gadget/r8a66597-udc.c
@@ -1416,7 +1416,12 @@ static void sudmac_finish(struct r8a6659
 	pipenum = ep->pipenum;
 	pipe_change(r8a66597, pipenum);
 
-	while (!(r8a66597_read(r8a66597, ep->fifoctr) & FRDY)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(r8a66597_read(r8a66597, ep->fifoctr) & FRDY)) {
 		udelay(1);
 		if (unlikely(i++ >= 10000)) {	/* timeout = 10 msec */
 			dev_err(r8a66597_to_dev(r8a66597),
@@ -1424,6 +1429,12 @@ static void sudmac_finish(struct r8a6659
 				__func__, pipenum);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	r8a66597_bset(r8a66597, BCLR, ep->fifoctr);
@@ -1577,11 +1588,22 @@ static int r8a66597_disable(struct usb_e
 	ep = container_of(_ep, struct r8a66597_ep, ep);
 	BUG_ON(!ep);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		req = get_request_from_ep(ep);
 		spin_lock_irqsave(&ep->r8a66597->lock, flags);
 		transfer_complete(ep, req, -ECONNRESET);
 		spin_unlock_irqrestore(&ep->r8a66597->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pipe_irq_disable(ep->r8a66597, ep->pipenum);
diff -u -p a/usb/gadget/langwell_udc.c b/usb/gadget/langwell_udc.c
--- a/usb/gadget/langwell_udc.c
+++ b/usb/gadget/langwell_udc.c
@@ -450,11 +450,22 @@ static void nuke(struct langwell_ep *ep,
 	if (&ep->ep && ep->desc)
 		langwell_ep_fifo_flush(&ep->ep);
 
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		struct langwell_request	*req = NULL;
 		req = list_entry(ep->queue.next, struct langwell_request,
 				queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1077,12 +1088,23 @@ static void langwell_ep_fifo_flush(struc
 	timeout = jiffies + FLUSH_TIMEOUT;
 	do {
 		writel(flush_bit, &dev->op_regs->endptflush);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (readl(&dev->op_regs->endptflush)) {
 			if (time_after(jiffies, timeout)) {
 				dev_err(&dev->pdev->dev, "ep flush timeout\n");
 				goto done;
 			}
 			cpu_relax();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} while (readl(&dev->op_regs->endptstat) & flush_bit);
 done:
@@ -1368,12 +1390,23 @@ static int langwell_udc_reset(struct lan
 
 	/* wait for reset to complete */
 	timeout = jiffies + RESET_TIMEOUT;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (readl(&dev->op_regs->usbcmd) & CMD_RST) {
 		if (time_after(jiffies, timeout)) {
 			dev_err(&dev->pdev->dev, "device reset timeout\n");
 			return -ETIMEDOUT;
 		}
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* set controller to device mode */
diff -u -p a/usb/gadget/atmel_usba_udc.c b/usb/gadget/atmel_usba_udc.c
--- a/usb/gadget/atmel_usba_udc.c
+++ b/usb/gadget/atmel_usba_udc.c
@@ -1558,6 +1558,11 @@ static void usba_ep_irq(struct usba_udc
 
 	DBG(DBG_INT, "%s: interrupt, status: 0x%08x\n", ep->ep.name, epstatus);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((epctrl & USBA_TX_PK_RDY) && !(epstatus & USBA_TX_PK_RDY)) {
 		DBG(DBG_BUS, "%s: TX PK ready\n", ep->ep.name);
 
@@ -1593,6 +1598,12 @@ static void usba_ep_irq(struct usba_udc
 
 		epstatus = usba_ep_readl(ep, STA);
 		epctrl = usba_ep_readl(ep, CTL);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if ((epstatus & epctrl) & USBA_RX_BK_RDY) {
 		DBG(DBG_BUS, "%s: RX data ready\n", ep->ep.name);
diff -u -p a/usb/gadget/at91_udc.c b/usb/gadget/at91_udc.c
--- a/usb/gadget/at91_udc.c
+++ b/usb/gadget/at91_udc.c
@@ -456,9 +456,20 @@ static void nuke(struct at91_ep *ep, int
 		return;
 
 	VDBG("%s %s\n", __func__, ep->ep.name);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct at91_request, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/gadget/composite.c b/usb/gadget/composite.c
--- a/usb/gadget/composite.c
+++ b/usb/gadget/composite.c
@@ -790,6 +790,11 @@ static void collect_langs(struct usb_gad
 	u16				language;
 	__le16				*tmp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*sp) {
 		s = *sp;
 		language = cpu_to_le16(s->language);
@@ -800,6 +805,12 @@ static void collect_langs(struct usb_gad
 		*tmp++ = language;
 repeat:
 		sp++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -813,6 +824,11 @@ static int lookup_string(
 	struct usb_gadget_strings	*s;
 	int				value;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*sp) {
 		s = *sp++;
 		if (s->language != language)
@@ -820,6 +836,12 @@ static int lookup_string(
 		value = usb_gadget_get_string(s, id, buf);
 		if (value > 0)
 			return value;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return -EINVAL;
 }
@@ -1328,12 +1350,22 @@ composite_unbind(struct usb_gadget *gadg
 	 */
 	WARN_ON(cdev->config);
 
-	while (!list_empty(&cdev->configs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cdev->configs)) {
 		struct usb_configuration	*c;
 
 		c = list_first_entry(&cdev->configs,
 				struct usb_configuration, list);
-		while (!list_empty(&c->functions)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&c->functions)) {
 			struct usb_function		*f;
 
 			f = list_first_entry(&c->functions,
@@ -1345,6 +1377,12 @@ composite_unbind(struct usb_gadget *gadg
 				f->unbind(c, f);
 				/* may free memory for "f" */
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		list_del(&c->list);
 		if (c->unbind) {
@@ -1352,6 +1390,12 @@ composite_unbind(struct usb_gadget *gadg
 			c->unbind(c);
 			/* may free memory for "c" */
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (composite->unbind)
 		composite->unbind(cdev);
diff -u -p a/usb/gadget/fsl_qe_udc.c b/usb/gadget/fsl_qe_udc.c
--- a/usb/gadget/fsl_qe_udc.c
+++ b/usb/gadget/fsl_qe_udc.c
@@ -137,11 +137,22 @@ static void done(struct qe_ep *ep, struc
 static void nuke(struct qe_ep *ep, int status)
 {
 	/* Whether this eq has request linked */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		struct qe_req *req = NULL;
 		req = list_entry(ep->queue.next, struct qe_req, queue);
 
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -740,6 +751,11 @@ static void recycle_rxbds(struct qe_ep *
 	bd = ep->e_rxbd;
 	bdstatus = in_be32((u32 __iomem *)bd);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(bdstatus & R_E) && !(bdstatus & BD_LENGTH_MASK) && !stop) {
 		bdstatus = R_E | R_I | (bdstatus & R_W);
 		out_be32((u32 __iomem *)bd, bdstatus);
@@ -752,6 +768,12 @@ static void recycle_rxbds(struct qe_ep *
 		bdstatus = in_be32((u32 __iomem *)bd);
 		if (stopatnext && (bd == nextbd))
 			stop = 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	ep->e_rxbd = bd;
@@ -840,6 +862,11 @@ static int qe_ep0_rx(struct qe_udc *udc)
 	bdstatus = in_be32((u32 __iomem *)bd);
 	length = bdstatus & BD_LENGTH_MASK;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(bdstatus & R_E) && length) {
 		if ((bdstatus & R_F) && (bdstatus & R_L)
 			&& !(bdstatus & R_ERROR)) {
@@ -887,6 +914,12 @@ static int qe_ep0_rx(struct qe_udc *udc)
 		bdstatus = in_be32((u32 __iomem *)bd);
 		length = bdstatus & BD_LENGTH_MASK;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ep->n_rxbd = bd;
@@ -1375,6 +1408,11 @@ static int qe_ep0_txconf(struct qe_ep *e
 
 	bd = ep->c_txbd;
 	bdstatus = in_be32((u32 __iomem *)bd);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(bdstatus & T_R) && (bdstatus & ~T_W)) {
 		pframe = ep->txframe;
 
@@ -1399,6 +1437,12 @@ static int qe_ep0_txconf(struct qe_ep *e
 
 		bd = ep->c_txbd;
 		bdstatus = in_be32((u32 __iomem *)bd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1432,6 +1476,11 @@ static int qe_ep_txconf(struct qe_ep *ep
 
 	bd = ep->c_txbd;
 	bdstatus = in_be32((u32 __iomem *)bd);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(bdstatus & T_R) && (bdstatus & ~T_W)) {
 		pframe = ep->txframe;
 		if (bdstatus & DEVICE_T_ERROR) {
@@ -1454,6 +1503,12 @@ static int qe_ep_txconf(struct qe_ep *ep
 		ep_txframe_handle(ep);
 		bd = ep->c_txbd;
 		bdstatus = in_be32((u32 __iomem *)bd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (breakonrxinterrupt)
 		return -EIO;
diff -u -p a/usb/gadget/rndis.c b/usb/gadget/rndis.c
--- a/usb/gadget/rndis.c
+++ b/usb/gadget/rndis.c
@@ -1162,9 +1162,20 @@ int rndis_init(void)
 					(void *)(rndis_per_dev_params + i));
 		if (!rndis_connect_state[i]) {
 			pr_debug("%s: remove entries", __func__);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (i) {
 				sprintf(name, NAME_TEMPLATE, --i);
 				remove_proc_entry(name, NULL);
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 			pr_debug("\n");
 			return -EIO;
diff -u -p a/usb/gadget/amd5536udc.c b/usb/gadget/amd5536udc.c
--- a/usb/gadget/amd5536udc.c
+++ b/usb/gadget/amd5536udc.c
@@ -897,8 +897,19 @@ static struct udc_data_dma *udc_get_last
 	struct udc_data_dma	*td;
 
 	td = req->td_data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (td && !(td->status & AMD_BIT(UDC_DMA_IN_STS_L))) {
 		td = phys_to_virt(td->next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return td;
@@ -915,6 +926,11 @@ static u32 udc_get_ppbdu_rxbytes(struct
 	/* received number bytes */
 	count = AMD_GETBITS(td->status, UDC_DMA_OUT_STS_RXBYTES);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (td && !(td->status & AMD_BIT(UDC_DMA_IN_STS_L))) {
 		td = phys_to_virt(td->next);
 		/* received number bytes */
@@ -922,6 +938,12 @@ static u32 udc_get_ppbdu_rxbytes(struct
 			count += AMD_GETBITS(td->status,
 				UDC_DMA_OUT_STS_RXBYTES);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return count;
@@ -1268,11 +1290,22 @@ static void empty_req_queue(struct udc_e
 	struct udc_request	*req;
 
 	ep->halted = 1;
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next,
 			struct udc_request,
 			queue);
 		complete_req(ep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/usb/gadget/f_hid.c b/usb/gadget/f_hid.c
--- a/usb/gadget/f_hid.c
+++ b/usb/gadget/f_hid.c
@@ -144,6 +144,11 @@ static ssize_t f_hidg_read(struct file *
 
 #define READ_COND (hidg->set_report_buff != NULL)
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!READ_COND) {
 		spin_unlock_irqrestore(&hidg->spinlock, flags);
 		if (file->f_flags & O_NONBLOCK)
@@ -153,6 +158,12 @@ static ssize_t f_hidg_read(struct file *
 			return -ERESTARTSYS;
 
 		spin_lock_irqsave(&hidg->spinlock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 
@@ -199,7 +210,12 @@ static ssize_t f_hidg_write(struct file
 #define WRITE_COND (!hidg->write_pending)
 
 	/* write queue */
-	while (!WRITE_COND) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (!WRITE_COND) {
 		mutex_unlock(&hidg->lock);
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
@@ -209,6 +225,12 @@ static ssize_t f_hidg_write(struct file
 			return -ERESTARTSYS;
 
 		mutex_lock(&hidg->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	count  = min_t(unsigned, count, hidg->report_length);
diff -u -p a/usb/gadget/ci13xxx_udc.c b/usb/gadget/ci13xxx_udc.c
--- a/usb/gadget/ci13xxx_udc.c
+++ b/usb/gadget/ci13xxx_udc.c
@@ -1590,7 +1590,12 @@ __acquires(mEp->lock)
 
 	hw_ep_flush(mEp->num, mEp->dir);
 
-	while (!list_empty(&mEp->qh.queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mEp->qh.queue)) {
 
 		/* pop oldest request */
 		struct ci13xxx_req *mReq = \
@@ -1604,6 +1609,12 @@ __acquires(mEp->lock)
 			mReq->req.complete(&mEp->ep, &mReq->req);
 			spin_lock(mEp->lock);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/usb/gadget/uvc_queue.c b/usb/gadget/uvc_queue.c
--- a/usb/gadget/uvc_queue.c
+++ b/usb/gadget/uvc_queue.c
@@ -479,12 +479,23 @@ static void uvc_queue_cancel(struct uvc_
 	unsigned long flags;
 
 	spin_lock_irqsave(&queue->irqlock, flags);
-	while (!list_empty(&queue->irqqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&queue->irqqueue)) {
 		buf = list_first_entry(&queue->irqqueue, struct uvc_buffer,
 				       queue);
 		list_del(&buf->queue);
 		buf->state = UVC_BUF_STATE_ERROR;
 		wake_up(&buf->wait);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* This must be protected by the irqlock spinlock to avoid race
 	 * conditions between uvc_queue_buffer and the disconnection event that
diff -u -p a/usb/gadget/mv_udc_core.c b/usb/gadget/mv_udc_core.c
--- a/usb/gadget/mv_udc_core.c
+++ b/usb/gadget/mv_udc_core.c
@@ -295,6 +295,11 @@ static int queue_dtd(struct mv_ep *ep, s
 			req->head->td_dma & EP_QUEUE_HEAD_NEXT_POINTER_MASK;
 		if (readl(&udc->op_regs->epprime) & bit_pos) {
 			loops = LOOPS(PRIME_TIMEOUT);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (readl(&udc->op_regs->epprime) & bit_pos) {
 				if (loops == 0) {
 					retval = -ETIME;
@@ -302,6 +307,12 @@ static int queue_dtd(struct mv_ep *ep, s
 				}
 				udelay(LOOPS_USEC);
 				loops--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if (readl(&udc->op_regs->epstatus) & bit_pos)
 				goto done;
@@ -348,6 +359,11 @@ static int queue_dtd(struct mv_ep *ep, s
 					&udc->dev->dev, dqh->curr_dtd_ptr);
 
 				loops = LOOPS(DTD_TIMEOUT);
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (curr_dtd->size_ioc_sts
 					& DTD_STATUS_ACTIVE) {
 					if (loops == 0) {
@@ -356,6 +372,12 @@ static int queue_dtd(struct mv_ep *ep, s
 					}
 					loops--;
 					udelay(LOOPS_USEC);
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 			/* No other transfers on the queue */
@@ -393,7 +415,12 @@ static int queue_dtd(struct mv_ep *ep, s
 
 			loops = LOOPS(DTD_TIMEOUT);
 			prime_again = 0;
-			while ((curr_dtd_ptr != req->head->td_dma)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((curr_dtd_ptr != req->head->td_dma)) {
 				curr_dtd_ptr = dqh->curr_dtd_ptr;
 				if (loops == 0) {
 					dev_err(&udc->dev->dev,
@@ -414,6 +441,12 @@ static int queue_dtd(struct mv_ep *ep, s
 						&udc->op_regs->epprime);
 					prime_again = 1;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -743,7 +776,12 @@ static void mv_ep_fifo_flush(struct usb_
 
 		/* Wait until flushing completed */
 		inter_loops = LOOPS(FLUSH_TIMEOUT);
-		while (readl(&udc->op_regs->epflush)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (readl(&udc->op_regs->epflush)) {
 			/*
 			 * ENDPTFLUSH bit should be cleared to indicate this
 			 * operation is complete
@@ -758,6 +796,12 @@ static void mv_ep_fifo_flush(struct usb_
 			}
 			inter_loops--;
 			udelay(LOOPS_USEC);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		loops--;
 	} while (readl(&udc->op_regs->epstatus) & bit_pos);
@@ -1091,7 +1135,12 @@ static int udc_reset(struct mv_udc *udc)
 
 	/* wait for reset to complete */
 	loops = LOOPS(RESET_TIMEOUT);
-	while (readl(&udc->op_regs->usbcmd) & USBCMD_CTRL_RESET) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (readl(&udc->op_regs->usbcmd) & USBCMD_CTRL_RESET) {
 		if (loops == 0) {
 			dev_err(&udc->dev->dev,
 				"Wait for RESET completed TIMEOUT\n");
@@ -1099,6 +1148,12 @@ static int udc_reset(struct mv_udc *udc)
 		}
 		loops--;
 		udelay(LOOPS_USEC);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* set controller to device mode */
@@ -1346,10 +1401,21 @@ static void nuke(struct mv_ep *ep, int s
 	/* endpoint fifo flush */
 	mv_ep_fifo_flush(&ep->ep);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		struct mv_req *req = NULL;
 		req = list_entry(ep->queue.next, struct mv_req, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/gadget/config.c b/usb/gadget/config.c
--- a/usb/gadget/config.c
+++ b/usb/gadget/config.c
@@ -144,12 +144,23 @@ usb_copy_descriptors(struct usb_descript
 	tmp = mem;
 	ret = mem;
 	mem += (n_desc + 1) * sizeof(*tmp);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*src) {
 		memcpy(mem, *src, (*src)->bLength);
 		*tmp = mem;
 		tmp++;
 		mem += (*src)->bLength;
 		src++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*tmp = NULL;
 
diff -u -p a/usb/gadget/s3c-hsudc.c b/usb/gadget/s3c-hsudc.c
--- a/usb/gadget/s3c-hsudc.c
+++ b/usb/gadget/s3c-hsudc.c
@@ -267,10 +267,21 @@ static void s3c_hsudc_nuke_ep(struct s3c
 {
 	struct s3c_hsudc_req *hsreq;
 
-	while (!list_empty(&hsep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&hsep->queue)) {
 		hsreq = list_entry(hsep->queue.next,
 				struct s3c_hsudc_req, queue);
 		s3c_hsudc_complete_request(hsep, hsreq, status);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1117,6 +1128,11 @@ static irqreturn_t s3c_hsudc_irq(int irq
 
 	ep_intr >>= 1;
 	ep_idx = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ep_intr) {
 		if (ep_intr & 1)  {
 			hsep = &hsudc->ep[ep_idx];
@@ -1129,6 +1145,12 @@ static irqreturn_t s3c_hsudc_irq(int irq
 		}
 		ep_intr >>= 1;
 		ep_idx++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	spin_unlock(&hsudc->lock);
diff -u -p a/usb/gadget/fusb300_udc.c b/usb/gadget/fusb300_udc.c
--- a/usb/gadget/fusb300_udc.c
+++ b/usb/gadget/fusb300_udc.c
@@ -258,11 +258,22 @@ static int fusb300_disable(struct usb_ep
 
 	BUG_ON(!ep);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct fusb300_request, queue);
 		spin_lock_irqsave(&ep->fusb300->lock, flags);
 		done(ep, req, -ECONNRESET);
 		spin_unlock_irqrestore(&ep->fusb300->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return fusb300_ep_release(ep);
diff -u -p a/usb/gadget/pxa25x_udc.c b/usb/gadget/pxa25x_udc.c
--- a/usb/gadget/pxa25x_udc.c
+++ b/usb/gadget/pxa25x_udc.c
@@ -598,6 +598,11 @@ read_ep0_fifo (struct pxa25x_ep *ep, str
 	buf = req->req.buf + req->req.actual;
 	bufferspace = req->req.length - req->req.actual;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (UDCCS0 & UDCCS0_RNE) {
 		byte = (u8) UDDR0;
 
@@ -614,6 +619,12 @@ read_ep0_fifo (struct pxa25x_ep *ep, str
 			req->req.actual++;
 			bufferspace--;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	UDCCS0 = UDCCS0_OPR | UDCCS0_IPR;
@@ -743,11 +754,22 @@ static void nuke(struct pxa25x_ep *ep, i
 	struct pxa25x_request *req;
 
 	/* called with irqs blocked */
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next,
 				struct pxa25x_request,
 				queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (ep->desc)
 		pio_irq_disable (ep->bEndpointAddress);
diff -u -p a/usb/gadget/pch_udc.c b/usb/gadget/pch_udc.c
--- a/usb/gadget/pch_udc.c
+++ b/usb/gadget/pch_udc.c
@@ -1292,9 +1292,20 @@ static void empty_req_queue(struct pch_u
 	struct pch_udc_request	*req;
 
 	ep->halted = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct pch_udc_request, queue);
 		complete_req(ep, req, -ESHUTDOWN);	/* Remove from list */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/gadget/net2272.c b/usb/gadget/net2272.c
--- a/usb/gadget/net2272.c
+++ b/usb/gadget/net2272.c
@@ -463,6 +463,11 @@ net2272_write_fifo(struct net2272_ep *ep
 	 *    host successfully takes another packet
 	 */
 	net2272_ep_write(ep, EP_STAT0, (1 << DATA_PACKET_TRANSMITTED_INTERRUPT));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(net2272_ep_read(ep, EP_STAT0) & (1 << BUFFER_FULL))) {
 		buf = req->req.buf + req->req.actual;
 		prefetch(buf);
@@ -499,6 +504,12 @@ net2272_write_fifo(struct net2272_ep *ep
 			return 1;
 		}
 		net2272_ep_write(ep, EP_STAT0, (1 << DATA_PACKET_TRANSMITTED_INTERRUPT));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -936,11 +947,22 @@ net2272_dequeue_all(struct net2272_ep *e
 	/* called with spinlock held */
 	ep->stopped = 1;
 
-	while (!list_empty(&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next,
 				struct net2272_request,
 				queue);
 		net2272_done(ep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1749,11 +1771,22 @@ net2272_handle_stat0_irqs(struct net2272
 
 		/* make sure any leftover interrupt state is cleared */
 		stat &= ~(1 << ENDPOINT_0_INTERRUPT);
-		while (!list_empty(&ep->queue)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&ep->queue)) {
 			req = list_entry(ep->queue.next,
 				struct net2272_request, queue);
 			net2272_done(ep, req,
 				(req->req.actual == req->req.length) ? 0 : -EPROTO);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		ep->stopped = 0;
 		dev->protocol_stall = 0;
diff -u -p a/usb/gadget/net2280.c b/usb/gadget/net2280.c
--- a/usb/gadget/net2280.c
+++ b/usb/gadget/net2280.c
@@ -1101,11 +1101,22 @@ static void nuke (struct net2280_ep *ep)
 	ep->stopped = 1;
 	if (ep->dma)
 		abort_dma (ep);
-	while (!list_empty (&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty (&ep->queue)) {
 		req = list_entry (ep->queue.next,
 				struct net2280_request,
 				queue);
 		done (ep, req, -ESHUTDOWN);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -2241,11 +2252,22 @@ static void handle_stat0_irqs (struct ne
 
 		/* make sure any leftover request state is cleared */
 		stat &= ~(1 << ENDPOINT_0_INTERRUPT);
-		while (!list_empty (&ep->queue)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty (&ep->queue)) {
 			req = list_entry (ep->queue.next,
 					struct net2280_request, queue);
 			done (ep, req, (req->req.actual == req->req.length)
 						? 0 : -EPROTO);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		ep->stopped = 0;
 		dev->protocol_stall = 0;
diff -u -p a/usb/gadget/s3c2410_udc.c b/usb/gadget/s3c2410_udc.c
--- a/usb/gadget/s3c2410_udc.c
+++ b/usb/gadget/s3c2410_udc.c
@@ -281,11 +281,22 @@ static void s3c2410_udc_nuke(struct s3c2
 	if (&ep->queue == NULL)
 		return;
 
-	while (!list_empty (&ep->queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty (&ep->queue)) {
 		struct s3c2410_request *req;
 		req = list_entry (ep->queue.next, struct s3c2410_request,
 				queue);
 		s3c2410_udc_done(ep, req, status);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/usb/gadget/goku_udc.c b/usb/gadget/goku_udc.c
--- a/usb/gadget/goku_udc.c
+++ b/usb/gadget/goku_udc.c
@@ -802,9 +802,20 @@ static void nuke(struct goku_ep *ep, int
 		return;
 	if (ep->dma)
 		abort_dma(ep, status);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct goku_request, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/gadget/pxa27x_udc.c b/usb/gadget/pxa27x_udc.c
--- a/usb/gadget/pxa27x_udc.c
+++ b/usb/gadget/pxa27x_udc.c
@@ -852,9 +852,20 @@ static void nuke(struct pxa_ep *ep, int
 	unsigned long		flags;
 
 	spin_lock_irqsave(&ep->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct pxa27x_request, queue);
 		req_done(ep, req, status, &flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&ep->lock, flags);
 }
@@ -1949,9 +1960,20 @@ static void handle_ep0_ctrl_req(struct p
 	}
 
 	have_extrabytes = !ep_is_empty(ep);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!ep_is_empty(ep)) {
 		i = udc_ep_readl(ep, UDCDR);
 		ep_err(ep, "wrong to have extra bytes for setup : 0x%08x\n", i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ep_dbg(ep, "SETUP %02x.%02x v%04x i%04x l%04x\n",
diff -u -p a/usb/gadget/fsl_udc_core.c b/usb/gadget/fsl_udc_core.c
--- a/usb/gadget/fsl_udc_core.c
+++ b/usb/gadget/fsl_udc_core.c
@@ -229,11 +229,22 @@ static void nuke(struct fsl_ep *ep, int
 	fsl_ep_fifo_flush(&ep->ep);
 
 	/* Whether this eq has request linked */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		struct fsl_req *req = NULL;
 
 		req = list_entry(ep->queue.next, struct fsl_req, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -283,12 +294,23 @@ static int dr_controller_setup(struct fs
 
 	/* Wait for reset to complete */
 	timeout = jiffies + FSL_UDC_RESET_TIMEOUT;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fsl_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {
 		if (time_after(jiffies, timeout)) {
 			ERR("udc reset timeout!\n");
 			return -ETIMEDOUT;
 		}
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Set the controller as device mode */
@@ -1118,12 +1140,23 @@ static void fsl_ep_fifo_flush(struct usb
 		fsl_writel(bits, &dr_regs->endptflush);
 
 		/* Wait until flush complete */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (fsl_readl(&dr_regs->endptflush)) {
 			if (time_after(jiffies, timeout)) {
 				ERR("ep flush timeout\n");
 				return;
 			}
 			cpu_relax();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* See if we need to flush again */
 	} while (fsl_readl(&dr_regs->endptstatus) & bits);
diff -u -p a/usb/gadget/u_ether.c b/usb/gadget/u_ether.c
--- a/usb/gadget/u_ether.c
+++ b/usb/gadget/u_ether.c
@@ -298,6 +298,11 @@ static void rx_complete(struct usb_ep *e
 		skb = NULL;
 
 		skb2 = skb_dequeue(&dev->rx_frames);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (skb2) {
 			if (status < 0
 					|| ETH_HLEN > skb2->len
@@ -318,6 +323,12 @@ static void rx_complete(struct usb_ep *e
 			status = netif_rx(skb2);
 next_frame:
 			skb2 = skb_dequeue(&dev->rx_frames);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 
@@ -424,7 +435,12 @@ static void rx_fill(struct eth_dev *dev,
 
 	/* fill unused rxq slots with some skb */
 	spin_lock_irqsave(&dev->req_lock, flags);
-	while (!list_empty(&dev->rx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_reqs)) {
 		req = container_of(dev->rx_reqs.next,
 				struct usb_request, list);
 		list_del_init(&req->list);
@@ -436,6 +452,12 @@ static void rx_fill(struct eth_dev *dev,
 		}
 
 		spin_lock_irqsave(&dev->req_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&dev->req_lock, flags);
 }
@@ -957,7 +979,12 @@ void gether_disconnect(struct gether *li
 	 */
 	usb_ep_disable(link->in_ep);
 	spin_lock(&dev->req_lock);
-	while (!list_empty(&dev->tx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->tx_reqs)) {
 		req = container_of(dev->tx_reqs.next,
 					struct usb_request, list);
 		list_del(&req->list);
@@ -965,6 +992,12 @@ void gether_disconnect(struct gether *li
 		spin_unlock(&dev->req_lock);
 		usb_ep_free_request(link->in_ep, req);
 		spin_lock(&dev->req_lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock(&dev->req_lock);
 	link->in_ep->driver_data = NULL;
@@ -972,7 +1005,12 @@ void gether_disconnect(struct gether *li
 
 	usb_ep_disable(link->out_ep);
 	spin_lock(&dev->req_lock);
-	while (!list_empty(&dev->rx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_reqs)) {
 		req = container_of(dev->rx_reqs.next,
 					struct usb_request, list);
 		list_del(&req->list);
@@ -980,6 +1018,12 @@ void gether_disconnect(struct gether *li
 		spin_unlock(&dev->req_lock);
 		usb_ep_free_request(link->out_ep, req);
 		spin_lock(&dev->req_lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock(&dev->req_lock);
 	link->out_ep->driver_data = NULL;
diff -u -p a/usb/gadget/dummy_hcd.c b/usb/gadget/dummy_hcd.c
--- a/usb/gadget/dummy_hcd.c
+++ b/usb/gadget/dummy_hcd.c
@@ -244,6 +244,11 @@ static struct dummy			the_controller;
 /* called with spinlock held */
 static void nuke (struct dummy *dum, struct dummy_ep *ep)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty (&ep->queue)) {
 		struct dummy_request	*req;
 
@@ -254,6 +259,12 @@ static void nuke (struct dummy *dum, str
 		spin_unlock (&dum->lock);
 		req->req.complete (&ep->ep, &req->req);
 		spin_lock (&dum->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/gadget/imx_udc.c b/usb/gadget/imx_udc.c
--- a/usb/gadget/imx_udc.c
+++ b/usb/gadget/imx_udc.c
@@ -378,9 +378,20 @@ static void nuke(struct imx_ep_struct *i
 {
 	struct imx_request *req;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&imx_ep->queue)) {
 		req = list_entry(imx_ep->queue.next, struct imx_request, queue);
 		done(imx_ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -612,11 +623,22 @@ static void handle_ep0_devreq(struct imx
 	}
 
 	temp = imx_ep_empty(imx_ep);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!imx_ep_empty(imx_ep)) {
 		i = __raw_readl(imx_usb->base +	USB_EP_FDAT(EP_NO(imx_ep)));
 		D_ERR(imx_usb->dev,
 			"<%s> wrong to have extra bytes for setup : 0x%08x\n",
 			__func__, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!temp)
 		goto stall;
diff -u -p a/usb/gadget/u_serial.c b/usb/gadget/u_serial.c
--- a/usb/gadget/u_serial.c
+++ b/usb/gadget/u_serial.c
@@ -626,12 +626,23 @@ static void gs_free_requests(struct usb_
 {
 	struct usb_request	*req;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(head)) {
 		req = list_entry(head->next, struct usb_request, list);
 		list_del(&req->list);
 		gs_free_req(ep, req);
 		if (allocated)
 			(*allocated)--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/usb/gadget/omap_udc.c b/usb/gadget/omap_udc.c
--- a/usb/gadget/omap_udc.c
+++ b/usb/gadget/omap_udc.c
@@ -1397,9 +1397,20 @@ static void nuke(struct omap_ep *ep, int
 	if (ep->bEndpointAddress && ep->bmAttributes != USB_ENDPOINT_XFER_ISOC)
 		omap_writew(UDC_SET_HALT, UDC_CTRL);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct omap_req, queue);
 		done(ep, req, status);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/gadget/m66592-udc.c b/usb/gadget/m66592-udc.c
--- a/usb/gadget/m66592-udc.c
+++ b/usb/gadget/m66592-udc.c
@@ -1321,11 +1321,22 @@ static int m66592_disable(struct usb_ep
 	ep = container_of(_ep, struct m66592_ep, ep);
 	BUG_ON(!ep);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&ep->queue)) {
 		req = list_entry(ep->queue.next, struct m66592_request, queue);
 		spin_lock_irqsave(&ep->m66592->lock, flags);
 		transfer_complete(ep, req, -ECONNRESET);
 		spin_unlock_irqrestore(&ep->m66592->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pipe_irq_disable(ep->m66592, ep->pipenum);
diff -u -p a/usb/gadget/printer.c b/usb/gadget/printer.c
--- a/usb/gadget/printer.c
+++ b/usb/gadget/printer.c
@@ -603,7 +603,12 @@ printer_read(struct file *fd, char __use
 	}
 
 	/* We have data to return then copy it to the caller's buffer.*/
-	while ((current_rx_bytes || likely(!list_empty(&dev->rx_buffers)))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((current_rx_bytes || likely(!list_empty(&dev->rx_buffers)))
 			&& len) {
 		if (current_rx_bytes == 0) {
 			req = container_of(dev->rx_buffers.next,
@@ -657,6 +662,12 @@ printer_read(struct file *fd, char __use
 			current_rx_buf = NULL;
 			current_rx_req = NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev->current_rx_req = current_rx_req;
@@ -714,7 +725,12 @@ printer_write(struct file *fd, const cha
 		spin_lock_irqsave(&dev->lock, flags);
 	}
 
-	while (likely(!list_empty(&dev->tx_reqs)) && len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (likely(!list_empty(&dev->tx_reqs)) && len) {
 
 		if (len > USB_BUFSIZE)
 			size = USB_BUFSIZE;
@@ -770,6 +786,12 @@ printer_write(struct file *fd, const cha
 
 		list_add(&req->list, &dev->tx_reqs_active);
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&dev->lock, flags);
@@ -1071,25 +1093,58 @@ static void printer_soft_reset(struct pr
 	dev->current_rx_buf = NULL;
 	dev->reset_printer = 1;
 
-	while (likely(!(list_empty(&dev->rx_buffers)))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!(list_empty(&dev->rx_buffers)))) {
 		req = container_of(dev->rx_buffers.next, struct usb_request,
 				list);
 		list_del_init(&req->list);
 		list_add(&req->list, &dev->rx_reqs);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
-	while (likely(!(list_empty(&dev->rx_reqs_active)))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!(list_empty(&dev->rx_reqs_active)))) {
 		req = container_of(dev->rx_buffers.next, struct usb_request,
 				list);
 		list_del_init(&req->list);
 		list_add(&req->list, &dev->rx_reqs);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
-	while (likely(!(list_empty(&dev->tx_reqs_active)))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (likely(!(list_empty(&dev->tx_reqs_active)))) {
 		req = container_of(dev->tx_reqs_active.next,
 				struct usb_request, list);
 		list_del_init(&req->list);
 		list_add(&req->list, &dev->tx_reqs);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (usb_ep_enable(dev->in_ep))
@@ -1314,28 +1369,61 @@ printer_unbind(struct usb_gadget *gadget
 	WARN_ON(!list_empty(&dev->rx_reqs_active));
 
 	/* Free all memory for this driver. */
-	while (!list_empty(&dev->tx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->tx_reqs)) {
 		req = container_of(dev->tx_reqs.next, struct usb_request,
 				list);
 		list_del(&req->list);
 		printer_req_free(dev->in_ep, req);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (dev->current_rx_req != NULL)
 		printer_req_free(dev->out_ep, dev->current_rx_req);
 
-	while (!list_empty(&dev->rx_reqs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_reqs)) {
 		req = container_of(dev->rx_reqs.next,
 				struct usb_request, list);
 		list_del(&req->list);
 		printer_req_free(dev->out_ep, req);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
-	while (!list_empty(&dev->rx_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&dev->rx_buffers)) {
 		req = container_of(dev->rx_buffers.next,
 				struct usb_request, list);
 		list_del(&req->list);
 		printer_req_free(dev->out_ep, req);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (dev->req) {
@@ -1489,11 +1577,22 @@ autoconf_fail:
 	for (i = 0; i < QLEN; i++) {
 		req = printer_req_alloc(dev->in_ep, USB_BUFSIZE, GFP_KERNEL);
 		if (!req) {
-			while (!list_empty(&dev->tx_reqs)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&dev->tx_reqs)) {
 				req = container_of(dev->tx_reqs.next,
 						struct usb_request, list);
 				list_del(&req->list);
 				printer_req_free(dev->in_ep, req);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			return -ENOMEM;
 		}
@@ -1503,11 +1602,22 @@ autoconf_fail:
 	for (i = 0; i < QLEN; i++) {
 		req = printer_req_alloc(dev->out_ep, USB_BUFSIZE, GFP_KERNEL);
 		if (!req) {
-			while (!list_empty(&dev->rx_reqs)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&dev->rx_reqs)) {
 				req = container_of(dev->rx_reqs.next,
 						struct usb_request, list);
 				list_del(&req->list);
 				printer_req_free(dev->out_ep, req);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			return -ENOMEM;
 		}
diff -u -p a/usb/serial/pl2303.c b/usb/serial/pl2303.c
--- a/usb/serial/pl2303.c
+++ b/usb/serial/pl2303.c
@@ -613,6 +613,11 @@ static int wait_modem_info(struct usb_se
 	prevstatus = priv->line_status;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		interruptible_sleep_on(&port->delta_msr_wait);
 		/* see if a signal did it */
@@ -635,6 +640,12 @@ static int wait_modem_info(struct usb_se
 			return 0;
 		}
 		prevstatus = status;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* NOTREACHED */
 	return 0;
diff -u -p a/usb/serial/garmin_gps.c b/usb/serial/garmin_gps.c
--- a/usb/serial/garmin_gps.c
+++ b/usb/serial/garmin_gps.c
@@ -349,10 +349,21 @@ static void pkt_clear(struct garmin_data
 	dbg("%s", __func__);
 
 	spin_lock_irqsave(&garmin_data_p->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&garmin_data_p->pktlist)) {
 		result = (struct garmin_packet *)garmin_data_p->pktlist.next;
 		list_del(&result->list);
 		kfree(result);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&garmin_data_p->lock, flags);
 }
@@ -438,9 +449,20 @@ static int gsp_rec_packet(struct garmin_
 		return -EINVPKT;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (n < size) {
 		cksum += *recpkt++;
 		n++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if ((0xff & (cksum + *recpkt)) != 0) {
@@ -517,6 +539,11 @@ static int gsp_receive(struct garmin_dat
 	if (size == 0)
 		size = GSP_INITIAL_OFFSET;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (offs < count) {
 
 		data = *(buf+offs);
@@ -573,6 +600,12 @@ static int gsp_receive(struct garmin_dat
 			size = GSP_INITIAL_OFFSET;
 			dleSeen = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_lock_irqsave(&garmin_data_p->lock, flags);
@@ -768,7 +801,12 @@ static int nat_receive(struct garmin_dat
 	int result = count;
 	int len;
 
-	while (offs < count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offs < count) {
 		/* if buffer contains header, copy rest of data */
 		if (garmin_data_p->insize >= GARMIN_PKTHDR_LENGTH)
 			len = GARMIN_PKTHDR_LENGTH
@@ -818,6 +856,12 @@ static int nat_receive(struct garmin_dat
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return result;
 }
diff -u -p a/usb/serial/ti_usb_3410_5052.c b/usb/serial/ti_usb_3410_5052.c
--- a/usb/serial/ti_usb_3410_5052.c
+++ b/usb/serial/ti_usb_3410_5052.c
@@ -846,6 +846,11 @@ static int ti_ioctl(struct tty_struct *t
 	case TIOCMIWAIT:
 		dbg("%s - (%d) TIOCMIWAIT", __func__, port->number);
 		cprev = tport->tp_icount;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (1) {
 			interruptible_sleep_on(&port->delta_msr_wait);
 			if (signal_pending(current))
@@ -864,6 +869,12 @@ static int ti_ioctl(struct tty_struct *t
 			    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)))
 				return 0;
 			cprev = cnow;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
diff -u -p a/usb/serial/digi_acceleport.c b/usb/serial/digi_acceleport.c
--- a/usb/serial/digi_acceleport.c
+++ b/usb/serial/digi_acceleport.c
@@ -639,13 +639,24 @@ static int digi_write_oob_command(struct
 
 	spin_lock_irqsave(&oob_priv->dp_port_lock, flags);
 	while (count > 0) {
-		while (oob_priv->dp_write_urb_in_use) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (oob_priv->dp_write_urb_in_use) {
 			cond_wait_interruptible_timeout_irqrestore(
 				&oob_port->write_wait, DIGI_RETRY_TIMEOUT,
 				&oob_priv->dp_port_lock, flags);
 			if (interruptible && signal_pending(current))
 				return -EINTR;
 			spin_lock_irqsave(&oob_priv->dp_port_lock, flags);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* len must be a multiple of 4, so commands are not split */
@@ -702,7 +713,12 @@ static int digi_write_inb_command(struct
 
 	spin_lock_irqsave(&priv->dp_port_lock, flags);
 	while (count > 0 && ret == 0) {
-		while (priv->dp_write_urb_in_use &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (priv->dp_write_urb_in_use &&
 		       time_before(jiffies, timeout)) {
 			cond_wait_interruptible_timeout_irqrestore(
 				&port->write_wait, DIGI_RETRY_TIMEOUT,
@@ -710,6 +726,12 @@ static int digi_write_inb_command(struct
 			if (signal_pending(current))
 				return -EINTR;
 			spin_lock_irqsave(&priv->dp_port_lock, flags);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* len must be a multiple of 4 and small enough to */
@@ -781,7 +803,12 @@ static int digi_set_modem_signals(struct
 	spin_lock_irqsave(&oob_priv->dp_port_lock, flags);
 	spin_lock(&port_priv->dp_port_lock);
 
-	while (oob_priv->dp_write_urb_in_use) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (oob_priv->dp_write_urb_in_use) {
 		spin_unlock(&port_priv->dp_port_lock);
 		cond_wait_interruptible_timeout_irqrestore(
 			&oob_port->write_wait, DIGI_RETRY_TIMEOUT,
@@ -790,6 +817,12 @@ static int digi_set_modem_signals(struct
 			return -EINTR;
 		spin_lock_irqsave(&oob_priv->dp_port_lock, flags);
 		spin_lock(&port_priv->dp_port_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	data[0] = DIGI_CMD_SET_DTR_SIGNAL;
 	data[1] = port_priv->dp_port_num;
@@ -855,13 +888,24 @@ static int digi_transmit_idle(struct usb
 
 	spin_lock_irqsave(&priv->dp_port_lock, flags);
 
-	while (time_before(jiffies, timeout) && !priv->dp_transmit_idle) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, timeout) && !priv->dp_transmit_idle) {
 		cond_wait_interruptible_timeout_irqrestore(
 			&priv->dp_transmit_idle_wait, DIGI_RETRY_TIMEOUT,
 			&priv->dp_port_lock, flags);
 		if (signal_pending(current))
 			return -EINTR;
 		spin_lock_irqsave(&priv->dp_port_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	priv->dp_transmit_idle = 0;
 	spin_unlock_irqrestore(&priv->dp_port_lock, flags);
diff -u -p a/usb/serial/console.c b/usb/serial/console.c
--- a/usb/serial/console.c
+++ b/usb/serial/console.c
@@ -219,6 +219,11 @@ static void usb_console_write(struct con
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		unsigned int i;
 		unsigned int lf;
@@ -250,6 +255,12 @@ static void usb_console_write(struct con
 		}
 		buf += i;
 		count -= i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/usb/serial/keyspan.c b/usb/serial/keyspan.c
--- a/usb/serial/keyspan.c
+++ b/usb/serial/keyspan.c
@@ -877,7 +877,12 @@ static void usa49wg_indat_callback(struc
 	len = 0;
 
 	if (urb->actual_length) {
-		while (i < urb->actual_length) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i < urb->actual_length) {
 
 			/* Check port number from message*/
 			if (data[i] >= serial->num_ports) {
@@ -915,6 +920,12 @@ static void usa49wg_indat_callback(struc
 			}
 			tty_flip_buffer_push(tty);
 			tty_kref_put(tty);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/usb/serial/spcp8x5.c b/usb/serial/spcp8x5.c
--- a/usb/serial/spcp8x5.c
+++ b/usb/serial/spcp8x5.c
@@ -544,6 +544,11 @@ static int spcp8x5_wait_modem_info(struc
 	prevstatus = priv->line_status;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		/* wake up in bulk read */
 		interruptible_sleep_on(&port->delta_msr_wait);
@@ -568,6 +573,12 @@ static int spcp8x5_wait_modem_info(struc
 			return 0;
 
 		prevstatus = status;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* NOTREACHED */
 	return 0;
diff -u -p a/usb/serial/io_edgeport.c b/usb/serial/io_edgeport.c
--- a/usb/serial/io_edgeport.c
+++ b/usb/serial/io_edgeport.c
@@ -622,7 +622,12 @@ static void edge_interrupt_callback(stru
 		/* grab the txcredits for the ports if available */
 		position = 2;
 		portNumber = 0;
-		while ((position < length) &&
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((position < length) &&
 				(portNumber < edge_serial->serial->num_ports)) {
 			txCredits = data[position] | (data[position+1] << 8);
 			if (txCredits) {
@@ -652,6 +657,12 @@ static void edge_interrupt_callback(stru
 			}
 			position += 2;
 			++portNumber;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -967,6 +978,11 @@ static void block_until_chase_response(s
 	int timeout = 1*HZ;
 	int loop = 10;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		/* Save Last credits */
 		lastCredits = edge_port->txCredits;
@@ -1002,6 +1018,12 @@ static void block_until_chase_response(s
 					lastCredits, edge_port->txCredits);
 			loop = 10;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1024,7 +1046,12 @@ static void block_until_tx_empty(struct
 	int timeout = HZ/10;
 	int loop = 30;
 
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		/* Save Last count */
 		lastCount = fifo->count;
 
@@ -1053,6 +1080,12 @@ static void block_until_tx_empty(struct
 			/* Reset timeout value back to seconds */
 			loop = 30;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1700,7 +1733,12 @@ static int edge_ioctl(struct tty_struct
 	case TIOCMIWAIT:
 		dbg("%s (%d) TIOCMIWAIT", __func__,  port->number);
 		cprev = edge_port->icount;
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (1) {
 			prepare_to_wait(&port->delta_msr_wait,
 						&wait, TASK_INTERRUPTIBLE);
 			schedule();
@@ -1723,6 +1761,12 @@ static int edge_ioctl(struct tty_struct
 				return 0;
 			}
 			cprev = cnow;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* NOTREACHED */
 		break;
diff -u -p a/usb/serial/oti6858.c b/usb/serial/oti6858.c
--- a/usb/serial/oti6858.c
+++ b/usb/serial/oti6858.c
@@ -702,7 +702,12 @@ static int wait_modem_info(struct usb_se
 	prev = priv->status.pin_state;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		wait_event_interruptible(port->delta_msr_wait,
 					port->serial->disconnected ||
 					priv->status.pin_state != prev);
@@ -724,6 +729,12 @@ static int wait_modem_info(struct usb_se
 		    ((arg & TIOCM_CTS) && (changed & PIN_CTS)))
 			return 0;
 		prev = status;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* NOTREACHED */
diff -u -p a/usb/serial/ssu100.c b/usb/serial/ssu100.c
--- a/usb/serial/ssu100.c
+++ b/usb/serial/ssu100.c
@@ -385,6 +385,11 @@ static int wait_modem_info(struct usb_se
 	prev = priv->icount;
 	spin_unlock_irqrestore(&priv->status_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		wait_event_interruptible(port->delta_msr_wait,
 					 (port->serial->disconnected ||
@@ -414,6 +419,12 @@ static int wait_modem_info(struct usb_se
 		    (arg & TIOCM_CD  && (prev.dcd != cur.dcd)) ||
 		    (arg & TIOCM_CTS && (prev.cts != cur.cts)))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/usb/serial/ch341.c b/usb/serial/ch341.c
--- a/usb/serial/ch341.c
+++ b/usb/serial/ch341.c
@@ -526,6 +526,11 @@ static int wait_modem_info(struct usb_se
 	priv->multi_status_change = 0;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!multi_change) {
 		interruptible_sleep_on(&port->delta_msr_wait);
 		/* see if a signal did it */
@@ -549,6 +554,12 @@ static int wait_modem_info(struct usb_se
 			return 0;
 		}
 		prevstatus = status;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/usb/serial/io_ti.c b/usb/serial/io_ti.c
--- a/usb/serial/io_ti.c
+++ b/usb/serial/io_ti.c
@@ -314,7 +314,12 @@ static int read_download_mem(struct usb_
 	/* Read in blocks of 64 bytes
 	 * (TI firmware can't handle more than 64 byte reads)
 	 */
-	while (length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (length) {
 		if (length > 64)
 			read_length = 64;
 		else
@@ -347,6 +352,12 @@ static int read_download_mem(struct usb_
 		start_address += read_length;
 		buffer += read_length;
 		length -= read_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return status;
@@ -469,7 +480,12 @@ static int write_i2c_mem(struct edgeport
 
 	/* We should be aligned now -- can write
 	   max page size bytes at a time */
-	while (length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (length) {
 		if (length > EPROM_PAGE_SIZE)
 			write_length = EPROM_PAGE_SIZE;
 		else
@@ -500,6 +516,12 @@ static int write_i2c_mem(struct edgeport
 		length		-= write_length;
 		start_address	+= write_length;
 		buffer		+= write_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return status;
 }
@@ -2585,6 +2607,11 @@ static int edge_ioctl(struct tty_struct
 	case TIOCMIWAIT:
 		dbg("%s - (%d) TIOCMIWAIT", __func__, port->number);
 		cprev = edge_port->icount;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (1) {
 			interruptible_sleep_on(&port->delta_msr_wait);
 			/* see if a signal did it */
@@ -2605,6 +2632,12 @@ static int edge_ioctl(struct tty_struct
 				return 0;
 			}
 			cprev = cnow;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* not reached */
 		break;
diff -u -p a/usb/serial/mos7720.c b/usb/serial/mos7720.c
--- a/usb/serial/mos7720.c
+++ b/usb/serial/mos7720.c
@@ -2041,6 +2041,11 @@ static int mos7720_ioctl(struct tty_stru
 	case TIOCMIWAIT:
 		dbg("%s (%d) TIOCMIWAIT", __func__,  port->number);
 		cprev = mos7720_port->icount;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (1) {
 			if (signal_pending(current))
 				return -ERESTARTSYS;
@@ -2055,6 +2060,12 @@ static int mos7720_ioctl(struct tty_stru
 				return 0;
 			}
 			cprev = cnow;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* NOTREACHED */
 		break;
diff -u -p a/usb/serial/mos7840.c b/usb/serial/mos7840.c
--- a/usb/serial/mos7840.c
+++ b/usb/serial/mos7840.c
@@ -1316,7 +1316,12 @@ static void mos7840_block_until_chase_re
 	int wait = 10;
 	int count;
 
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		count = mos7840_chars_in_buffer(tty);
 
 		/* Check for Buffer status */
@@ -1335,6 +1340,12 @@ static void mos7840_block_until_chase_re
 			/* Reset timeout value back to seconds */
 			wait = 10;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -2306,7 +2317,12 @@ static int mos7840_ioctl(struct tty_stru
 	case TIOCMIWAIT:
 		dbg("%s (%d) TIOCMIWAIT", __func__, port->number);
 		cprev = mos7840_port->icount;
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (1) {
 			/* interruptible_sleep_on(&mos7840_port->delta_msr_wait); */
 			mos7840_port->delta_msr_cond = 0;
 			wait_event_interruptible(port->delta_msr_wait,
@@ -2333,6 +2349,12 @@ static int mos7840_ioctl(struct tty_stru
 				return 0;
 			}
 			cprev = cnow;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* NOTREACHED */
 		break;
diff -u -p a/uwb/drp-avail.c b/uwb/drp-avail.c
--- a/uwb/drp-avail.c
+++ b/uwb/drp-avail.c
@@ -145,10 +145,21 @@ unsigned long get_val(u8 *array, size_t
 
 	BUG_ON(len > sizeof(val));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (itr < top) {
 		val <<= 8;
 		val |= array[top - 1];
 		top--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	val <<= 8 * (sizeof(val) - len); /* padding */
 	return val;
@@ -207,12 +218,23 @@ void buffer_to_bmp(unsigned long *bmp_it
 	unsigned long val;
 
 	itr = 0;
-	while (itr < buffer_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (itr < buffer_size) {
 		len = buffer_size - itr >= sizeof(val) ?
 			sizeof(val) : buffer_size - itr;
 		val = get_val(buffer, itr, len);
 		bmp_itr[itr / sizeof(val)] = val;
 		itr += sizeof(val);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/uwb/i1480/dfu/mac.c b/uwb/i1480/dfu/mac.c
--- a/uwb/i1480/dfu/mac.c
+++ b/uwb/i1480/dfu/mac.c
@@ -49,10 +49,21 @@ void fw_hdrs_free(struct fw_hdr *hdr)
 {
 	struct fw_hdr *next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hdr) {
 		next = hdr->next;
 		kfree(hdr);
 		hdr = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -122,7 +133,12 @@ int fw_hdrs_load(struct i1480 *i1480, st
 	*phdr = NULL;
 	data_itr = data;
 	data_top = (u32 *) (_data + data_size);
-	while (data_itr < data_top) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (data_itr < data_top) {
 		result = -ENOMEM;
 		hdr = kmalloc(sizeof(*hdr), GFP_KERNEL);
 		if (hdr == NULL) {
@@ -138,6 +154,12 @@ int fw_hdrs_load(struct i1480 *i1480, st
 		*prev_hdr = hdr;
 		prev_hdr = &hdr->next;
 		hdr_cnt++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	};
 	*prev_hdr = NULL;
 	return 0;
diff -u -p a/xen/xen-pciback/pci_stub.c b/xen/xen-pciback/pci_stub.c
--- a/xen/xen-pciback/pci_stub.c
+++ b/xen/xen-pciback/pci_stub.c
@@ -358,7 +358,12 @@ static int __init pcistub_init_devices_l
 
 	spin_lock_irqsave(&pcistub_devices_lock, flags);
 
-	while (!list_empty(&seized_devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&seized_devices)) {
 		psdev = container_of(seized_devices.next,
 				     struct pcistub_device, dev_list);
 		list_del(&psdev->dev_list);
@@ -377,6 +382,12 @@ static int __init pcistub_init_devices_l
 
 		if (psdev)
 			list_add_tail(&psdev->dev_list, &pcistub_devices);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	initialize_devices = 1;
diff -u -p a/xen/balloon.c b/xen/balloon.c
--- a/xen/balloon.c
+++ b/xen/balloon.c
@@ -509,6 +509,11 @@ int alloc_xenballooned_pages(int nr_page
 	int pgno = 0;
 	struct page *page;
 	mutex_lock(&balloon_mutex);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pgno < nr_pages) {
 		page = balloon_retrieve(highmem);
 		if (page && (highmem || !PageHighMem(page))) {
@@ -522,6 +527,12 @@ int alloc_xenballooned_pages(int nr_page
 			if (st != BP_DONE)
 				goto out_undo;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	mutex_unlock(&balloon_mutex);
 	return 0;
diff -u -p a/xen/xenfs/xenbus.c b/xen/xenfs/xenbus.c
--- a/xen/xenfs/xenbus.c
+++ b/xen/xenfs/xenbus.c
@@ -123,7 +123,12 @@ static ssize_t xenbus_file_read(struct f
 
 	mutex_lock(&u->reply_mutex);
 again:
-	while (list_empty(&u->read_buffers)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (list_empty(&u->read_buffers)) {
 		mutex_unlock(&u->reply_mutex);
 		if (filp->f_flags & O_NONBLOCK)
 			return -EAGAIN;
@@ -133,6 +138,12 @@ again:
 		if (ret)
 			return ret;
 		mutex_lock(&u->reply_mutex);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rb = list_entry(u->read_buffers.next, struct read_buffer, list);
@@ -204,10 +215,21 @@ static void queue_cleanup(struct list_he
 {
 	struct read_buffer *rb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(list)) {
 		rb = list_entry(list->next, struct read_buffer, list);
 		list_del(list->next);
 		kfree(rb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/xen/xencomm.c b/xen/xencomm.c
--- a/xen/xencomm.c
+++ b/xen/xencomm.c
@@ -31,6 +31,11 @@ static int xencomm_init(struct xencomm_d
 	unsigned long recorded = 0;
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((recorded < bytes) && (i < desc->nr_addrs)) {
 		unsigned long vaddr = (unsigned long)buffer + recorded;
 		unsigned long paddr;
@@ -49,6 +54,12 @@ static int xencomm_init(struct xencomm_d
 
 		desc->address[i++] = paddr;
 		recorded += chunksz;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (recorded < bytes) {
diff -u -p a/xen/grant-table.c b/xen/grant-table.c
--- a/xen/grant-table.c
+++ b/xen/grant-table.c
@@ -259,16 +259,38 @@ unsigned long gnttab_end_foreign_transfe
 	 * If a transfer is not even yet started, try to reclaim the grant
 	 * reference and return failure (== 0).
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((flags = shared[ref].flags) & GTF_transfer_committed)) {
 		if (sync_cmpxchg(&shared[ref].flags, flags, 0) == flags)
 			return 0;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If a transfer is in progress then wait until it is completed. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(flags & GTF_transfer_completed)) {
 		flags = shared[ref].flags;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rmb();	/* Read the frame number /after/ reading completion status. */
@@ -361,10 +383,21 @@ void gnttab_request_free_callback(struct
 
 	/* Check if the callback is already on the list */
 	cb = gnttab_free_callback_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cb) {
 		if (cb == callback)
 			goto out;
 		cb = cb->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	callback->fn = fn;
diff -u -p a/xen/xenbus/xenbus_xs.c b/xen/xenbus/xenbus_xs.c
--- a/xen/xenbus/xenbus_xs.c
+++ b/xen/xenbus/xenbus_xs.c
@@ -144,12 +144,23 @@ static void *read_reply(enum xsd_sockmsg
 
 	spin_lock(&xs_state.reply_lock);
 
-	while (list_empty(&xs_state.reply_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (list_empty(&xs_state.reply_list)) {
 		spin_unlock(&xs_state.reply_lock);
 		/* XXX FIXME: Avoid synchronous wait for response here. */
 		wait_event(xs_state.reply_waitq,
 			   !list_empty(&xs_state.reply_list));
 		spin_lock(&xs_state.reply_lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	msg = list_entry(xs_state.reply_list.next,
diff -u -p a/xen/gntdev.c b/xen/gntdev.c
--- a/xen/gntdev.c
+++ b/xen/gntdev.c
@@ -338,6 +338,11 @@ static int unmap_grant_pages(struct gran
 	/* It is possible the requested range will have a "hole" where we
 	 * already unmapped some of the grants. Only unmap valid ranges.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pages && !err) {
 		while (pages && map->unmap_ops[offset].handle == -1) {
 			offset++;
@@ -354,6 +359,12 @@ static int unmap_grant_pages(struct gran
 		err = __unmap_grant_pages(map, offset, range);
 		offset += range;
 		pages -= range;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return err;
@@ -493,10 +504,21 @@ static int gntdev_release(struct inode *
 
 	pr_debug("priv %p\n", priv);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&priv->maps)) {
 		map = list_entry(priv->maps.next, struct grant_map, next);
 		list_del(&map->next);
 		gntdev_put_map(map);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (use_ptemod)
diff -u -p a/xen/gntalloc.c b/xen/gntalloc.c
--- a/xen/gntalloc.c
+++ b/xen/gntalloc.c
@@ -252,13 +252,24 @@ static int gntalloc_release(struct inode
 	pr_debug("%s: priv %p\n", __func__, priv);
 
 	spin_lock(&gref_lock);
-	while (!list_empty(&priv->list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&priv->list)) {
 		gref = list_entry(priv->list.next,
 			struct gntalloc_gref, next_file);
 		list_del(&gref->next_file);
 		gref->users--;
 		if (gref->users == 0)
 			__del_gref(gref);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	kfree(priv);
 	spin_unlock(&gref_lock);
diff -u -p a/acpi/apei/apei-base.c b/acpi/apei/apei-base.c
--- a/acpi/apei/apei-base.c
+++ b/acpi/apei/apei-base.c
@@ -348,6 +348,11 @@ static int apei_res_sub(struct list_head
 	struct apei_res *res1, *resn1, *res2, *res;
 	res1 = list_entry(res_list1->next, struct apei_res, list);
 	resn1 = list_entry(res1->list.next, struct apei_res, list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (&res1->list != res_list1) {
 		list_for_each_entry(res2, res_list2, list) {
 			if (res1->start >= res2->end ||
@@ -377,6 +382,12 @@ static int apei_res_sub(struct list_head
 		}
 		res1 = resn1;
 		resn1 = list_entry(resn1->list.next, struct apei_res, list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/acpi/apei/ghes.c b/acpi/apei/ghes.c
--- a/acpi/apei/ghes.c
+++ b/acpi/apei/ghes.c
@@ -724,14 +724,30 @@ static void ghes_proc_in_irq(struct irq_
 	 * revert it back to proper order.
 	 */
 	llnode = llist_del_all(&ghes_estatus_llist);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (llnode) {
 		next = llnode->next;
 		llnode->next = tail;
 		tail = llnode;
 		llnode = next;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	llnode = tail;
-	while (llnode) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (llnode) {
 		next = llnode->next;
 		estatus_node = llist_entry(llnode, struct ghes_estatus_node,
 					   llnode);
@@ -747,6 +763,12 @@ static void ghes_proc_in_irq(struct irq_
 		gen_pool_free(ghes_estatus_pool, (unsigned long)estatus_node,
 			      node_len);
 		llnode = next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/acpi/pci_root.c b/acpi/pci_root.c
--- a/acpi/pci_root.c
+++ b/acpi/pci_root.c
@@ -319,6 +319,11 @@ struct pci_dev *acpi_get_pci_dev(acpi_ha
 	 * Walk up the ACPI CA namespace until we reach a PCI root bridge.
 	 */
 	phandle = handle;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!acpi_is_root_bridge(phandle)) {
 		node = kzalloc(sizeof(struct acpi_handle_node), GFP_KERNEL);
 		if (!node)
@@ -331,6 +336,12 @@ struct pci_dev *acpi_get_pci_dev(acpi_ha
 		status = acpi_get_parent(phandle, &phandle);
 		if (ACPI_FAILURE(status))
 			goto out;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	root = acpi_pci_find_root(phandle);
diff -u -p a/acpi/osl.c b/acpi/osl.c
--- a/acpi/osl.c
+++ b/acpi/osl.c
@@ -595,6 +595,11 @@ void acpi_os_sleep(u64 ms)
 
 void acpi_os_stall(u32 us)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (us) {
 		u32 delay = 1000;
 
@@ -603,6 +608,12 @@ void acpi_os_stall(u32 us)
 		udelay(delay);
 		touch_nmi_watchdog();
 		us -= delay;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/acpi/acpica/utinit.c b/acpi/acpica/utinit.c
--- a/acpi/acpica/utinit.c
+++ b/acpi/acpica/utinit.c
@@ -77,8 +77,18 @@ static void acpi_ut_terminate(void)
 	/* Free global GPE blocks and related info structures */
 
 	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (gpe_xrupt_info) {
 		gpe_block = gpe_xrupt_info->gpe_block_list_head;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (gpe_block) {
 			next_gpe_block = gpe_block->next;
 			ACPI_FREE(gpe_block->event_info);
@@ -86,10 +96,22 @@ static void acpi_ut_terminate(void)
 			ACPI_FREE(gpe_block);
 
 			gpe_block = next_gpe_block;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		next_gpe_xrupt_info = gpe_xrupt_info->next;
 		ACPI_FREE(gpe_xrupt_info);
 		gpe_xrupt_info = next_gpe_xrupt_info;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return_VOID;
diff -u -p a/acpi/acpica/rsdump.c b/acpi/acpica/rsdump.c
--- a/acpi/acpica/rsdump.c
+++ b/acpi/acpica/rsdump.c
@@ -384,6 +384,11 @@ acpi_rs_dump_descriptor(void *resource,
 
 	count = table->offset;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		previous_target = target;
 		target = ACPI_ADD_PTR(u8, resource, table->offset);
@@ -506,6 +511,12 @@ acpi_rs_dump_descriptor(void *resource,
 
 		table++;
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/acpi/acpica/pstree.c b/acpi/acpica/pstree.c
--- a/acpi/acpica/pstree.c
+++ b/acpi/acpica/pstree.c
@@ -96,9 +96,20 @@ union acpi_parse_object *acpi_ps_get_arg
 	/* Get the requested argument object */
 
 	arg = op->common.value.arg;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (arg && argn) {
 		argn--;
 		arg = arg->common.next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return (arg);
@@ -157,8 +168,19 @@ acpi_ps_append_arg(union acpi_parse_obje
 		/* Append to existing argument list */
 
 		prev_arg = op->common.value.arg;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (prev_arg->common.next) {
 			prev_arg = prev_arg->common.next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		prev_arg->common.next = arg;
 	} else {
@@ -169,11 +191,22 @@ acpi_ps_append_arg(union acpi_parse_obje
 
 	/* Set the parent in this arg and any args linked after it */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (arg) {
 		arg->common.parent = op;
 		arg = arg->common.next;
 
 		op->common.arg_list_length++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -223,10 +256,26 @@ union acpi_parse_object *acpi_ps_get_dep
 
 	parent = op->common.parent;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (parent) {
 		arg = acpi_ps_get_arg(parent, 0);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (arg && (arg != origin) && (arg != op)) {
 			arg = arg->common.next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (arg == origin) {
@@ -245,6 +294,12 @@ union acpi_parse_object *acpi_ps_get_dep
 
 		op = parent;
 		parent = parent->common.parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return (next);
diff -u -p a/acpi/acpica/dsopcode.c b/acpi/acpica/dsopcode.c
--- a/acpi/acpica/dsopcode.c
+++ b/acpi/acpica/dsopcode.c
@@ -730,6 +730,11 @@ acpi_ds_eval_bank_field_operands(struct
 	/* Arg points to the start Bank Field */
 
 	arg = acpi_ps_get_arg(op, 4);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (arg) {
 
 		/* Ignore OFFSET and ACCESSAS terms here */
@@ -749,6 +754,12 @@ acpi_ds_eval_bank_field_operands(struct
 		/* Move to next field in the list */
 
 		arg = arg->common.next;
+		if (_cur < timeout) {
+			    rdstcll(_cur);
+		}
+		else {
+			    break;
+		}
 	}
 
 	acpi_ut_remove_reference(operand_desc);
diff -u -p a/acpi/acpica/pswalk.c b/acpi/acpica/pswalk.c
--- a/acpi/acpica/pswalk.c
+++ b/acpi/acpica/pswalk.c
@@ -69,6 +69,11 @@ void acpi_ps_delete_parse_tree(union acp
 
 	/* Visit all nodes in the subtree */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (op) {
 
 		/* Check if we are not ascending */
@@ -104,6 +109,12 @@ void acpi_ps_delete_parse_tree(union acp
 		} else {
 			op = parent;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return_VOID;
diff -u -p a/acpi/acpica/exutils.c b/acpi/acpica/exutils.c
--- a/acpi/acpica/exutils.c
+++ b/acpi/acpica/exutils.c
@@ -345,10 +345,21 @@ static u32 acpi_ex_digits_needed(u64 val
 
 	/* Count the digits in the requested base */
 
-	while (current_value) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (current_value) {
 		(void)acpi_ut_short_divide(current_value, base, &current_value,
 					   NULL);
 		num_digits++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return_UINT32(num_digits);
diff -u -p a/acpi/acpica/utmisc.c b/acpi/acpica/utmisc.c
--- a/acpi/acpica/utmisc.c
+++ b/acpi/acpica/utmisc.c
@@ -945,6 +945,11 @@ acpi_ut_walk_package_tree(union acpi_ope
 		return_ACPI_STATUS(AE_NO_MEMORY);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (state) {
 
 		/* Get one element of the package */
@@ -973,6 +978,11 @@ acpi_ut_walk_package_tree(union acpi_ope
 			}
 
 			state->pkg.index++;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (state->pkg.index >=
 			       state->pkg.source_object->package.count) {
 				/*
@@ -1001,6 +1011,12 @@ acpi_ut_walk_package_tree(union acpi_ope
 				 * completed package object.
 				 */
 				state->pkg.index++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
 			/* This is a subobject of type package */
@@ -1024,15 +1040,32 @@ acpi_ut_walk_package_tree(union acpi_ope
 
 				/* Free any stacked Update State objects */
 
-				while (state_list) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (state_list) {
 					state =
 					    acpi_ut_pop_generic_state
 					    (&state_list);
 					acpi_ut_delete_generic_state(state);
+					if (_cur < timeout) {
+					    rdstcll(_cur);
+					}
+					else {
+					    break;
+					}
 				}
 				return_ACPI_STATUS(AE_NO_MEMORY);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* We should never get here */
diff -u -p a/acpi/acpica/dsobject.c b/acpi/acpica/dsobject.c
--- a/acpi/acpica/dsobject.c
+++ b/acpi/acpica/dsobject.c
@@ -505,7 +505,12 @@ acpi_ds_build_internal_package_obj(struc
 		 * BIOSs will alter the num_elements on the fly, creating this type
 		 * of ill-formed package object.
 		 */
-		while (arg) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (arg) {
 			/*
 			 * We must delete any package elements that were created earlier
 			 * and are not going to be used because of the package truncation.
@@ -522,6 +527,12 @@ acpi_ds_build_internal_package_obj(struc
 
 			i++;
 			arg = arg->common.next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		ACPI_INFO((AE_INFO,
diff -u -p a/acpi/acpica/exoparg2.c b/acpi/acpica/exoparg2.c
--- a/acpi/acpica/exoparg2.c
+++ b/acpi/acpica/exoparg2.c
@@ -321,10 +321,21 @@ acpi_status acpi_ex_opcode_2A_1T_1R(stru
 		 *       terminated string.
 		 */
 		length = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((length < operand[0]->buffer.length) &&
 		       (length < operand[1]->integer.value) &&
 		       (operand[0]->buffer.pointer[length])) {
 			length++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 
 		/* Allocate a new string object */
diff -u -p a/acpi/acpica/rslist.c b/acpi/acpica/rslist.c
--- a/acpi/acpica/rslist.c
+++ b/acpi/acpica/rslist.c
@@ -141,7 +141,12 @@ acpi_rs_convert_resources_to_aml(struct
 
 	/* Walk the resource descriptor list, convert each descriptor */
 
-	while (aml < end_aml) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (aml < end_aml) {
 
 		/* Validate the (internal) Resource Type */
 
@@ -195,6 +200,12 @@ acpi_rs_convert_resources_to_aml(struct
 		resource =
 		    ACPI_ADD_PTR(struct acpi_resource, resource,
 				 resource->length);
+		    if (_cur < timeout) {
+			rdstcll(_cur);
+		    }
+		    else {
+			break;
+		    }
 	}
 
 	/* Completed buffer, but did not find an end_tag resource descriptor */
diff -u -p a/acpi/acpica/rsmisc.c b/acpi/acpica/rsmisc.c
--- a/acpi/acpica/rsmisc.c
+++ b/acpi/acpica/rsmisc.c
@@ -102,7 +102,12 @@ acpi_rs_convert_aml_to_resource(struct a
 	 */
 	count = INIT_TABLE_LENGTH(info);
 
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		/*
 		 * Source is the external AML byte stream buffer,
 		 * destination is the internal resource descriptor
@@ -292,7 +297,13 @@ acpi_rs_convert_aml_to_resource(struct a
 
 		count--;
 		info++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
       exit:
 	if (!flags_mode) {
@@ -340,6 +351,11 @@ acpi_rs_convert_resource_to_aml(struct a
 	 */
 	count = INIT_TABLE_LENGTH(info);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		/*
 		 * Source is the internal resource descriptor,
@@ -517,6 +533,12 @@ acpi_rs_convert_resource_to_aml(struct a
 
 		count--;
 		info++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
       exit:
diff -u -p a/acpi/acpica/dsfield.c b/acpi/acpica/dsfield.c
--- a/acpi/acpica/dsfield.c
+++ b/acpi/acpica/dsfield.c
@@ -230,6 +230,11 @@ acpi_ds_get_field_names(struct acpi_crea
 
 	/* Process all elements in the field list (of parse nodes) */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (arg) {
 		/*
 		 * Three types of field elements are handled:
@@ -329,6 +334,12 @@ acpi_ds_get_field_names(struct acpi_crea
 		}
 
 		arg = arg->common.next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return_ACPI_STATUS(AE_OK);
@@ -472,6 +483,11 @@ acpi_ds_init_field_objects(union acpi_pa
 	 * Walk the list of entries in the field_list
 	 * Note: field_list can be of zero length. In this case, Arg will be NULL.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (arg) {
 		/*
 		 * Ignore OFFSET and ACCESSAS terms here; we are only interested in the
@@ -500,6 +516,12 @@ acpi_ds_init_field_objects(union acpi_pa
 		/* Get the next field element in the list */
 
 		arg = arg->common.next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return_ACPI_STATUS(AE_OK);
diff -u -p a/acpi/acpica/nsalloc.c b/acpi/acpica/nsalloc.c
--- a/acpi/acpica/nsalloc.c
+++ b/acpi/acpica/nsalloc.c
@@ -166,9 +166,20 @@ void acpi_ns_remove_node(struct acpi_nam
 
 	/* Find the node that is the previous peer in the parent's child list */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_node != node) {
 		prev_node = next_node;
 		next_node = next_node->peer;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (prev_node) {
@@ -250,8 +261,19 @@ void acpi_ns_install_node(struct acpi_wa
 	} else {
 		/* Add node to the end of the peer list */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (child_node->peer) {
 			child_node = child_node->peer;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		child_node->peer = node;
@@ -300,6 +322,11 @@ void acpi_ns_delete_children(struct acpi
 	/* Deallocate all children at this level */
 
 	next_node = parent_node->child;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_node) {
 
 		/* Grandchildren should have all been deleted already */
@@ -316,6 +343,12 @@ void acpi_ns_delete_children(struct acpi
 		node_to_delete = next_node;
 		next_node = next_node->peer;
 		acpi_ns_delete_node(node_to_delete);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	};
 
 	/* Clear the parent's child pointer */
diff -u -p a/acpi/acpica/utdebug.c b/acpi/acpica/utdebug.c
--- a/acpi/acpica/utdebug.c
+++ b/acpi/acpica/utdebug.c
@@ -537,6 +537,11 @@ void acpi_ut_dump_buffer2(u8 * buffer, u
 
 	/* Nasty little dump buffer routine! */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < count) {
 
 		/* Print current offset */
@@ -616,6 +621,12 @@ void acpi_ut_dump_buffer2(u8 * buffer, u
 
 		acpi_os_printf("\n");
 		i += 16;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return;
diff -u -p a/acpi/acpica/nsutils.c b/acpi/acpica/nsutils.c
--- a/acpi/acpica/nsutils.c
+++ b/acpi/acpica/nsutils.c
@@ -224,8 +224,19 @@ void acpi_ns_get_internal_name_length(st
 
 		/* Skip redundant root_prefix, like \\_SB.PCI0.SBRG.EC0 */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (acpi_ns_valid_root_prefix(*next_external_char)) {
 			next_external_char++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		/* Handle Carat prefixes */
diff -u -p a/acpi/acpica/evxfregn.c b/acpi/acpica/evxfregn.c
--- a/acpi/acpica/evxfregn.c
+++ b/acpi/acpica/evxfregn.c
@@ -215,6 +215,11 @@ acpi_remove_address_space_handler(acpi_h
 
 	handler_obj = obj_desc->device.handler;
 	last_obj_ptr = &obj_desc->device.handler;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (handler_obj) {
 
 		/* We have a handler, see if user requested this one */
@@ -241,6 +246,11 @@ acpi_remove_address_space_handler(acpi_h
 
 			/* Walk the handler's region list */
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (region_obj) {
 				/*
 				 * First disassociate the handler from the region.
@@ -258,6 +268,12 @@ acpi_remove_address_space_handler(acpi_h
 				region_obj =
 				    handler_obj->address_space.region_list;
 
+				    if (_cur < timeout) {
+				rdstcll(_cur);
+				    }
+				    else {
+				break;
+				    }
 			}
 
 			/* Remove this Handler object from the list */
@@ -274,6 +290,12 @@ acpi_remove_address_space_handler(acpi_h
 
 		last_obj_ptr = &handler_obj->address_space.next;
 		handler_obj = handler_obj->address_space.next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* The handler does not exist */
diff -u -p a/acpi/acpica/evgpeblk.c b/acpi/acpica/evgpeblk.c
--- a/acpi/acpica/evgpeblk.c
+++ b/acpi/acpica/evgpeblk.c
@@ -98,8 +98,19 @@ acpi_ev_install_gpe_block(struct acpi_gp
 	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
 	if (gpe_xrupt_block->gpe_block_list_head) {
 		next_gpe_block = gpe_xrupt_block->gpe_block_list_head;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (next_gpe_block->next) {
 			next_gpe_block = next_gpe_block->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		next_gpe_block->next = gpe_block;
diff -u -p a/acpi/acpica/utresrc.c b/acpi/acpica/utresrc.c
--- a/acpi/acpica/utresrc.c
+++ b/acpi/acpica/utresrc.c
@@ -280,6 +280,11 @@ acpi_ut_walk_aml_resources(u8 * aml,
 
 	/* Walk the byte list, abort on any invalid descriptor type or length */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (aml < end_aml) {
 
 		/* Validate the Resource Type and Resource Length */
@@ -329,6 +334,12 @@ acpi_ut_walk_aml_resources(u8 * aml,
 
 		aml += length;
 		offset += length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Did not find an end_tag descriptor */
diff -u -p a/acpi/acpica/nsaccess.c b/acpi/acpica/nsaccess.c
--- a/acpi/acpica/nsaccess.c
+++ b/acpi/acpica/nsaccess.c
@@ -524,6 +524,11 @@ acpi_ns_lookup(union acpi_generic_state
 	 */
 	this_search_type = ACPI_TYPE_ANY;
 	current_node = this_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num_segments && current_node) {
 		num_segments--;
 		if (!num_segments) {
@@ -647,6 +652,12 @@ acpi_ns_lookup(union acpi_generic_state
 
 		path += ACPI_NAME_SIZE;
 		current_node = this_node;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Always check if we need to open a new scope */
diff -u -p a/acpi/acpica/evregion.c b/acpi/acpica/evregion.c
--- a/acpi/acpica/evregion.c
+++ b/acpi/acpica/evregion.c
@@ -175,6 +175,11 @@ acpi_ev_has_default_handler(struct acpi_
 
 		/* Walk the linked list of handlers for this object */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (handler_obj) {
 			if (handler_obj->address_space.space_id == space_id) {
 				if (handler_obj->address_space.handler_flags &
@@ -184,6 +189,12 @@ acpi_ev_has_default_handler(struct acpi_
 			}
 
 			handler_obj = handler_obj->address_space.next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -539,6 +550,11 @@ acpi_ev_detach_region(union acpi_operand
 	obj_desc = handler_obj->address_space.region_list;
 	last_obj_ptr = &handler_obj->address_space.region_list;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (obj_desc) {
 
 		/* Is this the correct Region? */
@@ -626,6 +642,12 @@ acpi_ev_detach_region(union acpi_operand
 
 		last_obj_ptr = &obj_desc->region.next;
 		obj_desc = obj_desc->region.next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If we get here, the region was not in the handler's region list */
@@ -754,7 +776,12 @@ acpi_ev_install_handler(acpi_handle obj_
 		/* Check if this Device already has a handler for this address space */
 
 		next_handler_obj = obj_desc->device.handler;
-		while (next_handler_obj) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (next_handler_obj) {
 
 			/* Found a handler, is it for the same address space? */
 
@@ -782,6 +809,12 @@ acpi_ev_install_handler(acpi_handle obj_
 			/* Walk the linked list of handlers attached to this device */
 
 			next_handler_obj = next_handler_obj->address_space.next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/*
@@ -913,6 +946,11 @@ acpi_ev_install_space_handler(struct acp
 
 		/* Walk the handler list for this device */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (handler_obj) {
 
 			/* Same space_id indicates a handler already installed */
@@ -938,6 +976,12 @@ acpi_ev_install_space_handler(struct acp
 			/* Walk the linked list of handlers */
 
 			handler_obj = handler_obj->address_space.next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
@@ -1214,6 +1258,11 @@ static void acpi_ev_orphan_ec_reg_method
 	 * execute the _REG method with the EC space ID argument.
 	 */
 	next_node = acpi_ns_get_next_node(ec_device_node, NULL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_node) {
 		if ((next_node->type == ACPI_TYPE_REGION) &&
 		    (next_node->object) &&
@@ -1221,6 +1270,12 @@ static void acpi_ev_orphan_ec_reg_method
 			goto exit;	/* Do not execute _REG */
 		}
 		next_node = acpi_ns_get_next_node(ec_device_node, next_node);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Evaluate the _REG(EC,Connect) method */
diff -u -p a/acpi/acpica/dswscope.c b/acpi/acpica/dswscope.c
--- a/acpi/acpica/dswscope.c
+++ b/acpi/acpica/dswscope.c
@@ -66,7 +66,12 @@ void acpi_ds_scope_stack_clear(struct ac
 
 	ACPI_FUNCTION_NAME(ds_scope_stack_clear);
 
-	while (walk_state->scope_info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (walk_state->scope_info) {
 
 		/* Pop a scope off the stack */
 
@@ -78,6 +83,12 @@ void acpi_ds_scope_stack_clear(struct ac
 				  acpi_ut_get_type_name(scope_info->common.
 							value)));
 		acpi_ut_delete_generic_state(scope_info);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/acpi/acpica/nssearch.c b/acpi/acpica/nssearch.c
--- a/acpi/acpica/nssearch.c
+++ b/acpi/acpica/nssearch.c
@@ -123,6 +123,11 @@ acpi_ns_search_one_scope(u32 target_name
 	 * must search for the name among the children of this object
 	 */
 	node = parent_node->child;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (node) {
 
 		/* Check for match against the name */
@@ -155,6 +160,12 @@ acpi_ns_search_one_scope(u32 target_name
 		/* Didn't match name, move on to the next peer object */
 
 		node = node->peer;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Searched entire namespace level, not found */
@@ -235,7 +246,12 @@ acpi_ns_search_parent_tree(u32 target_na
 
 	/* Search parents until target is found or we have backed up to the root */
 
-	while (parent_node) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (parent_node) {
 		/*
 		 * Search parent scope. Use TYPE_ANY because we don't care about the
 		 * object type at this point, we only care about the existence of
@@ -251,6 +267,12 @@ acpi_ns_search_parent_tree(u32 target_na
 		/* Not found here, go up another level (until we reach the root) */
 
 		parent_node = parent_node->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Not found in parent tree */
diff -u -p a/acpi/acpica/evgpe.c b/acpi/acpica/evgpe.c
--- a/acpi/acpica/evgpe.c
+++ b/acpi/acpica/evgpe.c
@@ -362,6 +362,11 @@ u32 acpi_ev_gpe_detect(struct acpi_gpe_x
 	/* Examine all GPE blocks attached to this interrupt level */
 
 	gpe_block = gpe_xrupt_list->gpe_block_list_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (gpe_block) {
 		/*
 		 * Read all of the 8-bit GPE status and enable registers in this GPE
@@ -436,6 +441,12 @@ u32 acpi_ev_gpe_detect(struct acpi_gpe_x
 		}
 
 		gpe_block = gpe_block->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
       unlock_and_exit:
@@ -523,11 +534,22 @@ static void ACPI_SYSTEM_XFACE acpi_ev_as
 				ACPI_NOTIFY_DEVICE_WAKE);
 
 		notify_object = local_gpe_event_info->dispatch.device.next;
-		while (ACPI_SUCCESS(status) && notify_object) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (ACPI_SUCCESS(status) && notify_object) {
 			status = acpi_ev_queue_notify_request(
 					notify_object->node,
 					ACPI_NOTIFY_DEVICE_WAKE);
 			notify_object = notify_object->next;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		break;
diff -u -p a/acpi/acpica/tbutils.c b/acpi/acpica/tbutils.c
--- a/acpi/acpica/tbutils.c
+++ b/acpi/acpica/tbutils.c
@@ -182,12 +182,23 @@ u8 acpi_tb_tables_loaded(void)
 static void acpi_tb_fix_string(char *string, acpi_size length)
 {
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (length && *string) {
 		if (!ACPI_IS_PRINT(*string)) {
 			*string = '?';
 		}
 		string++;
 		length--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -340,8 +351,19 @@ u8 acpi_tb_checksum(u8 *buffer, u32 leng
 	u8 sum = 0;
 	u8 *end = buffer + length;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (buffer < end) {
 		sum = (u8) (sum + *(buffer++));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return sum;
diff -u -p a/acpi/acpica/psparse.c b/acpi/acpica/psparse.c
--- a/acpi/acpica/psparse.c
+++ b/acpi/acpica/psparse.c
@@ -269,32 +269,44 @@ acpi_ps_complete_this_op(struct acpi_wal
 
 		/* Search the parent list */
 
-		else
-			while (prev) {
+		else {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (prev) {
 
 				/* Traverse all siblings in the parent's argument list */
 
-				next = prev->common.next;
-				if (next == op) {
-					if (replacement_op) {
-						replacement_op->common.parent =
-						    op->common.parent;
-						replacement_op->common.value.
+					next = prev->common.next;
+					if (next == op) {
+						if (replacement_op) {
+				    replacement_op->common.parent =
+				    op->common.parent;
+						    replacement_op->common.value.
 						    arg = NULL;
-						replacement_op->common.node =
+						    replacement_op->common.node =
 						    op->common.node;
-						prev->common.next =
+						    prev->common.next =
 						    replacement_op;
-						replacement_op->common.next =
+						    replacement_op->common.next =
 						    op->common.next;
-						next = NULL;
-					} else {
-						prev->common.next =
+						    next = NULL;
+						} else {
+						    prev->common.next =
 						    op->common.next;
-						next = NULL;
+						    next = NULL;
+						}
+					}
+					prev = next;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
 					}
 				}
-				prev = next;
 			}
 	}
 
@@ -493,7 +505,12 @@ acpi_status acpi_ps_parse_aml(struct acp
 	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "State=%p\n", walk_state));
 
 	status = AE_OK;
-	while (walk_state) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (walk_state) {
 		if (ACPI_SUCCESS(status)) {
 			/*
 			 * The parse_loop executes AML until the method terminates
@@ -676,6 +693,12 @@ acpi_status acpi_ps_parse_aml(struct acp
 		}
 
 		acpi_ds_delete_walk_state(previous_walk_state);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Normal exit */
diff -u -p a/acpi/acpica/dsutils.c b/acpi/acpica/dsutils.c
--- a/acpi/acpica/dsutils.c
+++ b/acpi/acpica/dsutils.c
@@ -712,6 +712,11 @@ acpi_ds_create_operands(struct acpi_walk
 	/* Get all arguments in the list */
 
 	arg = first_arg;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (arg) {
 		if (index >= ACPI_OBJ_NUM_OPERANDS) {
 			return_ACPI_STATUS(AE_BAD_DATA);
@@ -725,6 +730,12 @@ acpi_ds_create_operands(struct acpi_walk
 		arg = arg->common.next;
 		arg_count++;
 		index++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	index--;
diff -u -p a/acpi/acpica/evgpeinit.c b/acpi/acpica/evgpeinit.c
--- a/acpi/acpica/evgpeinit.c
+++ b/acpi/acpica/evgpeinit.c
@@ -258,12 +258,22 @@ void acpi_ev_update_gpes(acpi_owner_id t
 	/* Walk the interrupt level descriptor list */
 
 	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (gpe_xrupt_info) {
 
 		/* Walk all Gpe Blocks attached to this interrupt level */
 
 		gpe_block = gpe_xrupt_info->gpe_block_list_head;
-		while (gpe_block) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (gpe_block) {
 			walk_info.gpe_block = gpe_block;
 			walk_info.gpe_device = gpe_block->node;
 
@@ -279,9 +289,21 @@ void acpi_ev_update_gpes(acpi_owner_id t
 			}
 
 			gpe_block = gpe_block->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		gpe_xrupt_info = gpe_xrupt_info->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (walk_info.count) {
diff -u -p a/acpi/acpica/nsdump.c b/acpi/acpica/nsdump.c
--- a/acpi/acpica/nsdump.c
+++ b/acpi/acpica/nsdump.c
@@ -86,6 +86,11 @@ void acpi_ns_print_pathname(u32 num_segm
 
 	ACPI_DEBUG_PRINT((ACPI_DB_NAMES, "["));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num_segments) {
 		for (i = 0; i < 4; i++) {
 			ACPI_IS_PRINT(pathname[i]) ?
@@ -98,6 +103,12 @@ void acpi_ns_print_pathname(u32 num_segm
 		if (num_segments) {
 			acpi_os_printf(".");
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	acpi_os_printf("]\n");
@@ -498,6 +509,11 @@ acpi_ns_dump_one_object(acpi_handle obj_
 
 	/* Dump attached objects */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (obj_desc) {
 		obj_type = ACPI_TYPE_INVALID;
 		acpi_os_printf("Attached Object %p: ", obj_desc);
@@ -590,6 +606,12 @@ acpi_ns_dump_one_object(acpi_handle obj_
 		}
 
 		obj_type = ACPI_TYPE_INVALID;	/* Terminate loop after next pass */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
       cleanup:
diff -u -p a/acpi/acpica/nspredef.c b/acpi/acpica/nspredef.c
--- a/acpi/acpica/nspredef.c
+++ b/acpi/acpica/nspredef.c
@@ -387,6 +387,11 @@ const union acpi_predefined_info *acpi_n
 	/* Search info table for a predefined method/object name */
 
 	this_name = predefined_names;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (this_name->info.name[0]) {
 		if (ACPI_COMPARE_NAME(node->name.ascii, this_name->info.name)) {
 			return (this_name);
@@ -401,6 +406,12 @@ const union acpi_predefined_info *acpi_n
 		}
 
 		this_name++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return (NULL);		/* Not found */
diff -u -p a/acpi/acpica/nseval.c b/acpi/acpica/nseval.c
--- a/acpi/acpica/nseval.c
+++ b/acpi/acpica/nseval.c
@@ -152,11 +152,22 @@ acpi_status acpi_ns_evaluate(struct acpi
 		/* Count the number of arguments being passed to the method */
 
 		if (info->parameters) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (info->parameters[info->param_count]) {
 				if (info->param_count > ACPI_METHOD_MAX_ARG) {
 					return_ACPI_STATUS(AE_LIMIT);
 				}
 				info->param_count++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
@@ -322,6 +333,11 @@ void acpi_ns_exec_module_code_list(void)
 
 	/* Walk the list, executing each "method" */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next) {
 		prev = next;
 		next = next->method.mutex;
@@ -335,6 +351,12 @@ void acpi_ns_exec_module_code_list(void)
 		/* Delete the (temporary) method object */
 
 		acpi_ut_remove_reference(prev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ACPI_INFO((AE_INFO,
diff -u -p a/acpi/acpica/dswstate.c b/acpi/acpica/dswstate.c
--- a/acpi/acpica/dswstate.c
+++ b/acpi/acpica/dswstate.c
@@ -657,8 +657,19 @@ acpi_ds_init_aml_walk(struct acpi_walk_s
 		 * Op with a namespace node.
 		 */
 		extra_op = parser_state->start_op;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (extra_op && !extra_op->common.node) {
 			extra_op = extra_op->common.parent;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		if (!extra_op) {
@@ -723,29 +734,62 @@ void acpi_ds_delete_walk_state(struct ac
 
 	/* Always must free any linked control states */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (walk_state->control_state) {
 		state = walk_state->control_state;
 		walk_state->control_state = state->common.next;
 
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Always must free any linked parse states */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (walk_state->scope_info) {
 		state = walk_state->scope_info;
 		walk_state->scope_info = state->common.next;
 
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Always must free any stacked result states */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (walk_state->results) {
 		state = walk_state->results;
 		walk_state->results = state->common.next;
 
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	ACPI_FREE(walk_state);
diff -u -p a/acpi/acpica/nsrepair2.c b/acpi/acpica/nsrepair2.c
--- a/acpi/acpica/nsrepair2.c
+++ b/acpi/acpica/nsrepair2.c
@@ -204,11 +204,22 @@ static const struct acpi_repair_info *ac
 	/* Search info table for a repairable predefined method/object name */
 
 	this_name = acpi_ns_repairable_names;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (this_name->repair_function) {
 		if (ACPI_COMPARE_NAME(node->name.ascii, this_name->name)) {
 			return (this_name);
 		}
 		this_name++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return (NULL);		/* Not found */
diff -u -p a/acpi/acpica/nsobject.c b/acpi/acpica/nsobject.c
--- a/acpi/acpica/nsobject.c
+++ b/acpi/acpica/nsobject.c
@@ -172,8 +172,19 @@ acpi_ns_attach_object(struct acpi_namesp
 		 * to the end of the descriptor list
 		 */
 		last_obj_desc = obj_desc;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (last_obj_desc->common.next_object) {
 			last_obj_desc = last_obj_desc->common.next_object;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 
 		/* Install the object at the front of the object list */
@@ -337,6 +348,11 @@ acpi_ns_attach_data(struct acpi_namespac
 
 	prev_obj_desc = NULL;
 	obj_desc = node->object;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (obj_desc) {
 		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
 		    (obj_desc->data.handler == handler)) {
@@ -345,6 +361,12 @@ acpi_ns_attach_data(struct acpi_namespac
 
 		prev_obj_desc = obj_desc;
 		obj_desc = obj_desc->common.next_object;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Create an internal object for the data */
@@ -391,6 +413,11 @@ acpi_ns_detach_data(struct acpi_namespac
 
 	prev_obj_desc = NULL;
 	obj_desc = node->object;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (obj_desc) {
 		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
 		    (obj_desc->data.handler == handler)) {
@@ -407,6 +434,12 @@ acpi_ns_detach_data(struct acpi_namespac
 
 		prev_obj_desc = obj_desc;
 		obj_desc = obj_desc->common.next_object;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return (AE_NOT_FOUND);
@@ -434,6 +467,11 @@ acpi_ns_get_attached_data(struct acpi_na
 	union acpi_operand_object *obj_desc;
 
 	obj_desc = node->object;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (obj_desc) {
 		if ((obj_desc->common.type == ACPI_TYPE_LOCAL_DATA) &&
 		    (obj_desc->data.handler == handler)) {
@@ -442,6 +480,12 @@ acpi_ns_get_attached_data(struct acpi_na
 		}
 
 		obj_desc = obj_desc->common.next_object;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return (AE_NOT_FOUND);
diff -u -p a/acpi/acpica/nsinit.c b/acpi/acpica/nsinit.c
--- a/acpi/acpica/nsinit.c
+++ b/acpi/acpica/nsinit.c
@@ -418,9 +418,20 @@ acpi_ns_find_ini_methods(acpi_handle obj
 
 		/* Mark parent and bubble up the INI present flag to the root */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (parent_node) {
 			parent_node->flags |= ANOBJ_SUBTREE_HAS_INI;
 			parent_node = parent_node->parent;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 
diff -u -p a/acpi/acpica/evgpeutil.c b/acpi/acpica/evgpeutil.c
--- a/acpi/acpica/evgpeutil.c
+++ b/acpi/acpica/evgpeutil.c
@@ -75,12 +75,22 @@ acpi_ev_walk_gpe_list(acpi_gpe_callback
 	/* Walk the interrupt level descriptor list */
 
 	gpe_xrupt_info = acpi_gbl_gpe_xrupt_list_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (gpe_xrupt_info) {
 
 		/* Walk all Gpe Blocks attached to this interrupt level */
 
 		gpe_block = gpe_xrupt_info->gpe_block_list_head;
-		while (gpe_block) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (gpe_block) {
 
 			/* One callback per GPE block */
 
@@ -95,9 +105,21 @@ acpi_ev_walk_gpe_list(acpi_gpe_callback
 			}
 
 			gpe_block = gpe_block->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		gpe_xrupt_info = gpe_xrupt_info->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
       unlock_and_exit:
@@ -131,11 +153,21 @@ u8 acpi_ev_valid_gpe_event(struct acpi_g
 	/* Walk the GPE interrupt levels */
 
 	gpe_xrupt_block = acpi_gbl_gpe_xrupt_list_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (gpe_xrupt_block) {
 		gpe_block = gpe_xrupt_block->gpe_block_list_head;
 
 		/* Walk the GPE blocks on this interrupt level */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (gpe_block) {
 			if ((&gpe_block->event_info[0] <= gpe_event_info) &&
 			    (&gpe_block->event_info[gpe_block->gpe_count] >
@@ -144,9 +176,21 @@ u8 acpi_ev_valid_gpe_event(struct acpi_g
 			}
 
 			gpe_block = gpe_block->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		gpe_xrupt_block = gpe_xrupt_block->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return (FALSE);
@@ -218,12 +262,23 @@ struct acpi_gpe_xrupt_info *acpi_ev_get_
 	/* No need for lock since we are not changing any list elements here */
 
 	next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_gpe_xrupt) {
 		if (next_gpe_xrupt->interrupt_number == interrupt_number) {
 			return_PTR(next_gpe_xrupt);
 		}
 
 		next_gpe_xrupt = next_gpe_xrupt->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Not found, must allocate a new xrupt descriptor */
@@ -240,8 +295,19 @@ struct acpi_gpe_xrupt_info *acpi_ev_get_
 	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
 	if (acpi_gbl_gpe_xrupt_list_head) {
 		next_gpe_xrupt = acpi_gbl_gpe_xrupt_list_head;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (next_gpe_xrupt->next) {
 			next_gpe_xrupt = next_gpe_xrupt->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		next_gpe_xrupt->next = gpe_xrupt;
diff -u -p a/acpi/acpica/evmisc.c b/acpi/acpica/evmisc.c
--- a/acpi/acpica/evmisc.c
+++ b/acpi/acpica/evmisc.c
@@ -257,11 +257,22 @@ static void ACPI_SYSTEM_XFACE acpi_ev_no
 		struct acpi_object_notify_handler *notifier;
 
 		notifier = &handler_obj->notify;
-		while (notifier) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (notifier) {
 			notifier->handler(notify_info->notify.node,
 					  notify_info->notify.value,
 					  notifier->context);
 			notifier = notifier->next;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
diff -u -p a/acpi/acpica/evrgnini.c b/acpi/acpica/evrgnini.c
--- a/acpi/acpica/evrgnini.c
+++ b/acpi/acpica/evrgnini.c
@@ -555,6 +555,11 @@ acpi_ev_initialize_region(union acpi_ope
 	 * The following loop depends upon the root Node having no parent
 	 * ie: acpi_gbl_root_node->parent_entry being set to NULL
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (node) {
 
 		/* Check to see if a handler exists */
@@ -601,7 +606,12 @@ acpi_ev_initialize_region(union acpi_ope
 				break;
 			}
 
-			while (handler_obj) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+					while (handler_obj) {
 
 				/* Is this handler of the correct type? */
 
@@ -655,12 +665,24 @@ acpi_ev_initialize_region(union acpi_ope
 				/* Try next handler in the list */
 
 				handler_obj = handler_obj->address_space.next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
 		/* This node does not have the handler we need; Pop up one level */
 
 		node = node->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If we get here, there is no handler for this region */
diff -u -p a/acpi/acpica/utosi.c b/acpi/acpica/utosi.c
--- a/acpi/acpica/utosi.c
+++ b/acpi/acpica/utosi.c
@@ -145,6 +145,11 @@ void acpi_ut_interface_terminate(void)
 	(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);
 	next_interface = acpi_gbl_supported_interfaces;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_interface) {
 		acpi_gbl_supported_interfaces = next_interface->next;
 
@@ -156,6 +161,12 @@ void acpi_ut_interface_terminate(void)
 		}
 
 		next_interface = acpi_gbl_supported_interfaces;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	acpi_os_release_mutex(acpi_gbl_osi_mutex);
@@ -222,6 +233,11 @@ acpi_status acpi_ut_remove_interface(acp
 	struct acpi_interface_info *next_interface;
 
 	previous_interface = next_interface = acpi_gbl_supported_interfaces;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_interface) {
 		if (!ACPI_STRCMP(interface_name, next_interface->name)) {
 
@@ -258,6 +274,12 @@ acpi_status acpi_ut_remove_interface(acp
 
 		previous_interface = next_interface;
 		next_interface = next_interface->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Interface was not found */
@@ -283,12 +305,23 @@ struct acpi_interface_info *acpi_ut_get_
 	struct acpi_interface_info *next_interface;
 
 	next_interface = acpi_gbl_supported_interfaces;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_interface) {
 		if (!ACPI_STRCMP(interface_name, next_interface->name)) {
 			return (next_interface);
 		}
 
 		next_interface = next_interface->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return (NULL);
diff -u -p a/acpi/acpica/nswalk.c b/acpi/acpica/nswalk.c
--- a/acpi/acpica/nswalk.c
+++ b/acpi/acpica/nswalk.c
@@ -129,6 +129,11 @@ struct acpi_namespace_node *acpi_ns_get_
 
 	/* Must search for the node -- but within this scope only */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_node) {
 
 		/* If type matches, we are done */
@@ -140,6 +145,12 @@ struct acpi_namespace_node *acpi_ns_get_
 		/* Otherwise, move on to the next peer node */
 
 		next_node = next_node->peer;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Not found */
diff -u -p a/acpi/acpica/psargs.c b/acpi/acpica/psargs.c
--- a/acpi/acpica/psargs.c
+++ b/acpi/acpica/psargs.c
@@ -91,6 +91,11 @@ acpi_ps_get_next_package_length(struct a
 
 	/* Get bytes 3, 2, 1 as needed */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (byte_count) {
 		/*
 		 * Final bit positions for the package length bytes:
@@ -103,6 +108,12 @@ acpi_ps_get_next_package_length(struct a
 
 		byte_zero_mask = 0x0F;	/* Use bits [0:3] of byte 0 */
 		byte_count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Byte 0 is a special case, either bits [0:3] or [0:5] are used */
@@ -162,8 +173,19 @@ char *acpi_ps_get_next_namestring(struct
 
 	/* Point past any namestring prefix characters (backslash or carat) */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (acpi_ps_is_prefix_char(*end)) {
 		end++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+	}
+	else {
+			break;
+	}
 	}
 
 	/* Decode the path prefix character */
@@ -444,8 +466,19 @@ acpi_ps_get_next_simple_arg(struct acpi_
 		/* Find the null terminator */
 
 		length = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (aml[length]) {
 			length++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		length++;
 		break;
@@ -630,6 +663,11 @@ acpi_ps_get_next_arg(struct acpi_walk_st
 
 			/* Non-empty list */
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (parser_state->aml < parser_state->pkg_end) {
 				field = acpi_ps_get_next_field(parser_state);
 				if (!field) {
@@ -642,6 +680,12 @@ acpi_ps_get_next_arg(struct acpi_walk_st
 					arg = field;
 				}
 				prev = field;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			/* Skip to End of byte data */
diff -u -p a/acpi/acpica/utdelete.c b/acpi/acpica/utdelete.c
--- a/acpi/acpica/utdelete.c
+++ b/acpi/acpica/utdelete.c
@@ -155,10 +155,21 @@ static void acpi_ut_delete_internal_obj(
 		/* Walk the notify handler list for this object */
 
 		handler_desc = object->common_notify.handler;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (handler_desc) {
 			next_desc = handler_desc->address_space.next;
 			acpi_ut_remove_reference(handler_desc);
 			handler_desc = next_desc;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		break;
 
@@ -482,7 +493,12 @@ acpi_ut_update_object_reference(union ac
 
 	ACPI_FUNCTION_TRACE_PTR(ut_update_object_reference, object);
 
-	while (object) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (object) {
 
 		/* Make sure that this isn't a namespace handle */
 
@@ -604,6 +620,12 @@ acpi_ut_update_object_reference(union ac
 			object = state->update.object;
 			acpi_ut_delete_generic_state(state);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return_ACPI_STATUS(AE_OK);
@@ -615,9 +637,20 @@ acpi_ut_update_object_reference(union ac
 
 	/* Free any stacked Update State objects */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (state_list) {
 		state = acpi_ut_pop_generic_state(&state_list);
 		acpi_ut_delete_generic_state(state);
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 
 	return_ACPI_STATUS(status);
diff -u -p a/acpi/acpica/exdump.c b/acpi/acpica/exdump.c
--- a/acpi/acpica/exdump.c
+++ b/acpi/acpica/exdump.c
@@ -343,7 +343,12 @@ acpi_ex_dump_object(union acpi_operand_o
 
 	count = info->offset;
 
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (count) {
 		target = ACPI_ADD_PTR(u8, obj_desc, info->offset);
 		name = info->name;
 
@@ -433,6 +438,12 @@ acpi_ex_dump_object(union acpi_operand_o
 
 		info++;
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -751,10 +762,21 @@ acpi_ex_dump_operands(union acpi_operand
 
 	/* Dump the individual operands */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num_operands) {
 		acpi_ex_dump_operand(*operands, 0);
 		operands++;
 		num_operands--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
diff -u -p a/acpi/acpica/hwpci.c b/acpi/acpica/hwpci.c
--- a/acpi/acpica/hwpci.c
+++ b/acpi/acpica/hwpci.c
@@ -184,6 +184,11 @@ acpi_hw_build_pci_list(acpi_handle root_
 	 * found, or the root of the namespace is reached.
 	 */
 	current_device = pci_region;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		status = acpi_get_parent(current_device, &parent_device);
 		if (ACPI_FAILURE(status)) {
@@ -209,6 +214,12 @@ acpi_hw_build_pci_list(acpi_handle root_
 		list_head = list_element;
 
 		current_device = parent_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -255,7 +266,12 @@ acpi_hw_process_pci_list(struct acpi_pci
 	 * to the PCI ID for the target device.
 	 */
 	info = list_head;
-	while (info) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (info) {
 		status = acpi_hw_get_pci_device_info(pci_id, info->device,
 						     &bus_number, &is_bridge);
 		if (ACPI_FAILURE(status)) {
@@ -263,6 +279,12 @@ acpi_hw_process_pci_list(struct acpi_pci
 		}
 
 		info = info->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
@@ -293,10 +315,21 @@ static void acpi_hw_delete_pci_list(stru
 	struct acpi_pci_device *previous;
 
 	next = list_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next) {
 		previous = next;
 		next = previous->next;
 		ACPI_FREE(previous);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/acpi/acpica/psscope.c b/acpi/acpica/psscope.c
--- a/acpi/acpica/psscope.c
+++ b/acpi/acpica/psscope.c
@@ -256,9 +256,20 @@ void acpi_ps_cleanup_scope(struct acpi_p
 
 	/* Delete anything on the scope stack */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (parser_state->scope) {
 		scope = acpi_ut_pop_generic_state(&parser_state->scope);
 		acpi_ut_delete_generic_state(scope);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return_VOID;
diff -u -p a/acpi/acpica/nsnames.c b/acpi/acpica/nsnames.c
--- a/acpi/acpica/nsnames.c
+++ b/acpi/acpica/nsnames.c
@@ -190,7 +190,12 @@ acpi_size acpi_ns_get_pathname_length(st
 	size = 0;
 	next_node = node;
 
-	while (next_node && (next_node != acpi_gbl_root_node)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (next_node && (next_node != acpi_gbl_root_node)) {
 		if (ACPI_GET_DESCRIPTOR_TYPE(next_node) != ACPI_DESC_TYPE_NAMED) {
 			ACPI_ERROR((AE_INFO,
 				    "Invalid Namespace Node (%p) while traversing namespace",
@@ -199,6 +204,12 @@ acpi_size acpi_ns_get_pathname_length(st
 		}
 		size += ACPI_PATH_SEGMENT_LENGTH;
 		next_node = next_node->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!size) {
diff -u -p a/acpi/acpica/exmutex.c b/acpi/acpica/exmutex.c
--- a/acpi/acpica/exmutex.c
+++ b/acpi/acpica/exmutex.c
@@ -466,6 +466,11 @@ void acpi_ex_release_all_mutexes(struct
 
 	/* Traverse the list of owned mutexes, releasing each one */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next) {
 		obj_desc = next;
 		next = obj_desc->mutex.next;
@@ -494,5 +499,11 @@ void acpi_ex_release_all_mutexes(struct
 
 		thread->current_sync_level =
 		    obj_desc->mutex.original_sync_level;
+		    if (_cur < timeout) {
+			rdstcll(_cur);
+		    }
+		    else {
+			break;
+		    }
 	}
 }
diff -u -p a/acpi/acpica/psloop.c b/acpi/acpica/psloop.c
--- a/acpi/acpica/psloop.c
+++ b/acpi/acpica/psloop.c
@@ -430,7 +430,12 @@ acpi_ps_get_arguments(struct acpi_walk_s
 		/*
 		 * Op is not a constant or string, append each argument to the Op
 		 */
-		while (GET_CURRENT_ARG_TYPE(walk_state->arg_types)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (GET_CURRENT_ARG_TYPE(walk_state->arg_types)
 		       && !walk_state->arg_count) {
 			walk_state->aml_offset =
 			    (u32) ACPI_PTR_DIFF(walk_state->parser_state.aml,
@@ -452,6 +457,12 @@ acpi_ps_get_arguments(struct acpi_walk_s
 			}
 
 			INCREMENT_ARG_LIST(walk_state->arg_types);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/*
@@ -627,9 +638,20 @@ acpi_ps_link_module_code(union acpi_pars
 	/* Get the tail of the list */
 
 	prev = next = acpi_gbl_module_code_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next) {
 		prev = next;
 		next = next->method.mutex;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -1050,6 +1072,11 @@ acpi_status acpi_ps_parse_loop(struct ac
 
 	/* Iterative parsing loop, while there is more AML to process: */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((parser_state->aml < parser_state->aml_end) || (op)) {
 		aml_op_start = parser_state->aml;
 		if (!op) {
@@ -1203,6 +1230,12 @@ acpi_status acpi_ps_parse_loop(struct ac
 			return_ACPI_STATUS(status);
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}			/* while parser_state->Aml */
 
 	status = acpi_ps_complete_final_op(walk_state, op, status);
diff -u -p a/acpi/acpica/nsrepair.c b/acpi/acpica/nsrepair.c
--- a/acpi/acpica/nsrepair.c
+++ b/acpi/acpica/nsrepair.c
@@ -320,9 +320,20 @@ acpi_ns_convert_to_string(union acpi_ope
 		 * the battery is often (incorrectly) returned as buffer object(s).
 		 */
 		length = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((length < original_object->buffer.length) &&
 		       (original_object->buffer.pointer[length])) {
 			length++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		/* Allocate a new string object */
diff -u -p a/acpi/acpica/rscalc.c b/acpi/acpica/rscalc.c
--- a/acpi/acpica/rscalc.c
+++ b/acpi/acpica/rscalc.c
@@ -194,6 +194,11 @@ acpi_rs_get_aml_length(struct acpi_resou
 
 	/* Traverse entire list of internal resource descriptors */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (resource) {
 
 		/* Validate the descriptor type */
@@ -326,6 +331,12 @@ acpi_rs_get_aml_length(struct acpi_resou
 		resource =
 		    ACPI_ADD_PTR(struct acpi_resource, resource,
 				 resource->length);
+		    if (_cur < timeout) {
+			rdstcll(_cur);
+		    }
+		    else {
+			break;
+		    }
 	}
 
 	/* Did not find an end_tag resource descriptor */
@@ -370,7 +381,12 @@ acpi_rs_get_list_length(u8 * aml_buffer,
 
 	/* Walk the list of AML resource descriptors */
 
-	while (aml_buffer < end_aml) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (aml_buffer < end_aml) {
 
 		/* Validate the Resource Type and Resource Length */
 
@@ -484,6 +500,12 @@ acpi_rs_get_list_length(u8 * aml_buffer,
 		 * contained in the resource descriptor header
 		 */
 		aml_buffer += acpi_ut_get_descriptor_length(aml_buffer);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Did not find an end_tag resource descriptor */
diff -u -p a/acpi/tables.c b/acpi/tables.c
--- a/acpi/tables.c
+++ b/acpi/tables.c
@@ -236,6 +236,11 @@ acpi_table_parse_entries(char *id,
 	entry = (struct acpi_subtable_header *)
 	    ((unsigned long)table_header + table_size);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (((unsigned long)entry) + sizeof(struct acpi_subtable_header) <
 	       table_end) {
 		if (entry->type == entry_id
@@ -247,6 +252,12 @@ acpi_table_parse_entries(char *id,
 
 		entry = (struct acpi_subtable_header *)
 		    ((unsigned long)entry + entry->length);
+		    if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (max_entries && count > max_entries) {
 		printk(KERN_WARNING PREFIX "[%4.4s:0x%02x] ignored %i entries of "
diff -u -p a/acpi/acpi_pad.c b/acpi/acpi_pad.c
--- a/acpi/acpi_pad.c
+++ b/acpi/acpi_pad.c
@@ -155,6 +155,11 @@ static int power_saving_thread(void *dat
 
 	sched_setscheduler(current, SCHED_RR, &param);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		int cpu;
 		u64 expire_time;
@@ -221,6 +226,12 @@ static int power_saving_thread(void *dat
 		 */
 		if (do_sleep)
 			schedule_timeout_killable(HZ * idle_pct / 100);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	exit_round_robin(tsk_index);
@@ -257,9 +268,20 @@ static void destroy_power_saving_task(vo
 static void set_power_saving_task_num(unsigned int num)
 {
 	if (num > ps_tsk_num) {
-		while (ps_tsk_num < num) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while (ps_tsk_num < num) {
 			if (create_power_saving_task())
 				return;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+			}
 		}
 	} else if (num < ps_tsk_num) {
 		while (ps_tsk_num > num)
diff -u -p a/acpi/pci_irq.c b/acpi/pci_irq.c
--- a/acpi/pci_irq.c
+++ b/acpi/pci_irq.c
@@ -379,6 +379,11 @@ static struct acpi_prt_entry *acpi_pci_i
 	 * PCI interrupt routing entry (eg. yenta bridge and add-in card bridge).
 	 */
 	bridge = dev->bus->self;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bridge) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 
@@ -405,6 +410,12 @@ static struct acpi_prt_entry *acpi_pci_i
 
 		dev = bridge;
 		bridge = dev->bus->self;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dev_warn(&dev->dev, "can't derive routing for PCI INT %c\n",
diff -u -p a/acpi/ec_sys.c b/acpi/ec_sys.c
--- a/acpi/ec_sys.c
+++ b/acpi/ec_sys.c
@@ -52,12 +52,23 @@ static ssize_t acpi_ec_read_io(struct fi
 	} else
 		size = count;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		err = ec_read(*off, &data[*off - init_off]);
 		if (err)
 			return err;
 		*off += 1;
 		size--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return count;
 }
@@ -81,6 +92,11 @@ static ssize_t acpi_ec_write_io(struct f
 		count = size;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		u8 byte_write = data[*off - init_off];
 		err = ec_write(*off, byte_write);
@@ -89,6 +105,12 @@ static ssize_t acpi_ec_write_io(struct f
 
 		*off += 1;
 		size--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return count;
 }
diff -u -p a/base/isa.c b/base/isa.c
--- a/base/isa.c
+++ b/base/isa.c
@@ -102,10 +102,21 @@ void isa_unregister_driver(struct isa_dr
 {
 	struct device *dev = isa_driver->devices;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dev) {
 		struct device *tmp = to_isa_dev(dev)->next;
 		device_unregister(dev);
 		dev = tmp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	driver_unregister(&isa_driver->driver);
 }
diff -u -p a/base/power/wakeup.c b/base/power/wakeup.c
--- a/base/power/wakeup.c
+++ b/base/power/wakeup.c
@@ -82,12 +82,23 @@ void wakeup_source_destroy(struct wakeup
 		return;
 
 	spin_lock_irq(&ws->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ws->active) {
 		spin_unlock_irq(&ws->lock);
 
 		schedule_timeout_interruptible(msecs_to_jiffies(TIMEOUT));
 
 		spin_lock_irq(&ws->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irq(&ws->lock);
 
diff -u -p a/base/power/trace.c b/base/power/trace.c
--- a/base/power/trace.c
+++ b/base/power/trace.c
@@ -193,6 +193,11 @@ static int show_dev_hash(unsigned int va
 
 	device_pm_lock();
 	entry = dpm_list.prev;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (entry != &dpm_list) {
 		struct device * dev = to_device(entry);
 		unsigned int hash = hash_string(DEVSEED, dev_name(dev), DEVHASH);
@@ -201,6 +206,12 @@ static int show_dev_hash(unsigned int va
 			match++;
 		}
 		entry = entry->prev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	device_pm_unlock();
 	return match;
@@ -220,7 +231,12 @@ int show_trace_dev_match(char *buf, size
 	 */
 	device_pm_lock();
 	entry = dpm_list.prev;
-	while (size && entry != &dpm_list) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size && entry != &dpm_list) {
 		struct device *dev = to_device(entry);
 		unsigned int hash = hash_string(DEVSEED, dev_name(dev),
 						DEVHASH);
@@ -234,6 +250,12 @@ int show_trace_dev_match(char *buf, size
 			size -= len;
 		}
 		entry = entry->prev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	device_pm_unlock();
 	return ret;
diff -u -p a/base/power/main.c b/base/power/main.c
--- a/base/power/main.c
+++ b/base/power/main.c
@@ -460,6 +460,11 @@ void dpm_resume_noirq(pm_message_t state
 	ktime_t starttime = ktime_get();
 
 	mutex_lock(&dpm_list_mtx);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&dpm_noirq_list)) {
 		struct device *dev = to_device(dpm_noirq_list.next);
 		int error;
@@ -478,6 +483,12 @@ void dpm_resume_noirq(pm_message_t state
 
 		mutex_lock(&dpm_list_mtx);
 		put_device(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&dpm_list_mtx);
 	dpm_show_time(starttime, state, "early");
@@ -626,6 +637,11 @@ void dpm_resume(pm_message_t state)
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&dpm_suspended_list)) {
 		dev = to_device(dpm_suspended_list.next);
 		get_device(dev);
@@ -647,6 +663,12 @@ void dpm_resume(pm_message_t state)
 		if (!list_empty(&dev->power.entry))
 			list_move_tail(&dev->power.entry, &dpm_prepared_list);
 		put_device(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&dpm_list_mtx);
 	async_synchronize_full();
@@ -698,6 +720,11 @@ void dpm_complete(pm_message_t state)
 
 	INIT_LIST_HEAD(&list);
 	mutex_lock(&dpm_list_mtx);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&dpm_prepared_list)) {
 		struct device *dev = to_device(dpm_prepared_list.prev);
 
@@ -710,6 +737,12 @@ void dpm_complete(pm_message_t state)
 
 		mutex_lock(&dpm_list_mtx);
 		put_device(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	list_splice(&list, &dpm_list);
 	mutex_unlock(&dpm_list_mtx);
diff -u -p a/base/platform.c b/base/platform.c
--- a/base/platform.c
+++ b/base/platform.c
@@ -634,12 +634,23 @@ static const struct platform_device_id *
 			const struct platform_device_id *id,
 			struct platform_device *pdev)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (id->name[0]) {
 		if (strcmp(pdev->name, id->name) == 0) {
 			pdev->id_entry = id;
 			return id;
 		}
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/base/core.c b/base/core.c
--- a/base/core.c
+++ b/base/core.c
@@ -1733,7 +1733,12 @@ void device_shutdown(void)
 	 * Beware that device unplug events may also start pulling
 	 * devices offline, even as the system is shutting down.
 	 */
-	while (!list_empty(&devices_kset->list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&devices_kset->list)) {
 		dev = list_entry(devices_kset->list.prev, struct device,
 				kobj.entry);
 		get_device(dev);
@@ -1758,6 +1763,12 @@ void device_shutdown(void)
 		put_device(dev);
 
 		spin_lock(&devices_kset->list_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock(&devices_kset->list_lock);
 	async_synchronize_full();
diff -u -p a/base/firmware_class.c b/base/firmware_class.c
--- a/base/firmware_class.c
+++ b/base/firmware_class.c
@@ -304,6 +304,11 @@ static ssize_t firmware_data_read(struct
 
 	ret_count = count;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		void *page_data;
 		int page_nr = offset >> PAGE_SHIFT;
@@ -318,7 +323,13 @@ static ssize_t firmware_data_read(struct
 		buffer += page_cnt;
 		offset += page_cnt;
 		count -= page_cnt;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	mutex_unlock(&fw_lock);
 	return ret_count;
@@ -349,7 +360,12 @@ static int fw_realloc_buffer(struct firm
 		fw_priv->page_array_size = new_array_size;
 	}
 
-	while (fw_priv->nr_pages < pages_needed) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (fw_priv->nr_pages < pages_needed) {
 		fw_priv->pages[fw_priv->nr_pages] =
 			alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
 
@@ -358,6 +374,12 @@ static int fw_realloc_buffer(struct firm
 			return -ENOMEM;
 		}
 		fw_priv->nr_pages++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -398,6 +420,11 @@ static ssize_t firmware_data_write(struc
 
 	retval = count;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		void *page_data;
 		int page_nr = offset >> PAGE_SHIFT;
@@ -412,6 +439,12 @@ static ssize_t firmware_data_write(struc
 		buffer += page_cnt;
 		offset += page_cnt;
 		count -= page_cnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	fw->size = max_t(size_t, offset, fw->size);
diff -u -p a/base/regmap/regcache-rbtree.c b/base/regmap/regcache-rbtree.c
--- a/base/regmap/regcache-rbtree.c
+++ b/base/regmap/regcache-rbtree.c
@@ -72,6 +72,11 @@ static struct regcache_rbtree_node *regc
 	}
 
 	node = rbtree_ctx->root.rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (node) {
 		rbnode = container_of(node, struct regcache_rbtree_node, node);
 		regcache_rbtree_get_base_top_reg(rbnode, &base_reg, &top_reg);
@@ -83,6 +88,12 @@ static struct regcache_rbtree_node *regc
 		} else if (reg < base_reg) {
 			node = node->rb_left;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
@@ -98,7 +109,12 @@ static int regcache_rbtree_insert(struct
 
 	parent = NULL;
 	new = &root->rb_node;
-	while (*new) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*new) {
 		rbnode_tmp = container_of(*new, struct regcache_rbtree_node,
 					  node);
 		/* base and top registers of the current rbnode */
@@ -115,6 +131,12 @@ static int regcache_rbtree_insert(struct
 			new = &((*new)->rb_right);
 		else if (base_reg < base_reg_tmp)
 			new = &((*new)->rb_left);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	/* insert the node into the rbtree */
@@ -166,12 +188,23 @@ static int regcache_rbtree_exit(struct r
 
 	/* free up the rbtree */
 	next = rb_first(&rbtree_ctx->root);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next) {
 		rbtree_node = rb_entry(next, struct regcache_rbtree_node, node);
 		next = rb_next(&rbtree_node->node);
 		rb_erase(&rbtree_node->node, &rbtree_ctx->root);
 		kfree(rbtree_node->block);
 		kfree(rbtree_node);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* release the resources */
diff -u -p a/base/devres.c b/base/devres.c
--- a/base/devres.c
+++ b/base/devres.c
@@ -337,6 +337,11 @@ static int remove_nodes(struct device *d
 	 * devres_group colors.
 	 */
 	cur = first;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cur != end) {
 		struct devres_node *node;
 		struct devres_group *grp;
@@ -356,6 +361,12 @@ static int remove_nodes(struct device *d
 			list_move_tail(&node->entry, todo);
 			cnt++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!nr_groups)
@@ -368,6 +379,11 @@ static int remove_nodes(struct device *d
 	 * opening marker is enough for an open group.
 	 */
 	cur = first;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cur != end) {
 		struct devres_node *node;
 		struct devres_group *grp;
@@ -390,6 +406,12 @@ static int remove_nodes(struct device *d
 			list_move_tail(&grp->node[0].entry, todo);
 			list_del_init(&grp->node[1].entry);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return cnt;
diff -u -p a/base/devtmpfs.c b/base/devtmpfs.c
--- a/base/devtmpfs.c
+++ b/base/devtmpfs.c
@@ -399,24 +399,57 @@ static int devtmpfsd(void *p)
 	sys_chdir("/.."); /* will traverse into overmounted root */
 	sys_chroot(".");
 	complete(&setup_done);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		spin_lock(&req_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (requests) {
 			struct req *req = requests;
 			requests = NULL;
 			spin_unlock(&req_lock);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (req) {
 				struct req *next = req->next;
 				req->err = handle(req->name, req->mode, req->dev);
 				complete(&req->done);
 				req = next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			spin_lock(&req_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock(&req_lock);
 		schedule();
 		__set_current_state(TASK_RUNNING);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 out:
diff -u -p a/base/class.c b/base/class.c
--- a/base/class.c
+++ b/base/class.c
@@ -330,6 +330,11 @@ struct device *class_dev_iter_next(struc
 	struct klist_node *knode;
 	struct device *dev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		knode = klist_next(&iter->ki);
 		if (!knode)
@@ -337,6 +342,12 @@ struct device *class_dev_iter_next(struc
 		dev = container_of(knode, struct device, knode_class);
 		if (!iter->type || iter->type == dev->type)
 			return dev;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 EXPORT_SYMBOL_GPL(class_dev_iter_next);
diff -u -p a/bcma/host_soc.c b/bcma/host_soc.c
--- a/bcma/host_soc.c
+++ b/bcma/host_soc.c
@@ -53,10 +53,21 @@ static void bcma_host_soc_block_read(str
 	case sizeof(u8): {
 		u8 *buf = buffer;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			*buf = __raw_readb(addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -64,10 +75,21 @@ static void bcma_host_soc_block_read(str
 		__le16 *buf = buffer;
 
 		WARN_ON(count & 1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			*buf = (__force __le16)__raw_readw(addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -75,10 +97,21 @@ static void bcma_host_soc_block_read(str
 		__le32 *buf = buffer;
 
 		WARN_ON(count & 3);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			*buf = (__force __le32)__raw_readl(addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -97,10 +130,21 @@ static void bcma_host_soc_block_write(st
 	case sizeof(u8): {
 		const u8 *buf = buffer;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			__raw_writeb(*buf, addr);
 			buf++;
 			count--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -108,10 +152,21 @@ static void bcma_host_soc_block_write(st
 		const __le16 *buf = buffer;
 
 		WARN_ON(count & 1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			__raw_writew((__force u16)(*buf), addr);
 			buf++;
 			count -= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
@@ -119,10 +174,21 @@ static void bcma_host_soc_block_write(st
 		const __le32 *buf = buffer;
 
 		WARN_ON(count & 3);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (count) {
 			__raw_writel((__force u32)(*buf), addr);
 			buf++;
 			count -= 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
diff -u -p a/char/agp/sgi-agp.c b/char/agp/sgi-agp.c
--- a/char/agp/sgi-agp.c
+++ b/char/agp/sgi-agp.c
@@ -177,10 +177,21 @@ static int sgi_tioca_insert_memory(struc
 
 	j = pg_start;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j < (pg_start + mem->page_count)) {
 		if (table[j])
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!mem->is_flushed) {
diff -u -p a/char/agp/parisc-agp.c b/char/agp/parisc-agp.c
--- a/char/agp/parisc-agp.c
+++ b/char/agp/parisc-agp.c
@@ -140,10 +140,21 @@ parisc_agp_insert_memory(struct agp_memo
 	}
 
 	j = io_pg_start;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j < (io_pg_start + io_pg_count)) {
 		if (info->gatt[j])
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!mem->is_flushed) {
diff -u -p a/char/agp/sworks-agp.c b/char/agp/sworks-agp.c
--- a/char/agp/sworks-agp.c
+++ b/char/agp/sworks-agp.c
@@ -333,12 +333,23 @@ static int serverworks_insert_memory(str
 	}
 
 	j = pg_start;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j < (pg_start + mem->page_count)) {
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = SVRWRKS_GET_GATT(addr);
 		if (!PGE_EMPTY(agp_bridge, readl(cur_gatt+GET_GATT_OFF(addr))))
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!mem->is_flushed) {
diff -u -p a/char/agp/generic.c b/char/agp/generic.c
--- a/char/agp/generic.c
+++ b/char/agp/generic.c
@@ -1101,10 +1101,21 @@ int agp_generic_insert_memory(struct agp
 
 	j = pg_start;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j < (pg_start + mem->page_count)) {
 		if (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!mem->is_flushed) {
diff -u -p a/char/agp/amd64-agp.c b/char/agp/amd64-agp.c
--- a/char/agp/amd64-agp.c
+++ b/char/agp/amd64-agp.c
@@ -66,10 +66,21 @@ static int amd64_insert_memory(struct ag
 	j = pg_start;
 
 	/* gatt table should be empty. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j < (pg_start + mem->page_count)) {
 		if (!PGE_EMPTY(agp_bridge, readl(agp_bridge->gatt_table+j)))
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!mem->is_flushed) {
diff -u -p a/char/agp/amd-k7-agp.c b/char/agp/amd-k7-agp.c
--- a/char/agp/amd-k7-agp.c
+++ b/char/agp/amd-k7-agp.c
@@ -298,12 +298,23 @@ static int amd_insert_memory(struct agp_
 		return -EINVAL;
 
 	j = pg_start;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j < (pg_start + mem->page_count)) {
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
 		if (!PGE_EMPTY(agp_bridge, readl(cur_gatt+GET_GATT_OFF(addr))))
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!mem->is_flushed) {
@@ -437,6 +448,11 @@ static int __devinit agp_amdk7_probe(str
 		struct pci_dev *gfxcard=NULL;
 
 		cap_ptr = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!cap_ptr) {
 			gfxcard = pci_get_class(PCI_CLASS_DISPLAY_VGA<<8, gfxcard);
 			if (!gfxcard) {
@@ -444,6 +460,12 @@ static int __devinit agp_amdk7_probe(str
 				return -ENODEV;
 			}
 			cap_ptr = pci_find_capability(gfxcard, PCI_CAP_ID_AGP);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* With so many variants of NVidia cards, it's simpler just
diff -u -p a/char/agp/ati-agp.c b/char/agp/ati-agp.c
--- a/char/agp/ati-agp.c
+++ b/char/agp/ati-agp.c
@@ -284,12 +284,23 @@ static int ati_insert_memory(struct agp_
 		return -EINVAL;
 
 	j = pg_start;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j < (pg_start + mem->page_count)) {
 		addr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
 		if (!PGE_EMPTY(agp_bridge,readl(cur_gatt+GET_GATT_OFF(addr))))
 			return -EBUSY;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!mem->is_flushed) {
diff -u -p a/char/agp/i460-agp.c b/char/agp/i460-agp.c
--- a/char/agp/i460-agp.c
+++ b/char/agp/i460-agp.c
@@ -314,13 +314,24 @@ static int i460_insert_memory_small_io_p
 	}
 
 	j = io_pg_start;
-	while (j < (io_pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (j < (io_pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count)) {
 		if (!PGE_EMPTY(agp_bridge, RD_GATT(j))) {
 			pr_debug("i460_insert_memory_small_io_page: GATT[%d]=0x%x is busy\n",
 				 j, RD_GATT(j));
 			return -EBUSY;
 		}
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	io_page_size = 1UL << I460_IO_PAGE_SHIFT;
diff -u -p a/char/agp/hp-agp.c b/char/agp/hp-agp.c
--- a/char/agp/hp-agp.c
+++ b/char/agp/hp-agp.c
@@ -348,11 +348,22 @@ hp_zx1_insert_memory (struct agp_memory
 	}
 
 	j = io_pg_start;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j < (io_pg_start + io_pg_count)) {
 		if (hp->gatt[j]) {
 			return -EBUSY;
 		}
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!mem->is_flushed) {
diff -u -p a/char/agp/frontend.c b/char/agp/frontend.c
--- a/char/agp/frontend.c
+++ b/char/agp/frontend.c
@@ -340,6 +340,11 @@ static void agp_remove_all_clients(struc
 
 	client = controller->clients;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (client) {
 		struct agp_file_private *priv;
 
@@ -353,6 +358,12 @@ static void agp_remove_all_clients(struc
 		}
 		client = client->next;
 		kfree(temp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -363,10 +374,21 @@ static void agp_remove_all_memory(struct
 
 	memory = controller->pool;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (memory) {
 		temp = memory;
 		memory = memory->next;
 		agp_free_memory_wrap(temp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/char/tpm/tpm_tis.c b/char/tpm/tpm_tis.c
--- a/char/tpm/tpm_tis.c
+++ b/char/tpm/tpm_tis.c
@@ -325,6 +325,11 @@ static int tpm_tis_send_data(struct tpm_
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count < len - 1) {
 		burstcnt = get_burstcount(chip);
 		for (; burstcnt > 0 && count < len - 1; burstcnt--) {
@@ -340,6 +345,12 @@ static int tpm_tis_send_data(struct tpm_
 			rc = -EIO;
 			goto out_err;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* write last byte */
diff -u -p a/char/ipmi/ipmi_watchdog.c b/char/ipmi/ipmi_watchdog.c
--- a/char/ipmi/ipmi_watchdog.c
+++ b/char/ipmi/ipmi_watchdog.c
@@ -842,11 +842,22 @@ static ssize_t ipmi_read(struct file *fi
 
 		init_waitqueue_entry(&wait, current);
 		add_wait_queue(&read_q, &wait);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!data_to_read) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			spin_unlock(&ipmi_read_lock);
 			schedule();
 			spin_lock(&ipmi_read_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		remove_wait_queue(&read_q, &wait);
 
diff -u -p a/char/ipmi/ipmi_msghandler.c b/char/ipmi/ipmi_msghandler.c
--- a/char/ipmi/ipmi_msghandler.c
+++ b/char/ipmi/ipmi_msghandler.c
@@ -1043,10 +1043,21 @@ int ipmi_destroy_user(ipmi_user_t user)
 	}
 	mutex_unlock(&intf->cmd_rcvrs_mutex);
 	synchronize_rcu();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rcvrs) {
 		rcvr = rcvrs;
 		rcvrs = rcvr->next;
 		kfree(rcvr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_lock(&ipmi_interfaces_mutex);
@@ -1197,6 +1208,11 @@ int ipmi_set_gets_events(ipmi_user_t use
 		goto out;
 
 	/* Deliver any queued events. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (user->gets_events && !list_empty(&intf->waiting_events)) {
 		list_for_each_entry_safe(msg, msg2, &intf->waiting_events, link)
 			list_move_tail(&msg->link, &msgs);
@@ -1218,6 +1234,12 @@ int ipmi_set_gets_events(ipmi_user_t use
 
 		spin_lock_irqsave(&intf->events_lock, flags);
 		intf->delivering_events = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
  out:
@@ -1322,10 +1344,21 @@ int ipmi_unregister_for_cmd(ipmi_user_t
 	}
 	mutex_unlock(&intf->cmd_rcvrs_mutex);
 	synchronize_rcu();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rcvrs) {
 		rcvr = rcvrs;
 		rcvrs = rcvr->next;
 		kfree(rcvr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return rv;
 }
@@ -2090,6 +2123,11 @@ static void remove_proc_entries(ipmi_smi
 	struct ipmi_proc_entry *entry;
 
 	mutex_lock(&smi->proc_entry_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (smi->proc_entries) {
 		entry = smi->proc_entries;
 		smi->proc_entries = entry->next;
@@ -2097,6 +2135,12 @@ static void remove_proc_entries(ipmi_smi
 		remove_proc_entry(entry->name, smi->proc_dir);
 		kfree(entry->name);
 		kfree(entry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&smi->proc_entry_lock);
 	remove_proc_entry(smi->proc_dir_name, proc_ipmi_root);
@@ -4388,6 +4432,11 @@ static void send_panic_events(char *str)
 		msg.data_len = 16;
 
 		j = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (*p) {
 			int size = strlen(p);
 
@@ -4417,6 +4466,12 @@ static void send_panic_events(char *str)
 				       intf->channels[0].address,
 				       intf->channels[0].lun,
 				       0, 1); /* no retry, and no wait. */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 #endif /* CONFIG_IPMI_PANIC_STRING */
diff -u -p a/char/bsr.c b/char/bsr.c
--- a/char/bsr.c
+++ b/char/bsr.c
@@ -281,6 +281,11 @@ static int bsr_create_devs(struct device
 {
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bn) {
 		ret = bsr_add_node(bn);
 		if (ret) {
@@ -288,6 +293,12 @@ static int bsr_create_devs(struct device
 			return ret;
 		}
 		bn = of_find_compatible_node(bn, NULL, "ibm,bsr");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/char/mem.c b/char/mem.c
--- a/char/mem.c
+++ b/char/mem.c
@@ -64,7 +64,12 @@ static inline int range_is_allowed(unsig
 	u64 to = from + size;
 	u64 cursor = from;
 
-	while (cursor < to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cursor < to) {
 		if (!devmem_is_allowed(pfn)) {
 			printk(KERN_INFO
 		"Program %s tried to access /dev/mem between %Lx->%Lx.\n",
@@ -73,6 +78,12 @@ static inline int range_is_allowed(unsig
 		}
 		cursor += PAGE_SIZE;
 		pfn++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 1;
 }
@@ -365,6 +376,11 @@ static ssize_t read_oldmem(struct file *
 	size_t read = 0, csize;
 	int rc = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		pfn = *ppos / PAGE_SIZE;
 		if (pfn > saved_max_pfn)
@@ -383,6 +399,12 @@ static ssize_t read_oldmem(struct file *
 		*ppos += csize;
 		read += csize;
 		count -= csize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return read;
 }
diff -u -p a/char/sonypi.c b/char/sonypi.c
--- a/char/sonypi.c
+++ b/char/sonypi.c
@@ -1238,7 +1238,12 @@ static int __devinit sonypi_setup_ioport
 	 * this is enough.
 	 */
 	const struct sonypi_ioport_list *check = ioport_list;
-	while (check_ioport && check->port1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (check_ioport && check->port1) {
 		if (!request_region(check->port1,
 				   sonypi_device.region_size,
 				   "Sony Programmable I/O Device Check")) {
@@ -1249,9 +1254,20 @@ static int __devinit sonypi_setup_ioport
 		}
 		release_region(check->port1, sonypi_device.region_size);
 		check++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
-	while (ioport_list->port1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ioport_list->port1) {
 
 		if (request_region(ioport_list->port1,
 				   sonypi_device.region_size,
@@ -1261,6 +1277,12 @@ static int __devinit sonypi_setup_ioport
 			return 0;
 		}
 		ioport_list++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -EBUSY;
@@ -1269,7 +1291,12 @@ static int __devinit sonypi_setup_ioport
 static int __devinit sonypi_setup_irq(struct sonypi_device *dev,
 				      const struct sonypi_irq_list *irq_list)
 {
-	while (irq_list->irq) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (irq_list->irq) {
 
 		if (!request_irq(irq_list->irq, sonypi_irq,
 				 IRQF_SHARED, "sonypi", sonypi_irq)) {
@@ -1278,6 +1305,12 @@ static int __devinit sonypi_setup_irq(st
 			return 0;
 		}
 		irq_list++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -EBUSY;
diff -u -p a/char/nwflash.c b/char/nwflash.c
--- a/char/nwflash.c
+++ b/char/nwflash.c
@@ -386,6 +386,11 @@ static int erase_block(int nBlock)
 	 */
 	timeout = jiffies + 10 * HZ;
 	c1 = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(c1 & 0x80) && time_before(jiffies, timeout)) {
 		msleep(10);
 		/*
@@ -393,6 +398,12 @@ static int erase_block(int nBlock)
 		 */
 		c1 = *(volatile unsigned char *) (pWritePtr);
 		//              printk("Flash_erase: status=%X.\n",c1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/char/virtio_console.c b/char/virtio_console.c
--- a/char/virtio_console.c
+++ b/char/virtio_console.c
@@ -414,6 +414,11 @@ static void discard_port_data(struct por
 	buf = get_inbuf(port);
 
 	err = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (buf) {
 		port->stats.bytes_discarded += buf->len - buf->offset;
 		if (add_inbuf(port->in_vq, buf) < 0) {
@@ -422,6 +427,12 @@ static void discard_port_data(struct por
 		}
 		port->inbuf = NULL;
 		buf = get_inbuf(port);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (err)
 		dev_warn(port->dev, "Errors adding %d buffers back to vq\n",
@@ -491,9 +502,20 @@ static void reclaim_consumed_buffers(str
 		/* Device has been unplugged.  vqs are already gone. */
 		return;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((buf = virtqueue_get_buf(port->out_vq, &len))) {
 		kfree(buf);
 		port->outvq_full = false;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1480,6 +1502,11 @@ static void control_work_handler(struct
 	vq = portdev->c_ivq;
 
 	spin_lock(&portdev->c_ivq_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((buf = virtqueue_get_buf(vq, &len))) {
 		spin_unlock(&portdev->c_ivq_lock);
 
@@ -1494,6 +1521,12 @@ static void control_work_handler(struct
 				 "Error adding buffer to queue\n");
 			free_buf(buf);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock(&portdev->c_ivq_lock);
 }
diff -u -p a/char/dtlk.c b/char/dtlk.c
--- a/char/dtlk.c
+++ b/char/dtlk.c
@@ -136,12 +136,23 @@ static ssize_t dtlk_read(struct file *fi
 		return -EINVAL;
 
 	for (retries = 0; retries < loops_per_jiffy; retries++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (i < count && dtlk_readable()) {
 			ch = dtlk_read_lpc();
 			/*        printk("dtlk_read() reads 0x%02x\n", ch); */
 			if (put_user(ch, buf++))
 				return -EFAULT;
 			i++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (i)
 			return i;
diff -u -p a/char/random.c b/char/random.c
--- a/char/random.c
+++ b/char/random.c
@@ -990,6 +990,11 @@ static ssize_t extract_entropy(struct en
 	xfer_secondary_pool(r, nbytes);
 	nbytes = account(r, nbytes, min, reserved);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nbytes) {
 		extract_buf(r, tmp);
 
@@ -1007,6 +1012,12 @@ static ssize_t extract_entropy(struct en
 		nbytes -= i;
 		buf += i;
 		ret += i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Wipe data just returned from memory */
diff -u -p a/char/pcmcia/cm4000_cs.c b/char/pcmcia/cm4000_cs.c
--- a/char/pcmcia/cm4000_cs.c
+++ b/char/pcmcia/cm4000_cs.c
@@ -1725,7 +1725,12 @@ static void cmm_cm4000_release(struct pc
 	 * close doing that for us.
 	 */
 	DEBUGP(3, dev, "-> cmm_cm4000_release\n");
-	while (link->open) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (link->open) {
 		printk(KERN_INFO MODULE_NAME ": delaying release until "
 		       "process has terminated\n");
 		/* note: don't interrupt us:
@@ -1733,6 +1738,12 @@ static void cmm_cm4000_release(struct pc
 		 * the devices _first_ !
 		 */
 		wait_event(dev->devq, (link->open == 0));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* dev->devq=NULL;	this cannot be zeroed earlier */
 	DEBUGP(3, dev, "<- cmm_cm4000_release\n");
diff -u -p a/char/pcmcia/cm4040_cs.c b/char/pcmcia/cm4040_cs.c
--- a/char/pcmcia/cm4040_cs.c
+++ b/char/pcmcia/cm4040_cs.c
@@ -505,10 +505,21 @@ static void cm4040_reader_release(struct
 	struct reader_dev *dev = link->priv;
 
 	DEBUGP(3, dev, "-> cm4040_reader_release\n");
-	while (link->open) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+ 		unsigned long long timeout;
+ 		timeout = rdstcll(start) + delta;
+ 		while (link->open) {
 		DEBUGP(3, dev, KERN_INFO MODULE_NAME ": delaying release "
 		       "until process has terminated\n");
  		wait_event(dev->devq, (link->open == 0));
+ 		if (_cur < timeout) {
+		rdstcll(_cur);
+ 		}
+ 		else {
+		break;
+ 		}
 	}
 	DEBUGP(3, dev, "<- cm4040_reader_release\n");
 	return;
diff -u -p a/char/pcmcia/synclink_cs.c b/char/pcmcia/synclink_cs.c
--- a/char/pcmcia/synclink_cs.c
+++ b/char/pcmcia/synclink_cs.c
@@ -680,10 +680,21 @@ static bool wait_command_complete(MGSLPC
 {
 	int i = 0;
 	/* wait for command completion */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (read_reg(info, (unsigned char)(channel+STAR)) & BIT2) {
 		udelay(1);
 		if (i++ == 1000)
 			return false;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return true;
 }
@@ -906,6 +917,11 @@ static void rx_ready_async(MGSLPC_INFO *
 
 	tty_buffer_request_room(tty, fifo_count);
 	/* Flush received async data to receive data buffer. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fifo_count) {
 		data   = read_reg(info, CHA + RXFIFO);
 		status = read_reg(info, CHA + RXFIFO);
@@ -936,6 +952,12 @@ static void rx_ready_async(MGSLPC_INFO *
 				flag = TTY_FRAME;
 		}
 		work += tty_insert_flip_char(tty, data, flag);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	issue_command(info, CHA, CMD_RXFIFO);
 
@@ -1012,6 +1034,11 @@ static void tx_ready(MGSLPC_INFO *info,
 	if (!info->tx_count)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (info->tx_count && fifo_count) {
 		c = min(2, min_t(int, fifo_count, min(info->tx_count, TXBUFSIZE - info->tx_get)));
 
@@ -1024,6 +1051,12 @@ static void tx_ready(MGSLPC_INFO *info,
 		info->tx_count -= c;
 		info->tx_get = (info->tx_get + c) & (TXBUFSIZE - 1);
 		fifo_count -= c;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (info->params.mode == MGSL_MODE_ASYNC) {
@@ -2628,9 +2661,20 @@ static int mgslpc_proc_show(struct seq_f
 	seq_printf(m, "synclink driver:%s\n", driver_version);
 
 	info = mgslpc_device_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( info ) {
 		line_info(m, info);
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -2739,6 +2783,11 @@ static void mgslpc_remove_device(MGSLPC_
 	MGSLPC_INFO *info = mgslpc_device_list;
 	MGSLPC_INFO *last = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(info) {
 		if (info == remove_info) {
 			if (last)
@@ -2755,6 +2804,12 @@ static void mgslpc_remove_device(MGSLPC_
 		}
 		last = info;
 		info = info->next_device;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -3816,7 +3871,12 @@ static void trace_block(MGSLPC_INFO *inf
 	else
 		printk("%s rx data:\n",info->device_name);
 
-	while(count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while(count) {
 		if (count > 16)
 			linecount = 16;
 		else
@@ -3836,6 +3896,12 @@ static void trace_block(MGSLPC_INFO *inf
 
 		data  += linecount;
 		count -= linecount;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
diff -u -p a/char/mmtimer.c b/char/mmtimer.c
--- a/char/mmtimer.c
+++ b/char/mmtimer.c
@@ -268,6 +268,11 @@ static void mmtimer_add_list(struct mmti
 	/*
 	 * Find the right place in the rbtree:
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*link) {
 		parent = *link;
 		x = rb_entry(parent, struct mmtimer, list);
@@ -276,6 +281,12 @@ static void mmtimer_add_list(struct mmti
 			link = &(*link)->rb_left;
 		else
 			link = &(*link)->rb_right;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/*
@@ -322,7 +333,12 @@ restart:
 	/* Interval timer */
 	i = 0;
 	expires = exp = t->it.mmtimer.expires;
-	while (!mmtimer_setup(x->cpu, COMPARATOR, expires,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!mmtimer_setup(x->cpu, COMPARATOR, expires,
 				&set_completion_time)) {
 		int to;
 
@@ -344,6 +360,12 @@ restart:
 			kfree(x);
 			goto restart;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/char/applicom.c b/char/applicom.c
--- a/char/applicom.c
+++ b/char/applicom.c
@@ -194,6 +194,11 @@ static int __init applicom_init(void)
 
 	/* No mem and irq given - check for a PCI card */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ( (dev = pci_get_class(PCI_CLASS_OTHERS << 16, dev))) {
 
 		if (!pci_match_id(applicom_pci_tbl, dev))
@@ -239,6 +244,12 @@ static int __init applicom_init(void)
 		writeb(0x40, apbs[boardno - 1].RamIO + RAM_IT_FROM_PC);
 
 		apbs[boardno - 1].irq = dev->irq;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Finished with PCI cards. If none registered, 
@@ -548,6 +559,11 @@ static ssize_t ac_read (struct file *fil
 		return -EINVAL;
 	}
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(1) {
 		/* Stick ourself on the wait queue */
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -612,6 +628,12 @@ static ssize_t ac_read (struct file *fil
 			printk(KERN_DEBUG "Looping in ac_read. loopcount %d\n", loopcount);
 		}
 #endif
+if (_cur < timeout) {
+			rdstcll(_cur);
+}
+else {
+			break;
+}
 	} 
 }
 
diff -u -p a/char/viotape.c b/char/viotape.c
--- a/char/viotape.c
+++ b/char/viotape.c
@@ -271,10 +271,21 @@ void get_dev_info(struct inode *ino, str
 /* This is called only from the exit and init paths, so no need for locking */
 static void clear_op_struct_pool(void)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (op_struct_list) {
 		struct op_struct *toFree = op_struct_list;
 		op_struct_list = op_struct_list->next;
 		kfree(toFree);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/char/hw_random/n2-drv.c b/char/hw_random/n2-drv.c
--- a/char/hw_random/n2-drv.c
+++ b/char/hw_random/n2-drv.c
@@ -178,6 +178,11 @@ static int n2rng_generic_read_data(unsig
 	unsigned long ticks, hv_err;
 	int block = 0, hcheck = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		hv_err = sun4v_rng_data_read(data_ra, &ticks);
 		if (hv_err == HV_EOK)
@@ -195,6 +200,12 @@ static int n2rng_generic_read_data(unsig
 			udelay(10000);
 		} else
 			return -ENODEV;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -225,7 +236,12 @@ static int n2rng_generic_read_diag_data(
 	unsigned long ticks, hv_err;
 	int block = 0;
 
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		hv_err = n2rng_read_diag_data_one(np, unit,
 						  data_ra, data_len,
 						  &ticks);
@@ -242,6 +258,12 @@ static int n2rng_generic_read_diag_data(
 			return -EIO;
 		} else
 			return -ENODEV;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -254,7 +276,12 @@ static int n2rng_generic_write_control(s
 	unsigned long hv_err, ticks;
 	int block = 0, busy = 0;
 
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		hv_err = n2rng_write_ctl_one(np, unit, state, control_ra,
 					     np->wd_timeo, &ticks);
 		if (hv_err == HV_EOK)
@@ -270,6 +297,12 @@ static int n2rng_generic_write_control(s
 			udelay(1);
 		} else
 			return -ENODEV;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/char/hw_random/core.c b/char/hw_random/core.c
--- a/char/hw_random/core.c
+++ b/char/hw_random/core.c
@@ -108,6 +108,11 @@ static ssize_t rng_dev_read(struct file
 	int err = 0;
 	int bytes_read, len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		if (mutex_lock_interruptible(&rng_mutex)) {
 			err = -ERESTARTSYS;
@@ -161,7 +166,13 @@ static ssize_t rng_dev_read(struct file
 			err = -ERESTARTSYS;
 			goto out;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	return ret ? : err;
 out_unlock:
diff -u -p a/char/xilinx_hwicap/buffer_icap.c b/char/xilinx_hwicap/buffer_icap.c
--- a/char/xilinx_hwicap/buffer_icap.c
+++ b/char/xilinx_hwicap/buffer_icap.c
@@ -202,10 +202,21 @@ static int buffer_icap_device_read(struc
 	buffer_icap_set_offset(base_address, offset);
 	buffer_icap_set_rnc(base_address, XHI_READBACK);
 
-	while (buffer_icap_busy(base_address)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (buffer_icap_busy(base_address)) {
 		retries++;
 		if (retries > XHI_MAX_RETRIES)
 			return -EBUSY;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 
@@ -236,10 +247,21 @@ static int buffer_icap_device_write(stru
 	buffer_icap_set_offset(base_address, offset);
 	buffer_icap_set_rnc(base_address, XHI_CONFIGURE);
 
-	while (buffer_icap_busy(base_address)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (buffer_icap_busy(base_address)) {
 		retries++;
 		if (retries > XHI_MAX_RETRIES)
 			return -EBUSY;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 
diff -u -p a/edac/i7core_edac.c b/edac/i7core_edac.c
--- a/edac/i7core_edac.c
+++ b/edac/i7core_edac.c
@@ -1311,6 +1311,11 @@ static void __init i7core_xeon_pci_fixup
 	 * aren't announced by acpi. So, we need to use a legacy scan probing
 	 * to detect them
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (table && table->descr) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL, table->descr[0].dev_id, NULL);
 		if (unlikely(!pdev)) {
@@ -1319,6 +1324,12 @@ static void __init i7core_xeon_pci_fixup
 		}
 		pci_dev_put(pdev);
 		table++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -1471,6 +1482,11 @@ static int i7core_get_all_devices(void)
 
 	last_bus = i7core_pci_lastbus();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (table && table->descr) {
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
@@ -1488,6 +1504,12 @@ static int i7core_get_all_devices(void)
 			} while (pdev);
 		}
 		table++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/edac/i5400_edac.c b/edac/i5400_edac.c
--- a/edac/i5400_edac.c
+++ b/edac/i5400_edac.c
@@ -735,7 +735,12 @@ static int i5400_get_devices(struct mem_
 
 	/* Attempt to 'get' the MCH register we want */
 	pdev = NULL;
-	while (!pvt->branchmap_werrors || !pvt->fsb_error_regs) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!pvt->branchmap_werrors || !pvt->fsb_error_regs) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_5400_ERR, pdev);
 		if (!pdev) {
@@ -759,6 +764,12 @@ static int i5400_get_devices(struct mem_
 			pvt->fsb_error_regs = pdev;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	debugf1("System Address, processor bus- PCI Bus ID: %s  %x:%x\n",
diff -u -p a/edac/sb_edac.c b/edac/sb_edac.c
--- a/edac/sb_edac.c
+++ b/edac/sb_edac.c
@@ -1259,6 +1259,11 @@ static int sbridge_get_all_devices(u8 *n
 	struct pci_dev *pdev = NULL;
 	const struct pci_id_table *table = pci_dev_descr_sbridge_table;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (table && table->descr) {
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
@@ -1276,6 +1281,12 @@ static int sbridge_get_all_devices(u8 *n
 			} while (pdev);
 		}
 		table++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/edac/i7300_edac.c b/edac/i7300_edac.c
--- a/edac/i7300_edac.c
+++ b/edac/i7300_edac.c
@@ -962,7 +962,12 @@ static int __devinit i7300_get_devices(s
 
 	/* Attempt to 'get' the MCH register we want */
 	pdev = NULL;
-	while ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7300_MCH_ERR,
 				      pdev))) {
 		/* Store device 16 funcs 1 and 2 */
@@ -978,6 +983,12 @@ static int __devinit i7300_get_devices(s
 							pci_dev_get(pdev);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!pvt->pci_dev_16_1_fsb_addr_map ||
diff -u -p a/eisa/eisa-bus.c b/eisa/eisa-bus.c
--- a/eisa/eisa-bus.c
+++ b/eisa/eisa-bus.c
@@ -115,6 +115,11 @@ static int eisa_bus_match(struct device
 	if (!eids)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (strlen(eids->sig)) {
 		if (!strcmp(eids->sig, edev->id.sig) &&
 		    edev->state & EISA_CONFIG_ENABLED) {
@@ -123,6 +128,12 @@ static int eisa_bus_match(struct device
 		}
 
 		eids++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/gpio/gpio-msm-v1.c b/gpio/gpio-msm-v1.c
--- a/gpio/gpio-msm-v1.c
+++ b/gpio/gpio-msm-v1.c
@@ -569,6 +569,11 @@ static void msm_gpio_irq_handler(unsigne
 		struct msm_gpio_chip *msm_chip = &msm_gpio_chips[i];
 		val = readl(msm_chip->regs.int_status);
 		val &= msm_chip->int_enable[0];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (val) {
 			mask = val & -val;
 			j = fls(mask) - 1;
@@ -578,6 +583,12 @@ static void msm_gpio_irq_handler(unsigne
 			val &= ~mask;
 			generic_handle_irq(FIRST_GPIO_IRQ +
 					   msm_chip->chip.base + j);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	desc->irq_data.chip->irq_ack(&desc->irq_data);
diff -u -p a/gpio/gpio-pca953x.c b/gpio/gpio-pca953x.c
--- a/gpio/gpio-pca953x.c
+++ b/gpio/gpio-pca953x.c
@@ -341,10 +341,21 @@ static void pca953x_irq_bus_sync_unlock(
 	new_irqs = chip->irq_trig_fall | chip->irq_trig_raise;
 	new_irqs &= ~chip->reg_direction;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (new_irqs) {
 		level = __ffs(new_irqs);
 		pca953x_gpio_direction_input(&chip->gpio_chip, level);
 		new_irqs &= ~(1 << level);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&chip->irq_lock);
diff -u -p a/gpio/gpio-langwell.c b/gpio/gpio-langwell.c
--- a/gpio/gpio-langwell.c
+++ b/gpio/gpio-langwell.c
@@ -250,6 +250,11 @@ static void lnw_irq_handler(unsigned irq
 	for (base = 0; base < lnw->chip.ngpio; base += 32) {
 		gedr = gpio_reg(&lnw->chip, base, GEDR);
 		pending = readl(gedr);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (pending) {
 			gpio = __ffs(pending);
 			mask = BIT(gpio);
@@ -257,6 +262,12 @@ static void lnw_irq_handler(unsigned irq
 			/* Clear before handling so we can't lose an edge */
 			writel(mask, gedr);
 			generic_handle_irq(lnw->irq_base + base + gpio);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/gpio/gpio-adp5588.c b/gpio/gpio-adp5588.c
--- a/gpio/gpio-adp5588.c
+++ b/gpio/gpio-adp5588.c
@@ -256,7 +256,12 @@ static irqreturn_t adp5588_irq_handler(i
 			bank++, bit = 0) {
 			pending = dev->irq_stat[bank] & dev->irq_mask[bank];
 
-			while (pending) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (pending) {
 				if (pending & (1 << bit)) {
 					handle_nested_irq(dev->irq_base +
 							  (bank << 3) + bit);
@@ -264,6 +269,12 @@ static irqreturn_t adp5588_irq_handler(i
 
 				}
 				bit++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
diff -u -p a/gpio/gpio-nomadik.c b/gpio/gpio-nomadik.c
--- a/gpio/gpio-nomadik.c
+++ b/gpio/gpio-nomadik.c
@@ -751,11 +751,22 @@ static void __nmk_gpio_irq_handler(unsig
 
 	nmk_chip = irq_get_handler_data(irq);
 	first_irq = NOMADIK_GPIO_TO_IRQ(nmk_chip->chip.base);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status) {
 		int bit = __ffs(status);
 
 		generic_handle_irq(first_irq + bit);
 		status &= ~BIT(bit);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	chained_irq_exit(host_chip, desc);
diff -u -p a/gpio/gpio-stmpe.c b/gpio/gpio-stmpe.c
--- a/gpio/gpio-stmpe.c
+++ b/gpio/gpio-stmpe.c
@@ -232,12 +232,23 @@ static irqreturn_t stmpe_gpio_irq(int ir
 		if (!stat)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (stat) {
 			int bit = __ffs(stat);
 			int line = bank * 8 + bit;
 
 			handle_nested_irq(stmpe_gpio->irq_base + line);
 			stat &= ~(1 << bit);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		stmpe_reg_write(stmpe, statmsbreg + i, status[i]);
diff -u -p a/gpio/gpio-tc3589x.c b/gpio/gpio-tc3589x.c
--- a/gpio/gpio-tc3589x.c
+++ b/gpio/gpio-tc3589x.c
@@ -219,12 +219,23 @@ static irqreturn_t tc3589x_gpio_irq(int
 		if (!stat)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (stat) {
 			int bit = __ffs(stat);
 			int line = i * 8 + bit;
 
 			handle_nested_irq(tc3589x_gpio->irq_base + line);
 			stat &= ~(1 << bit);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		tc3589x_reg_write(tc3589x, TC3589x_GPIOIC0 + i, status[i]);
diff -u -p a/gpio/gpio-davinci.c b/gpio/gpio-davinci.c
--- a/gpio/gpio-davinci.c
+++ b/gpio/gpio-davinci.c
@@ -279,11 +279,22 @@ gpio_irq_handler(unsigned irq, struct ir
 			status >>= 16;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (status) {
 			res = ffs(status);
 			n += res;
 			generic_handle_irq(n - 1);
 			status >>= res;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	desc->irq_data.chip->irq_unmask(&desc->irq_data);
diff -u -p a/isdn/sc/message.c b/isdn/sc/message.c
--- a/isdn/sc/message.c
+++ b/isdn/sc/message.c
@@ -197,6 +197,11 @@ int send_and_receive(int card,
 
 	tries = 0;
 	/* wait for the response */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tries < timeout) {
 		schedule_timeout_interruptible(1);
 		
@@ -222,6 +227,12 @@ int send_and_receive(int card,
 		}
 
    		tries++;
+   		if (_cur < timeout) {
+			rdstcll(_cur);
+   		}
+   		else {
+			break;
+   		}
 	}
 
 	pr_debug("%s: SAR message timeout\n", sc_adapter[card]->devicename);
diff -u -p a/isdn/i4l/isdn_ppp.c b/isdn/i4l/isdn_ppp.c
--- a/isdn/i4l/isdn_ppp.c
+++ b/isdn/i4l/isdn_ppp.c
@@ -164,11 +164,22 @@ isdn_ppp_bind(isdn_net_local * lp)
 		isdn_net_dev *net_dev = dev->netdev;
 		char exclusive[ISDN_MAX_CHANNELS];	/* exclusive flags */
 		memset(exclusive, 0, ISDN_MAX_CHANNELS);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (net_dev) {	/* step through net devices to find exclusive minors */
 			isdn_net_local *lp = net_dev->local;
 			if (lp->pppbind >= 0)
 				exclusive[lp->pppbind] = 1;
 			net_dev = net_dev->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/*
 		 * search a free device / slot
@@ -591,12 +602,23 @@ isdn_ppp_ioctl(int min, struct file *fil
 			{
 				unsigned long protos[8] = {0,};
 				struct isdn_ppp_compressor *ipc = ipc_head;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while(ipc) {
 					j = ipc->num / (sizeof(long)*8);
 					i = ipc->num % (sizeof(long)*8);
 					if(j < 8)
 						protos[j] |= (0x1<<i);
 					ipc = ipc->next;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				if ((r = set_arg(argp,protos,8*sizeof(long) )))
 					return r;
@@ -1807,10 +1829,21 @@ static void isdn_ppp_mp_cleanup( isdn_ne
 {
 	struct sk_buff * frag = lp->netdev->pb->frags;
 	struct sk_buff * nextfrag;
-    	while( frag ) {
+    	unsigned long long delta = (cpu / khz / HZ) * 2;
+    	unsigned long long _start = 0;
+    	unsigned long long _cur = 0;
+    	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while( frag ) {
 		nextfrag = frag->next;
 		isdn_ppp_mp_free_skb(lp->netdev->pb, frag);
 		frag = nextfrag;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	lp->netdev->pb->frags = NULL;
 }
@@ -1852,11 +1885,23 @@ static u32 isdn_ppp_mp_get_seq( int shor
 struct sk_buff * isdn_ppp_mp_discard( ippp_bundle * mp,
 			struct sk_buff * from, struct sk_buff * to )
 {
-	if( from )
-		while (from != to) {
-	  		struct sk_buff * next = from->next;
-			isdn_ppp_mp_free_skb(mp, from);
+	if( from ) {
+	  		unsigned long long delta = (cpu / khz / HZ) * 2;
+	  		unsigned long long _start = 0;
+	  		unsigned long long _cur = 0;
+	  		unsigned long long timeout;
+	  		timeout = rdstcll(start) + delta;
+	  		while (from != to) {
+	  			struct sk_buff * next = from->next;
+	  		isdn_ppp_mp_free_skb(mp, from);
 	  		from = next;
+	  		if (_cur < timeout) {
+	  			  		rdstcll(_cur);
+	  		}
+	  		else {
+	  			  		break;
+	  		}
+	  		}
 		}
 	return from;
 }
@@ -1899,7 +1944,12 @@ void isdn_ppp_mp_reassembly( isdn_net_de
 			return;
 		}
 
-		while( from != to ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while( from != to ) {
 			unsigned int len = from->len - MP_HEADER_LEN;
 
 			skb_copy_from_linear_data_offset(from, MP_HEADER_LEN,
@@ -1908,6 +1958,12 @@ void isdn_ppp_mp_reassembly( isdn_net_de
 			frag = from->next;
 			isdn_ppp_mp_free_skb(mp, from);
 			from = frag; 
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
    	proto = isdn_ppp_strip_proto(skb);
diff -u -p a/isdn/i4l/isdn_common.c b/isdn/i4l/isdn_common.c
--- a/isdn/i4l/isdn_common.c
+++ b/isdn/i4l/isdn_common.c
@@ -129,9 +129,20 @@ isdn_dumppkt(char *s, u_char * p, int le
 static int
 isdn_star(char *s, char *p)
 {
-	while (isdn_wildmat(s, p)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (isdn_wildmat(s, p)) {
 		if (*++s == '\0')
 			return (2);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return (0);
 }
@@ -1049,9 +1060,20 @@ isdn_info_update(void)
 {
 	infostruct *p = dev->infochain;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		*(p->private) = 1;
 		p = (infostruct *) p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	wake_up_interruptible(&(dev->info_waitq));
 }
@@ -1804,6 +1826,11 @@ isdn_close(struct inode *ino, struct fil
 		infostruct *p = dev->infochain;
 		infostruct *q = NULL;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (p) {
 			if (p->private == (char *) &(filep->private_data)) {
 				if (q)
@@ -1815,6 +1842,12 @@ isdn_close(struct inode *ino, struct fil
 			}
 			q = p;
 			p = (infostruct *) (p->next);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		printk(KERN_WARNING "isdn: No private data while closing isdnctrl\n");
 		goto out;
diff -u -p a/isdn/i4l/isdn_audio.c b/isdn/i4l/isdn_audio.c
--- a/isdn/i4l/isdn_audio.c
+++ b/isdn/i4l/isdn_audio.c
@@ -301,11 +301,22 @@ static int bitmask[9] =
 static int
 isdn_audio_get_bits(adpcm_state * s, unsigned char **in, int *len)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (s->nleft < s->nbits) {
 		int d = *((*in)++);
 		(*len)--;
 		s->word = (s->word << 8) | d;
 		s->nleft += 8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	s->nleft -= s->nbits;
 	return (s->word >> s->nleft) & bitmask[s->nbits];
@@ -366,6 +377,11 @@ isdn_audio_adpcm2xlaw(adpcm_state * s, i
 	int nbits = s->nbits;
 	int olen = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		int e = isdn_audio_get_bits(s, &in, &len);
 		int sign;
@@ -386,6 +402,12 @@ isdn_audio_adpcm2xlaw(adpcm_state * s, i
 		d = (d * Mx[nbits - 2][e] + 0x2000) >> 14;
 		if (d < 5)
 			d = 5;
+			if (_cur < timeout) {
+					 rdstcll(_cur);
+			}
+			else {
+					 break;
+			}
 	}
 	s->a = a;
 	s->d = d;
@@ -506,6 +528,11 @@ isdn_audio_eval_dtmf(modem_info * info)
 	char *p;
 	int thresh;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&info->dtmf_queue))) {
 		result = (int *) skb->data;
 		s = info->dtmf_state;
@@ -577,6 +604,12 @@ isdn_audio_eval_dtmf(modem_info * info)
 		} else
 			kfree_skb(skb);
 		s->last = what;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/isdn/i4l/isdn_v110.c b/isdn/i4l/isdn_v110.c
--- a/isdn/i4l/isdn_v110.c
+++ b/isdn/i4l/isdn_v110.c
@@ -196,6 +196,11 @@ DecodeMatrix(isdn_v110_stream * v, unsig
 	int dbit = v->dbit;
 	unsigned char b = v->b;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (line < len) {    /* Are we done with all lines of the matrix? */
 		if ((line % 10) == 0) {	/* the 0. line of the matrix is always 0 ! */
 			if (m[line] != 0x00) {	/* not 0 ? -> error! */
@@ -239,6 +244,12 @@ DecodeMatrix(isdn_v110_stream * v, unsig
 			}
 			goto next_byte;	/* look for next bit in the matrix */
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	v->introducer = introducer;
 	v->dbit = dbit;
diff -u -p a/isdn/icn/icn.c b/isdn/icn/icn.c
--- a/isdn/icn/icn.c
+++ b/isdn/icn/icn.c
@@ -648,10 +648,21 @@ icn_polldchan(unsigned long data)
 							       "icn: (%s) Euro-Protocol loaded and running\n", CID);
 						}
 						p = strstr(card->imsg, "BRV") + 3;
+						unsigned long long delta = (cpu / khz / HZ) * 2;
+						unsigned long long _start = 0;
+						unsigned long long _cur = 0;
+						unsigned long long timeout;
+						timeout = rdstcll(start) + delta;
 						while (*p) {
 							if (*p >= '0' && *p <= '9')
 								*q++ = *p;
 							p++;
+							if (_cur < timeout) {
+								rdstcll(_cur);
+							}
+							else {
+								break;
+							}
 						}
 						*q = '\0';
 						strcat(vstr, "000");
@@ -748,6 +759,11 @@ icn_check_loader(int cardnumber)
 {
 	int timer = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 #ifdef BOOT_DEBUG
 		printk(KERN_DEBUG "Loader %d ?\n", cardnumber);
@@ -772,6 +788,12 @@ icn_check_loader(int cardnumber)
 			icn_release_channel();
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -788,10 +810,21 @@ icn_check_loader(int cardnumber)
 #define SLEEP(sec) { \
 int slsec = sec; \
   printk(KERN_DEBUG "SLEEP(%d)\n",slsec); \
-  while (slsec) { \
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (slsec) { \
     msleep_interruptible(1000); \
     slsec--; \
-  } \
+  if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	} \
 }
 #else
 #define SLEEP(sec)
@@ -927,6 +960,11 @@ icn_loadproto(u_char __user * buffer, ic
 		icn_lock_channel(card, 0);
 	}
 	spin_unlock_irqrestore(&dev.devlock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (left) {
 		if (sbfree) {   /* If there is a free buffer...  */
 			cnt = left;
@@ -951,9 +989,20 @@ icn_loadproto(u_char __user * buffer, ic
 			}
 			schedule_timeout_interruptible(10);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	writeb(0x20, &sbuf_n);
 	timer = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (readb(&cmd_o) || readb(&cmd_i)) {
 #ifdef BOOT_DEBUG
@@ -999,6 +1048,12 @@ icn_loadproto(u_char __user * buffer, ic
 			icn_maprelease_channel(card, 0);
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1118,9 +1173,20 @@ icn_stopallcards(void)
 {
 	icn_card *p = cards;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		icn_stopcard(p);
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1133,6 +1199,11 @@ icn_disable_cards(void)
 {
 	icn_card *card = cards;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card) {
 		if (!request_region(card->port, ICN_PORTLEN, "icn-isdn")) {
 			printk(KERN_WARNING
@@ -1146,6 +1217,12 @@ icn_disable_cards(void)
 			release_region(card->port, ICN_PORTLEN);
 		}
 		card = card->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1442,10 +1519,21 @@ icn_findcard(int driverid)
 {
 	icn_card *p = cards;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		if (p->myid == driverid)
 			return p;
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (icn_card *) 0;
 }
@@ -1658,6 +1746,11 @@ static void __exit icn_exit(void)
 	unsigned long flags;
 
 	icn_stopallcards();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card) {
 		cmd.command = ISDN_STAT_UNLOAD;
 		cmd.driver = card->myid;
@@ -1676,13 +1769,30 @@ static void __exit icn_exit(void)
 		tmpcard = card->next;
 		spin_unlock_irqrestore(&card->lock, flags);
 		card = tmpcard;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	card = cards;
 	cards = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card) {
 		last = card;
 		card = card->next;
 		kfree(last);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (dev.mvalid) {
 		iounmap(dev.shmem);
diff -u -p a/isdn/capi/kcapi.c b/isdn/capi/kcapi.c
--- a/isdn/capi/kcapi.c
+++ b/isdn/capi/kcapi.c
@@ -320,13 +320,24 @@ static void recv_handler(struct work_str
 		return;
 
 	mutex_lock(&ap->recv_mtx);
-	while ((skb = skb_dequeue(&ap->recv_queue))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&ap->recv_queue))) {
 		if (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_IND)
 			ap->nrecvdatapkt++;
 		else
 			ap->nrecvctlpkt++;
 
 		ap->recv_message(ap, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&ap->recv_mtx);
 }
diff -u -p a/isdn/capi/capidrv.c b/isdn/capi/capidrv.c
--- a/isdn/capi/capidrv.c
+++ b/isdn/capi/capidrv.c
@@ -543,6 +543,11 @@ static struct listenstatechange listenta
 static void listen_change_state(capidrv_contr * card, int event)
 {
 	struct listenstatechange *p = listentable;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p->event) {
 		if (card->state == p->actstate && p->event == event) {
 			if (debugmode)
@@ -552,6 +557,12 @@ static void listen_change_state(capidrv_
 			return;
 		}
 		p++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "capidrv-%d: listen_change_state state=%d event=%d ????\n",
 	       card->contrnr, card->state, event);
@@ -638,6 +649,11 @@ static struct plcistatechange plcitable[
 static void plci_change_state(capidrv_contr * card, capidrv_plci * plci, int event)
 {
 	struct plcistatechange *p = plcitable;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p->event) {
 		if (plci->state == p->actstate && p->event == event) {
 			if (debugmode)
@@ -649,6 +665,12 @@ static void plci_change_state(capidrv_co
 			return;
 		}
 		p++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "capidrv-%d: plci_change_state:0x%x state=%d event=%d ????\n",
 	       card->contrnr, plci->plci, plci->state, event);
@@ -727,6 +749,11 @@ static struct nccistatechange nccitable[
 static void ncci_change_state(capidrv_contr * card, capidrv_ncci * ncci, int event)
 {
 	struct nccistatechange *p = nccitable;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p->event) {
 		if (ncci->state == p->actstate && p->event == event) {
 			if (debugmode)
@@ -744,6 +771,12 @@ static void ncci_change_state(capidrv_co
 			return;
 		}
 		p++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "capidrv-%d: ncci_change_state:0x%x state=%d event=%d ????\n",
 	       card->contrnr, ncci->ncci, ncci->state, event);
@@ -1512,6 +1545,11 @@ static int decodeFVteln(char *teln, unsi
 		active = !0;
 		s++;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*s) {
 		int digit1 = 0;
 		int digit2 = 0;
@@ -1550,6 +1588,12 @@ static int decodeFVteln(char *teln, unsi
 			continue;
 		}
 		return -6;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (activep) *activep = active;
 	if (bmaskp) *bmaskp = bmask;
@@ -2164,6 +2208,11 @@ static int capidrv_delcontr(u16 contr)
 	cmd.driver = card->myid;
 	card->interface.statcallb(&cmd);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card->nbchan) {
 
 		cmd.command = ISDN_STAT_DISCH;
@@ -2182,6 +2231,12 @@ static int capidrv_delcontr(u16 contr)
 		if (card->plci_list)
 			printk(KERN_ERR "capidrv: bug in free_plci()\n");
 		card->nbchan--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(card->bchans);
 	card->bchans = NULL;
diff -u -p a/isdn/hisax/hfc_sx.c b/isdn/hisax/hfc_sx.c
--- a/isdn/hisax/hfc_sx.c
+++ b/isdn/hisax/hfc_sx.c
@@ -271,9 +271,20 @@ read_fifo(struct IsdnCardState *cs, u_ch
 	  if ((count > fifo_size) || (count < 4)) {
 	    if (cs->debug & L1_DEB_WARN)
 	      debugl1(cs, "hfcsx_read_fifo %d paket inv. len %d ", fifo , count);
+	    unsigned long long delta = (cpu / khz / HZ) * 2;
+	    unsigned long long _start = 0;
+	    unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
 	    while (count) {
 	      count--; /* empty fifo */
 	      Read_hfc(cs, HFCSX_FIF_DRD);
+	      if (_cur < timeout) {
+		  rdstcll(_cur);
+	      }
+	      else {
+		  break;
+	      }
 	    }
 	    skb = NULL;
 	  } else 
@@ -734,6 +745,11 @@ hfcsx_interrupt(int intno, void *dev_id)
 		val &= ~0x80;
 		Write_hfc(cs, HFCSX_CTMT, cs->hw.hfcsx.ctmt | HFCSX_CLTIMER);
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (val) {
 		if (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {
 			cs->hw.hfcsx.int_s1 |= val;
@@ -851,6 +867,12 @@ hfcsx_interrupt(int intno, void *dev_id)
 				debugl1(cs, "HFC-SX irq %x loop %d", val, 15 - count);
 		} else
 			val = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	spin_unlock_irqrestore(&cs->lock, flags);
 	return IRQ_HANDLED;
diff -u -p a/isdn/hisax/hfc_pci.c b/isdn/hisax/hfc_pci.c
--- a/isdn/hisax/hfc_pci.c
+++ b/isdn/hisax/hfc_pci.c
@@ -619,6 +619,11 @@ hfcpci_fill_fifo(struct BCState *bcs)
 			fcnt += B_FIFO_SIZE;	/* fcnt contains available bytes in fifo */
 		fcnt = B_FIFO_SIZE - fcnt;	/* remaining bytes to send */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((fcnt < 2 * HFCPCI_BTRANS_THRESHOLD) && (bcs->tx_skb)) {
 			if (bcs->tx_skb->len < B_FIFO_SIZE - fcnt) {
 				/* data is suitable for fifo */
@@ -658,6 +663,12 @@ hfcpci_fill_fifo(struct BCState *bcs)
 
 			dev_kfree_skb_any(bcs->tx_skb);
 			bcs->tx_skb = skb_dequeue(&bcs->squeue);	/* fetch next data */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		test_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);
 		return;
@@ -969,6 +980,11 @@ hfcpci_interrupt(int intno, void *dev_id
 		val &= ~0x80;
 		Write_hfc(cs, HFCPCI_CTMT, cs->hw.hfcpci.ctmt | HFCPCI_CLTIMER);
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (val) {
 		if (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {
 			cs->hw.hfcpci.int_s1 |= val;
@@ -1086,6 +1102,12 @@ hfcpci_interrupt(int intno, void *dev_id
 				debugl1(cs, "HFC-PCI irq %x loop %d", val, 15 - count);
 		} else
 			val = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	spin_unlock_irqrestore(&cs->lock, flags);
 	return IRQ_HANDLED;
diff -u -p a/isdn/hisax/st5481_b.c b/isdn/hisax/st5481_b.c
--- a/isdn/hisax/st5481_b.c
+++ b/isdn/hisax/st5481_b.c
@@ -59,6 +59,11 @@ static void usb_b_out(struct st5481_bcs
 	b_out->flow_event = 0;
 
 	len = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len < buf_size) {
 		if ((skb = b_out->tx_skb)) {
 			DBG_SKB(0x100, skb);
@@ -105,6 +110,12 @@ static void usb_b_out(struct st5481_bcs
 						       urb->transfer_buffer+len, buf_size-len);
 			}
 		}	
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	// Prepare the URB
diff -u -p a/isdn/hisax/st5481_d.c b/isdn/hisax/st5481_d.c
--- a/isdn/hisax/st5481_d.c
+++ b/isdn/hisax/st5481_d.c
@@ -339,6 +339,11 @@ static void usb_d_out(struct st5481_adap
 	urb->transfer_buffer_length = len;
 	num_packets = 0;
 	packet_offset = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (packet_offset < len) {
 		desc = &urb->iso_frame_desc[num_packets];
 		desc->offset = packet_offset;
@@ -347,6 +352,12 @@ static void usb_d_out(struct st5481_adap
 			desc->length = len - packet_offset;
 		num_packets++;
 		packet_offset += desc->length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	urb->number_of_packets = num_packets;
 
diff -u -p a/isdn/hisax/avm_a1p.c b/isdn/hisax/avm_a1p.c
--- a/isdn/hisax/avm_a1p.c
+++ b/isdn/hisax/avm_a1p.c
@@ -147,6 +147,11 @@ avm_a1p_interrupt(int intno, void *dev_i
 	u_long flags;
 
 	spin_lock_irqsave(&cs->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((sval = (~bytein(cs->hw.avm.cfg_reg+ASL0_OFFSET) & ASL0_R_IRQPENDING))) {
 		if (cs->debug & L1_DEB_INTSTAT)
 			debugl1(cs, "avm IntStatus %x", sval);
@@ -160,6 +165,12 @@ avm_a1p_interrupt(int intno, void *dev_i
 			if (val)
 				isac_interrupt(cs, val);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	WriteHSCX(cs, 0, HSCX_MASK, 0xff);
 	WriteHSCX(cs, 1, HSCX_MASK, 0xff);
diff -u -p a/isdn/hisax/avm_pci.c b/isdn/hisax/avm_pci.c
--- a/isdn/hisax/avm_pci.c
+++ b/isdn/hisax/avm_pci.c
@@ -262,6 +262,11 @@ hdlc_empty_fifo(struct BCState *bcs, int
 	bcs->hw.hdlc.rcvidx += count;
 	if (cs->subtyp == AVM_FRITZ_PCI) {
 		outl(idx, cs->hw.avm.cfg_reg + 4);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cnt < count) {
 #ifdef __powerpc__
 			*ptr++ = in_be32((unsigned *)(cs->hw.avm.isac +_IO_BASE));
@@ -269,12 +274,29 @@ hdlc_empty_fifo(struct BCState *bcs, int
 			*ptr++ = inl(cs->hw.avm.isac);
 #endif /* __powerpc__ */
 			cnt += 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		outb(idx, cs->hw.avm.cfg_reg + 4);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cnt < count) {
 			*p++ = inb(cs->hw.avm.isac);
 			cnt++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (cs->debug & L1_DEB_HSCX_FIFO) {
@@ -323,6 +345,11 @@ hdlc_fill_fifo(struct BCState *bcs)
 	bcs->hw.hdlc.ctrl.sr.xml = ((count == fifo_size) ? 0 : count);
 	write_ctrl(bcs, 3);  /* sets the correct index too */
 	if (cs->subtyp == AVM_FRITZ_PCI) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cnt<count) {
 #ifdef __powerpc__
 			out_be32((unsigned *)(cs->hw.avm.isac +_IO_BASE), *ptr++);
@@ -330,11 +357,28 @@ hdlc_fill_fifo(struct BCState *bcs)
 			outl(*ptr++, cs->hw.avm.isac);
 #endif /* __powerpc__ */
 			cnt += 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cnt<count) {
 			outb(*p++, cs->hw.avm.isac);
 			cnt++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (cs->debug & L1_DEB_HSCX_FIFO) {
diff -u -p a/isdn/hisax/tei.c b/isdn/hisax/tei.c
--- a/isdn/hisax/tei.c
+++ b/isdn/hisax/tei.c
@@ -427,9 +427,20 @@ release_tei(struct IsdnCardState *cs)
 {
 	struct PStack *st = cs->stlist;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (st) {
 		FsmDelTimer(&st->ma.t202, 1);
 		st = st->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/isdn/hisax/hfc_2bs0.c b/isdn/hisax/hfc_2bs0.c
--- a/isdn/hisax/hfc_2bs0.c
+++ b/isdn/hisax/hfc_2bs0.c
@@ -24,11 +24,22 @@ WaitForBusy(struct IsdnCardState *cs)
 	int to = 130;
 	u_char val;
 
-	while (!(cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {
 		val = cs->BC_Read_Reg(cs, HFC_DATA, HFC_CIP | HFC_F2 |
 				      (cs->hw.hfc.cip & 3));
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (!to) {
 		printk(KERN_WARNING "HiSax: waitforBusy timeout\n");
@@ -42,9 +53,20 @@ WaitNoBusy(struct IsdnCardState *cs)
 {
 	int to = 125;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cs->BC_Read_Reg(cs, HFC_STATUS, 0) & HFC_BUSY) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!to) {
 		printk(KERN_WARNING "HiSax: waitforBusy timeout\n");
@@ -116,9 +138,20 @@ hfc_clear_fifo(struct BCState *bcs)
 				bcs->channel, z1, z2, rcnt);
 		cip = HFC_CIP | HFC_FIFO_OUT | HFC_REC | HFC_CHANNEL(bcs->channel);
 		idx = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((idx < rcnt) && WaitNoBusy(cs)) {
 			cs->BC_Read_Reg(cs, HFC_DATA_NODEB, cip);
 			idx++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (f1 != f2) {
 			WaitNoBusy(cs);
@@ -190,9 +223,20 @@ hfc_empty_fifo(struct BCState *bcs, int
 		ptr = skb_put(skb, count);
 		idx = 0;
 		cip = HFC_CIP | HFC_FIFO_OUT | HFC_REC | HFC_CHANNEL(bcs->channel);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((idx < count) && WaitNoBusy(cs)) {
 			*ptr++ = cs->BC_Read_Reg(cs, HFC_DATA_NODEB, cip);
 			idx++;
+			if (_cur < timeout) {
+			  rdstcll(_cur);
+			}
+			else {
+			  break;
+			}
 		}
 		if (idx != count) {
 			debugl1(cs, "RFIFO BUSY error");
diff -u -p a/isdn/hisax/diva.c b/isdn/hisax/diva.c
--- a/isdn/hisax/diva.c
+++ b/isdn/hisax/diva.c
@@ -295,6 +295,11 @@ diva_interrupt(int intno, void *dev_id)
 	int cnt=5;
 
 	spin_lock_irqsave(&cs->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (((sval = bytein(cs->hw.diva.ctrl)) & DIVA_IRQ_REQ) && cnt) {
 		val = readreg(cs->hw.diva.hscx_adr, cs->hw.diva.hscx, HSCX_ISTA + 0x40);
 		if (val)
@@ -303,6 +308,12 @@ diva_interrupt(int intno, void *dev_id)
 		if (val)
 			isac_interrupt(cs, val);
 		cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!cnt)
 		printk(KERN_WARNING "Diva: IRQ LOOP\n");
@@ -368,9 +379,20 @@ MemwaitforCEC(struct IsdnCardState *cs,
 {
 	int to = 50;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((MemReadHSCX(cs, hscx, HSCX_STAR) & 0x04) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!to)
 		printk(KERN_WARNING "HiSax: waitforCEC timeout\n");
@@ -1074,6 +1096,11 @@ static int __devinit setup_diva_isapnp(s
 	if (!isapnp_present())
 		return (-1);	/* card not found; continue search */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ipid->card_vendor) {
 		if ((pnp_c = pnp_find_card(ipid->card_vendor,
 			ipid->card_device, pnp_c))) {
@@ -1134,6 +1161,12 @@ static int __devinit setup_diva_isapnp(s
 		}
 		ipid++;
 		pnp_c=NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} 
 
 	return (-1);	/* card not found; continue search */
diff -u -p a/isdn/hisax/config.c b/isdn/hisax/config.c
--- a/isdn/hisax/config.c
+++ b/isdn/hisax/config.c
@@ -617,7 +617,12 @@ static int HiSax_readstatus(u_char __use
 			cs->status_read = cs->status_buf;
 		p += count;
 		count = len - count;
-		while (count) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (count) {
 			if (count > HISAX_STATUS_BUFSIZE)
 				cnt = HISAX_STATUS_BUFSIZE;
 			else
@@ -627,6 +632,12 @@ static int HiSax_readstatus(u_char __use
 			p += cnt;
 			cs->status_read += cnt % HISAX_STATUS_BUFSIZE;
 			count -= cnt;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		return len;
 	} else {
@@ -827,7 +838,12 @@ static int init_card(struct IsdnCardStat
 		       cs->irq);
 		return 1;
 	}
-	while (cnt) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt) {
 		cs->cardmsg(cs, CARD_INIT, NULL);
 		/* Timeout 10ms */
 		msleep(10);
@@ -848,6 +864,12 @@ static int init_card(struct IsdnCardStat
 			cs->cardmsg(cs, CARD_TEST, NULL);
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 3;
 }
@@ -1284,9 +1306,20 @@ void HiSax_closecard(int cardnr)
 		cards[cardnr].cs = NULL;
 	}
 	i = cardnr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i <= last) {
 		cards[i] = cards[i + 1];
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	nrcards--;
 }
diff -u -p a/isdn/hisax/hfc_2bds0.c b/isdn/hisax/hfc_2bds0.c
--- a/isdn/hisax/hfc_2bds0.c
+++ b/isdn/hisax/hfc_2bds0.c
@@ -85,9 +85,20 @@ WaitForBusy(struct IsdnCardState *cs)
 {
 	int to = 130;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(ReadReg(cs, HFCD_DATA, HFCD_STAT) & HFCD_BUSY) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!to)
 		printk(KERN_WARNING "HiSax: WaitForBusy timeout\n");
@@ -99,9 +110,20 @@ WaitNoBusy(struct IsdnCardState *cs)
 {
 	int to = 130;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ReadReg(cs, HFCD_STATUS, HFCD_STATUS) & HFCD_BUSY) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!to) 
 		printk(KERN_WARNING "HiSax: WaitNoBusy timeout\n");
@@ -782,6 +804,11 @@ hfc2bds0_interrupt(struct IsdnCardState
 		schedule_event(cs, D_L1STATECHANGE);
 		val &= ~0x40;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (val) {
 		if (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {
 			cs->hw.hfcD.int_s1 |= val;
@@ -896,6 +923,12 @@ hfc2bds0_interrupt(struct IsdnCardState
 				debugl1(cs, "HFCD irq %x loop %d", val, 15-count);
 		} else
 			val = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/isdn/hisax/isdnl1.c b/isdn/hisax/isdnl1.c
--- a/isdn/hisax/isdnl1.c
+++ b/isdn/hisax/isdnl1.c
@@ -158,12 +158,23 @@ L1activated(struct IsdnCardState *cs)
 	struct PStack *st;
 
 	st = cs->stlist;
-	while (st) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (st) {
 		if (test_and_clear_bit(FLG_L1_ACTIVATING, &st->l1.Flags))
 			st->l1.l1l2(st, PH_ACTIVATE | CONFIRM, NULL);
 		else
 			st->l1.l1l2(st, PH_ACTIVATE | INDICATION, NULL);
 		st = st->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -173,11 +184,22 @@ L1deactivated(struct IsdnCardState *cs)
 	struct PStack *st;
 
 	st = cs->stlist;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (st) {
 		if (test_bit(FLG_L1_DBUSY, &cs->HW_Flags))
 			st->l1.l1l2(st, PH_PAUSE | CONFIRM, NULL);
 		st->l1.l1l2(st, PH_DEACTIVATE | INDICATION, NULL);
 		st = st->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags);
 }
@@ -210,6 +232,11 @@ DChannel_proc_rcv(struct IsdnCardState *
 	if (stptr)
 		if (test_bit(FLG_L1_ACTTIMER, &stptr->l1.Flags))
 			FsmEvent(&stptr->l1.l1m, EV_TIMER_ACT, NULL);	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&cs->rq))) {
 #ifdef L2FRAME_DEBUG		/* psa */
 		if (cs->debug & L1_DEB_LAPD)
@@ -264,6 +291,12 @@ DChannel_proc_rcv(struct IsdnCardState *
 				dev_kfree_skb(skb);
 		} else
 			dev_kfree_skb(skb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -296,8 +329,19 @@ BChannel_proc_rcv(struct BCState *bcs)
 		FsmDelTimer(&bcs->st->l1.timer, 4);
 		FsmEvent(&bcs->st->l1.l1m, EV_TIMER_ACT, NULL);
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&bcs->rqueue))) {
 		bcs->st->l1.l1l2(bcs->st, PH_DATA | INDICATION, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -841,6 +885,11 @@ l1_msg(struct IsdnCardState *cs, int pr,
 
 	st = cs->stlist;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (st) {
 		switch(pr) {
 			case (HW_RESET | INDICATION):
@@ -871,6 +920,12 @@ l1_msg(struct IsdnCardState *cs, int pr,
 				break;
 		}
 		st = st->next;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
diff -u -p a/isdn/hisax/isdnl2.c b/isdn/hisax/isdnl2.c
--- a/isdn/hisax/isdnl2.c
+++ b/isdn/hisax/isdnl2.c
@@ -400,7 +400,12 @@ setva(struct PStack *st, unsigned int nr
 	u_long flags;
 
 	spin_lock_irqsave(&l2->lock, flags);
-	while (l2->va != nr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l2->va != nr) {
 		(l2->va)++;
 		if(test_bit(FLG_MOD128, &l2->flag))
 			l2->va %= 128;
@@ -416,6 +421,12 @@ setva(struct PStack *st, unsigned int nr
 		if (test_bit(FLG_LLI_L2WAKEUP, &st->lli.flag) && (len >=0))
 			lli_writewakeup(st, len);
 		spin_lock_irqsave(&l2->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&l2->lock, flags);
 }
@@ -598,9 +609,20 @@ tx_ui(struct PStack *st)
 
 	i = sethdraddr(&(st->l2), header, CMD);
 	header[i++] = UI;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&st->l2.ui_queue))) {
 		memcpy(skb_push(skb, i), header, i);
 		enqueue_ui(st, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -939,6 +961,11 @@ invoke_retransmission(struct PStack *st,
 
 	spin_lock_irqsave(&l2->lock, flags);
 	if (l2->vs != nr) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (l2->vs != nr) {
 			(l2->vs)--;
 			if(test_bit(FLG_MOD128, &l2->flag)) {
@@ -953,6 +980,12 @@ invoke_retransmission(struct PStack *st,
 				st->l1.bcs->tx_cnt += l2->windowar[p1]->len + l2headersize(l2, 0);
 			skb_queue_head(&l2->i_queue, l2->windowar[p1]);
 			l2->windowar[p1] = NULL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		spin_unlock_irqrestore(&l2->lock, flags);
 		st->l2.l2l1(st, PH_PULL | REQUEST, NULL);
diff -u -p a/isdn/hisax/isdnl3.c b/isdn/hisax/isdnl3.c
--- a/isdn/hisax/isdnl3.c
+++ b/isdn/hisax/isdnl3.c
@@ -91,6 +91,11 @@ findie(u_char * p, int size, u_char ie,
 	codeset = 0;
 	maincodeset = 0;
 	/* while there are bytes left... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p < pend) {
 		if ((*p & 0xf0) == 0x90) {
 			codeset = *p & 0x07;
@@ -118,6 +123,12 @@ findie(u_char * p, int size, u_char ie,
 			p += l;
 			codeset = maincodeset;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (NULL);
 }
@@ -281,6 +292,11 @@ release_l3_process(struct l3_process *p)
 	if (!p)
 		return;
 	np = p->st->l3.proc;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (np) {
 		if (np == p) {
 			StopAllL3Timer(p);
@@ -307,6 +323,12 @@ release_l3_process(struct l3_process *p)
 		}
 		pp = np;
 		np = np->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "HiSax internal L3 error CR(%d) not in list\n", p->callref);
 	l3_debug(p->st, "HiSax internal L3 error CR(%d) not in list", p->callref);
@@ -318,11 +340,22 @@ l3ml3p(struct PStack *st, int pr)
 	struct l3_process *p = st->l3.proc;
 	struct l3_process *np;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		/* p might be kfreed under us, so we need to save where we want to go on */
 		np = p->next;
 		st->l3.l3ml3(st, pr, p);
 		p = np;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -433,9 +466,20 @@ lc_connect(struct FsmInst *fi, int event
 	int dequeued = 0;
 
 	FsmChangeState(fi, ST_L3_LC_ESTAB);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&st->l3.squeue))) {
 		st->l3.l3l2(st, DL_DATA | REQUEST, skb);
 		dequeued++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if ((!st->l3.proc) &&  dequeued) {
 		if (st->l3.debug)
@@ -454,9 +498,20 @@ lc_connected(struct FsmInst *fi, int eve
 
 	FsmDelTimer(&st->l3.l3m_timer, 51);
 	FsmChangeState(fi, ST_L3_LC_ESTAB);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&st->l3.squeue))) {
 		st->l3.l3l2(st, DL_DATA | REQUEST, skb);
 		dequeued++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if ((!st->l3.proc) &&  dequeued) {
 		if (st->l3.debug)
diff -u -p a/isdn/hisax/l3ni1.c b/isdn/hisax/l3ni1.c
--- a/isdn/hisax/l3ni1.c
+++ b/isdn/hisax/l3ni1.c
@@ -114,10 +114,21 @@ l3ni1_search_dummy_proc(struct PStack *s
 
   if (!id) return(NULL);
 
-  while (pc)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
+   while (pc)
    { if ((pc->callref == -1) && (pc->prot.ni1.invoke_id == id))
        return(pc);
      pc = pc->next;
+     if (_cur < timeout) {
+       rdstcll(_cur);
+     }
+     else {
+       break;
+     }
    } 
   return(NULL);
 } /* l3ni1_search_dummy_proc */
@@ -678,6 +689,11 @@ check_infoelements(struct l3_process *pc
 	p += l;
 	mt = *p++;
 	oldpos = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((p - skb->data) < skb->len) {
 		if ((*p & 0xf0) == 0x90) { /* shift codeset */
 			old_codeset = codeset;
@@ -724,6 +740,12 @@ check_infoelements(struct l3_process *pc
 			codeset = old_codeset;
 			codelock = 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (err_compr | err_ureg | err_len | err_seq) {
 		if (pc->debug & L3_DEB_CHECK)
@@ -1207,12 +1229,23 @@ l3ni1_setup_req(struct l3_process *pc, u
 
 	sub = NULL;
 	sp = teln;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*sp) {
 		if ('.' == *sp) {
 			sub = sp;
 			*sp = 0;
 		} else
 			sp++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	
 	*p++ = IE_KEYPAD;
@@ -2557,6 +2590,11 @@ l3ni1_global_restart(struct l3_process *
 	}
 	newl3state(pc, 2);
 	up = pc->st->l3.proc;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (up) {
 		if ((ri & 7) == 7)
 			up->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);
@@ -2564,6 +2602,12 @@ l3ni1_global_restart(struct l3_process *
 			up->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);
 		
 		up = up->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	p = tmp;
 	MsgHead(p, pc->callref, MT_RESTART_ACKNOWLEDGE);
diff -u -p a/isdn/hisax/q931.c b/isdn/hisax/q931.c
--- a/isdn/hisax/q931.c
+++ b/isdn/hisax/q931.c
@@ -1287,6 +1287,11 @@ dlogframe(struct IsdnCardState *cs, stru
 		}
 
 		/* display each information element */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (buf < bend) {
 			/* Is it a single octet information element? */
 			if (*buf & 0x80) {
@@ -1349,6 +1354,12 @@ dlogframe(struct IsdnCardState *cs, stru
 				cs_fest = 0;
 			}
 			buf += buf[1] + 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else if ((buf[0] == 8) && (cs->protocol == ISDN_PTYPE_NI1)) {	/* NI-1 */
 		/* locate message type */
@@ -1374,6 +1385,11 @@ dlogframe(struct IsdnCardState *cs, stru
 				      size, mtlist[i].descr);
 
 		/* display each information element */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (buf < bend) {
 			/* Is it a single octet information element? */
 			if (*buf & 0x80) {
@@ -1435,6 +1451,12 @@ dlogframe(struct IsdnCardState *cs, stru
 				cs_fest = 0;
 			}
 			buf += buf[1] + 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else if ((buf[0] == 8) && (cs->protocol == ISDN_PTYPE_EURO)) { /* EURO */
 		/* locate message type */
@@ -1460,6 +1482,11 @@ dlogframe(struct IsdnCardState *cs, stru
 				      size, mtlist[i].descr);
 
 		/* display each information element */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (buf < bend) {
 			/* Is it a single octet information element? */
 			if (*buf & 0x80) {
@@ -1504,6 +1531,12 @@ dlogframe(struct IsdnCardState *cs, stru
 
 			/* Skip to next element */
 			buf += buf[1] + 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		dp += sprintf(dp, "Unknown protocol %x!", buf[0]);
diff -u -p a/isdn/hisax/sedlbauer.c b/isdn/hisax/sedlbauer.c
--- a/isdn/hisax/sedlbauer.c
+++ b/isdn/hisax/sedlbauer.c
@@ -539,6 +539,11 @@ setup_sedlbauer_isapnp(struct IsdnCard *
 	if (!isapnp_present())
 		return -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ipid->card_vendor) {
 		if ((pnp_c = pnp_find_card(ipid->card_vendor,
 			ipid->card_device, pnp_c))) {
@@ -584,6 +589,12 @@ setup_sedlbauer_isapnp(struct IsdnCard *
 		}
 		ipid++;
 		pnp_c = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} 
 
 	printk(KERN_INFO "Sedlbauer PnP: no ISAPnP card found\n");
diff -u -p a/isdn/hisax/amd7930_fn.c b/isdn/hisax/amd7930_fn.c
--- a/isdn/hisax/amd7930_fn.c
+++ b/isdn/hisax/amd7930_fn.c
@@ -370,11 +370,22 @@ Amd7930_fill_Dfifo(struct IsdnCardState
 
         /* while free place in tx-fifo available and data in sk-buffer */
         txstat = 0x10;
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while((txstat & 0x10) && (cs->tx_cnt < len)) {
                 wByteAMD(cs, 0x04, *ptr);
                 ptr++;
                 cs->tx_cnt++;
                 txstat= rByteAMD(cs, 0x07);
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
         }
         count = ptr - cs->tx_skb->data;
 	skb_pull(cs->tx_skb, count);
@@ -418,6 +429,11 @@ void Amd7930_interrupt(struct IsdnCardSt
 	BYTE dsr1, dsr2, lsr;
         WORD der;
 
+ unsigned long long delta = (cpu / khz / HZ) * 2;
+ unsigned long long _start = 0;
+ unsigned long long _cur = 0;
+ unsigned long long timeout;
+ timeout = rdstcll(start) + delta;
  while (irflags)
  {
 
@@ -550,6 +566,12 @@ void Amd7930_interrupt(struct IsdnCardSt
 
         /* reads Interrupt-Register again. If there is a new interrupt-flag: restart handler */
         irflags = rByteAMD(cs, 0x00);
+        if (_cur < timeout) {
+                rdstcll(_cur);
+        }
+        else {
+                break;
+        }
  }
 
 }
diff -u -p a/isdn/hisax/callc.c b/isdn/hisax/callc.c
--- a/isdn/hisax/callc.c
+++ b/isdn/hisax/callc.c
@@ -889,22 +889,44 @@ static struct Channel
 		chanp += 2;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < ((bch) ? cs->chanlimit : (2 + MAX_WAITING_CALLS))) {
 		if (chanp->fi.state == ST_NULL)
 			return (chanp);
 		chanp++;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (bch) /* number of channels is limited */ {
 		i = 2; /* virtual channel */
 		chanp = st->lli.userdata;
 		chanp += i;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (i < (2 + MAX_WAITING_CALLS)) {
 			if (chanp->fi.state == ST_NULL)
 				return (chanp);
 			chanp++;
 			i++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return (NULL);
diff -u -p a/isdn/hisax/ipacx.c b/isdn/hisax/ipacx.c
--- a/isdn/hisax/ipacx.c
+++ b/isdn/hisax/ipacx.c
@@ -847,7 +847,12 @@ interrupt_ipacx(struct IsdnCardState *cs
 {
 	u_char ista;
   
-	while ((ista = cs->readisac(cs, IPACX_ISTA))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while ((ista = cs->readisac(cs, IPACX_ISTA))) {
 //#################################################  
 //		printk(KERN_WARNING "interrupt_ipacx(ista=%02x)\n", ista);
 //#################################################  
@@ -856,6 +861,12 @@ interrupt_ipacx(struct IsdnCardState *cs
     
     if (ista &0x01) dch_int(cs);    // D channel
     if (ista &0x10) cic_int(cs);    // Layer 1 state
+    if (_cur < timeout) {
+        rdstcll(_cur);
+    }
+    else {
+        break;
+    }
   }  
 }
 
diff -u -p a/isdn/hisax/hscx_irq.c b/isdn/hisax/hscx_irq.c
--- a/isdn/hisax/hscx_irq.c
+++ b/isdn/hisax/hscx_irq.c
@@ -18,9 +18,20 @@ waitforCEC(struct IsdnCardState *cs, int
 {
 	int to = 50;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((READHSCX(cs, hscx, HSCX_STAR) & 0x04) && to) {
 		udelay(1);
 		to--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!to)
 		printk(KERN_WARNING "HiSax: waitforCEC timeout\n");
diff -u -p a/isdn/hisax/jade_irq.c b/isdn/hisax/jade_irq.c
--- a/isdn/hisax/jade_irq.c
+++ b/isdn/hisax/jade_irq.c
@@ -15,9 +15,20 @@ waitforCEC(struct IsdnCardState *cs, int
 {
   	int to = 50;
   	int mask = (reg == jade_HDLC_XCMD ? jadeSTAR_XCEC : jadeSTAR_RCEC);
+  	unsigned long long delta = (cpu / khz / HZ) * 2;
+  	unsigned long long _start = 0;
+  	unsigned long long _cur = 0;
+  	unsigned long long timeout;
+  	timeout = rdstcll(start) + delta;
   	while ((READJADE(cs, jade, jade_HDLC_STAR) & mask) && to) {
   		udelay(1);
   		to--;
+  		if (_cur < timeout) {
+  		  	rdstcll(_cur);
+  		}
+  		else {
+  		  	break;
+  		}
   	}
   	if (!to)
   		printk(KERN_WARNING "HiSax: waitforCEC (jade) timeout\n");
diff -u -p a/isdn/hisax/hfc4s8s_l1.c b/isdn/hisax/hfc4s8s_l1.c
--- a/isdn/hisax/hfc4s8s_l1.c
+++ b/isdn/hisax/hfc4s8s_l1.c
@@ -318,8 +318,19 @@ Read_hfc8_stable(hfc4s8s_hw * hw, int re
 	u_char ref8;
 	u_char in8;
 	ref8 = Read_hfc8(hw, reg);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (((in8 = Read_hfc8(hw, reg)) != ref8)) {
 		ref8 = in8;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return in8;
 }
@@ -331,8 +342,19 @@ Read_hfc16_stable(hfc4s8s_hw * hw, int r
 	int in16;
 
 	ref16 = Read_hfc16(hw, reg);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (((in16 = Read_hfc16(hw, reg)) != ref16)) {
 		ref16 = in16;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return in16;
 }
@@ -1095,6 +1117,11 @@ hfc4s8s_bh(struct work_struct *work)
 	/* handle layer 1 state changes */
 	b = 1;
 	l1p = hw->l1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (b) {
 		if ((b & hw->mr.r_irq_statech)) {
 			/* reset l1 event */
@@ -1197,12 +1224,23 @@ hfc4s8s_bh(struct work_struct *work)
 		}
 		b <<= 1;
 		l1p++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* now handle the fifos */
 	idx = 0;
 	fifo_stat = hw->mr.r_irq_fifo_blx;
 	l1p = hw->l1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (idx < hw->driver_data.max_st_ports) {
 
 		if (hw->mr.timer_irq) {
@@ -1216,6 +1254,11 @@ hfc4s8s_bh(struct work_struct *work)
 		/* ignore fifo 6 (TX E fifo) */
 		*fifo_stat &= 0xff - 0x40;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (*fifo_stat) {
 
 			if (!l1p->nt_mode) {
@@ -1255,10 +1298,22 @@ hfc4s8s_bh(struct work_struct *work)
 				*fifo_stat &= ~0x4;
 				tx_b_frame(l1p->b_ch + 1);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		fifo_stat++;
 		l1p++;
 		idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (hw->fifo_sched_cnt <= 0)
@@ -1309,6 +1364,11 @@ hfc4s8s_interrupt(int intno, void *dev_i
 		hw->mr.r_irq_oview |= ovr;
 		idx = R_IRQ_FIFO_BL0;
 		ovp = hw->mr.r_irq_fifo_blx;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ovr) {
 			if ((ovr & 1)) {
 				*ovp |= Read_hfc8(hw, idx);
@@ -1316,6 +1376,12 @@ hfc4s8s_interrupt(int intno, void *dev_i
 			ovp++;
 			idx++;
 			ovr >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/isdn/hisax/l3dss1.c b/isdn/hisax/l3dss1.c
--- a/isdn/hisax/l3dss1.c
+++ b/isdn/hisax/l3dss1.c
@@ -115,10 +115,21 @@ l3dss1_search_dummy_proc(struct PStack *
 
   if (!id) return(NULL);
 
-  while (pc)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
+   while (pc)
    { if ((pc->callref == -1) && (pc->prot.dss1.invoke_id == id))
        return(pc);
      pc = pc->next;
+     if (_cur < timeout) {
+       rdstcll(_cur);
+     }
+     else {
+       break;
+     }
    } 
   return(NULL);
 } /* l3dss1_search_dummy_proc */
@@ -728,6 +739,11 @@ check_infoelements(struct l3_process *pc
 	p += l;
 	mt = *p++;
 	oldpos = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((p - skb->data) < skb->len) {
 		if ((*p & 0xf0) == 0x90) { /* shift codeset */
 			old_codeset = codeset;
@@ -774,6 +790,12 @@ check_infoelements(struct l3_process *pc
 			codeset = old_codeset;
 			codelock = 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (err_compr | err_ureg | err_len | err_seq) {
 		if (pc->debug & L3_DEB_CHECK)
@@ -1313,12 +1335,23 @@ l3dss1_setup_req(struct l3_process *pc,
 	msn = pc->para.setup.eazmsn;
 	sub = NULL;
 	sp = msn;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*sp) {
 		if ('.' == *sp) {
 			sub = sp;
 			*sp = 0;
 		} else
 			sp++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (*msn) {
 		*p++ = IE_CALLING_PN;
@@ -1343,13 +1376,24 @@ l3dss1_setup_req(struct l3_process *pc,
 	}
 	sub = NULL;
 	sp = teln;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*sp) {
 		if ('.' == *sp) {
 			sub = sp;
 			*sp = 0;
 		} else
 			sp++;
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
+        }
 	
         if (!send_keypad) {      
 		*p++ = IE_CALLED_PN;
@@ -2701,12 +2745,23 @@ l3dss1_global_restart(struct l3_process
 	}
 	newl3state(pc, 2);
 	up = pc->st->l3.proc;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (up) {
 		if ((ri & 7) == 7)
 			up->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);
 		else if (up->para.bchannel == chan)
 			up->st->lli.l4l3(up->st, CC_RESTART | REQUEST, up);
 		up = up->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	p = tmp;
 	MsgHead(p, pc->callref, MT_RESTART_ACKNOWLEDGE);
diff -u -p a/isdn/hysdn/boardergo.c b/isdn/hysdn/boardergo.c
--- a/isdn/hysdn/boardergo.c
+++ b/isdn/hysdn/boardergo.c
@@ -277,6 +277,11 @@ ergo_writebootseq(struct HYSDN_CARD *car
 
 	/* try until all bytes written or error */
 	i = 0x1000;		/* timeout value */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 
 		/* first determine the number of bytes that may be buffered */
@@ -309,6 +314,12 @@ ergo_writebootseq(struct HYSDN_CARD *car
 			sp->WrPtr = wr_mirror;	/* announce the next byte to E1 */
 		}		/* while (nr_write) */
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}			/* while (len) */
 	return (0);
 }				/* ergo_writebootseq */
diff -u -p a/isdn/hysdn/hysdn_net.c b/isdn/hysdn/hysdn_net.c
--- a/isdn/hysdn/hysdn_net.c
+++ b/isdn/hysdn/hysdn_net.c
@@ -88,11 +88,22 @@ static void
 flush_tx_buffers(struct net_local *nl)
 {
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nl->sk_count) {
 		dev_kfree_skb(nl->skbs[nl->out_idx++]);		/* free skb */
 		if (nl->out_idx >= MAX_SKB_BUFFERS)
 			nl->out_idx = 0;	/* wrap around */
 		nl->sk_count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }				/* flush_tx_buffers */
 
diff -u -p a/isdn/hysdn/hysdn_proclog.c b/isdn/hysdn/hysdn_proclog.c
--- a/isdn/hysdn/hysdn_proclog.c
+++ b/isdn/hysdn/hysdn_proclog.c
@@ -302,17 +302,40 @@ hysdn_log_close(struct inode *ino, struc
 		if (pd)
 			pd->if_used--;	/* decrement interface usage count by one */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (inf) {
 			inf->usage_cnt--;	/* decrement usage count for buffers */
 			inf = inf->next;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 
 		if (pd)
-			if (pd->if_used <= 0)	/* delete buffers if last file closed */
-				while (pd->log_head) {
-					inf = pd->log_head;
-					pd->log_head = pd->log_head->next;
-					kfree(inf);
+			if (pd->if_used <= 0)	/* delete buffers if last file closed */ {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (pd->log_head) {
+						inf = pd->log_head;
+						pd->log_head = pd->log_head->next;
+						kfree(inf);
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
+					}
 				}
 	}			/* read access */
 	mutex_unlock(&hysdn_log_mutex);
diff -u -p a/isdn/hysdn/hysdn_procconf.c b/isdn/hysdn/hysdn_procconf.c
--- a/isdn/hysdn/hysdn_procconf.c
+++ b/isdn/hysdn/hysdn_procconf.c
@@ -391,6 +391,11 @@ hysdn_procconf_init(void)
 		return (-1);
 	}
 	card = card_root;	/* point to first card */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card) {
 
 		sprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);
@@ -401,6 +406,12 @@ hysdn_procconf_init(void)
 			hysdn_proclog_init(card);	/* init the log file entry */
 		}
 		card = card->next;	/* next entry */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk(KERN_NOTICE "HYSDN: procfs initialised\n");
@@ -418,6 +429,11 @@ hysdn_procconf_release(void)
 	unsigned char conf_name[20];
 
 	card = card_root;	/* start with first card */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card) {
 
 		sprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);
@@ -427,6 +443,12 @@ hysdn_procconf_release(void)
 		hysdn_proclog_release(card);	/* init the log file entry */
 
 		card = card->next;	/* point to next card */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	remove_proc_entry(PROC_SUBDIR_NAME, init_net.proc_net);
diff -u -p a/isdn/hysdn/hysdn_sched.c b/isdn/hysdn/hysdn_sched.c
--- a/isdn/hysdn/hysdn_sched.c
+++ b/isdn/hysdn/hysdn_sched.c
@@ -155,6 +155,11 @@ hysdn_tx_cfgline(hysdn_card *card, unsig
 	if (card->debug_flags & LOG_SCHED_ASYN)
 		hysdn_addlog(card, "async tx-cfg chan=%d len=%d", chan, strlen(line) + 1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card->async_busy) {
 
 		if (card->debug_flags & LOG_SCHED_ASYN)
@@ -163,6 +168,12 @@ hysdn_tx_cfgline(hysdn_card *card, unsig
 		msleep_interruptible(20);		/* Timeout 20ms */
 		if (!--cnt)
 			return (-ERR_ASYNC_TIME);	/* timed out */
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}			/* wait for buffer to become free */
 
 	spin_lock_irqsave(&card->hysdn_lock, flags);
@@ -180,6 +191,11 @@ hysdn_tx_cfgline(hysdn_card *card, unsig
 
 	cnt++;			/* short delay */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card->async_busy) {
 
 		if (card->debug_flags & LOG_SCHED_ASYN)
@@ -188,6 +204,12 @@ hysdn_tx_cfgline(hysdn_card *card, unsig
 		msleep_interruptible(20);		/* Timeout 20ms */
 		if (!--cnt)
 			return (-ERR_ASYNC_TIME);	/* timed out */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}			/* wait for buffer to become free again */
 
 	if (card->debug_flags & LOG_SCHED_ASYN)
diff -u -p a/isdn/hysdn/hysdn_init.c b/isdn/hysdn/hysdn_init.c
--- a/isdn/hysdn/hysdn_init.c
+++ b/isdn/hysdn/hysdn_init.c
@@ -131,11 +131,22 @@ static void __devexit hysdn_pci_remove_o
 			card_last = NULL;
 	} else {
 		hysdn_card *tmp = card_root;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tmp) {
 			if (tmp->next == card)
 				tmp->next = card->next;
 			card_last = tmp;
 			tmp = tmp->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/isdn/mISDN/dsp_tones.c b/isdn/mISDN/dsp_tones.c
--- a/isdn/mISDN/dsp_tones.c
+++ b/isdn/mISDN/dsp_tones.c
@@ -216,14 +216,36 @@ dsp_audio_generate_ulaw_samples(void)
 	int i, j;
 
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (samples[i].len) {
 		j = 0;
-		while (j < (*samples[i].len)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (j < (*samples[i].len)) {
 			samples[i].data[j] =
 				dsp_audio_alaw_to_ulaw[samples[i].data[j]];
 			j++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -391,6 +413,11 @@ void dsp_tone_copy(struct dsp *dsp, u8 *
 	count = tone->count; /* gives current sample */
 
 	/* copy sample */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		/* find sample to start with */
 		while (42) {
@@ -421,6 +448,12 @@ void dsp_tone_copy(struct dsp *dsp, u8 *
 		data += num;
 		count += num;
 		len -= num;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	tone->index = index;
 	tone->count = count;
diff -u -p a/isdn/mISDN/dsp_core.c b/isdn/mISDN/dsp_core.c
--- a/isdn/mISDN/dsp_core.c
+++ b/isdn/mISDN/dsp_core.c
@@ -735,6 +735,11 @@ dsp_function(struct mISDNchannel *ch,  s
 
 		/* send dtmf result, if any */
 		if (digits) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (*digits) {
 				int k;
 				struct sk_buff *nskb;
@@ -755,6 +760,12 @@ dsp_function(struct mISDNchannel *ch,  s
 						dev_kfree_skb(nskb);
 				}
 				digits++;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 		}
 		if (dsp->rx_disabled) {
@@ -781,6 +792,11 @@ dsp_function(struct mISDNchannel *ch,  s
 			}
 			digits = dsp_dtmf_goertzel_decode(dsp, skb->data,
 				skb->len, 2);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (*digits) {
 				int k;
 				struct sk_buff *nskb;
@@ -801,6 +817,12 @@ dsp_function(struct mISDNchannel *ch,  s
 						dev_kfree_skb(nskb);
 				}
 				digits++;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 			break;
 		case (HFC_VOL_CHANGE_TX): /* change volume */
@@ -1011,6 +1033,11 @@ dsp_send_bh(struct work_struct *work)
 		return; /* wait until data has been acknowledged */
 
 	/* send queued data */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&dsp->sendq))) {
 		/* in locked date, we must have still data in queue */
 		if (dsp->data_pending) {
@@ -1040,6 +1067,12 @@ dsp_send_bh(struct work_struct *work)
 			} else
 				dev_kfree_skb(skb);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
diff -u -p a/isdn/mISDN/hwchannel.c b/isdn/mISDN/hwchannel.c
--- a/isdn/mISDN/hwchannel.c
+++ b/isdn/mISDN/hwchannel.c
@@ -27,6 +27,11 @@ dchannel_bh(struct work_struct *ws)
 	int		err;
 
 	if (test_and_clear_bit(FLG_RECVQUEUE, &dch->Flags)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((skb = skb_dequeue(&dch->rqueue))) {
 			if (likely(dch->dev.D.peer)) {
 				err = dch->dev.D.recv(dch->dev.D.peer, skb);
@@ -34,6 +39,12 @@ dchannel_bh(struct work_struct *ws)
 					dev_kfree_skb(skb);
 			} else
 				dev_kfree_skb(skb);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+			}
 		}
 	}
 	if (test_and_clear_bit(FLG_PHCHANGE, &dch->Flags)) {
@@ -50,6 +61,11 @@ bchannel_bh(struct work_struct *ws)
 	int		err;
 
 	if (test_and_clear_bit(FLG_RECVQUEUE, &bch->Flags)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((skb = skb_dequeue(&bch->rqueue))) {
 			bch->rcount--;
 			if (likely(bch->ch.peer)) {
@@ -58,6 +74,12 @@ bchannel_bh(struct work_struct *ws)
 					dev_kfree_skb(skb);
 			} else
 				dev_kfree_skb(skb);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 }
diff -u -p a/isdn/mISDN/dsp_hwec.c b/isdn/mISDN/dsp_hwec.c
--- a/isdn/mISDN/dsp_hwec.c
+++ b/isdn/mISDN/dsp_hwec.c
@@ -75,6 +75,11 @@ void dsp_hwec_enable(struct dsp *dsp, co
 		strcpy(_dup, arg);
 		dup = _dup;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((tok = strsep(&dup, ","))) {
 			if (!strlen(tok))
 				continue;
@@ -88,6 +93,12 @@ void dsp_hwec_enable(struct dsp *dsp, co
 				if (sscanf(val, "%d", &tmp) == 1)
 					deftaps = tmp;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
diff -u -p a/isdn/mISDN/l1oip_codec.c b/isdn/mISDN/l1oip_codec.c
--- a/isdn/mISDN/l1oip_codec.c
+++ b/isdn/mISDN/l1oip_codec.c
@@ -239,11 +239,22 @@ l1oip_law_to_4bit(u8 *data, int len, u8
 
 	ii = len >> 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < ii) {
 		*result++ = table_com[(data[0]<<8) | (data[1])];
 		data += 2;
 		i++;
 		o++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if len has an odd number, we save byte for next call */
@@ -265,11 +276,22 @@ l1oip_4bit_to_law(u8 *data, int len, u8
 	int i = 0;
 	u16 r;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len) {
 		r = table_dec[*data++];
 		*result++ = r>>8;
 		*result++ = r;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return len << 1;
@@ -284,9 +306,20 @@ l1oip_alaw_to_ulaw(u8 *data, int len, u8
 {
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len) {
 		*result++ = alaw_to_ulaw[*data++];
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return len;
@@ -297,9 +330,20 @@ l1oip_ulaw_to_alaw(u8 *data, int len, u8
 {
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len) {
 		*result++ = ulaw_to_alaw[*data++];
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return len;
diff -u -p a/isdn/mISDN/dsp_audio.c b/isdn/mISDN/dsp_audio.c
--- a/isdn/mISDN/dsp_audio.c
+++ b/isdn/mISDN/dsp_audio.c
@@ -425,10 +425,21 @@ dsp_change_volume(struct sk_buff *skb, i
 	ii = skb->len;
 	p = skb->data;
 	/* change volume */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < ii) {
 		*p = volume_change[*p];
 		p++;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/isdn/mISDN/dsp_cmx.c b/isdn/mISDN/dsp_cmx.c
--- a/isdn/mISDN/dsp_cmx.c
+++ b/isdn/mISDN/dsp_cmx.c
@@ -1284,9 +1284,20 @@ dsp_cmx_receive(struct dsp *dsp, struct
 	w = dsp->rx_W;
 	i = 0;
 	ii = len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < ii) {
 		d[w++ & CMX_BUFF_MASK] = *p++;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* increase write-pointer */
@@ -1715,9 +1726,20 @@ dsp_cmx_send(void *arg)
 				r = dsp->rx_R;
 				rr = (r + length) & CMX_BUFF_MASK;
 				/* add member's data */
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (r != rr) {
 					*c++ += dsp_audio_law_to_s32[q[r]];
 					r = (r+1) & CMX_BUFF_MASK;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 
@@ -1741,9 +1763,20 @@ dsp_cmx_send(void *arg)
 		if (!dsp->rx_is_off) {
 			rr = (r + length) & CMX_BUFF_MASK;
 			/* delete rx-data */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (r != rr) {
 				p[r] = dsp_silence;
 				r = (r+1) & CMX_BUFF_MASK;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			/* increment rx-buffer pointer */
 			dsp->rx_R = r; /* write incremented read pointer */
@@ -1788,9 +1821,20 @@ dsp_cmx_send(void *arg)
 				rr = (r + delay - (dsp_poll >> 1))
 					& CMX_BUFF_MASK;
 				/* delete rx-data */
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (r != rr) {
 					p[r] = dsp_silence;
 					r = (r+1) & CMX_BUFF_MASK;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				/* increment rx-buffer pointer */
 				dsp->rx_R = r;
@@ -1819,9 +1863,20 @@ dsp_cmx_send(void *arg)
 				rr = (r + delay - (dsp_poll >> 1))
 					& CMX_BUFF_MASK;
 				/* delete tx-data */
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (r != rr) {
 					q[r] = dsp_silence;
 					r = (r+1) & CMX_BUFF_MASK;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				/* increment rx-buffer pointer */
 				dsp->tx_R = r;
@@ -1829,10 +1884,21 @@ dsp_cmx_send(void *arg)
 			}
 			/* scroll up delays */
 			i = MAX_SECONDS_JITTER_CHECK - 1;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (i) {
 				dsp->rx_delay[i] = dsp->rx_delay[i-1];
 				dsp->tx_delay[i] = dsp->tx_delay[i-1];
 				i--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			dsp->tx_delay[0] = CMX_BUFF_HALF; /* (infinite) delay */
 			dsp->rx_delay[0] = CMX_BUFF_HALF; /* (infinite) delay */
@@ -1895,6 +1961,11 @@ dsp_cmx_transmit(struct dsp *dsp, struct
 #ifdef CMX_TX_DEBUG
 	sprintf(debugbuf, "TX getting (%04x-%04x)%p: ", w, ww, p);
 #endif
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (w != ww) {
 #ifdef CMX_TX_DEBUG
 		if (strlen(debugbuf) < 48)
@@ -1902,7 +1973,13 @@ dsp_cmx_transmit(struct dsp *dsp, struct
 #endif
 		p[w] = *d++;
 		w = (w+1) & CMX_BUFF_MASK;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 #ifdef CMX_TX_DEBUG
 	printk(KERN_DEBUG "%s\n", debugbuf);
 #endif
diff -u -p a/isdn/mISDN/dsp_blowfish.c b/isdn/mISDN/dsp_blowfish.c
--- a/isdn/mISDN/dsp_blowfish.c
+++ b/isdn/mISDN/dsp_blowfish.c
@@ -377,6 +377,11 @@ dsp_bf_encrypt(struct dsp *dsp, u8 *data
 	u32 cs;
 	u8 nibble;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len) {
 		/* collect a block of 9 samples */
 		if (j < 9) {
@@ -442,6 +447,12 @@ dsp_bf_encrypt(struct dsp *dsp, u8 *data
 		bf_crypt_out[6] = ((yr>>15) & 0x7f) | ((cs<<6) & 0x80);
 		bf_crypt_out[7] = ((yr>>8) & 0x7f) | (cs<<7);
 		bf_crypt_out[8] = yr;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* write current count */
@@ -469,6 +480,11 @@ dsp_bf_decrypt(struct dsp *dsp, u8 *data
 	u8 nibble;
 	u8 cs, cs0, cs1, cs2;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len) {
 		/*
 		 * shift upper bit and rotate data to buffer ring
@@ -549,6 +565,12 @@ dsp_bf_decrypt(struct dsp *dsp, u8 *data
 		bf_data_out[7] = dsp_audio_seven2law[(yr>>8) & 0x7f];
 		bf_data_out[8] = dsp_audio_seven2law[(yr>>1) & 0x7f];
 		k = 0; /* start with new decoded frame */
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 
 	/* write current count and sync */
diff -u -p a/isdn/mISDN/dsp_pipeline.c b/isdn/mISDN/dsp_pipeline.c
--- a/isdn/mISDN/dsp_pipeline.c
+++ b/isdn/mISDN/dsp_pipeline.c
@@ -258,6 +258,11 @@ int dsp_pipeline_build(struct dsp_pipeli
 	if (!dup)
 		return 0;
 	strcpy(dup, cfg);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((tok = strsep(&dup, "|"))) {
 		if (!strlen(tok))
 			continue;
@@ -320,7 +325,13 @@ int dsp_pipeline_build(struct dsp_pipeli
 				"%s\n", __func__, name);
 			incomplete = 1;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 _out:
 	if (!list_empty(&pipeline->list))
diff -u -p a/isdn/mISDN/l1oip_core.c b/isdn/mISDN/l1oip_core.c
--- a/isdn/mISDN/l1oip_core.c
+++ b/isdn/mISDN/l1oip_core.c
@@ -729,7 +729,12 @@ l1oip_socket_thread(void *data)
 	if (debug & DEBUG_L1OIP_SOCKET)
 		printk(KERN_DEBUG "%s: socket created and open\n",
 			__func__);
-	while (!signal_pending(current)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!signal_pending(current)) {
 		struct kvec iov = {
 			.iov_base = recvbuf,
 			.iov_len = recvbuf_size,
@@ -743,15 +748,32 @@ l1oip_socket_thread(void *data)
 				printk(KERN_WARNING
 				    "%s: broken pipe on socket\n", __func__);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/* get socket back, check first if in use, maybe by send function */
 	spin_lock(&hc->socket_lock);
 	/* if hc->socket is NULL, it is in use until it is given back */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!hc->socket) {
 		spin_unlock(&hc->socket_lock);
 		schedule_timeout(HZ/10);
 		spin_lock(&hc->socket_lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	hc->socket = NULL;
 	spin_unlock(&hc->socket_lock);
@@ -915,12 +937,23 @@ handle_dmsg(struct mISDNchannel *ch, str
 		/* send frame */
 		p = skb->data;
 		l = skb->len;
-		while (l) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (l) {
 			ll = (l < L1OIP_MAX_PERFRAME) ? l : L1OIP_MAX_PERFRAME;
 			l1oip_socket_send(hc, 0, dch->slot, 0,
 				hc->chan[dch->slot].tx_counter++, p, ll);
 			p += ll;
 			l -= ll;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		skb_trim(skb, 0);
 		queue_ch_frame(ch, PH_DATA_CNF, hh->id, skb);
@@ -1163,13 +1196,24 @@ handle_bmsg(struct mISDNchannel *ch, str
 		/* send frame */
 		p = skb->data;
 		l = skb->len;
-		while (l) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (l) {
 			ll = (l < L1OIP_MAX_PERFRAME) ? l : L1OIP_MAX_PERFRAME;
 			l1oip_socket_send(hc, hc->codec, bch->slot, 0,
 				hc->chan[bch->slot].tx_counter, p, ll);
 			hc->chan[bch->slot].tx_counter += ll;
 			p += ll;
 			l -= ll;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		skb_trim(skb, 0);
 		queue_ch_frame(ch, PH_DATA_CNF, hh->id, skb);
diff -u -p a/isdn/mISDN/layer2.c b/isdn/mISDN/layer2.c
--- a/isdn/mISDN/layer2.c
+++ b/isdn/mISDN/layer2.c
@@ -570,7 +570,12 @@ setva(struct layer2 *l2, unsigned int nr
 {
 	struct sk_buff	*skb;
 
-	while (l2->va != nr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l2->va != nr) {
 		l2->va++;
 		if (test_bit(FLG_MOD128, &l2->flag))
 			l2->va %= 128;
@@ -582,11 +587,28 @@ setva(struct layer2 *l2, unsigned int nr
 			l2->windowar[l2->sow] = NULL;
 		}
 		l2->sow = (l2->sow + 1) % l2->window;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	skb = skb_dequeue(&l2->tmp_queue);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb) {
 		dev_kfree_skb(skb);
 		skb = skb_dequeue(&l2->tmp_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -777,9 +799,20 @@ tx_ui(struct layer2 *l2)
 	if (test_bit(FLG_LAPD_NET, &l2->flag))
 		header[1] = 0xff; /* tei 127 */
 	header[i++] = UI;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&l2->ui_queue))) {
 		memcpy(skb_push(skb, i), header, i);
 		enqueue_ui(l2, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1135,6 +1168,11 @@ invoke_retransmission(struct layer2 *l2,
 	u_int	p1;
 
 	if (l2->vs != nr) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (l2->vs != nr) {
 			(l2->vs)--;
 			if (test_bit(FLG_MOD128, &l2->flag)) {
@@ -1152,6 +1190,12 @@ invoke_retransmission(struct layer2 *l2,
 				    "%s: windowar[%d] is NULL\n",
 				    __func__, p1);
 			l2->windowar[p1] = NULL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		mISDN_FsmEvent(&l2->l2m, EV_L2_ACK_PULL, NULL);
 	}
diff -u -p a/isdn/pcbit/layer2.c b/isdn/pcbit/layer2.c
--- a/isdn/pcbit/layer2.c
+++ b/isdn/pcbit/layer2.c
@@ -291,6 +291,11 @@ pcbit_deliver(struct work_struct *work)
 
 	spin_lock_irqsave(&dev->lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((frame = dev->read_queue)) {
 		dev->read_queue = frame->next;
 		spin_unlock_irqrestore(&dev->lock, flags);
@@ -312,6 +317,12 @@ pcbit_deliver(struct work_struct *work)
 		kfree(frame);
 
 		spin_lock_irqsave(&dev->lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock_irqrestore(&dev->lock, flags);
@@ -539,9 +550,20 @@ pcbit_irq_handler(int interrupt, void *d
 	dev->interrupt = 0;
 
 	if (read_seq != dev->rcv_seq) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (read_seq != dev->rcv_seq) {
 			pcbit_receive(dev);
 			dev->rcv_seq = (dev->rcv_seq + 1) % 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		pcbit_sched_delivery(dev);
 	}
diff -u -p a/isdn/divert/divert_procfs.c b/isdn/divert/divert_procfs.c
--- a/isdn/divert/divert_procfs.c
+++ b/isdn/divert/divert_procfs.c
@@ -162,15 +162,38 @@ isdn_divert_close(struct inode *ino, str
 	spin_lock_irqsave( &divert_info_lock, flags );
 	if_used--;
 	inf = *((struct divert_info **) filep->private_data);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (inf) {
 		inf->usage_cnt--;
 		inf = inf->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
-	if (if_used <= 0)
-		while (divert_info_head) {
-			inf = divert_info_head;
-			divert_info_head = divert_info_head->next;
-			kfree(inf);
+	if (if_used <= 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (divert_info_head) {
+				inf = divert_info_head;
+				divert_info_head = divert_info_head->next;
+				kfree(inf);
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
+			}
 		}
 	spin_unlock_irqrestore( &divert_info_lock, flags );
 	return (0);
diff -u -p a/isdn/hardware/avm/t1isa.c b/isdn/hardware/avm/t1isa.c
--- a/isdn/hardware/avm/t1isa.c
+++ b/isdn/hardware/avm/t1isa.c
@@ -149,6 +149,11 @@ static irqreturn_t t1isa_interrupt(int i
 
 	spin_lock_irqsave(&card->lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (b1_rx_full(card->port)) {
 
 		b1cmd = b1_get_byte(card->port);
@@ -276,6 +281,12 @@ static irqreturn_t t1isa_interrupt(int i
 					card->name, b1cmd);
 			return IRQ_NONE;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return IRQ_HANDLED;
 }
diff -u -p a/isdn/hardware/eicon/di.c b/isdn/hardware/eicon/di.c
--- a/isdn/hardware/eicon/di.c
+++ b/isdn/hardware/eicon/di.c
@@ -103,6 +103,11 @@ void pr_out(ADAPTER * a)
     return;
   }
   ReqCount = 0;
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while(e_no && ReadyCount) {
     next_req(a);
     this = entity_ptr(a, e_no);
@@ -149,7 +154,12 @@ void pr_out(ADAPTER * a)
    } else { /* Use CMA extension in order to transfer data to the card */
       i = this->XCurrent;
       X = PTR_X(a,this);
-      while (i < this->XNum) {
+      unsigned long long delta = (cpu / khz / HZ) * 2;
+      unsigned long long _start = 0;
+      unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+        while (i < this->XNum) {
         diva_istream_write (a,
                             this->Id,
                             PTR_P(a,this,&X[i].P[0]),
@@ -157,6 +167,12 @@ void pr_out(ADAPTER * a)
                             ((i+1) == this->XNum),
                             0, 0);
         this->XCurrent = (byte)++i;
+        if (_cur < timeout) {
+        rdstcll(_cur);
+        }
+        else {
+        break;
+        }
       }
       length = 0;
    }
@@ -217,6 +233,12 @@ void pr_out(ADAPTER * a)
     ReadyCount--;
     ReqCount++;
     e_no = look_req(a);
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
         /* send the filled request buffers to the ISDN adapter      */
   a->ram_out(a, &PR_RAM->ReqInput,
diff -u -p a/isdn/hardware/eicon/s_4bri.c b/isdn/hardware/eicon/s_4bri.c
--- a/isdn/hardware/eicon/s_4bri.c
+++ b/isdn/hardware/eicon/s_4bri.c
@@ -330,6 +330,11 @@ int qBri_FPGA_download (PISDN_ADAPTER Io
 /*
  *	put data onto the FPGA
  */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ( code < FileLength )
 	{
 		val = ((word)File[code++]) << 3 ;
@@ -343,6 +348,12 @@ int qBri_FPGA_download (PISDN_ADAPTER Io
 			WRITE_WORD(addr, baseval | FPGA_CCLK) ;     /* set CCLK hi */
 			WRITE_WORD(addr, baseval) ;                 /* set CCLK lo */
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	xdiFreeFile (File) ;
 	diva_os_wait (100) ;
diff -u -p a/isdn/hardware/eicon/capidtmf.c b/isdn/hardware/eicon/capidtmf.c
--- a/isdn/hardware/eicon/capidtmf.c
+++ b/isdn/hardware/eicon/capidtmf.c
@@ -503,6 +503,11 @@ void capidtmf_recv_block (t_capidtmf_sta
   {
     cycle_counter = p_state->recv.cycle_counter;
     sample_number = 0;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (sample_number < length)
     {
       if (cycle_counter < CAPIDTMF_RECV_ACCUMULATE_CYCLES)
@@ -669,6 +674,12 @@ void capidtmf_recv_block (t_capidtmf_sta
         cycle_counter = 0;
         sample_number++;
       }
+      if (_cur < timeout) {
+        rdstcll(_cur);
+      }
+      else {
+        break;
+      }
     }
     p_state->recv.cycle_counter = cycle_counter;
   }
diff -u -p a/isdn/hardware/eicon/mntfunc.c b/isdn/hardware/eicon/mntfunc.c
--- a/isdn/hardware/eicon/mntfunc.c
+++ b/isdn/hardware/eicon/mntfunc.c
@@ -314,10 +314,21 @@ int DIVA_INIT_FUNCTION mntfunc_init(int
 	if (diva_dbg_mem) {
 		*buffer = (void *) diva_dbg_mem;
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((*buffer_length >= (64 * 1024))
 		       &&
 		       (!(*buffer = diva_os_malloc (0, *buffer_length)))) {
 			*buffer_length -= 1024;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (!*buffer) {
diff -u -p a/isdn/hardware/eicon/diva.c b/isdn/hardware/eicon/diva.c
--- a/isdn/hardware/eicon/diva.c
+++ b/isdn/hardware/eicon/diva.c
@@ -370,6 +370,11 @@ void divasa_xdi_driver_unload(void)
 {
 	diva_os_xdi_adapter_t *a;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((a = get_and_remove_from_queue())) {
 		if (a->interface.cleanup_adapter_proc) {
 			(*(a->interface.cleanup_adapter_proc)) (a);
@@ -379,6 +384,12 @@ void divasa_xdi_driver_unload(void)
 			remove_adapter_proc(a);
 		}
 		diva_os_free(0, a);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	diva_os_destroy_spin_lock(&adapter_lock, "adapter");
 }
diff -u -p a/isdn/hardware/eicon/message.c b/isdn/hardware/eicon/message.c
--- a/isdn/hardware/eicon/message.c
+++ b/isdn/hardware/eicon/message.c
@@ -473,6 +473,11 @@ word api_put(APPL   * appl, CAPI_MSG   *
         n = ncci_ptr->data_pending;
         l = ncci_ptr->data_ack_pending;
         k = plci->msg_in_read_pos;
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (k != plci->msg_in_write_pos)
         {
           if (k == plci->msg_in_wrap_pos)
@@ -488,6 +493,12 @@ word api_put(APPL   * appl, CAPI_MSG   *
           k += (((CAPI_MSG   *)(&((byte   *)(plci->msg_in_queue))[k]))->header.length +
             MSG_IN_OVERHEAD + 3) & 0xfffc;
 
+          if (_cur < timeout) {
+              rdstcll(_cur);
+          }
+          else {
+              break;
+          }
         }
         if ((n >= MAX_DATA_B3) || (l >= MAX_DATA_ACK))
         {
@@ -1021,6 +1032,11 @@ static void plci_free_msg_in_queue (PLCI
   if (plci->appl)
   {
     i = plci->msg_in_read_pos;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (i != plci->msg_in_write_pos)
     {
       if (i == plci->msg_in_wrap_pos)
@@ -1036,6 +1052,12 @@ static void plci_free_msg_in_queue (PLCI
       i += (((CAPI_MSG   *)(&((byte   *)(plci->msg_in_queue))[i]))->header.length +
         MSG_IN_OVERHEAD + 3) & 0xfffc;
 
+      if (_cur < timeout) {
+        rdstcll(_cur);
+      }
+      else {
+        break;
+      }
     }
   }
   plci->msg_in_write_pos = MSG_IN_QUEUE_SIZE;
@@ -8950,6 +8972,11 @@ static void IndParse(PLCI *plci, word *p
     parms[i] = (byte   *)"";
   }
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while(ploc<plci->Sig.RBuffer->length-1) {
 
         /* read information element id and length                   */
@@ -9003,6 +9030,12 @@ static void IndParse(PLCI *plci, word *p
     }
 
     ploc +=(wlen+1);
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
   return ;
 }
@@ -13089,17 +13122,39 @@ static void adv_voice_write_coefs (PLCI
   p = coef_buffer + 1;
   *(p++) = DSP_CTRL_OLD_SET_MIXER_COEFFICIENTS;
   i = 0;
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (i + sizeof(word) <= a->adv_voice_coef_length)
   {
     PUT_WORD (p, GET_WORD (a->adv_voice_coef_buffer + i));
     p += 2;
     i += 2;
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while (i < ADV_VOICE_OLD_COEF_COUNT * sizeof(word))
   {
     PUT_WORD (p, 0x8000);
     p += 2;
     i += 2;
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
 
   if (!a->li_pri && (plci->li_bchannel_id == 0))
@@ -13658,10 +13713,21 @@ static word adjust_b_process (dword Id,
       if (plci->adjust_b_ncci != 0)
       {
         ncci_ptr = &(plci->adapter->ncci[plci->adjust_b_ncci]);
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (ncci_ptr->data_pending)
         {
           plci->data_sent_ptr = ncci_ptr->DBuffer[ncci_ptr->data_out].P;
           data_rc (plci, plci->adapter->ncci_ch[plci->adjust_b_ncci]);
+          if (_cur < timeout) {
+        rdstcll(_cur);
+          }
+          else {
+        break;
+          }
         }
         while (ncci_ptr->data_ack_pending)
           data_ack (plci, plci->adapter->ncci_ch[plci->adjust_b_ncci]);
diff -u -p a/isdn/hardware/mISDN/hfcmulti.c b/isdn/hardware/mISDN/hfcmulti.c
--- a/isdn/hardware/mISDN/hfcmulti.c
+++ b/isdn/hardware/mISDN/hfcmulti.c
@@ -447,42 +447,108 @@ static void
 write_fifo_regio(struct hfc_multi *hc, u_char *data, int len)
 {
 	outb(A_FIFO_DATA0, (hc->pci_iobase)+4);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len>>2) {
 		outl(cpu_to_le32(*(u32 *)data), hc->pci_iobase);
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len>>1) {
 		outw(cpu_to_le16(*(u16 *)data), hc->pci_iobase);
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		outb(*data, hc->pci_iobase);
 		data++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 /* write fifo data (PCIMEM) */
 static void
 write_fifo_pcimem(struct hfc_multi *hc, u_char *data, int len)
 {
-	while (len>>2) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>2) {
 		writel(cpu_to_le32(*(u32 *)data),
 			hc->pci_membase + A_FIFO_DATA0);
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
-	while (len>>1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>1) {
 		writew(cpu_to_le16(*(u16 *)data),
 			hc->pci_membase + A_FIFO_DATA0);
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		writeb(*data, hc->pci_membase + A_FIFO_DATA0);
 		data++;
 		len--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -491,20 +557,53 @@ static void
 read_fifo_regio(struct hfc_multi *hc, u_char *data, int len)
 {
 	outb(A_FIFO_DATA0, (hc->pci_iobase)+4);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len>>2) {
 		*(u32 *)data = le32_to_cpu(inl(hc->pci_iobase));
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len>>1) {
 		*(u16 *)data = le16_to_cpu(inw(hc->pci_iobase));
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		*data = inb(hc->pci_iobase);
 		data++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -512,22 +611,55 @@ read_fifo_regio(struct hfc_multi *hc, u_
 static void
 read_fifo_pcimem(struct hfc_multi *hc, u_char *data, int len)
 {
-	while (len>>2) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>2) {
 		*(u32 *)data =
 			le32_to_cpu(readl(hc->pci_membase + A_FIFO_DATA0));
 		data += 4;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
-	while (len>>1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (len>>1) {
 		*(u16 *)data =
 			le16_to_cpu(readw(hc->pci_membase + A_FIFO_DATA0));
 		data += 2;
 		len -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		*data = readb(hc->pci_membase + A_FIFO_DATA0);
 		data++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1963,12 +2095,23 @@ next_frame:
 	if (dch || test_bit(FLG_HDLC, &bch->Flags)) {
 		f1 = HFC_inb_nodebug(hc, A_F1);
 		f2 = HFC_inb_nodebug(hc, A_F2);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (f2 != (temp = HFC_inb_nodebug(hc, A_F2))) {
 			if (debug & DEBUG_HFCMULTI_FIFO)
 				printk(KERN_DEBUG
 				    "%s(card %d): reread f2 because %d!=%d\n",
 				    __func__, hc->id + 1, temp, f2);
 			f2 = temp; /* repeat until F2 is equal */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		Fspace = f2 - f1 - 1;
 		if (Fspace < 0)
@@ -1996,11 +2139,22 @@ next_frame:
 	}
 	z1 = HFC_inw_nodebug(hc, A_Z1) - hc->Zmin;
 	z2 = HFC_inw_nodebug(hc, A_Z2) - hc->Zmin;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (z2 != (temp = (HFC_inw_nodebug(hc, A_Z2) - hc->Zmin))) {
 		if (debug & DEBUG_HFCMULTI_FIFO)
 			printk(KERN_DEBUG "%s(card %d): reread z2 because "
 				"%d!=%d\n", __func__, hc->id + 1, temp, z2);
 		z2 = temp; /* repeat unti Z2 is equal */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	hc->chan[ch].Zfill = z1 - z2;
 	if (hc->chan[ch].Zfill < 0)
@@ -2200,21 +2354,43 @@ next_frame:
 
 	if (dch || test_bit(FLG_HDLC, &bch->Flags)) {
 		f1 = HFC_inb_nodebug(hc, A_F1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (f1 != (temp = HFC_inb_nodebug(hc, A_F1))) {
 			if (debug & DEBUG_HFCMULTI_FIFO)
 				printk(KERN_DEBUG
 				    "%s(card %d): reread f1 because %d!=%d\n",
 				    __func__, hc->id + 1, temp, f1);
 			f1 = temp; /* repeat until F1 is equal */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		f2 = HFC_inb_nodebug(hc, A_F2);
 	}
 	z1 = HFC_inw_nodebug(hc, A_Z1) - hc->Zmin;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (z1 != (temp = (HFC_inw_nodebug(hc, A_Z1) - hc->Zmin))) {
 		if (debug & DEBUG_HFCMULTI_FIFO)
 			printk(KERN_DEBUG "%s(card %d): reread z2 because "
 				"%d!=%d\n", __func__, hc->id + 1, temp, z2);
 		z1 = temp; /* repeat until Z1 is equal */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	z2 = HFC_inw_nodebug(hc, A_Z2) - hc->Zmin;
 	Zsize = z1 - z2;
@@ -2564,6 +2740,11 @@ ph_state_irq(struct hfc_multi *hc, u_cha
 				udelay(1);
 				/* undocumented: status changes during read */
 				st_status = HFC_inb_nodebug(hc, A_ST_RD_STATE);
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (st_status != (temp =
 					HFC_inb_nodebug(hc, A_ST_RD_STATE))) {
 					if (debug & DEBUG_HFCMULTI_STATE)
@@ -2572,6 +2753,12 @@ ph_state_irq(struct hfc_multi *hc, u_cha
 						    __func__, temp,
 						    st_status);
 					st_status = temp; /* repeat */
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				/* Speech Design TE-sync indication */
@@ -2759,6 +2946,11 @@ hfcmulti_interrupt(int intno, void *dev_
 				}
 				/* undocumented: status changes during read */
 				dch->state = HFC_inb_nodebug(hc, R_E1_RD_STA);
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (dch->state != (temp =
 					HFC_inb_nodebug(hc, R_E1_RD_STA))) {
 					if (debug & DEBUG_HFCMULTI_STATE)
@@ -2767,6 +2959,12 @@ hfcmulti_interrupt(int intno, void *dev_
 						    __func__, temp,
 						    dch->state);
 					dch->state = temp; /* repeat */
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				dch->state = HFC_inb_nodebug(hc, R_E1_RD_STA)
 					& 0x7;
@@ -5101,9 +5299,20 @@ hfcmulti_init(struct hm_map *m, struct p
 			    __func__, HFC_cnt + 1, pt, ret_err);
 
 		if (ret_err) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (pt) { /* release already registered ports */
 				pt--;
 				release_port(hc, hc->chan[(pt << 2) + 2].dch);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 			}
 			goto free_card;
 		}
diff -u -p a/isdn/hardware/mISDN/hfcsusb.c b/isdn/hardware/mISDN/hfcsusb.c
--- a/isdn/hardware/mISDN/hfcsusb.c
+++ b/isdn/hardware/mISDN/hfcsusb.c
@@ -1972,11 +1972,21 @@ hfcsusb_probe(struct usb_interface *intf
 	iso_packet_size = 16;
 	packet_size = 64;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (alt_idx < intf->num_altsetting) {
 		iface = intf->altsetting + alt_idx;
 		probe_alt_setting = iface->desc.bAlternateSetting;
 		cfg_used = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (validconf[cfg_used][0]) {
 			cfg_found = 1;
 			vcf = validconf[cfg_used];
@@ -2026,8 +2036,20 @@ hfcsusb_probe(struct usb_interface *intf
 				}
 			}
 			cfg_used++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		alt_idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}	/* (alt_idx < intf->num_altsetting) */
 
 	/* not found a valid USB Ta Endpoint config */
diff -u -p a/isdn/hardware/mISDN/avmfritz.c b/isdn/hardware/mISDN/avmfritz.c
--- a/isdn/hardware/mISDN/avmfritz.c
+++ b/isdn/hardware/mISDN/avmfritz.c
@@ -423,11 +423,22 @@ hdlc_empty_fifo(struct bchannel *bch, in
 		addr = fc->addr + CHIP_WINDOW;
 		outl(bch->nr == 2 ? AVM_HDLC_2 : AVM_HDLC_1, fc->addr);
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt < count) {
 		val = le32_to_cpu(inl(addr));
 		put_unaligned(val, ptr);
 		ptr++;
 		cnt += 4;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (debug & DEBUG_HW_BFIFO) {
 		snprintf(fc->log, LOG_SIZE, "B%1d-recv %s %d ",
@@ -472,11 +483,22 @@ hdlc_fill_fifo(struct bchannel *bch)
 		__write_ctrl_pci(fc, hdlc, bch->nr);
 		addr = fc->addr + CHIP_WINDOW;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt < count) {
 		val = get_unaligned(ptr);
 		outl(cpu_to_le32(val), addr);
 		ptr++;
 		cnt += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (debug & DEBUG_HW_BFIFO) {
 		snprintf(fc->log, LOG_SIZE, "B%1d-send %s %d ",
diff -u -p a/isdn/hardware/mISDN/mISDNisar.c b/isdn/hardware/mISDN/mISDNisar.c
--- a/isdn/hardware/mISDN/mISDNisar.c
+++ b/isdn/hardware/mISDN/mISDNisar.c
@@ -53,10 +53,21 @@ waitforHIA(struct isar_hw *isar, int tim
 	int t = timeout;
 	u8 val = isar->read_reg(isar->hw, ISAR_HIA);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((val & 1) && t) {
 		udelay(1);
 		t--;
 		val = isar->read_reg(isar->hw, ISAR_HIA);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	pr_debug("%s: HIA after %dus\n", isar->name, timeout - t);
 	return timeout;
@@ -82,12 +93,23 @@ send_mbox(struct isar_hw *isar, u8 his,
 		if (isar->ch[0].bch.debug & DEBUG_HW_BFIFO) {
 			int l = 0;
 
-			while (l < (int)len) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (l < (int)len) {
 				hex_dump_to_buffer(msg + l, len - l, 32, 1,
 					isar->log, 256, 1);
 				pr_debug("%s: %s %02x: %s\n", isar->name,
 					__func__, l, isar->log);
 				l += 32;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
@@ -111,12 +133,23 @@ rcv_mbox(struct isar_hw *isar, u8 *msg)
 		if (isar->ch[0].bch.debug & DEBUG_HW_BFIFO) {
 			int l = 0;
 
-			while (l < (int)isar->clsb) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (l < (int)isar->clsb) {
 				hex_dump_to_buffer(msg + l, isar->clsb - l, 32,
 					1, isar->log, 256, 1);
 				pr_debug("%s: %s %02x: %s\n", isar->name,
 					__func__, l, isar->log);
 				l += 32;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
@@ -145,9 +178,20 @@ poll_mbox(struct isar_hw *isar, int maxd
 	u8 irq;
 
 	irq = isar->read_reg(isar->hw, ISAR_IRQBIT);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (t && !(irq & ISAR_IRQSTA)) {
 		udelay(1);
 		t--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (t)	{
 		get_irq_infos(isar);
@@ -213,6 +257,11 @@ load_firmware(struct isar_hw *isar, cons
 	spin_lock_irqsave(isar->hwlock, flags);
 	isar->write_reg(isar->hw, ISAR_IRQBIT, 0);
 	spin_unlock_irqrestore(isar->hwlock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt < size) {
 		blk_head.sadr = le16_to_cpu(*sp++);
 		blk_head.len = le16_to_cpu(*sp++);
@@ -262,11 +311,22 @@ load_firmware(struct isar_hw *isar, cons
 			pr_debug("%s: load %3d words at %04x\n", isar->name,
 				noc, blk_head.sadr);
 			blk_head.sadr += noc;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (noc) {
 				val = le16_to_cpu(*sp++);
 				*mp++ = val >> 8;
 				*mp++ = val & 0xFF;
 				noc--;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			spin_lock_irqsave(isar->hwlock, flags);
 			if (!send_mbox(isar, ISAR_HIS_FIRM, 0, nom, NULL)) {
@@ -290,6 +350,12 @@ load_firmware(struct isar_hw *isar, cons
 		}
 		pr_debug("%s: ISAR firmware block %d words loaded\n",
 			isar->name, blk_head.len);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	isar->ch[0].bch.debug = saved_debug;
 	/* 10ms delay */
@@ -323,9 +389,20 @@ load_firmware(struct isar_hw *isar, cons
 	isar->write_reg(isar->hw, ISAR_IRQBIT, ISAR_IRQSTA);
 	spin_unlock_irqrestore(isar->hwlock, flags);
 	cnt = 1000; /* max 1s */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((!isar->bstat) && cnt) {
 		mdelay(1);
 		cnt--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (!cnt) {
 		pr_info("ISAR no general status event received\n");
diff -u -p a/isdn/isdnloop/isdnloop.c b/isdn/isdnloop/isdnloop.c
--- a/isdn/isdnloop/isdnloop.c
+++ b/isdn/isdnloop/isdnloop.c
@@ -58,6 +58,11 @@ isdnloop_bchan_send(isdnloop_card * card
 	struct sk_buff *skb;
 	isdn_ctrl cmd;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card->sndcount[ch]) {
 		if ((skb = skb_dequeue(&card->bqueue[ch]))) {
 			len = skb->len;
@@ -77,6 +82,12 @@ isdnloop_bchan_send(isdnloop_card * card
 			card->interface.statcallb(&cmd);
 		} else
 			card->sndcount[ch] = 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -678,6 +689,11 @@ isdnloop_try_call(isdnloop_card * card,
 	char nbuf[32];
 
 	isdnloop_parse_setup(p, cmd);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cc) {
 		for (ch = 0; ch < 2; ch++) {
 			/* Exclude ourself */
@@ -692,12 +708,23 @@ isdnloop_try_call(isdnloop_card * card,
 					break;
 				case ISDN_PTYPE_1TR6:
 					e = cc->eazlist[ch];
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					while (*e) {
 						sprintf(nbuf, "%s%c", cc->s0num[0], *e);
 						if (!(strcmp(nbuf, cmd->parm.setup.phone)))
 							num_match = 1;
 						e++;
-					}
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
+				}
 			}
 			if (num_match) {
 				spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -724,6 +751,12 @@ isdnloop_try_call(isdnloop_card * card,
 			}
 		}
 		cc = cc->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 2;
 }
@@ -922,10 +955,21 @@ isdnloop_parse_cmd(isdnloop_card * card)
 			/* 0x;SETSIL */
 			p += 6;
 			i = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (strchr("0157", *p)) {
 				if (i)
 					card->sil[ch - 1] |= si2bit[*p - '0'];
 				i = (*p++ == '0');
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if (*p)
 				isdnloop_fake_err(card);
@@ -973,6 +1017,11 @@ isdnloop_writecmd(const u_char * buf, in
 	int ocount = 1;
 	isdn_ctrl cmd;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		int count = len;
 		u_char *p;
@@ -1005,6 +1054,12 @@ isdnloop_writecmd(const u_char * buf, in
 			}
 			ocount++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	cmd.command = ISDN_STAT_STAVAIL;
 	cmd.driver = card->myid;
@@ -1044,9 +1099,20 @@ isdnloop_stopallcards(void)
 {
 	isdnloop_card *p = cards;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		isdnloop_stopcard(p);
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1360,10 +1426,21 @@ isdnloop_findcard(int driverid)
 {
 	isdnloop_card *p = cards;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		if (p->myid == driverid)
 			return p;
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (isdnloop_card *) 0;
 }
@@ -1517,6 +1594,11 @@ isdnloop_exit(void)
 	int i;
 
 	isdnloop_stopallcards();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card) {
 		cmd.command = ISDN_STAT_UNLOAD;
 		cmd.driver = card->myid;
@@ -1524,13 +1606,30 @@ isdnloop_exit(void)
 		for (i = 0; i < ISDNLOOP_BCH; i++)
 			isdnloop_free_queue(card, i);
 		card = card->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	card = cards;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card) {
 		last = card;
 		skb_queue_purge(&card->dqueue);
 		card = card->next;
 		kfree(last);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_NOTICE "isdnloop-ISDN-driver unloaded\n");
 }
diff -u -p a/isdn/gigaset/ser-gigaset.c b/isdn/gigaset/ser-gigaset.c
--- a/isdn/gigaset/ser-gigaset.c
+++ b/isdn/gigaset/ser-gigaset.c
@@ -131,6 +131,11 @@ static int send_cb(struct cardstate *cs)
 			sent, cb->len, cs->cmdbytes);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cb && !cb->len) {
 		spin_lock_irqsave(&cs->cmdlock, flags);
 		cs->cmdbytes -= cs->curlen;
@@ -148,6 +153,12 @@ static int send_cb(struct cardstate *cs)
 		if (tcb->wake_tasklet)
 			tasklet_schedule(tcb->wake_tasklet);
 		kfree(tcb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return sent;
 }
diff -u -p a/isdn/gigaset/isocdata.c b/isdn/gigaset/isocdata.c
--- a/isdn/gigaset/isocdata.c
+++ b/isdn/gigaset/isocdata.c
@@ -945,6 +945,11 @@ void gigaset_isoc_input(struct inbuf_t *
 	unsigned char *src;
 
 	head = inbuf->head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (head != (tail = inbuf->tail)) {
 		gig_dbg(DEBUG_INTR, "buffer state: %u -> %u", head, tail);
 		if (head > tail)
@@ -966,6 +971,12 @@ void gigaset_isoc_input(struct inbuf_t *
 			head = 0;
 		gig_dbg(DEBUG_INTR, "setting head to %u", head);
 		inbuf->head = head;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/isdn/gigaset/capi.c b/isdn/gigaset/capi.c
--- a/isdn/gigaset/capi.c
+++ b/isdn/gigaset/capi.c
@@ -180,11 +180,22 @@ static inline void ignore_cstruct_param(
 static int encode_ie(char *in, u8 *out, int maxlen)
 {
 	int l = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*in) {
 		if (!isxdigit(in[0]) || !isxdigit(in[1]) || l >= maxlen)
 			return -1;
 		out[++l] = (hex_to_bin(in[0]) << 4) + hex_to_bin(in[1]);
 		in += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	out[0] = l;
 	return l;
@@ -771,13 +782,24 @@ void gigaset_isdn_connD(struct bc_state
 		return;
 	}
 	spin_unlock_irqrestore(&bcs->aplock, flags);
-	while (ap->bcnext) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ap->bcnext) {
 		/* this should never happen */
 		dev_warn(cs->dev, "%s: dropping extra application %u\n",
 			 __func__, ap->bcnext->id);
 		send_disconnect_ind(bcs, ap->bcnext,
 				    CapiCallGivenToOtherApplication);
 		ap->bcnext = ap->bcnext->bcnext;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* prepare CONNECT_ACTIVE_IND message
@@ -884,13 +906,24 @@ void gigaset_isdn_connB(struct bc_state
 
 	spin_unlock_irqrestore(&bcs->aplock, flags);
 
-	while (ap->bcnext) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ap->bcnext) {
 		/* this should never happen */
 		dev_warn(cs->dev, "%s: dropping extra application %u\n",
 			 __func__, ap->bcnext->id);
 		send_disconnect_ind(bcs, ap->bcnext,
 				    CapiCallGivenToOtherApplication);
 		ap->bcnext = ap->bcnext->bcnext;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	capi_cmsg_header(&iif->hcmsg, ap->id, command, CAPI_IND,
diff -u -p a/isdn/gigaset/common.c b/isdn/gigaset/common.c
--- a/isdn/gigaset/common.c
+++ b/isdn/gigaset/common.c
@@ -304,10 +304,21 @@ static void clear_events(struct cardstat
 	head = cs->ev_head;
 	tail = cs->ev_tail;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tail != head) {
 		ev = cs->events + head;
 		kfree(ev->ptr);
 		head = (head + 1) % MAX_EVENTS;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	cs->ev_head = tail;
@@ -858,10 +869,21 @@ static void cleanup_cs(struct cardstate
 	cs->inbuf->tail = 0;
 
 	cb = cs->cmdbuf;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cb) {
 		tcb = cb;
 		cb = cb->next;
 		kfree(tcb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	cs->cmdbuf = cs->lastcmdbuf = NULL;
 	cs->curlen = 0;
diff -u -p a/isdn/act2000/module.c b/isdn/act2000/module.c
--- a/isdn/act2000/module.c
+++ b/isdn/act2000/module.c
@@ -69,10 +69,21 @@ act2000_clear_msn(act2000_card *card)
 	spin_lock_irqsave(&card->lock, flags);
 	card->msn_list = NULL;
 	spin_unlock_irqrestore(&card->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		q  = p->next;
 		kfree(p);
 		p = q;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -109,10 +120,21 @@ act2000_find_eaz(act2000_card *card, cha
 {
         struct msn_entry *p = card->msn_list;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		if (p->eaz == eaz)
 			return(p->msn);
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return("\0");
 }
@@ -140,6 +162,11 @@ act2000_set_msn(act2000_card *card, char
 			return -EINVAL;
         if (strlen(eazmsn) == 1) {
 		/* Delete a single MSN */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (p) {
 			if (p->eaz == eazmsn[0]) {
 				spin_lock_irqsave(&card->lock, flags);
@@ -156,10 +183,21 @@ act2000_set_msn(act2000_card *card, char
 			}
 			q = p;
 			p = p->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		return 0;
         }
 	/* Add a single MSN */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		/* Found in list, replace MSN */
 		if (p->eaz == eazmsn[0]) {
@@ -173,6 +211,12 @@ act2000_set_msn(act2000_card *card, char
 			return 0;
 		}
 		p = p->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Not found in list, add new entry */
 	p = kmalloc(sizeof(msn_entry), GFP_KERNEL);
@@ -494,10 +538,21 @@ act2000_findcard(int driverid)
 {
         act2000_card *p = cards;
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (p) {
                 if (p->myid == driverid)
                         return p;
                 p = p->next;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
         }
         return (act2000_card *) 0;
 }
@@ -706,6 +761,11 @@ act2000_addcard(int bus, int port, int i
 	if (!cards)
 		return 1;
         p = cards;
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (p) {
 		initialized = 0;
 		if (!p->interface.statcallb) {
@@ -774,7 +834,13 @@ act2000_addcard(int bus, int port, int i
                         }
 			failed++;
                 }
-	}
+                if (_cur < timeout) {
+			rdstcll(_cur);
+                }
+                else {
+			break;
+                }
+        }
         return (added - failed);
 }
 
@@ -794,17 +860,39 @@ static void __exit act2000_exit(void)
 {
         act2000_card *card = cards;
         act2000_card *last;
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (card) {
                 unregister_card(card);
 		del_timer(&card->ptimer);
                 card = card->next;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
         }
         card = cards;
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (card) {
                 last = card;
                 card = card->next;
 		act2000_clear_msn(last);
                 kfree(last);
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
         }
         printk(KERN_INFO "%s unloaded\n", DRIVERNAME);
 }
diff -u -p a/isdn/act2000/capi.c b/isdn/act2000/capi.c
--- a/isdn/act2000/capi.c
+++ b/isdn/act2000/capi.c
@@ -276,6 +276,11 @@ actcapi_manufacturer_req_msn(act2000_car
 	struct sk_buff *skb;
 	int len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		int i;
 
@@ -294,7 +299,13 @@ actcapi_manufacturer_req_msn(act2000_car
 			ACTCAPI_QUEUE_TX;
 		}
 		p = p->next;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+        }
         return 0;
 }
 
@@ -600,6 +611,11 @@ handle_ack(act2000_card *card, act2000_c
 		return 0;
 	}
         tmp = skb;
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (1) {
                 m = (actcapi_msg *)tmp->data;
                 if ((((m->msg.data_b3_req.fakencci >> 8) & 0xff) == chan->ncci) &&
@@ -622,6 +638,12 @@ handle_ack(act2000_card *card, act2000_c
 			printk(KERN_WARNING "act2000: handle_ack nothing found!\n");
                         return 0;
 		}
+		if (_cur < timeout) {
+                        rdstcll(_cur);
+		}
+		else {
+                        break;
+		}
         }
 }
 
@@ -639,6 +661,11 @@ actcapi_dispatch(struct work_struct *wor
 	isdn_ctrl cmd;
 	char tmp[170];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&card->rcvq))) {
 		actcapi_debug_msg(skb, 0);
 		msg = (actcapi_msg *)skb->data;
@@ -934,6 +961,12 @@ actcapi_dispatch(struct work_struct *wor
 				break;
 		}
 		dev_kfree_skb(skb);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
diff -u -p a/isdn/act2000/act2000_isa.c b/isdn/act2000/act2000_isa.c
--- a/isdn/act2000/act2000_isa.c
+++ b/isdn/act2000/act2000_isa.c
@@ -198,6 +198,11 @@ act2000_isa_writeb(act2000_card * card,
 {
         u_char timeout = 40;
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (timeout) {
                 if (inb(ISA_PORT_SOS) & ISA_SOS_READY) {
                         outb(data, ISA_PORT_SDO);
@@ -206,6 +211,12 @@ act2000_isa_writeb(act2000_card * card,
                         timeout--;
                         udelay(10);
                 }
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
         }
         return 1;
 }
@@ -215,6 +226,11 @@ act2000_isa_readb(act2000_card * card, u
 {
         u_char timeout = 40;
 
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (timeout) {
                 if (inb(ISA_PORT_SIS) & ISA_SIS_READY) {
                         *data = inb(ISA_PORT_SDI);
@@ -223,6 +239,12 @@ act2000_isa_readb(act2000_card * card, u
                         timeout--;
                         udelay(10);
                 }
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
         }
         return 1;
 }
@@ -234,6 +256,11 @@ act2000_isa_receive(act2000_card *card)
 
         if (test_and_set_bit(ACT2000_LOCK_RX, (void *) &card->ilock) != 0)
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!act2000_isa_readb(card, &c)) {
 		if (card->idat.isa.rcvidx < 8) {
                         card->idat.isa.rcvhdr[card->idat.isa.rcvidx++] = c;
@@ -279,6 +306,12 @@ act2000_isa_receive(act2000_card *card)
 				card->idat.isa.rcvptr = card->idat.isa.rcvhdr;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!(card->flags & ACT2000_FLAGS_IVALID)) {
 		/* In polling mode, schedule myself */
@@ -300,6 +333,11 @@ act2000_isa_send(act2000_card * card)
 
         if (test_and_set_bit(ACT2000_LOCK_TX, (void *) &card->ilock) != 0)
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		spin_lock_irqsave(&card->lock, flags);
 		if (!(card->sbuf)) {
@@ -322,6 +360,11 @@ act2000_isa_send(act2000_card * card)
 		}
 		skb = card->sbuf;
 		l = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (skb->len) {
 			if (act2000_isa_writeb(card, *(skb->data))) {
 				/* Fifo is full, but more data to send */
@@ -332,6 +375,12 @@ act2000_isa_send(act2000_card * card)
 			}
 			skb_pull(skb, 1);
 			l++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		msg = (actcapi_msg *)card->ack_msg;
 		if ((msg->hdr.cmd.cmd == 0x86) &&
@@ -347,6 +396,12 @@ act2000_isa_send(act2000_card * card)
 		} else
 			dev_kfree_skb(skb);
 		card->sbuf = NULL;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -416,6 +471,11 @@ act2000_isa_download(act2000_card * card
         if (!buf)
                 return -ENOMEM;
         timeout = 0;
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (length) {
                 l = (length > 1024) ? 1024 : length;
                 c = 0;
@@ -424,7 +484,12 @@ act2000_isa_download(act2000_card * card
                         kfree(buf);
                         return -EFAULT;
                 }
-                while (c < l) {
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                timeout = rdstcll(start) + delta;
+                        while (c < l) {
                         if (act2000_isa_writeb(card, *b++)) {
                                 printk(KERN_WARNING
                                        "act2000: loader timed out"
@@ -433,9 +498,21 @@ act2000_isa_download(act2000_card * card
                                 return -ETIME;
                         }
                         c++;
+                        if (_cur < timeout) {
+                                rdstcll(_cur);
+                        }
+                        else {
+                                break;
+                        }
                 }
                 length -= l;
                 p += l;
+                if (_cur < timeout) {
+                        rdstcll(_cur);
+                }
+                else {
+                        break;
+                }
         }
         kfree(buf);
         msleep_interruptible(500);
diff -u -p a/misc/carma/carma-fpga-program.c b/misc/carma/carma-fpga-program.c
--- a/misc/carma/carma-fpga-program.c
+++ b/misc/carma/carma-fpga-program.c
@@ -299,11 +299,22 @@ static int fpga_enable_power_supplies(st
 	}
 
 	iowrite8(PWR_CONTROL_ENABLE, priv->regs + CTL_PWR_CONTROL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, start + HZ)) {
 		if (fpga_power_good(priv))
 			return 0;
 
 		usleep_range(5000, 10000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return fpga_power_good(priv) ? 0 : -ETIMEDOUT;
diff -u -p a/misc/carma/carma-fpga.c b/misc/carma/carma-fpga.c
--- a/misc/carma/carma-fpga.c
+++ b/misc/carma/carma-fpga.c
@@ -1093,6 +1093,11 @@ static ssize_t data_read(struct file *fi
 	spin_lock_irq(&priv->lock);
 
 	/* Block until there is at least one buffer on the used list */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (list_empty(used)) {
 		spin_unlock_irq(&priv->lock);
 
@@ -1104,6 +1109,12 @@ static ssize_t data_read(struct file *fi
 			return ret;
 
 		spin_lock_irq(&priv->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Grab the first buffer off of the used list */
diff -u -p a/misc/iwmc3200top/main.c b/misc/iwmc3200top/main.c
--- a/misc/iwmc3200top/main.c
+++ b/misc/iwmc3200top/main.c
@@ -611,12 +611,23 @@ static void iwmct_remove(struct sdio_fun
 	sdio_release_host(func);
 
 	/* free read requests */
-	while (!list_empty(&priv->read_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&priv->read_req_list)) {
 		read_req = list_entry(priv->read_req_list.next,
 			struct iwmct_work_struct, list);
 
 		list_del(&read_req->list);
 		kfree(read_req);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	kfree(priv);
diff -u -p a/misc/iwmc3200top/fw-download.c b/misc/iwmc3200top/fw-download.c
--- a/misc/iwmc3200top/fw-download.c
+++ b/misc/iwmc3200top/fw-download.c
@@ -115,6 +115,11 @@ static int iwmct_parse_next_section(stru
 
 	LOG_TRACE(priv, FW_DOWNLOAD, "-->\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (parser->cur_pos + sizeof(struct iwmct_fw_sec_hdr)
 		<= parser->file_size) {
 
@@ -150,6 +155,12 @@ static int iwmct_parse_next_section(stru
 		parser->cur_pos += le32_to_cpu(sec_hdr->data_size);
 		LOG_INFO(priv, FW_DOWNLOAD,
 			"finished with section cur_pos=%zd\n", parser->cur_pos);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	LOG_TRACE(priv, INIT, "<--\n");
@@ -340,13 +351,24 @@ int iwmct_fw_load(struct iwmct_priv *pri
 	}
 
 	/* download firmware to device */
-	while (iwmct_parse_next_section(priv, &pdata, &len, &addr)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (iwmct_parse_next_section(priv, &pdata, &len, &addr)) {
 		ret = iwmct_download_section(priv, pdata, len, addr);
 		if (ret) {
 			LOG_ERROR(priv, FW_DOWNLOAD,
 				  "%s download section failed\n", fw_name);
 			goto exit;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = iwmct_kick_fw(priv, !!(priv->barker & BARKER_DNLOAD_JUMP_MSK));
diff -u -p a/misc/ti-st/st_core.c b/misc/ti-st/st_core.c
--- a/misc/ti-st/st_core.c
+++ b/misc/ti-st/st_core.c
@@ -254,6 +254,11 @@ void st_int_recv(void *disc_data,
 
 	spin_lock_irqsave(&st_gdata->lock, flags);
 	/* Decode received bytes here */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		if (st_gdata->rx_count) {
 			len = min_t(unsigned int, st_gdata->rx_count, count);
@@ -359,7 +364,13 @@ void st_int_recv(void *disc_data,
 		};
 		ptr++;
 		count--;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 done:
 	spin_unlock_irqrestore(&st_gdata->lock, flags);
 	pr_debug("done %s", __func__);
diff -u -p a/misc/ti-st/st_kim.c b/misc/ti-st/st_kim.c
--- a/misc/ti-st/st_kim.c
+++ b/misc/ti-st/st_kim.c
@@ -134,6 +134,11 @@ void kim_int_recv(struct kim_data_s *kim
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		if (kim_gdata->rx_count) {
 			len = min_t(unsigned int, kim_gdata->rx_count, count);
@@ -190,6 +195,12 @@ void kim_int_recv(struct kim_data_s *kim
 		kim_gdata->rx_skb->cb[0] = 4;
 		kim_gdata->rx_skb->cb[1] = 0;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return;
 }
diff -u -p a/misc/enclosure.c b/misc/enclosure.c
--- a/misc/enclosure.c
+++ b/misc/enclosure.c
@@ -65,6 +65,11 @@ struct enclosure_device *enclosure_find(
 		struct device *parent = edev->edev.parent;
 		/* parent might not be immediate, so iterate up to
 		 * the root of the tree if necessary */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (parent) {
 			if (parent == dev) {
 				get_device(&edev->edev);
@@ -72,6 +77,12 @@ struct enclosure_device *enclosure_find(
 				return edev;
 			}
 			parent = parent->parent;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	mutex_unlock(&container_list_lock);
diff -u -p a/misc/sgi-gru/grufault.c b/misc/sgi-gru/grufault.c
--- a/misc/sgi-gru/grufault.c
+++ b/misc/sgi-gru/grufault.c
@@ -337,7 +337,12 @@ static void gru_preload_tlb(struct gru_s
 	vaddr &= PAGE_MASK;
 	vaddr = min(vaddr, fault_vaddr + tlb_preload_count * PAGE_SIZE);
 
-	while (vaddr > fault_vaddr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (vaddr > fault_vaddr) {
 		ret = gru_vtop(gts, vaddr, write, atomic, &gpa, &pageshift);
 		if (ret || tfh_write_only(tfh, gpa, GAA_RAM, vaddr, asid, write,
 					  GRU_PAGESIZE(pageshift)))
@@ -348,6 +353,12 @@ static void gru_preload_tlb(struct gru_s
 			vaddr, asid, write, pageshift, gpa);
 		vaddr -= PAGE_SIZE;
 		STAT(tlb_preload_page);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -627,7 +638,12 @@ static int gru_user_dropin(struct gru_th
 	int ret;
 
 	gts->ustats.upm_tlbmiss++;
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		wait_event(gms->ms_wait_queue,
 			   atomic_read(&gms->ms_range_active) == 0);
 		prefetchw(tfh);	/* Helps on hdw, required for emulator */
@@ -635,6 +651,12 @@ static int gru_user_dropin(struct gru_th
 		if (ret <= 0)
 			return ret;
 		STAT(call_os_wait_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/misc/sgi-gru/grukservices.c b/misc/sgi-gru/grukservices.c
--- a/misc/sgi-gru/grukservices.c
+++ b/misc/sgi-gru/grukservices.c
@@ -173,9 +173,20 @@ static void gru_load_kernel_context(stru
 		kgts->ts_dsr_au_count = GRU_DS_BYTES_TO_AU(
 			GRU_NUM_KERNEL_DSR_BYTES * ncpus +
 				bs->bs_async_dsr_bytes);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!gru_assign_gru_context(kgts)) {
 			msleep(1);
 			gru_steal_context(kgts);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		gru_load_context(kgts);
 		gru = bs->bs_kgts->ts_gru;
diff -u -p a/misc/ibmasm/event.c b/misc/ibmasm/event.c
--- a/misc/ibmasm/event.c
+++ b/misc/ibmasm/event.c
@@ -108,9 +108,20 @@ int ibmasm_get_next_event(struct service
 
 	index = buffer->next_index;
 	event = &buffer->events[index];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (event->serial_number < reader->next_serial_number) {
 		index = (index + 1) % IBMASM_NUM_EVENTS;
 		event = &buffer->events[index];
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	memcpy(reader->data, event->data, event->data_size);
 	reader->data_size = event->data_size;
diff -u -p a/misc/altera-stapl/altera-comp.c b/misc/altera-stapl/altera-comp.c
--- a/misc/altera-stapl/altera-comp.c
+++ b/misc/altera-stapl/altera-comp.c
@@ -106,6 +106,11 @@ u32 altera_shrink(u8 *in, u32 in_length,
 	}
 
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < data_length) {
 		/* A 0 bit indicates literal data. */
 		if (altera_read_packed(in, 1, &bits_avail,
@@ -136,6 +141,12 @@ u32 altera_shrink(u8 *in, u32 in_length,
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return data_length;
diff -u -p a/misc/sgi-xp/xpc_sn2.c b/misc/sgi-xp/xpc_sn2.c
--- a/misc/sgi-xp/xpc_sn2.c
+++ b/misc/sgi-xp/xpc_sn2.c
@@ -1477,7 +1477,12 @@ xpc_make_first_contact_sn2(struct xpc_pa
 				  part_sn2->activate_IRQ_nasid,
 				  part_sn2->activate_IRQ_phys_cpuid);
 
-	while ((ret = xpc_pull_remote_vars_part_sn2(part)) != xpSuccess) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((ret = xpc_pull_remote_vars_part_sn2(part)) != xpSuccess) {
 		if (ret != xpRetry) {
 			XPC_DEACTIVATE_PARTITION(part, ret);
 			return ret;
@@ -1491,6 +1496,12 @@ xpc_make_first_contact_sn2(struct xpc_pa
 
 		if (part->act_state == XPC_P_AS_DEACTIVATING)
 			return part->reason;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return xpSuccess;
@@ -1923,6 +1934,11 @@ xpc_pull_remote_msg_sn2(struct xpc_chann
 		return NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (get >= ch_sn2->next_msg_to_pull) {
 
 		/* pull as many messages as are ready and able to be pulled */
@@ -1957,6 +1973,12 @@ xpc_pull_remote_msg_sn2(struct xpc_chann
 		}
 
 		ch_sn2->next_msg_to_pull += nmsgs;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&ch_sn2->msg_to_pull_mutex);
diff -u -p a/misc/sgi-xp/xpc_main.c b/misc/sgi-xp/xpc_main.c
--- a/misc/sgi-xp/xpc_main.c
+++ b/misc/sgi-xp/xpc_main.c
@@ -266,7 +266,12 @@ xpc_hb_checker(void *ignore)
 	xpc_hb_check_timeout = jiffies + (xpc_hb_check_interval * HZ);
 	xpc_start_hb_beater();
 
-	while (!xpc_exiting) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!xpc_exiting) {
 
 		dev_dbg(xpc_part, "woke up with %d ticks rem; %d IRQs have "
 			"been received\n",
@@ -303,6 +308,12 @@ xpc_hb_checker(void *ignore)
 						xpc_hb_check_timeout) ||
 						xpc_activate_IRQ_rcvd > 0 ||
 						xpc_exiting));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	xpc_stop_hb_beater();
diff -u -p a/misc/atmel_pwm.c b/misc/atmel_pwm.c
--- a/misc/atmel_pwm.c
+++ b/misc/atmel_pwm.c
@@ -283,6 +283,11 @@ static irqreturn_t pwm_irq(int id, void
 	/* ack irqs, then handle them */
 	irqstat = pwm_readl(pwm, PWM_ISR);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (irqstat) {
 		struct pwm_channel *ch;
 		void (*handler)(struct pwm_channel *ch);
@@ -297,6 +302,12 @@ static irqreturn_t pwm_irq(int id, void
 			spin_lock(&p->lock);
 			handled = IRQ_HANDLED;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock(&p->lock);
diff -u -p a/misc/tifm_core.c b/misc/tifm_core.c
--- a/misc/tifm_core.c
+++ b/misc/tifm_core.c
@@ -50,10 +50,21 @@ static int tifm_bus_match(struct device
 	struct tifm_device_id *ids = fm_drv->id_table;
 
 	if (ids) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ids->type) {
 			if (tifm_dev_match(sock, ids))
 				return 1;
 			++ids;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 0;
diff -u -p a/misc/ad525x_dpot-spi.c b/misc/ad525x_dpot-spi.c
--- a/misc/ad525x_dpot-spi.c
+++ b/misc/ad525x_dpot-spi.c
@@ -113,10 +113,21 @@ static const struct ad_dpot_bus_ops bops
 static const struct ad_dpot_id *dpot_match_id(const struct ad_dpot_id *id,
 						char *name)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (id->name && id->name[0]) {
 		if (strcmp(name, id->name) == 0)
 			return id;
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/misc/kgdbts.c b/misc/kgdbts.c
--- a/misc/kgdbts.c
+++ b/misc/kgdbts.c
@@ -700,9 +700,20 @@ static void fill_get_buf(char *buf)
 
 	strcpy(get_buf, "$");
 	strcat(get_buf, buf);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ch = buf[count])) {
 		checksum += ch;
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	strcat(get_buf, "#");
 	get_buf[count + 2] = hex_asc_hi(checksum);
diff -u -p a/s390/cio/blacklist.c b/s390/cio/blacklist.c
--- a/s390/cio/blacklist.c
+++ b/s390/cio/blacklist.c
@@ -59,7 +59,12 @@ static int blacklist_range(range_action
 		return 1;
 	}
 
-	while ((from_ssid < to_ssid) || ((from_ssid == to_ssid) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((from_ssid < to_ssid) || ((from_ssid == to_ssid) &&
 	       (from <= to))) {
 		if (action == add)
 			set_bit(from, bl_dev[from_ssid]);
@@ -70,6 +75,12 @@ static int blacklist_range(range_action
 			from_ssid++;
 			from = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -157,6 +168,11 @@ static int blacklist_parse_parameters(ch
 
 	totalrc = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((parm = strsep(&str, ","))) {
 		rc = 0;
 		ra = action;
@@ -196,6 +212,12 @@ static int blacklist_parse_parameters(ch
 				totalrc = -EINVAL;
 		} else
 			totalrc = -EINVAL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return totalrc;
diff -u -p a/s390/cio/ccwgroup.c b/s390/cio/ccwgroup.c
--- a/s390/cio/ccwgroup.c
+++ b/s390/cio/ccwgroup.c
@@ -581,7 +581,12 @@ void ccwgroup_driver_unregister(struct c
 
 	/* We don't want ccwgroup devices to live longer than their driver. */
 	get_driver(&cdriver->driver);
-	while ((dev = driver_find_device(&cdriver->driver, NULL, NULL,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((dev = driver_find_device(&cdriver->driver, NULL, NULL,
 					 __ccwgroup_match_all))) {
 		struct ccwgroup_device *gdev = to_ccwgroupdev(dev);
 
@@ -591,6 +596,12 @@ void ccwgroup_driver_unregister(struct c
 		__ccwgroup_remove_cdev_refs(gdev);
 		mutex_unlock(&gdev->reg_mutex);
 		put_device(dev);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	put_driver(&cdriver->driver);
 	driver_unregister(&cdriver->driver);
diff -u -p a/s390/cio/airq.c b/s390/cio/airq.c
--- a/s390/cio/airq.c
+++ b/s390/cio/airq.c
@@ -130,6 +130,11 @@ void do_adapter_IO(u8 isc)
 		/*
 		 * Check bytes within word for active indicators.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (word) {
 			if (word & INDICATOR_MASK) {
 				airq = airqs[isc][i];
@@ -146,6 +151,12 @@ void do_adapter_IO(u8 isc)
 			}
 			word <<= 8;
 			i++;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 }
diff -u -p a/s390/net/lcs.c b/s390/net/lcs.c
--- a/s390/net/lcs.c
+++ b/s390/net/lcs.c
@@ -458,7 +458,12 @@ lcs_clear_multicast_list(struct lcs_card
 	/* Free multicast list. */
 	LCS_DBF_TEXT(3, setup, "clmclist");
 	spin_lock_irqsave(&card->ipm_lock, flags);
-	while (!list_empty(&card->ipm_list)){
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&card->ipm_list)){
 		ipm = list_entry(card->ipm_list.next,
 				 struct lcs_ipm_list, list);
 		list_del(&ipm->list);
@@ -468,6 +473,12 @@ lcs_clear_multicast_list(struct lcs_card
 			spin_lock_irqsave(&card->ipm_lock, flags);
 		}
 		kfree(ipm);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&card->ipm_lock, flags);
 #endif
@@ -1441,11 +1452,22 @@ lcs_irq(struct ccw_device *cdev, unsigne
 		    (irb->scsw.cmd.cstat & SCHN_STAT_PCI))
 			/* Bloody io subsystem tells us lies about cpa... */
 			index = (index - 1) & (LCS_NUM_BUFFS - 1);
-		while (channel->io_idx != index) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (channel->io_idx != index) {
 			__lcs_processed_buffer(channel,
 					       channel->iob + channel->io_idx);
 			channel->io_idx =
 				(channel->io_idx + 1) & (LCS_NUM_BUFFS - 1);
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 	}
 
diff -u -p a/s390/net/qeth_l3_main.c b/s390/net/qeth_l3_main.c
--- a/s390/net/qeth_l3_main.c
+++ b/s390/net/qeth_l3_main.c
@@ -48,9 +48,20 @@ static int __qeth_l3_set_offline(struct
 
 static int qeth_l3_isxdigit(char *buf)
 {
-	while (*buf) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (*buf) {
 		if (!isxdigit(*buf++))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 1;
 }
@@ -448,6 +459,11 @@ void qeth_l3_set_ip_addr_list(struct qet
 	} else
 		INIT_LIST_HEAD(card->ip_tbd_list);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(tbd_list)) {
 		todo = list_entry(tbd_list->next, struct qeth_ipaddr, entry);
 		list_del(&todo->entry);
@@ -481,6 +497,12 @@ void qeth_l3_set_ip_addr_list(struct qet
 				list_add_tail(&addr->entry, &card->ip_list);
 			kfree(todo);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&card->ip_lock, flags);
 	kfree(tbd_list);
@@ -501,7 +523,12 @@ static void qeth_l3_clear_ip_list(struct
 		kfree(addr);
 	}
 
-	while (!list_empty(&card->ip_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&card->ip_list)) {
 		addr = list_entry(card->ip_list.next,
 				  struct qeth_ipaddr, entry);
 		list_del_init(&addr->entry);
@@ -510,6 +537,12 @@ static void qeth_l3_clear_ip_list(struct
 			continue;
 		}
 		list_add_tail(&addr->entry, card->ip_tbd_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&card->ip_lock, flags);
 }
@@ -2079,6 +2112,11 @@ static int qeth_l3_poll(struct napi_stru
 			card->rx.e_offset = 0;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (card->rx.b_count) {
 			buffer = &card->qdio.in_q->bufs[card->rx.b_index];
 			if (!(card->rx.qdio_err &&
@@ -2112,6 +2150,12 @@ static int qeth_l3_poll(struct napi_stru
 				goto out;
 			else
 				new_budget = budget - work_done;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 
diff -u -p a/s390/net/netiucv.c b/s390/net/netiucv.c
--- a/s390/net/netiucv.c
+++ b/s390/net/netiucv.c
@@ -752,7 +752,12 @@ static void conn_action_txdone(fsm_insta
 	skb_reset_tail_pointer(conn->tx_buff);
 	conn->tx_buff->len = 0;
 	spin_lock_irqsave(&conn->collect_lock, saveflags);
-	while ((skb = skb_dequeue(&conn->collect_queue))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&conn->collect_queue))) {
 		header.next = conn->tx_buff->len + skb->len + NETIUCV_HDRLEN;
 		memcpy(skb_put(conn->tx_buff, NETIUCV_HDRLEN), &header,
 		       NETIUCV_HDRLEN);
@@ -764,6 +769,12 @@ static void conn_action_txdone(fsm_insta
 		stat_maxcq++;
 		atomic_dec(&skb->users);
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (conn->collect_len > conn->prof.maxmulti)
 		conn->prof.maxmulti = conn->collect_len;
@@ -952,9 +963,20 @@ static void netiucv_purge_skb_queue(stru
 {
 	struct sk_buff *skb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(q))) {
 		atomic_dec(&skb->users);
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2175,7 +2197,12 @@ static void __exit netiucv_exit(void)
 	struct device *dev;
 
 	IUCV_DBF_TEXT(trace, 3, __func__);
-	while (!list_empty(&iucv_connection_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&iucv_connection_list)) {
 		cp = list_entry(iucv_connection_list.next,
 				struct iucv_connection, list);
 		ndev = cp->netdev;
@@ -2184,6 +2211,12 @@ static void __exit netiucv_exit(void)
 
 		unregister_netdev(ndev);
 		netiucv_unregister_device(dev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	device_unregister(netiucv_dev);
diff -u -p a/s390/net/ctcm_fsms.c b/s390/net/ctcm_fsms.c
--- a/s390/net/ctcm_fsms.c
+++ b/s390/net/ctcm_fsms.c
@@ -218,9 +218,20 @@ void ctcm_purge_skb_queue(struct sk_buff
 
 	CTCM_DBF_TEXT(TRACE, CTC_DBF_DEBUG, __func__);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(q))) {
 		atomic_dec(&skb->users);
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -268,6 +279,11 @@ static void chx_txdone(fsm_instance *fi,
 			"%s(%s): TX not complete, remaining %d bytes",
 			     CTCM_FUNTAIL, dev->name, ch->irb->scsw.cmd.count);
 	fsm_deltimer(&ch->timer);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&ch->io_queue))) {
 		priv->stats.tx_packets++;
 		priv->stats.tx_bytes += skb->len - LL_HEADER_LENGTH;
@@ -277,6 +293,12 @@ static void chx_txdone(fsm_instance *fi,
 		}
 		atomic_dec(&skb->users);
 		dev_kfree_skb_irq(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_lock(&ch->collect_lock);
 	clear_normalized_cda(&ch->ccw[4]);
@@ -296,7 +318,12 @@ static void chx_txdone(fsm_instance *fi,
 			ch->prof.maxcqueue = skb_queue_len(&ch->collect_queue);
 		*((__u16 *)skb_put(ch->trans_skb, 2)) = ch->collect_len + 2;
 		i = 0;
-		while ((skb = skb_dequeue(&ch->collect_queue))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((skb = skb_dequeue(&ch->collect_queue))) {
 			skb_copy_from_linear_data(skb,
 				skb_put(ch->trans_skb, skb->len), skb->len);
 			priv->stats.tx_packets++;
@@ -304,6 +331,12 @@ static void chx_txdone(fsm_instance *fi,
 			atomic_dec(&skb->users);
 			dev_kfree_skb_irq(skb);
 			i++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		ch->collect_len = 0;
 		spin_unlock(&ch->collect_lock);
@@ -1247,6 +1280,11 @@ static void ctcmpc_chx_txdone(fsm_instan
 			"%s(%s): TX not complete, remaining %d bytes",
 			     CTCM_FUNTAIL, dev->name, ch->irb->scsw.cmd.count);
 	fsm_deltimer(&ch->timer);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&ch->io_queue))) {
 		priv->stats.tx_packets++;
 		priv->stats.tx_bytes += skb->len - TH_HEADER_LENGTH;
@@ -1256,6 +1294,12 @@ static void ctcmpc_chx_txdone(fsm_instan
 		}
 		atomic_dec(&skb->users);
 		dev_kfree_skb_irq(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_lock(&ch->collect_lock);
 	clear_normalized_cda(&ch->ccw[4]);
diff -u -p a/s390/net/qeth_core_main.c b/s390/net/qeth_core_main.c
--- a/s390/net/qeth_core_main.c
+++ b/s390/net/qeth_core_main.c
@@ -367,6 +367,11 @@ static inline void qeth_cleanup_handled_
 		struct qeth_qdio_out_buffer *head = q->bufs[bidx];
 		struct qeth_qdio_out_buffer *c = q->bufs[bidx]->next_pending;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (c) {
 			if (forced_cleanup ||
 			    atomic_read(&c->state) ==
@@ -388,6 +393,12 @@ static inline void qeth_cleanup_handled_
 				c = c->next_pending;
 			}
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 }
@@ -1092,6 +1103,11 @@ static void qeth_notify_skbs(struct qeth
 	if (skb_queue_empty(&buf->skb_list))
 		goto out;
 	skb = skb_peek(&buf->skb_list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb) {
 		QETH_CARD_TEXT_(q->card, 5, "skbn%d", notification);
 		QETH_CARD_TEXT_(q->card, 5, "%lx", (long) skb);
@@ -1105,7 +1121,13 @@ static void qeth_notify_skbs(struct qeth
 			skb = NULL;
 		else
 			skb = skb_queue_next(&buf->skb_list, skb);
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+}
 out:
 	return;
 }
@@ -1115,12 +1137,23 @@ static void qeth_release_skbs(struct qet
 	struct sk_buff *skb;
 
 	skb = skb_dequeue(&buf->skb_list);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb) {
 		QETH_CARD_TEXT(buf->q->card, 5, "skbr");
 		QETH_CARD_TEXT_(buf->q->card, 5, "%lx", (long) skb);
 		atomic_dec(&skb->users);
 		dev_kfree_skb_any(skb);
 		skb = skb_dequeue(&buf->skb_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1432,6 +1465,11 @@ static int qeth_determine_card_type(stru
 
 	card->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;
 	card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (known_devices[i][QETH_DEV_MODEL_IND]) {
 		if ((CARD_RDEV(card)->id.dev_type ==
 				known_devices[i][QETH_DEV_TYPE_IND]) &&
@@ -1447,6 +1485,12 @@ static int qeth_determine_card_type(stru
 			return 0;
 		}
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	card->info.type = QETH_CARD_TYPE_UNKNOWN;
 	dev_err(&card->gdev->dev, "The adapter hardware is of an "
@@ -1994,10 +2038,21 @@ int qeth_send_control_data(struct qeth_c
 		    atomic_read(&reply->received), event_timeout))
 			goto time_err;
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!atomic_read(&reply->received)) {
 			if (time_after(jiffies, timeout))
 				goto time_err;
 			cpu_relax();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		};
 	}
 
@@ -3432,6 +3487,11 @@ static void qeth_qdio_cq_handler(struct
 		int e;
 
 		e = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (buffer->element[e].addr) {
 			unsigned long phys_aob_addr;
 
@@ -3443,6 +3503,12 @@ static void qeth_qdio_cq_handler(struct
 			buffer->element[e].length = 0;
 
 			++e;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		buffer->element[15].eflags = 0;
@@ -3864,6 +3930,11 @@ int qeth_do_send_packet(struct qeth_card
 	 * (switch packing state or flush buffer to get another pci flag out).
 	 * In that case we will enter this loop
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (atomic_dec_return(&queue->state)) {
 		flush_count = 0;
 		start_index = queue->next_buf_to_fill;
@@ -3877,6 +3948,12 @@ int qeth_do_send_packet(struct qeth_card
 			flush_count += qeth_flush_buffers_on_no_pci(queue);
 		if (flush_count)
 			qeth_flush_buffers(queue, start_index, flush_count);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* at this point the queue is UNLOCKED again */
 	if (queue->card->options.performance_stats && do_pack)
@@ -4812,6 +4889,11 @@ struct sk_buff *qeth_core_get_next_skb(s
 	}
 
 	data_ptr = element->addr + offset;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb_len) {
 		data_len = min(skb_len, (int)(element->length - offset));
 		if (data_len) {
@@ -4839,6 +4921,12 @@ struct sk_buff *qeth_core_get_next_skb(s
 		} else {
 			offset += data_len;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*__element = element;
 	*__offset = offset;
diff -u -p a/s390/net/qeth_l2_main.c b/s390/net/qeth_l2_main.c
--- a/s390/net/qeth_l2_main.c
+++ b/s390/net/qeth_l2_main.c
@@ -479,6 +479,11 @@ static int qeth_l2_poll(struct napi_stru
 			card->rx.e_offset = 0;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (card->rx.b_count) {
 			buffer = &card->qdio.in_q->bufs[card->rx.b_index];
 			if (!(card->rx.qdio_err &&
@@ -512,6 +517,12 @@ static int qeth_l2_poll(struct napi_stru
 				goto out;
 			else
 				new_budget = budget - work_done;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 
diff -u -p a/s390/char/sclp_vt220.c b/s390/char/sclp_vt220.c
--- a/s390/char/sclp_vt220.c
+++ b/s390/char/sclp_vt220.c
@@ -395,13 +395,24 @@ __sclp_vt220_write(const unsigned char *
 	do {
 		/* Create an sclp output buffer if none exists yet */
 		if (sclp_vt220_current_request == NULL) {
-			while (list_empty(&sclp_vt220_empty)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (list_empty(&sclp_vt220_empty)) {
 				spin_unlock_irqrestore(&sclp_vt220_lock, flags);
 				if (may_fail || sclp_vt220_suspended)
 					goto out;
 				else
 					sclp_sync_wait();
 				spin_lock_irqsave(&sclp_vt220_lock, flags);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			page = (void *) sclp_vt220_empty.next;
 			list_del((struct list_head *) page);
@@ -718,10 +729,21 @@ static void __sclp_vt220_flush_buffer(vo
 	spin_lock_irqsave(&sclp_vt220_lock, flags);
 	if (timer_pending(&sclp_vt220_timer))
 		del_timer(&sclp_vt220_timer);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sclp_vt220_queue_running) {
 		spin_unlock_irqrestore(&sclp_vt220_lock, flags);
 		sclp_sync_wait();
 		spin_lock_irqsave(&sclp_vt220_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&sclp_vt220_lock, flags);
 }
diff -u -p a/s390/char/raw3270.c b/s390/char/raw3270.c
--- a/s390/char/raw3270.c
+++ b/s390/char/raw3270.c
@@ -521,10 +521,22 @@ raw3270_start_init(struct raw3270 *rp, s
 		spin_lock_irqsave(get_ccwdev_lock(view->dev->cdev), flags);
 		rq->callback = NULL;
 		rc = __raw3270_start(rp, view, rq);
-		if (rc == 0)
-			while (!raw3270_request_final(rq)) {
-				wait_cons_dev();
-				barrier();
+		if (rc == 0) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!raw3270_request_final(rq)) {
+					wait_cons_dev();
+					barrier();
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
+				}
 			}
 		spin_unlock_irqrestore(get_ccwdev_lock(view->dev->cdev), flags);
 		return rq->rc;
@@ -1278,6 +1290,11 @@ raw3270_remove (struct ccw_device *cdev)
 		rp->view->fn->deactivate(rp->view);
 		rp->view = NULL;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rp->view_list)) {
 		v = list_entry(rp->view_list.next, struct raw3270_view, list);
 		if (v->fn->release)
@@ -1285,6 +1302,12 @@ raw3270_remove (struct ccw_device *cdev)
 		spin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);
 		raw3270_del_view(v);
 		spin_lock_irqsave(get_ccwdev_lock(cdev), flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);
 
diff -u -p a/s390/char/vmlogrdr.c b/s390/char/vmlogrdr.c
--- a/s390/char/vmlogrdr.c
+++ b/s390/char/vmlogrdr.c
@@ -482,6 +482,11 @@ static ssize_t vmlogrdr_read(struct file
 	int rc;
 	struct vmlogrdr_priv_t * priv = filp->private_data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (priv->buffer_free) {
 		rc = vmlogrdr_receive_data(priv);
 		if (rc) {
@@ -490,6 +495,12 @@ static ssize_t vmlogrdr_read(struct file
 			if (rc)
 				return rc;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* copy only up to end of record */
 	if (count > priv->remaining)
diff -u -p a/s390/char/zcore.c b/s390/char/zcore.c
--- a/s390/char/zcore.c
+++ b/s390/char/zcore.c
@@ -250,6 +250,11 @@ static int zcore_add_lc(char __user *buf
 		return 0;
 
 	end = start + count;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (zfcpdump_save_areas[i]) {
 		unsigned long cp_start, cp_end; /* copy range */
 		unsigned long sa_start, sa_end; /* save area range */
@@ -274,6 +279,12 @@ static int zcore_add_lc(char __user *buf
 			return -EFAULT;
 next:
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/s390/char/con3270.c b/s390/char/con3270.c
--- a/s390/char/con3270.c
+++ b/s390/char/con3270.c
@@ -510,9 +510,20 @@ con3270_device(struct console *c, int *i
 static void
 con3270_wait_write(struct con3270 *cp)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!cp->write) {
 		raw3270_wait_cons_dev(cp->view.dev);
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/s390/char/sclp.c b/s390/char/sclp.c
--- a/s390/char/sclp.c
+++ b/s390/char/sclp.c
@@ -469,6 +469,11 @@ sclp_sync_wait(void)
 	__ctl_load(cr0_sync, 0, 0);
 	__arch_local_irq_stosm(0x01);
 	/* Loop until driver state indicates finished request */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sclp_running_state != sclp_running_state_idle) {
 		/* Check for expired request timer */
 		if (timer_pending(&sclp_request_timer) &&
@@ -476,6 +481,12 @@ sclp_sync_wait(void)
 		    del_timer(&sclp_request_timer))
 			sclp_request_timer.function(sclp_request_timer.data);
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	local_irq_disable();
 	__ctl_load(cr0, 0, 0);
diff -u -p a/s390/char/vmur.c b/s390/char/vmur.c
--- a/s390/char/vmur.c
+++ b/s390/char/vmur.c
@@ -212,9 +212,20 @@ static void free_chan_prog(struct ccw1 *
 {
 	struct ccw1 *ptr = cpa;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ptr->cda) {
 		kfree((void *)(addr_t) ptr->cda);
 		ptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(cpa);
 }
@@ -712,6 +723,11 @@ static int ur_open(struct inode *inode,
 	}
 
 	spin_lock(&urd->open_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (urd->open_flag) {
 		spin_unlock(&urd->open_lock);
 		if (file->f_flags & O_NONBLOCK) {
@@ -723,6 +739,12 @@ static int ur_open(struct inode *inode,
 			goto fail_put;
 		}
 		spin_lock(&urd->open_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	urd->open_flag++;
 	spin_unlock(&urd->open_lock);
diff -u -p a/s390/char/sclp_con.c b/s390/char/sclp_con.c
--- a/s390/char/sclp_con.c
+++ b/s390/char/sclp_con.c
@@ -111,10 +111,21 @@ static void sclp_console_sync_queue(void
 	spin_lock_irqsave(&sclp_con_lock, flags);
 	if (timer_pending(&sclp_con_timer))
 		del_timer(&sclp_con_timer);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sclp_con_queue_running) {
 		spin_unlock_irqrestore(&sclp_con_lock, flags);
 		sclp_sync_wait();
 		spin_lock_irqsave(&sclp_con_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&sclp_con_lock, flags);
 }
@@ -150,12 +161,23 @@ sclp_console_write(struct console *conso
 	do {
 		/* make sure we have a console output buffer */
 		if (sclp_conbuf == NULL) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (list_empty(&sclp_con_pages)) {
 				if (sclp_con_suspended)
 					goto out;
 				spin_unlock_irqrestore(&sclp_con_lock, flags);
 				sclp_sync_wait();
 				spin_lock_irqsave(&sclp_con_lock, flags);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			page = sclp_con_pages.next;
 			list_del((struct list_head *) page);
diff -u -p a/s390/char/sclp_tty.c b/s390/char/sclp_tty.c
--- a/s390/char/sclp_tty.c
+++ b/s390/char/sclp_tty.c
@@ -187,13 +187,24 @@ static int sclp_tty_write_string(const u
 	do {
 		/* Create a sclp output buffer if none exists yet */
 		if (sclp_ttybuf == NULL) {
-			while (list_empty(&sclp_tty_pages)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (list_empty(&sclp_tty_pages)) {
 				spin_unlock_irqrestore(&sclp_tty_lock, flags);
 				if (may_fail)
 					goto out;
 				else
 					sclp_sync_wait();
 				spin_lock_irqsave(&sclp_tty_lock, flags);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			page = sclp_tty_pages.next;
 			list_del((struct list_head *) page);
diff -u -p a/s390/char/tty3270.c b/s390/char/tty3270.c
--- a/s390/char/tty3270.c
+++ b/s390/char/tty3270.c
@@ -967,12 +967,23 @@ static void tty3270_put_character(struct
 
 	line = tp->screen + tp->cy;
 	if (line->len <= tp->cx) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (line->len < tp->cx) {
 			cell = line->cells + line->len;
 			cell->character = tp->view.ascebc[' '];
 			cell->highlight = tp->highlight;
 			cell->f_color = tp->f_color;
 			line->len++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		line->len++;
 	}
@@ -1141,11 +1152,22 @@ tty3270_insert_characters(struct tty3270
 	int k;
 
 	line = tp->screen + tp->cy;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (line->len < tp->cx) {
 		line->cells[line->len].character = tp->view.ascebc[' '];
 		line->cells[line->len].highlight = TAX_RESET;
 		line->cells[line->len].f_color = TAC_RESET;
 		line->len++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (n > tp->view.cols - tp->cx)
 		n = tp->view.cols - tp->cx;
diff -u -p a/s390/scsi/zfcp_cfdc.c b/s390/scsi/zfcp_cfdc.c
--- a/s390/scsi/zfcp_cfdc.c
+++ b/s390/scsi/zfcp_cfdc.c
@@ -61,12 +61,23 @@ static int zfcp_cfdc_copy_from_user(stru
 	unsigned int length;
 	unsigned int size = ZFCP_CFDC_MAX_SIZE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		length = min((unsigned int)size, sg->length);
 		if (copy_from_user(sg_virt(sg++), user_buffer, length))
 			return -EFAULT;
 		user_buffer += length;
 		size -= length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -77,12 +88,23 @@ static int zfcp_cfdc_copy_to_user(void _
 	unsigned int length;
 	unsigned int size = ZFCP_CFDC_MAX_SIZE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		length = min((unsigned int) size, sg->length);
 		if (copy_to_user(user_buffer, sg_virt(sg++), length))
 			return -EFAULT;
 		user_buffer += length;
 		size -= length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/s390/scsi/zfcp_scsi.c b/s390/scsi/zfcp_scsi.c
--- a/s390/scsi/zfcp_scsi.c
+++ b/s390/scsi/zfcp_scsi.c
@@ -640,6 +640,11 @@ void zfcp_scsi_rport_work(struct work_st
 	struct zfcp_port *port = container_of(work, struct zfcp_port,
 					      rport_work);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (port->rport_task) {
 		if (port->rport_task == RPORT_ADD) {
 			port->rport_task = RPORT_NONE;
@@ -648,6 +653,12 @@ void zfcp_scsi_rport_work(struct work_st
 			port->rport_task = RPORT_NONE;
 			zfcp_scsi_rport_block(port);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	put_device(&port->dev);
diff -u -p a/s390/scsi/zfcp_dbf.c b/s390/scsi/zfcp_dbf.c
--- a/s390/scsi/zfcp_dbf.c
+++ b/s390/scsi/zfcp_dbf.c
@@ -40,7 +40,12 @@ void zfcp_dbf_pl_write(struct zfcp_dbf *
 	pl->fsf_req_id = req_id;
 	memcpy(pl->area, area, ZFCP_DBF_TAG_LEN);
 
-	while (offset < length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < length) {
 		rec_length = min((u16) ZFCP_DBF_PAY_MAX_REC,
 				 (u16) (length - offset));
 		memcpy(pl->data, data + offset, rec_length);
@@ -48,6 +53,12 @@ void zfcp_dbf_pl_write(struct zfcp_dbf *
 
 		offset += rec_length;
 		pl->counter++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock(&dbf->pay_lock);
@@ -191,10 +202,21 @@ void zfcp_dbf_hba_def_err(struct zfcp_ad
 	length = min((u16)sizeof(struct qdio_buffer),
 		     (u16)ZFCP_DBF_PAY_MAX_REC);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (payload->counter < scount && (char *)pl[payload->counter]) {
 		memcpy(payload->data, (char *)pl[payload->counter], length);
 		debug_event(dbf->pay, 1, payload, zfcp_dbf_plen(length));
 		payload->counter++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock_irqrestore(&dbf->pay_lock, flags);
diff -u -p a/s390/block/dasd_eckd.c b/s390/block/dasd_eckd.c
--- a/s390/block/dasd_eckd.c
+++ b/s390/block/dasd_eckd.c
@@ -2391,6 +2391,11 @@ static struct dasd_ccw_req *dasd_eckd_bu
 	rq_for_each_segment(bv, req, iter) {
 		dst = page_address(bv->bv_page) + bv->bv_offset;
 		seg_len = bv->bv_len;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (seg_len) {
 			if (new_track) {
 				trkid = recid;
@@ -2452,6 +2457,12 @@ static struct dasd_ccw_req *dasd_eckd_bu
 				idaw_len = 0;
 				end_idaw = 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -2702,6 +2713,11 @@ static struct dasd_ccw_req *dasd_eckd_bu
 		rq_for_each_segment(bv, req, iter) {
 			dst = page_address(bv->bv_page) + bv->bv_offset;
 			seg_len = bv->bv_len;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (seg_len) {
 				if (new_track) {
 					trkid = recid;
@@ -2727,6 +2743,12 @@ static struct dasd_ccw_req *dasd_eckd_bu
 				if (IS_ERR(last_tidaw))
 					return ERR_PTR(-EINVAL);
 				dst += part_len;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	} else {
@@ -3599,7 +3621,12 @@ dasd_eckd_dump_ccw_range(struct ccw1 *fr
 	char *datap;
 
 	len = 0;
-	while (from <= to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (from <= to) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       from, ((int *) from)[0], ((int *) from)[1]);
@@ -3618,6 +3645,12 @@ dasd_eckd_dump_ccw_range(struct ccw1 *fr
 		}
 		len += sprintf(page + len, "\n");
 		from++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return len;
 }
diff -u -p a/s390/block/dasd_alias.c b/s390/block/dasd_alias.c
--- a/s390/block/dasd_alias.c
+++ b/s390/block/dasd_alias.c
@@ -839,7 +839,12 @@ static void flush_all_alias_devices_on_l
 	list_for_each_entry(pavgroup, &lcu->grouplist, group) {
 		list_splice_init(&pavgroup->aliaslist, &active);
 	}
-	while (!list_empty(&active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&active)) {
 		device = list_first_entry(&active, struct dasd_device,
 					  alias_list);
 		spin_unlock_irqrestore(&lcu->lock, flags);
@@ -852,6 +857,12 @@ static void flush_all_alias_devices_on_l
 		if (device == list_first_entry(&active,
 					       struct dasd_device, alias_list))
 			list_move(&device->alias_list, &lcu->active_devices);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 	spin_unlock_irqrestore(&lcu->lock, flags);
 }
diff -u -p a/s390/block/dasd_devmap.c b/s390/block/dasd_devmap.c
--- a/s390/block/dasd_devmap.c
+++ b/s390/block/dasd_devmap.c
@@ -338,12 +338,23 @@ dasd_parse_range( char *parsestring ) {
 		return ERR_PTR(-EINVAL);
 	/* each device in dasd= parameter should be set initially online */
 	features |= DASD_FEATURE_INITIAL_ONLINE;
-	while (from <= to) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (from <= to) {
 		sprintf(bus_id, "%01x.%01x.%04x",
 			from_id0, from_id1, from++);
 		devmap = dasd_add_busid(bus_id, features);
 		if (IS_ERR(devmap))
 			return (char *)devmap;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (*str == ',')
 		return str + 1;
diff -u -p a/s390/block/dasd_eer.c b/s390/block/dasd_eer.c
--- a/s390/block/dasd_eer.c
+++ b/s390/block/dasd_eer.c
@@ -190,6 +190,11 @@ static int dasd_eer_start_record(struct
 
 	if (count + sizeof(count) > eerb->buffersize)
 		return -ENOMEM;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dasd_eer_get_free_bytes(eerb) < count + sizeof(count)) {
 		if (eerb->residual > 0) {
 			eerb->tail += eerb->residual;
@@ -202,6 +207,12 @@ static int dasd_eer_start_record(struct
 		eerb->tail += tailcount;
 		if (eerb->tail >= eerb->buffersize)
 			eerb->tail -= eerb->buffersize;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	dasd_eer_write_buffer(eerb, (char*) &count, sizeof(count));
 
@@ -609,7 +620,12 @@ static ssize_t dasd_eer_read(struct file
 		eerb->residual -= effective_count;
 	} else {
 		tc = 0;
-		while (!tc) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!tc) {
 			tc = dasd_eer_read_buffer(eerb, (char *) &tailcount,
 						  sizeof(tailcount));
 			if (!tc) {
@@ -627,6 +643,12 @@ static ssize_t dasd_eer_read(struct file
 					return -ERESTARTSYS;
 				spin_lock_irqsave(&bufferlock, flags);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		WARN_ON(tc != sizeof(tailcount));
 		effective_count = min(tailcount,(int)count);
diff -u -p a/s390/block/dasd_fba.c b/s390/block/dasd_fba.c
--- a/s390/block/dasd_fba.c
+++ b/s390/block/dasd_fba.c
@@ -515,7 +515,12 @@ dasd_fba_dump_sense(struct dasd_device *
 	end = min(act + 8, last);
 	len = sprintf(page, KERN_ERR PRINTK_HEADER
 		      " Related CP in req: %p\n", req);
-	while (act <= end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (act <= end) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       act, ((int *) act)[0], ((int *) act)[1]);
@@ -526,6 +531,12 @@ dasd_fba_dump_sense(struct dasd_device *
 				       [(count>>2)]);
 		len += sprintf(page + len, "\n");
 		act++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_ERR "%s", page);
 
@@ -537,7 +548,12 @@ dasd_fba_dump_sense(struct dasd_device *
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER "......\n");
 	}
 	end = min((struct ccw1 *)(addr_t) irb->scsw.cmd.cpa + 2, last);
-	while (act <= end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (act <= end) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       act, ((int *) act)[0], ((int *) act)[1]);
@@ -548,6 +564,12 @@ dasd_fba_dump_sense(struct dasd_device *
 				       [(count>>2)]);
 		len += sprintf(page + len, "\n");
 		act++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* print last CCWs */
@@ -555,7 +577,12 @@ dasd_fba_dump_sense(struct dasd_device *
 		act = last - 2;
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER "......\n");
 	}
-	while (act <= last) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (act <= last) {
 		len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 			       " CCW %p: %08X %08X DAT:",
 			       act, ((int *) act)[0], ((int *) act)[1]);
@@ -566,6 +593,12 @@ dasd_fba_dump_sense(struct dasd_device *
 				       [(count>>2)]);
 		len += sprintf(page + len, "\n");
 		act++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (len > 0)
 		printk(KERN_ERR "%s", page);
diff -u -p a/s390/block/dasd_ioctl.c b/s390/block/dasd_ioctl.c
--- a/s390/block/dasd_ioctl.c
+++ b/s390/block/dasd_ioctl.c
@@ -178,6 +178,11 @@ static int dasd_format(struct dasd_block
 		bdput(bdev);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fdata->start_unit <= fdata->stop_unit) {
 		cqr = base->discipline->format_device(base, fdata);
 		if (IS_ERR(cqr))
@@ -192,6 +197,12 @@ static int dasd_format(struct dasd_block
 			return rc;
 		}
 		fdata->start_unit++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/s390/block/dasd_3990_erp.c b/s390/block/dasd_3990_erp.c
--- a/s390/block/dasd_3990_erp.c
+++ b/s390/block/dasd_3990_erp.c
@@ -2624,6 +2624,11 @@ dasd_3990_erp_handle_match_erp(struct da
 	struct dasd_ccw_req *erp_free = NULL;	/* req to be freed */
 
 	/* loop over successful ERPs and remove them from chanq */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (erp_done != erp) {
 
 		if (erp_done == NULL)	/* end of chain reached */
@@ -2639,6 +2644,12 @@ dasd_3990_erp_handle_match_erp(struct da
 		/* free the finished erp request */
 		dasd_free_erp_request(erp_free, erp_free->memdev);
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}			/* end while */
 
 	if (erp->retries > 0) {
diff -u -p a/s390/crypto/ap_bus.c b/s390/crypto/ap_bus.c
--- a/s390/crypto/ap_bus.c
+++ b/s390/crypto/ap_bus.c
@@ -1846,11 +1846,22 @@ void ap_module_exit(void)
 	destroy_workqueue(ap_work_queue);
 	tasklet_kill(&ap_tasklet);
 	root_device_unregister(ap_root_device);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((dev = bus_find_device(&ap_bus_type, NULL, NULL,
 		    __ap_match_all)))
 	{
 		device_unregister(dev);
 		put_device(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	for (i = 0; ap_bus_attrs[i]; i++)
 		bus_remove_file(&ap_bus_type, ap_bus_attrs[i]);
diff -u -p a/sbus/char/jsflash.c b/sbus/char/jsflash.c
--- a/sbus/char/jsflash.c
+++ b/sbus/char/jsflash.c
@@ -188,6 +188,11 @@ static void jsfd_do_request(struct reque
 	struct request *req;
 
 	req = blk_fetch_request(q);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (req) {
 		struct jsfd_part *jdp = req->rq_disk->private_data;
 		unsigned long offset = blk_rq_pos(req) << 9;
@@ -212,6 +217,12 @@ static void jsfd_do_request(struct reque
 	end:
 		if (!__blk_end_request_cur(req, err))
 			req = blk_fetch_request(q);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/sbus/char/envctrl.c b/sbus/char/envctrl.c
--- a/sbus/char/envctrl.c
+++ b/sbus/char/envctrl.c
@@ -1042,6 +1042,11 @@ static int __devinit envctrl_probe(struc
 
 	index = 0;
 	dp = op->dev.of_node->child;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dp) {
 		if (!strcmp(dp->name, "gpio")) {
 			i2c_childlist[index].i2ctype = I2C_GPIO;
@@ -1052,6 +1057,12 @@ static int __devinit envctrl_probe(struc
 		}
 
 		dp = dp->sibling;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Set device address. */
diff -u -p a/scsi/bfa/bfa_core.c b/scsi/bfa/bfa_core.c
--- a/scsi/bfa/bfa_core.c
+++ b/scsi/bfa/bfa_core.c
@@ -241,12 +241,23 @@ bfa_isr_rspq(struct bfa_s *bfa, int qid)
 	ci = bfa_rspq_ci(bfa, qid);
 	pi = bfa_rspq_pi(bfa, qid);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ci != pi) {
 		m = bfa_rspq_elem(bfa, qid, ci);
 		WARN_ON(m->mhdr.msg_class >= BFI_MC_MAX);
 
 		bfa_isrs[m->mhdr.msg_class] (bfa, m);
 		CQ_INCR(ci, bfa->iocfc.cfg.drvcfg.num_rspq_elems);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -1559,11 +1570,22 @@ bfa_comp_free(struct bfa_s *bfa, struct
 	struct list_head		*qe;
 	struct bfa_cb_qe_s	*hcb_qe;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(comp_q)) {
 		bfa_q_deq(comp_q, &qe);
 		hcb_qe = (struct bfa_cb_qe_s *) qe;
 		WARN_ON(hcb_qe->pre_rmv);
 		hcb_qe->cbfn(hcb_qe->cbarg, BFA_FALSE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/bfa/bfa_fcs_lport.c b/scsi/bfa/bfa_fcs_lport.c
--- a/scsi/bfa/bfa_fcs_lport.c
+++ b/scsi/bfa/bfa_fcs_lport.c
@@ -4910,6 +4910,11 @@ bfa_fcs_lport_get_rports(struct bfa_fcs_
 	qh = &port->rport_q;
 	qe = bfa_q_first(qh);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((qe != qh) && (i < *nrports)) {
 		rport = (struct bfa_fcs_rport_s *) qe;
 		if (bfa_ntoh3b(rport->pid) > 0xFFF000) {
@@ -4924,6 +4929,12 @@ bfa_fcs_lport_get_rports(struct bfa_fcs_
 
 		i++;
 		qe = bfa_q_next(qe);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bfa_trc(fcs, i);
@@ -4961,6 +4972,11 @@ bfa_fcs_lport_get_rport_max_speed(bfa_fc
 	qh = &port->rport_q;
 	qe = bfa_q_first(qh);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qe != qh) {
 		rport = (struct bfa_fcs_rport_s *) qe;
 		if ((bfa_ntoh3b(rport->pid) > 0xFFF000) ||
@@ -4982,6 +4998,12 @@ bfa_fcs_lport_get_rport_max_speed(bfa_fc
 			max_speed = rport_speed;
 
 		qe = bfa_q_next(qe);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (max_speed > port_speed)
diff -u -p a/scsi/bfa/bfa_ioc.c b/scsi/bfa/bfa_ioc.c
--- a/scsi/bfa/bfa_ioc.c
+++ b/scsi/bfa/bfa_ioc.c
@@ -2990,6 +2990,11 @@ bfa_timer_beat(struct bfa_timer_mod_s *m
 
 	qe = bfa_q_next(qh);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qe != qh) {
 		qe_next = bfa_q_next(qe);
 
@@ -3003,14 +3008,31 @@ bfa_timer_beat(struct bfa_timer_mod_s *m
 		}
 
 		qe = qe_next;	/* go to next elem */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
 	 * Pop all the timeout entries
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&timedout_q)) {
 		bfa_q_deq(&timedout_q, &elem);
 		elem->timercb(elem->arg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/bfa/bfa_svc.c b/scsi/bfa/bfa_svc.c
--- a/scsi/bfa/bfa_svc.c
+++ b/scsi/bfa/bfa_svc.c
@@ -1604,6 +1604,11 @@ bfa_lps_no_res(struct bfa_lps_s *first_l
 
 	qe = bfa_q_next(first_lps);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count && qe) {
 		qe_next = bfa_q_next(qe);
 		lps = (struct bfa_lps_s *)qe;
@@ -1614,6 +1619,12 @@ bfa_lps_no_res(struct bfa_lps_s *first_l
 		bfa_sm_send_event(lps, BFA_LPS_SM_FWRSP);
 		qe = qe_next;
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/bfa/bfad_im.c b/scsi/bfa/bfad_im.c
--- a/scsi/bfa/bfad_im.c
+++ b/scsi/bfa/bfad_im.c
@@ -224,11 +224,22 @@ bfad_im_abort_handler(struct scsi_cmnd *
 
 	/* Need to wait until the command get aborted */
 	timeout = 10;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((struct bfa_ioim_s *) cmnd->host_scribble == hal_io) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(timeout);
 		if (timeout < 4 * HZ)
 			timeout *= 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	cmnd->scsi_done(cmnd);
@@ -668,6 +679,11 @@ static void bfad_aen_im_notify_handler(s
 	void *event_data;
 	unsigned long flags;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&bfad->active_aen_q)) {
 		spin_lock_irqsave(&bfad->bfad_aen_spinlock, flags);
 		bfa_q_deq(&bfad->active_aen_q, &aen_entry);
@@ -680,6 +696,12 @@ static void bfad_aen_im_notify_handler(s
 		spin_lock_irqsave(&bfad->bfad_aen_spinlock, flags);
 		list_add_tail(&aen_entry->qe, &bfad->free_aen_q);
 		spin_unlock_irqrestore(&bfad->bfad_aen_spinlock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/scsi/bfa/bfa_fcpim.c b/scsi/bfa/bfa_fcpim.c
--- a/scsi/bfa/bfa_fcpim.c
+++ b/scsi/bfa/bfa_fcpim.c
@@ -1270,10 +1270,21 @@ bfa_itnim_iotov_online(struct bfa_itnim_
 	/*
 	 * Start all pending IO requests.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&itnim->pending_q)) {
 		bfa_q_deq(&itnim->pending_q, &ioim);
 		list_add_tail(&ioim->qe, &itnim->io_q);
 		bfa_ioim_start(ioim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1293,10 +1304,21 @@ bfa_itnim_iotov_cleanup(struct bfa_itnim
 	/*
 	 * Fail any pending IO requests.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&itnim->pending_q)) {
 		bfa_q_deq(&itnim->pending_q, &ioim);
 		list_add_tail(&ioim->qe, &ioim->fcpim->ioim_comp_q);
 		bfa_ioim_tov(ioim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/bfa/bfad_bsg.c b/scsi/bfa/bfad_bsg.c
--- a/scsi/bfa/bfad_bsg.c
+++ b/scsi/bfa/bfad_bsg.c
@@ -2281,7 +2281,12 @@ bfad_iocmd_qos_get_vc_attr(struct bfad_s
 				be32_to_cpu(bfa_vc_attr->elp_opmode_flags);
 
 	/* Individual VC info */
-	while (i < iocmd->attr.total_vc_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i < iocmd->attr.total_vc_count) {
 		iocmd->attr.vc_info[i].vc_credit =
 				bfa_vc_attr->vc_info[i].vc_credit;
 		iocmd->attr.vc_info[i].borrow_credit =
@@ -2289,6 +2294,12 @@ bfad_iocmd_qos_get_vc_attr(struct bfad_s
 		iocmd->attr.vc_info[i].priority =
 				bfa_vc_attr->vc_info[i].priority;
 		i++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 
diff -u -p a/scsi/arm/oak.c b/scsi/arm/oak.c
--- a/scsi/arm/oak.c
+++ b/scsi/arm/oak.c
@@ -60,10 +60,21 @@ static inline int NCR5380_pwrite(struct
 printk("writing %p len %d\n",addr, len);
   if(!len) return -1;
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while(1)
   {
     int status;
     while (((status = readw(base + STAT)) & 0x100)==0);
+    if (_cur < timeout) {
+      rdstcll(_cur);
+    }
+    else {
+      break;
+    }
   }
 }
 
diff -u -p a/scsi/arm/fas216.c b/scsi/arm/fas216.c
--- a/scsi/arm/fas216.c
+++ b/scsi/arm/fas216.c
@@ -846,10 +846,21 @@ static void fas216_stoptransfer(FAS216_I
 		 * from the on-board FIFO.  Read them manually.
 		 */
 		fifo = fas216_readb(info, REG_CFIS) & CFIS_CF;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (fifo && info->scsi.SCp.ptr) {
 			*info->scsi.SCp.ptr = fas216_readb(info, REG_FF);
 			fas216_updateptrs(info, 1);
 			fifo--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		/*
@@ -2289,6 +2300,11 @@ static int fas216_noqueue_command_lck(st
 	 */
 	spin_unlock_irq(info->host->host_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!info->internal_done) {
 		/*
 		 * If we don't have an IRQ, then we must poll the card for
@@ -2303,6 +2319,12 @@ static int fas216_noqueue_command_lck(st
 			fas216_intr(info);
 			spin_unlock_irq(info->host->host_lock);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_lock_irq(info->host->host_lock);
diff -u -p a/scsi/fcoe/fcoe.c b/scsi/fcoe/fcoe.c
--- a/scsi/fcoe/fcoe.c
+++ b/scsi/fcoe/fcoe.c
@@ -1735,6 +1735,11 @@ int fcoe_percpu_receive_thread(void *arg
 
 	set_user_nice(current, -20);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 
 		spin_lock_bh(&p->fcoe_rx_list.lock);
@@ -1749,6 +1754,12 @@ int fcoe_percpu_receive_thread(void *arg
 		}
 		spin_unlock_bh(&p->fcoe_rx_list.lock);
 		fcoe_recv_frame(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/scsi/fnic/fnic_fcs.c b/scsi/fnic/fnic_fcs.c
--- a/scsi/fnic/fnic_fcs.c
+++ b/scsi/fnic/fnic_fcs.c
@@ -102,6 +102,11 @@ void fnic_handle_frame(struct work_struc
 	struct sk_buff *skb;
 	struct fc_frame *fp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&fnic->frame_queue))) {
 
 		spin_lock_irqsave(&fnic->fnic_lock, flags);
@@ -125,6 +130,12 @@ void fnic_handle_frame(struct work_struc
 		spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 
 		fc_exch_recv(lp, fp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -617,9 +628,20 @@ void fnic_flush_tx(struct fnic *fnic)
 	struct sk_buff *skb;
 	struct fc_frame *fp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&fnic->tx_queue))) {
 		fp = (struct fc_frame *)skb;
 		fnic_send_frame(fnic, fp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/isci/request.c b/scsi/isci/request.c
--- a/scsi/isci/request.c
+++ b/scsi/isci/request.c
@@ -112,6 +112,11 @@ static void sci_request_build_sgl(struct
 	if (task->num_scatter > 0) {
 		sg = task->scatter;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sg) {
 			scu_sg = to_sgl_element_pair(ireq, sg_idx);
 			init_sgl_element(&scu_sg->A, sg);
@@ -135,6 +140,12 @@ static void sci_request_build_sgl(struct
 
 			prev_sg = scu_sg;
 			sg_idx++;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	} else {	/* handle when no sg */
 		scu_sg = to_sgl_element_pair(ireq, sg_idx);
diff -u -p a/scsi/isci/host.c b/scsi/isci/host.c
--- a/scsi/isci/host.c
+++ b/scsi/isci/host.c
@@ -499,7 +499,12 @@ static void sci_controller_process_compl
 	event_get = NORMALIZE_EVENT_POINTER(ihost->completion_queue_get);
 	event_cycle = SMU_CQGR_EVENT_CYCLE_BIT & ihost->completion_queue_get;
 
-	while (
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (
 		NORMALIZE_GET_POINTER_CYCLE_BIT(get_cycle)
 		== COMPLETION_QUEUE_CYCLE_BIT(ihost->completion_queue[get_index])
 		) {
@@ -550,6 +555,12 @@ static void sci_controller_process_compl
 				 ent);
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Update the get register if we completed one or more entries */
diff -u -p a/scsi/isci/task.c b/scsi/isci/task.c
--- a/scsi/isci/task.c
+++ b/scsi/isci/task.c
@@ -769,7 +769,12 @@ void isci_terminate_pending_requests(str
 	list_splice_init(&idev->reqs_in_process, &list);
 
 	/* assumes that isci_terminate_request_core deletes from the list */
-	while (!list_empty(&list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&list)) {
 		struct isci_request *ireq = list_entry(list.next, typeof(*ireq), dev_node);
 
 		/* Change state to "terminating" if it is currently
@@ -829,6 +834,12 @@ void isci_terminate_pending_requests(str
 		 */
 		isci_terminate_request_core(ihost, idev, ireq);
 		spin_lock_irqsave(&ihost->scic_lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
diff -u -p a/scsi/lpfc/lpfc_ct.c b/scsi/lpfc/lpfc_ct.c
--- a/scsi/lpfc/lpfc_ct.c
+++ b/scsi/lpfc/lpfc_ct.c
@@ -222,6 +222,11 @@ lpfc_alloc_ct_rsp(struct lpfc_hba *phba,
 	/* We get chunks of FCELSSIZE */
 	cnt = size > FCELSSIZE ? FCELSSIZE: size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		/* Allocate buffer for rsp payload */
 		mp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);
@@ -262,6 +267,12 @@ lpfc_alloc_ct_rsp(struct lpfc_hba *phba,
 
 		i++;
 		size -= cnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*entries = i;
diff -u -p a/scsi/lpfc/lpfc_hbadisc.c b/scsi/lpfc/lpfc_hbadisc.c
--- a/scsi/lpfc/lpfc_hbadisc.c
+++ b/scsi/lpfc/lpfc_hbadisc.c
@@ -492,7 +492,12 @@ lpfc_work_list_done(struct lpfc_hba *phb
 	uint32_t nlp_did;
 
 	spin_lock_irq(&phba->hbalock);
-	while (!list_empty(&phba->work_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->work_list)) {
 		list_remove_head((&phba->work_list), evtp, typeof(*evtp),
 				 evt_listp);
 		spin_unlock_irq(&phba->hbalock);
@@ -572,6 +577,12 @@ lpfc_work_list_done(struct lpfc_hba *phb
 		if (free_evt)
 			kfree(evtp);
 		spin_lock_irq(&phba->hbalock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irq(&phba->hbalock);
 
@@ -1474,9 +1485,20 @@ lpfc_match_fcf_conn_list(struct lpfc_hba
 		if (new_fcf_record->vlan_bitmap[i]) {
 			fcf_vlan_id = i * 8;
 			j = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (!((new_fcf_record->vlan_bitmap[i] >> j) & 1)) {
 				j++;
 				fcf_vlan_id++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			break;
 		}
@@ -2979,6 +3001,11 @@ lpfc_mbx_process_link_up(struct lpfc_hba
 				} un;
 				numalpa = phba->alpa_map[0];
 				j = 0;
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (j < numalpa) {
 					memset(un.pamap, 0, 16);
 					for (k = 1; j < numalpa; k++) {
@@ -2997,6 +3024,12 @@ lpfc_mbx_process_link_up(struct lpfc_hba
 							"x%x x%x x%x\n",
 							un.pa.wd1, un.pa.wd2,
 							un.pa.wd3, un.pa.wd4);
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
 				}
 			}
 		}
@@ -5994,6 +6027,11 @@ lpfc_get_rec_conf23(uint8_t *buff, uint3
 	 * One TLV record has one word header and number of data words
 	 * specified in the rec_length field of the record header.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((offset + rec_length * sizeof(uint32_t) + sizeof(uint32_t))
 		<= size) {
 		if (buff[offset] == rec_type)
@@ -6004,6 +6042,12 @@ lpfc_get_rec_conf23(uint8_t *buff, uint3
 
 		offset += rec_length * sizeof(uint32_t) + sizeof(uint32_t);
 		rec_length = buff[offset + 1];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/scsi/lpfc/lpfc_scsi.c b/scsi/lpfc/lpfc_scsi.c
--- a/scsi/lpfc/lpfc_scsi.c
+++ b/scsi/lpfc/lpfc_scsi.c
@@ -92,11 +92,22 @@ lpfc_debug_save_data(struct lpfc_hba *ph
 	}
 
 	dst = (void *) _dump_buf_data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sgde) {
 		src = sg_virt(sgde);
 		memcpy(dst, src, sgde->length);
 		dst += sgde->length;
 		sgde = sg_next(sgde);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -120,11 +131,22 @@ lpfc_debug_save_dif(struct lpfc_hba *phb
 	}
 
 	dst = _dump_buf_dif;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sgde) {
 		src = sg_virt(sgde);
 		memcpy(dst, src, sgde->length);
 		dst += sgde->length;
 		sgde = sg_next(sgde);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -761,7 +783,12 @@ lpfc_sli4_repost_scsi_sgl_list(struct lp
 							bcnt);
 		/* Reset SCSI buffer count for next round of posting */
 		bcnt = 0;
-		while (!list_empty(&sblist)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&sblist)) {
 			list_remove_head(&sblist, psb, struct lpfc_scsi_buf,
 					 list);
 			if (status) {
@@ -774,6 +801,12 @@ lpfc_sli4_repost_scsi_sgl_list(struct lp
 			}
 			/* Put it back into the SCSI buffer list */
 			lpfc_release_scsi_buf_s4(phba, psb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return rc;
@@ -949,7 +982,12 @@ lpfc_new_scsi_buf_s4(struct lpfc_vport *
 			bcnt = 0;
 		}
 		/* Reset SCSI buffer count for next round of posting */
-		while (!list_empty(&sblist)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&sblist)) {
 			list_remove_head(&sblist, psb, struct lpfc_scsi_buf,
 				 list);
 			if (status) {
@@ -961,6 +999,12 @@ lpfc_new_scsi_buf_s4(struct lpfc_vport *
 			}
 			/* Put it back into the SCSI buffer list */
 			lpfc_release_scsi_buf_s4(phba, psb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -3648,6 +3692,11 @@ lpfc_chk_tgt_mapped(struct lpfc_vport *v
 	 * target is rediscovered or devloss timeout expires.
 	 */
 	later = msecs_to_jiffies(2 * vport->cfg_devloss_tmo * 1000) + jiffies;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_after(later, jiffies)) {
 		if (!pnode || !NLP_CHK_NODE_ACT(pnode))
 			return FAILED;
@@ -3658,6 +3707,12 @@ lpfc_chk_tgt_mapped(struct lpfc_vport *v
 		if (!rdata)
 			return FAILED;
 		pnode = rdata->pnode;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (!pnode || !NLP_CHK_NODE_ACT(pnode) ||
 	    (pnode->nlp_state != NLP_STE_MAPPED_NODE))
@@ -3694,9 +3749,20 @@ lpfc_reset_flush_io_context(struct lpfc_
 		lpfc_sli_abort_iocb(vport, &phba->sli.ring[phba->sli.fcp_ring],
 				    tgt_id, lun_id, context);
 	later = msecs_to_jiffies(2 * vport->cfg_devloss_tmo * 1000) + jiffies;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_after(later, jiffies) && cnt) {
 		schedule_timeout_uninterruptible(msecs_to_jiffies(20));
 		cnt = lpfc_sli_sum_iocb(vport, tgt_id, lun_id, context);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (cnt) {
 		lpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,
diff -u -p a/scsi/lpfc/lpfc_bsg.c b/scsi/lpfc/lpfc_bsg.c
--- a/scsi/lpfc/lpfc_bsg.c
+++ b/scsi/lpfc/lpfc_bsg.c
@@ -662,18 +662,40 @@ lpfc_bsg_event_free(struct kref *kref)
 
 	list_del(&evt->node);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&evt->events_to_get)) {
 		ed = list_entry(evt->events_to_get.next, typeof(*ed), node);
 		list_del(&ed->node);
 		kfree(ed->data);
 		kfree(ed);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&evt->events_to_see)) {
 		ed = list_entry(evt->events_to_see.next, typeof(*ed), node);
 		list_del(&ed->node);
 		kfree(ed->data);
 		kfree(ed);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(evt);
@@ -2405,7 +2427,12 @@ diag_cmd_data_alloc(struct lpfc_hba *phb
 
 	pcidev = phba->pcidev;
 
-	while (size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size) {
 		/* We get chunks of 4K */
 		if (size > BUF_SZ_4K)
 			cnt = BUF_SZ_4K;
@@ -2456,6 +2483,12 @@ diag_cmd_data_alloc(struct lpfc_hba *phb
 		i++;
 		offset += cnt;
 		size -= cnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mlist->flag = i;
diff -u -p a/scsi/lpfc/lpfc_els.c b/scsi/lpfc/lpfc_els.c
--- a/scsi/lpfc/lpfc_els.c
+++ b/scsi/lpfc/lpfc_els.c
@@ -4407,6 +4407,11 @@ lpfc_rscn_payload_check(struct lpfc_vpor
 		lp = vport->fc_rscn_id_list[i]->virt;
 		payload_len = be32_to_cpu(*lp++ & ~ELS_CMD_MASK);
 		payload_len -= sizeof(uint32_t);	/* take off word 0 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (payload_len) {
 			rscn_did.un.word = be32_to_cpu(*lp++);
 			payload_len -= sizeof(uint32_t);
@@ -4429,6 +4434,12 @@ lpfc_rscn_payload_check(struct lpfc_vpor
 			case RSCN_ADDRESS_FORMAT_FABRIC:
 				goto return_did_out;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	/* Indicate we are done with walking fc_rscn_id_list on this vport */
diff -u -p a/scsi/lpfc/lpfc_sli.c b/scsi/lpfc/lpfc_sli.c
--- a/scsi/lpfc/lpfc_sli.c
+++ b/scsi/lpfc/lpfc_sli.c
@@ -249,11 +249,22 @@ lpfc_sli4_eq_release(struct lpfc_queue *
 	struct lpfc_register doorbell;
 
 	/* while there are valid entries */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->hba_index != q->host_index) {
 		temp_eqe = q->qe[q->host_index].eqe;
 		bf_set_le32(lpfc_eqe_valid, temp_eqe, 0);
 		released++;
 		q->host_index = ((q->host_index + 1) % q->entry_count);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (unlikely(released == 0 && !arm))
 		return 0;
@@ -323,11 +334,22 @@ lpfc_sli4_cq_release(struct lpfc_queue *
 	struct lpfc_register doorbell;
 
 	/* while there are valid entries */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (q->hba_index != q->host_index) {
 		temp_qe = q->qe[q->host_index].cqe;
 		bf_set_le32(lpfc_cqe_valid, temp_qe, 0);
 		released++;
 		q->host_index = ((q->host_index + 1) % q->entry_count);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (unlikely(released == 0 && !arm))
 		return 0;
@@ -1042,6 +1064,11 @@ lpfc_sli_cancel_iocbs(struct lpfc_hba *p
 {
 	struct lpfc_iocbq *piocb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(iocblist)) {
 		list_remove_head(iocblist, piocb, struct lpfc_iocbq, list);
 
@@ -1052,6 +1079,12 @@ lpfc_sli_cancel_iocbs(struct lpfc_hba *p
 			piocb->iocb.un.ulpWord[4] = ulpWord4;
 			(piocb->iocb_cmpl) (phba, piocb, piocb);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return;
 }
@@ -1808,7 +1841,12 @@ lpfc_sli_hbqbuf_fill_hbqs(struct lpfc_hb
 	spin_lock_irqsave(&phba->hbalock, flags);
 	if (!phba->hbq_in_use)
 		goto err;
-	while (!list_empty(&hbq_buf_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&hbq_buf_list)) {
 		list_remove_head(&hbq_buf_list, hbq_buffer, struct hbq_dmabuf,
 				 dbuf.list);
 		hbq_buffer->tag = (phba->hbqs[hbqno].buffer_count |
@@ -1818,15 +1856,32 @@ lpfc_sli_hbqbuf_fill_hbqs(struct lpfc_hb
 			posted++;
 		} else
 			(phba->hbqs[hbqno].hbq_free_buffer)(phba, hbq_buffer);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	spin_unlock_irqrestore(&phba->hbalock, flags);
 	return posted;
 err:
 	spin_unlock_irqrestore(&phba->hbalock, flags);
-	while (!list_empty(&hbq_buf_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&hbq_buf_list)) {
 		list_remove_head(&hbq_buf_list, hbq_buffer, struct hbq_dmabuf,
 				 dbuf.list);
 		(phba->hbqs[hbqno].hbq_free_buffer)(phba, hbq_buffer);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return 0;
 }
@@ -2856,6 +2911,11 @@ lpfc_sli_handle_fast_ring_event(struct l
 		phba->fcp_ring_in_use = 1;
 
 	rmb();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pring->rspidx != portRspPut) {
 		/*
 		 * Fetch an entry off the ring and copy it into a local data
@@ -2971,6 +3031,12 @@ lpfc_sli_handle_fast_ring_event(struct l
 
 		if (pring->rspidx == portRspPut)
 			portRspPut = le32_to_cpu(pgp->rspPutInx);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+		}
 	}
 
 	if ((rsp_cmpl > 0) && (mask & HA_R0RE_REQ)) {
@@ -3343,7 +3409,12 @@ lpfc_sli_handle_slow_ring_event_s4(struc
 	spin_lock_irqsave(&phba->hbalock, iflag);
 	phba->hba_flag &= ~HBA_SP_QUEUE_EVT;
 	spin_unlock_irqrestore(&phba->hbalock, iflag);
-	while (!list_empty(&phba->sli4_hba.sp_queue_event)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->sli4_hba.sp_queue_event)) {
 		/* Get the response iocb from the head of work queue */
 		spin_lock_irqsave(&phba->hbalock, iflag);
 		list_remove_head(&phba->sli4_hba.sp_queue_event,
@@ -3370,6 +3441,12 @@ lpfc_sli_handle_slow_ring_event_s4(struc
 		default:
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4052,6 +4129,11 @@ lpfc_sli_chipset_init(struct lpfc_hba *p
 
 	/* Check status register to see what current state is */
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status & (HS_FFRDY | HS_MBRDY)) != (HS_FFRDY | HS_MBRDY)) {
 
 		/* Check every 10ms for 10 retries, then every 100ms for 90
@@ -4105,6 +4187,12 @@ lpfc_sli_chipset_init(struct lpfc_hba *p
 		/* Read the HBA Host Status Register */
 		if (lpfc_readl(phba->HSregaddr, &status))
 			return -EIO;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	/* Check to see if any errors occurred during init */
@@ -5312,10 +5400,21 @@ lpfc_sli4_alloc_extent(struct lpfc_hba *
 			phba->sli4_hba.scsi_xri_start = rsrc_start +
 				lpfc_sli4_get_els_iocb_cnt(phba);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (rsrc_id < (rsrc_start + rsrc_size)) {
 			ids[j] = rsrc_id;
 			rsrc_id++;
 			j++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		/* Entire word processed.  Get next word.*/
 		if ((i % 2) == 1)
@@ -8457,11 +8556,22 @@ lpfc_sli_mbox_sys_flush(struct lpfc_hba
 	spin_unlock_irqrestore(&phba->hbalock, iflag);
 
 	/* Return all flushed mailbox commands with MBX_NOT_FINISHED status */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&completions)) {
 		list_remove_head(&completions, pmb, LPFC_MBOXQ_t, list);
 		pmb->u.mb.mbxStatus = MBX_NOT_FINISHED;
 		if (pmb->mbox_cmpl)
 			pmb->mbox_cmpl(phba, pmb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -8598,11 +8708,22 @@ lpfc_sli_hba_down(struct lpfc_hba *phba)
 	phba->elsbuf_prev_cnt = 0;
 	spin_unlock_irqrestore(&phba->hbalock, flags);
 
-	while (!list_empty(&completions)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&completions)) {
 		list_remove_head(&completions, buf_ptr,
 			struct lpfc_dmabuf, list);
 		lpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);
 		kfree(buf_ptr);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Return any active mbox cmds */
@@ -10414,7 +10535,12 @@ void lpfc_sli4_fcp_xri_abort_event_proc(
 	phba->hba_flag &= ~FCP_XRI_ABORT_EVENT;
 	spin_unlock_irq(&phba->hbalock);
 	/* Now, handle all the fcp xri abort events */
-	while (!list_empty(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue)) {
 		/* Get the first event from the head of the event queue */
 		spin_lock_irq(&phba->hbalock);
 		list_remove_head(&phba->sli4_hba.sp_fcp_xri_aborted_work_queue,
@@ -10424,6 +10550,12 @@ void lpfc_sli4_fcp_xri_abort_event_proc(
 		lpfc_sli4_fcp_xri_aborted(phba, &cq_event->cqe.wcqe_axri);
 		/* Free the event processed back to the free pool */
 		lpfc_sli4_cq_event_release(phba, cq_event);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -10443,7 +10575,12 @@ void lpfc_sli4_els_xri_abort_event_proc(
 	phba->hba_flag &= ~ELS_XRI_ABORT_EVENT;
 	spin_unlock_irq(&phba->hbalock);
 	/* Now, handle all the els xri abort events */
-	while (!list_empty(&phba->sli4_hba.sp_els_xri_aborted_work_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&phba->sli4_hba.sp_els_xri_aborted_work_queue)) {
 		/* Get the first event from the head of the event queue */
 		spin_lock_irq(&phba->hbalock);
 		list_remove_head(&phba->sli4_hba.sp_els_xri_aborted_work_queue,
@@ -10453,6 +10590,12 @@ void lpfc_sli4_els_xri_abort_event_proc(
 		lpfc_sli4_els_xri_aborted(phba, &cq_event->cqe.wcqe_axri);
 		/* Free the event processed back to the free pool */
 		lpfc_sli4_cq_event_release(phba, cq_event);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -11017,14 +11160,30 @@ lpfc_sli4_sp_handle_eqe(struct lpfc_hba
 	/* Process all the entries to the CQ */
 	switch (cq->type) {
 	case LPFC_MCQ:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((cqe = lpfc_sli4_cq_get(cq))) {
 			workposted |= lpfc_sli4_sp_handle_mcqe(phba, cqe);
 			if (!(++ecount % cq->entry_repost))
 				lpfc_sli4_cq_release(cq, LPFC_QUEUE_NOARM);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		break;
 	case LPFC_WCQ:
-		while ((cqe = lpfc_sli4_cq_get(cq))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((cqe = lpfc_sli4_cq_get(cq))) {
 			if (cq->subtype == LPFC_FCP)
 				workposted |= lpfc_sli4_fp_handle_wcqe(phba, cq,
 								       cqe);
@@ -11033,6 +11192,12 @@ lpfc_sli4_sp_handle_eqe(struct lpfc_hba
 								      cqe);
 			if (!(++ecount % cq->entry_repost))
 				lpfc_sli4_cq_release(cq, LPFC_QUEUE_NOARM);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		break;
 	default:
@@ -11261,10 +11426,21 @@ lpfc_sli4_fp_handle_eqe(struct lpfc_hba
 	}
 
 	/* Process all the entries to the CQ */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cqe = lpfc_sli4_cq_get(cq))) {
 		workposted |= lpfc_sli4_fp_handle_wcqe(phba, cq, cqe);
 		if (!(++ecount % cq->entry_repost))
 			lpfc_sli4_cq_release(cq, LPFC_QUEUE_NOARM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Catch the no cq entry condition */
@@ -11350,10 +11526,21 @@ lpfc_sli4_sp_intr_handler(int irq, void
 	/*
 	 * Process all the event on FCP slow-path EQ
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((eqe = lpfc_sli4_eq_get(speq))) {
 		lpfc_sli4_sp_handle_eqe(phba, eqe);
 		if (!(++ecount % speq->entry_repost))
 			lpfc_sli4_eq_release(speq, LPFC_QUEUE_NOARM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	/* Always clear and re-arm the slow-path EQ */
@@ -11432,10 +11619,21 @@ lpfc_sli4_fp_intr_handler(int irq, void
 	/*
 	 * Process all the event on FCP fast-path EQ
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((eqe = lpfc_sli4_eq_get(fpeq))) {
 		lpfc_sli4_fp_handle_eqe(phba, eqe, fcp_eqidx);
 		if (!(++ecount % fpeq->entry_repost))
 			lpfc_sli4_eq_release(fpeq, LPFC_QUEUE_NOARM);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	/* Always clear and re-arm the fast-path EQ */
@@ -11519,12 +11717,23 @@ lpfc_sli4_queue_free(struct lpfc_queue *
 	if (!queue)
 		return;
 
-	while (!list_empty(&queue->page_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&queue->page_list)) {
 		list_remove_head(&queue->page_list, dmabuf, struct lpfc_dmabuf,
 				 list);
 		dma_free_coherent(&queue->phba->pcidev->dev, SLI4_PAGE_SIZE,
 				  dmabuf->virt, dmabuf->phys);
 		kfree(dmabuf);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	kfree(queue);
 	return;
@@ -15553,6 +15762,11 @@ lpfc_cleanup_pending_mbox(struct lpfc_vp
 	spin_unlock_irq(&phba->hbalock);
 
 	/* Release the cleaned-up mailbox commands */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&mbox_cmd_list)) {
 		list_remove_head(&mbox_cmd_list, mb, LPFC_MBOXQ_t, list);
 		if (mb->u.mb.mbxCommand == MBX_REG_LOGIN64) {
@@ -15571,6 +15785,12 @@ lpfc_cleanup_pending_mbox(struct lpfc_vp
 			}
 		}
 		mempool_free(mb, phba->mbox_mem_pool);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Release the ndlp with the cleaned-up active mailbox command */
diff -u -p a/scsi/sd.c b/scsi/sd.c
--- a/scsi/sd.c
+++ b/scsi/sd.c
@@ -2106,6 +2106,11 @@ sd_read_cache_type(struct scsi_disk *sdk
 	if (scsi_status_is_good(res)) {
 		int offset = data.header_length + data.block_descriptor_length;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (offset < len) {
 			u8 page_code = buffer[offset] & 0x3F;
 			u8 spf       = buffer[offset] & 0x40;
@@ -2134,6 +2139,12 @@ sd_read_cache_type(struct scsi_disk *sdk
 					goto defaults;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		sd_printk(KERN_ERR, sdkp, "No Caching mode page found\n");
diff -u -p a/scsi/scsi_debug.c b/scsi/scsi_debug.c
--- a/scsi/scsi_debug.c
+++ b/scsi/scsi_debug.c
@@ -2018,6 +2018,11 @@ static void map_region(sector_t lba, uns
 	granularity = scsi_debug_unmap_granularity;
 	alignment = granularity - scsi_debug_unmap_alignment;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lba < end) {
 		sector_t block, rem;
 
@@ -2028,6 +2033,12 @@ static void map_region(sector_t lba, uns
 			set_bit(block, map_storep);
 
 		lba += granularity - rem;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2039,6 +2050,11 @@ static void unmap_region(sector_t lba, u
 	granularity = scsi_debug_unmap_granularity;
 	alignment = granularity - scsi_debug_unmap_alignment;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lba < end) {
 		sector_t block, rem;
 
@@ -2049,6 +2065,12 @@ static void unmap_region(sector_t lba, u
 			clear_bit(block, map_storep);
 
 		lba += granularity - rem;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/qla2xxx/qla_nx.c b/scsi/qla2xxx/qla_nx.c
--- a/scsi/qla2xxx/qla_nx.c
+++ b/scsi/qla2xxx/qla_nx.c
@@ -2589,7 +2589,12 @@ qla2xx_build_scsi_type_6_iocbs(srb_t *sp
 	cur_seg = scsi_sglist(cmd);
 	ctx = sp->ctx;
 
-	while (tot_dsds) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tot_dsds) {
 		avail_dsds = (tot_dsds > QLA_DSDS_PER_IOCB) ?
 		    QLA_DSDS_PER_IOCB : tot_dsds;
 		tot_dsds -= avail_dsds;
@@ -2616,6 +2621,11 @@ qla2xx_build_scsi_type_6_iocbs(srb_t *sp
 			*cur_dsd++ = cpu_to_le32(dsd_list_len);
 		}
 		cur_dsd = (uint32_t *)next_dsd;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (avail_dsds) {
 			dma_addr_t	sle_dma;
 
@@ -2625,6 +2635,18 @@ qla2xx_build_scsi_type_6_iocbs(srb_t *sp
 			*cur_dsd++ = cpu_to_le32(sg_dma_len(cur_seg));
 			cur_seg = sg_next(cur_seg);
 			avail_dsds--;
+			if (_cur < timeout) {
+		    rdstcll(_cur);
+			}
+			else {
+		    break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
@@ -2990,11 +3012,22 @@ sufficient_dsds:
 			(unsigned long __iomem *)ha->nxdb_wr_ptr,
 			dbval);
 		wmb();
-		while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
 			WRT_REG_DWORD(
 				(unsigned long __iomem *)ha->nxdb_wr_ptr,
 				dbval);
 			wmb();
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -3296,10 +3329,21 @@ qla82xx_start_iocbs(srb_t *sp)
 	else {
 		WRT_REG_DWORD((unsigned long __iomem *)ha->nxdb_wr_ptr, dbval);
 		wmb();
-		while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
 			WRT_REG_DWORD((unsigned long  __iomem *)ha->nxdb_wr_ptr,
 				dbval);
 			wmb();
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 }
@@ -3438,7 +3482,12 @@ qla82xx_need_qsnt_handler(scsi_qla_host_
 	/* Its 2 that is written when qsnt is acked, moving one bit */
 	drv_active = drv_active << 0x01;
 
-	while (drv_state != drv_active) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (drv_state != drv_active) {
 
 		if (time_after_eq(jiffies, reset_timeout)) {
 			/* quiescence timeout, other functions didn't ack
@@ -3468,6 +3517,12 @@ qla82xx_need_qsnt_handler(scsi_qla_host_
 		drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
 		drv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
 		drv_active = drv_active << 0x01;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
 	/* everyone acked so set the state to DEV_QUIESCENCE */
diff -u -p a/scsi/qla2xxx/qla_os.c b/scsi/qla2xxx/qla_os.c
--- a/scsi/qla2xxx/qla_os.c
+++ b/scsi/qla2xxx/qla_os.c
@@ -727,12 +727,23 @@ qla2x00_wait_for_hba_online(scsi_qla_hos
 	scsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);
 
 	wait_online = jiffies + (MAX_LOOP_TIMEOUT * HZ);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (((test_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags)) ||
 	    test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags) ||
 	    test_bit(ISP_ABORT_RETRY, &base_vha->dpc_flags) ||
 	    ha->dpc_active) && time_before(jiffies, wait_online)) {
 
 		msleep(1000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (base_vha->flags.online)
 		return_status = QLA_SUCCESS;
@@ -2485,6 +2496,11 @@ qla2x00_remove_one(struct pci_dev *pdev)
 	ha = base_vha->hw;
 
 	mutex_lock(&ha->vport_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ha->cur_vport_count) {
 		struct Scsi_Host *scsi_host;
 
@@ -2502,6 +2518,12 @@ qla2x00_remove_one(struct pci_dev *pdev)
 		scsi_host_put(vha->host);
 
 		mutex_lock(&ha->vport_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&ha->vport_lock);
 
@@ -3453,7 +3475,12 @@ qla2x00_do_dpc(void *data)
 	set_user_nice(current, -20);
 
 	set_current_state(TASK_INTERRUPTIBLE);
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		ql_dbg(ql_dbg_dpc, base_vha, 0x4000,
 		    "DPC handler sleeping.\n");
 
@@ -3623,6 +3650,12 @@ qla2x00_do_dpc(void *data)
 
 		ha->dpc_active = 0;
 		set_current_state(TASK_INTERRUPTIBLE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} /* End of while(1) */
 	__set_current_state(TASK_RUNNING);
 
diff -u -p a/scsi/qla2xxx/qla_init.c b/scsi/qla2xxx/qla_init.c
--- a/scsi/qla2xxx/qla_init.c
+++ b/scsi/qla2xxx/qla_init.c
@@ -3511,6 +3511,11 @@ qla2x00_device_resync(scsi_qla_host_t *v
 
 	rval = QLA_RSCNS_HANDLED;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (vha->rscn_out_ptr != vha->rscn_in_ptr ||
 	    vha->flags.rscn_queue_overflow) {
 
@@ -3588,6 +3593,12 @@ qla2x00_device_resync(scsi_qla_host_t *v
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (rval);
 }
diff -u -p a/scsi/qla2xxx/qla_iocb.c b/scsi/qla2xxx/qla_iocb.c
--- a/scsi/qla2xxx/qla_iocb.c
+++ b/scsi/qla2xxx/qla_iocb.c
@@ -576,10 +576,21 @@ qla2x00_isp_cmd(struct scsi_qla_host *vh
 				(unsigned long __iomem *)ha->nxdb_wr_ptr,
 				dbval);
 			wmb();
-			while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {
 				WRT_REG_DWORD((unsigned long __iomem *)
 					ha->nxdb_wr_ptr, dbval);
 				wmb();
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	} else if (ha->mqenable) {
@@ -879,6 +890,11 @@ qla24xx_walk_and_build_sglist_no_difb(st
 
 	sg_prot = scsi_prot_sglist(sp->cmd);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qla24xx_get_one_block_sg(prot_int, &sgx, &partial)) {
 
 		sle_dma = sgx.dma_addr;
@@ -940,6 +956,12 @@ alloc_and_fill:
 			partial = 1; /* So as to not re-enter this block */
 			goto alloc_and_fill;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Null termination */
 	*cur_dsd++ = 0;
diff -u -p a/scsi/qla2xxx/qla_mid.c b/scsi/qla2xxx/qla_mid.c
--- a/scsi/qla2xxx/qla_mid.c
+++ b/scsi/qla2xxx/qla_mid.c
@@ -71,12 +71,23 @@ qla24xx_deallocate_vp_id(scsi_qla_host_t
 	 * from the queue)
 	 */
 	spin_lock_irqsave(&ha->vport_slock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (atomic_read(&vha->vref_count)) {
 		spin_unlock_irqrestore(&ha->vport_slock, flags);
 
 		msleep(500);
 
 		spin_lock_irqsave(&ha->vport_slock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	list_del(&vha->list);
 	spin_unlock_irqrestore(&ha->vport_slock, flags);
diff -u -p a/scsi/qla2xxx/qla_sup.c b/scsi/qla2xxx/qla_sup.c
--- a/scsi/qla2xxx/qla_sup.c
+++ b/scsi/qla2xxx/qla_sup.c
@@ -27,9 +27,20 @@ qla2x00_lock_nvram_access(struct qla_hw_
 
 	if (!IS_QLA2100(ha) && !IS_QLA2200(ha) && !IS_QLA2300(ha)) {
 		data = RD_REG_WORD(&reg->nvram);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (data & NVR_BUSY) {
 			udelay(100);
 			data = RD_REG_WORD(&reg->nvram);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Lock resource */
@@ -2492,6 +2503,11 @@ qla2x00_get_fcode_version(struct qla_hw_
 		/* Scan for the sentinel date string...eeewww. */
 		do_next = 0;
 		iter = istart;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((iter < iend) && !do_next) {
 			iter++;
 			if (qla2x00_read_flash_byte(ha, iter) == '/') {
@@ -2502,16 +2518,33 @@ qla2x00_get_fcode_version(struct qla_hw_
 				    iter + 3) == '/')
 					do_next++;
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		if (!do_next)
 			break;
 
 		/* Backtrack to previous ' ' (space). */
 		do_next = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((iter > istart) && !do_next) {
 			iter--;
 			if (qla2x00_read_flash_byte(ha, iter) == ' ')
 				do_next++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!do_next)
 			break;
@@ -2522,11 +2555,22 @@ qla2x00_get_fcode_version(struct qla_hw_
 		 */
 		vend = iter - 1;
 		do_next = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((iter > istart) && !do_next) {
 			iter--;
 			rbyte = qla2x00_read_flash_byte(ha, iter);
 			if (rbyte == ' ' || rbyte == 0xd || rbyte == 0x10)
 				do_next++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!do_next)
 			break;
@@ -2536,9 +2580,20 @@ qla2x00_get_fcode_version(struct qla_hw_
 		if ((vend - iter) &&
 		    ((vend - iter) < sizeof(ha->fcode_revision))) {
 			vbyte = ha->fcode_revision;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (iter <= vend) {
 				*vbyte++ = qla2x00_read_flash_byte(ha, iter);
 				iter++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			ret = QLA_SUCCESS;
 		}
diff -u -p a/scsi/qla4xxx/ql4_init.c b/scsi/qla4xxx/ql4_init.c
--- a/scsi/qla4xxx/ql4_init.c
+++ b/scsi/qla4xxx/ql4_init.c
@@ -630,6 +630,11 @@ int ql4xxx_lock_drvr_wait(struct scsi_ql
 #define QL4_LOCK_DRVR_SLEEP	1
 
 	int drvr_wait = QL4_LOCK_DRVR_WAIT;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drvr_wait) {
 		if (ql4xxx_lock_drvr(a) == 0) {
 			ssleep(QL4_LOCK_DRVR_SLEEP);
@@ -645,6 +650,12 @@ int ql4xxx_lock_drvr_wait(struct scsi_ql
 				      "acquired\n", a->host_no, __func__));
 			return QLA_SUCCESS;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return QLA_ERROR;
 }
diff -u -p a/scsi/qla4xxx/ql4_nx.c b/scsi/qla4xxx/ql4_nx.c
--- a/scsi/qla4xxx/ql4_nx.c
+++ b/scsi/qla4xxx/ql4_nx.c
@@ -1802,6 +1802,11 @@ int qla4_8xxx_device_state_handler(struc
 	/* wait for 30 seconds for device to go ready */
 	dev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		qla4_8xxx_idc_lock(ha);
 
@@ -1860,7 +1865,13 @@ int qla4_8xxx_device_state_handler(struc
 			rval = QLA_ERROR;
 			goto exit;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 exit:
 	return rval;
 }
diff -u -p a/scsi/qla4xxx/ql4_os.c b/scsi/qla4xxx/ql4_os.c
--- a/scsi/qla4xxx/ql4_os.c
+++ b/scsi/qla4xxx/ql4_os.c
@@ -2198,6 +2198,11 @@ static int qla4xxx_cmd_wait(struct scsi_
 	DEBUG2(ql4_printk(KERN_INFO, ha, "Wait up to %d seconds for cmds to "
 	    "complete\n", WAIT_CMD_TOV));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!time_after_eq(jiffies, wtime)) {
 		spin_lock_irqsave(&ha->hardware_lock, flags);
 		/* Find a command that hasn't completed. */
@@ -2219,6 +2224,12 @@ static int qla4xxx_cmd_wait(struct scsi_
 			return QLA_SUCCESS;
 
 		msleep(1000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* If we timed out on waiting for commands to come back
 	 * return ERROR. */
@@ -4592,12 +4603,23 @@ static int qla4xxx_wait_for_hba_online(s
 	unsigned long wait_online;
 
 	wait_online = jiffies + (HBA_ONLINE_TOV * HZ);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, wait_online)) {
 
 		if (adapter_up(ha))
 			return QLA_SUCCESS;
 
 		msleep(2000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return QLA_ERROR;
diff -u -p a/scsi/qla4xxx/ql4_isr.c b/scsi/qla4xxx/ql4_isr.c
--- a/scsi/qla4xxx/ql4_isr.c
+++ b/scsi/qla4xxx/ql4_isr.c
@@ -1042,6 +1042,11 @@ void qla4xxx_process_aen(struct scsi_qla
 	unsigned long flags;
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ha->aen_out != ha->aen_in) {
 		aen = &ha->aen_q[ha->aen_out];
 		/* copy aen information to local structure */
@@ -1083,6 +1088,12 @@ void qla4xxx_process_aen(struct scsi_qla
 			}
 		}
 		spin_lock_irqsave(&ha->hardware_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 }
diff -u -p a/scsi/in2000.c b/scsi/in2000.c
--- a/scsi/in2000.c
+++ b/scsi/in2000.c
@@ -1697,6 +1697,11 @@ static int __in2000_abort(Scsi_Cmnd * cm
 
 	tmp = (Scsi_Cmnd *) hostdata->input_Q;
 	prev = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmp) {
 		if (tmp == cmd) {
 			if (prev)
@@ -1709,6 +1714,12 @@ static int __in2000_abort(Scsi_Cmnd * cm
 		}
 		prev = tmp;
 		tmp = (Scsi_Cmnd *) tmp->host_scribble;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 /*
@@ -2276,19 +2287,41 @@ static int in2000_proc_info(struct Scsi_
 	if (hd->proc & PR_INPUTQ) {
 		strcat(bp, "\ninput_Q:       ");
 		cmd = (Scsi_Cmnd *) hd->input_Q;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)", cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (Scsi_Cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (hd->proc & PR_DISCQ) {
 		strcat(bp, "\ndisconnected_Q:");
 		cmd = (Scsi_Cmnd *) hd->disconnected_Q;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)", cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (Scsi_Cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (hd->proc & PR_TEST) {
diff -u -p a/scsi/scsi_lib.c b/scsi/scsi_lib.c
--- a/scsi/scsi_lib.c
+++ b/scsi/scsi_lib.c
@@ -2325,9 +2325,20 @@ scsi_device_quiesce(struct scsi_device *
 		return err;
 
 	scsi_run_queue(sdev->request_queue);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sdev->device_busy) {
 		msleep_interruptible(200);
 		scsi_run_queue(sdev->request_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/scsi/pmcraid.c b/scsi/pmcraid.c
--- a/scsi/pmcraid.c
+++ b/scsi/pmcraid.c
@@ -4606,6 +4606,11 @@ static void pmcraid_tasklet_function(uns
 
 	resp = le32_to_cpu(*(pinstance->hrrq_curr[id]));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((resp & HRRQ_TOGGLE_BIT) ==
 		pinstance->host_toggle_bit[id]) {
 
@@ -4649,6 +4654,12 @@ static void pmcraid_tasklet_function(uns
 		/* loop over until we are done with all responses */
 		spin_lock_irqsave(lockp, hrrq_lock_flags);
 		resp = le32_to_cpu(*(pinstance->hrrq_curr[id]));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(lockp, hrrq_lock_flags);
diff -u -p a/scsi/atari_scsi.c b/scsi/atari_scsi.c
--- a/scsi/atari_scsi.c
+++ b/scsi/atari_scsi.c
@@ -552,6 +552,11 @@ static void falcon_get_lock(void)
 	while (!in_irq() && falcon_got_lock && stdma_others_waiting())
 		sleep_on(&falcon_fairness_wait);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!falcon_got_lock) {
 		if (in_irq())
 			panic("Falcon SCSI hasn't ST-DMA lock in interrupt");
@@ -564,6 +569,12 @@ static void falcon_get_lock(void)
 		} else {
 			sleep_on(&falcon_try_wait);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	local_irq_restore(flags);
diff -u -p a/scsi/vmw_pvscsi.c b/scsi/vmw_pvscsi.c
--- a/scsi/vmw_pvscsi.c
+++ b/scsi/vmw_pvscsi.c
@@ -591,7 +591,12 @@ static void pvscsi_process_completion_ri
 	struct PVSCSIRingCmpDesc *ring = adapter->cmp_ring;
 	u32 cmp_entries = s->cmpNumEntriesLog2;
 
-	while (s->cmpConsIdx != s->cmpProdIdx) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (s->cmpConsIdx != s->cmpProdIdx) {
 		struct PVSCSIRingCmpDesc *e = ring + (s->cmpConsIdx &
 						      MASK(cmp_entries));
 		/*
@@ -610,6 +615,12 @@ static void pvscsi_process_completion_ri
 		 */
 		barrier();
 		s->cmpConsIdx++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -988,7 +999,12 @@ static void pvscsi_process_msg_ring(cons
 	struct PVSCSIRingMsgDesc *ring = adapter->msg_ring;
 	u32 msg_entries = s->msgNumEntriesLog2;
 
-	while (pvscsi_msg_pending(adapter)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pvscsi_msg_pending(adapter)) {
 		struct PVSCSIRingMsgDesc *e = ring + (s->msgConsIdx &
 						      MASK(msg_entries));
 
@@ -996,6 +1012,12 @@ static void pvscsi_process_msg_ring(cons
 		pvscsi_process_msg(adapter, e);
 		barrier();
 		s->msgConsIdx++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/scsi/scsi_transport_fc.c b/scsi/scsi_transport_fc.c
--- a/scsi/scsi_transport_fc.c
+++ b/scsi/scsi_transport_fc.c
@@ -1597,12 +1597,23 @@ store_fc_private_host_tgtid_bind_type(st
 	/* if changing bind type, purge all unused consistent bindings */
 	if (val != fc_host_tgtid_bind_type(shost)) {
 		spin_lock_irqsave(shost->host_lock, flags);
-		while (!list_empty(&fc_host_rport_bindings(shost))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&fc_host_rport_bindings(shost))) {
 			get_list_head_entry(rport,
 				&fc_host_rport_bindings(shost), peers);
 			list_del(&rport->peers);
 			rport->port_state = FC_PORTSTATE_DELETED;
 			fc_queue_work(shost, &rport->rport_delete_work);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		spin_unlock_irqrestore(shost->host_lock, flags);
 	}
diff -u -p a/scsi/sgiwd93.c b/scsi/sgiwd93.c
--- a/scsi/sgiwd93.c
+++ b/scsi/sgiwd93.c
@@ -75,6 +75,11 @@ void fill_hpc_entries(struct ip22_hostda
 	cmd->SCp.dma_handle = physaddr;
 	hcp = hd->cpu;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		/*
 		 * even cntinfo could be up to 16383, without
@@ -86,6 +91,12 @@ void fill_hpc_entries(struct ip22_hostda
 		hcp++;
 		len -= count;
 		physaddr += count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -181,12 +192,23 @@ static inline void init_hpc_chain(struct
 
 	start = (unsigned long) hcp;
 	end = start + HPC_DMA_SIZE;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start < end) {
 		hcp->desc.pnext = (u32) (dma + sizeof(struct hpc_chunk));
 		hcp->desc.cntinfo = HPCDMA_EOX;
 		hcp++;
 		dma += sizeof(struct hpc_chunk);
 		start += sizeof(struct hpc_chunk);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	};
 	hcp--;
 	hcp->desc.pnext = hdata->dma;
diff -u -p a/scsi/wd7000.c b/scsi/wd7000.c
--- a/scsi/wd7000.c
+++ b/scsi/wd7000.c
@@ -764,11 +764,22 @@ static inline short WAIT(unsigned port,
 	unsigned WAITbits;
 	unsigned long WAITtimeout = jiffies + WAITnexttimeout;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before_eq(jiffies, WAITtimeout)) {
 		WAITbits = inb(port) & mask;
 
 		if (((WAITbits & allof) == allof) && ((WAITbits & noneof) == 0))
 			return (0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return (1);
@@ -820,6 +831,11 @@ static inline Scb *alloc_scbs(struct Scs
 	spin_unlock_irq(host->host_lock);
 
       retry:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (freescbs < needed) {
 		timeout = jiffies + WAITnexttimeout;
 		do {
@@ -835,6 +851,12 @@ static inline Scb *alloc_scbs(struct Scs
 			printk(KERN_ERR "wd7000: can't get enough free SCBs.\n");
 			return (NULL);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Take the lock, then check we didn't get beaten, if so try again */
@@ -1287,9 +1309,20 @@ static void wd7000_revision(Adapter * ho
 	 * which in turn means that scatter/gather will be disabled.
 	 */
 	mail_out(host, (struct scb *) &icb);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (icb.phase) {
 		cpu_relax();	/* wait for completion */
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	host->rev1 = icb.primary;
 	host->rev2 = icb.secondary;
diff -u -p a/scsi/bnx2i/bnx2i_iscsi.c b/scsi/bnx2i/bnx2i_iscsi.c
--- a/scsi/bnx2i/bnx2i_iscsi.c
+++ b/scsi/bnx2i/bnx2i_iscsi.c
@@ -59,10 +59,21 @@ static void bnx2i_get_write_cmd_bd_idx(s
 	u32 cur_bd_idx = 0;
 
 	if (buf_off) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (buf_off >= (cur_offset + bd_tbl->buffer_length)) {
 			cur_offset += bd_tbl->buffer_length;
 			cur_bd_idx++;
 			bd_tbl++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/scsi/bnx2i/bnx2i_init.c b/scsi/bnx2i/bnx2i_init.c
--- a/scsi/bnx2i/bnx2i_init.c
+++ b/scsi/bnx2i/bnx2i_init.c
@@ -536,6 +536,11 @@ static void __exit bnx2i_mod_exit(void)
 	unsigned cpu = 0;
 
 	mutex_lock(&bnx2i_dev_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&adapter_list)) {
 		hba = list_entry(adapter_list.next, struct bnx2i_hba, link);
 		list_del(&hba->link);
@@ -548,6 +553,12 @@ static void __exit bnx2i_mod_exit(void)
 		}
 
 		bnx2i_free_hba(hba);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&bnx2i_dev_lock);
 
diff -u -p a/scsi/bnx2i/bnx2i_hwi.c b/scsi/bnx2i/bnx2i_hwi.c
--- a/scsi/bnx2i/bnx2i_hwi.c
+++ b/scsi/bnx2i/bnx2i_hwi.c
@@ -721,9 +721,20 @@ static int bnx2i_power_of2(u32 val)
 	if (val & (val - 1))
 		return power;
 	val--;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (val) {
 		val = val >> 1;
 		power++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return power;
 }
@@ -1857,8 +1868,18 @@ int bnx2i_percpu_io_thread(void *arg)
 
 	set_user_nice(current, -20);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		spin_lock_bh(&p->p_work_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!list_empty(&p->work_list)) {
 			list_splice_init(&p->work_list, &work_list);
 			spin_unlock_bh(&p->p_work_lock);
@@ -1873,10 +1894,22 @@ int bnx2i_percpu_io_thread(void *arg)
 				kfree(work);
 			}
 			spin_lock_bh(&p->p_work_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock_bh(&p->p_work_lock);
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	__set_current_state(TASK_RUNNING);
 
@@ -2482,6 +2515,11 @@ static void bnx2i_indicate_kcqe(void *co
 	int i = 0;
 	struct iscsi_kcqe *ikcqe = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < num_cqe) {
 		ikcqe = (struct iscsi_kcqe *) kcqe[i++];
 
@@ -2517,6 +2555,12 @@ static void bnx2i_indicate_kcqe(void *co
 		else
 			printk(KERN_ALERT "bnx2i: unknown opcode 0x%x\n",
 					  ikcqe->op_code);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/scsi/FlashPoint.c b/scsi/FlashPoint.c
--- a/scsi/FlashPoint.c
+++ b/scsi/FlashPoint.c
@@ -759,10 +759,32 @@ typedef struct SCCBscam_info {
          count >>= 16,\
          WR_HARPOON(port+hp_xfer_cnt_hi, (count & 0xFF)))
 
-#define ACCEPT_MSG(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
+#define ACCEPT_MSG(port) {unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}\
                           WR_HARPOON(port+hp_scsisig, S_ILL_PH);}
 
-#define ACCEPT_MSG_ATN(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
+#define ACCEPT_MSG_ATN(port) {unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}\
                           WR_HARPOON(port+hp_scsisig, (S_ILL_PH|SCSI_ATN));}
 
 #define DISABLE_AUTO(port) (WR_HARPOON(port+hp_scsireset, PROG_RESET),\
@@ -2072,7 +2094,18 @@ static unsigned char FPT_SccbMgr_bad_isr
 
 		FPT_sresb(p_port, p_card);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST) {
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		pCurrNvRam = pCurrCard->pNvRamInfo;
@@ -2689,12 +2722,23 @@ static void FPT_sres(unsigned long port,
 		currTar_Info = &FPT_sccbMgrTbl[p_card][our_target];
 		tag = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {
 			if (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {
 
 				WRW_HARPOON((port + hp_intstat), PHASE);
 				return;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		WRW_HARPOON((port + hp_intstat), PHASE);
@@ -2859,12 +2903,23 @@ static void FPT_sres(unsigned long port,
 
 static void FPT_SendMsg(unsigned long port, unsigned char message)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {
 		if (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {
 
 			WRW_HARPOON((port + hp_intstat), PHASE);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	WRW_HARPOON((port + hp_intstat), PHASE);
@@ -2884,9 +2939,20 @@ static void FPT_SendMsg(unsigned long po
 
 		if ((message == SMABORT) || (message == SMDEV_RESET) ||
 		    (message == SMABORT_TAG)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (!
 			       (RDW_HARPOON((port + hp_intstat)) &
 				(BUS_FREE | PHASE))) {
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			if (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {
@@ -2960,9 +3026,20 @@ static void FPT_sdecm(unsigned char mess
 
 			ACCEPT_MSG(port);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
 			       (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))
 			{
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			if (currSCCB->Lun == 0x00) {
@@ -3037,9 +3114,20 @@ static void FPT_sdecm(unsigned char mess
 		else {
 			ACCEPT_MSG(port);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
 			       (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))
 			{
+				if (_cur < timeout) {
+				    rdstcll(_cur);
+				}
+				else {
+				    break;
+				}
 			}
 
 			if (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)) {
@@ -3381,7 +3469,18 @@ static void FPT_sisyncr(unsigned long po
 
 	WR_HARPOON(port + hp_autostart_3, (AUTO_IMMED + CMD_ONLY_STRT));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -3536,7 +3635,18 @@ static void FPT_siwidr(unsigned long por
 
 	WR_HARPOON(port + hp_autostart_3, (AUTO_IMMED + CMD_ONLY_STRT));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -3638,7 +3748,18 @@ static void FPT_sresb(unsigned long port
 
 	WR_HARPOON(port + hp_portctrl_0, (SCSI_PORT | START_TO));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(RDW_HARPOON((port + hp_intstat)) & TIMEOUT)) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	WR_HARPOON(port + hp_seltimeout, scsiID);
@@ -3765,6 +3886,11 @@ static void FPT_sxfrp(unsigned long p_po
 
 	WR_HARPOON(p_port + hp_scsisig, curr_phz);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET)) &&
 	       (curr_phz ==
 		(RD_HARPOON(p_port + hp_scsisig) & (unsigned char)S_SCSI_PHZ)))
@@ -3783,6 +3909,12 @@ static void FPT_sxfrp(unsigned long p_po
 				WR_HARPOON(p_port + hp_fifodata_0, 0xFA);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}			/* End of While loop for padding data I/O phase */
 
 	while (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET))) {
@@ -3792,14 +3924,36 @@ static void FPT_sxfrp(unsigned long p_po
 
 	WR_HARPOON(p_port + hp_portctrl_0,
 		   (SCSI_PORT | HOST_PORT | SCSI_INBIT));
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY)) {
 		RD_HARPOON(p_port + hp_fifodata_0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET))) {
 		WR_HARPOON(p_port + hp_autostart_0,
 			   (AUTO_IMMED + DISCONNECT_START));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(RDW_HARPOON((p_port + hp_intstat)) & AUTO_INT)) {
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		if (RDW_HARPOON((p_port + hp_intstat)) &
@@ -3860,7 +4014,18 @@ static void FPT_schkdd(unsigned long por
 
 	FPT_hostDataXferAbort(port, p_card, currSCCB);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (RD_HARPOON(port + hp_scsisig) & SCSI_ACK) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	TimeOutLoop = 0;
@@ -4259,7 +4424,18 @@ static void FPT_phaseMsgOut(unsigned lon
 	if ((message == SMABORT) || (message == SMDEV_RESET) ||
 	    (message == SMABORT_TAG)) {
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | PHASE))) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {
@@ -4399,8 +4575,19 @@ static void FPT_phaseChkFifo(unsigned lo
 
 	if (currSCCB->Sccb_scsistat == DATA_IN_ST) {
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) &&
 		       (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) {
@@ -4418,9 +4605,20 @@ static void FPT_phaseChkFifo(unsigned lo
 
 			FPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY))
 			       && (RD_HARPOON(port + hp_ext_status) &
 				   BM_CMD_BUSY)) {
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 		}
@@ -5465,10 +5663,21 @@ static void FPT_hostDataXferRestart(stru
 
 		sg_ptr = (unsigned long *)currSCCB->DataPointer;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (data_count < currSCCB->Sccb_ATC) {
 
 			sg_index++;
 			data_count += *(sg_ptr + (sg_index * 2));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (data_count == currSCCB->Sccb_ATC) {
@@ -5713,7 +5922,18 @@ static int FPT_scarb(unsigned long p_por
 {
 	if (p_sel_type == INIT_SELTD) {
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (RD_HARPOON(p_port + hp_scsisig) & (SCSI_SEL | SCSI_BSY)) {
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (RD_HARPOON(p_port + hp_scsisig) & SCSI_SEL)
@@ -5816,6 +6036,11 @@ static void FPT_scasid(unsigned char p_c
 
 	i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!i) {
 
 		for (k = 0; k < ID_STRING_LENGTH; k++) {
@@ -5866,6 +6091,12 @@ static void FPT_scasid(unsigned char p_c
 			i = 1;
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}			/*End while */
 
 	FPT_scxferc(p_port, SYNC_PTRN);
@@ -6181,8 +6412,19 @@ static unsigned char FPT_scsell(unsigned
 	WR_HARPOON(p_port + hp_autostart_3, (SELECT | CMD_ONLY_STRT));
 	WR_HARPOON(p_port + hp_scsictrl_0, (SEL_TAR | ENA_RESEL));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(RDW_HARPOON((p_port + hp_intstat)) &
 		 (RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (RDW_HARPOON((p_port + hp_intstat)) & RESET)
@@ -6210,12 +6452,23 @@ static unsigned char FPT_scsell(unsigned
 
 	else {
 
-		while (!(RDW_HARPOON((p_port + hp_intstat)) & BUS_FREE)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!(RDW_HARPOON((p_port + hp_intstat)) & BUS_FREE)) {
 			if (RD_HARPOON(p_port + hp_scsisig) & SCSI_REQ) {
 				WR_HARPOON(p_port + hp_scsisig,
 					   (SCSI_ACK + S_ILL_PH));
 				ACCEPT_MSG(p_port);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		WRW_HARPOON((p_port + hp_intstat), CLR_ALL_INT_1);
@@ -6238,7 +6491,18 @@ static unsigned char FPT_scsell(unsigned
 
 static void FPT_scwtsel(unsigned long p_port)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL)) {
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -7227,11 +7491,22 @@ static void FPT_utilUpdateResidual(struc
 			sg_index++;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (((unsigned long)sg_index *
 			(unsigned long)SG_ELEMENT_SIZE) < p_SCCB->DataLength) {
 
 			partial_cnt += *(sg_ptr + (sg_index * 2));
 			sg_index++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		p_SCCB->DataLength = partial_cnt;
diff -u -p a/scsi/cxgbi/libcxgbi.c b/scsi/cxgbi/libcxgbi.c
--- a/scsi/cxgbi/libcxgbi.c
+++ b/scsi/cxgbi/libcxgbi.c
@@ -887,7 +887,12 @@ static int cxgbi_sock_send_pdus(struct c
 		goto out_err;
 	}
 
-	while (skb) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (skb) {
 		int frags = skb_shinfo(skb)->nr_frags +
 				(skb->len != skb->data_len);
 
@@ -914,7 +919,13 @@ static int cxgbi_sock_send_pdus(struct c
 		csk->write_seq += skb->len +
 				cxgbi_ulp_extra_len(cxgbi_skcb_ulp_mode(skb));
 		skb = next;
-	}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+}
 done:
 	if (likely(skb_queue_len(&csk->write_queue)))
 		cdev->csk_push_tx_frames(csk, 1);
@@ -1337,6 +1348,11 @@ static void ddp_destroy(struct kref *kre
 
 	pr_info("kref 0, destroy ddp 0x%p, cdev 0x%p.\n", ddp, cdev);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < ddp->nppods) {
 		struct cxgbi_gather_list *gl = ddp->gl_map[i];
 
@@ -1348,6 +1364,12 @@ static void ddp_destroy(struct kref *kre
 			i += npods;
 		} else
 			i++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	cxgbi_free_big_mem(ddp);
 }
diff -u -p a/scsi/ipr.c b/scsi/ipr.c
--- a/scsi/ipr.c
+++ b/scsi/ipr.c
@@ -2569,6 +2569,11 @@ static int ipr_wait_iodbg_ack(struct ipr
 	int delay = 1;
 
 	/* Read interrupt reg until IOA signals IO Debug Acknowledge */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (delay < max_delay) {
 		pcii_reg = readl(ioa_cfg->regs.sense_interrupt_reg);
 
@@ -2582,6 +2587,12 @@ static int ipr_wait_iodbg_ack(struct ipr
 			udelay(delay);
 
 		delay += delay;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -EIO;
 }
@@ -3313,10 +3324,21 @@ static ssize_t ipr_store_diagnostics(str
 		return -EACCES;
 
 	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ioa_cfg->errors_logged = 0;
@@ -3680,10 +3702,21 @@ static int ipr_update_ioa_ucode(struct i
 	unsigned long lock_flags;
 
 	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ioa_cfg->ucode_sglist) {
@@ -3915,7 +3948,12 @@ static ssize_t ipr_read_dump(struct file
 
 	off -= sdt_end;
 
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count) {
 		if ((off & PAGE_MASK) != ((off + count) & PAGE_MASK))
 			len = PAGE_ALIGN(off) - off;
 		else
@@ -3926,6 +3964,12 @@ static ssize_t ipr_read_dump(struct file
 		buf += len;
 		off += len;
 		count -= len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kref_put(&dump->kref, ipr_release_dump);
@@ -4716,10 +4760,21 @@ static int ipr_sata_reset(struct ata_lin
 
 	ENTER;
 	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	res = sata_port->res;
@@ -5109,7 +5164,12 @@ static irqreturn_t ipr_isr(int irq, void
 	while (1) {
 		ipr_cmd = NULL;
 
-		while ((be32_to_cpu(*ioa_cfg->hrrq_curr) & IPR_HRRQ_TOGGLE_BIT) ==
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((be32_to_cpu(*ioa_cfg->hrrq_curr) & IPR_HRRQ_TOGGLE_BIT) ==
 		       ioa_cfg->toggle_bit) {
 
 			cmd_index = (be32_to_cpu(*ioa_cfg->hrrq_curr) &
@@ -5139,6 +5199,12 @@ static irqreturn_t ipr_isr(int irq, void
 				ioa_cfg->hrrq_curr = ioa_cfg->hrrq_start;
 				ioa_cfg->toggle_bit ^= 1u;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (ipr_cmd != NULL) {
@@ -5943,10 +6009,21 @@ static void ipr_ata_phy_reset(struct ata
 
 	ENTER;
 	spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!ioa_cfg->allow_cmds)
@@ -5983,10 +6060,21 @@ static void ipr_ata_post_internal(struct
 	unsigned long flags;
 
 	spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	list_for_each_entry(ipr_cmd, &ioa_cfg->pending_q, queue) {
@@ -8922,10 +9010,21 @@ static void __ipr_remove(struct pci_dev
 	ENTER;
 
 	spin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ipr_initiate_ioa_bringdown(ioa_cfg, IPR_SHUTDOWN_NORMAL);
@@ -9051,10 +9150,21 @@ static void ipr_shutdown(struct pci_dev
 	unsigned long lock_flags = 0;
 
 	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ioa_cfg->in_reset_reload) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		wait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);
 		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ipr_initiate_ioa_bringdown(ioa_cfg, IPR_SHUTDOWN_NORMAL);
diff -u -p a/scsi/ips.c b/scsi/ips.c
--- a/scsi/ips.c
+++ b/scsi/ips.c
@@ -516,6 +516,11 @@ ips_setup(char *ips_str)
 
 	/* Don't use strtok() anymore ( if 2.4 Kernel or beyond ) */
 	/* Search for value */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((key = strsep(&ips_str, ",."))) {
 		if (!*key)
 			continue;
@@ -539,6 +544,12 @@ ips_setup(char *ips_str)
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return (1);
@@ -942,19 +953,41 @@ static int __ips_eh_reset(struct scsi_cm
 		DEBUG_VAR(1, "(%s%d) Failing active commands",
 			  ips_name, ha->host_num);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {
 			scb->scsi_cmd->result = DID_ERROR << 16;
 			scb->scsi_cmd->scsi_done(scb->scsi_cmd);
 			ips_freescb(ha, scb);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 
 		/* Now fail all of the pending commands */
 		DEBUG_VAR(1, "(%s%d) Failing pending commands",
 			  ips_name, ha->host_num);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((scsi_cmd = ips_removeq_wait_head(&ha->scb_waitlist))) {
 			scsi_cmd->result = DID_ERROR;
 			scsi_cmd->scsi_done(scsi_cmd);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		ha->active = FALSE;
@@ -971,19 +1004,41 @@ static int __ips_eh_reset(struct scsi_cm
 		DEBUG_VAR(1, "(%s%d) Failing active commands",
 			  ips_name, ha->host_num);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {
 			scb->scsi_cmd->result = DID_ERROR << 16;
 			scb->scsi_cmd->scsi_done(scb->scsi_cmd);
 			ips_freescb(ha, scb);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 
 		/* Now fail all of the pending commands */
 		DEBUG_VAR(1, "(%s%d) Failing pending commands",
 			  ips_name, ha->host_num);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((scsi_cmd = ips_removeq_wait_head(&ha->scb_waitlist))) {
 			scsi_cmd->result = DID_ERROR << 16;
 			scsi_cmd->scsi_done(scsi_cmd);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		ha->active = FALSE;
@@ -1003,10 +1058,21 @@ static int __ips_eh_reset(struct scsi_cm
 	/* Now fail all of the active commands */
 	DEBUG_VAR(1, "(%s%d) Failing active commands", ips_name, ha->host_num);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {
 		scb->scsi_cmd->result = DID_RESET << 16;
 		scb->scsi_cmd->scsi_done(scb->scsi_cmd);
 		ips_freescb(ha, scb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Reset DCDB active command bits */
@@ -2717,6 +2783,11 @@ ips_next(ips_ha_t * ha, int intr)
 	 */
 
 	p = ha->scb_waitlist.head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((p) && (scb = ips_getscb(ha))) {
 		if ((scmd_channel(p) > 0)
 		    && (ha->
@@ -2824,6 +2895,12 @@ ips_next(ips_ha_t * ha, int intr)
 
 		p = (struct scsi_cmnd *) p->host_scribble;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}			/* end while */
 
 	if (intr == IPS_INTR_ON)
diff -u -p a/scsi/libfc/fc_rport.c b/scsi/libfc/fc_rport.c
--- a/scsi/libfc/fc_rport.c
+++ b/scsi/libfc/fc_rport.c
@@ -1738,6 +1738,11 @@ static void fc_rport_recv_prli_req(struc
 	 */
 	spp = &pp->spp;
 	mutex_lock(&fc_prov_mutex);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len >= plen) {
 		rdata->spp_type = rspp->spp_type;
 		spp->spp_type = rspp->spp_type;
@@ -1765,6 +1770,12 @@ static void fc_rport_recv_prli_req(struc
 		len -= plen;
 		rspp = (struct fc_els_spp *)((char *)rspp + plen);
 		spp = (struct fc_els_spp *)((char *)spp + plen);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+	}
 	}
 	mutex_unlock(&fc_prov_mutex);
 
diff -u -p a/scsi/libfc/fc_exch.c b/scsi/libfc/fc_exch.c
--- a/scsi/libfc/fc_exch.c
+++ b/scsi/libfc/fc_exch.c
@@ -743,10 +743,21 @@ static struct fc_exch *fc_exch_em_alloc(
 
 	index = pool->next_index;
 	/* allocate new exch from pool */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fc_exch_ptr_get(pool, index)) {
 		index = index == mp->pool_max_index ? 0 : index + 1;
 		if (index == pool->next_index)
 			goto err;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	pool->next_index = index == mp->pool_max_index ? 0 : index + 1;
 hit:
@@ -2483,9 +2494,20 @@ int fc_setup_exch_mgr(void)
 	 */
 	fc_cpu_mask = 1;
 	fc_cpu_order = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fc_cpu_mask < nr_cpu_ids) {
 		fc_cpu_mask <<= 1;
 		fc_cpu_order++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	fc_cpu_mask--;
 
diff -u -p a/scsi/mvsas/mv_sas.c b/scsi/mvsas/mv_sas.c
--- a/scsi/mvsas/mv_sas.c
+++ b/scsi/mvsas/mv_sas.c
@@ -1236,10 +1236,21 @@ static void mvs_port_notify_deformed(str
 	struct asd_sas_port *port = sas_phy->port;
 	int phy_no = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (phy != &mvi->phy[phy_no]) {
 		phy_no++;
 		if (phy_no >= MVS_MAX_PHYS)
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	list_for_each_entry(dev, &port->dev_list, dev_list_node)
 		mvs_do_release_task(phy->mvi, phy_no, dev);
@@ -2175,6 +2186,11 @@ int mvs_int_rx(struct mvs_info *mvi, boo
 	if (mvi->rx_cons == rx_prod_idx)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mvi->rx_cons != rx_prod_idx) {
 		/* increment our internal RX consumer pointer */
 		rx_prod_idx = (rx_prod_idx + 1) & (MVS_RX_RING_SZ - 1);
@@ -2190,6 +2206,12 @@ int mvs_int_rx(struct mvs_info *mvi, boo
 		} else if (rx_desc & RXQ_SLOT_RESET) {
 			mvs_slot_free(mvi, rx_desc);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (attn && self_clear)
diff -u -p a/scsi/ses.c b/scsi/ses.c
--- a/scsi/ses.c
+++ b/scsi/ses.c
@@ -468,6 +468,11 @@ static void ses_match_to_enclosure(struc
 		goto free;
 
 	desc = buf + 4;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (desc < buf + vpd_len) {
 		enum scsi_protocol proto = desc[0] >> 4;
 		u8 code_set = desc[0] & 0x0f;
@@ -488,6 +493,12 @@ static void ses_match_to_enclosure(struc
 				(u64)desc[11];
 
 		desc += len + 4;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (!efd.addr)
 		goto free;
diff -u -p a/scsi/scsi_netlink.c b/scsi/scsi_netlink.c
--- a/scsi/scsi_netlink.c
+++ b/scsi/scsi_netlink.c
@@ -85,6 +85,11 @@ scsi_nl_rcv_msg(struct sk_buff *skb)
 	u32 rlen;
 	int err, tport;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb->len >= NLMSG_SPACE(0)) {
 		err = 0;
 
@@ -147,6 +152,12 @@ next_msg:
 			netlink_ack(skb, nlh, err);
 
 		skb_pull(skb, rlen);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/ibmmca.c b/scsi/ibmmca.c
--- a/scsi/ibmmca.c
+++ b/scsi/ibmmca.c
@@ -1729,6 +1729,11 @@ static int ibmmca_queuecommand_lck(Scsi_
 	if (ldn >= MAX_LOG_DEV) {	/* on invalid ldn do special stuff */
 		if (ldn > MAX_LOG_DEV) {	/* dynamical remapping if ldn unassigned */
 			current_ldn = next_ldn(shpnt);	/* stop-value for one circle */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (ld(shpnt)[next_ldn(shpnt)].cmd) {	/* search for a occupied, but not in */
 				/* command-processing ldn. */
 				next_ldn(shpnt)++;
@@ -1745,6 +1750,12 @@ static int ibmmca_queuecommand_lck(Scsi_
 						done(cmd);
 					return 0;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			/* unmap non-processing ldn */
diff -u -p a/scsi/ibmvscsi/ibmvfc.c b/scsi/ibmvscsi/ibmvfc.c
--- a/scsi/ibmvscsi/ibmvfc.c
+++ b/scsi/ibmvscsi/ibmvfc.c
@@ -3144,6 +3144,11 @@ static void ibmvfc_tasklet(void *data)
 	int done = 0;
 
 	spin_lock_irqsave(vhost->host->host_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!done) {
 		/* Pull all the valid messages off the async CRQ */
 		while ((async = ibmvfc_next_async_crq(vhost)) != NULL) {
@@ -3172,6 +3177,12 @@ static void ibmvfc_tasklet(void *data)
 			wmb();
 		} else
 			done = 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	spin_unlock_irqrestore(vhost->host->host_lock, flags);
diff -u -p a/scsi/ibmvscsi/rpa_vscsi.c b/scsi/ibmvscsi/rpa_vscsi.c
--- a/scsi/ibmvscsi/rpa_vscsi.c
+++ b/scsi/ibmvscsi/rpa_vscsi.c
@@ -136,6 +136,11 @@ static void rpavscsi_task(void *data)
 	struct viosrp_crq *crq;
 	int done = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!done) {
 		/* Pull all the valid messages off the CRQ */
 		while ((crq = crq_queue_next_crq(&hostdata->queue)) != NULL) {
@@ -151,6 +156,12 @@ static void rpavscsi_task(void *data)
 		} else {
 			done = 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/ibmvscsi/ibmvscsi.c b/scsi/ibmvscsi/ibmvscsi.c
--- a/scsi/ibmvscsi/ibmvscsi.c
+++ b/scsi/ibmvscsi/ibmvscsi.c
@@ -478,6 +478,11 @@ static void purge_requests(struct ibmvsc
 	unsigned long flags;
 
 	spin_lock_irqsave(hostdata->host->host_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&hostdata->sent)) {
 		evt = list_first_entry(&hostdata->sent, struct srp_event_struct, list);
 		list_del(&evt->list);
@@ -494,6 +499,12 @@ static void purge_requests(struct ibmvsc
 			evt->done(evt);
 		free_event_struct(&evt->hostdata->pool, evt);
 		spin_lock_irqsave(hostdata->host->host_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
 }
diff -u -p a/scsi/ibmvscsi/ibmvstgt.c b/scsi/ibmvscsi/ibmvstgt.c
--- a/scsi/ibmvscsi/ibmvstgt.c
+++ b/scsi/ibmvscsi/ibmvstgt.c
@@ -702,6 +702,11 @@ static void handle_crq(struct work_struc
 	struct viosrp_crq *crq;
 	int done = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!done) {
 		while ((crq = next_crq(&vport->crq_queue)) != NULL) {
 			process_crq(crq, target);
@@ -717,6 +722,12 @@ static void handle_crq(struct work_struc
 			crq->valid = 0x00;
 		} else
 			done = 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	handle_cmd_queue(target);
diff -u -p a/scsi/qlogicpti.c b/scsi/qlogicpti.c
--- a/scsi/qlogicpti.c
+++ b/scsi/qlogicpti.c
@@ -1146,6 +1146,11 @@ static struct scsi_cmnd *qlogicpti_intr_
 
 	/* This looks like a network driver! */
 	out_ptr = qpti->res_out_ptr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (out_ptr != in_ptr) {
 		u_int cmd_slot;
 
@@ -1184,6 +1189,12 @@ static struct scsi_cmnd *qlogicpti_intr_
 		sbus_writew(out_ptr, qpti->qregs + MBOX5);
 		Cmnd->host_scribble = (unsigned char *) done_queue;
 		done_queue = Cmnd;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	qpti->res_out_ptr = out_ptr;
 
diff -u -p a/scsi/aha152x.c b/scsi/aha152x.c
--- a/scsi/aha152x.c
+++ b/scsi/aha152x.c
@@ -1222,6 +1222,11 @@ static void free_hard_reset_SCs(struct S
 	Scsi_Cmnd *ptr;
 
 	ptr=*SCs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ptr) {
 		Scsi_Cmnd *next;
 
@@ -1241,6 +1246,12 @@ static void free_hard_reset_SCs(struct S
 		}
 
 		ptr = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2480,6 +2491,11 @@ static void rsti_run(struct Scsi_Host *s
 	printk(KERN_NOTICE "aha152x%d: scsi reset in\n", HOSTNO);
 	
 	ptr=DISCONNECTED_SC;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ptr) {
 		Scsi_Cmnd *next = SCNEXT(ptr);
 
@@ -2494,6 +2510,12 @@ static void rsti_run(struct Scsi_Host *s
 		}
 
 		ptr = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if(CURRENT_SC && !CURRENT_SC->device->soft_reset)
@@ -3786,6 +3808,11 @@ static int __init aha152x_init(void)
 
 #ifdef __ISAPNP__
 	for(i=0; setup_count<ARRAY_SIZE(setup) && id_table[i].vendor; i++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ( setup_count<ARRAY_SIZE(setup) &&
 			(dev=pnp_find_dev(NULL, id_table[i].vendor, id_table[i].function, dev)) ) {
 			if (pnp_device_attach(dev) < 0)
@@ -3824,7 +3851,13 @@ static int __init aha152x_init(void)
 				"aha152x: found ISAPnP adapter at io=0x%03x, irq=%d\n",
 				setup[setup_count].io_port, setup[setup_count].irq);
 			setup_count++;
-		}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+}
 	}
 #endif
 
diff -u -p a/scsi/aha1740.c b/scsi/aha1740.c
--- a/scsi/aha1740.c
+++ b/scsi/aha1740.c
@@ -245,6 +245,11 @@ static irqreturn_t aha1740_intr_handle(i
 	number_serviced = 0;
 	edev = HOSTDATA(host)->edev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(inb(G2STAT(base)) & G2STAT_INTPEND) {
 		handled = 1;
 		DEB(printk("aha1740_intr top of loop.\n"));
@@ -325,6 +330,12 @@ static irqreturn_t aha1740_intr_handle(i
 			break;
 		}
 		number_serviced++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(host->host_lock, flags);
diff -u -p a/scsi/dpt_i2o.c b/scsi/dpt_i2o.c
--- a/scsi/dpt_i2o.c
+++ b/scsi/dpt_i2o.c
@@ -196,6 +196,11 @@ static int adpt_detect(struct scsi_host_
 	PINFO("Detecting Adaptec I2O RAID controllers...\n");
 
         /* search for all Adatpec I2O RAID cards */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((pDev = pci_get_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
 		if(pDev->device == PCI_DPT_DEVICE_ID ||
 		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
@@ -206,6 +211,12 @@ static int adpt_detect(struct scsi_host_
 			}
 			pci_dev_get(pDev);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* In INIT state, Activate IOPs */
@@ -622,6 +633,11 @@ static int adpt_proc_info(struct Scsi_Ho
 	for(chan = 0; chan < MAX_CHANNEL; chan++) {
 		for(id = 0; id < MAX_ID; id++) {
 			d = pHba->channel[chan].device[id];
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(d){
 				len += sprintf(buffer+len,"\t%-24.24s", d->pScsi_dev->vendor);
 				len += sprintf(buffer+len," Rev: %-8.8s\n", d->pScsi_dev->rev);
@@ -653,6 +669,12 @@ static int adpt_proc_info(struct Scsi_Ho
 				}
 
 				d = d->next_lun;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -1971,6 +1993,11 @@ cleanup:
 		struct sg_simple_element *sg =
 				(struct sg_simple_element*) (msg +sg_offset);
 		kfree (reply);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(sg_index) {
 			if(sg_list[--sg_index]) {
 				dma_free_coherent(&pHba->pDev->dev,
@@ -1978,6 +2005,12 @@ cleanup:
 					sg_list[sg_index],
 					sg[sg_index].addr_bus);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return rcode;
@@ -2221,6 +2254,11 @@ static irqreturn_t adpt_isr(int irq, voi
 	if(pHba->host)
 		spin_lock_irqsave(pHba->host->host_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while( readl(pHba->irq_mask) & I2O_INTERRUPT_PENDING_B) {
 		m = readl(pHba->reply_port);
 		if(m == EMPTY_QUEUE){
@@ -2295,6 +2333,12 @@ static irqreturn_t adpt_isr(int irq, voi
 		writel(m, pHba->reply_port);
 		wmb();
 		rmb();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	handled = 1;
 out:	if(pHba->host)
@@ -2688,8 +2732,19 @@ static s32 adpt_i2o_reparse_lct(adpt_hba
 					}
 					pHba->channel[bus_no].device[scsi_id] = pDev;
 				} else {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					while (pDev->next_lun) {
 						pDev = pDev->next_lun;
+						if (_cur < timeout) {
+					rdstcll(_cur);
+						}
+						else {
+					break;
+						}
 					}
 					pDev = pDev->next_lun =
 					  kzalloc(sizeof(struct adpt_device),
diff -u -p a/scsi/3w-xxxx.c b/scsi/3w-xxxx.c
--- a/scsi/3w-xxxx.c
+++ b/scsi/3w-xxxx.c
@@ -308,6 +308,11 @@ static int tw_poll_status(TW_Device_Exte
 	if (tw_check_bits(status_reg_value))
 		tw_decode_bits(tw_dev, status_reg_value, 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status_reg_value & flag) != flag) {
 		status_reg_value = inl(TW_STATUS_REG_ADDR(tw_dev));
 
@@ -318,6 +323,12 @@ static int tw_poll_status(TW_Device_Exte
 			goto out;
 
 		msleep(50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	retval = 0;
 out:
diff -u -p a/scsi/scsi_error.c b/scsi/scsi_error.c
--- a/scsi/scsi_error.c
+++ b/scsi/scsi_error.c
@@ -987,6 +987,11 @@ static int scsi_eh_test_devices(struct l
 	struct scsi_device *sdev;
 	int finish_cmds;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(cmd_list)) {
 		scmd = list_entry(cmd_list->next, struct scsi_cmnd, eh_entry);
 		sdev = scmd->device;
@@ -1003,6 +1008,12 @@ static int scsi_eh_test_devices(struct l
 				else
 					list_move_tail(&scmd->eh_entry, work_q);
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 	}
 	return list_empty(work_q);
 }
@@ -1203,6 +1214,11 @@ static int scsi_eh_target_reset(struct S
 
 	list_splice_init(work_q, &tmp_list);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&tmp_list)) {
 		struct scsi_cmnd *next, *scmd;
 		int rtn;
@@ -1232,6 +1248,12 @@ static int scsi_eh_target_reset(struct S
 				/* push back on work queue for further processing */
 				list_move(&scmd->eh_entry, work_q);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return scsi_eh_test_devices(&check_list, work_q, done_q, 0);
@@ -1815,6 +1837,11 @@ int scsi_error_handler(void *data)
 	 * disables signal delivery for the created thread.
 	 */
 	set_current_state(TASK_INTERRUPTIBLE);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		if ((shost->host_failed == 0 && shost->host_eh_scheduled == 0) ||
 		    shost->host_failed != shost->host_busy) {
@@ -1859,6 +1886,12 @@ int scsi_error_handler(void *data)
 		scsi_restart_operations(shost);
 		scsi_autopm_put_host(shost);
 		set_current_state(TASK_INTERRUPTIBLE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	__set_current_state(TASK_RUNNING);
 
diff -u -p a/scsi/arcmsr/arcmsr_hba.c b/scsi/arcmsr/arcmsr_hba.c
--- a/scsi/arcmsr/arcmsr_hba.c
+++ b/scsi/arcmsr/arcmsr_hba.c
@@ -2190,26 +2190,59 @@ static bool arcmsr_get_hbb_config(struct
 		return false;
 	}
 	count = 8;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count){
 		*acb_firm_model = readb(iop_firm_model);
 		acb_firm_model++;
 		iop_firm_model++;
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	count = 16;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count){
 		*acb_firm_version = readb(iop_firm_version);
 		acb_firm_version++;
 		iop_firm_version++;
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	count = 16;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(count){
 		*acb_device_map = readb(iop_device_map);
 		acb_device_map++;
 		iop_device_map++;
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
 	printk(KERN_NOTICE "Areca RAID Controller%d: F/W %s & Model %s\n",
@@ -2265,18 +2298,40 @@ static bool arcmsr_get_hbc_config(struct
 		return false;
 	}
 	count = 8;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		*acb_firm_model = readb(iop_firm_model);
 		acb_firm_model++;
 		iop_firm_model++;
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	count = 16;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		*acb_firm_version = readb(iop_firm_version);
 		acb_firm_version++;
 		iop_firm_version++;
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk(KERN_NOTICE "Areca RAID Controller%d: F/W %s & Model %s\n",
 		pACB->host->host_no,
diff -u -p a/scsi/bnx2fc/bnx2fc_hwi.c b/scsi/bnx2fc/bnx2fc_hwi.c
--- a/scsi/bnx2fc/bnx2fc_hwi.c
+++ b/scsi/bnx2fc/bnx2fc_hwi.c
@@ -1028,6 +1028,11 @@ int bnx2fc_process_new_cqes(struct bnx2f
 	cq_cons = tgt->cq_cons_idx;
 	cqe = &cq[cq_cons];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (((wqe = cqe->wqe) & FCOE_CQE_TOGGLE_BIT) ==
 	       (tgt->cq_curr_toggle_bit <<
 	       FCOE_CQE_TOGGLE_BIT_SHIFT)) {
@@ -1071,6 +1076,12 @@ unlock:
 			tgt->cq_curr_toggle_bit =
 				1 - tgt->cq_curr_toggle_bit;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (num_cqes) {
 		/* Arm CQ only if doorbell is mapped */
@@ -1322,6 +1333,11 @@ void bnx2fc_indicate_kcqe(void *context,
 	int i = 0;
 	struct fcoe_kcqe *kcqe = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < num_cqe) {
 		kcqe = (struct fcoe_kcqe *) kcq[i++];
 
@@ -1384,6 +1400,12 @@ void bnx2fc_indicate_kcqe(void *context,
 			printk(KERN_ERR PFX "unknown opcode 0x%x\n",
 								kcqe->op_code);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2068,6 +2090,11 @@ static int bnx2fc_allocate_hash_table(st
 	}
 	pbl = hba->hash_tbl_pbl;
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*pbl && *(pbl + 1)) {
 		u32 lo;
 		u32 hi;
@@ -2076,6 +2103,12 @@ static int bnx2fc_allocate_hash_table(st
 		hi = *pbl;
 		++pbl;
 		++i;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	kfree(dma_segment_array);
 	return 0;
diff -u -p a/scsi/bnx2fc/bnx2fc_io.c b/scsi/bnx2fc/bnx2fc_io.c
--- a/scsi/bnx2fc/bnx2fc_io.c
+++ b/scsi/bnx2fc/bnx2fc_io.c
@@ -1585,7 +1585,12 @@ static int bnx2fc_split_bd(struct bnx2fc
 	int frag_size, sg_frags;
 
 	sg_frags = 0;
-	while (sg_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (sg_len) {
 		if (sg_len >= BNX2FC_BD_SPLIT_SZ)
 			frag_size = BNX2FC_BD_SPLIT_SZ;
 		else
@@ -1598,6 +1603,12 @@ static int bnx2fc_split_bd(struct bnx2fc
 		addr += (u64) frag_size;
 		sg_frags++;
 		sg_len -= frag_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return sg_frags;
 
diff -u -p a/scsi/bnx2fc/bnx2fc_fcoe.c b/scsi/bnx2fc/bnx2fc_fcoe.c
--- a/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -461,6 +461,11 @@ static int bnx2fc_l2_rcv_thread(void *ar
 
 	set_user_nice(current, -20);
 	set_current_state(TASK_INTERRUPTIBLE);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		schedule();
 		spin_lock_bh(&bg->fcoe_rx_list.lock);
@@ -471,6 +476,12 @@ static int bnx2fc_l2_rcv_thread(void *ar
 		}
 		__set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock_bh(&bg->fcoe_rx_list.lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	__set_current_state(TASK_RUNNING);
 	return 0;
@@ -600,9 +611,19 @@ int bnx2fc_percpu_io_thread(void *arg)
 
 	set_user_nice(current, -20);
 	set_current_state(TASK_INTERRUPTIBLE);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		schedule();
 		spin_lock_bh(&p->fp_work_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!list_empty(&p->work_list)) {
 			list_splice_init(&p->work_list, &work_list);
 			spin_unlock_bh(&p->fp_work_lock);
@@ -614,9 +635,21 @@ int bnx2fc_percpu_io_thread(void *arg)
 			}
 
 			spin_lock_bh(&p->fp_work_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		__set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock_bh(&p->fp_work_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	__set_current_state(TASK_RUNNING);
 
diff -u -p a/scsi/device_handler/scsi_dh_alua.c b/scsi/device_handler/scsi_dh_alua.c
--- a/scsi/device_handler/scsi_dh_alua.c
+++ b/scsi/device_handler/scsi_dh_alua.c
@@ -375,6 +375,11 @@ static int alua_vpd_inquiry(struct scsi_
 	 * Now look for the correct descriptor.
 	 */
 	d = h->buff + 4;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (d < h->buff + len) {
 		switch (d[1] & 0xf) {
 		case 0x4:
@@ -389,6 +394,12 @@ static int alua_vpd_inquiry(struct scsi_
 			break;
 		}
 		d += d[3] + 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (h->group_id == -1) {
diff -u -p a/scsi/eata.c b/scsi/eata.c
--- a/scsi/eata.c
+++ b/scsi/eata.c
@@ -980,10 +980,21 @@ static int eata2x_slave_configure(struct
 
 static int wait_on_busy(unsigned long iobase, unsigned int loop)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (inb(iobase + REG_AUX_STATUS) & ABSY_ASSERTED) {
 		udelay(1L);
 		if (--loop == 0)
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
@@ -1015,10 +1026,21 @@ static int read_pio(unsigned long iobase
 	ushort *p;
 
 	for (p = start; p <= end; p++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(inb(iobase + REG_STATUS) & DRQ_ASSERTED)) {
 			udelay(1L);
 			if (--loop == 0)
 				return 1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 		loop = MAXLOOP;
 		*p = REG2H(inw(iobase));
@@ -1033,6 +1055,11 @@ static struct pci_dev *get_pci_dev(unsig
 	unsigned int addr;
 	struct pci_dev *dev = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {
 		addr = pci_resource_start(dev, 0);
 
@@ -1048,7 +1075,13 @@ static struct pci_dev *get_pci_dev(unsig
 		pci_dev_put(dev);
 		if (addr + PCI_BASE_ADDRESS_0 == port_base)
 			return dev;
-	}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+}
 #endif				/* end CONFIG_PCI */
 	return NULL;
 }
@@ -1058,6 +1091,11 @@ static void enable_pci_ports(void)
 #if defined(CONFIG_PCI)
 	struct pci_dev *dev = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {
 #if defined(DEBUG_PCI_DETECT)
 		printk("%s: enable_pci_ports, bus %d, devfn 0x%x.\n",
@@ -1068,7 +1106,13 @@ static void enable_pci_ports(void)
 			printk
 			    ("%s: warning, pci_enable_device failed, bus %d devfn 0x%x.\n",
 			     driver_name, dev->bus->number, dev->devfn);
-	}
+			    if (_cur < timeout) {
+			    	rdstcll(_cur);
+			    }
+			    else {
+			    	break;
+			    }
+}
 
 #endif				/* end CONFIG_PCI */
 }
@@ -1465,6 +1509,11 @@ static void internal_setup(char *str, in
 		setup_done = 1;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cur && (pc = strchr(cur, ':'))) {
 		int val = 0, c = *++pc;
 
@@ -1498,6 +1547,12 @@ static void internal_setup(char *str, in
 
 		if ((cur = strchr(cur, ',')))
 			++cur;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return;
diff -u -p a/scsi/3w-9xxx.c b/scsi/3w-9xxx.c
--- a/scsi/3w-9xxx.c
+++ b/scsi/3w-9xxx.c
@@ -1484,6 +1484,11 @@ static int twa_poll_status(TW_Device_Ext
 	if (twa_check_bits(status_reg_value))
 		twa_decode_bits(tw_dev, status_reg_value);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status_reg_value & flag) != flag) {
 		status_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));
 
@@ -1494,6 +1499,12 @@ static int twa_poll_status(TW_Device_Ext
 			goto out;
 
 		msleep(50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	retval = 0;
 out:
diff -u -p a/scsi/dc395x.c b/scsi/dc395x.c
--- a/scsi/dc395x.c
+++ b/scsi/dc395x.c
@@ -1596,10 +1596,21 @@ static u8 start_scsi(struct AdapterCtlBl
 		/* Send Tag message */
 		u32 tag_mask = 1;
 		u8 tag_number = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tag_mask & dcb->tag_mask
 		       && tag_number < dcb->max_command) {
 			tag_mask = tag_mask << 1;
 			tag_number++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		if (tag_number >= dcb->max_command) {
 			dprintkl(KERN_WARNING, "start_scsi: (0x%p) "
@@ -2271,6 +2282,11 @@ static void data_in_phase0(struct Adapte
 			if (srb->dcb->sync_period & WIDE_SYNC)
 				DC395x_write8(acb, TRM_S1040_SCSI_CONFIG2,
 					      CFG2_WIDEFIFO);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (left_io) {
 				unsigned char *virt, *base = NULL;
 				unsigned long flags = 0;
@@ -2325,6 +2341,12 @@ static void data_in_phase0(struct Adapte
 
 				scsi_kunmap_atomic_sg(base);
 				local_irq_restore(flags);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			/*printk(" %08x", *(u32*)(bus_to_virt (addr))); */
 			/*srb->total_xfer_length = 0; */
@@ -2489,6 +2511,11 @@ static void data_io_transfer(struct Adap
 				DC395x_write8(acb, TRM_S1040_SCSI_CONFIG2,
 				     CFG2_WIDEFIFO);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (left_io) {
 				unsigned char *virt, *base = NULL;
 				unsigned long flags = 0;
@@ -2514,6 +2541,12 @@ static void data_io_transfer(struct Adap
 
 				scsi_kunmap_atomic_sg(base);
 				local_irq_restore(flags);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if (srb->dcb->sync_period & WIDE_SYNC) {
 				if (ln % 2) {
diff -u -p a/scsi/tmscsim.c b/scsi/tmscsim.c
--- a/scsi/tmscsim.c
+++ b/scsi/tmscsim.c
@@ -376,11 +376,22 @@ static unsigned long inline dc390_advanc
 static struct dc390_dcb __inline__ *dc390_findDCB ( struct dc390_acb* pACB, u8 id, u8 lun)
 {
    struct dc390_dcb* pDCB = pACB->pLinkDCB; if (!pDCB) return NULL;
-   while (pDCB->TargetID != id || pDCB->TargetLUN != lun)
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+     unsigned long long timeout;
+     timeout = rdstcll(start) + delta;
+     while (pDCB->TargetID != id || pDCB->TargetLUN != lun)
      {
 	pDCB = pDCB->pNextDCB;
 	if (pDCB == pACB->pLinkDCB)
 	     return NULL;
+	     if (_cur < timeout) {
+	          rdstcll(_cur);
+	     }
+	     else {
+	          break;
+	     }
      }
    DCBDEBUG1( printk (KERN_DEBUG "DCB %p (%02x,%02x) found.\n",	\
 		      pDCB, pDCB->TargetID, pDCB->TargetLUN));
@@ -769,11 +780,23 @@ dc390_DataOut_0(struct dc390_acb* pACB,
 	    unsigned long timeout = jiffies + HZ;
 
 	    /* Function called from the ISR with the host_lock held and interrupts disabled */
-	    if (pSRB->SGToBeXferLen)
-		while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
-		    spin_unlock_irq(pACB->pScsiHost->host_lock);
-		    udelay(50);
-		    spin_lock_irq(pACB->pScsiHost->host_lock);
+	    if (pSRB->SGToBeXferLen) {
+		    unsigned long long delta = (cpu / khz / HZ) * 2;
+		    unsigned long long _start = 0;
+		    unsigned long long _cur = 0;
+		    unsigned long long timeout;
+		    timeout = rdstcll(start) + delta;
+		    while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
+		        spin_unlock_irq(pACB->pScsiHost->host_lock);
+		        udelay(50);
+		        spin_lock_irq(pACB->pScsiHost->host_lock);
+		        if (_cur < timeout) {
+		            rdstcll(_cur);
+		        }
+		        else {
+		            break;
+		        }
+		    }
 		}
 	    if (!time_before(jiffies, timeout))
 		printk (KERN_CRIT "DC390: Deadlock in DataOut_0: DMA aborted unfinished: %06x bytes remain!!\n",
@@ -828,11 +851,23 @@ dc390_DataIn_0(struct dc390_acb* pACB, s
 	    unsigned long timeout = jiffies + HZ;
 
 	    /* Function called from the ISR with the host_lock held and interrupts disabled */
-	    if (pSRB->SGToBeXferLen)
-		while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
-		    spin_unlock_irq(pACB->pScsiHost->host_lock);
-		    udelay(50);
-		    spin_lock_irq(pACB->pScsiHost->host_lock);
+	    if (pSRB->SGToBeXferLen) {
+		    unsigned long long delta = (cpu / khz / HZ) * 2;
+		    unsigned long long _start = 0;
+		    unsigned long long _cur = 0;
+		    unsigned long long timeout;
+		    timeout = rdstcll(start) + delta;
+		    while (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {
+			    spin_unlock_irq(pACB->pScsiHost->host_lock);
+			    udelay(50);
+			    spin_lock_irq(pACB->pScsiHost->host_lock);
+			    if (_cur < timeout) {
+			        rdstcll(_cur);
+			    }
+			    else {
+			        break;
+			    }
+		    }
 		}
 	    if (!time_before(jiffies, timeout)) {
 		printk (KERN_CRIT "DC390: Deadlock in DataIn_0: DMA aborted unfinished: %06x bytes remain!!\n",
@@ -863,6 +898,11 @@ dc390_DataIn_0(struct dc390_acb* pACB, s
 	{
 	    residual = 0;
 	    bval = DC390_read8 (Current_Fifo);
+	    unsigned long long delta = (cpu / khz / HZ) * 2;
+	    unsigned long long _start = 0;
+	    unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
 	    while( bval & 0x1f )
 	    {
 		DEBUG1(printk (KERN_DEBUG "Check for residuals,"));
@@ -882,7 +922,13 @@ dc390_DataIn_0(struct dc390_acb* pACB, s
 		}
 		else
 		    bval = DC390_read8 (Current_Fifo);
-	    }
+		    if (_cur < timeout) {
+		    rdstcll(_cur);
+		    }
+		    else {
+		    break;
+		}
+}
 din_1:
 	    DC390_write8 (DMA_Cmd, READ_DIRECTION+DMA_BLAST_CMD);
 	    for (i = 0xa000; i; i--)
@@ -1148,6 +1194,11 @@ dc390_restore_ptr (struct dc390_acb* pAC
 	psgl = pSRB->pSegmentList;
 	//dc390_pci_sync(pSRB);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pSRB->TotalXferredLen + (unsigned long) sg_dma_len(psgl) < pSRB->Saved_Ptr)
 	{
 	    pSRB->TotalXferredLen += (unsigned long) sg_dma_len(psgl);
@@ -1160,6 +1211,12 @@ dc390_restore_ptr (struct dc390_acb* pAC
 	    }
 	    else
 		pSRB->SGToBeXferLen = 0;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	saved = pSRB->Saved_Ptr - pSRB->TotalXferredLen;
diff -u -p a/scsi/gdth.c b/scsi/gdth.c
--- a/scsi/gdth.c
+++ b/scsi/gdth.c
@@ -2011,9 +2011,20 @@ static void gdth_putq(gdth_ha_str *ha, S
         pscp = ha->req_first;
         nscp = (Scsi_Cmnd *)pscp->SCp.ptr;
         /* priority: 0-highest,..,0xff-lowest */
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
         while (nscp && gdth_cmnd_priv(nscp)->priority <= priority) {
             pscp = nscp;
             nscp = (Scsi_Cmnd *)pscp->SCp.ptr;
+            if (_cur < timeout) {
+                rdstcll(_cur);
+            }
+            else {
+                break;
+            }
         }
         pscp->SCp.ptr = (char *)scp;
         scp->SCp.ptr  = (char *)nscp;
diff -u -p a/scsi/mpt2sas/mpt2sas_config.c b/scsi/mpt2sas/mpt2sas_config.c
--- a/scsi/mpt2sas/mpt2sas_config.c
+++ b/scsi/mpt2sas/mpt2sas_config.c
@@ -1382,7 +1382,12 @@ mpt2sas_config_get_volume_handle(struct
 		goto out;
 	}
 	config_num = 0xff;
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		mpi_request.PageAddress = cpu_to_le32(config_num +
 		    MPI2_RAID_PGAD_FORM_GET_NEXT_CONFIGNUM);
 		r = _config_request(ioc, &mpi_request, &mpi_reply,
@@ -1421,6 +1426,12 @@ mpt2sas_config_get_volume_handle(struct
 			}
 		}
 		config_num = config_page->ConfigNum;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
  out:
 	kfree(config_page);
diff -u -p a/scsi/mpt2sas/mpt2sas_scsih.c b/scsi/mpt2sas/mpt2sas_scsih.c
--- a/scsi/mpt2sas/mpt2sas_scsih.c
+++ b/scsi/mpt2sas/mpt2sas_scsih.c
@@ -1084,7 +1084,12 @@ _scsih_build_scatter_gather(struct MPT2S
 	    (sges_in_segment * ioc->sge_size))/4;
 
 	/* fill in main message segment when there is a chain following */
-	while (sges_in_segment) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sges_in_segment) {
 		if (sges_in_segment == 1)
 			ioc->base_add_sg_single(sg_local,
 			    sgl_flags_last_element | sg_dma_len(sg_scmd),
@@ -1096,6 +1101,12 @@ _scsih_build_scatter_gather(struct MPT2S
 		sg_local += ioc->sge_size;
 		sges_left--;
 		sges_in_segment--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* initializing the chain flags and pointers */
@@ -1124,7 +1135,12 @@ _scsih_build_scatter_gather(struct MPT2S
 			goto fill_in_last_segment;
 
 		/* fill in chain segments */
-		while (sges_in_segment) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (sges_in_segment) {
 			if (sges_in_segment == 1)
 				ioc->base_add_sg_single(sg_local,
 				    sgl_flags_last_element |
@@ -1138,6 +1154,12 @@ _scsih_build_scatter_gather(struct MPT2S
 			sg_local += ioc->sge_size;
 			sges_left--;
 			sges_in_segment--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		chain_req = _scsih_get_chain_buffer_tracker(ioc, smid);
@@ -1151,7 +1173,12 @@ _scsih_build_scatter_gather(struct MPT2S
  fill_in_last_segment:
 
 	/* fill the last segment */
-	while (sges_left) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (sges_left) {
 		if (sges_left == 1)
 			ioc->base_add_sg_single(sg_local, sgl_flags_end_buffer |
 			    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));
@@ -1161,6 +1188,12 @@ _scsih_build_scatter_gather(struct MPT2S
 		sg_scmd = sg_next(sg_scmd);
 		sg_local += ioc->sge_size;
 		sges_left--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/scsi/hpsa.c b/scsi/hpsa.c
--- a/scsi/hpsa.c
+++ b/scsi/hpsa.c
@@ -888,6 +888,11 @@ static void adjust_hpsa_scsi_table(struc
 	i = 0;
 	nremoved = 0;
 	nadded = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < h->ndevices) {
 		csd = h->dev[i];
 		device_change = hpsa_scsi_find_entry(csd, sd, nsds, &entry);
@@ -906,6 +911,12 @@ static void adjust_hpsa_scsi_table(struc
 			sd[entry] = NULL;
 		}
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Now, make sure every device listed in sd[] is also
@@ -2759,6 +2770,11 @@ static int hpsa_big_passthru_ioctl(struc
 	}
 	left = ioc->buf_size;
 	data_ptr = ioc->buf;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (left) {
 		sz = (left > ioc->malloc_size) ? ioc->malloc_size : left;
 		buff_size[sg_used] = sz;
@@ -2777,6 +2793,12 @@ static int hpsa_big_passthru_ioctl(struc
 		left -= sz;
 		data_ptr += sz;
 		sg_used++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	c = cmd_special_alloc(h);
 	if (c == NULL) {
@@ -3172,10 +3194,21 @@ static irqreturn_t hpsa_intx_discard_com
 		return IRQ_NONE;
 	spin_lock_irqsave(&h->lock, flags);
 	h->last_intr_timestamp = get_jiffies_64();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
 		while (raw_tag != FIFO_EMPTY)
 			raw_tag = next_command(h);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	spin_unlock_irqrestore(&h->lock, flags);
 	return IRQ_HANDLED;
@@ -3209,6 +3242,11 @@ static irqreturn_t do_hpsa_intr_intx(int
 		return IRQ_NONE;
 	spin_lock_irqsave(&h->lock, flags);
 	h->last_intr_timestamp = get_jiffies_64();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
 		while (raw_tag != FIFO_EMPTY) {
@@ -3217,6 +3255,12 @@ static irqreturn_t do_hpsa_intr_intx(int
 			else
 				raw_tag = process_nonindexed_cmd(h, raw_tag);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	spin_unlock_irqrestore(&h->lock, flags);
 	return IRQ_HANDLED;
@@ -4195,10 +4239,21 @@ static void fail_all_cmds_on_list(struct
 
 	assert_spin_locked(&h->lock);
 	/* Mark all outstanding commands as failed and complete them. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(list)) {
 		c = list_entry(list->next, struct CommandList, list);
 		c->err_info->CommandStatus = CMD_HARDWARE_ERR;
 		finish_cmd(c, c->Header.Tag.lower);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/aacraid/sa.c b/scsi/aacraid/sa.c
--- a/scsi/aacraid/sa.c
+++ b/scsi/aacraid/sa.c
@@ -351,7 +351,12 @@ int aac_sa_init(struct aac_dev *dev)
 	/*
 	 *	Wait for the adapter to be up and running. Wait up to 3 minutes.
 	 */
-	while (!(sa_readl(dev, Mailbox7) & KERNEL_UP_AND_RUNNING)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!(sa_readl(dev, Mailbox7) & KERNEL_UP_AND_RUNNING)) {
 		if (time_after(jiffies, start+startup_timeout*HZ)) {
 			status = sa_readl(dev, Mailbox7);
 			printk(KERN_WARNING "%s%d: adapter kernel failed to start, init status = %lx.\n", 
@@ -359,6 +364,12 @@ int aac_sa_init(struct aac_dev *dev)
 			goto error_iounmap;
 		}
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/scsi/aacraid/rx.c b/scsi/aacraid/rx.c
--- a/scsi/aacraid/rx.c
+++ b/scsi/aacraid/rx.c
@@ -598,6 +598,11 @@ int _aac_rx_init(struct aac_dev *dev)
 	/*
 	 *	Wait for the adapter to be up and running. Wait up to 3 minutes
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((status = rx_readl(dev, MUnit.OMRx[0])) & KERNEL_UP_AND_RUNNING))
 	{
 		if ((restart &&
@@ -618,6 +623,12 @@ int _aac_rx_init(struct aac_dev *dev)
 			++restart;
 		}
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (restart && aac_commit)
 		aac_commit = 1;
diff -u -p a/scsi/aacraid/dpcsup.c b/scsi/aacraid/dpcsup.c
--- a/scsi/aacraid/dpcsup.c
+++ b/scsi/aacraid/dpcsup.c
@@ -67,6 +67,11 @@ unsigned int aac_response_normal(struct
 	 *	back to the system. If no response was requesed we just
 	 *	deallocate the Fib here and continue.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(aac_consumer_get(dev, q, &entry))
 	{
 		int fast;
@@ -147,6 +152,12 @@ unsigned int aac_response_normal(struct
 		}
 		consumed++;
 		spin_lock_irqsave(q->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (consumed > aac_config.peak_fibs)
@@ -182,6 +193,11 @@ unsigned int aac_command_normal(struct a
 	 *	up the waiters until there are no more QEs. We then return
 	 *	back to the system.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(aac_consumer_get(dev, q, &entry))
 	{
 		struct fib fibctx;
@@ -224,6 +240,12 @@ unsigned int aac_command_normal(struct a
 			aac_fib_adapter_complete(fib, sizeof(u32));
 			spin_lock_irqsave(q->lock, flags);
 		}		
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(q->lock, flags);
 	return 0;
diff -u -p a/scsi/aacraid/src.c b/scsi/aacraid/src.c
--- a/scsi/aacraid/src.c
+++ b/scsi/aacraid/src.c
@@ -514,6 +514,11 @@ int aac_src_init(struct aac_dev *dev)
 	/*
 	 *	Wait for the adapter to be up and running. Wait up to 3 minutes
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((status = src_readl(dev, MUnit.OMR)) &
 		KERNEL_UP_AND_RUNNING)) {
 		if ((restart &&
@@ -535,6 +540,12 @@ int aac_src_init(struct aac_dev *dev)
 			++restart;
 		}
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (restart && aac_commit)
 		aac_commit = 1;
diff -u -p a/scsi/aacraid/commctrl.c b/scsi/aacraid/commctrl.c
--- a/scsi/aacraid/commctrl.c
+++ b/scsi/aacraid/commctrl.c
@@ -207,6 +207,11 @@ static int open_getadapter_fib(struct aa
 		spin_lock_irqsave(&dev->fib_lock, flags);
 		/* Ensure that we have a unique identifier */
 		entry = dev->fib_list.next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (entry != &dev->fib_list) {
 			context = list_entry(entry, struct aac_fib_context, next);
 			if (context->unique == fibctx->unique) {
@@ -216,6 +221,12 @@ static int open_getadapter_fib(struct aa
 			} else {
 				entry = entry->next;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		list_add_tail(&fibctx->next, &dev->fib_list);
 		spin_unlock_irqrestore(&dev->fib_lock, flags);
@@ -344,6 +355,11 @@ int aac_close_fib_context(struct aac_dev
 	/*
 	 *	First free any FIBs that have not been consumed.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&fibctx->fib_list)) {
 		struct list_head * entry;
 		/*
@@ -358,6 +374,12 @@ int aac_close_fib_context(struct aac_dev
 		 */
 		kfree(fib->hw_fib_va);
 		kfree(fib);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 *	Remove the Context from the AdapterFibContext List
diff -u -p a/scsi/libsas/sas_scsi_host.c b/scsi/libsas/sas_scsi_host.c
--- a/scsi/libsas/sas_scsi_host.c
+++ b/scsi/libsas/sas_scsi_host.c
@@ -872,6 +872,11 @@ static void sas_queue(struct sas_ha_stru
 	struct sas_internal *i = to_sas_internal(core->shost->transportt);
 
 	spin_lock_irqsave(&core->task_queue_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop() &&
 	       !list_empty(&core->task_queue)) {
 
@@ -907,6 +912,12 @@ static void sas_queue(struct sas_ha_stru
 			list_splice_init(&q, &core->task_queue); /*at head*/
 			core->task_queue_size += can_queue;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&core->task_queue_lock, flags);
 }
diff -u -p a/scsi/mesh.c b/scsi/mesh.c
--- a/scsi/mesh.c
+++ b/scsi/mesh.c
@@ -565,6 +565,11 @@ static void mesh_start(struct mesh_state
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ms->phase == idle) {
 		prev = NULL;
 		for (cmd = ms->request_q; ; cmd = (struct scsi_cmnd *) cmd->host_scribble) {
@@ -583,6 +588,12 @@ static void mesh_start(struct mesh_state
 			ms->request_qtail = prev;
 
 		mesh_start_cmd(ms, cmd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1770,10 +1781,21 @@ static int mesh_suspend(struct macio_dev
 
 	scsi_block_requests(ms->host);
 	spin_lock_irqsave(ms->host->host_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(ms->phase != idle) {
 		spin_unlock_irqrestore(ms->host->host_lock, flags);
 		msleep(10);
 		spin_lock_irqsave(ms->host->host_lock, flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	ms->phase = sleeping;
 	spin_unlock_irqrestore(ms->host->host_lock, flags);
diff -u -p a/scsi/mvumi.c b/scsi/mvumi.c
--- a/scsi/mvumi.c
+++ b/scsi/mvumi.c
@@ -370,12 +370,23 @@ static void mvumi_free_cmds(struct mvumi
 {
 	struct mvumi_cmd *cmd;
 
-	while (!list_empty(&mhba->cmd_pool)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->cmd_pool)) {
 		cmd = list_first_entry(&mhba->cmd_pool, struct mvumi_cmd,
 							queue_pointer);
 		list_del(&cmd->queue_pointer);
 		kfree(cmd->frame);
 		kfree(cmd);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -405,12 +416,23 @@ static int mvumi_alloc_cmds(struct mvumi
 err_exit:
 	dev_err(&mhba->pdev->dev,
 			"failed to allocate memory for cmd[0x%x].\n", i);
-	while (!list_empty(&mhba->cmd_pool)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->cmd_pool)) {
 		cmd = list_first_entry(&mhba->cmd_pool, struct mvumi_cmd,
 						queue_pointer);
 		list_del(&cmd->queue_pointer);
 		kfree(cmd->frame);
 		kfree(cmd);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return -ENOMEM;
 }
@@ -1291,7 +1313,12 @@ static void mvumi_handle_clob(struct mvu
 	struct mvumi_cmd *cmd;
 	struct mvumi_ob_data *pool;
 
-	while (!list_empty(&mhba->free_ob_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->free_ob_list)) {
 		pool = list_first_entry(&mhba->free_ob_list,
 						struct mvumi_ob_data, list);
 		list_del_init(&pool->list);
@@ -1307,6 +1334,12 @@ static void mvumi_handle_clob(struct mvu
 			mvumi_complete_cmd(mhba, cmd, ob_frame);
 		else
 			mvumi_complete_internal_cmd(mhba, cmd, ob_frame);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	mhba->instancet->fire_cmd(mhba, NULL);
 }
@@ -1379,7 +1412,12 @@ static void mvumi_fire_cmd(struct mvumi_
 	if (cmd)
 		list_add_tail(&cmd->queue_pointer, &mhba->waiting_req_list);
 
-	while (!list_empty(&mhba->waiting_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mhba->waiting_req_list)) {
 		cmd = list_first_entry(&mhba->waiting_req_list,
 					 struct mvumi_cmd, queue_pointer);
 		list_del_init(&cmd->queue_pointer);
@@ -1395,6 +1433,12 @@ static void mvumi_fire_cmd(struct mvumi_
 
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (num_of_cl_sent > 0)
 		mvumi_send_ib_list_entry(mhba);
diff -u -p a/scsi/pcmcia/sym53c500_cs.c b/scsi/pcmcia/sym53c500_cs.c
--- a/scsi/pcmcia/sym53c500_cs.c
+++ b/scsi/pcmcia/sym53c500_cs.c
@@ -248,6 +248,11 @@ SYM53C500_pio_read(int fast_pio, int bas
 	int len;	/* current scsi fifo size */
 
 	REG1(base);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reqlen) {
 		i = inb(base + PIO_STATUS);
 		/* VDEB(printk("pio_status=%x\n", i)); */
@@ -292,6 +297,12 @@ SYM53C500_pio_read(int fast_pio, int bas
 				}
 			} 
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -303,6 +314,11 @@ SYM53C500_pio_write(int fast_pio, int ba
 	int len;	/* current scsi fifo size */
 
 	REG1(base);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reqlen && !(i & 0x40)) {
 		i = inb(base + PIO_STATUS);
 		/* VDEB(printk("pio_status=%x\n", i)); */
@@ -343,6 +359,12 @@ SYM53C500_pio_write(int fast_pio, int ba
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/scsi/pm8001/pm8001_sas.c b/scsi/pm8001/pm8001_sas.c
--- a/scsi/pm8001/pm8001_sas.c
+++ b/scsi/pm8001/pm8001_sas.c
@@ -309,11 +309,22 @@ static int sas_find_local_port_id(struct
 	/* Directly attached device */
 	if (!pdev)
 		return dev->port->id;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pdev) {
 		struct domain_device *pdev_p = pdev->parent;
 		if (!pdev_p)
 			return pdev->port->id;
 		pdev = pdev->parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/scsi/osst.c b/scsi/osst.c
--- a/scsi/osst.c
+++ b/scsi/osst.c
@@ -1907,6 +1907,11 @@ static int osst_space_over_filemarks_bac
 #endif
 	}
 	cnt = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt != mt_count) {
 		last_mark_ppos = ntohl(STp->buffer->aux->last_mark_ppos);
 		if (last_mark_ppos == -1)
@@ -1927,7 +1932,13 @@ static int osst_space_over_filemarks_bac
 					 name, last_mark_ppos);
 			return (-EIO);
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 found:
 	if (mt_op == MTBSFM) {
 		STp->frame_seq_number++;
@@ -2107,6 +2118,11 @@ static int osst_space_over_filemarks_for
 			}
 		}
 		cnt++;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (cnt != mt_count) {
 			next_mark_ppos = ntohl(STp->buffer->aux->next_mark_ppos);
 			if (!next_mark_ppos || next_mark_ppos > STp->eod_frame_ppos) {
@@ -2132,6 +2148,12 @@ static int osst_space_over_filemarks_for
 						 name, next_mark_ppos);
 				return (-EIO);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (mt_op == MTFSF) {
@@ -3566,6 +3588,11 @@ if (SRpnt) printk(KERN_ERR "%s:A: Not su
 				STp->logical_blk_num, STp->frame_seq_number, STp->first_frame_position);
 #endif
 	b_point = buf;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((STp->buffer)->buffer_bytes + count > write_threshold)
 	{
 		doing_write = 1;
@@ -3634,6 +3661,12 @@ if (SRpnt) printk(KERN_ERR "%s:A: Not su
 		}
 		STp->buffer->buffer_bytes = 0;
 		STp->dirty = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}  /* end while write threshold exceeded */
 
 	if (count != 0) {
diff -u -p a/scsi/NCR_Q720.c b/scsi/NCR_Q720.c
--- a/scsi/NCR_Q720.c
+++ b/scsi/NCR_Q720.c
@@ -67,9 +67,20 @@ NCR_Q720_intr(int irq, void *data)
 		return IRQ_NONE;
 
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while((siop = ffz(sir)) < p->siops) {
 		sir |= 1<<siop;
 		ncr53c8xx_intr(irq, p->hosts[siop]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return IRQ_HANDLED;
 }
diff -u -p a/scsi/NCR53c406a.c b/scsi/NCR53c406a.c
--- a/scsi/NCR53c406a.c
+++ b/scsi/NCR53c406a.c
@@ -349,6 +349,11 @@ static __inline__ int NCR53c406a_pio_rea
 	int len;		/* current scsi fifo size */
 
 	REG1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reqlen) {
 		i = inb(PIO_STATUS);
 		/*    VDEB(printk("pio_status=%x\n", i)); */
@@ -393,6 +398,12 @@ static __inline__ int NCR53c406a_pio_rea
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -403,6 +414,11 @@ static __inline__ int NCR53c406a_pio_wri
 	int len;		/* current scsi fifo size */
 
 	REG1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reqlen && !(i & 0x40)) {
 		i = inb(PIO_STATUS);
 		/*    VDEB(printk("pio_status=%x\n", i)); */
@@ -443,6 +459,12 @@ static __inline__ int NCR53c406a_pio_wri
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/scsi/be2iscsi/be_cmds.c b/scsi/be2iscsi/be_cmds.c
--- a/scsi/be2iscsi/be_cmds.c
+++ b/scsi/be2iscsi/be_cmds.c
@@ -269,6 +269,11 @@ int beiscsi_process_mcc(struct beiscsi_h
 	struct be_ctrl_info *ctrl = &phba->ctrl;
 
 	spin_lock_bh(&phba->ctrl.mcc_cq_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((compl = be_mcc_compl_get(phba))) {
 		if (compl->flags & CQE_FLAGS_ASYNC_MASK) {
 			/* Interpret flags as an async trailer */
@@ -287,6 +292,12 @@ int beiscsi_process_mcc(struct beiscsi_h
 		}
 		be_mcc_compl_use(compl);
 		num++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (num)
diff -u -p a/scsi/be2iscsi/be_main.c b/scsi/be2iscsi/be_main.c
--- a/scsi/be2iscsi/be_main.c
+++ b/scsi/be2iscsi/be_main.c
@@ -627,7 +627,12 @@ static irqreturn_t be_isr_mcc(int irq, v
 
 	num_eq_processed = 0;
 
-	while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 				& EQE_VALID_MASK) {
 		if (((eqe->dw[offsetof(struct amap_eq_entry,
 		     resource_id) / 32] &
@@ -640,6 +645,12 @@ static irqreturn_t be_isr_mcc(int irq, v
 		queue_tail_inc(eq);
 		eqe = queue_tail_node(eq);
 		num_eq_processed++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (phba->todo_mcc_cq)
 		queue_work(phba->wq, &phba->work_cqs);
@@ -674,7 +685,12 @@ static irqreturn_t be_isr_msix(int irq,
 	phba = pbe_eq->phba;
 	num_eq_processed = 0;
 	if (blk_iopoll_enabled) {
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 					& EQE_VALID_MASK) {
 			if (!blk_iopoll_sched_prep(&pbe_eq->iopoll))
 				blk_iopoll_sched(&pbe_eq->iopoll);
@@ -683,13 +699,24 @@ static irqreturn_t be_isr_msix(int irq,
 			queue_tail_inc(eq);
 			eqe = queue_tail_node(eq);
 			num_eq_processed++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (num_eq_processed)
 			hwi_ring_eq_db(phba, eq->id, 1,	num_eq_processed, 0, 1);
 
 		return IRQ_HANDLED;
 	} else {
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 						& EQE_VALID_MASK) {
 			spin_lock_irqsave(&phba->isr_lock, flags);
 			phba->todo_cq = 1;
@@ -698,6 +725,12 @@ static irqreturn_t be_isr_msix(int irq,
 			queue_tail_inc(eq);
 			eqe = queue_tail_node(eq);
 			num_eq_processed++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if (phba->todo_cq)
 			queue_work(phba->wq, &phba->work_cqs);
@@ -750,7 +783,12 @@ static irqreturn_t be_isr(int irq, void
 	num_ioeq_processed = 0;
 	num_mcceq_processed = 0;
 	if (blk_iopoll_enabled) {
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 					& EQE_VALID_MASK) {
 			if (((eqe->dw[offsetof(struct amap_eq_entry,
 			     resource_id) / 32] &
@@ -767,6 +805,12 @@ static irqreturn_t be_isr(int irq, void
 			AMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);
 			queue_tail_inc(eq);
 			eqe = queue_tail_node(eq);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (num_ioeq_processed || num_mcceq_processed) {
 			if (phba->todo_mcc_cq)
@@ -786,7 +830,12 @@ static irqreturn_t be_isr(int irq, void
 			return IRQ_NONE;
 	} else {
 		cq = &phwi_context->be_cq[0];
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 						& EQE_VALID_MASK) {
 
 			if (((eqe->dw[offsetof(struct amap_eq_entry,
@@ -804,6 +853,12 @@ static irqreturn_t be_isr(int irq, void
 			queue_tail_inc(eq);
 			eqe = queue_tail_node(eq);
 			num_ioeq_processed++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (phba->todo_cq || phba->todo_mcc_cq)
 			queue_work(phba->wq, &phba->work_cqs);
@@ -1459,7 +1514,12 @@ hwi_update_async_writables(struct hwi_as
 		num_entries = pasync_ctx->async_data.num_entries;
 	}
 
-	while ((*pep_read_ptr) != cq_index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((*pep_read_ptr) != cq_index) {
 		(*pep_read_ptr)++;
 		*pep_read_ptr = (*pep_read_ptr) % num_entries;
 
@@ -1477,6 +1537,12 @@ hwi_update_async_writables(struct hwi_as
 		}
 
 		writables++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!writables) {
@@ -1783,7 +1849,12 @@ static void  beiscsi_process_mcc_isr(str
 	mcc_cq = &phba->ctrl.mcc_obj.cq;
 	mcc_compl = queue_tail_node(mcc_cq);
 	mcc_compl->flags = le32_to_cpu(mcc_compl->flags);
-	while (mcc_compl->flags & CQE_FLAGS_VALID_MASK) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (mcc_compl->flags & CQE_FLAGS_VALID_MASK) {
 
 		if (num_processed >= 32) {
 			hwi_ring_cq_db(phba, mcc_cq->id,
@@ -1810,6 +1881,12 @@ static void  beiscsi_process_mcc_isr(str
 		mcc_compl = queue_tail_node(mcc_cq);
 		mcc_compl->flags = le32_to_cpu(mcc_compl->flags);
 		num_processed++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (num_processed > 0)
@@ -1833,6 +1910,11 @@ static unsigned int beiscsi_process_cq(s
 	sol = queue_tail_node(cq);
 	phba = pbe_eq->phba;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sol->dw[offsetof(struct amap_sol_cqe, valid) / 32] &
 	       CQE_VALID_MASK) {
 		be_dws_le_to_cpu(sol, sizeof(struct sol_cqe));
@@ -1949,6 +2031,12 @@ static unsigned int beiscsi_process_cq(s
 		queue_tail_inc(cq);
 		sol = queue_tail_node(cq);
 		num_processed++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (num_processed > 0) {
@@ -2295,6 +2383,11 @@ static int beiscsi_alloc_mem(struct beis
 	return 0;
 free_mem:
 	mem_descr->num_elements = j;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((i) || (j)) {
 		for (j = mem_descr->num_elements; j > 0; j--) {
 			pci_free_consistent(phba->pcidev,
@@ -2310,6 +2403,12 @@ free_mem:
 			kfree(mem_descr->mem_array);
 			mem_descr--;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(mem_arr_orig);
 	kfree(phba->init_mem);
@@ -3330,6 +3429,11 @@ static int beiscsi_init_sgl_handle(struc
 
 	arr_index = 0;
 	idx = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (idx < mem_descr_sglh->num_elements) {
 		psgl_handle = mem_descr_sglh->mem_array[idx].virtual_address;
 
@@ -3349,6 +3453,12 @@ static int beiscsi_init_sgl_handle(struc
 			psgl_handle++;
 		}
 		idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	SE_DEBUG(DBG_LVL_8,
 		 "phba->io_sgl_hndl_avbl=%d"
@@ -3361,6 +3471,11 @@ static int beiscsi_init_sgl_handle(struc
 		 mem_descr_sg->num_elements);
 	arr_index = 0;
 	idx = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (idx < mem_descr_sg->num_elements) {
 		pfrag = mem_descr_sg->mem_array[idx].virtual_address;
 
@@ -3381,6 +3496,12 @@ static int beiscsi_init_sgl_handle(struc
 				phba->fw_config.iscsi_icd_start + arr_index++;
 		}
 		idx++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	phba->io_sgl_free_index = 0;
 	phba->io_sgl_alloc_index = 0;
@@ -3665,12 +3786,23 @@ static void hwi_purge_eq(struct beiscsi_
 		eq = &phwi_context->be_eq[i].q;
 		eqe = queue_tail_node(eq);
 		num_processed = 0;
-		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 					& EQE_VALID_MASK) {
 			AMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);
 			queue_tail_inc(eq);
 			eqe = queue_tail_node(eq);
 			num_processed++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 
 		if (num_processed)
diff -u -p a/scsi/libiscsi.c b/scsi/libiscsi.c
--- a/scsi/libiscsi.c
+++ b/scsi/libiscsi.c
@@ -1461,7 +1461,12 @@ static int iscsi_data_xmit(struct iscsi_
 	 * overflow us with nop-ins
 	 */
 check_mgmt:
-	while (!list_empty(&conn->mgmtqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&conn->mgmtqueue)) {
 		conn->task = list_entry(conn->mgmtqueue.next,
 					 struct iscsi_task, running);
 		list_del_init(&conn->task->running);
@@ -1473,10 +1478,21 @@ check_mgmt:
 		rc = iscsi_xmit_task(conn);
 		if (rc)
 			goto done;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	/* process pending command queue */
-	while (!list_empty(&conn->cmdqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&conn->cmdqueue)) {
 		conn->task = list_entry(conn->cmdqueue.next, struct iscsi_task,
 					running);
 		list_del_init(&conn->task->running);
@@ -1505,6 +1521,12 @@ check_mgmt:
 		 */
 		if (!list_empty(&conn->mgmtqueue))
 			goto check_mgmt;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	while (!list_empty(&conn->requeue)) {
diff -u -p a/scsi/aic94xx/aic94xx_sds.c b/scsi/aic94xx/aic94xx_sds.c
--- a/scsi/aic94xx/aic94xx_sds.c
+++ b/scsi/aic94xx/aic94xx_sds.c
@@ -1280,6 +1280,11 @@ int asd_erase_nv_sector(struct asd_ha_st
 	 * Erasing an flash sector needs to be done in six consecutive
 	 * write cyles.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sector_addr < flash_addr+size) {
 		switch (asd_ha->hw_prof.flash.method) {
 		case FLASH_METHOD_A:
@@ -1306,6 +1311,12 @@ int asd_erase_nv_sector(struct asd_ha_st
 			return FAIL_ERASE_FLASH;
 
 		sector_addr += FLASH_SECTOR_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/scsi/aic7xxx/aic79xx_osm.c b/scsi/aic7xxx/aic79xx_osm.c
--- a/scsi/aic7xxx/aic79xx_osm.c
+++ b/scsi/aic7xxx/aic79xx_osm.c
@@ -1080,6 +1080,11 @@ ahd_parse_brace_option(char *opt_name, c
 	tok_end = strchr(opt_arg, '\0');
 	if (tok_end < end)
 		*tok_end = ',';
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!done) {
 		switch (*opt_arg) {
 		case '{':
@@ -1129,6 +1134,12 @@ ahd_parse_brace_option(char *opt_name, c
 			opt_arg = tok_end;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (opt_arg);
 }
diff -u -p a/scsi/aic7xxx/aic7xxx_core.c b/scsi/aic7xxx/aic7xxx_core.c
--- a/scsi/aic7xxx/aic7xxx_core.c
+++ b/scsi/aic7xxx/aic7xxx_core.c
@@ -5901,7 +5901,12 @@ ahc_search_qinfifo(struct ahc_softc *ahc
 	ahc->qinfifonext = qinpos;
 	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);
 
-	while (qinpos != qintail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (qinpos != qintail) {
 		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinpos]);
 		if (scb == NULL) {
 			printk("qinpos = %d, SCB index = %d\n",
@@ -5944,6 +5949,12 @@ ahc_search_qinfifo(struct ahc_softc *ahc
 			prev_scb = scb;
 		}
 		qinpos++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
@@ -6968,6 +6979,11 @@ ahc_check_patch(struct ahc_softc *ahc, c
 	last_patch = &patches[num_patches];
 	cur_patch = *start_patch;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
 
 		if (cur_patch->patch_func(ahc) == 0) {
@@ -6982,6 +6998,12 @@ ahc_check_patch(struct ahc_softc *ahc, c
 			 */
 			cur_patch++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*start_patch = cur_patch;
@@ -7239,9 +7261,20 @@ ahc_dump_card_state(struct ahc_softc *ah
 	} else
 		qinpos = ahc_inb(ahc, QINPOS);
 	qintail = ahc->qinfifonext;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qinpos != qintail) {
 		printk("%d ", ahc->qinfifo[qinpos]);
 		qinpos++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	printk("\n");
 
diff -u -p a/scsi/aic7xxx/aic79xx_core.c b/scsi/aic7xxx/aic79xx_core.c
--- a/scsi/aic7xxx/aic79xx_core.c
+++ b/scsi/aic7xxx/aic79xx_core.c
@@ -1331,6 +1331,11 @@ rescan_fifos:
 	 * DMA'ed back up to the host.
 	 */
 	scbid = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!SCBID_IS_NULL(scbid)) {
 		uint8_t *hscb_ptr;
 		u_int	 i;
@@ -1349,11 +1354,22 @@ rescan_fifos:
 
 		ahd_complete_scb(ahd, scb);
 		scbid = next_scbid;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);
 	ahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, SCB_LIST_NULL);
 
 	scbid = ahd_inw(ahd, COMPLETE_ON_QFREEZE_HEAD);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!SCBID_IS_NULL(scbid)) {
 
 		ahd_set_scbptr(ahd, scbid);
@@ -1367,10 +1383,21 @@ rescan_fifos:
 
 		ahd_complete_scb(ahd, scb);
 		scbid = next_scbid;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ahd_outw(ahd, COMPLETE_ON_QFREEZE_HEAD, SCB_LIST_NULL);
 
 	scbid = ahd_inw(ahd, COMPLETE_SCB_HEAD);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!SCBID_IS_NULL(scbid)) {
 
 		ahd_set_scbptr(ahd, scbid);
@@ -1384,6 +1411,12 @@ rescan_fifos:
 
 		ahd_complete_scb(ahd, scb);
 		scbid = next_scbid;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);
 
@@ -8249,7 +8282,12 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 	busaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);
 	ahd_outl(ahd, NEXT_QUEUED_SCB_ADDR, busaddr);
 
-	while (qinpos != qintail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (qinpos != qintail) {
 		scb = ahd_lookup_scb(ahd, ahd->qinfifo[qinpos]);
 		if (scb == NULL) {
 			printk("qinpos = %d, SCB index = %d\n",
@@ -8283,6 +8321,12 @@ ahd_search_qinfifo(struct ahd_softc *ahd
 			prev_scb = scb;
 		}
 		qinpos = AHD_QIN_WRAP(qinpos+1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
@@ -9520,6 +9564,11 @@ ahd_check_patch(struct ahd_softc *ahd, c
 	last_patch = &patches[num_patches];
 	cur_patch = *start_patch;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
 
 		if (cur_patch->patch_func(ahd) == 0) {
@@ -9534,6 +9583,12 @@ ahd_check_patch(struct ahd_softc *ahd, c
 			 */
 			cur_patch++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*start_patch = cur_patch;
@@ -9648,6 +9703,11 @@ ahd_probe_stack_size(struct ahd_softc *a
 	int last_probe;
 
 	last_probe = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		int i;
 
@@ -9672,7 +9732,13 @@ ahd_probe_stack_size(struct ahd_softc *a
 				goto sized;
 		}
 		last_probe++;
-	}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+}
 sized:
 	return (last_probe);
 }
diff -u -p a/scsi/aic7xxx/aic7xxx_osm.c b/scsi/aic7xxx/aic7xxx_osm.c
--- a/scsi/aic7xxx/aic7xxx_osm.c
+++ b/scsi/aic7xxx/aic7xxx_osm.c
@@ -969,6 +969,11 @@ ahc_parse_brace_option(char *opt_name, c
 	tok_end = strchr(opt_arg, '\0');
 	if (tok_end < end)
 		*tok_end = ',';
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!done) {
 		switch (*opt_arg) {
 		case '{':
@@ -1018,6 +1023,12 @@ ahc_parse_brace_option(char *opt_name, c
 			opt_arg = tok_end;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (opt_arg);
 }
diff -u -p a/scsi/aic7xxx/aicasm/aicasm.c b/scsi/aic7xxx/aicasm/aicasm.c
--- a/scsi/aic7xxx/aicasm/aicasm.c
+++ b/scsi/aic7xxx/aicasm/aicasm.c
@@ -607,10 +607,21 @@ output_listing(char *ifilename)
                         continue;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (line < cur_instr->srcline) {
 			fgets(buf, sizeof(buf), ifile);
 				fprintf(listfile, "             \t%s", buf);
 				line++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		fprintf(listfile, "%04x %02x%02x%02x%02x", instrptr,
 #ifdef __LITTLE_ENDIAN
diff -u -p a/scsi/scsi.c b/scsi/scsi.c
--- a/scsi/scsi.c
+++ b/scsi/scsi.c
@@ -515,12 +515,23 @@ void scsi_destroy_command_freelist(struc
 	if (!shost->cmd_pool)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&shost->free_list)) {
 		struct scsi_cmnd *cmd;
 
 		cmd = list_entry(shost->free_list.next, struct scsi_cmnd, list);
 		list_del_init(&cmd->list);
 		scsi_pool_free_command(shost->cmd_pool, cmd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	shost->cmd_pool = NULL;
 	scsi_put_host_cmd_pool(shost->unchecked_isa_dma ? GFP_DMA : GFP_KERNEL);
diff -u -p a/scsi/iscsi_tcp.c b/scsi/iscsi_tcp.c
--- a/scsi/iscsi_tcp.c
+++ b/scsi/iscsi_tcp.c
@@ -268,6 +268,11 @@ static int iscsi_sw_tcp_xmit_segment(str
 	unsigned int copied = 0;
 	int r = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!iscsi_tcp_segment_done(tcp_conn, segment, 0, r)) {
 		struct scatterlist *sg;
 		unsigned int offset, copy;
@@ -301,6 +306,12 @@ static int iscsi_sw_tcp_xmit_segment(str
 			return r;
 		}
 		copied += r;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return copied;
 }
@@ -372,12 +383,23 @@ static int iscsi_sw_tcp_pdu_xmit(struct
 	struct iscsi_conn *conn = task->conn;
 	int rc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (iscsi_sw_tcp_xmit_qlen(conn)) {
 		rc = iscsi_sw_tcp_xmit(conn);
 		if (rc == 0)
 			return -EAGAIN;
 		if (rc < 0)
 			return rc;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/scsi/stex.c b/scsi/stex.c
--- a/scsi/stex.c
+++ b/scsi/stex.c
@@ -800,6 +800,11 @@ static void stex_mu_intr(struct st_hba *
 		goto update_status;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hba->status_tail != hba->status_head) {
 		resp = stex_get_status(hba);
 		tag = le16_to_cpu(resp->tag);
@@ -846,7 +851,13 @@ static void stex_mu_intr(struct st_hba *
 			stex_scsi_done(ccb);
 		} else
 			ccb->req_type = 0;
-	}
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+}
 
 update_status:
 	writel(hba->status_head, base + IMR1);
@@ -895,6 +906,11 @@ static void stex_ss_mu_intr(struct st_hb
 			hba->mu_status == MU_STATE_RESETTING))
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count < hba->sts_count) {
 		scratch = hba->scratch + hba->status_tail;
 		value = le32_to_cpu(*scratch);
@@ -951,6 +967,12 @@ static void stex_ss_mu_intr(struct st_hb
 			stex_scsi_done(ccb);
 		} else
 			ccb->req_type = 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1760,12 +1782,23 @@ static void stex_hba_stop(struct st_hba
 	spin_unlock_irqrestore(hba->host->host_lock, flags);
 
 	before = jiffies;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hba->ccb[tag].req_type & PASSTHRU_REQ_TYPE) {
 		if (time_after(jiffies, before + ST_INTERNAL_TIMEOUT * HZ)) {
 			hba->ccb[tag].req_type = 0;
 			return;
 		}
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/scsi_tgt_lib.c b/scsi/scsi_tgt_lib.c
--- a/scsi/scsi_tgt_lib.c
+++ b/scsi/scsi_tgt_lib.c
@@ -281,6 +281,11 @@ void scsi_tgt_free_queue(struct Scsi_Hos
 
 	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&cmds)) {
 		tcmd = list_entry(cmds.next, struct scsi_tgt_cmd, hash_list);
 		list_del(&tcmd->hash_list);
@@ -288,6 +293,12 @@ void scsi_tgt_free_queue(struct Scsi_Hos
 
 		shost->hostt->eh_abort_handler(cmd);
 		scsi_tgt_cmd_destroy(&tcmd->work);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_free_queue);
diff -u -p a/scsi/qlogicfas408.c b/scsi/qlogicfas408.c
--- a/scsi/qlogicfas408.c
+++ b/scsi/qlogicfas408.c
@@ -186,10 +186,21 @@ static int ql_wai(struct qlogicfas408_pr
 
 	k = 0;
 	i = jiffies + WATCHDOG;
-	while (time_before(jiffies, i) && !priv->qabort &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (time_before(jiffies, i) && !priv->qabort &&
 					!((k = inb(qbase + 4)) & 0xe0)) {
 		barrier();
 		cpu_relax();
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (time_after_eq(jiffies, i))
 		return (DID_TIME_OUT);
diff -u -p a/scsi/scsi_devinfo.c b/scsi/scsi_devinfo.c
--- a/scsi/scsi_devinfo.c
+++ b/scsi/scsi_devinfo.c
@@ -682,6 +682,11 @@ static void *devinfo_seq_next(struct seq
 
 	++*ppos;
 	dl->bottom = dl->bottom->next;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (&devinfo_table->scsi_dev_info_list == dl->bottom) {
 		dl->top = dl->top->next;
 		if (dl->top == &scsi_dev_info_list) {
@@ -692,6 +697,12 @@ static void *devinfo_seq_next(struct seq
 					   struct scsi_dev_info_list_table,
 					   node);
 		dl->bottom = devinfo_table->scsi_dev_info_list.next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return dl;
diff -u -p a/scsi/sym53c416.c b/scsi/sym53c416.c
--- a/scsi/sym53c416.c
+++ b/scsi/sym53c416.c
@@ -251,6 +251,11 @@ static __inline__ unsigned int sym53c416
 
 	/* Do transfer */
 	spin_lock_irqsave(&sym53c416_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len && timeout)
 	{
 		bytes_left = inb(base + PIO_FIFO_CNT); /* Number of bytes in the PIO FIFO */
@@ -277,6 +282,12 @@ static __inline__ unsigned int sym53c416
 			if(inb(base + PIO_INT_REG) & EMPTY)
 				timeout = 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	spin_unlock_irqrestore(&sym53c416_lock, flags);
 	return orig_len - len;
@@ -293,6 +304,11 @@ static __inline__ unsigned int sym53c416
 
 	/* Do transfer */
 	spin_lock_irqsave(&sym53c416_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len && timeout)
 	{
 		bufferfree = PIO_SIZE - inb(base + PIO_FIFO_CNT);
@@ -320,6 +336,12 @@ static __inline__ unsigned int sym53c416
 			if(inb(base + PIO_INT_REG) & FULL)
 				timeout = 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	spin_unlock_irqrestore(&sym53c416_lock, flags);
 	return orig_len - len;
diff -u -p a/scsi/sym53c8xx_2/sym_hipd.c b/scsi/sym53c8xx_2/sym_hipd.c
--- a/scsi/sym53c8xx_2/sym_hipd.c
+++ b/scsi/sym53c8xx_2/sym_hipd.c
@@ -2990,6 +2990,11 @@ sym_dequeue_from_squeue(struct sym_hcb *
 	 *  that matches the target/lun/task condition.
 	 */
 	j = i;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i != np->squeueput) {
 		cp = sym_ccb_from_dsa(np, scr_to_cpu(np->squeue[i]));
 		assert(cp);
@@ -3010,6 +3015,12 @@ sym_dequeue_from_squeue(struct sym_hcb *
 			if ((j += 2) >= MAX_QUEUE*2) j = 0;
 		}
 		if ((i += 2) >= MAX_QUEUE*2) i = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (i != j)		/* Copy back the idle task if needed */
 		np->squeue[j] = np->squeue[i];
diff -u -p a/scsi/sym53c8xx_2/sym_malloc.c b/scsi/sym53c8xx_2/sym_malloc.c
--- a/scsi/sym53c8xx_2/sym_malloc.c
+++ b/scsi/sym53c8xx_2/sym_malloc.c
@@ -68,9 +68,20 @@ static void *___sym_malloc(m_pool_p mp,
 	if (size > SYM_MEM_CLUSTER_SIZE)
 		return NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size > s) {
 		s <<= 1;
 		++i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	j = i;
@@ -87,11 +98,22 @@ static void *___sym_malloc(m_pool_p mp,
 	a = h[j].next;
 	if (a) {
 		h[j].next = h[j].next->next;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (j > i) {
 			j -= 1;
 			s >>= 1;
 			h[j].next = (m_link_p) (a+s);
 			h[j].next->next = NULL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 #ifdef DEBUG
@@ -118,9 +140,20 @@ static void ___sym_mfree(m_pool_p mp, vo
 	if (size > SYM_MEM_CLUSTER_SIZE)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size > s) {
 		s <<= 1;
 		++i;
+		if (_cur < timeout) {
+rdstcll(_cur);
+		}
+		else {
+break;
+		}
 	}
 
 	a = (unsigned long)ptr;
@@ -137,8 +170,19 @@ static void ___sym_mfree(m_pool_p mp, vo
 		}
 		b = a ^ s;
 		q = &h[i];
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (q->next && q->next != (m_link_p) b) {
 			q = q->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!q->next) {
 			((m_link_p) a)->next = h[i].next;
diff -u -p a/scsi/atp870u.c b/scsi/atp870u.c
--- a/scsi/atp870u.c
+++ b/scsi/atp870u.c
@@ -364,8 +364,19 @@ stop_dma:
 				j |= 0x01;
 			}
 			outb(j, tmport);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while ((inb(tmport) & 0x01) != j) {
 				outb(j,tmport);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if (dev->id[c][target_id].last_len == 0) {
 				tmport = workport + 0x18;
diff -u -p a/scsi/qla1280.c b/scsi/qla1280.c
--- a/scsi/qla1280.c
+++ b/scsi/qla1280.c
@@ -1285,6 +1285,11 @@ qla1280_done(struct scsi_qla_host *ha)
 
 	done_q = &ha->done_q;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(done_q)) {
 		sp = list_entry(done_q->next, struct srb, list);
 
@@ -1319,6 +1324,12 @@ qla1280_done(struct scsi_qla_host *ha)
 			(*(cmd)->scsi_done)(cmd);
 		else
 			complete(sp->wait);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	LEAVE("qla1280_done");
 }
@@ -3582,7 +3593,12 @@ qla1280_isr(struct scsi_qla_host *ha, st
 	if (mailbox[5] >= RESPONSE_ENTRY_CNT)
 		goto out;
 
-	while (ha->rsp_ring_index != mailbox[5]) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ha->rsp_ring_index != mailbox[5]) {
 		pkt = ha->response_ring_ptr;
 
 		dprintk(5, "qla1280_isr: ha->rsp_ring_index = 0x%x, mailbox[5]"
@@ -3626,6 +3642,12 @@ qla1280_isr(struct scsi_qla_host *ha, st
 				ha->response_ring_ptr++;
 			WRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	
  out:
@@ -3649,6 +3671,11 @@ qla1280_rst_aen(struct scsi_qla_host *ha
 	if (ha->flags.online && !ha->flags.reset_active &&
 	    !ha->flags.abort_isp_active) {
 		ha->flags.reset_active = 1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ha->flags.reset_marker) {
 			/* Issue marker command. */
 			ha->flags.reset_marker = 0;
@@ -3660,6 +3687,12 @@ qla1280_rst_aen(struct scsi_qla_host *ha
 						       MK_SYNC_ALL);
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/scsi/NCR5380.c b/scsi/NCR5380.c
--- a/scsi/NCR5380.c
+++ b/scsi/NCR5380.c
@@ -340,6 +340,11 @@ static int NCR5380_poll_politely(struct
 	}
 	
 	/* t time yet ? */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(time_before(jiffies, end))
 	{
 		r = NCR5380_read(reg);
@@ -349,6 +354,12 @@ static int NCR5380_poll_politely(struct
 			cond_resched();
 		else
 			cpu_relax();
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return -ETIMEDOUT;
 }
diff -u -p a/scsi/wd33c93.c b/scsi/wd33c93.c
--- a/scsi/wd33c93.c
+++ b/scsi/wd33c93.c
@@ -1626,6 +1626,11 @@ wd33c93_abort(struct scsi_cmnd * cmd)
 
 	tmp = (struct scsi_cmnd *) hostdata->input_Q;
 	prev = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmp) {
 		if (tmp == cmd) {
 			if (prev)
@@ -1644,6 +1649,12 @@ wd33c93_abort(struct scsi_cmnd * cmd)
 		}
 		prev = tmp;
 		tmp = (struct scsi_cmnd *) tmp->host_scribble;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 /*
@@ -1725,7 +1736,12 @@ wd33c93_abort(struct scsi_cmnd * cmd)
  */
 
 	tmp = (struct scsi_cmnd *) hostdata->disconnected_Q;
-	while (tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (tmp) {
 		if (tmp == cmd) {
 			printk
 			    ("scsi%d: Abort - command found on disconnected_Q - ",
@@ -1735,6 +1751,12 @@ wd33c93_abort(struct scsi_cmnd * cmd)
 			return FAILED;
 		}
 		tmp = (struct scsi_cmnd *) tmp->host_scribble;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 /*
@@ -2186,21 +2208,43 @@ wd33c93_proc_info(struct Scsi_Host *inst
 	if (hd->proc & PR_INPUTQ) {
 		strcat(bp, "\ninput_Q:       ");
 		cmd = (struct scsi_cmnd *) hd->input_Q;
-		while (cmd) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)",
 				cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (struct scsi_cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 	if (hd->proc & PR_DISCQ) {
 		strcat(bp, "\ndisconnected_Q:");
 		cmd = (struct scsi_cmnd *) hd->disconnected_Q;
-		while (cmd) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (cmd) {
 			sprintf(tbuf, " %d:%d(%02x)",
 				cmd->device->id, cmd->device->lun, cmd->cmnd[0]);
 			strcat(bp, tbuf);
 			cmd = (struct scsi_cmnd *) cmd->host_scribble;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 	strcat(bp, "\n");
diff -u -p a/scsi/3w-sas.c b/scsi/3w-sas.c
--- a/scsi/3w-sas.c
+++ b/scsi/3w-sas.c
@@ -566,6 +566,11 @@ static int twl_poll_response(TW_Device_E
 
 	before = jiffies;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!found) {
 		if (sizeof(dma_addr_t) > 4) {
 			regh = readl(TWL_HOBQPH_REG_ADDR(tw_dev));
@@ -583,6 +588,12 @@ static int twl_poll_response(TW_Device_E
 			goto out;
 
 		msleep(50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	retval = 0;
 out: 
@@ -1197,6 +1208,11 @@ static irqreturn_t twl_interrupt(int irq
 	}
 
 	/* Response interrupt */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg & TWL_HISTATUS_RESPONSE_INTERRUPT) {
 		if (sizeof(dma_addr_t) > 4) {
 			regh = readl(TWL_HOBQPH_REG_ADDR(tw_dev));
@@ -1274,7 +1290,13 @@ static irqreturn_t twl_interrupt(int irq
 
 		/* Check for another response interrupt */
 		reg = readl(TWL_HISTAT_REG_ADDR(tw_dev));
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 twl_interrupt_bail:
 	spin_unlock(tw_dev->host->host_lock);
@@ -1291,11 +1313,22 @@ static int twl_poll_register(TW_Device_E
 	reg_value = readl(reg);
 	before = jiffies;
 
-        while ((reg_value & value) != result) {
+        unsigned long long delta = (cpu / khz / HZ) * 2;
+        unsigned long long _start = 0;
+        unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+	while ((reg_value & value) != result) {
 		reg_value = readl(reg);
 		if (time_after(jiffies, before + HZ * seconds))
 			goto out;
 		msleep(50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	retval = 0;
 out:
diff -u -p a/scsi/libiscsi_tcp.c b/scsi/libiscsi_tcp.c
--- a/scsi/libiscsi_tcp.c
+++ b/scsi/libiscsi_tcp.c
@@ -458,10 +458,21 @@ void iscsi_tcp_cleanup_task(struct iscsi
 		return;
 
 	/* flush task's r2t queues */
-	while (kfifo_out(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (kfifo_out(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {
 		kfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,
 			    sizeof(void*));
 		ISCSI_DBG_TCP(task->conn, "pending r2t dropped\n");
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	r2t = tcp_task->r2t;
@@ -897,6 +908,11 @@ int iscsi_tcp_recv_skb(struct iscsi_conn
 	}
 
 	skb_prepare_seq_read(skb, offset, skb->len, &seq);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		unsigned int avail;
 		const u8 *ptr;
@@ -921,7 +937,13 @@ int iscsi_tcp_recv_skb(struct iscsi_conn
 			skb_abort_seq_read(&seq);
 			goto segment_done;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 segment_done:
 	*status = ISCSI_TCP_SEGMENT_DONE;
diff -u -p a/scsi/megaraid/megaraid_mbox.c b/scsi/megaraid/megaraid_mbox.c
--- a/scsi/megaraid/megaraid_mbox.c
+++ b/scsi/megaraid/megaraid_mbox.c
@@ -1929,6 +1929,11 @@ megaraid_mbox_runpendq(adapter_t *adapte
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&adapter->pend_list)) {
 
 		assert_spin_locked(PENDING_LIST_LOCK(adapter));
@@ -1964,6 +1969,12 @@ megaraid_mbox_runpendq(adapter_t *adapte
 		}
 
 		spin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);
diff -u -p a/scsi/megaraid/megaraid_sas_base.c b/scsi/megaraid/megaraid_sas_base.c
--- a/scsi/megaraid/megaraid_sas_base.c
+++ b/scsi/megaraid/megaraid_sas_base.c
@@ -771,7 +771,12 @@ megasas_adp_reset_gen2(struct megasas_in
 
 	HostDiag = (u32)readl(hostdiag_offset);
 
-	while ( !( HostDiag & DIAG_WRITE_ENABLE) ) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ( !( HostDiag & DIAG_WRITE_ENABLE) ) {
 		msleep(100);
 		HostDiag = (u32)readl(hostdiag_offset);
 		printk(KERN_NOTICE "RESETGEN2: retry=%x, hostdiag=%x\n",
@@ -780,6 +785,12 @@ megasas_adp_reset_gen2(struct megasas_in
 		if (retry++ >= 100)
 			return 1;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	printk(KERN_NOTICE "ADP_RESET_GEN2: HostDiag=%x\n", HostDiag);
@@ -789,7 +800,12 @@ megasas_adp_reset_gen2(struct megasas_in
 	ssleep(10);
 
 	HostDiag = (u32)readl(hostdiag_offset);
-	while ( ( HostDiag & DIAG_RESET_ADAPTER) ) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ( ( HostDiag & DIAG_RESET_ADAPTER) ) {
 		msleep(100);
 		HostDiag = (u32)readl(hostdiag_offset);
 		printk(KERN_NOTICE "RESET_GEN2: retry=%x, hostdiag=%x\n",
@@ -798,6 +814,12 @@ megasas_adp_reset_gen2(struct megasas_in
 		if (retry++ >= 1000)
 			return 1;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
@@ -1652,7 +1674,12 @@ static void megasas_complete_cmd_dpc(uns
 	producer = *instance->producer;
 	consumer = *instance->consumer;
 
-	while (consumer != producer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (consumer != producer) {
 		context = instance->reply_queue[consumer];
 		if (context >= instance->max_fw_cmds) {
 			printk(KERN_ERR "Unexpected context value %x\n",
@@ -1668,6 +1695,12 @@ static void megasas_complete_cmd_dpc(uns
 		if (consumer == (instance->max_fw_cmds + 1)) {
 			consumer = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*instance->consumer = producer;
@@ -1753,7 +1786,12 @@ static int megasas_wait_for_outstanding(
 		}
 
 		reset_index	= 0;
-		while (!list_empty(&clist_local)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&clist_local)) {
 			reset_cmd	= list_entry((&clist_local)->next,
 						struct megasas_cmd, list);
 			list_del_init(&reset_cmd->list);
@@ -1780,6 +1818,12 @@ static int megasas_wait_for_outstanding(
 					reset_cmd);
 			}
 			reset_index++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		return SUCCESS;
@@ -2342,7 +2386,12 @@ megasas_issue_pending_cmds_again(struct
 	list_splice_init(&instance->internal_reset_pending_q, &clist_local);
 	spin_unlock_irqrestore(&instance->hba_lock, flags);
 
-	while (!list_empty(&clist_local)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&clist_local)) {
 		cmd	= list_entry((&clist_local)->next,
 					struct megasas_cmd, list);
 		list_del_init(&cmd->list);
@@ -2393,6 +2442,12 @@ megasas_issue_pending_cmds_again(struct
 				"internal reset defer list while re-issue!!\n",
 				cmd);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (instance->aen_cmd) {
diff -u -p a/scsi/advansys.c b/scsi/advansys.c
--- a/scsi/advansys.c
+++ b/scsi/advansys.c
@@ -4875,9 +4875,20 @@ static int AdvLoadMicrocode(AdvPortAddr
 
 	end = len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len < memsize) {
 		AdvWriteWordAutoIncLram(iop_base, 0);
 		len += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Verify the microcode checksum. */
@@ -9902,6 +9913,11 @@ static int __devinit AscWriteEEPDataReg(
 	int retry;
 
 	retry = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (TRUE) {
 		AscSetChipEEPData(iop_base, data_reg);
 		mdelay(1);
@@ -9912,6 +9928,12 @@ static int __devinit AscWriteEEPDataReg(
 		if (retry++ > ASC_EEP_MAX_RETRY) {
 			return (0);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -11876,10 +11898,21 @@ static void advansys_wide_free_mem(struc
 	adv_dvc->carrier_buf = NULL;
 	kfree(adv_dvc->orig_reqp);
 	adv_dvc->orig_reqp = board->adv_reqp = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (board->adv_sgblkp) {
 		adv_sgblk_t *sgp = board->adv_sgblkp;
 		board->adv_sgblkp = sgp->next_sgblkp;
 		kfree(sgp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/u14-34f.c b/scsi/u14-34f.c
--- a/scsi/u14-34f.c
+++ b/scsi/u14-34f.c
@@ -734,9 +734,20 @@ static int u14_34f_slave_configure(struc
 
 static int wait_on_busy(unsigned long iobase, unsigned int loop) {
 
-   while (inb(iobase + REG_LCL_INTR) & BSY_ASSERTED) {
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (inb(iobase + REG_LCL_INTR) & BSY_ASSERTED) {
       udelay(1L);
       if (--loop == 0) return TRUE;
+      if (_cur < timeout) {
+            rdstcll(_cur);
+      }
+      else {
+            break;
+      }
       }
 
    return FALSE;
@@ -1045,6 +1056,11 @@ static void internal_setup(char *str, in
       setup_done = TRUE;
       }
 
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    while (cur && (pc = strchr(cur, ':'))) {
       int val = 0, c = *++pc;
 
@@ -1061,6 +1077,12 @@ static void internal_setup(char *str, in
       else if (!strncmp(cur, "et:", 3))  ext_tran = val;
 
       if ((cur = strchr(cur, ','))) ++cur;
+      if (_cur < timeout) {
+      rdstcll(_cur);
+      }
+      else {
+      break;
+      }
       }
 
    return;
diff -u -p a/scsi/g_NCR5380.c b/scsi/g_NCR5380.c
--- a/scsi/g_NCR5380.c
+++ b/scsi/g_NCR5380.c
@@ -606,10 +606,21 @@ static inline int NCR5380_pread(struct S
 	}
 
 	if (blocks) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
 		{
 			// FIXME - no timeout
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+}
 
 #ifndef SCSI_G_NCR5380_MEM
 		{
diff -u -p a/rapidio/devices/tsi721.c b/rapidio/devices/tsi721.c
--- a/rapidio/devices/tsi721.c
+++ b/rapidio/devices/tsi721.c
@@ -140,6 +140,11 @@ static int tsi721_maint_dma(struct tsi72
 	i = 0;
 
 	/* Wait until DMA transfer is finished */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ch_stat = ioread32(priv->regs +
 		TSI721_DMAC_STS(TSI721_DMACH_MAINT))) & TSI721_DMAC_STS_RUN) {
 		udelay(1);
@@ -152,6 +157,12 @@ static int tsi721_maint_dma(struct tsi72
 			err = -EIO;
 			goto err_out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ch_stat & TSI721_DMAC_STS_ABORT) {
@@ -293,6 +304,11 @@ static void tsi721_pw_dpc(struct work_st
 	/*
 	 * Process port-write messages
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (kfifo_out_spinlocked(&priv->pw_fifo, (unsigned char *)msg_buffer,
 			 TSI721_RIO_PW_MSG_SIZE, &priv->pw_fifo_lock)) {
 		/* Process one message */
@@ -311,6 +327,12 @@ static void tsi721_pw_dpc(struct work_st
 #endif
 		/* Pass the port-write message to RIO core for processing */
 		rio_inb_pwrite_handler((union rio_pw_msg *)msg_buffer);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -413,7 +435,12 @@ static void tsi721_db_dpc(struct work_st
 	wr_ptr = ioread32(priv->regs + TSI721_IDQ_WP(IDB_QUEUE)) % IDB_QSIZE;
 	rd_ptr = ioread32(priv->regs + TSI721_IDQ_RP(IDB_QUEUE)) % IDB_QSIZE;
 
-	while (wr_ptr != rd_ptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (wr_ptr != rd_ptr) {
 		idb_entry = (u64 *)(priv->idb_base +
 					(TSI721_IDB_ENTRY_SIZE * rd_ptr));
 		rd_ptr++;
@@ -442,6 +469,12 @@ static void tsi721_db_dpc(struct work_st
 
 		wr_ptr = ioread32(priv->regs +
 				  TSI721_IDQ_WP(IDB_QUEUE)) % IDB_QSIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	iowrite32(rd_ptr & (IDB_QSIZE - 1),
@@ -1258,6 +1291,11 @@ static void tsi721_omsg_handler(struct t
 		srd_ptr = priv->omsg_ring[ch].sts_rdptr;
 		sts_ptr = priv->omsg_ring[ch].sts_base;
 		j = srd_ptr * 8;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sts_ptr[j]) {
 			for (i = 0; i < 8 && sts_ptr[j]; i++, j++) {
 				prev_ptr = last_ptr;
@@ -1268,6 +1306,12 @@ static void tsi721_omsg_handler(struct t
 			++srd_ptr;
 			srd_ptr %= priv->omsg_ring[ch].sts_size;
 			j = srd_ptr * 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (last_ptr == 0)
diff -u -p a/rapidio/rio.c b/rapidio/rio.c
--- a/rapidio/rio.c
+++ b/rapidio/rio.c
@@ -414,7 +414,12 @@ rio_mport_get_physefb(struct rio_mport *
 
 	ext_ftr_ptr = rio_mport_get_efb(port, local, destid, hopcount, 0);
 
-	while (ext_ftr_ptr)  {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ext_ftr_ptr)  {
 		if (local)
 			rio_local_read_config_32(port, ext_ftr_ptr,
 						 &ftr_header);
@@ -441,6 +446,12 @@ rio_mport_get_physefb(struct rio_mport *
 
 		ext_ftr_ptr = rio_mport_get_efb(port, local, destid,
 						hopcount, ext_ftr_ptr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ext_ftr_ptr;
@@ -466,11 +477,22 @@ struct rio_dev *rio_get_comptag(u32 comp
 	spin_lock(&rio_global_list_lock);
 	n = from ? from->global_list.next : rio_devices.next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (n && (n != &rio_devices)) {
 		rdev = rio_dev_g(n);
 		if (rdev->comp_tag == comp_tag)
 			goto exit;
 		n = n->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	rdev = NULL;
 exit:
@@ -556,12 +578,23 @@ rio_mport_chk_dev_access(struct rio_mpor
 	int i = 0;
 	u32 tmp;
 
-	while (rio_mport_read_config_32(mport, destid, hopcount,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (rio_mport_read_config_32(mport, destid, hopcount,
 					RIO_DEV_ID_CAR, &tmp)) {
 		i++;
 		if (i == RIO_MAX_CHK_RETRY)
 			return -EIO;
 		mdelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -981,6 +1014,11 @@ struct rio_dev *rio_get_asm(u16 vid, u16
 	spin_lock(&rio_global_list_lock);
 	n = from ? from->global_list.next : rio_devices.next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (n && (n != &rio_devices)) {
 		rdev = rio_dev_g(n);
 		if ((vid == RIO_ANY_ID || rdev->vid == vid) &&
@@ -989,6 +1027,12 @@ struct rio_dev *rio_get_asm(u16 vid, u16
 		    (asm_did == RIO_ANY_ID || rdev->asm_did == asm_did))
 			goto exit;
 		n = n->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	rdev = NULL;
       exit:
diff -u -p a/rapidio/rio-scan.c b/rapidio/rio-scan.c
--- a/rapidio/rio-scan.c
+++ b/rapidio/rio-scan.c
@@ -587,7 +587,12 @@ rio_lock_device(struct rio_mport *port,
 	rio_mport_read_config_32(port, destid, hopcount,
 				 RIO_HOST_DID_LOCK_CSR, &result);
 
-	while (result != port->host_deviceid) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (result != port->host_deviceid) {
 		if (wait_ms != 0 && tcnt == wait_ms) {
 			pr_debug("RIO: timeout when locking device %x:%x\n",
 				destid, hopcount);
@@ -605,6 +610,12 @@ rio_lock_device(struct rio_mport *port,
 		rio_mport_read_config_32(port, destid,
 			hopcount,
 			RIO_HOST_DID_LOCK_CSR, &result);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
@@ -788,6 +799,11 @@ static int __devinit rio_enum_peer(struc
 	rio_mport_write_config_32(port, RIO_ANY_DESTID(port->sys_size),
 				  hopcount,
 				  RIO_HOST_DID_LOCK_CSR, port->host_deviceid);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((tmp = rio_get_host_deviceid_lock(port, hopcount))
 	       < port->host_deviceid) {
 		/* Delay a bit */
@@ -797,6 +813,12 @@ static int __devinit rio_enum_peer(struc
 					  hopcount,
 					  RIO_HOST_DID_LOCK_CSR,
 					  port->host_deviceid);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (rio_get_host_deviceid_lock(port, hopcount) > port->host_deviceid) {
@@ -1277,12 +1299,23 @@ int __devinit rio_disc_mport(struct rio_
 		    jiffies + CONFIG_RAPIDIO_DISC_TIMEOUT * HZ;
 		rio_enum_timer.data = (unsigned long)&enum_timeout_flag;
 		add_timer(&rio_enum_timer);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!rio_enum_complete(mport)) {
 			mdelay(1);
 			if (enum_timeout_flag) {
 				del_timer_sync(&rio_enum_timer);
 				goto timeout;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		del_timer_sync(&rio_enum_timer);
 
diff -u -p a/rapidio/switches/tsi57x.c b/rapidio/switches/tsi57x.c
--- a/rapidio/switches/tsi57x.c
+++ b/rapidio/switches/tsi57x.c
@@ -251,7 +251,12 @@ tsi57x_em_handler(struct rio_dev *rdev,
 		 * symbol to recover from IES/OES
 		 */
 		sendcount = 3;
-		while (sendcount) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (sendcount) {
 			rio_write_config_32(rdev,
 					  TSI578_SP_CS_TX(portnum), 0x40fc8000);
 			checkcount = 3;
@@ -266,6 +271,12 @@ tsi57x_em_handler(struct rio_dev *rdev,
 			}
 
 			sendcount--;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
diff -u -p a/rapidio/rio-driver.c b/rapidio/rio-driver.c
--- a/rapidio/rio-driver.c
+++ b/rapidio/rio-driver.c
@@ -30,6 +30,11 @@ static const struct rio_device_id *rio_m
 						    *id,
 						    const struct rio_dev *rdev)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (id->vid || id->asm_vid) {
 		if (((id->vid == RIO_ANY_ID) || (id->vid == rdev->vid)) &&
 		    ((id->did == RIO_ANY_ID) || (id->did == rdev->did)) &&
@@ -39,6 +44,12 @@ static const struct rio_device_id *rio_m
 			|| (id->asm_did == rdev->asm_did)))
 			return id;
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/regulator/core.c b/regulator/core.c
--- a/regulator/core.c
+++ b/regulator/core.c
@@ -244,10 +244,21 @@ static int regulator_mode_constrain(stru
 	/* The modes are bitmasks, the most power hungry modes having
 	 * the lowest values. If the requested mode isn't supported
 	 * try higher modes. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*mode) {
 		if (rdev->constraints->valid_modes_mask & *mode)
 			return 0;
 		*mode /= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -EINVAL;
diff -u -p a/cpufreq/gx-suspmod.c b/cpufreq/gx-suspmod.c
--- a/cpufreq/gx-suspmod.c
+++ b/cpufreq/gx-suspmod.c
@@ -393,13 +393,35 @@ static int cpufreq_gx_target(struct cpuf
 	policy->cpu = 0;
 
 	tmp_freq = gx_validate_speed(target_freq, &tmp1, &tmp2);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmp_freq < policy->min) {
 		tmp_freq += stock_freq / max_duration;
 		tmp_freq = gx_validate_speed(tmp_freq, &tmp1, &tmp2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmp_freq > policy->max) {
 		tmp_freq -= stock_freq / max_duration;
 		tmp_freq = gx_validate_speed(tmp_freq, &tmp1, &tmp2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	gx_set_cpuspeed(tmp_freq);
diff -u -p a/cpufreq/powernow-k8.c b/cpufreq/powernow-k8.c
--- a/cpufreq/powernow-k8.c
+++ b/cpufreq/powernow-k8.c
@@ -355,11 +355,22 @@ static int core_voltage_pre_transition(s
 	if (reqvid < maxvid) /* lower numbers are higher voltages */
 		reqvid = maxvid;
 
-	while (data->currvid > reqvid) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (data->currvid > reqvid) {
 		pr_debug("ph1: curr 0x%x, req vid 0x%x\n",
 			data->currvid, reqvid);
 		if (decrease_vid_code_by_step(data, reqvid, data->vidmvs))
 			return 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	while ((rvosteps > 0) &&
diff -u -p a/cpufreq/speedstep-lib.c b/cpufreq/speedstep-lib.c
--- a/cpufreq/speedstep-lib.c
+++ b/cpufreq/speedstep-lib.c
@@ -78,10 +78,21 @@ static unsigned int pentium3_get_frequen
 	/* decode the FSB */
 	msr_tmp &= 0x00c0000;
 	msr_tmp >>= 18;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (msr_tmp != msr_decode_fsb[i].bitmap) {
 		if (msr_decode_fsb[i].bitmap == 0xff)
 			return 0;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* decode the multiplier */
@@ -91,10 +102,21 @@ static unsigned int pentium3_get_frequen
 	} else
 		msr_lo &= 0x0bc00000;
 	msr_lo >>= 22;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (msr_lo != msr_decode_mult[j].bitmap) {
 		if (msr_decode_mult[j].bitmap == 0xff)
 			return 0;
 		j++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_debug("speed is %u\n",
diff -u -p a/cpufreq/e_powersaver.c b/cpufreq/e_powersaver.c
--- a/cpufreq/e_powersaver.c
+++ b/cpufreq/e_powersaver.c
@@ -119,6 +119,11 @@ static int eps_set_state(struct eps_cpu_
 	/* Wait while CPU is busy */
 	rdmsr(MSR_IA32_PERF_STATUS, lo, hi);
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (lo & ((1 << 16) | (1 << 17))) {
 		udelay(16);
 		rdmsr(MSR_IA32_PERF_STATUS, lo, hi);
@@ -127,6 +132,12 @@ static int eps_set_state(struct eps_cpu_
 			err = -ENODEV;
 			goto postchange;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Set new multiplier and voltage */
 	wrmsr(MSR_IA32_PERF_CTL, dest_state & 0xffff, 0);
diff -u -p a/cpufreq/longhaul.c b/cpufreq/longhaul.c
--- a/cpufreq/longhaul.c
+++ b/cpufreq/longhaul.c
@@ -286,11 +286,22 @@ retry_loop:
 	    || ((pr != NULL) && pr->flags.bm_control))) {
 		bm_status = inw(acpi_regs_addr);
 		bm_status &= 1 << 4;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bm_status && bm_timeout) {
 			outw(1 << 4, acpi_regs_addr);
 			bm_timeout--;
 			bm_status = inw(acpi_regs_addr);
 			bm_status &= 1 << 4;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -659,6 +670,11 @@ static int longhaul_target(struct cpufre
 		current_vid &= 0x1f;
 		if (table_index > longhaul_index)
 			dir = 1;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (i != table_index) {
 			vid = (longhaul_table[i].index >> 8) & 0x1f;
 			if (vid != current_vid) {
@@ -670,6 +686,12 @@ static int longhaul_target(struct cpufre
 				i++;
 			else
 				i--;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		longhaul_setstate(table_index);
 	}
diff -u -p a/cpufreq/cpufreq-nforce2.c b/cpufreq/cpufreq-nforce2.c
--- a/cpufreq/cpufreq-nforce2.c
+++ b/cpufreq/cpufreq-nforce2.c
@@ -204,7 +204,12 @@ static int nforce2_set_fsb(unsigned int
 	if (!diff)
 		return 0;
 
-	while ((tfsb != fsb) && (tfsb <= max_fsb) && (tfsb >= min_fsb)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((tfsb != fsb) && (tfsb <= max_fsb) && (tfsb >= min_fsb)) {
 		if (diff < 0)
 			tfsb++;
 		else
@@ -219,6 +224,12 @@ static int nforce2_set_fsb(unsigned int
 #ifdef NFORCE2_DELAY
 		mdelay(NFORCE2_DELAY);
 #endif
+if (_cur < timeout) {
+			rdstcll(_cur);
+}
+else {
+			break;
+}
 	}
 
 	temp = 0x40;
diff -u -p a/cpufreq/cpufreq.c b/cpufreq/cpufreq.c
--- a/cpufreq/cpufreq.c
+++ b/cpufreq/cpufreq.c
@@ -799,11 +799,22 @@ static int cpufreq_add_dev_interface(uns
 
 	/* set up files for this cpu device */
 	drv_attr = cpufreq_driver->attr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((drv_attr) && (*drv_attr)) {
 		ret = sysfs_create_file(&policy->kobj, &((*drv_attr)->attr));
 		if (ret)
 			goto err_out_kobj_put;
 		drv_attr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (cpufreq_driver->get) {
 		ret = sysfs_create_file(&policy->kobj, &cpuinfo_cur_freq.attr);
diff -u -p a/devfreq/devfreq.c b/devfreq/devfreq.c
--- a/devfreq/devfreq.c
+++ b/devfreq/devfreq.c
@@ -427,10 +427,21 @@ int devfreq_remove_device(struct devfreq
 
 	if (central_polling) {
 		mutex_lock(&devfreq_list_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (wait_remove_device == devfreq) {
 			mutex_unlock(&devfreq_list_lock);
 			schedule();
 			mutex_lock(&devfreq_list_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/infiniband/hw/nes/nes_mgt.c b/infiniband/hw/nes/nes_mgt.c
--- a/infiniband/hw/nes/nes_mgt.c
+++ b/infiniband/hw/nes/nes_mgt.c
@@ -418,6 +418,11 @@ static int forward_fpdus(struct nes_vnic
 	u32 u32tmp;
 	int rc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		rc = get_fpdu_info(nesdev, nesqp, &fpdu_info);
 		if (fpdu_info == NULL)
@@ -475,6 +480,12 @@ static int forward_fpdus(struct nes_vnic
 
 		atomic_set(&cqp_request->refcount, 1);
 		nes_post_cqp_request(nesdev, cqp_request);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
@@ -581,9 +592,19 @@ static int mgt_thread(void *context)
 	struct sk_buff *skb;
 	struct nes_rskb_cb *cb;
 
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		wait_event_interruptible(nesvnic->mgt_wait_queue,
 					 skb_queue_len(&nesvnic->mgt_skb_list) || kthread_should_stop());
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((skb_queue_len(&nesvnic->mgt_skb_list)) && !kthread_should_stop()) {
 			skb = skb_dequeue(&nesvnic->mgt_skb_list);
 			cb = (struct nes_rskb_cb *)&skb->cb[0];
@@ -591,15 +612,38 @@ static int mgt_thread(void *context)
 			cb->busaddr = pci_map_single(nesvnic->nesdev->pcidev, cb->data_start,
 						     nesvnic->max_frame_size, PCI_DMA_TODEVICE);
 			queue_fpdus(skb, nesvnic, cb->nesqp);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
 	/* Closing down so delete any entries on the queue */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb_queue_len(&nesvnic->mgt_skb_list)) {
 		skb = skb_dequeue(&nesvnic->mgt_skb_list);
 		cb = (struct nes_rskb_cb *)&skb->cb[0];
 		nes_rem_ref_cm_node(cb->nesqp->cm_node);
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -626,10 +670,21 @@ void nes_destroy_pau_qp(struct nes_devic
 	/* Free packets that have not yet been forwarded */
 	/* Lock is acquired by skb_dequeue when removing the skb */
 	spin_lock_irqsave(&nesqp->pau_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb_queue_len(&nesqp->pau_list)) {
 		skb = skb_dequeue(&nesqp->pau_list);
 		nes_mgt_free_skb(nesdev, skb, PCI_DMA_TODEVICE);
 		nes_rem_ref_cm_node(nesqp->cm_node);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&nesqp->pau_lock, flags);
 }
@@ -1092,11 +1147,22 @@ void nes_destroy_mgt(struct nes_vnic *ne
 		if (mgtvnic == NULL)
 			continue;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (mgtvnic->mgt.rq_head != mgtvnic->mgt.rq_tail) {
 			rx_skb = mgtvnic->mgt.rx_skb[mgtvnic->mgt.rq_tail];
 			nes_mgt_free_skb(nesdev, rx_skb, PCI_DMA_FROMDEVICE);
 			mgtvnic->mgt.rq_tail++;
 			mgtvnic->mgt.rq_tail &= (mgtvnic->mgt.rq_size - 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		spin_lock_irqsave(&nesdev->cqp.lock, flags);
diff -u -p a/infiniband/hw/nes/nes_cm.c b/infiniband/hw/nes/nes_cm.c
--- a/infiniband/hw/nes/nes_cm.c
+++ b/infiniband/hw/nes/nes_cm.c
@@ -1554,7 +1554,12 @@ static int process_options(struct nes_cm
 	union all_known_options *all_options;
 	char got_mss_option = 0;
 
-	while (offset < optionsize) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (offset < optionsize) {
 		all_options = (union all_known_options *)(optionsloc + offset);
 		switch (all_options->as_base.optionnum) {
 		case OPTION_NUMBER_END:
@@ -1587,6 +1592,12 @@ static int process_options(struct nes_cm
 			break;
 		}
 		offset += all_options->as_base.length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if ((!got_mss_option) && (syn_packet))
 		cm_node->tcp_cntxt.mss = NES_CM_DEFAULT_MSS;
diff -u -p a/infiniband/hw/nes/nes_hw.c b/infiniband/hw/nes/nes_hw.c
--- a/infiniband/hw/nes/nes_hw.c
+++ b/infiniband/hw/nes/nes_hw.c
@@ -1934,6 +1934,11 @@ void nes_destroy_nic_qp(struct nes_vnic
 	nes_write_indexed(nesdev, NES_IDX_WQM_CONFIG0, wqm_cfg0 & 0xFFFF7FFF);
 
 	/* Free remaining NIC receive buffers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nesvnic->nic.rq_head != nesvnic->nic.rq_tail) {
 		rx_skb = nesvnic->nic.rx_skb[nesvnic->nic.rq_tail];
 		cb = (struct nes_rskb_cb *)&rx_skb->cb[0];
@@ -1942,9 +1947,20 @@ void nes_destroy_nic_qp(struct nes_vnic
 
 		dev_kfree_skb(nesvnic->nic.rx_skb[nesvnic->nic.rq_tail++]);
 		nesvnic->nic.rq_tail &= (nesvnic->nic.rq_size - 1);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Free remaining NIC transmit buffers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nesvnic->nic.sq_head != nesvnic->nic.sq_tail) {
 		nic_sqe = &nesvnic->nic.sq_vbase[nesvnic->nic.sq_tail];
 		wqe_fragment_index = 1;
@@ -1995,6 +2011,12 @@ void nes_destroy_nic_qp(struct nes_vnic
 
 		nesvnic->nic.sq_tail = (nesvnic->nic.sq_tail + 1)
 					& (nesvnic->nic.sq_size - 1);
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 	}
 
 	spin_lock_irqsave(&nesdev->cqp.lock, flags);
diff -u -p a/infiniband/hw/nes/nes_verbs.c b/infiniband/hw/nes/nes_verbs.c
--- a/infiniband/hw/nes/nes_verbs.c
+++ b/infiniband/hw/nes/nes_verbs.c
@@ -1430,6 +1430,11 @@ static void nes_clean_cq(struct nes_qp *
 	spin_lock_irqsave(&nescq->lock, flags);
 
 	cq_head = nescq->hw_cq.cq_head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (le32_to_cpu(nescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_OPCODE_IDX]) & NES_CQE_VALID) {
 		rmb();
 		lo = le32_to_cpu(nescq->hw_cq.cq_vbase[cq_head].cqe_words[NES_CQE_COMP_COMP_CTX_LOW_IDX]);
@@ -1444,6 +1449,12 @@ static void nes_clean_cq(struct nes_qp *
 
 		if (++cq_head >= nescq->hw_cq.cq_size)
 			cq_head = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	spin_unlock_irqrestore(&nescq->lock, flags);
@@ -3519,11 +3530,22 @@ static int nes_post_send(struct ib_qp *i
 
 	nesqp->hwqp.sq_head = head;
 	barrier();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (wqe_count) {
 		counter = min(wqe_count, ((u32)255));
 		wqe_count -= counter;
 		nes_write32(nesdev->regs + NES_WQE_ALLOC,
 				(counter << 24) | 0x00800000 | nesqp->hwqp.qp_id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&nesqp->lock, flags);
@@ -3613,10 +3635,21 @@ static int nes_post_recv(struct ib_qp *i
 
 	nesqp->hwqp.rq_head = head;
 	barrier();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (wqe_count) {
 		counter = min(wqe_count, ((u32)255));
 		wqe_count -= counter;
 		nes_write32(nesdev->regs+NES_WQE_ALLOC, (counter<<24) | nesqp->hwqp.qp_id);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&nesqp->lock, flags);
diff -u -p a/infiniband/hw/qib/qib_verbs_mcast.c b/infiniband/hw/qib/qib_verbs_mcast.c
--- a/infiniband/hw/qib/qib_verbs_mcast.c
+++ b/infiniband/hw/qib/qib_verbs_mcast.c
@@ -116,7 +116,12 @@ struct qib_mcast *qib_mcast_find(struct
 
 	spin_lock_irqsave(&ibp->lock, flags);
 	n = ibp->mcast_tree.rb_node;
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		int ret;
 
 		mcast = rb_entry(n, struct qib_mcast, rb_node);
@@ -132,6 +137,12 @@ struct qib_mcast *qib_mcast_find(struct
 			spin_unlock_irqrestore(&ibp->lock, flags);
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&ibp->lock, flags);
 
@@ -159,6 +170,11 @@ static int qib_mcast_add(struct qib_ibde
 
 	spin_lock_irq(&ibp->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*n) {
 		struct qib_mcast *tmcast;
 		struct qib_mcast_qp *p;
@@ -194,6 +210,12 @@ static int qib_mcast_add(struct qib_ibde
 		list_add_tail_rcu(&mqp->list, &tmcast->qp_list);
 		ret = EEXIST;
 		goto bail;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_lock(&dev->n_mcast_grps_lock);
diff -u -p a/infiniband/hw/qib/qib_diag.c b/infiniband/hw/qib/qib_diag.c
--- a/infiniband/hw/qib/qib_diag.c
+++ b/infiniband/hw/qib/qib_diag.c
@@ -194,10 +194,21 @@ void qib_diag_remove(struct qib_devdata
 		return_client(dd->diag_client);
 
 	/* Now clean up all unused client structs */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (client_pool) {
 		dc = client_pool;
 		client_pool = dc->next;
 		kfree(dc);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Clean up observer list */
 	qib_unregister_observers(dd);
@@ -349,6 +360,11 @@ static int qib_read_umem64(struct qib_de
 	reg_end = reg_addr + (count / sizeof(u64));
 
 	/* not very efficient, but it works for now */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_addr < reg_end) {
 		u64 data = readq(reg_addr);
 
@@ -358,6 +374,12 @@ static int qib_read_umem64(struct qib_de
 		}
 		reg_addr++;
 		uaddr += sizeof(u64);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0;
 bail:
@@ -393,6 +415,11 @@ static int qib_write_umem64(struct qib_d
 	reg_end = reg_addr + (count / sizeof(u64));
 
 	/* not very efficient, but it works for now */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_addr < reg_end) {
 		u64 data;
 		if (copy_from_user(&data, uaddr, sizeof(data))) {
@@ -403,6 +430,12 @@ static int qib_write_umem64(struct qib_d
 
 		reg_addr++;
 		uaddr += sizeof(u64);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0;
 bail:
@@ -437,6 +470,11 @@ static int qib_read_umem32(struct qib_de
 	reg_end = reg_addr + (count / sizeof(u32));
 
 	/* not very efficient, but it works for now */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_addr < reg_end) {
 		u32 data = readl(reg_addr);
 
@@ -448,6 +486,12 @@ static int qib_read_umem32(struct qib_de
 		reg_addr++;
 		uaddr += sizeof(u32);
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0;
 bail:
@@ -482,6 +526,11 @@ static int qib_write_umem32(struct qib_d
 		count = limit;
 	reg_end = reg_addr + (count / sizeof(u32));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_addr < reg_end) {
 		u32 data;
 
@@ -493,6 +542,12 @@ static int qib_write_umem32(struct qib_d
 
 		reg_addr++;
 		uaddr += sizeof(u32);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0;
 bail:
@@ -718,6 +773,11 @@ static void qib_unregister_observers(str
 
 	spin_lock_irqsave(&dd->qib_diag_trans_lock, flags);
 	olp = dd->diag_observer_list;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (olp) {
 		/* Pop one observer, let go of lock */
 		dd->diag_observer_list = olp->next;
@@ -726,6 +786,12 @@ static void qib_unregister_observers(str
 		/* try again. */
 		spin_lock_irqsave(&dd->qib_diag_trans_lock, flags);
 		olp = dd->diag_observer_list;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);
 }
diff -u -p a/infiniband/hw/qib/qib_keys.c b/infiniband/hw/qib/qib_keys.c
--- a/infiniband/hw/qib/qib_keys.c
+++ b/infiniband/hw/qib/qib_keys.c
@@ -190,6 +190,11 @@ int qib_lkey_ok(struct qib_lkey_table *r
 	} else {
 		m = 0;
 		n = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (off >= mr->map[m]->segs[n].length) {
 			off -= mr->map[m]->segs[n].length;
 			n++;
@@ -197,6 +202,12 @@ int qib_lkey_ok(struct qib_lkey_table *r
 				m++;
 				n = 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	isge->mr = mr;
@@ -284,6 +295,11 @@ int qib_rkey_ok(struct qib_qp *qp, struc
 	} else {
 		m = 0;
 		n = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (off >= mr->map[m]->segs[n].length) {
 			off -= mr->map[m]->segs[n].length;
 			n++;
@@ -291,6 +307,12 @@ int qib_rkey_ok(struct qib_qp *qp, struc
 				m++;
 				n = 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	sge->mr = mr;
diff -u -p a/infiniband/hw/qib/qib_qsfp.c b/infiniband/hw/qib/qib_qsfp.c
--- a/infiniband/hw/qib/qib_qsfp.c
+++ b/infiniband/hw/qib/qib_qsfp.c
@@ -96,6 +96,11 @@ static int qsfp_read(struct qib_pportdat
 	/* All QSFP modules are at A0 */
 
 	cnt = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt < len) {
 		unsigned in_page;
 		int wlen = len - cnt;
@@ -113,6 +118,12 @@ static int qsfp_read(struct qib_pportdat
 		}
 		addr += wlen;
 		cnt += wlen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = cnt;
 
@@ -203,6 +214,11 @@ static int qib_qsfp_write(struct qib_ppo
 	/* All QSFP modules are at A0 */
 
 	cnt = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt < len) {
 		unsigned in_page;
 		int wlen = len - cnt;
@@ -217,6 +233,12 @@ static int qib_qsfp_write(struct qib_ppo
 		}
 		addr += wlen;
 		cnt += wlen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = cnt;
 
@@ -255,12 +277,23 @@ static int qsfp_cks(struct qib_pportdata
 	u8 bval;
 
 	cks = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (first < next) {
 		ret = qsfp_read(ppd, first, &bval, 1);
 		if (ret < 0)
 			goto bail;
 		cks += bval;
 		++first;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = cks & 0xFF;
 bail:
diff -u -p a/infiniband/hw/qib/qib_sdma.c b/infiniband/hw/qib/qib_sdma.c
--- a/infiniband/hw/qib/qib_sdma.c
+++ b/infiniband/hw/qib/qib_sdma.c
@@ -131,10 +131,21 @@ static void clear_sdma_activelist(struct
 			unsigned idx;
 
 			idx = txp->start_idx;
-			while (idx != txp->next_descq_idx) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+		while (idx != txp->next_descq_idx) {
 				unmap_desc(ppd, idx);
 				if (++idx == ppd->sdma_descq_cnt)
 					idx = 0;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 			}
 		}
 		if (txp->callback)
@@ -367,6 +378,11 @@ int qib_sdma_make_progress(struct qib_pp
 		idx = txp->start_idx;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ppd->sdma_descq_head != hwhead) {
 		/* if desc is part of this txp, unmap if needed */
 		if (txp && (txp->flags & QIB_SDMA_TXREQ_F_FREEDESC) &&
@@ -400,6 +416,12 @@ int qib_sdma_make_progress(struct qib_pp
 			}
 		}
 		progress = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (progress)
 		qib_verbs_sdma_desc_avail(ppd, qib_sdma_descq_freecnt(ppd));
diff -u -p a/infiniband/hw/qib/qib_twsi.c b/infiniband/hw/qib/qib_twsi.c
--- a/infiniband/hw/qib/qib_twsi.c
+++ b/infiniband/hw/qib/qib_twsi.c
@@ -477,10 +477,21 @@ int qib_twsi_blk_wr(struct qib_devdata *
 		 * whether we have real eeprom_dev. Legacy likes any address.
 		 */
 		max_wait_time = 100;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (qib_twsi_wr(dd, dev | READ_CMD, QIB_TWSI_START)) {
 			stop_cmd(dd);
 			if (!--max_wait_time)
 				goto failed_write;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		/* now read (and ignore) the resulting byte */
 		rd_byte(dd, 1);
diff -u -p a/infiniband/hw/qib/qib_iba7220.c b/infiniband/hw/qib/qib_iba7220.c
--- a/infiniband/hw/qib/qib_iba7220.c
+++ b/infiniband/hw/qib/qib_iba7220.c
@@ -3415,10 +3415,21 @@ static void autoneg_7220_sendpkt(struct
 	i = 0;
 	pbc = 7 + dcnt + 1; /* 7 dword header, dword data, icrc */
 	pbc |= PBC_7220_VL15_SEND;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(piobuf = get_7220_link_buf(ppd, &pnum))) {
 		if (i++ > 5)
 			return;
 		udelay(2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	sendctrl_7220_mod(dd->pport, QIB_SENDCTRL_DISARM_BUF(pnum));
 	writeq(pbc, piobuf);
diff -u -p a/infiniband/hw/qib/qib_iba7322.c b/infiniband/hw/qib/qib_iba7322.c
--- a/infiniband/hw/qib/qib_iba7322.c
+++ b/infiniband/hw/qib/qib_iba7322.c
@@ -1299,8 +1299,18 @@ static void err_decode(char *msg, size_t
 	u64 these, lmask;
 	int took, multi, n = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (errs && msp && msp->mask) {
 		multi = (msp->mask & (msp->mask - 1));
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (errs & msp->mask) {
 			these = (errs & msp->mask);
 			lmask = (these & (these - 1)) ^ these;
@@ -1324,16 +1334,39 @@ static void err_decode(char *msg, size_t
 				/* More than one bit this mask */
 				int idx = -1;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (lmask & msp->mask) {
 					++idx;
 					lmask >>= 1;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 				took = scnprintf(msg, len, "_%d", idx);
 				len -= took;
 				msg += took;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		++msp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* If some bits are left, show in hex. */
 	if (len && errs)
@@ -4885,10 +4918,21 @@ static void autoneg_7322_sendpkt(struct
 	len = 7 + dcnt + 1; /* 7 dword header, dword data, icrc */
 	control = qib_7322_setpbc_control(ppd, len, 0, 15);
 	pbc = ((u64) control << 32) | len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(piobuf = qib_7322_getsendbuf(ppd, pbc, &pnum))) {
 		if (i++ > 15)
 			return;
 		udelay(2);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* disable header check on this packet, since it can't be valid */
 	dd->f_txchk_change(dd, pnum, 1, TXCHK_CHG_TYPE_DIS1, NULL);
@@ -7619,7 +7663,12 @@ static int serdes_7322_init_new(struct q
 	/*       Start Calibration */
 	ibsd_wr_allchans(ppd, 4, (1 << 10), BMASK(10, 10));
 	tstart = get_jiffies_64();
-	while (chan_done &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (chan_done &&
 	       !time_after64(get_jiffies_64(),
 			tstart + msecs_to_jiffies(500))) {
 		msleep(20);
@@ -7631,6 +7680,12 @@ static int serdes_7322_init_new(struct q
 			    (~chan_done & (1 << chan)) == 0)
 				chan_done &= ~(1 << chan);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (chan_done) {
 		printk(KERN_INFO QIB_DRV_NAME
diff -u -p a/infiniband/hw/qib/qib_ruc.c b/infiniband/hw/qib/qib_ruc.c
--- a/infiniband/hw/qib/qib_ruc.c
+++ b/infiniband/hw/qib/qib_ruc.c
@@ -107,10 +107,21 @@ static int qib_init_sge(struct qib_qp *q
 	goto bail;
 
 bad_lkey:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (j) {
 		struct qib_sge *sge = --j ? &ss->sg_list[j - 1] : &ss->sge;
 
 		atomic_dec(&sge->mr->refcount);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ss->num_sge = 0;
 	memset(&wc, 0, sizeof(wc));
@@ -541,11 +552,23 @@ again:
 		}
 		sqp->s_len -= len;
 	}
-	if (release)
-		while (qp->r_sge.num_sge) {
-			atomic_dec(&qp->r_sge.sge.mr->refcount);
-			if (--qp->r_sge.num_sge)
+	if (release) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (qp->r_sge.num_sge) {
+				atomic_dec(&qp->r_sge.sge.mr->refcount);
+				if (--qp->r_sge.num_sge)
 				qp->r_sge.sge = *qp->r_sge.sg_list++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
+				}
 		}
 
 	if (!test_and_clear_bit(QIB_R_WRID_VALID, &qp->r_aflags))
diff -u -p a/infiniband/hw/qib/qib_srq.c b/infiniband/hw/qib/qib_srq.c
--- a/infiniband/hw/qib/qib_srq.c
+++ b/infiniband/hw/qib/qib_srq.c
@@ -278,6 +278,11 @@ int qib_modify_srq(struct ib_srq *ibsrq,
 		}
 		n = 0;
 		p = wq->wq;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tail != head) {
 			struct qib_rwqe *wqe;
 			int i;
@@ -291,6 +296,12 @@ int qib_modify_srq(struct ib_srq *ibsrq,
 			p = (struct qib_rwqe *)((char *) p + sz);
 			if (++tail >= srq->rq.size)
 				tail = 0;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		srq->rq.wq = wq;
 		srq->rq.size = size;
diff -u -p a/infiniband/hw/qib/qib_rc.c b/infiniband/hw/qib/qib_rc.c
--- a/infiniband/hw/qib/qib_rc.c
+++ b/infiniband/hw/qib/qib_rc.c
@@ -2024,10 +2024,21 @@ send_last:
 		if (unlikely(wc.byte_len > qp->r_len))
 			goto nack_inv;
 		qib_copy_sge(&qp->r_sge, data, tlen, 1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (qp->r_sge.num_sge) {
 			atomic_dec(&qp->r_sge.sge.mr->refcount);
 			if (--qp->r_sge.num_sge)
 				qp->r_sge.sge = *qp->r_sge.sg_list++;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		qp->r_msn++;
 		if (!test_and_clear_bit(QIB_R_WRID_VALID, &qp->r_aflags))
diff -u -p a/infiniband/hw/qib/qib_qp.c b/infiniband/hw/qib/qib_qp.c
--- a/infiniband/hw/qib/qib_qp.c
+++ b/infiniband/hw/qib/qib_qp.c
@@ -405,21 +405,49 @@ static void clear_mr_refs(struct qib_qp
 {
 	unsigned n;
 
-	if (test_and_clear_bit(QIB_R_REWIND_SGE, &qp->r_aflags))
-		while (qp->s_rdma_read_sge.num_sge) {
-			atomic_dec(&qp->s_rdma_read_sge.sge.mr->refcount);
-			if (--qp->s_rdma_read_sge.num_sge)
-				qp->s_rdma_read_sge.sge =
-					*qp->s_rdma_read_sge.sg_list++;
+	if (test_and_clear_bit(QIB_R_REWIND_SGE, &qp->r_aflags)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (qp->s_rdma_read_sge.num_sge) {
+				atomic_dec(&qp->s_rdma_read_sge.sge.mr->refcount);
+				if (--qp->s_rdma_read_sge.num_sge)
+			qp->s_rdma_read_sge.sge =
+			*qp->s_rdma_read_sge.sg_list++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+					}
 		}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qp->r_sge.num_sge) {
 		atomic_dec(&qp->r_sge.sge.mr->refcount);
 		if (--qp->r_sge.num_sge)
 			qp->r_sge.sge = *qp->r_sge.sg_list++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (clr_sends) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (qp->s_last != qp->s_head) {
 			struct qib_swqe *wqe = get_swqe_ptr(qp, qp->s_last);
 			unsigned i;
@@ -435,6 +463,12 @@ static void clear_mr_refs(struct qib_qp
 				atomic_dec(&to_iah(wqe->wr.wr.ud.ah)->refcount);
 			if (++qp->s_last >= qp->s_size)
 				qp->s_last = 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (qp->s_rdma_mr) {
 			atomic_dec(&qp->s_rdma_mr->refcount);
@@ -536,11 +570,22 @@ int qib_error_qp(struct qib_qp *qp, enum
 		tail = wq->tail;
 		if (tail >= qp->r_rq.size)
 			tail = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tail != head) {
 			wc.wr_id = get_rwqe_ptr(&qp->r_rq, tail)->wr_id;
 			if (++tail >= qp->r_rq.size)
 				tail = 0;
 			qib_cq_enter(to_icq(qp->ibqp.recv_cq), &wc, 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		wq->tail = tail;
 
diff -u -p a/infiniband/hw/qib/qib_ud.c b/infiniband/hw/qib/qib_ud.c
--- a/infiniband/hw/qib/qib_ud.c
+++ b/infiniband/hw/qib/qib_ud.c
@@ -201,10 +201,21 @@ static void qib_ud_loopback(struct qib_q
 		}
 		length -= len;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qp->r_sge.num_sge) {
 		atomic_dec(&qp->r_sge.sge.mr->refcount);
 		if (--qp->r_sge.num_sge)
 			qp->r_sge.sge = *qp->r_sge.sg_list++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (!test_and_clear_bit(QIB_R_WRID_VALID, &qp->r_aflags))
 		goto bail_unlock;
@@ -563,10 +574,21 @@ void qib_ud_rcv(struct qib_ibport *ibp,
 	} else
 		qib_skip_sge(&qp->r_sge, sizeof(struct ib_grh), 1);
 	qib_copy_sge(&qp->r_sge, data, wc.byte_len - sizeof(struct ib_grh), 1);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qp->r_sge.num_sge) {
 		atomic_dec(&qp->r_sge.sge.mr->refcount);
 		if (--qp->r_sge.num_sge)
 			qp->r_sge.sge = *qp->r_sge.sg_list++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (!test_and_clear_bit(QIB_R_WRID_VALID, &qp->r_aflags))
 		return;
diff -u -p a/infiniband/hw/qib/qib_tx.c b/infiniband/hw/qib/qib_tx.c
--- a/infiniband/hw/qib/qib_tx.c
+++ b/infiniband/hw/qib/qib_tx.c
@@ -391,6 +391,11 @@ void qib_chg_pioavailkernel(struct qib_d
 
 	spin_lock_irqsave(&dd->pioavail_lock, flags);
 	/* Set or clear the busy bit in the shadow. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start < end) {
 		if (avail) {
 			unsigned long dma;
@@ -428,6 +433,12 @@ void qib_chg_pioavailkernel(struct qib_d
 			__clear_bit(start, dd->pioavailkernel);
 		}
 		start += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&dd->pioavail_lock, flags);
diff -u -p a/infiniband/hw/ehca/ipz_pt_fn.c b/infiniband/hw/ehca/ipz_pt_fn.c
--- a/infiniband/hw/ehca/ipz_pt_fn.c
+++ b/infiniband/hw/ehca/ipz_pt_fn.c
@@ -104,6 +104,11 @@ static int alloc_queue_pages(struct ipz_
 	int k, f = 0;
 	u8 *kpage;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (f < nr_of_pages) {
 		kpage = (u8 *)get_zeroed_page(GFP_KERNEL);
 		if (!kpage)
@@ -114,6 +119,12 @@ static int alloc_queue_pages(struct ipz_
 			kpage += EHCA_PAGESIZE;
 			f++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 1;
 
diff -u -p a/infiniband/hw/ehca/ehca_qp.c b/infiniband/hw/ehca/ehca_qp.c
--- a/infiniband/hw/ehca/ehca_qp.c
+++ b/infiniband/hw/ehca/ehca_qp.c
@@ -1150,10 +1150,21 @@ static int calc_left_cqes(u64 wqe_p, str
 	wqe_idx = q_ofs / ipz_queue->qe_size;
 
 	/* check all processed wqes, whether a cqe is requested or not */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tail_idx != wqe_idx) {
 		if (qmap->map[tail_idx].cqe_req)
 			qmap->left_to_poll++;
 		tail_idx = next_index(tail_idx, qmap->entries);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* save index in queue, where we have to start flushing */
 	qmap->next_wqe_idx = wqe_idx;
diff -u -p a/infiniband/hw/ehca/ehca_irq.c b/infiniband/hw/ehca/ehca_irq.c
--- a/infiniband/hw/ehca/ehca_irq.c
+++ b/infiniband/hw/ehca/ehca_irq.c
@@ -483,11 +483,22 @@ void ehca_tasklet_neq(unsigned long data
 
 	eqe = ehca_poll_eq(shca, &shca->neq);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (eqe) {
 		if (!EHCA_BMASK_GET(NEQE_COMPLETION_EVENT, eqe->entry))
 			parse_ec(shca, eqe->entry);
 
 		eqe = ehca_poll_eq(shca, &shca->neq);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = hipz_h_reset_event(shca->ipz_hca_handle,
@@ -723,6 +734,11 @@ static void run_comp_task(struct ehca_cp
 
 	spin_lock_irqsave(&cct->task_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&cct->cq_list)) {
 		cq = list_entry(cct->cq_list.next, struct ehca_cq, entry);
 		spin_unlock_irqrestore(&cct->task_lock, flags);
@@ -739,6 +755,12 @@ static void run_comp_task(struct ehca_cp
 			cct->cq_jobs--;
 		}
 		spin_unlock(&cq->task_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&cct->task_lock, flags);
@@ -751,7 +773,12 @@ static int comp_task(void *__cct)
 	DECLARE_WAITQUEUE(wait, current);
 
 	set_current_state(TASK_INTERRUPTIBLE);
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		add_wait_queue(&cct->wait_queue, &wait);
 
 		spin_lock_irq(&cct->task_lock);
@@ -771,6 +798,12 @@ static int comp_task(void *__cct)
 			run_comp_task(__cct);
 
 		set_current_state(TASK_INTERRUPTIBLE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	__set_current_state(TASK_RUNNING);
 
@@ -823,11 +856,22 @@ static void __cpuinit take_over_work(str
 
 	list_splice_init(&cct->cq_list, &list);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&list)) {
 		cq = list_entry(cct->cq_list.next, struct ehca_cq, entry);
 
 		list_del(&cq->entry);
 		__queue_comp_task(cq, this_cpu_ptr(pool->cpu_comp_tasks));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&cct->task_lock, flags_cct);
diff -u -p a/infiniband/hw/ehca/ehca_mrmw.c b/infiniband/hw/ehca/ehca_mrmw.c
--- a/infiniband/hw/ehca/ehca_mrmw.c
+++ b/infiniband/hw/ehca/ehca_mrmw.c
@@ -1548,6 +1548,11 @@ static u64 ehca_reg_mr_section(int top,
 	}
 	page_count = EHCA_SECTSIZE / pginfo->hwpage_size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (page < page_count) {
 		u64 rnum;
 		for (rnum = 0; (rnum < MAX_RPAGES) && (page < page_count);
@@ -1564,6 +1569,12 @@ static u64 ehca_reg_mr_section(int top,
 			ehca_err(&shca->ib_device, "register_rpage_mr failed");
 			return h_ret;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return h_ret;
 }
@@ -2064,7 +2075,12 @@ static int ehca_set_pagebuf_phys(struct
 	u32 i = 0;
 
 	/* loop over desired phys_buf_array entries */
-	while (i < number) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < number) {
 		pbuf   = pginfo->u.phy.phys_buf_array + pginfo->u.phy.next_buf;
 		num_hw  = NUM_CHUNKS((pbuf->addr % pginfo->hwpage_size) +
 				     pbuf->size, pginfo->hwpage_size);
@@ -2110,6 +2126,12 @@ static int ehca_set_pagebuf_phys(struct
 			(pginfo->u.phy.next_buf)++;
 			pginfo->next_hwpage = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return ret;
 }
@@ -2435,6 +2457,11 @@ static int ehca_create_busmap_callback(u
 	end_pfn = initial_pfn + total_nr_pages;
 	pfn = start_pfn;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pfn < end_pfn) {
 		if (ehca_is_hugepage(pfn)) {
 			/* Add mem found in front of the hugepage */
@@ -2447,6 +2474,12 @@ static int ehca_create_busmap_callback(u
 			start_pfn = pfn;
 		} else
 			pfn += (EHCA_SECTSIZE / PAGE_SIZE);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	/* Add mem found behind the hugepage(s)  */
diff -u -p a/infiniband/hw/ehca/ehca_reqs.c b/infiniband/hw/ehca/ehca_reqs.c
--- a/infiniband/hw/ehca/ehca_reqs.c
+++ b/infiniband/hw/ehca/ehca_reqs.c
@@ -115,7 +115,12 @@ static void trace_send_wr_ud(const struc
 {
 	int idx;
 	int j;
-	while (send_wr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (send_wr) {
 		struct ib_mad_hdr *mad_hdr = send_wr->wr.ud.mad_hdr;
 		struct ib_sge *sge = send_wr->sg_list;
 		ehca_gen_dbg("send_wr#%x wr_id=%lx num_sge=%x "
@@ -147,6 +152,12 @@ static void trace_send_wr_ud(const struc
 		} /* eof for j */
 		idx++;
 		send_wr = send_wr->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} /* eof while send_wr */
 }
 
@@ -478,6 +489,11 @@ int ehca_post_send(struct ib_qp *qp,
 	}
 
 	/* loop processes list of send reqs */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (send_wr) {
 		ret = post_one_send(my_qp, send_wr, 0);
 		if (unlikely(ret)) {
@@ -485,7 +501,13 @@ int ehca_post_send(struct ib_qp *qp,
 		}
 		wqe_cnt++;
 		send_wr = send_wr->next;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 post_send_exit0:
 	iosync(); /* serialize GAL register access */
@@ -525,6 +547,11 @@ static int internal_post_recv(struct ehc
 	spin_lock_irqsave(&my_qp->spinlock_r, flags);
 
 	/* loop processes list of recv reqs */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (recv_wr) {
 		u64 start_offset = my_qp->ipz_rqueue.current_q_offset;
 		/* get pointer next to free WQE */
@@ -564,7 +591,13 @@ static int internal_post_recv(struct ehc
 
 		wqe_cnt++;
 		recv_wr = recv_wr->next;
-	} /* eof for recv_wr */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+} /* eof for recv_wr */
 
 post_recv_exit0:
 	iosync(); /* serialize GAL register access */
diff -u -p a/infiniband/hw/amso1100/c2_cq.c b/infiniband/hw/amso1100/c2_cq.c
--- a/infiniband/hw/amso1100/c2_cq.c
+++ b/infiniband/hw/amso1100/c2_cq.c
@@ -94,6 +94,11 @@ void c2_cq_clean(struct c2_dev *c2dev, s
 		u16 priv = q->priv;
 		struct c2wr_ce *msg;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (priv != be16_to_cpu(*q->shared)) {
 			msg = (struct c2wr_ce *)
 				(q->msg_pool.host + priv * q->msg_size);
@@ -101,6 +106,12 @@ void c2_cq_clean(struct c2_dev *c2dev, s
 				msg->qp_user_context = (u64) 0;
 			}
 			priv = (priv + 1) % q->q_size;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	spin_unlock_irq(&cq->lock);
diff -u -p a/infiniband/hw/amso1100/c2_mm.c b/infiniband/hw/amso1100/c2_mm.c
--- a/infiniband/hw/amso1100/c2_mm.c
+++ b/infiniband/hw/amso1100/c2_mm.c
@@ -87,6 +87,11 @@ send_pbl_messages(struct c2_dev *c2dev,
 	wr->stag_index = stag_index;	/* already swapped */
 	wr->flags = 0;
 	pbl_index = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pbl_depth) {
 		count = min(pbe_count, pbl_depth);
 		wr->addrs_length = cpu_to_be32(count);
@@ -142,6 +147,12 @@ send_pbl_messages(struct c2_dev *c2dev,
 		}
 		pbl_depth -= count;
 		pbl_index += count;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/infiniband/hw/amso1100/c2_alloc.c b/infiniband/hw/amso1100/c2_alloc.c
--- a/infiniband/hw/amso1100/c2_alloc.c
+++ b/infiniband/hw/amso1100/c2_alloc.c
@@ -78,11 +78,22 @@ void c2_free_mqsp_pool(struct c2_dev *c2
 {
 	struct sp_chunk *next;
 
-	while (root) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (root) {
 		next = root->next;
 		dma_free_coherent(&c2dev->pcidev->dev, PAGE_SIZE, root,
 				  dma_unmap_addr(root, mapping));
 		root = next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/infiniband/hw/cxgb3/cxio_resource.c b/infiniband/hw/cxgb3/cxio_resource.c
--- a/infiniband/hw/cxgb3/cxio_resource.c
+++ b/infiniband/hw/cxgb3/cxio_resource.c
@@ -278,7 +278,12 @@ int cxio_hal_pblpool_create(struct cxio_
 	pbl_start = rdev_p->rnic_info.pbl_base;
 	pbl_chunk = rdev_p->rnic_info.pbl_top - pbl_start + 1;
 
-	while (pbl_start < rdev_p->rnic_info.pbl_top) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pbl_start < rdev_p->rnic_info.pbl_top) {
 		pbl_chunk = min(rdev_p->rnic_info.pbl_top - pbl_start + 1,
 				pbl_chunk);
 		if (gen_pool_add(rdev_p->pbl_pool, pbl_start, pbl_chunk, -1)) {
@@ -295,6 +300,12 @@ int cxio_hal_pblpool_create(struct cxio_
 			     __func__, pbl_start, pbl_chunk);
 			pbl_start += pbl_chunk;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/infiniband/hw/cxgb3/cxio_hal.c b/infiniband/hw/cxgb3/cxio_hal.c
--- a/infiniband/hw/cxgb3/cxio_hal.c
+++ b/infiniband/hw/cxgb3/cxio_hal.c
@@ -107,13 +107,24 @@ int cxio_hal_cq_op(struct cxio_rdev *rde
 		 * spin until that CQE is valid.
 		 */
 		cqe = cq->queue + Q_PTR2IDX(rptr, cq->size_log2);
-		while (!CQ_VLD_ENTRY(rptr, cq->size_log2, cqe)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!CQ_VLD_ENTRY(rptr, cq->size_log2, cqe)) {
 			udelay(1);
 			if (i++ > 1000000) {
 				printk(KERN_ERR "%s: stalled rnic\n",
 				       rdev_p->dev_name);
 				return -EIO;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		return 1;
@@ -412,12 +423,23 @@ int cxio_flush_sq(struct t3_wq *wq, stru
 
 	ptr = wq->sq_rptr + count;
 	sqp = wq->sq + Q_PTR2IDX(ptr, wq->sq_size_log2);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ptr != wq->sq_wptr) {
 		sqp->signaled = 0;
 		insert_sq_cqe(wq, cq, sqp);
 		ptr++;
 		sqp = wq->sq + Q_PTR2IDX(ptr, wq->sq_size_log2);
 		flushed++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return flushed;
 }
@@ -431,7 +453,12 @@ void cxio_flush_hw_cq(struct t3_cq *cq)
 
 	PDBG("%s cq %p cqid 0x%x\n", __func__, cq, cq->cqid);
 	cqe = cxio_next_hw_cqe(cq);
-	while (cqe) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (cqe) {
 		PDBG("%s flushing hwcq rptr 0x%x to swcq wptr 0x%x\n",
 		     __func__, cq->rptr, cq->sw_wptr);
 		swcqe = cq->sw_queue + Q_PTR2IDX(cq->sw_wptr, cq->size_log2);
@@ -440,6 +467,12 @@ void cxio_flush_hw_cq(struct t3_cq *cq)
 		cq->sw_wptr++;
 		cq->rptr++;
 		cqe = cxio_next_hw_cqe(cq);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -468,6 +501,11 @@ void cxio_count_scqes(struct t3_cq *cq,
 
 	*count = 0;
 	ptr = cq->sw_rptr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!Q_EMPTY(ptr, cq->sw_wptr)) {
 		cqe = cq->sw_queue + (Q_PTR2IDX(ptr, cq->size_log2));
 		if ((SQ_TYPE(*cqe) ||
@@ -475,6 +513,12 @@ void cxio_count_scqes(struct t3_cq *cq,
 		    (CQE_QPID(*cqe) == wq->qpid))
 			(*count)++;
 		ptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	PDBG("%s cq %p count %d\n", __func__, cq, *count);
 }
@@ -487,12 +531,23 @@ void cxio_count_rcqes(struct t3_cq *cq,
 	*count = 0;
 	PDBG("%s count zero %d\n", __func__, *count);
 	ptr = cq->sw_rptr;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!Q_EMPTY(ptr, cq->sw_wptr)) {
 		cqe = cq->sw_queue + (Q_PTR2IDX(ptr, cq->size_log2));
 		if (RQ_TYPE(*cqe) && (CQE_OPCODE(*cqe) != T3_READ_RESP) &&
 		    (CQE_QPID(*cqe) == wq->qpid) && cqe_completes_wr(cqe, wq))
 			(*count)++;
 		ptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	PDBG("%s cq %p count %d\n", __func__, cq, *count);
 }
@@ -1121,12 +1176,23 @@ static void advance_oldest_read(struct t
 	u32 rptr = wq->oldest_read - wq->sq + 1;
 	u32 wptr = Q_PTR2IDX(wq->sq_wptr, wq->sq_size_log2);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (Q_PTR2IDX(rptr, wq->sq_size_log2) != wptr) {
 		wq->oldest_read = wq->sq + Q_PTR2IDX(rptr, wq->sq_size_log2);
 
 		if (wq->oldest_read->opcode == T3_READ_REQ)
 			return;
 		rptr++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	wq->oldest_read = NULL;
 }
diff -u -p a/infiniband/hw/cxgb3/iwch_cm.c b/infiniband/hw/cxgb3/iwch_cm.c
--- a/infiniband/hw/cxgb3/iwch_cm.c
+++ b/infiniband/hw/cxgb3/iwch_cm.c
@@ -2177,6 +2177,11 @@ static void process_work(struct work_str
 	struct t3cdev *tdev;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&rxq))) {
 		ep = *((void **) (skb->cb));
 		tdev = *((struct t3cdev **) (skb->cb + sizeof(void *)));
@@ -2188,6 +2193,12 @@ static void process_work(struct work_str
 		 * ep was referenced in sched(), and is freed here.
 		 */
 		put_ep((struct iwch_ep_common *)ep);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/infiniband/hw/cxgb4/cm.c b/infiniband/hw/cxgb4/cm.c
--- a/infiniband/hw/cxgb4/cm.c
+++ b/infiniband/hw/cxgb4/cm.c
@@ -2600,6 +2600,11 @@ static void process_timedout_eps(void)
 	struct c4iw_ep *ep;
 
 	spin_lock_irq(&timeout_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&timeout_list)) {
 		struct list_head *tmp;
 
@@ -2609,6 +2614,12 @@ static void process_timedout_eps(void)
 		ep = list_entry(tmp, struct c4iw_ep, entry);
 		process_timeout(ep);
 		spin_lock_irq(&timeout_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irq(&timeout_lock);
 }
@@ -2621,6 +2632,11 @@ static void process_work(struct work_str
 	unsigned int opcode;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&rxq))) {
 		rpl = cplhdr(skb);
 		dev = *((struct c4iw_dev **) (skb->cb + sizeof(void *)));
@@ -2630,6 +2646,12 @@ static void process_work(struct work_str
 		ret = work_handlers[opcode](dev, skb);
 		if (!ret)
 			kfree_skb(skb);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	process_timedout_eps();
 }
diff -u -p a/infiniband/hw/cxgb4/cq.c b/infiniband/hw/cxgb4/cq.c
--- a/infiniband/hw/cxgb4/cq.c
+++ b/infiniband/hw/cxgb4/cq.c
@@ -253,7 +253,12 @@ void c4iw_flush_hw_cq(struct t4_cq *cq)
 
 	PDBG("%s cq %p cqid 0x%x\n", __func__, cq, cq->cqid);
 	ret = t4_next_hw_cqe(cq, &cqe);
-	while (!ret) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!ret) {
 		PDBG("%s flushing hwcq cidx 0x%x swcq pidx 0x%x\n",
 		     __func__, cq->cidx, cq->sw_pidx);
 		swcqe = &cq->sw_queue[cq->sw_pidx];
@@ -262,6 +267,12 @@ void c4iw_flush_hw_cq(struct t4_cq *cq)
 		t4_swcq_produce(cq);
 		t4_hwcq_consume(cq);
 		ret = t4_next_hw_cqe(cq, &cqe);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -288,6 +299,11 @@ void c4iw_count_scqes(struct t4_cq *cq,
 
 	*count = 0;
 	ptr = cq->sw_cidx;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ptr != cq->sw_pidx) {
 		cqe = &cq->sw_queue[ptr];
 		if ((SQ_TYPE(cqe) || ((CQE_OPCODE(cqe) == FW_RI_READ_RESP) &&
@@ -296,6 +312,12 @@ void c4iw_count_scqes(struct t4_cq *cq,
 			(*count)++;
 		if (++ptr == cq->size)
 			ptr = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	PDBG("%s cq %p count %d\n", __func__, cq, *count);
 }
@@ -308,6 +330,11 @@ void c4iw_count_rcqes(struct t4_cq *cq,
 	*count = 0;
 	PDBG("%s count zero %d\n", __func__, *count);
 	ptr = cq->sw_cidx;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ptr != cq->sw_pidx) {
 		cqe = &cq->sw_queue[ptr];
 		if (RQ_TYPE(cqe) && (CQE_OPCODE(cqe) != FW_RI_READ_RESP) &&
@@ -315,6 +342,12 @@ void c4iw_count_rcqes(struct t4_cq *cq,
 			(*count)++;
 		if (++ptr == cq->size)
 			ptr = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	PDBG("%s cq %p count %d\n", __func__, cq, *count);
 }
@@ -372,6 +405,11 @@ static void advance_oldest_read(struct t
 
 	if (rptr == wq->sq.size)
 		rptr = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rptr != wq->sq.pidx) {
 		wq->sq.oldest_read = &wq->sq.sw_sq[rptr];
 
@@ -379,6 +417,12 @@ static void advance_oldest_read(struct t
 			return;
 		if (++rptr == wq->sq.size)
 			rptr = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	wq->sq.oldest_read = NULL;
 }
diff -u -p a/infiniband/hw/cxgb4/qp.c b/infiniband/hw/cxgb4/qp.c
--- a/infiniband/hw/cxgb4/qp.c
+++ b/infiniband/hw/cxgb4/qp.c
@@ -301,6 +301,11 @@ static int build_immd(struct t4_sq *sq,
 		srcp = (u8 *)(unsigned long)wr->sg_list[i].addr;
 		plen += wr->sg_list[i].length;
 		rem = wr->sg_list[i].length;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (rem) {
 			if (dstp == (u8 *)&sq->queue[sq->size])
 				dstp = (u8 *)sq->queue;
@@ -312,6 +317,12 @@ static int build_immd(struct t4_sq *sq,
 			dstp += len;
 			srcp += len;
 			rem -= len;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	len = roundup(plen + sizeof *immdp, 16) - (plen + sizeof *immdp);
@@ -546,11 +557,22 @@ static int build_fastreg(struct t4_sq *s
 			p = (__be64 *)sq->queue;
 	}
 	BUG_ON(rem < 0);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rem) {
 		*p = 0;
 		rem -= sizeof *p;
 		if (++p == (__be64 *)&sq->queue[sq->size])
 			p = (__be64 *)sq->queue;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	*len16 = DIV_ROUND_UP(sizeof wqe->fr + sizeof *imdp + pbllen, 16);
 	return 0;
diff -u -p a/infiniband/hw/cxgb4/resource.c b/infiniband/hw/cxgb4/resource.c
--- a/infiniband/hw/cxgb4/resource.c
+++ b/infiniband/hw/cxgb4/resource.c
@@ -336,6 +336,11 @@ int c4iw_pblpool_create(struct c4iw_rdev
 	pbl_chunk = rdev->lldi.vr->pbl.size;
 	pbl_top = pbl_start + pbl_chunk;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pbl_start < pbl_top) {
 		pbl_chunk = min(pbl_top - pbl_start + 1, pbl_chunk);
 		if (gen_pool_add(rdev->pbl_pool, pbl_start, pbl_chunk, -1)) {
@@ -354,6 +359,12 @@ int c4iw_pblpool_create(struct c4iw_rdev
 			     __func__, pbl_start, pbl_chunk);
 			pbl_start += pbl_chunk;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -398,6 +409,11 @@ int c4iw_rqtpool_create(struct c4iw_rdev
 	rqt_chunk = rdev->lldi.vr->rq.size;
 	rqt_top = rqt_start + rqt_chunk;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rqt_start < rqt_top) {
 		rqt_chunk = min(rqt_top - rqt_start + 1, rqt_chunk);
 		if (gen_pool_add(rdev->rqt_pool, rqt_start, rqt_chunk, -1)) {
@@ -415,6 +431,12 @@ int c4iw_rqtpool_create(struct c4iw_rdev
 			     __func__, rqt_start, rqt_chunk);
 			rqt_start += rqt_chunk;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -454,6 +476,11 @@ int c4iw_ocqp_pool_create(struct c4iw_rd
 	chunk = rdev->lldi.vr->ocq.size;
 	top = start + chunk;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start < top) {
 		chunk = min(top - start + 1, chunk);
 		if (gen_pool_add(rdev->ocqp_pool, start, chunk, -1)) {
@@ -471,6 +498,12 @@ int c4iw_ocqp_pool_create(struct c4iw_rd
 			     __func__, start, chunk);
 			start += chunk;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/infiniband/hw/ipath/ipath_eeprom.c b/infiniband/hw/ipath/ipath_eeprom.c
--- a/infiniband/hw/ipath/ipath_eeprom.c
+++ b/infiniband/hw/ipath/ipath_eeprom.c
@@ -607,13 +607,24 @@ static int ipath_eeprom_internal_write(s
 		 * whether we have real eeprom_dev. legacy likes any address.
 		 */
 		max_wait_time = 100;
-		while (i2c_startcmd(dd, icd->eeprom_dev | READ_CMD)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i2c_startcmd(dd, icd->eeprom_dev | READ_CMD)) {
 			stop_cmd(dd);
 			if (!--max_wait_time) {
 				ipath_dbg("Did not get successful read to "
 					  "complete write\n");
 				goto failed_write;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/* now read (and ignore) the resulting byte */
 		rd_byte(dd);
diff -u -p a/infiniband/hw/ipath/ipath_srq.c b/infiniband/hw/ipath/ipath_srq.c
--- a/infiniband/hw/ipath/ipath_srq.c
+++ b/infiniband/hw/ipath/ipath_srq.c
@@ -282,6 +282,11 @@ int ipath_modify_srq(struct ib_srq *ibsr
 		}
 		n = 0;
 		p = wq->wq;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tail != head) {
 			struct ipath_rwqe *wqe;
 			int i;
@@ -295,6 +300,12 @@ int ipath_modify_srq(struct ib_srq *ibsr
 			p = (struct ipath_rwqe *)((char *) p + sz);
 			if (++tail >= srq->rq.size)
 				tail = 0;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		srq->rq.wq = wq;
 		srq->rq.size = size;
diff -u -p a/infiniband/hw/ipath/ipath_driver.c b/infiniband/hw/ipath/ipath_driver.c
--- a/infiniband/hw/ipath/ipath_driver.c
+++ b/infiniband/hw/ipath/ipath_driver.c
@@ -1680,6 +1680,11 @@ void ipath_chg_pioavailkernel(struct ipa
 
 	spin_lock_irqsave(&ipath_pioavail_lock, flags);
 	/* Set or clear the busy bit in the shadow. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start < end) {
 		if (avail) {
 			unsigned long dma;
@@ -1719,6 +1724,12 @@ void ipath_chg_pioavailkernel(struct ipa
 			__clear_bit(start, dd->ipath_pioavailkernel);
 		}
 		start += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (dd->ipath_pioupd_thresh) {
diff -u -p a/infiniband/hw/ipath/ipath_diag.c b/infiniband/hw/ipath/ipath_diag.c
--- a/infiniband/hw/ipath/ipath_diag.c
+++ b/infiniband/hw/ipath/ipath_diag.c
@@ -147,6 +147,11 @@ static int ipath_read_umem64(struct ipat
 		ret = -EINVAL;
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_addr < reg_end) {
 		u64 data = readq(reg_addr);
 		if (copy_to_user(uaddr, &data, sizeof(u64))) {
@@ -155,6 +160,12 @@ static int ipath_read_umem64(struct ipat
 		}
 		reg_addr++;
 		uaddr += sizeof(u64);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0;
 bail:
@@ -184,6 +195,11 @@ static int ipath_write_umem64(struct ipa
 		ret = -EINVAL;
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_addr < reg_end) {
 		u64 data;
 		if (copy_from_user(&data, uaddr, sizeof(data))) {
@@ -194,6 +210,12 @@ static int ipath_write_umem64(struct ipa
 
 		reg_addr++;
 		uaddr += sizeof(u64);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0;
 bail:
@@ -223,6 +245,11 @@ static int ipath_read_umem32(struct ipat
 		goto bail;
 	}
 	/* not very efficient, but it works for now */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_addr < reg_end) {
 		u32 data = readl(reg_addr);
 		if (copy_to_user(uaddr, &data, sizeof(data))) {
@@ -233,6 +260,12 @@ static int ipath_read_umem32(struct ipat
 		reg_addr++;
 		uaddr += sizeof(u32);
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0;
 bail:
@@ -262,6 +295,11 @@ static int ipath_write_umem32(struct ipa
 		ret = -EINVAL;
 		goto bail;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_addr < reg_end) {
 		u32 data;
 		if (copy_from_user(&data, uaddr, sizeof(data))) {
@@ -272,6 +310,12 @@ static int ipath_write_umem32(struct ipa
 
 		reg_addr++;
 		uaddr += sizeof(u32);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ret = 0;
 bail:
diff -u -p a/infiniband/hw/ipath/ipath_keys.c b/infiniband/hw/ipath/ipath_keys.c
--- a/infiniband/hw/ipath/ipath_keys.c
+++ b/infiniband/hw/ipath/ipath_keys.c
@@ -164,6 +164,11 @@ int ipath_lkey_ok(struct ipath_qp *qp, s
 	off += mr->offset;
 	m = 0;
 	n = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (off >= mr->map[m]->segs[n].length) {
 		off -= mr->map[m]->segs[n].length;
 		n++;
@@ -171,6 +176,12 @@ int ipath_lkey_ok(struct ipath_qp *qp, s
 			m++;
 			n = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	isge->mr = mr;
 	isge->vaddr = mr->map[m]->segs[n].vaddr + off;
@@ -246,6 +257,11 @@ int ipath_rkey_ok(struct ipath_qp *qp, s
 	off += mr->offset;
 	m = 0;
 	n = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (off >= mr->map[m]->segs[n].length) {
 		off -= mr->map[m]->segs[n].length;
 		n++;
@@ -253,6 +269,12 @@ int ipath_rkey_ok(struct ipath_qp *qp, s
 			m++;
 			n = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	sge->mr = mr;
 	sge->vaddr = mr->map[m]->segs[n].vaddr + off;
diff -u -p a/infiniband/hw/ipath/ipath_sdma.c b/infiniband/hw/ipath/ipath_sdma.c
--- a/infiniband/hw/ipath/ipath_sdma.c
+++ b/infiniband/hw/ipath/ipath_sdma.c
@@ -117,6 +117,11 @@ int ipath_sdma_make_progress(struct ipat
 	if (dmahead >= dd->ipath_sdma_descq_cnt)
 		goto done;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dd->ipath_sdma_descq_head != dmahead) {
 		if (txp && txp->flags & IPATH_SDMA_TXREQ_F_FREEDESC &&
 		    dd->ipath_sdma_descq_head == start_idx) {
@@ -147,6 +152,12 @@ int ipath_sdma_make_progress(struct ipat
 			}
 		}
 		progress = 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (progress)
@@ -802,13 +813,24 @@ retry:
 	goto unlock;
 
 unmap:
-	while (tail != dd->ipath_sdma_descq_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (tail != dd->ipath_sdma_descq_tail) {
 		if (!tail)
 			tail = dd->ipath_sdma_descq_cnt - 1;
 		else
 			tail--;
 		unmap_desc(dd, tail);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 ioerr:
 	ret = -EIO;
 unlock:
diff -u -p a/infiniband/hw/ipath/ipath_verbs_mcast.c b/infiniband/hw/ipath/ipath_verbs_mcast.c
--- a/infiniband/hw/ipath/ipath_verbs_mcast.c
+++ b/infiniband/hw/ipath/ipath_verbs_mcast.c
@@ -126,7 +126,12 @@ struct ipath_mcast *ipath_mcast_find(uni
 
 	spin_lock_irqsave(&mcast_lock, flags);
 	n = mcast_tree.rb_node;
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		int ret;
 
 		mcast = rb_entry(n, struct ipath_mcast, rb_node);
@@ -142,6 +147,12 @@ struct ipath_mcast *ipath_mcast_find(uni
 			spin_unlock_irqrestore(&mcast_lock, flags);
 			goto bail;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&mcast_lock, flags);
 
@@ -170,6 +181,11 @@ static int ipath_mcast_add(struct ipath_
 
 	spin_lock_irq(&mcast_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*n) {
 		struct ipath_mcast *tmcast;
 		struct ipath_mcast_qp *p;
@@ -205,6 +221,12 @@ static int ipath_mcast_add(struct ipath_
 		list_add_tail_rcu(&mqp->list, &tmcast->qp_list);
 		ret = EEXIST;
 		goto bail;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_lock(&dev->n_mcast_grps_lock);
diff -u -p a/infiniband/hw/ipath/ipath_mr.c b/infiniband/hw/ipath/ipath_mr.c
--- a/infiniband/hw/ipath/ipath_mr.c
+++ b/infiniband/hw/ipath/ipath_mr.c
@@ -109,9 +109,20 @@ static struct ipath_mr *alloc_mr(int cou
 	goto done;
 
 bail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i) {
 		i--;
 		kfree(mr->mr.map[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	kfree(mr);
 	mr = NULL;
@@ -264,9 +275,20 @@ int ipath_dereg_mr(struct ib_mr *ibmr)
 
 	ipath_free_lkey(&to_idev(ibmr->device)->lk_table, ibmr->lkey);
 	i = mr->mr.mapsz;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i) {
 		i--;
 		kfree(mr->mr.map[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (mr->umem)
diff -u -p a/infiniband/hw/ipath/ipath_qp.c b/infiniband/hw/ipath/ipath_qp.c
--- a/infiniband/hw/ipath/ipath_qp.c
+++ b/infiniband/hw/ipath/ipath_qp.c
@@ -422,11 +422,22 @@ int ipath_error_qp(struct ipath_qp *qp,
 		tail = wq->tail;
 		if (tail >= qp->r_rq.size)
 			tail = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tail != head) {
 			wc.wr_id = get_rwqe_ptr(&qp->r_rq, tail)->wr_id;
 			if (++tail >= qp->r_rq.size)
 				tail = 0;
 			ipath_cq_enter(to_icq(qp->ibqp.recv_cq), &wc, 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		wq->tail = tail;
 
diff -u -p a/infiniband/hw/mthca/mthca_allocator.c b/infiniband/hw/mthca/mthca_allocator.c
--- a/infiniband/hw/mthca/mthca_allocator.c
+++ b/infiniband/hw/mthca/mthca_allocator.c
@@ -215,9 +215,20 @@ int mthca_buf_alloc(struct mthca_dev *de
 
 		memset(buf->direct.buf, 0, size);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (t & ((1 << shift) - 1)) {
 			--shift;
 			npages *= 2;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		dma_list = kmalloc(npages * sizeof *dma_list, GFP_KERNEL);
diff -u -p a/infiniband/hw/mthca/mthca_memfree.c b/infiniband/hw/mthca/mthca_memfree.c
--- a/infiniband/hw/mthca/mthca_memfree.c
+++ b/infiniband/hw/mthca/mthca_memfree.c
@@ -333,9 +333,20 @@ int mthca_table_get_range(struct mthca_d
 	return 0;
 
 fail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i > start) {
 		i -= inc;
 		mthca_table_put(dev, table, i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return err;
diff -u -p a/infiniband/hw/mthca/mthca_eq.c b/infiniband/hw/mthca/mthca_eq.c
--- a/infiniband/hw/mthca/mthca_eq.c
+++ b/infiniband/hw/mthca/mthca_eq.c
@@ -264,6 +264,11 @@ static int mthca_eq_int(struct mthca_dev
 	int eqes_found = 0;
 	int set_ci = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((eqe = next_eqe_sw(eq))) {
 		/*
 		 * Make sure we read EQ entry contents after we've
@@ -379,6 +384,12 @@ static int mthca_eq_int(struct mthca_dev
 			set_eq_ci(dev, eq, eq->cons_index);
 			set_ci = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/infiniband/hw/mthca/mthca_mr.c b/infiniband/hw/mthca/mthca_mr.c
--- a/infiniband/hw/mthca/mthca_mr.c
+++ b/infiniband/hw/mthca/mthca_mr.c
@@ -104,11 +104,22 @@ static u32 mthca_buddy_alloc(struct mthc
 	clear_bit(seg, buddy->bits[o]);
 	--buddy->num_free[o];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (o > order) {
 		--o;
 		seg <<= 1;
 		set_bit(seg ^ 1, buddy->bits[o]);
 		++buddy->num_free[o];
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock(&buddy->lock);
@@ -124,11 +135,22 @@ static void mthca_buddy_free(struct mthc
 
 	spin_lock(&buddy->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (test_bit(seg ^ 1, buddy->bits[order])) {
 		clear_bit(seg ^ 1, buddy->bits[order]);
 		--buddy->num_free[order];
 		seg >>= 1;
 		++order;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	set_bit(seg, buddy->bits[order]);
diff -u -p a/infiniband/hw/mthca/mthca_cmd.c b/infiniband/hw/mthca/mthca_cmd.c
--- a/infiniband/hw/mthca/mthca_cmd.c
+++ b/infiniband/hw/mthca/mthca_cmd.c
@@ -239,9 +239,20 @@ static int mthca_cmd_post_hcr(struct mth
 	if (event) {
 		unsigned long end = jiffies + GO_BIT_TIMEOUT;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (go_bit(dev) && time_before(jiffies, end)) {
 			set_current_state(TASK_RUNNING);
 			schedule();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -357,9 +368,20 @@ static int mthca_cmd_poll(struct mthca_d
 		goto out;
 
 	end = timeout + jiffies;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (go_bit(dev) && time_before(jiffies, end)) {
 		set_current_state(TASK_RUNNING);
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (go_bit(dev)) {
diff -u -p a/infiniband/ulp/iser/iscsi_iser.c b/infiniband/ulp/iser/iscsi_iser.c
--- a/infiniband/ulp/iser/iscsi_iser.c
+++ b/infiniband/ulp/iser/iscsi_iser.c
@@ -216,7 +216,12 @@ iscsi_iser_task_xmit_unsol_data(struct i
 	int error = 0;
 
 	/* Send data-out PDUs while there's still unsolicited data to send */
-	while (iscsi_task_has_unsol_data(task)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (iscsi_task_has_unsol_data(task)) {
 		iscsi_prep_data_out_pdu(task, r2t, &hdr);
 		iser_dbg("Sending data-out: itt 0x%x, data count %d\n",
 			   hdr.itt, r2t->data_count);
@@ -231,7 +236,13 @@ iscsi_iser_task_xmit_unsol_data(struct i
 		r2t->sent += r2t->data_count;
 		iser_dbg("Need to send %d more as data-out PDUs\n",
 			   r2t->data_length - r2t->sent);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 iscsi_iser_task_xmit_unsol_data_exit:
 	return error;
diff -u -p a/infiniband/ulp/ipoib/ipoib_main.c b/infiniband/ulp/ipoib/ipoib_main.c
--- a/infiniband/ulp/ipoib/ipoib_main.c
+++ b/infiniband/ulp/ipoib/ipoib_main.c
@@ -215,7 +215,12 @@ static struct ipoib_path *__path_find(st
 	struct ipoib_path *path;
 	int ret;
 
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		path = rb_entry(n, struct ipoib_path, rb_node);
 
 		ret = memcmp(gid, path->pathrec.dgid.raw,
@@ -227,6 +232,12 @@ static struct ipoib_path *__path_find(st
 			n = n->rb_right;
 		else
 			return path;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return NULL;
@@ -240,7 +251,12 @@ static int __path_add(struct net_device
 	struct ipoib_path *tpath;
 	int ret;
 
-	while (*n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*n) {
 		pn = *n;
 		tpath = rb_entry(pn, struct ipoib_path, rb_node);
 
@@ -252,6 +268,12 @@ static int __path_add(struct net_device
 			n = &pn->rb_right;
 		else
 			return -EEXIST;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	rb_link_node(&path->rb_node, pn, n);
@@ -489,11 +511,22 @@ static void path_rec_completion(int stat
 	if (old_ah)
 		ipoib_put_ah(old_ah);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = __skb_dequeue(&skqueue))) {
 		skb->dev = dev;
 		if (dev_queue_xmit(skb))
 			ipoib_warn(priv, "dev_queue_xmit failed "
 				   "to requeue packet\n");
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 	}
 }
 
@@ -903,9 +936,20 @@ void ipoib_neigh_free(struct net_device
 {
 	struct sk_buff *skb;
 	*to_ipoib_neigh(neigh->neighbour) = NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = __skb_dequeue(&neigh->queue))) {
 		++dev->stats.tx_dropped;
 		dev_kfree_skb_any(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (ipoib_cm_get(neigh))
 		ipoib_cm_destroy_tx(ipoib_cm_get(neigh));
diff -u -p a/infiniband/ulp/ipoib/ipoib_cm.c b/infiniband/ulp/ipoib/ipoib_cm.c
--- a/infiniband/ulp/ipoib/ipoib_cm.c
+++ b/infiniband/ulp/ipoib/ipoib_cm.c
@@ -904,6 +904,11 @@ void ipoib_cm_dev_stop(struct net_device
 	priv->cm.id = NULL;
 
 	spin_lock_irq(&priv->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&priv->cm.passive_ids)) {
 		p = list_entry(priv->cm.passive_ids.next, typeof(*p), list);
 		list_move(&p->list, &priv->cm.rx_error_list);
@@ -913,6 +918,12 @@ void ipoib_cm_dev_stop(struct net_device
 		if (ret)
 			ipoib_warn(priv, "unable to move qp to error state: %d\n", ret);
 		spin_lock_irq(&priv->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Wait for all RX to be drained */
@@ -1001,11 +1012,22 @@ static int ipoib_cm_rep_handler(struct i
 			__skb_queue_tail(&skqueue, skb);
 	spin_unlock_irq(&priv->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = __skb_dequeue(&skqueue))) {
 		skb->dev = p->dev;
 		if (dev_queue_xmit(skb))
 			ipoib_warn(priv, "dev_queue_xmit failed "
 				   "to requeue packet\n");
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	ret = ib_send_cm_rtu(cm_id, NULL, 0);
@@ -1304,6 +1326,11 @@ static void ipoib_cm_tx_start(struct wor
 	netif_tx_lock_bh(dev);
 	spin_lock_irqsave(&priv->lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&priv->cm.start_list)) {
 		p = list_entry(priv->cm.start_list.next, typeof(*p), list);
 		list_del_init(&p->list);
@@ -1331,6 +1358,12 @@ static void ipoib_cm_tx_start(struct wor
 			list_del(&p->list);
 			kfree(p);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -1348,6 +1381,11 @@ static void ipoib_cm_tx_reap(struct work
 	netif_tx_lock_bh(dev);
 	spin_lock_irqsave(&priv->lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&priv->cm.reap_list)) {
 		p = list_entry(priv->cm.reap_list.next, typeof(*p), list);
 		list_del(&p->list);
@@ -1356,6 +1394,12 @@ static void ipoib_cm_tx_reap(struct work
 		ipoib_cm_tx_destroy(p);
 		netif_tx_lock_bh(dev);
 		spin_lock_irqsave(&priv->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -1374,6 +1418,11 @@ static void ipoib_cm_skb_reap(struct wor
 	netif_tx_lock_bh(dev);
 	spin_lock_irqsave(&priv->lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&priv->cm.skb_queue))) {
 		spin_unlock_irqrestore(&priv->lock, flags);
 		netif_tx_unlock_bh(dev);
@@ -1388,6 +1437,12 @@ static void ipoib_cm_skb_reap(struct wor
 
 		netif_tx_lock_bh(dev);
 		spin_lock_irqsave(&priv->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&priv->lock, flags);
diff -u -p a/infiniband/ulp/ipoib/ipoib_ib.c b/infiniband/ulp/ipoib/ipoib_ib.c
--- a/infiniband/ulp/ipoib/ipoib_ib.c
+++ b/infiniband/ulp/ipoib/ipoib_ib.c
@@ -830,6 +830,11 @@ int ipoib_ib_dev_stop(struct net_device
 	/* Wait for all sends and receives to complete */
 	begin = jiffies;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (priv->tx_head != priv->tx_tail || recvs_pending(dev)) {
 		if (time_after(jiffies, begin + 5 * HZ)) {
 			ipoib_warn(priv, "timing out; %d sends %d receives not completed\n",
@@ -866,6 +871,12 @@ int ipoib_ib_dev_stop(struct net_device
 		ipoib_drain_cq(dev);
 
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ipoib_dbg(priv, "All sends and receives done.\n");
diff -u -p a/infiniband/ulp/ipoib/ipoib_multicast.c b/infiniband/ulp/ipoib/ipoib_multicast.c
--- a/infiniband/ulp/ipoib/ipoib_multicast.c
+++ b/infiniband/ulp/ipoib/ipoib_multicast.c
@@ -95,9 +95,20 @@ static void ipoib_mcast_free(struct ipoi
 	if (mcast->ah)
 		ipoib_put_ah(mcast->ah);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!skb_queue_empty(&mcast->pkt_queue)) {
 		++tx_dropped;
 		dev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	netif_tx_lock_bh(dev);
@@ -132,7 +143,12 @@ static struct ipoib_mcast *__ipoib_mcast
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct rb_node *n = priv->multicast_tree.rb_node;
 
-	while (n) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (n) {
 		struct ipoib_mcast *mcast;
 		int ret;
 
@@ -146,6 +162,12 @@ static struct ipoib_mcast *__ipoib_mcast
 			n = n->rb_right;
 		else
 			return mcast;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return NULL;
@@ -156,6 +178,11 @@ static int __ipoib_mcast_add(struct net_
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct rb_node **n = &priv->multicast_tree.rb_node, *pn = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*n) {
 		struct ipoib_mcast *tmcast;
 		int ret;
@@ -171,6 +198,12 @@ static int __ipoib_mcast_add(struct net_
 			n = &pn->rb_right;
 		else
 			return -EEXIST;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	rb_link_node(&mcast->rb_node, pn, n);
@@ -269,6 +302,11 @@ static int ipoib_mcast_join_finish(struc
 
 	/* actually send any queued packets */
 	netif_tx_lock_bh(dev);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!skb_queue_empty(&mcast->pkt_queue)) {
 		struct sk_buff *skb = skb_dequeue(&mcast->pkt_queue);
 
@@ -280,6 +318,12 @@ static int ipoib_mcast_join_finish(struc
 			ipoib_warn(priv, "dev_queue_xmit failed to requeue packet\n");
 
 		netif_tx_lock_bh(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	netif_tx_unlock_bh(dev);
 
@@ -307,9 +351,20 @@ ipoib_mcast_sendonly_join_complete(int s
 
 		/* Flush out any queued packets */
 		netif_tx_lock_bh(dev);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!skb_queue_empty(&mcast->pkt_queue)) {
 			++dev->stats.tx_dropped;
 			dev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		netif_tx_unlock_bh(dev);
 
diff -u -p a/infiniband/core/cm.c b/infiniband/core/cm.c
--- a/infiniband/core/cm.c
+++ b/infiniband/core/cm.c
@@ -502,7 +502,12 @@ static struct cm_id_private * cm_insert_
 	__be64 service_mask = cm_id_priv->id.service_mask;
 	int data_cmp;
 
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_cm_id_priv = rb_entry(parent, struct cm_id_private,
 					  service_node);
@@ -526,6 +531,12 @@ static struct cm_id_private * cm_insert_
 			link = &(*link)->rb_left;
 		else
 			link = &(*link)->rb_right;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	rb_link_node(&cm_id_priv->service_node, parent, link);
 	rb_insert_color(&cm_id_priv->service_node, &cm.listen_service_table);
@@ -540,7 +551,12 @@ static struct cm_id_private * cm_find_li
 	struct cm_id_private *cm_id_priv;
 	int data_cmp;
 
-	while (node) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (node) {
 		cm_id_priv = rb_entry(node, struct cm_id_private, service_node);
 		data_cmp = cm_compare_private_data(private_data,
 						   cm_id_priv->compare_data);
@@ -561,6 +577,12 @@ static struct cm_id_private * cm_find_li
 			node = node->rb_left;
 		else
 			node = node->rb_right;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return NULL;
 }
@@ -574,7 +596,12 @@ static struct cm_timewait_info * cm_inse
 	__be64 remote_ca_guid = timewait_info->remote_ca_guid;
 	__be32 remote_id = timewait_info->work.remote_id;
 
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_timewait_info = rb_entry(parent, struct cm_timewait_info,
 					     remote_id_node);
@@ -588,6 +615,12 @@ static struct cm_timewait_info * cm_inse
 			link = &(*link)->rb_right;
 		else
 			return cur_timewait_info;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	timewait_info->inserted_remote_id = 1;
 	rb_link_node(&timewait_info->remote_id_node, parent, link);
@@ -601,7 +634,12 @@ static struct cm_timewait_info * cm_find
 	struct rb_node *node = cm.remote_id_table.rb_node;
 	struct cm_timewait_info *timewait_info;
 
-	while (node) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (node) {
 		timewait_info = rb_entry(node, struct cm_timewait_info,
 					 remote_id_node);
 		if (be32_lt(remote_id, timewait_info->work.remote_id))
@@ -614,6 +652,12 @@ static struct cm_timewait_info * cm_find
 			node = node->rb_right;
 		else
 			return timewait_info;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return NULL;
 }
@@ -627,7 +671,12 @@ static struct cm_timewait_info * cm_inse
 	__be64 remote_ca_guid = timewait_info->remote_ca_guid;
 	__be32 remote_qpn = timewait_info->remote_qpn;
 
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_timewait_info = rb_entry(parent, struct cm_timewait_info,
 					     remote_qp_node);
@@ -641,6 +690,12 @@ static struct cm_timewait_info * cm_inse
 			link = &(*link)->rb_right;
 		else
 			return cur_timewait_info;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	timewait_info->inserted_remote_qp = 1;
 	rb_link_node(&timewait_info->remote_qp_node, parent, link);
@@ -657,7 +712,12 @@ static struct cm_id_private * cm_insert_
 	union ib_gid *port_gid = &cm_id_priv->av.dgid;
 	__be32 remote_id = cm_id_priv->id.remote_id;
 
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_cm_id_priv = rb_entry(parent, struct cm_id_private,
 					  sidr_id_node);
@@ -676,6 +736,12 @@ static struct cm_id_private * cm_insert_
 			else
 				return cur_cm_id_priv;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	rb_link_node(&cm_id_priv->sidr_id_node, parent, link);
 	rb_insert_color(&cm_id_priv->sidr_id_node, &cm.remote_sidr_table);
@@ -1318,6 +1384,11 @@ static void cm_process_work(struct cm_id
 	ret = cm_id_priv->id.cm_handler(&cm_id_priv->id, &work->cm_event);
 	cm_free_work(work);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!ret && !atomic_add_negative(-1, &cm_id_priv->work_count)) {
 		spin_lock_irq(&cm_id_priv->lock);
 		work = cm_dequeue_work(cm_id_priv);
@@ -1326,6 +1397,12 @@ static void cm_process_work(struct cm_id
 		ret = cm_id_priv->id.cm_handler(&cm_id_priv->id,
 						&work->cm_event);
 		cm_free_work(work);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	cm_deref_id(cm_id_priv);
 	if (ret)
diff -u -p a/infiniband/core/mad_rmpp.c b/infiniband/core/mad_rmpp.c
--- a/infiniband/core/mad_rmpp.c
+++ b/infiniband/core/mad_rmpp.c
@@ -420,10 +420,21 @@ static void update_seg_num(struct mad_rm
 {
 	struct list_head *rmpp_list = &rmpp_recv->rmpp_wc->rmpp_list;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (new_buf && (get_seg_num(new_buf) == rmpp_recv->seg_num + 1)) {
 		rmpp_recv->cur_seg_buf = new_buf;
 		rmpp_recv->seg_num++;
 		new_buf = get_next_seg(rmpp_list, new_buf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/infiniband/core/cma.c b/infiniband/core/cma.c
--- a/infiniband/core/cma.c
+++ b/infiniband/core/cma.c
@@ -830,7 +830,12 @@ static void cma_cancel_listens(struct rd
 	mutex_lock(&lock);
 	list_del(&id_priv->list);
 
-	while (!list_empty(&id_priv->listen_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&id_priv->listen_list)) {
 		dev_id_priv = list_entry(id_priv->listen_list.next,
 					 struct rdma_id_private, listen_list);
 		/* sync with device removal to avoid duplicate destruction */
@@ -840,6 +845,12 @@ static void cma_cancel_listens(struct rd
 
 		rdma_destroy_id(&dev_id_priv->id);
 		mutex_lock(&lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	mutex_unlock(&lock);
 }
@@ -884,7 +895,12 @@ static void cma_leave_mc_groups(struct r
 {
 	struct cma_multicast *mc;
 
-	while (!list_empty(&id_priv->mc_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&id_priv->mc_list)) {
 		mc = container_of(id_priv->mc_list.next,
 				  struct cma_multicast, list);
 		list_del(&mc->list);
@@ -899,6 +915,12 @@ static void cma_leave_mc_groups(struct r
 		default:
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -3322,7 +3344,12 @@ static void cma_process_remove(struct cm
 	int ret;
 
 	mutex_lock(&lock);
-	while (!list_empty(&cma_dev->id_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&cma_dev->id_list)) {
 		id_priv = list_entry(cma_dev->id_list.next,
 				     struct rdma_id_private, list);
 
@@ -3337,6 +3364,12 @@ static void cma_process_remove(struct cm
 			rdma_destroy_id(&id_priv->id);
 
 		mutex_lock(&lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&lock);
 
diff -u -p a/infiniband/core/mad.c b/infiniband/core/mad.c
--- a/infiniband/core/mad.c
+++ b/infiniband/core/mad.c
@@ -2370,7 +2370,12 @@ static void local_completions(struct wor
 		container_of(work, struct ib_mad_agent_private, local_work);
 
 	spin_lock_irqsave(&mad_agent_priv->lock, flags);
-	while (!list_empty(&mad_agent_priv->local_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&mad_agent_priv->local_list)) {
 		local = list_entry(mad_agent_priv->local_list.next,
 				   struct ib_mad_local_private,
 				   completion_list);
@@ -2432,6 +2437,12 @@ local_send_completion:
 		if (free_mad)
 			kmem_cache_free(ib_mad_cache, local->mad_priv);
 		kfree(local);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&mad_agent_priv->lock, flags);
 }
@@ -2612,7 +2623,12 @@ static void cleanup_recv_queue(struct ib
 	if (!qp_info->qp)
 		return;
 
-	while (!list_empty(&qp_info->recv_queue.list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&qp_info->recv_queue.list)) {
 
 		mad_list = list_entry(qp_info->recv_queue.list.next,
 				      struct ib_mad_list_head, list);
@@ -2631,6 +2647,12 @@ static void cleanup_recv_queue(struct ib
 				      sizeof(struct ib_mad_private_header),
 				    DMA_FROM_DEVICE);
 		kmem_cache_free(ib_mad_cache, recv);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	qp_info->recv_queue.count = 0;
@@ -2966,6 +2988,11 @@ error_agent:
 error:
 	i--;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i >= start) {
 		if (ib_agent_port_close(device, i))
 			printk(KERN_ERR PFX "Couldn't close %s port %d "
@@ -2975,6 +3002,12 @@ error:
 			printk(KERN_ERR PFX "Couldn't close %s port %d\n",
 			       device->name, i);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/infiniband/core/ucm.c b/infiniband/core/ucm.c
--- a/infiniband/core/ucm.c
+++ b/infiniband/core/ucm.c
@@ -158,7 +158,12 @@ static void ib_ucm_cleanup_events(struct
 
 	mutex_lock(&ctx->file->file_mutex);
 	list_del(&ctx->file_list);
-	while (!list_empty(&ctx->events)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ctx->events)) {
 
 		uevent = list_entry(ctx->events.next,
 				    struct ib_ucm_event, ctx_list);
@@ -172,6 +177,12 @@ static void ib_ucm_cleanup_events(struct
 
 		kfree(uevent);
 		mutex_lock(&ctx->file->file_mutex);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&ctx->file->file_mutex);
 }
@@ -409,7 +420,12 @@ static ssize_t ib_ucm_event(struct ib_uc
 		return -EFAULT;
 
 	mutex_lock(&file->file_mutex);
-	while (list_empty(&file->events)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->events)) {
 		mutex_unlock(&file->file_mutex);
 
 		if (file->filp->f_flags & O_NONBLOCK)
@@ -420,6 +436,12 @@ static ssize_t ib_ucm_event(struct ib_uc
 			return -ERESTARTSYS;
 
 		mutex_lock(&file->file_mutex);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	uevent = list_entry(file->events.next, struct ib_ucm_event, file_list);
@@ -1185,7 +1207,12 @@ static int ib_ucm_close(struct inode *in
 	struct ib_ucm_context *ctx;
 
 	mutex_lock(&file->file_mutex);
-	while (!list_empty(&file->ctxs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&file->ctxs)) {
 		ctx = list_entry(file->ctxs.next,
 				 struct ib_ucm_context, file_list);
 		mutex_unlock(&file->file_mutex);
@@ -1199,6 +1226,12 @@ static int ib_ucm_close(struct inode *in
 		kfree(ctx);
 
 		mutex_lock(&file->file_mutex);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	mutex_unlock(&file->file_mutex);
 	kfree(file);
diff -u -p a/infiniband/core/uverbs_main.c b/infiniband/core/uverbs_main.c
--- a/infiniband/core/uverbs_main.c
+++ b/infiniband/core/uverbs_main.c
@@ -294,7 +294,12 @@ static ssize_t ib_uverbs_event_read(stru
 
 	spin_lock_irq(&file->lock);
 
-	while (list_empty(&file->event_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->event_list)) {
 		spin_unlock_irq(&file->lock);
 
 		if (filp->f_flags & O_NONBLOCK)
@@ -305,6 +310,12 @@ static ssize_t ib_uverbs_event_read(stru
 			return -ERESTARTSYS;
 
 		spin_lock_irq(&file->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	event = list_entry(file->event_list.next, struct ib_uverbs_event, list);
diff -u -p a/infiniband/core/iwcm.c b/infiniband/core/iwcm.c
--- a/infiniband/core/iwcm.c
+++ b/infiniband/core/iwcm.c
@@ -853,7 +853,12 @@ static void cm_work_handler(struct work_
 
 	spin_lock_irqsave(&cm_id_priv->lock, flags);
 	empty = list_empty(&cm_id_priv->work_list);
-	while (!empty) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!empty) {
 		work = list_entry(cm_id_priv->work_list.next,
 				  struct iwcm_work, list);
 		list_del_init(&work->list);
@@ -877,6 +882,12 @@ static void cm_work_handler(struct work_
 			return;
 		}
 		spin_lock_irqsave(&cm_id_priv->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&cm_id_priv->lock, flags);
 }
diff -u -p a/infiniband/core/user_mad.c b/infiniband/core/user_mad.c
--- a/infiniband/core/user_mad.c
+++ b/infiniband/core/user_mad.c
@@ -333,7 +333,12 @@ static ssize_t ib_umad_read(struct file
 
 	mutex_lock(&file->mutex);
 
-	while (list_empty(&file->recv_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->recv_list)) {
 		mutex_unlock(&file->mutex);
 
 		if (filp->f_flags & O_NONBLOCK)
@@ -344,6 +349,12 @@ static ssize_t ib_umad_read(struct file
 			return -ERESTARTSYS;
 
 		mutex_lock(&file->mutex);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	packet = list_entry(file->recv_list.next, struct ib_umad_packet, list);
diff -u -p a/infiniband/core/ucma.c b/infiniband/core/ucma.c
--- a/infiniband/core/ucma.c
+++ b/infiniband/core/ucma.c
@@ -325,7 +325,12 @@ static ssize_t ucma_get_event(struct ucm
 		return -EFAULT;
 
 	mutex_lock(&file->mut);
-	while (list_empty(&file->event_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (list_empty(&file->event_list)) {
 		mutex_unlock(&file->mut);
 
 		if (file->filp->f_flags & O_NONBLOCK)
@@ -336,6 +341,12 @@ static ssize_t ucma_get_event(struct ucm
 			return -ERESTARTSYS;
 
 		mutex_lock(&file->mut);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	uevent = list_entry(file->event_list.next, struct ucma_event, list);
diff -u -p a/infiniband/core/verbs.c b/infiniband/core/verbs.c
--- a/infiniband/core/verbs.c
+++ b/infiniband/core/verbs.c
@@ -1231,11 +1231,22 @@ int ib_dealloc_xrcd(struct ib_xrcd *xrcd
 	if (atomic_read(&xrcd->usecnt))
 		return -EBUSY;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&xrcd->tgt_qp_list)) {
 		qp = list_entry(xrcd->tgt_qp_list.next, struct ib_qp, xrcd_list);
 		ret = ib_destroy_qp(qp);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return xrcd->device->dealloc_xrcd(xrcd);
diff -u -p a/infiniband/core/umem.c b/infiniband/core/umem.c
--- a/infiniband/core/umem.c
+++ b/infiniband/core/umem.c
@@ -148,7 +148,12 @@ struct ib_umem *ib_umem_get(struct ib_uc
 	cur_base = addr & PAGE_MASK;
 
 	ret = 0;
-	while (npages) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (npages) {
 		ret = get_user_pages(current, current->mm, cur_base,
 				     min_t(unsigned long, npages,
 					   PAGE_SIZE / sizeof (struct page *)),
@@ -162,7 +167,12 @@ struct ib_umem *ib_umem_get(struct ib_uc
 
 		off = 0;
 
-		while (ret) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (ret) {
 			chunk = kmalloc(sizeof *chunk + sizeof (struct scatterlist) *
 					min_t(int, ret, IB_UMEM_MAX_PAGE_CHUNK),
 					GFP_KERNEL);
@@ -197,10 +207,22 @@ struct ib_umem *ib_umem_get(struct ib_uc
 			ret -= chunk->nents;
 			off += chunk->nents;
 			list_add_tail(&chunk->list, &umem->chunk_list);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		ret = 0;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	if (ret < 0) {
diff -u -p a/infiniband/core/uverbs_cmd.c b/infiniband/core/uverbs_cmd.c
--- a/infiniband/core/uverbs_cmd.c
+++ b/infiniband/core/uverbs_cmd.c
@@ -627,6 +627,11 @@ static int xrcd_table_insert(struct ib_u
 	entry->xrcd  = xrcd;
 	entry->inode = inode;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*p) {
 		parent = *p;
 		scan = rb_entry(parent, struct xrcd_table_entry, node);
@@ -639,6 +644,12 @@ static int xrcd_table_insert(struct ib_u
 			kfree(entry);
 			return -EEXIST;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rb_link_node(&entry->node, parent, p);
@@ -653,6 +664,11 @@ static struct xrcd_table_entry *xrcd_tab
 	struct xrcd_table_entry *entry;
 	struct rb_node *p = dev->xrcd_tree.rb_node;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		entry = rb_entry(p, struct xrcd_table_entry, node);
 
@@ -662,6 +678,12 @@ static struct xrcd_table_entry *xrcd_tab
 			p = p->rb_right;
 		else
 			return entry;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return NULL;
@@ -2053,13 +2075,24 @@ ssize_t ib_uverbs_post_send(struct ib_uv
 out_put:
 	put_qp_read(qp);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (wr) {
 		if (is_ud && wr->wr.ud.ah)
 			put_ah_read(wr->wr.ud.ah);
 		next = wr->next;
 		kfree(wr);
 		wr = next;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	kfree(user_wr);
@@ -2143,10 +2176,21 @@ static struct ib_recv_wr *ib_uverbs_unma
 err:
 	kfree(user_wr);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (wr) {
 		next = wr->next;
 		kfree(wr);
 		wr = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ERR_PTR(ret);
@@ -2192,10 +2236,21 @@ ssize_t ib_uverbs_post_recv(struct ib_uv
 		ret = -EFAULT;
 
 out:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (wr) {
 		next = wr->next;
 		kfree(wr);
 		wr = next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return ret ? ret : in_len;
@@ -2241,10 +2296,21 @@ ssize_t ib_uverbs_post_srq_recv(struct i
 		ret = -EFAULT;
 
 out:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (wr) {
 		next = wr->next;
 		kfree(wr);
 		wr = next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return ret ? ret : in_len;
diff -u -p a/infiniband/core/multicast.c b/infiniband/core/multicast.c
--- a/infiniband/core/multicast.c
+++ b/infiniband/core/multicast.c
@@ -134,6 +134,11 @@ static struct mcast_group *mcast_find(st
 	struct mcast_group *group;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (node) {
 		group = rb_entry(node, struct mcast_group, node);
 		ret = memcmp(mgid->raw, group->rec.mgid.raw, sizeof *mgid);
@@ -144,6 +149,12 @@ static struct mcast_group *mcast_find(st
 			node = node->rb_left;
 		else
 			node = node->rb_right;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return NULL;
 }
@@ -157,7 +168,12 @@ static struct mcast_group *mcast_insert(
 	struct mcast_group *cur_group;
 	int ret;
 
-	while (*link) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (*link) {
 		parent = *link;
 		cur_group = rb_entry(parent, struct mcast_group, node);
 
@@ -171,6 +187,12 @@ static struct mcast_group *mcast_insert(
 			link = &(*link)->rb_left;
 		else
 			return cur_group;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	rb_link_node(&group->node, parent, link);
 	rb_insert_color(&group->node, &port->table);
@@ -406,7 +428,12 @@ static void process_group_error(struct m
 	    group->pkey_index == pkey_index)
 		goto out;
 
-	while (!list_empty(&group->active_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&group->active_list)) {
 		member = list_entry(group->active_list.next,
 				    struct mcast_member, list);
 		atomic_inc(&member->refcount);
@@ -421,6 +448,12 @@ static void process_group_error(struct m
 		if (ret)
 			ib_sa_free_multicast(&member->multicast);
 		spin_lock_irq(&group->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	group->rec.join_state = 0;
diff -u -p a/block/aoe/aoedev.c b/block/aoe/aoedev.c
--- a/block/aoe/aoedev.c
+++ b/block/aoe/aoedev.c
@@ -83,12 +83,23 @@ aoedev_downdev(struct aoedev *d)
 	d->inprocess = NULL;
 	d->htgt = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&d->bufq)) {
 		buf = container_of(d->bufq.next, struct buf, bufs);
 		list_del(d->bufq.next);
 		bio = buf->bio;
 		mempool_free(buf, d->bufpool);
 		bio_endio(bio, -EIO);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (d->gd)
@@ -138,6 +149,11 @@ aoedev_flush(const char __user *str, siz
 
 	spin_lock_irqsave(&devlist_lock, flags);
 	dd = &devlist;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((d = *dd)) {
 		spin_lock(&d->lock);
 		if ((!all && (d->flags & DEVFL_UP))
@@ -153,12 +169,29 @@ aoedev_flush(const char __user *str, siz
 		spin_unlock(&d->lock);
 		d->next = rmd;
 		rmd = d;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&devlist_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((d = rmd)) {
 		rmd = d->next;
 		del_timer_sync(&d->timer);
 		aoedev_freedev(d);	/* must be able to sleep */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -257,6 +290,11 @@ aoedev_exit(void)
 	struct aoedev *d;
 	ulong flags;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((d = devlist)) {
 		devlist = d->next;
 
@@ -267,6 +305,12 @@ aoedev_exit(void)
 
 		del_timer_sync(&d->timer);
 		aoedev_freedev(d);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/block/drbd/drbd_worker.c b/block/drbd/drbd_worker.c
--- a/block/drbd/drbd_worker.c
+++ b/block/drbd/drbd_worker.c
@@ -264,11 +264,22 @@ void drbd_csum_ee(struct drbd_conf *mdev
 	sg_init_table(&sg, 1);
 	crypto_hash_init(&desc);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((tmp = page_chain_next(page))) {
 		/* all but the last page will be fully used */
 		sg_set_page(&sg, page, PAGE_SIZE, 0);
 		crypto_hash_update(&desc, &sg, sg.length);
 		page = tmp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* and now the last, possibly only partially used page */
 	len = e->size & (PAGE_SIZE - 1);
@@ -1422,6 +1433,11 @@ static int sync_after_error(struct drbd_
 
 	/* check for loops */
 	odev = minor_to_mdev(o_minor);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (odev == mdev)
 			return ERR_SYNC_AFTER_CYCLE;
@@ -1432,6 +1448,12 @@ static int sync_after_error(struct drbd_
 
 		/* follow the dependency chain */
 		odev = minor_to_mdev(odev->sync_conf.after);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/block/drbd/drbd_bitmap.c b/block/drbd/drbd_bitmap.c
--- a/block/drbd/drbd_bitmap.c
+++ b/block/drbd/drbd_bitmap.c
@@ -577,6 +577,11 @@ static void bm_memset(struct drbd_bitmap
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (offset < end) {
 		do_now = min_t(size_t, ALIGN(offset + 1, LWPP), end) - offset;
 		idx = bm_word_to_page_idx(b, offset);
@@ -590,6 +595,12 @@ static void bm_memset(struct drbd_bitmap
 		bm_unmap(p_addr);
 		bm_set_page_need_writeout(b->bm_pages[idx]);
 		offset += do_now;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/block/drbd/drbd_receiver.c b/block/drbd/drbd_receiver.c
--- a/block/drbd/drbd_receiver.c
+++ b/block/drbd/drbd_receiver.c
@@ -423,12 +423,23 @@ void _drbd_wait_ee_list_empty(struct drb
 
 	/* avoids spin_lock/unlock
 	 * and calling prepare_to_wait in the fast path */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(head)) {
 		prepare_to_wait(&mdev->ee_wait, &wait, TASK_UNINTERRUPTIBLE);
 		spin_unlock_irq(&mdev->req_lock);
 		io_schedule();
 		finish_wait(&mdev->ee_wait, &wait);
 		spin_lock_irq(&mdev->req_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1148,10 +1159,21 @@ next_bio:
 	return 0;
 
 fail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bios) {
 		bio = bios;
 		bios = bios->bi_next;
 		bio_put(bio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return err;
 }
@@ -3682,6 +3704,11 @@ static void drbdd(struct drbd_conf *mdev
 	size_t shs; /* sub header size */
 	int rv;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (get_t_state(&mdev->receiver) == Running) {
 		drbd_thread_current_set_cpu(mdev);
 		if (!drbd_recv_header(mdev, &cmd, &packet_size))
@@ -3714,6 +3741,12 @@ static void drbdd(struct drbd_conf *mdev
 			    cmdname(cmd), packet_size);
 			goto err_out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+	else {
+			break;
+	}
 	}
 
 	if (0) {
diff -u -p a/block/drbd/drbd_main.c b/block/drbd/drbd_main.c
--- a/block/drbd/drbd_main.c
+++ b/block/drbd/drbd_main.c
@@ -3117,11 +3117,22 @@ static void drbd_destroy_mempools(void)
 {
 	struct page *page;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (drbd_pp_pool) {
 		page = drbd_pp_pool;
 		drbd_pp_pool = (struct page *)page_private(page);
 		__free_page(page);
 		drbd_pp_vacant--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* D_ASSERT(atomic_read(&drbd_pp_vacant)==0); */
diff -u -p a/block/ub.c b/block/ub.c
--- a/block/ub.c
+++ b/block/ub.c
@@ -510,6 +510,11 @@ static void ub_cleanup(struct ub_dev *sc
 	struct ub_lun *lun;
 	struct request_queue *q;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&sc->luns)) {
 		p = sc->luns.next;
 		lun = list_entry(p, struct ub_lun, link);
@@ -532,6 +537,12 @@ static void ub_cleanup(struct ub_dev *sc
 
 		ub_id_put(lun->id);
 		kfree(lun);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	usb_set_intfdata(sc->intf, NULL);
diff -u -p a/block/xd.c b/block/xd.c
--- a/block/xd.c
+++ b/block/xd.c
@@ -317,6 +317,11 @@ static void do_xd_request (struct reques
 		return;
 
 	req = blk_fetch_request(q);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (req) {
 		unsigned block = blk_rq_pos(req);
 		unsigned count = blk_rq_cur_sectors(req);
@@ -335,6 +340,12 @@ static void do_xd_request (struct reques
 		/* wrap up, 0 = success, -errno = fail */
 		if (!__blk_end_request_cur(req, res))
 			req = blk_fetch_request(q);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
@@ -408,6 +419,11 @@ static int xd_readwrite (u_char operatio
 	control = p->control;
 	if (!xd_dma_buffer)
 		xd_dma_buffer = (char *)xd_dma_mem_alloc(xd_maxsectors * 0x200);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		temp = count < xd_maxsectors ? count : xd_maxsectors;
 
@@ -464,6 +480,12 @@ static int xd_readwrite (u_char operatio
 				buffer[i] = xd_dma_buffer[i];
 
 		count -= temp, buffer += temp * 0x200, block += temp;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	spin_lock_irq(&xd_lock);
 	return 0;
@@ -594,6 +616,11 @@ static u_int xd_command (u_char *command
 	if (xd_waitport(XD_STATUS,STAT_SELECT,STAT_SELECT,timeout))
 		return (1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!complete) {
 		if (xd_waitport(XD_STATUS,STAT_READY,STAT_READY,timeout))
 			return (1);
@@ -623,6 +650,12 @@ static u_int xd_command (u_char *command
 				complete = 1;
 				break;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	csb = inb(XD_DATA);
 
@@ -1004,6 +1037,11 @@ static void __init xd_override_init_driv
 		xd_manual_geo_set(drive);
 	else {
 		for (i = 0; i < 3; i++) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (min[i] != max[i] - 1) {
 				test[i] = (min[i] + max[i]) / 2;
 				xd_build(cmdblk,CMD_SEEK,drive,(u_char) test[0],(u_short) test[1],(u_char) test[2],0,0);
@@ -1011,6 +1049,12 @@ static void __init xd_override_init_driv
 					min[i] = test[i];
 				else
 					max[i] = test[i];
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 			test[i] = min[i];
 		}
diff -u -p a/block/osdblk.c b/block/osdblk.c
--- a/block/osdblk.c
+++ b/block/osdblk.c
@@ -253,11 +253,22 @@ static void bio_chain_put(struct bio *ch
 {
 	struct bio *tmp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (chain) {
 		tmp = chain;
 		chain = chain->bi_next;
 
 		bio_put(tmp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -265,6 +276,11 @@ static struct bio *bio_chain_clone(struc
 {
 	struct bio *tmp, *new_chain = NULL, *tail = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (old_chain) {
 		tmp = bio_kmalloc(gfpmask, old_chain->bi_max_vecs);
 		if (!tmp)
@@ -283,6 +299,12 @@ static struct bio *bio_chain_clone(struc
 		}
 
 		old_chain = old_chain->bi_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return new_chain;
diff -u -p a/block/xen-blkback/blkback.c b/block/xen-blkback/blkback.c
--- a/block/xen-blkback/blkback.c
+++ b/block/xen-blkback/blkback.c
@@ -281,7 +281,12 @@ int xen_blkif_schedule(void *arg)
 
 	xen_blkif_get(blkif);
 
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		if (try_to_freeze())
 			continue;
 		if (unlikely(vbd->size != vbd_sz(vbd)))
@@ -307,6 +312,12 @@ int xen_blkif_schedule(void *arg)
 
 		if (log_stats && time_after(jiffies, blkif->st_print))
 			print_stats(blkif);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (log_stats)
diff -u -p a/block/nbd.c b/block/nbd.c
--- a/block/nbd.c
+++ b/block/nbd.c
@@ -438,20 +438,42 @@ static void nbd_clear_que(struct nbd_dev
 	BUG_ON(lo->sock);
 	BUG_ON(lo->active_req);
 
-	while (!list_empty(&lo->queue_head)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&lo->queue_head)) {
 		req = list_entry(lo->queue_head.next, struct request,
 				 queuelist);
 		list_del_init(&req->queuelist);
 		req->errors++;
 		nbd_end_request(req);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
-	while (!list_empty(&lo->waiting_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&lo->waiting_queue)) {
 		req = list_entry(lo->waiting_queue.next, struct request,
 				 queuelist);
 		list_del_init(&req->queuelist);
 		req->errors++;
 		nbd_end_request(req);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -510,7 +532,12 @@ static int nbd_thread(void *data)
 	struct request *req;
 
 	set_user_nice(current, -20);
-	while (!kthread_should_stop() || !list_empty(&lo->waiting_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop() || !list_empty(&lo->waiting_queue)) {
 		/* wait for something to do */
 		wait_event_interruptible(lo->waiting_wq,
 					 kthread_should_stop() ||
@@ -528,6 +555,12 @@ static int nbd_thread(void *data)
 
 		/* handle request */
 		nbd_handle_req(lo, req);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return 0;
 }
diff -u -p a/block/rbd.c b/block/rbd.c
--- a/block/rbd.c
+++ b/block/rbd.c
@@ -645,10 +645,21 @@ static void bio_chain_put(struct bio *ch
 {
 	struct bio *tmp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (chain) {
 		tmp = chain;
 		chain = chain->bi_next;
 		bio_put(tmp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -663,6 +674,11 @@ static void zero_bio_chain(struct bio *c
 	int i;
 	int pos = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (chain) {
 		bio_for_each_segment(bv, chain, i) {
 			if (pos + bv->bv_len > start_ofs) {
@@ -676,6 +692,12 @@ static void zero_bio_chain(struct bio *c
 		}
 
 		chain = chain->bi_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -695,6 +717,11 @@ static struct bio *bio_chain_clone(struc
 		*bp = NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (old_chain && (total < len)) {
 		tmp = bio_kmalloc(gfpmask, old_chain->bi_max_vecs);
 		if (!tmp)
@@ -739,6 +766,12 @@ static struct bio *bio_chain_clone(struc
 		old_chain = old_chain->bi_next;
 
 		total += tmp->bi_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	BUG_ON(total < len);
@@ -1660,9 +1693,20 @@ static void __rbd_remove_all_snaps(struc
 {
 	struct rbd_snap *snap;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&rbd_dev->snaps)) {
 		snap = list_first_entry(&rbd_dev->snaps, struct rbd_snap, node);
 		__rbd_remove_snap_dev(rbd_dev, snap);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2003,10 +2047,21 @@ const char *rbd_prev_snap_name(const cha
 		return NULL;
 
 	name -= 2;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*name) {
 		if (name == start)
 			return start;
 		name--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return name + 1;
 }
diff -u -p a/block/pktcdvd.c b/block/pktcdvd.c
--- a/block/pktcdvd.c
+++ b/block/pktcdvd.c
@@ -717,6 +717,11 @@ static void pkt_rbtree_insert(struct pkt
 	sector_t s = node->bio->bi_sector;
 	struct pkt_rb_node *tmp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*p) {
 		parent = *p;
 		tmp = rb_entry(parent, struct pkt_rb_node, rb_node);
@@ -724,6 +729,12 @@ static void pkt_rbtree_insert(struct pkt
 			p = &(*p)->rb_left;
 		else
 			p = &(*p)->rb_right;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	rb_link_node(&node->rb_node, parent, p);
 	rb_insert_color(&node->rb_node, &pd->bio_queue);
@@ -1385,11 +1396,22 @@ static void pkt_start_write(struct pktcd
 		for (f = first_frame; f < first_frame + num_frames; f++) {
 			struct bio_vec *src_bvl = bio_iovec_idx(bio, segment);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (src_offs >= src_bvl->bv_len) {
 				src_offs -= src_bvl->bv_len;
 				segment++;
 				BUG_ON(segment >= bio->bi_vcnt);
 				src_bvl = bio_iovec_idx(bio, segment);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			if (src_bvl->bv_len - src_offs >= CD_FRAMESIZE) {
diff -u -p a/block/cpqarray.c b/block/cpqarray.c
--- a/block/cpqarray.c
+++ b/block/cpqarray.c
@@ -273,17 +273,39 @@ static int ida_proc_show(struct seq_file
 	c = h->reqQ;
 	seq_printf(m, "reqQ = %p", c);
 	if (c) c=c->next;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(c && c != h->reqQ) {
 		seq_printf(m, "->%p", c);
 		c=c->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	c = h->cmpQ;
 	seq_printf(m, "\ncmpQ = %p", c);
 	if (c) c=c->next;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(c && c != h->cmpQ) {
 		seq_printf(m, "->%p", c);
 		c=c->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	seq_putc(m, '\n');
@@ -1061,6 +1083,11 @@ static irqreturn_t do_ida_intr(int irq,
 	 */
 	spin_lock_irqsave(IDA_LOCK(h->ctlr), flags);
 	if (istat & FIFO_NOT_EMPTY) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while((a = h->access.command_completed(h))) {
 			a1 = a; a &= ~3;
 			if ((c = h->cmpQ) == NULL)
@@ -1096,6 +1123,12 @@ static irqreturn_t do_ida_intr(int irq,
 				}
 				continue;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/block/DAC960.c b/block/DAC960.c
--- a/block/DAC960.c
+++ b/block/DAC960.c
@@ -2800,7 +2800,12 @@ DAC960_DetectController(struct pci_dev *
 	  DAC960_GEM_DisableInterrupts(BaseAddress);
 	  DAC960_GEM_AcknowledgeHardwareMailboxStatus(BaseAddress);
 	  udelay(1000);
-	  while (DAC960_GEM_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_GEM_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_GEM_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2808,7 +2813,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
 		goto Failure;
 	      udelay(10);
-	    }
+	      if (_cur < timeout) {
+		rdstcll(_cur);
+	      }
+	      else {
+		break;
+	      }
+	      }
 	  if (!DAC960_V2_EnableMemoryMailboxInterface(Controller))
 	    {
 	      DAC960_Error("Unable to Enable Memory Mailbox Interface "
@@ -2830,7 +2841,12 @@ DAC960_DetectController(struct pci_dev *
 	  DAC960_BA_DisableInterrupts(BaseAddress);
 	  DAC960_BA_AcknowledgeHardwareMailboxStatus(BaseAddress);
 	  udelay(1000);
-	  while (DAC960_BA_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_BA_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_BA_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2838,7 +2854,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
 		goto Failure;
 	      udelay(10);
-	    }
+	      if (_cur < timeout) {
+		rdstcll(_cur);
+	      }
+	      else {
+		break;
+	      }
+	      }
 	  if (!DAC960_V2_EnableMemoryMailboxInterface(Controller))
 	    {
 	      DAC960_Error("Unable to Enable Memory Mailbox Interface "
@@ -2860,7 +2882,12 @@ DAC960_DetectController(struct pci_dev *
 	  DAC960_LP_DisableInterrupts(BaseAddress);
 	  DAC960_LP_AcknowledgeHardwareMailboxStatus(BaseAddress);
 	  udelay(1000);
-	  while (DAC960_LP_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_LP_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_LP_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2868,7 +2895,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
 		goto Failure;
 	      udelay(10);
-	    }
+	      if (_cur < timeout) {
+		rdstcll(_cur);
+	      }
+	      else {
+		break;
+	      }
+	      }
 	  if (!DAC960_V2_EnableMemoryMailboxInterface(Controller))
 	    {
 	      DAC960_Error("Unable to Enable Memory Mailbox Interface "
@@ -2890,7 +2923,12 @@ DAC960_DetectController(struct pci_dev *
 	  DAC960_LA_DisableInterrupts(BaseAddress);
 	  DAC960_LA_AcknowledgeHardwareMailboxStatus(BaseAddress);
 	  udelay(1000);
-	  while (DAC960_LA_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_LA_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_LA_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2898,7 +2936,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
 		goto Failure;
 	      udelay(10);
-	    }
+	      if (_cur < timeout) {
+		rdstcll(_cur);
+	      }
+	      else {
+		break;
+	      }
+	      }
 	  if (!DAC960_V1_EnableMemoryMailboxInterface(Controller))
 	    {
 	      DAC960_Error("Unable to Enable Memory Mailbox Interface "
@@ -2922,7 +2966,12 @@ DAC960_DetectController(struct pci_dev *
 	  DAC960_PG_DisableInterrupts(BaseAddress);
 	  DAC960_PG_AcknowledgeHardwareMailboxStatus(BaseAddress);
 	  udelay(1000);
-	  while (DAC960_PG_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_PG_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_PG_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2930,7 +2979,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
 		goto Failure;
 	      udelay(10);
-	    }
+	      if (_cur < timeout) {
+		rdstcll(_cur);
+	      }
+	      else {
+		break;
+	      }
+	      }
 	  if (!DAC960_V1_EnableMemoryMailboxInterface(Controller))
 	    {
 	      DAC960_Error("Unable to Enable Memory Mailbox Interface "
@@ -2960,7 +3015,12 @@ DAC960_DetectController(struct pci_dev *
 	  DAC960_PD_DisableInterrupts(BaseAddress);
 	  DAC960_PD_AcknowledgeStatus(BaseAddress);
 	  udelay(1000);
-	  while (DAC960_PD_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_PD_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_PD_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -2968,7 +3028,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
 		goto Failure;
 	      udelay(10);
-	    }
+	      if (_cur < timeout) {
+		rdstcll(_cur);
+	      }
+	      else {
+		break;
+	      }
+	      }
 	  if (!DAC960_V1_EnableMemoryMailboxInterface(Controller))
 	    {
 	      DAC960_Error("Unable to allocate DMA mapped memory "
@@ -2996,7 +3062,12 @@ DAC960_DetectController(struct pci_dev *
 	  DAC960_PD_DisableInterrupts(BaseAddress);
 	  DAC960_PD_AcknowledgeStatus(BaseAddress);
 	  udelay(1000);
-	  while (DAC960_PD_InitializationInProgressP(BaseAddress))
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (DAC960_PD_InitializationInProgressP(BaseAddress))
 	    {
 	      if (DAC960_PD_ReadErrorStatus(BaseAddress, &ErrorStatus,
 					    &Parameter0, &Parameter1) &&
@@ -3004,7 +3075,13 @@ DAC960_DetectController(struct pci_dev *
 					   Parameter0, Parameter1))
 		goto Failure;
 	      udelay(10);
-	    }
+	      if (_cur < timeout) {
+		rdstcll(_cur);
+	      }
+	      else {
+		break;
+	      }
+	      }
 	  if (!DAC960_V1_EnableMemoryMailboxInterface(Controller))
 	    {
 	      DAC960_Error("Unable to allocate DMA mapped memory"
@@ -3328,6 +3405,11 @@ static int DAC960_process_queue(DAC960_C
 	struct request *Request;
 	DAC960_Command_T *Command;
 
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    while(1) {
 	Request = blk_peek_request(req_q);
 	if (!Request)
@@ -3357,6 +3439,12 @@ static int DAC960_process_queue(DAC960_C
 		 Command->SegmentCount, Command->DmaDirection);
 
 	DAC960_QueueReadWriteCommand(Command);
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
   }
 }
 
@@ -5394,7 +5482,12 @@ static irqreturn_t DAC960_LA_InterruptHa
   spin_lock_irqsave(&Controller->queue_lock, flags);
   DAC960_LA_AcknowledgeInterrupt(ControllerBaseAddress);
   NextStatusMailbox = Controller->V1.NextStatusMailbox;
-  while (NextStatusMailbox->Fields.Valid)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (NextStatusMailbox->Fields.Valid)
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	NextStatusMailbox->Fields.CommandIdentifier;
@@ -5404,6 +5497,12 @@ static irqreturn_t DAC960_LA_InterruptHa
       if (++NextStatusMailbox > Controller->V1.LastStatusMailbox)
 	NextStatusMailbox = Controller->V1.FirstStatusMailbox;
       DAC960_V1_ProcessCompletedCommand(Command);
+      if (_cur < timeout) {
+	rdstcll(_cur);
+      }
+      else {
+	break;
+      }
     }
   Controller->V1.NextStatusMailbox = NextStatusMailbox;
   /*
@@ -5432,7 +5531,12 @@ static irqreturn_t DAC960_PG_InterruptHa
   spin_lock_irqsave(&Controller->queue_lock, flags);
   DAC960_PG_AcknowledgeInterrupt(ControllerBaseAddress);
   NextStatusMailbox = Controller->V1.NextStatusMailbox;
-  while (NextStatusMailbox->Fields.Valid)
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (NextStatusMailbox->Fields.Valid)
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	NextStatusMailbox->Fields.CommandIdentifier;
@@ -5442,6 +5546,12 @@ static irqreturn_t DAC960_PG_InterruptHa
       if (++NextStatusMailbox > Controller->V1.LastStatusMailbox)
 	NextStatusMailbox = Controller->V1.FirstStatusMailbox;
       DAC960_V1_ProcessCompletedCommand(Command);
+      if (_cur < timeout) {
+	rdstcll(_cur);
+      }
+      else {
+	break;
+      }
     }
   Controller->V1.NextStatusMailbox = NextStatusMailbox;
   /*
@@ -5467,7 +5577,12 @@ static irqreturn_t DAC960_PD_InterruptHa
   unsigned long flags;
 
   spin_lock_irqsave(&Controller->queue_lock, flags);
-  while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	DAC960_PD_ReadStatusCommandIdentifier(ControllerBaseAddress);
@@ -5477,6 +5592,12 @@ static irqreturn_t DAC960_PD_InterruptHa
       DAC960_PD_AcknowledgeInterrupt(ControllerBaseAddress);
       DAC960_PD_AcknowledgeStatus(ControllerBaseAddress);
       DAC960_V1_ProcessCompletedCommand(Command);
+      if (_cur < timeout) {
+	rdstcll(_cur);
+      }
+      else {
+	break;
+      }
     }
   /*
     Attempt to remove additional I/O Requests from the Controller's
@@ -5505,7 +5626,12 @@ static irqreturn_t DAC960_P_InterruptHan
   unsigned long flags;
 
   spin_lock_irqsave(&Controller->queue_lock, flags);
-  while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
+    while (DAC960_PD_StatusAvailableP(ControllerBaseAddress))
     {
       DAC960_V1_CommandIdentifier_T CommandIdentifier =
 	DAC960_PD_ReadStatusCommandIdentifier(ControllerBaseAddress);
@@ -5550,6 +5676,12 @@ static irqreturn_t DAC960_P_InterruptHan
 	  break;
 	}
       DAC960_V1_ProcessCompletedCommand(Command);
+      if (_cur < timeout) {
+	rdstcll(_cur);
+      }
+      else {
+	break;
+      }
     }
   /*
     Attempt to remove additional I/O Requests from the Controller's
@@ -6410,10 +6542,21 @@ static bool DAC960_V2_ExecuteUserCommand
 					.SegmentByteCount =
 	    CommandMailbox->ControllerInfo.DataTransferSize;
 	  DAC960_ExecuteCommand(Command);
-	  while (Controller->V2.NewControllerInformation->PhysicalScanActive)
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	    unsigned long long timeout;
+	    timeout = rdstcll(start) + delta;
+	    while (Controller->V2.NewControllerInformation->PhysicalScanActive)
 	    {
 	      DAC960_ExecuteCommand(Command);
 	      sleep_on_timeout(&Controller->CommandWaitQueue, HZ);
+	      if (_cur < timeout) {
+					rdstcll(_cur);
+	      }
+	      else {
+					break;
+	      }
 	    }
 	  DAC960_UserCritical("Discovery Completed\n", Controller);
  	}
@@ -6766,7 +6909,12 @@ static long DAC960_gam_ioctl(struct file
 	    spin_lock_irqsave(&Controller->queue_lock, flags);
 	    while ((Command = DAC960_AllocateCommand(Controller)) == NULL)
 	      DAC960_WaitForCommand(Controller);
-	    while (Controller->V1.DirectCommandActive[DCDB.Channel]
+	    unsigned long long delta = (cpu / khz / HZ) * 2;
+	    unsigned long long _start = 0;
+	    unsigned long long _cur = 0;
+	      unsigned long long timeout;
+	      timeout = rdstcll(start) + delta;
+	      while (Controller->V1.DirectCommandActive[DCDB.Channel]
 						     [DCDB.TargetID])
 	      {
 		spin_unlock_irq(&Controller->queue_lock);
@@ -6774,6 +6922,12 @@ static long DAC960_gam_ioctl(struct file
 			     !Controller->V1.DirectCommandActive
 					     [DCDB.Channel][DCDB.TargetID]);
 		spin_lock_irq(&Controller->queue_lock);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	      }
 	    Controller->V1.DirectCommandActive[DCDB.Channel]
 					      [DCDB.TargetID] = true;
diff -u -p a/block/swim3.c b/block/swim3.c
--- a/block/swim3.c
+++ b/block/swim3.c
@@ -840,6 +840,11 @@ static int grab_drive(struct floppy_stat
 	spin_lock_irqsave(&swim3_lock, flags);
 	if (fs->state != idle && fs->state != available) {
 		++fs->wanted;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (fs->state != available) {
 			spin_unlock_irqrestore(&swim3_lock, flags);
 			if (interruptible && signal_pending(current)) {
@@ -848,6 +853,12 @@ static int grab_drive(struct floppy_stat
 			}
 			interruptible_sleep_on(&fs->wait);
 			spin_lock_irqsave(&swim3_lock, flags);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		--fs->wanted;
 	}
diff -u -p a/block/xsysace.c b/block/xsysace.c
--- a/block/xsysace.c
+++ b/block/xsysace.c
@@ -508,10 +508,21 @@ static void ace_fsm_dostate(struct ace_d
 		/* Drop back to IDLE state and notify waiters */
 		ace->fsm_state = ACE_FSM_STATE_IDLE;
 		ace->id_result = -EIO;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ace->id_req_count) {
 			complete(&ace->id_completion);
 			ace->id_req_count--;
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+	}
 	}
 
 	switch (ace->fsm_state) {
@@ -639,9 +650,20 @@ static void ace_fsm_dostate(struct ace_d
 		/* We're done, drop to IDLE state and notify waiters */
 		ace->fsm_state = ACE_FSM_STATE_IDLE;
 		ace->id_result = ace->data_result;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ace->id_req_count) {
 			complete(&ace->id_completion);
 			ace->id_req_count--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		break;
 
diff -u -p a/block/cciss_scsi.c b/block/cciss_scsi.c
--- a/block/cciss_scsi.c
+++ b/block/cciss_scsi.c
@@ -556,6 +556,11 @@ adjust_cciss_scsi_table(ctlr_info_t *h,
 	i = 0;
 	nremoved = 0;
 	nadded = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < ccissscsi[h->ctlr].ndevices) {
 		csd = &ccissscsi[h->ctlr].dev[i];
 		found=0;
@@ -598,6 +603,12 @@ adjust_cciss_scsi_table(ctlr_info_t *h,
 				sizeof(csd->revision));
 		} else 		/* device is same as it ever was, */
 			i++;	/* so just move along. */
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 
 	/* Now, make sure every device listed in sd[] is also
diff -u -p a/block/loop.c b/block/loop.c
--- a/block/loop.c
+++ b/block/loop.c
@@ -535,7 +535,12 @@ static int loop_thread(void *data)
 
 	set_user_nice(current, -20);
 
-	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
 
 		wait_event_interruptible(lo->lo_event,
 				!bio_list_empty(&lo->lo_bio_list) ||
@@ -549,6 +554,12 @@ static int loop_thread(void *data)
 
 		BUG_ON(!bio);
 		loop_handle_bio(lo, bio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -828,6 +839,11 @@ static int loop_set_fd(struct loop_devic
 
 	/* Avoid recursion */
 	f = file;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (is_loop_device(f)) {
 		struct loop_device *l;
 
@@ -840,6 +856,12 @@ static int loop_set_fd(struct loop_devic
 			goto out_putf;
 		}
 		f = l->lo_backing_file;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mapping = file->f_mapping;
diff -u -p a/block/z2ram.c b/block/z2ram.c
--- a/block/z2ram.c
+++ b/block/z2ram.c
@@ -74,6 +74,11 @@ static void do_z2_request(struct request
 	struct request *req;
 
 	req = blk_fetch_request(q);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (req) {
 		unsigned long start = blk_rq_pos(req) << 9;
 		unsigned long len  = blk_rq_cur_bytes(req);
@@ -87,6 +92,11 @@ static void do_z2_request(struct request
 			err = -EIO;
 			goto done;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			unsigned long addr = start & Z2RAM_CHUNKMASK;
 			unsigned long size = Z2RAM_CHUNKSIZE - addr;
@@ -99,10 +109,22 @@ static void do_z2_request(struct request
 				memcpy((char *)addr, req->buffer, size);
 			start += size;
 			len -= size;
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+			}
 	done:
 		if (!__blk_end_request_cur(req, err))
 			req = blk_fetch_request(q);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -207,11 +229,22 @@ static int z2_open(struct block_device *
 		    goto err_out;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (size) {
 			z2ram_map[ z2ram_size++ ] = vaddr;
 			size -= Z2RAM_CHUNKSIZE;
 			vaddr += Z2RAM_CHUNKSIZE;
 			list_count++;
+			if (_cur < timeout) {
+		    rdstcll(_cur);
+			}
+		    else {
+		    break;
+		    }
 		}
 
 		if ( z2ram_size != 0 )
diff -u -p a/block/paride/pd.c b/block/paride/pd.c
--- a/block/paride/pd.c
+++ b/block/paride/pd.c
@@ -386,6 +386,11 @@ static PIA *pi_current; /* current reque
 
 static void run_fsm(void)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		enum action res;
 		unsigned long saved_flags;
@@ -429,6 +434,12 @@ static void run_fsm(void)
 				pi_disconnect(pi_current);
 				pd_claimed = 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
diff -u -p a/block/paride/pg.c b/block/paride/pg.c
--- a/block/paride/pg.c
+++ b/block/paride/pg.c
@@ -290,12 +290,23 @@ static int pg_wait(struct pg *dev, int g
 	dev->status = 0;
 
 	j = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((((r = status_reg(dev)) & go) || (stop && (!(r & stop))))
 	       && time_before(jiffies, tmo)) {
 		if (j++ < PG_SPIN)
 			udelay(PG_SPIN_DEL);
 		else
 			pg_sleep(1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	to = time_after_eq(jiffies, tmo);
@@ -361,6 +372,11 @@ static int pg_completion(struct pg *dev,
 
 	dev->dlen = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (read_reg(dev, 7) & STAT_DRQ) {
 		d = (read_reg(dev, 4) + 256 * read_reg(dev, 5));
 		n = ((d + 3) & 0xfffc);
@@ -376,6 +392,12 @@ static int pg_completion(struct pg *dev,
 		buf += d;
 		r = pg_wait(dev, STAT_BUSY, STAT_DRQ | STAT_READY | STAT_ERR,
 			    tmo, "completion");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pi_disconnect(dev->pi);
diff -u -p a/block/paride/pt.c b/block/paride/pt.c
--- a/block/paride/pt.c
+++ b/block/paride/pt.c
@@ -484,6 +484,11 @@ static int pt_ready_wait(struct pt_unit
 	int k, p;
 
 	k = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (k < tmo) {
 		tape->last_sense = 0;
 		pt_atapi(tape, tr_cmd, 0, NULL, DBMSG("test unit ready"));
@@ -494,6 +499,12 @@ static int pt_ready_wait(struct pt_unit
 			return p;
 		k++;
 		pt_sleep(HZ);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0x000020;	/* timeout */
 }
diff -u -p a/block/paride/pcd.c b/block/paride/pcd.c
--- a/block/paride/pcd.c
+++ b/block/paride/pcd.c
@@ -579,6 +579,11 @@ static int pcd_ready_wait(struct pcd_uni
 	int k, p;
 
 	k = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (k < tmo) {
 		cd->last_sense = 0;
 		pcd_atapi(cd, tr_cmd, 0, NULL, DBMSG("test unit ready"));
@@ -589,6 +594,12 @@ static int pcd_ready_wait(struct pcd_uni
 			return p;
 		k++;
 		pcd_sleep(HZ);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0x000020;	/* timeout */
 }
@@ -734,6 +745,11 @@ static void do_pcd_request(struct reques
 {
 	if (pcd_busy)
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (!pcd_req) {
 			pcd_req = blk_fetch_request(q);
@@ -756,6 +772,12 @@ static void do_pcd_request(struct reques
 			__blk_end_request_all(pcd_req, -EIO);
 			pcd_req = NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -779,12 +801,23 @@ static int pcd_ready(void)
 static void pcd_transfer(void)
 {
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pcd_count && (pcd_sector / 4 == pcd_bufblk)) {
 		int o = (pcd_sector % 4) * 512;
 		memcpy(pcd_buf, pcd_buffer + o, 512);
 		pcd_count--;
 		pcd_buf += 512;
 		pcd_sector++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/block/paride/ppc6lnx.c b/block/paride/ppc6lnx.c
--- a/block/paride/ppc6lnx.c
+++ b/block/paride/ppc6lnx.c
@@ -383,6 +383,11 @@ static void ppc6_rd_data_blk(Interface *
 		case PPCMODE_UNI_SW :
 		case PPCMODE_UNI_FW :
 		{
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(count)
 			{
 				u8 d;
@@ -407,6 +412,12 @@ static void ppc6_rd_data_blk(Interface *
 
 				*data++ = d;
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			break;
@@ -421,6 +432,11 @@ static void ppc6_rd_data_blk(Interface *
 
 			ppc->cur_ctrl |= port_stb;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(count)
 			{
 				ppc->cur_ctrl ^= data_stb;
@@ -429,6 +445,12 @@ static void ppc6_rd_data_blk(Interface *
 
 				*data++ = inb(ppc->lpt_addr);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			ppc->cur_ctrl &= ~port_stb;
@@ -448,10 +470,21 @@ static void ppc6_rd_data_blk(Interface *
 
 			// DELAY
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(count)
 			{
 				*data++ = inb(ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			outb(ppc->cur_ctrl, ppc->lpt_addr + 2);
@@ -472,10 +505,21 @@ static void ppc6_rd_data_blk(Interface *
 				count -= 2;
 			}
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(count)
 			{
 				*data++ = inb(ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			outb(ppc->cur_ctrl, ppc->lpt_addr + 2);
@@ -496,10 +540,21 @@ static void ppc6_rd_data_blk(Interface *
 				count -= 4;
 			}
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(count)
 			{
 				*data++ = inb(ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			outb(ppc->cur_ctrl, ppc->lpt_addr + 2);
@@ -559,6 +614,11 @@ static void ppc6_wr_data_blk(Interface *
 
 			outb(last, ppc->lpt_addr);
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(count)
 			{
 				this = *data++;
@@ -576,6 +636,12 @@ static void ppc6_wr_data_blk(Interface *
 
 					last = this;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			ppc->cur_ctrl &= ~port_stb;
@@ -589,10 +655,21 @@ static void ppc6_wr_data_blk(Interface *
 
 		case PPCMODE_EPP_BYTE :
 		{
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(count)
 			{
 				outb(*data++,ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			ppc6_wait_for_fifo(ppc);
@@ -609,10 +686,21 @@ static void ppc6_wr_data_blk(Interface *
 				count -= 2;
 			}
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(count)
 			{
 				outb(*data++,ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			ppc6_wait_for_fifo(ppc);
@@ -629,10 +717,21 @@ static void ppc6_wr_data_blk(Interface *
 				count -= 4;
 			}
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while(count)
 			{
 				outb(*data++,ppc->lpt_addr + 4);
 				count--;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			ppc6_wait_for_fifo(ppc);
diff -u -p a/block/swim.c b/block/swim.c
--- a/block/swim.c
+++ b/block/swim.c
@@ -532,6 +532,11 @@ static void redo_fd_request(struct reque
 	struct floppy_state *fs;
 
 	req = blk_fetch_request(q);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (req) {
 		int err = -EIO;
 
@@ -556,6 +561,12 @@ static void redo_fd_request(struct reque
 	done:
 		if (!__blk_end_request_cur(req, err))
 			req = blk_fetch_request(q);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/block/umem.c b/block/umem.c
--- a/block/umem.c
+++ b/block/umem.c
@@ -504,12 +504,23 @@ static void process_page(unsigned long d
  out_unlock:
 	spin_unlock_bh(&card->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (return_bio) {
 		struct bio *bio = return_bio;
 
 		return_bio = bio->bi_next;
 		bio->bi_next = NULL;
 		bio_endio(bio, 0);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/block/ps3vram.c b/block/ps3vram.c
--- a/block/ps3vram.c
+++ b/block/ps3vram.c
@@ -445,6 +445,11 @@ static int ps3vram_read(struct ps3_syste
 
 	/* Copy from vram to buf */
 	count = len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		unsigned int offset, avail;
 		unsigned int entry;
@@ -466,6 +471,12 @@ static int ps3vram_read(struct ps3_syste
 		buf += avail;
 		count -= avail;
 		from += avail;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*retlen = len;
@@ -486,6 +497,11 @@ static int ps3vram_write(struct ps3_syst
 
 	/* Copy from buf to vram */
 	count = len;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		unsigned int offset, avail;
 		unsigned int entry;
@@ -509,6 +525,12 @@ static int ps3vram_write(struct ps3_syst
 		buf += avail;
 		count -= avail;
 		to += avail;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*retlen = len;
diff -u -p a/block/floppy.c b/block/floppy.c
--- a/block/floppy.c
+++ b/block/floppy.c
@@ -2016,6 +2016,11 @@ static int next_valid_format(void)
 	int probed_format;
 
 	probed_format = DRS->probed_format;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (probed_format >= 8 || !DP->autodetect[probed_format]) {
 			DRS->probed_format = 0;
@@ -2026,6 +2031,12 @@ static int next_valid_format(void)
 			return 0;
 		}
 		probed_format++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2593,14 +2604,36 @@ static int make_raw_rw_request(void)
 			SECTOR--;
 
 		/* if we are beyond tracksize, fill up using smaller sectors */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tracksize <= fsector_t % _floppy->sect) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (tracksize + ssize > _floppy->sect) {
 				SIZECODE--;
 				ssize >>= 1;
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
+		break;
+				}
 			}
 			SECTOR++;
 			SECT_PER_TRACK++;
 			tracksize += ssize;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		max_sector = HEAD * _floppy->sect + tracksize;
 	} else if (!TRACK && !HEAD && !(_floppy->rate & FD_2M) && probing) {
@@ -3059,6 +3092,11 @@ static int raw_cmd_copyout(int cmd, void
 {
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ptr) {
 		struct floppy_raw_cmd cmd = *ptr;
 		cmd.next = NULL;
@@ -3078,6 +3116,12 @@ static int raw_cmd_copyout(int cmd, void
 			}
 		}
 		ptr = ptr->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -3090,7 +3134,12 @@ static void raw_cmd_free(struct floppy_r
 
 	this = *ptr;
 	*ptr = NULL;
-	while (this) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (this) {
 		if (this->buffer_length) {
 			fd_dma_mem_free((unsigned long)this->kernel_data,
 					this->buffer_length);
@@ -3099,6 +3148,12 @@ static void raw_cmd_free(struct floppy_r
 		next = this->next;
 		kfree(this);
 		this = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4374,9 +4429,20 @@ static const struct io_region {
 
 static void floppy_release_allocated_regions(int fdc, const struct io_region *p)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p != io_regions) {
 		p--;
 		release_region(FDCS->address + p->offset, p->size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -4524,6 +4590,11 @@ static void __init parse_floppy_cfg_stri
 {
 	char *ptr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*cfg) {
 		ptr = cfg;
 		while (*cfg && *cfg != ' ' && *cfg != '\t')
@@ -4534,6 +4605,12 @@ static void __init parse_floppy_cfg_stri
 		}
 		if (*ptr)
 			floppy_setup(ptr);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/block/cciss.c b/block/cciss.c
--- a/block/cciss.c
+++ b/block/cciss.c
@@ -1612,6 +1612,11 @@ static int cciss_bigpassthru(ctlr_info_t
 	}
 	left = ioc->buf_size;
 	data_ptr = ioc->buf;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (left) {
 		sz = (left > ioc->malloc_size) ? ioc->malloc_size : left;
 		buff_size[sg_used] = sz;
@@ -1631,6 +1636,12 @@ static int cciss_bigpassthru(ctlr_info_t
 		left -= sz;
 		data_ptr += sz;
 		sg_used++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	c = cmd_special_alloc(h);
 	if (!c) {
@@ -3567,10 +3578,21 @@ static irqreturn_t cciss_intx_discard_co
 	if (interrupt_not_for_us(h))
 		return IRQ_NONE;
 	spin_lock_irqsave(&h->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
 		while (raw_tag != FIFO_EMPTY)
 			raw_tag = next_command(h);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	spin_unlock_irqrestore(&h->lock, flags);
 	return IRQ_HANDLED;
@@ -3602,6 +3624,11 @@ static irqreturn_t do_cciss_intx(int irq
 	if (interrupt_not_for_us(h))
 		return IRQ_NONE;
 	spin_lock_irqsave(&h->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (interrupt_pending(h)) {
 		raw_tag = get_next_completion(h);
 		while (raw_tag != FIFO_EMPTY) {
@@ -3610,6 +3637,12 @@ static irqreturn_t do_cciss_intx(int irq
 			else
 				raw_tag = process_nonindexed_cmd(h, raw_tag);
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	spin_unlock_irqrestore(&h->lock, flags);
 	return IRQ_HANDLED;
diff -u -p a/block/mg_disk.c b/block/mg_disk.c
--- a/block/mg_disk.c
+++ b/block/mg_disk.c
@@ -270,10 +270,21 @@ static unsigned int mg_wait_rstout(u32 r
 	unsigned long expire;
 
 	expire = jiffies + msecs_to_jiffies(msec);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, expire)) {
 		if (gpio_get_value(rstout) == 1)
 			return MG_ERR_NONE;
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return MG_ERR_RSTOUT;
diff -u -p a/hwmon/ibmaem.c b/hwmon/ibmaem.c
--- a/hwmon/ibmaem.c
+++ b/hwmon/ibmaem.c
@@ -765,7 +765,12 @@ static void aem_init_aem2(struct aem_ipm
 	int err;
 	int i = 0;
 
-	while (!aem_find_aem2(probe, &fi_resp, i)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!aem_find_aem2(probe, &fi_resp, i)) {
 		if (fi_resp.major != 2) {
 			dev_err(probe->bmc_device, "Unknown AEM v%d; please "
 				"report this to the maintainer.\n",
@@ -780,6 +785,12 @@ static void aem_init_aem2(struct aem_ipm
 				err, fi_resp.module_handle);
 		}
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -928,6 +939,11 @@ static int aem_register_sensors(struct a
 	int err;
 
 	/* Set up read-only sensors */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ro->label) {
 		sysfs_attr_init(&sensors->dev_attr.attr);
 		sensors->dev_attr.attr.name = ro->label;
@@ -942,9 +958,20 @@ static int aem_register_sensors(struct a
 		}
 		sensors++;
 		ro++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Set up read-write sensors */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rw->label) {
 		sysfs_attr_init(&sensors->dev_attr.attr);
 		sensors->dev_attr.attr.name = rw->label;
@@ -960,6 +987,12 @@ static int aem_register_sensors(struct a
 		}
 		sensors++;
 		rw++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	err = device_create_file(dev, &sensor_dev_attr_name.dev_attr);
diff -u -p a/hwmon/abituguru.c b/hwmon/abituguru.c
--- a/hwmon/abituguru.c
+++ b/hwmon/abituguru.c
@@ -232,6 +232,11 @@ static int abituguru_wait(struct abitugu
 {
 	int timeout = ABIT_UGURU_WAIT_TIMEOUT;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (inb_p(data->addr + ABIT_UGURU_DATA) != state) {
 		timeout--;
 		if (timeout == 0)
@@ -240,6 +245,12 @@ static int abituguru_wait(struct abitugu
 		   this where ABIT_UGURU_WAIT_TIMEOUT_SLEEP is defined. */
 		if (timeout <= ABIT_UGURU_WAIT_TIMEOUT_SLEEP)
 			msleep(0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/hwmon/abituguru3.c b/hwmon/abituguru3.c
--- a/hwmon/abituguru3.c
+++ b/hwmon/abituguru3.c
@@ -621,7 +621,12 @@ static int abituguru3_wait_while_busy(st
 	u8 x;
 	int timeout = ABIT_UGURU3_WAIT_TIMEOUT;
 
-	while ((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
 			ABIT_UGURU3_STATUS_BUSY) {
 		timeout--;
 		if (timeout == 0)
@@ -630,6 +635,12 @@ static int abituguru3_wait_while_busy(st
 		   last chance to respond. */
 		if (timeout == 1)
 			msleep(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return ABIT_UGURU3_SUCCESS;
 }
@@ -640,7 +651,12 @@ static int abituguru3_wait_for_read(stru
 	u8 x;
 	int timeout = ABIT_UGURU3_WAIT_TIMEOUT;
 
-	while (!((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!((x = inb_p(data->addr + ABIT_UGURU3_DATA)) &
 			ABIT_UGURU3_STATUS_READY_FOR_READ)) {
 		timeout--;
 		if (timeout == 0)
@@ -649,6 +665,12 @@ static int abituguru3_wait_for_read(stru
 		   last chance to respond. */
 		if (timeout == 1)
 			msleep(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return ABIT_UGURU3_SUCCESS;
 }
diff -u -p a/hwmon/acpi_power_meter.c b/hwmon/acpi_power_meter.c
--- a/hwmon/acpi_power_meter.c
+++ b/hwmon/acpi_power_meter.c
@@ -626,6 +626,11 @@ static int register_ro_attrs(struct acpi
 		&resource->sensors[resource->num_sensors];
 	int res = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ro->label) {
 		sensors->dev_attr.attr.name = ro->label;
 		sensors->dev_attr.attr.mode = S_IRUGO;
@@ -640,7 +645,13 @@ static int register_ro_attrs(struct acpi
 		sensors++;
 		resource->num_sensors++;
 		ro++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 error:
 	return res;
@@ -654,6 +665,11 @@ static int register_rw_attrs(struct acpi
 		&resource->sensors[resource->num_sensors];
 	int res = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rw->label) {
 		sensors->dev_attr.attr.name = rw->label;
 		sensors->dev_attr.attr.mode = S_IRUGO | S_IWUSR;
@@ -669,7 +685,13 @@ static int register_rw_attrs(struct acpi
 		sensors++;
 		resource->num_sensors++;
 		rw++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 error:
 	return res;
diff -u -p a/hwmon/applesmc.c b/hwmon/applesmc.c
--- a/hwmon/applesmc.c
+++ b/hwmon/applesmc.c
@@ -354,6 +354,11 @@ static int applesmc_get_lower_bound(unsi
 	int begin = 0, end = smcreg.key_count;
 	const struct applesmc_entry *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (begin != end) {
 		int middle = begin + (end - begin) / 2;
 		entry = applesmc_get_entry_by_index(middle);
@@ -365,6 +370,12 @@ static int applesmc_get_lower_bound(unsi
 			begin = middle + 1;
 		else
 			end = middle;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	*lo = begin;
@@ -376,6 +387,11 @@ static int applesmc_get_upper_bound(unsi
 	int begin = 0, end = smcreg.key_count;
 	const struct applesmc_entry *entry;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (begin != end) {
 		int middle = begin + (end - begin) / 2;
 		entry = applesmc_get_entry_by_index(middle);
@@ -387,6 +403,12 @@ static int applesmc_get_upper_bound(unsi
 			end = middle;
 		else
 			begin = middle + 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	*hi = begin;
diff -u -p a/input/misc/yealink.c b/input/misc/yealink.c
--- a/input/misc/yealink.c
+++ b/input/misc/yealink.c
@@ -311,6 +311,11 @@ static int yealink_set_ringtone(struct y
 
 	p->cmd = CMD_RING_NOTE;
 	ix = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size != ix) {
 		len = size - ix;
 		if (len > sizeof(p->data))
@@ -320,6 +325,12 @@ static int yealink_set_ringtone(struct y
 		memcpy(p->data, &buf[ix], len);
 		yealink_cmd(yld, p);
 		ix += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/input/misc/hp_sdc_rtc.c b/input/misc/hp_sdc_rtc.c
--- a/input/misc/hp_sdc_rtc.c
+++ b/input/misc/hp_sdc_rtc.c
@@ -139,10 +139,21 @@ static int hp_sdc_rtc_read_bbrtc (struct
 	if (hp_sdc_rtc_do_read_bbrtc(&tm_last)) return -1;
 	if (hp_sdc_rtc_do_read_bbrtc(&tm)) return -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (memcmp(&tm, &tm_last, sizeof(struct rtc_time))) {
 		if (i++ > 4) return -1;
 		memcpy(&tm_last, &tm, sizeof(struct rtc_time));
 		if (hp_sdc_rtc_do_read_bbrtc(&tm)) return -1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	memcpy(rtctm, &tm, sizeof(struct rtc_time));
diff -u -p a/input/misc/uinput.c b/input/misc/uinput.c
--- a/input/misc/uinput.c
+++ b/input/misc/uinput.c
@@ -477,6 +477,11 @@ static ssize_t uinput_read(struct file *
 		goto out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (udev->head != udev->tail && retval + input_event_size() <= count) {
 		if (input_event_to_user(buffer + retval, &udev->buff[udev->tail])) {
 			retval = -EFAULT;
@@ -484,6 +489,12 @@ static ssize_t uinput_read(struct file *
 		}
 		udev->tail = (udev->tail + 1) % UINPUT_BUFFER_SIZE;
 		retval += input_event_size();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
  out:
diff -u -p a/input/misc/keyspan_remote.c b/input/misc/keyspan_remote.c
--- a/input/misc/keyspan_remote.c
+++ b/input/misc/keyspan_remote.c
@@ -164,10 +164,21 @@ static int keyspan_load_tester(struct us
 	}
 
 	/* Load as much as we can into the tester. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((dev->data.bits_left + 7 < (sizeof(dev->data.tester) * 8)) &&
 	       (dev->data.pos < dev->data.len)) {
 		dev->data.tester += (dev->data.buffer[dev->data.pos++] << dev->data.bits_left);
 		dev->data.bits_left += 8;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
diff -u -p a/input/mouse/psmouse-base.c b/input/mouse/psmouse-base.c
--- a/input/mouse/psmouse-base.c
+++ b/input/mouse/psmouse-base.c
@@ -1596,7 +1596,12 @@ static ssize_t psmouse_attr_set_protocol
 	if (!new_dev)
 		return -ENOMEM;
 
-	while (!list_empty(&serio->children)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&serio->children)) {
 		if (++retry > 3) {
 			psmouse_warn(psmouse,
 				     "failed to destroy children ports, protocol change aborted.\n");
@@ -1617,6 +1622,12 @@ static ssize_t psmouse_attr_set_protocol
 			input_free_device(new_dev);
 			return count; /* switched by other thread */
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {
diff -u -p a/input/serio/sa1111ps2.c b/input/serio/sa1111ps2.c
--- a/input/serio/sa1111ps2.c
+++ b/input/serio/sa1111ps2.c
@@ -46,6 +46,11 @@ static irqreturn_t ps2_rxint(int irq, vo
 	unsigned int scancode, flag, status;
 
 	status = sa1111_readl(ps2if->base + SA1111_PS2STAT);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & PS2STAT_RXF) {
 		if (status & PS2STAT_STP)
 			sa1111_writel(PS2STAT_STP, ps2if->base + SA1111_PS2STAT);
@@ -61,6 +66,12 @@ static irqreturn_t ps2_rxint(int irq, vo
 		serio_interrupt(ps2if->io, scancode, flag);
 
 		status = sa1111_readl(ps2if->base + SA1111_PS2STAT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
         }
 
         return IRQ_HANDLED;
diff -u -p a/input/serio/ambakmi.c b/input/serio/ambakmi.c
--- a/input/serio/ambakmi.c
+++ b/input/serio/ambakmi.c
@@ -43,10 +43,21 @@ static irqreturn_t amba_kmi_int(int irq,
 	unsigned int status = readb(KMIIR);
 	int handled = IRQ_NONE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & KMIIR_RXINTR) {
 		serio_interrupt(kmi->io, readb(KMIDATA), 0);
 		status = readb(KMIIR);
 		handled = IRQ_HANDLED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return handled;
diff -u -p a/input/serio/ct82c710.c b/input/serio/ct82c710.c
--- a/input/serio/ct82c710.c
+++ b/input/serio/ct82c710.c
@@ -83,13 +83,24 @@ static int ct82c170_wait(void)
 {
 	int timeout = 60000;
 
-	while ((inb(CT82C710_STATUS) & (CT82C710_RX_FULL | CT82C710_TX_IDLE | CT82C710_DEV_IDLE))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((inb(CT82C710_STATUS) & (CT82C710_RX_FULL | CT82C710_TX_IDLE | CT82C710_DEV_IDLE))
 		       != (CT82C710_DEV_IDLE | CT82C710_TX_IDLE) && timeout) {
 
 		if (inb_p(CT82C710_STATUS) & CT82C710_RX_FULL) inb_p(CT82C710_DATA);
 
 		udelay(1);
 		timeout--;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return !timeout;
@@ -128,12 +139,23 @@ static int ct82c710_open(struct serio *s
 	status |= CT82C710_INTS_ON;
 	outb_p(status, CT82C710_STATUS);	/* Enable interrupts */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ct82c170_wait()) {
 		printk(KERN_ERR "ct82c710: Device busy in open()\n");
 		status &= ~(CT82C710_ENABLE | CT82C710_INTS_ON);
 		outb_p(status, CT82C710_STATUS);
 		free_irq(CT82C710_IRQ, NULL);
 		return -EBUSY;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/input/serio/hil_mlc.c b/input/serio/hil_mlc.c
--- a/input/serio/hil_mlc.c
+++ b/input/serio/hil_mlc.c
@@ -172,6 +172,11 @@ static void hil_mlc_send_polls(hil_mlc *
 	serio = did ? mlc->serio[mlc->di_map[did - 1]] : NULL;
 	drv = (serio != NULL) ? serio->drv : NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mlc->icount < 15 - i) {
 		hil_packet p;
 
@@ -199,6 +204,12 @@ static void hil_mlc_send_polls(hil_mlc *
 			drv->interrupt(serio, (p >> 8) & ~HIL_PKT_ADDR_MASK, 0);
 			drv->interrupt(serio, p & 0xff, 0);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -846,12 +857,23 @@ static int hil_mlc_serio_write(struct se
 	while ((last != idx) && (*last == 0))
 		last--;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (idx != last) {
 		drv->interrupt(serio, 0, 0);
 		drv->interrupt(serio, HIL_ERR_INT >> 16, 0);
 		drv->interrupt(serio, 0, 0);
 		drv->interrupt(serio, *idx, 0);
 		idx++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	drv->interrupt(serio, 0, 0);
 	drv->interrupt(serio, HIL_ERR_INT >> 16, 0);
diff -u -p a/input/serio/altera_ps2.c b/input/serio/altera_ps2.c
--- a/input/serio/altera_ps2.c
+++ b/input/serio/altera_ps2.c
@@ -40,9 +40,20 @@ static irqreturn_t altera_ps2_rxint(int
 	unsigned int status;
 	int handled = IRQ_NONE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = readl(ps2if->base)) & 0xffff0000) {
 		serio_interrupt(ps2if->io, status & 0xff, 0);
 		handled = IRQ_HANDLED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return handled;
diff -u -p a/input/serio/serio.c b/input/serio/serio.c
--- a/input/serio/serio.c
+++ b/input/serio/serio.c
@@ -90,6 +90,11 @@ static void serio_disconnect_driver(stru
 
 static int serio_match_port(const struct serio_device_id *ids, struct serio *serio)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ids->type || ids->proto) {
 		if ((ids->type == SERIO_ANY || ids->type == serio->id.type) &&
 		    (ids->proto == SERIO_ANY || ids->proto == serio->id.proto) &&
@@ -97,6 +102,12 @@ static int serio_match_port(const struct
 		    (ids->id == SERIO_ANY || ids->id == serio->id.id))
 			return 1;
 		ids++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -220,7 +231,12 @@ static void serio_handle_event(struct wo
 
 	mutex_lock(&serio_mutex);
 
-	while ((event = serio_get_event())) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((event = serio_get_event())) {
 
 		switch (event->type) {
 
@@ -248,6 +264,12 @@ static void serio_handle_event(struct wo
 
 		serio_remove_duplicate_events(event->object, event->type);
 		serio_free_event(event);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&serio_mutex);
@@ -650,6 +672,11 @@ static void serio_disconnect_port(struct
 	 * Children ports should be disconnected and destroyed
 	 * first; we travel the tree in depth-first order.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&serio->children)) {
 
 		/* Locate a leaf */
@@ -669,6 +696,12 @@ static void serio_disconnect_port(struct
 
 			s = parent;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/input/serio/gscps2.c b/input/serio/gscps2.c
--- a/input/serio/gscps2.c
+++ b/input/serio/gscps2.c
@@ -119,10 +119,21 @@ struct gscps2port {
 static int wait_TBE(char *addr)
 {
 	int timeout = 25000; /* device is expected to react within 250 msec */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (gscps2_readb_status(addr) & GSC_STAT_TBNE) {
 		if (!--timeout)
 			return 0;	/* This should not happen */
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 1;
 }
@@ -236,11 +247,22 @@ static irqreturn_t gscps2_interrupt(int
 	  unsigned long flags;
 	  spin_lock_irqsave(&ps2port->lock, flags);
 
-	  while ( (ps2port->buffer[ps2port->append].str =
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	  unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ( (ps2port->buffer[ps2port->append].str =
 		   gscps2_readb_status(ps2port->addr)) & GSC_STAT_RBNE ) {
 		ps2port->buffer[ps2port->append].data =
 				gscps2_readb_input(ps2port->addr);
 		ps2port->append = ((ps2port->append+1) & BUFFER_SIZE);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	  }
 
 	  spin_unlock_irqrestore(&ps2port->lock, flags);
@@ -251,6 +273,11 @@ static irqreturn_t gscps2_interrupt(int
 
 	list_for_each_entry(ps2port, &ps2port_list, node) {
 
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	  unsigned long long timeout;
+	  timeout = rdstcll(start) + delta;
 	  while (ps2port->act != ps2port->append) {
 
 	    unsigned int rxflags;
@@ -270,6 +297,12 @@ static irqreturn_t gscps2_interrupt(int
 
 	    serio_interrupt(ps2port->port, data, rxflags);
 
+	    if (_cur < timeout) {
+			rdstcll(_cur);
+	    }
+	    else {
+			break;
+	    }
 	  } /* while() */
 
 	} /* list_for_each_entry */
diff -u -p a/input/serio/hp_sdc.c b/input/serio/hp_sdc.c
--- a/input/serio/hp_sdc.c
+++ b/input/serio/hp_sdc.c
@@ -171,8 +171,19 @@ static inline void hp_sdc_spin_ibf(void)
 	}
 	read_unlock(lock);
 	write_lock(lock);
-	while (sdc_readb(hp_sdc.status_io) & HP_SDC_STATUS_IBF)
-		{ }
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (sdc_readb(hp_sdc.status_io) & HP_SDC_STATUS_IBF)
+		{ if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+		}
 	hp_sdc.ibf = 0;
 	write_unlock_irqrestore(lock, flags);
 }
diff -u -p a/input/serio/rpckbd.c b/input/serio/rpckbd.c
--- a/input/serio/rpckbd.c
+++ b/input/serio/rpckbd.c
@@ -62,11 +62,22 @@ static irqreturn_t rpckbd_rx(int irq, vo
 	unsigned int byte;
 	int handled = IRQ_NONE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (iomd_readb(IOMD_KCTRL) & (1 << 5)) {
 		byte = iomd_readb(IOMD_KARTRX);
 
 		serio_interrupt(port, byte, 0);
 		handled = IRQ_HANDLED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return handled;
 }
diff -u -p a/input/serio/serio_raw.c b/input/serio/serio_raw.c
--- a/input/serio/serio_raw.c
+++ b/input/serio/serio_raw.c
@@ -180,10 +180,21 @@ static ssize_t serio_raw_read(struct fil
 	if (serio_raw->dead)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retval < count && serio_raw_fetch_byte(serio_raw, &c)) {
 		if (put_user(c, buffer++))
 			return -EFAULT;
 		retval++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return retval;
diff -u -p a/input/touchscreen/atmel_mxt_ts.c b/input/touchscreen/atmel_mxt_ts.c
--- a/input/touchscreen/atmel_mxt_ts.c
+++ b/input/touchscreen/atmel_mxt_ts.c
@@ -977,7 +977,12 @@ static int mxt_load_fw(struct device *de
 	/* Unlock bootloader */
 	mxt_unlock_bootloader(client);
 
-	while (pos < fw->size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pos < fw->size) {
 		ret = mxt_check_bootloader(client,
 						MXT_WAITING_FRAME_DATA);
 		if (ret)
@@ -1001,7 +1006,13 @@ static int mxt_load_fw(struct device *de
 		pos += frame_size;
 
 		dev_dbg(dev, "Updated %d bytes / %zd bytes\n", pos, fw->size);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	release_firmware(fw);
diff -u -p a/input/touchscreen/wm9705.c b/input/touchscreen/wm9705.c
--- a/input/touchscreen/wm9705.c
+++ b/input/touchscreen/wm9705.c
@@ -234,10 +234,21 @@ static int wm9705_poll_sample(struct wm9
 	poll_delay(delay);
 
 	/* wait for POLL to go low */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout == 0) {
diff -u -p a/input/touchscreen/wm9712.c b/input/touchscreen/wm9712.c
--- a/input/touchscreen/wm9712.c
+++ b/input/touchscreen/wm9712.c
@@ -274,10 +274,21 @@ static int wm9712_poll_sample(struct wm9
 	poll_delay(delay);
 
 	/* wait for POLL to go low */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout <= 0) {
@@ -334,10 +345,21 @@ static int wm9712_poll_coord(struct wm97
 	poll_delay(delay);
 	data->x = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);
 	/* wait for POLL to go low */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout <= 0) {
diff -u -p a/input/touchscreen/wm9713.c b/input/touchscreen/wm9713.c
--- a/input/touchscreen/wm9713.c
+++ b/input/touchscreen/wm9713.c
@@ -284,10 +284,21 @@ static int wm9713_poll_sample(struct wm9
 	poll_delay(delay);
 
 	/* wait for POLL to go low */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((wm97xx_reg_read(wm, AC97_WM9713_DIG1) & WM9713_POLL) &&
 		timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout <= 0) {
@@ -349,10 +360,21 @@ static int wm9713_poll_coord(struct wm97
 	poll_delay(delay);
 	data->x = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);
 	/* wait for POLL to go low */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((wm97xx_reg_read(wm, AC97_WM9713_DIG1) & WM9713_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout <= 0) {
diff -u -p a/input/touchscreen/tps6507x-ts.c b/input/touchscreen/tps6507x-ts.c
--- a/input/touchscreen/tps6507x-ts.c
+++ b/input/touchscreen/tps6507x-ts.c
@@ -152,12 +152,23 @@ static s32 tps6507x_adc_standby(struct t
 	if (ret)
 		return ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (val & TPS6507X_REG_TSC_INT) {
 		mdelay(10);
 		ret = tps6507x_read_u8(tsc, TPS6507X_REG_INT, &val);
 		if (ret)
 			return ret;
 		loops++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
diff -u -p a/input/touchscreen/ads7846.c b/input/touchscreen/ads7846.c
--- a/input/touchscreen/ads7846.c
+++ b/input/touchscreen/ads7846.c
@@ -721,6 +721,11 @@ static void ads7846_read_state(struct ad
 	int action;
 	int error;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (msg_idx < ts->msg_count) {
 
 		ts->wait_for_sync();
@@ -763,6 +768,12 @@ static void ads7846_read_state(struct ad
 		} else {
 			msg_idx++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -879,6 +890,11 @@ static irqreturn_t ads7846_irq(int irq,
 	/* Start with a small delay before checking pendown state */
 	msleep(TS_POLL_DELAY);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!ts->stopped && get_pendown_state(ts)) {
 
 		/* pen is down, continue with the measurement */
@@ -889,6 +905,12 @@ static irqreturn_t ads7846_irq(int irq,
 
 		wait_event_timeout(ts->wait, ts->stopped,
 				   msecs_to_jiffies(TS_POLL_PERIOD));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ts->pendown) {
diff -u -p a/input/touchscreen/ucb1400_ts.c b/input/touchscreen/ucb1400_ts.c
--- a/input/touchscreen/ucb1400_ts.c
+++ b/input/touchscreen/ucb1400_ts.c
@@ -187,6 +187,11 @@ static int ucb1400_ts_thread(void *_ucb)
 	sched_setscheduler(tsk, SCHED_FIFO, &param);
 
 	set_freezable();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		unsigned int x, y, p;
 		long timeout;
@@ -231,6 +236,12 @@ static int ucb1400_ts_thread(void *_ucb)
 		wait_event_freezable_timeout(ucb->ts_wait,
 			ucb->irq_pending || ucb->ts_restart ||
 			kthread_should_stop(), timeout);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Send the "pen off" if we are stopping with the pen still active */
@@ -317,7 +328,12 @@ static int ucb1400_ts_detect_irq(struct
 
 	/* Wait for the conversion to complete. */
 	timeout = jiffies + HZ/2;
-	while (!(ucb1400_reg_read(ucb->ac97, UCB_ADC_DATA) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(ucb1400_reg_read(ucb->ac97, UCB_ADC_DATA) &
 						UCB_ADC_DAT_VALID)) {
 		cpu_relax();
 		if (time_after(jiffies, timeout)) {
@@ -325,6 +341,12 @@ static int ucb1400_ts_detect_irq(struct
 			probe_irq_off(mask);
 			return -ENODEV;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ucb1400_reg_write(ucb->ac97, UCB_ADC_CR, 0);
 
diff -u -p a/input/touchscreen/usbtouchscreen.c b/input/touchscreen/usbtouchscreen.c
--- a/input/touchscreen/usbtouchscreen.c
+++ b/input/touchscreen/usbtouchscreen.c
@@ -1217,7 +1217,12 @@ static void usbtouch_process_multi(struc
 
 	/* loop over the received packet, process */
 	pos = 0;
-	while (pos < buf_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pos < buf_len) {
 		/* get packet len */
 		pkt_len = usbtouch->type->get_pkt_len(buffer + pos,
 							buf_len - pos);
@@ -1238,7 +1243,13 @@ static void usbtouch_process_multi(struc
 			return;
 		}
 		pos += pkt_len;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out_flush_buf:
 	usbtouch->buf_len = 0;
diff -u -p a/input/evdev.c b/input/evdev.c
--- a/input/evdev.c
+++ b/input/evdev.c
@@ -403,6 +403,11 @@ static ssize_t evdev_read(struct file *f
 	if (!evdev->exist)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retval + input_event_size() <= count &&
 	       evdev_fetch_next_event(client, &event)) {
 
@@ -410,6 +415,12 @@ static ssize_t evdev_read(struct file *f
 			return -EFAULT;
 
 		retval += input_event_size();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return retval;
diff -u -p a/input/tablet/gtco.c b/input/tablet/gtco.c
--- a/input/tablet/gtco.c
+++ b/input/tablet/gtco.c
@@ -231,6 +231,11 @@ static void parse_hid_report_descriptor(
 	dbg("======>>>>>>PARSE<<<<<<======");
 
 	/* Walk  this report and pull out the info we need */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < length) {
 		prefix = report[i];
 
@@ -528,6 +533,12 @@ static void parse_hid_report_descriptor(
 
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/input/joydev.c b/input/joydev.c
--- a/input/joydev.c
+++ b/input/joydev.c
@@ -424,6 +424,11 @@ static ssize_t joydev_read(struct file *
 	if (!joydev->exist)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retval + sizeof(struct js_event) <= count &&
 	       joydev_generate_startup_event(client, input, &event)) {
 
@@ -431,8 +436,19 @@ static ssize_t joydev_read(struct file *
 			return -EFAULT;
 
 		retval += sizeof(struct js_event);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retval + sizeof(struct js_event) <= count &&
 	       joydev_fetch_next_event(client, &event)) {
 
@@ -440,6 +456,12 @@ static ssize_t joydev_read(struct file *
 			return -EFAULT;
 
 		retval += sizeof(struct js_event);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return retval;
diff -u -p a/input/gameport/gameport.c b/input/gameport/gameport.c
--- a/input/gameport/gameport.c
+++ b/input/gameport/gameport.c
@@ -132,7 +132,18 @@ static int gameport_measure_speed(struct
 		return 0;
 
 	j = jiffies; while (j == jiffies);
-	j = jiffies; while (j == jiffies) { t++; gameport_read(gameport); }
+	j = jiffies; unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (j == jiffies) { t++; gameport_read(gameport); if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 
 	gameport_close(gameport);
 	return t * HZ / 1000;
diff -u -p a/input/joystick/sidewinder.c b/input/joystick/sidewinder.c
--- a/input/joystick/sidewinder.c
+++ b/input/joystick/sidewinder.c
@@ -286,9 +286,20 @@ static int sw_check(__u64 t)
 	if ((t & 0x8080808080808080ULL) ^ 0x80)			/* Sync */
 		return -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (t) {						/* Sum */
 		sum += t & 0xf;
 		t >>= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return sum & 0xf;
diff -u -p a/input/keyboard/gpio_keys.c b/input/keyboard/gpio_keys.c
--- a/input/keyboard/gpio_keys.c
+++ b/input/keyboard/gpio_keys.c
@@ -486,6 +486,11 @@ static int gpio_keys_get_devtree_pdata(s
 
 	pp = NULL;
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((pp = of_get_next_child(node, pp))) {
 		enum of_gpio_flags flags;
 
@@ -518,6 +523,12 @@ static int gpio_keys_get_devtree_pdata(s
 			buttons[i].debounce_interval = 5;
 
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pdata->buttons = buttons;
diff -u -p a/input/keyboard/hil_kbd.c b/input/keyboard/hil_kbd.c
--- a/input/keyboard/hil_kbd.c
+++ b/input/keyboard/hil_kbd.c
@@ -248,6 +248,11 @@ static void hil_dev_handle_ptr_events(st
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt < idx - 1) {
 		unsigned int btn = ptr->data[cnt++];
 		int up = btn & 1;
@@ -260,6 +265,12 @@ static void hil_dev_handle_ptr_events(st
 		btn = (btn - 0x80) >> 1;
 		btn = ptr->btnmap[btn];
 		input_report_key(dev, btn, !up);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_sync(dev);
diff -u -p a/input/keyboard/lm8323.c b/input/keyboard/lm8323.c
--- a/input/keyboard/lm8323.c
+++ b/input/keyboard/lm8323.c
@@ -491,12 +491,23 @@ static void lm8323_pwm_work(struct work_
 	else if (perstep > 63)
 		perstep = 63;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (steps) {
 		int s;
 
 		s = min(126, steps);
 		pwm_cmds[num_cmds++] = PWM_RAMP(div512, perstep, s, up);
 		steps -= s;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lm8323_write_pwm(pwm, kill, num_cmds, pwm_cmds);
diff -u -p a/input/keyboard/tnetv107x-keypad.c b/input/keyboard/tnetv107x-keypad.c
--- a/input/keyboard/tnetv107x-keypad.c
+++ b/input/keyboard/tnetv107x-keypad.c
@@ -86,6 +86,11 @@ static irqreturn_t keypad_irq(int irq, v
 	for (i = 0; i < 3; i++) {
 		change = curr_keys[i] ^ kp->prev_keys[i];
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (change) {
 			bit     = fls(change) - 1;
 			change ^= BIT(bit);
@@ -98,6 +103,12 @@ static irqreturn_t keypad_irq(int irq, v
 			input_event(kp->input_dev, EV_MSC, MSC_SCAN, code);
 			input_report_key(kp->input_dev, kp->keycodes[code],
 					 val);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	input_sync(kp->input_dev);
diff -u -p a/iommu/amd_iommu_init.c b/iommu/amd_iommu_init.c
--- a/iommu/amd_iommu_init.c
+++ b/iommu/amd_iommu_init.c
@@ -414,7 +414,12 @@ static int __init find_last_devid_from_i
 			PCI_FUNC(h->devid),
 			h->cap_ptr);
 
-	while (p < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (p < end) {
 		dev = (struct ivhd_entry *)p;
 		switch (dev->type) {
 		case IVHD_DEV_SELECT:
@@ -428,6 +433,12 @@ static int __init find_last_devid_from_i
 			break;
 		}
 		p += ivhd_entry_length(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	WARN_ON(p != end);
@@ -461,7 +472,12 @@ static int __init find_last_devid_acpi(s
 	p += IVRS_HEADER_LENGTH;
 
 	end += table->length;
-	while (p < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (p < end) {
 		h = (struct ivhd_header *)p;
 		switch (h->type) {
 		case ACPI_IVHD_TYPE:
@@ -471,6 +487,12 @@ static int __init find_last_devid_acpi(s
 			break;
 		}
 		p += h->length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	WARN_ON(p != end);
 
@@ -750,6 +772,11 @@ static void __init init_iommu_from_acpi(
 	end += h->length;
 
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p < end) {
 		e = (struct ivhd_entry *)p;
 		switch (e->type) {
@@ -883,6 +910,12 @@ static void __init init_iommu_from_acpi(
 		}
 
 		p += ivhd_entry_length(p);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1021,6 +1054,11 @@ static int __init init_iommu_all(struct
 	end += table->length;
 	p += IVRS_HEADER_LENGTH;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p < end) {
 		h = (struct ivhd_header *)p;
 		switch (*p) {
@@ -1051,6 +1089,12 @@ static int __init init_iommu_all(struct
 		}
 		p += h->length;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	WARN_ON(p != end);
 
@@ -1207,6 +1251,11 @@ static int __init init_memory_definition
 	end += table->length;
 	p += IVRS_HEADER_LENGTH;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p < end) {
 		m = (struct ivmd_header *)p;
 		if (m->flags & IVMD_FLAG_EXCL_RANGE)
@@ -1215,6 +1264,12 @@ static int __init init_memory_definition
 			init_unity_map_range(m);
 
 		p += m->length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/iommu/dmar.c b/iommu/dmar.c
--- a/iommu/dmar.c
+++ b/iommu/dmar.c
@@ -127,6 +127,11 @@ int __init dmar_parse_dev_scope(void *st
 	int ret;
 
 	*cnt = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start < end) {
 		scope = start;
 		if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_ENDPOINT ||
@@ -137,6 +142,12 @@ int __init dmar_parse_dev_scope(void *st
 			       "Unsupported device scope\n");
 		}
 		start += scope->length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (*cnt == 0)
 		return 0;
@@ -147,6 +158,11 @@ int __init dmar_parse_dev_scope(void *st
 
 	start = tmp;
 	index = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start < end) {
 		scope = start;
 		if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_ENDPOINT ||
@@ -160,6 +176,12 @@ int __init dmar_parse_dev_scope(void *st
 			index ++;
 		}
 		start += scope->length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -387,6 +409,11 @@ static int dmar_pci_device_match(struct
 {
 	int index;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dev) {
 		for (index = 0; index < cnt; index++)
 			if (dev == devices[index])
@@ -394,6 +421,12 @@ static int dmar_pci_device_match(struct
 
 		/* Check our parent */
 		dev = dev->bus->self;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return 0;
@@ -501,7 +534,12 @@ int __init check_zero_address(void)
 	dmar = (struct acpi_table_dmar *)dmar_tbl;
 	entry_header = (struct acpi_dmar_header *)(dmar + 1);
 
-	while (((unsigned long)entry_header) <
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (((unsigned long)entry_header) <
 			(((unsigned long)dmar) + dmar_tbl->length)) {
 		/* Avoid looping forever on bad ACPI tables */
 		if (entry_header->length == 0) {
@@ -536,6 +574,12 @@ int __init check_zero_address(void)
 		}
 
 		entry_header = ((void *)entry_header + entry_header->length);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 1;
 
diff -u -p a/iommu/iova.c b/iommu/iova.c
--- a/iommu/iova.c
+++ b/iommu/iova.c
@@ -150,7 +150,12 @@ move_left:
 			entry = &iovad->rbroot.rb_node;
 
 		/* Figure out where to put new node */
-		while (*entry) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (*entry) {
 			struct iova *this = container_of(*entry,
 							struct iova, node);
 			parent = *entry;
@@ -161,6 +166,12 @@ move_left:
 				entry = &((*entry)->rb_right);
 			else
 				BUG(); /* this should not happen */
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 
 		/* Add new node and rebalance tree. */
@@ -180,6 +191,11 @@ iova_insert_rbtree(struct rb_root *root,
 {
 	struct rb_node **new = &(root->rb_node), *parent = NULL;
 	/* Figure out where to put new node */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*new) {
 		struct iova *this = container_of(*new, struct iova, node);
 		parent = *new;
@@ -190,6 +206,12 @@ iova_insert_rbtree(struct rb_root *root,
 			new = &((*new)->rb_right);
 		else
 			BUG(); /* this should not happen */
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	/* Add new node and rebalance tree. */
 	rb_link_node(&iova->node, parent, new);
@@ -251,6 +273,11 @@ struct iova *find_iova(struct iova_domai
 	/* Take the lock so that no other thread is manipulating the rbtree */
 	spin_lock_irqsave(&iovad->iova_rbtree_lock, flags);
 	node = iovad->rbroot.rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (node) {
 		struct iova *iova = container_of(node, struct iova, node);
 
@@ -270,6 +297,12 @@ struct iova *find_iova(struct iova_domai
 			node = node->rb_left;
 		else if (pfn > iova->pfn_lo)
 			node = node->rb_right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags);
@@ -322,11 +355,22 @@ void put_iova_domain(struct iova_domain
 
 	spin_lock_irqsave(&iovad->iova_rbtree_lock, flags);
 	node = rb_first(&iovad->rbroot);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (node) {
 		struct iova *iova = container_of(node, struct iova, node);
 		rb_erase(node, &iovad->rbroot);
 		free_iova_mem(iova);
 		node = rb_first(&iovad->rbroot);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags);
 }
diff -u -p a/iommu/intr_remapping.c b/iommu/intr_remapping.c
--- a/iommu/intr_remapping.c
+++ b/iommu/intr_remapping.c
@@ -35,6 +35,11 @@ static __init int setup_intremap(char *s
 	if (!str)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*str) {
 		if (!strncmp(str, "on", 2))
 			disable_intremap = 0;
@@ -48,6 +53,12 @@ static __init int setup_intremap(char *s
 		str += strcspn(str, ",");
 		while (*str == ',')
 			str++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -713,6 +724,11 @@ static int ir_parse_ioapic_hpet_scope(st
 	start = (void *)(drhd + 1);
 	end = ((void *)drhd) + header->length;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start < end) {
 		scope = start;
 		if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_IOAPIC) {
@@ -739,6 +755,12 @@ static int ir_parse_ioapic_hpet_scope(st
 			ir_parse_one_hpet_scope(scope, iommu);
 		}
 		start += scope->length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/iommu/omap-iovmm.c b/iommu/omap-iovmm.c
--- a/iommu/omap-iovmm.c
+++ b/iommu/omap-iovmm.c
@@ -92,6 +92,11 @@ static unsigned sgtable_nents(size_t byt
 		return 0;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bytes) {
 		ent_sz = max_alignment(da | pa);
 		ent_sz = min_t(unsigned, ent_sz, iopgsz_max(bytes));
@@ -99,6 +104,12 @@ static unsigned sgtable_nents(size_t byt
 		da += ent_sz;
 		pa += ent_sz;
 		bytes -= ent_sz;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return nr_entries;
diff -u -p a/iommu/intel-iommu.c b/iommu/intel-iommu.c
--- a/iommu/intel-iommu.c
+++ b/iommu/intel-iommu.c
@@ -426,6 +426,11 @@ static int __init intel_iommu_setup(char
 {
 	if (!str)
 		return -EINVAL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*str) {
 		if (!strncmp(str, "on", 2)) {
 			dmar_disabled = 0;
@@ -454,6 +459,12 @@ static int __init intel_iommu_setup(char
 		str += strcspn(str, ",");
 		while (*str == ',')
 			str++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return 0;
 }
@@ -1663,7 +1674,12 @@ domain_context_mapping(struct dmar_domai
 		return 0;
 	/* Secondary interface's bus number and devfn 0 */
 	parent = pdev->bus->self;
-	while (parent != tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (parent != tmp) {
 		ret = domain_context_mapping_one(domain,
 						 pci_domain_nr(parent->bus),
 						 parent->bus->number,
@@ -1671,6 +1687,12 @@ domain_context_mapping(struct dmar_domai
 		if (ret)
 			return ret;
 		parent = parent->bus->self;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (pci_is_pcie(tmp)) /* this is a PCIe-to-PCI bridge */
 		return domain_context_mapping_one(domain,
@@ -1705,12 +1727,23 @@ static int domain_context_mapped(struct
 		return ret;
 	/* Secondary interface's bus number and devfn 0 */
 	parent = pdev->bus->self;
-	while (parent != tmp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (parent != tmp) {
 		ret = device_context_mapped(iommu, parent->bus->number,
 					    parent->devfn);
 		if (!ret)
 			return ret;
 		parent = parent->bus->self;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (pci_is_pcie(tmp))
 		return device_context_mapped(iommu, tmp->subordinate->number,
@@ -1895,7 +1928,12 @@ static void domain_remove_dev_info(struc
 	struct intel_iommu *iommu;
 
 	spin_lock_irqsave(&device_domain_lock, flags);
-	while (!list_empty(&domain->devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&domain->devices)) {
 		info = list_entry(domain->devices.next,
 			struct device_domain_info, link);
 		list_del(&info->link);
@@ -1910,6 +1948,12 @@ static void domain_remove_dev_info(struc
 		free_devinfo_mem(info);
 
 		spin_lock_irqsave(&device_domain_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&device_domain_lock, flags);
 }
@@ -3711,10 +3755,21 @@ static void iommu_detach_dependent_devic
 	/* Secondary interface's bus number and devfn 0 */
 	if (tmp) {
 		parent = pdev->bus->self;
-		while (parent != tmp) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (parent != tmp) {
 			iommu_detach_dev(iommu, parent->bus->number,
 					 parent->devfn);
 			parent = parent->bus->self;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if (pci_is_pcie(tmp)) /* this is a PCIe-to-PCI bridge */
 			iommu_detach_dev(iommu,
@@ -3800,7 +3855,12 @@ static void vm_domain_remove_all_dev_inf
 	unsigned long flags1, flags2;
 
 	spin_lock_irqsave(&device_domain_lock, flags1);
-	while (!list_empty(&domain->devices)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&domain->devices)) {
 		info = list_entry(domain->devices.next,
 			struct device_domain_info, link);
 		list_del(&info->link);
@@ -3828,6 +3888,12 @@ static void vm_domain_remove_all_dev_inf
 
 		free_devinfo_mem(info);
 		spin_lock_irqsave(&device_domain_lock, flags1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&device_domain_lock, flags1);
 }
@@ -4001,6 +4067,11 @@ static int intel_iommu_attach_device(str
 	/*
 	 * Knock out extra levels of page tables if necessary
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (iommu->agaw < dmar_domain->agaw) {
 		struct dma_pte *pte;
 
@@ -4011,6 +4082,12 @@ static int intel_iommu_attach_device(str
 			free_pgtable_page(pte);
 		}
 		dmar_domain->agaw--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return domain_add_dev_info(dmar_domain, pdev, CONTEXT_TT_MULTI_LEVEL);
diff -u -p a/iommu/amd_iommu.c b/iommu/amd_iommu.c
--- a/iommu/amd_iommu.c
+++ b/iommu/amd_iommu.c
@@ -470,9 +470,20 @@ static void iommu_poll_events(struct amd
 	head = readl(iommu->mmio_base + MMIO_EVT_HEAD_OFFSET);
 	tail = readl(iommu->mmio_base + MMIO_EVT_TAIL_OFFSET);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (head != tail) {
 		iommu_print_event(iommu, iommu->evt_buf + head);
 		head = (head + EVENT_ENTRY_SIZE) % iommu->evt_buf_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	writel(head, iommu->mmio_base + MMIO_EVT_HEAD_OFFSET);
@@ -924,6 +935,11 @@ static u64 *alloc_pte(struct protection_
 	address = PAGE_SIZE_ALIGN(address, page_size);
 	end_lvl = PAGE_SIZE_LEVEL(page_size);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (level > end_lvl) {
 		if (!IOMMU_PTE_PRESENT(*pte)) {
 			page = (u64 *)get_zeroed_page(gfp);
@@ -944,6 +960,12 @@ static u64 *alloc_pte(struct protection_
 			*pte_page = pte;
 
 		pte = &pte[PM_LEVEL_INDEX(level, address)];
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return pte;
diff -u -p a/media/rc/rc-main.c b/media/rc/rc-main.c
--- a/media/rc/rc-main.c
+++ b/media/rc/rc-main.c
@@ -414,6 +414,11 @@ static unsigned int ir_lookup_by_scancod
 	int end = rc_map->len - 1;
 	int mid;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start <= end) {
 		mid = (start + end) / 2;
 		if (rc_map->scan[mid].scancode < scancode)
@@ -422,6 +427,12 @@ static unsigned int ir_lookup_by_scancod
 			end = mid - 1;
 		else
 			return mid;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return -1U;
diff -u -p a/media/rc/nuvoton-cir.c b/media/rc/nuvoton-cir.c
--- a/media/rc/nuvoton-cir.c
+++ b/media/rc/nuvoton-cir.c
@@ -890,9 +890,20 @@ static irqreturn_t nvt_cir_wake_isr(int
 
 	if ((status & CIR_WAKE_IRSTS_PE) &&
 	    (nvt->wake_state == ST_WAKE_START)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY_IDX)) {
 			val = nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY);
 			nvt_dbg("setting wake up key: 0x%x", val);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		nvt_cir_wake_reg_write(nvt, 0, CIR_WAKE_IREN);
diff -u -p a/media/rc/ite-cir.c b/media/rc/ite-cir.c
--- a/media/rc/ite-cir.c
+++ b/media/rc/ite-cir.c
@@ -196,6 +196,11 @@ static void ite_decode_bytes(struct ite_
 		ir_raw_event_store_with_filter(dev->rdev, &ev);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next_one < size) {
 		next_zero = find_next_zero_bit_le(ldata, size, next_one + 1);
 		ev.pulse = false;
@@ -215,6 +220,12 @@ static void ite_decode_bytes(struct ite_
 			    (dev->rdev, &ev);
 		} else
 			next_one = size;
+			if (_cur < timeout) {
+			    rdstcll(_cur);
+			}
+			else {
+			    break;
+			}
 	}
 
 	ir_raw_event_handle(dev->rdev);
diff -u -p a/media/rc/ir-raw.c b/media/rc/ir-raw.c
--- a/media/rc/ir-raw.c
+++ b/media/rc/ir-raw.c
@@ -43,6 +43,11 @@ static int ir_raw_event_thread(void *dat
 	struct ir_raw_event_ctrl *raw = (struct ir_raw_event_ctrl *)data;
 	int retval;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 
 		spin_lock_irq(&raw->lock);
@@ -69,6 +74,12 @@ static int ir_raw_event_thread(void *dat
 			handler->decode(raw->dev, ev);
 		raw->prev_ev = ev;
 		mutex_unlock(&ir_raw_handler_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/media/rc/winbond-cir.c b/media/rc/winbond-cir.c
--- a/media/rc/winbond-cir.c
+++ b/media/rc/winbond-cir.c
@@ -353,6 +353,11 @@ wbcir_irq_rx(struct wbcir_data *data, st
 	DEFINE_IR_RAW_EVENT(rawir);
 
 	/* Since RXHDLEV is set, at least 8 bytes are in the FIFO */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (inb(data->sbase + WBCIR_REG_SP3_LSR) & WBCIR_RX_AVAIL) {
 		irdata = inb(data->sbase + WBCIR_REG_SP3_RXDATA);
 		if (data->rxstate == WBCIR_RXSTATE_ERROR)
@@ -360,6 +365,12 @@ wbcir_irq_rx(struct wbcir_data *data, st
 		rawir.pulse = irdata & 0x80 ? false : true;
 		rawir.duration = US_TO_NS((irdata & 0x7F) * 10);
 		ir_raw_event_store_with_filter(data->dev, &rawir);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Check if we should go idle */
diff -u -p a/media/dvb/pt1/pt1.c b/media/dvb/pt1/pt1.c
--- a/media/dvb/pt1/pt1.c
+++ b/media/dvb/pt1/pt1.c
@@ -313,6 +313,11 @@ static int pt1_thread(void *data)
 	table_index = 0;
 	buf_index = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		try_to_freeze();
 
@@ -328,6 +333,12 @@ static int pt1_thread(void *data)
 			if (++table_index >= pt1_nr_tables)
 				table_index = 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return 0;
@@ -455,12 +466,23 @@ static int pt1_init_tables(struct pt1 *p
 		i++;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < pt1_nr_tables) {
 		ret = pt1_init_table(pt1, &tables[i], &pfn);
 		if (ret)
 			goto err;
 		tables[i - 1].page->next_pfn = cpu_to_le32(pfn);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tables[pt1_nr_tables - 1].page->next_pfn = cpu_to_le32(first_pfn);
diff -u -p a/media/dvb/frontends/tda10048.c b/media/dvb/frontends/tda10048.c
--- a/media/dvb/frontends/tda10048.c
+++ b/media/dvb/frontends/tda10048.c
@@ -545,7 +545,12 @@ static int tda10048_firmware_upload(stru
 		tda10048_writereg(state, TDA10048_DSP_CODE_CPT, 0);
 
 		/* Download the firmware payload */
-		while (pos < fw->size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (pos < fw->size) {
 
 			if ((fw->size - pos) > wlen)
 				cnt = wlen;
@@ -556,6 +561,12 @@ static int tda10048_firmware_upload(stru
 				&fw->data[pos], cnt);
 
 			pos += cnt;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		ret = -EIO;
diff -u -p a/media/dvb/frontends/tda1004x.c b/media/dvb/frontends/tda1004x.c
--- a/media/dvb/frontends/tda1004x.c
+++ b/media/dvb/frontends/tda1004x.c
@@ -330,6 +330,11 @@ static int tda1004x_do_upload(struct tda
 	fw_msg.addr = state->config->demod_address;
 
 	buf[0] = dspCodeInReg;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos != len) {
 		// work out how much to send this time
 		tx_size = len - pos;
@@ -346,6 +351,12 @@ static int tda1004x_do_upload(struct tda
 		pos += tx_size;
 
 		dprintk("%s: fw_pos=0x%x\n", __func__, pos);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	// give the DSP a chance to settle 03/10/05 Hac
 	msleep(100);
diff -u -p a/media/dvb/frontends/cx24116.c b/media/dvb/frontends/cx24116.c
--- a/media/dvb/frontends/cx24116.c
+++ b/media/dvb/frontends/cx24116.c
@@ -548,7 +548,12 @@ static int cx24116_cmd_execute(struct dv
 
 	/* Start execution and wait for cmd to terminate */
 	cx24116_writereg(state, CX24116_REG_EXECUTE, 0x01);
-	while (cx24116_readreg(state, CX24116_REG_EXECUTE)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cx24116_readreg(state, CX24116_REG_EXECUTE)) {
 		msleep(10);
 		if (i++ > 64) {
 			/* Avoid looping forever if the firmware does
@@ -557,6 +562,12 @@ static int cx24116_cmd_execute(struct dv
 				__func__);
 			return -EREMOTEIO;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/media/dvb/frontends/cx24123.c b/media/dvb/frontends/cx24123.c
--- a/media/dvb/frontends/cx24123.c
+++ b/media/dvb/frontends/cx24123.c
@@ -643,6 +643,11 @@ static int cx24123_pll_writereg(struct d
 	 * wait for the send to be completed */
 	timeout = jiffies + msecs_to_jiffies(40);
 	cx24123_writereg(state, 0x22, (data) & 0xff);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cx24123_readreg(state, 0x20) & 0x80)) {
 		if (time_after(jiffies, timeout)) {
 			err("%s:  demodulator is not responding," \
@@ -650,6 +655,12 @@ static int cx24123_pll_writereg(struct d
 			return -EREMOTEIO;
 		}
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Trigger the demod to configure the tuner */
diff -u -p a/media/dvb/frontends/stb0899_algo.c b/media/dvb/frontends/stb0899_algo.c
--- a/media/dvb/frontends/stb0899_algo.c
+++ b/media/dvb/frontends/stb0899_algo.c
@@ -1124,11 +1124,22 @@ static int stb0899_dvbs2_get_data_lock(s
 	int time = 0, lock = 0;
 	u8 reg;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((!lock) && (time < timeout)) {
 		reg = stb0899_read_reg(state, STB0899_CFGPDELSTATUS1);
 		dprintk(state->verbose, FE_DEBUG, 1, "---------> CFGPDELSTATUS=[0x%02x]", reg);
 		lock = STB0899_GETFIELD(CFGPDELSTATUS_LOCK, reg);
 		time++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return lock;
diff -u -p a/media/dvb/frontends/dib7000m.c b/media/dvb/frontends/dib7000m.c
--- a/media/dvb/frontends/dib7000m.c
+++ b/media/dvb/frontends/dib7000m.c
@@ -130,6 +130,11 @@ static void dib7000m_write_tab(struct di
 	u16 l = 0, r, *n;
 	n = buf;
 	l = *n++;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (l) {
 		r = *n++;
 
@@ -141,6 +146,12 @@ static void dib7000m_write_tab(struct di
 			r++;
 		} while (--l);
 		l = *n++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/dvb/frontends/dib7000p.c b/media/dvb/frontends/dib7000p.c
--- a/media/dvb/frontends/dib7000p.c
+++ b/media/dvb/frontends/dib7000p.c
@@ -142,6 +142,11 @@ static void dib7000p_write_tab(struct di
 	u16 l = 0, r, *n;
 	n = buf;
 	l = *n++;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (l) {
 		r = *n++;
 
@@ -150,6 +155,12 @@ static void dib7000p_write_tab(struct di
 			r++;
 		} while (--l);
 		l = *n++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/dvb/frontends/sp8870.c b/media/dvb/frontends/sp8870.c
--- a/media/dvb/frontends/sp8870.c
+++ b/media/dvb/frontends/sp8870.c
@@ -120,6 +120,11 @@ static int sp8870_firmware_upload (struc
 
 	// do firmware upload
 	fw_pos = SP8870_FIRMWARE_OFFSET;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fw_pos < SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET){
 		tx_len = (fw_pos <= SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - 252) ? 252 : SP8870_FIRMWARE_SIZE + SP8870_FIRMWARE_OFFSET - fw_pos;
 		// write register 0xCF0A
@@ -136,6 +141,12 @@ static int sp8870_firmware_upload (struc
 			return err;
 		}
 		fw_pos += tx_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dprintk ("%s: done!\n", __func__);
diff -u -p a/media/dvb/frontends/dibx000_common.c b/media/dvb/frontends/dibx000_common.c
--- a/media/dvb/frontends/dibx000_common.c
+++ b/media/dvb/frontends/dibx000_common.c
@@ -94,6 +94,11 @@ static int dibx000_master_i2c_write(stru
 	u16 txlen = msg->len, len;
 	const u8 *b = msg->buf;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (txlen) {
 		dibx000_read_word(mst, mst->base_reg + 2);
 
@@ -124,6 +129,12 @@ static int dibx000_master_i2c_write(stru
 		if (dibx000_is_i2c_done(mst) != 0)
 			return -EREMOTEIO;
 		txlen -= len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -135,6 +146,11 @@ static int dibx000_master_i2c_read(struc
 	u8 *b = msg->buf;
 	u16 rxlen = msg->len, len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rxlen) {
 		len = rxlen > 8 ? 8 : rxlen;
 		da = (((u8) (msg->addr)) << 9) |
@@ -158,6 +174,11 @@ static int dibx000_master_i2c_read(struc
 
 		rxlen -= len;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			da = dibx000_read_word(mst, mst->base_reg);
 			*b++ = (da >> 8) & 0xff;
@@ -166,6 +187,18 @@ static int dibx000_master_i2c_read(struc
 				*b++ =  da   & 0xff;
 				len--;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
diff -u -p a/media/dvb/frontends/bcm3510.c b/media/dvb/frontends/bcm3510.c
--- a/media/dvb/frontends/bcm3510.c
+++ b/media/dvb/frontends/bcm3510.c
@@ -185,6 +185,11 @@ static int bcm3510_hab_send_request(stru
 
 /* Polling method: Wait until the AP finishes processing the HAB request */
 	t = jiffies + 1*HZ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, t)) {
 		deb_info("waiting for HAB to complete\n");
 		msleep(10);
@@ -193,6 +198,12 @@ static int bcm3510_hab_send_request(stru
 
 		if (!v.HABSTAT_a8.HABR)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	deb_info("send_request execution timed out.\n");
@@ -670,6 +681,11 @@ static int bcm3510_reset(struct bcm3510_
 		return ret;
 
     t = jiffies + 3*HZ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, t)) {
 		msleep(10);
 		if ((ret = bcm3510_readB(st,0xa2,&v)) < 0)
@@ -677,6 +693,12 @@ static int bcm3510_reset(struct bcm3510_
 
 		if (v.APSTAT1_a2.RESET)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	deb_info("reset timed out\n");
 	return -ETIMEDOUT;
@@ -693,6 +715,11 @@ static int bcm3510_clear_reset(struct bc
 		return ret;
 
     t = jiffies + 3*HZ;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, t)) {
 		msleep(10);
 		if ((ret = bcm3510_readB(st,0xa2,&v)) < 0)
@@ -701,6 +728,12 @@ static int bcm3510_clear_reset(struct bc
 		/* verify that reset is cleared */
 		if (!v.APSTAT1_a2.RESET)
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	deb_info("reset clear timed out\n");
 	return -ETIMEDOUT;
diff -u -p a/media/dvb/frontends/dib0070.c b/media/dvb/frontends/dib0070.c
--- a/media/dvb/frontends/dib0070.c
+++ b/media/dvb/frontends/dib0070.c
@@ -676,6 +676,11 @@ static int dib0070_reset(struct dvb_fron
 
 	n = (u16 *) dib0070_p1f_defaults;
 	l = pgm_read_word(n++);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (l) {
 		r = pgm_read_word(n++);
 		do {
@@ -683,6 +688,12 @@ static int dib0070_reset(struct dvb_fron
 			r++;
 		} while (--l);
 		l = pgm_read_word(n++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (state->cfg->force_crystal_mode != 0)
diff -u -p a/media/dvb/frontends/dib0090.c b/media/dvb/frontends/dib0090.c
--- a/media/dvb/frontends/dib0090.c
+++ b/media/dvb/frontends/dib0090.c
@@ -1413,6 +1413,11 @@ static void dib0090_set_default_config(s
 	u16 l, r;
 
 	l = pgm_read_word(n++);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (l) {
 		r = pgm_read_word(n++);
 		do {
@@ -1420,6 +1425,12 @@ static void dib0090_set_default_config(s
 			r++;
 		} while (--l);
 		l = pgm_read_word(n++);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/dvb/frontends/stv0900_core.c b/media/dvb/frontends/stv0900_core.c
--- a/media/dvb/frontends/stv0900_core.c
+++ b/media/dvb/frontends/stv0900_core.c
@@ -1725,11 +1725,22 @@ static int stv0900_diseqc_send(struct st
 	s32 i = 0;
 
 	stv0900_write_bits(intp, DIS_PRECHARGE, 1);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < NbData) {
 		while (stv0900_get_bits(intp, FIFO_FULL))
 			;/* checkpatch complains */
 		stv0900_write_reg(intp, DISTXDATA, data[i]);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	stv0900_write_bits(intp, DIS_PRECHARGE, 0);
diff -u -p a/media/dvb/frontends/dib8000.c b/media/dvb/frontends/dib8000.c
--- a/media/dvb/frontends/dib8000.c
+++ b/media/dvb/frontends/dib8000.c
@@ -840,6 +840,11 @@ static int dib8000_reset(struct dvb_fron
 		const u16 *n;
 		n = dib8000_defaults;
 		l = *n++;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (l) {
 			r = *n++;
 			do {
@@ -847,6 +852,12 @@ static int dib8000_reset(struct dvb_fron
 				r++;
 			} while (--l);
 			l = *n++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	state->isdbt_cfg_loaded = 0;
diff -u -p a/media/dvb/frontends/tda8083.c b/media/dvb/frontends/tda8083.c
--- a/media/dvb/frontends/tda8083.c
+++ b/media/dvb/frontends/tda8083.c
@@ -171,10 +171,21 @@ static void tda8083_wait_diseqc_fifo (st
 {
 	unsigned long start = jiffies;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (jiffies - start < timeout &&
 	       !(tda8083_readreg(state, 0x02) & 0x80))
 	{
 		msleep(50);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	};
 }
 
diff -u -p a/media/dvb/frontends/stv0299.c b/media/dvb/frontends/stv0299.c
--- a/media/dvb/frontends/stv0299.c
+++ b/media/dvb/frontends/stv0299.c
@@ -193,12 +193,23 @@ static int stv0299_wait_diseqc_fifo (str
 
 	dprintk ("%s\n", __func__);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (stv0299_readreg(state, 0x0a) & 1) {
 		if (jiffies - start > timeout) {
 			dprintk ("%s: timeout!!\n", __func__);
 			return -ETIMEDOUT;
 		}
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	};
 
 	return 0;
diff -u -p a/media/dvb/frontends/stb0899_drv.c b/media/dvb/frontends/stb0899_drv.c
--- a/media/dvb/frontends/stb0899_drv.c
+++ b/media/dvb/frontends/stb0899_drv.c
@@ -723,6 +723,11 @@ static int stb0899_wait_diseqc_rxidle(st
 	u8 reg = 0;
 	unsigned long start = jiffies;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!STB0899_GETFIELD(RXEND, reg)) {
 		reg = stb0899_read_reg(state, STB0899_DISRX_ST0);
 		if (jiffies - start > timeout) {
@@ -730,6 +735,12 @@ static int stb0899_wait_diseqc_rxidle(st
 			return -ETIMEDOUT;
 		}
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -772,6 +783,11 @@ static int stb0899_wait_diseqc_txidle(st
 	u8 reg = 0;
 	unsigned long start = jiffies;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!STB0899_GETFIELD(TXIDLE, reg)) {
 		reg = stb0899_read_reg(state, STB0899_DISSTATUS);
 		if (jiffies - start > timeout) {
@@ -779,6 +795,12 @@ static int stb0899_wait_diseqc_txidle(st
 			return -ETIMEDOUT;
 		}
 		msleep(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/media/dvb/bt8xx/dvb-bt8xx.c b/media/dvb/bt8xx/dvb-bt8xx.c
--- a/media/dvb/bt8xx/dvb-bt8xx.c
+++ b/media/dvb/bt8xx/dvb-bt8xx.c
@@ -55,6 +55,11 @@ static void dvb_bt8xx_task(unsigned long
 
 	//printk("%d ", card->bt->finished_block);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card->bt->last_block != card->bt->finished_block) {
 		(card->bt->TS_Size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)
 			(&card->demux,
@@ -63,6 +68,12 @@ static void dvb_bt8xx_task(unsigned long
 			 card->bt->block_bytes);
 		card->bt->last_block = (card->bt->last_block + 1) %
 					card->bt->block_count;
+					if (_cur < timeout) {
+			rdstcll(_cur);
+					}
+					else {
+			break;
+					}
 	}
 }
 
diff -u -p a/media/dvb/ngene/ngene-dvb.c b/media/dvb/ngene/ngene-dvb.c
--- a/media/dvb/ngene/ngene-dvb.c
+++ b/media/dvb/ngene/ngene-dvb.c
@@ -73,7 +73,12 @@ static ssize_t ts_read(struct file *file
 	int left, avail;
 
 	left = count;
-	while (left) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (left) {
 		if (wait_event_interruptible(
 			    dev->tsin_rbuf.queue,
 			    dvb_ringbuffer_avail(&dev->tsin_rbuf) > 0) < 0)
@@ -84,6 +89,12 @@ static ssize_t ts_read(struct file *file
 		dvb_ringbuffer_read_user(&dev->tsin_rbuf, buf, avail);
 		left -= avail;
 		buf += avail;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return count;
 }
@@ -111,10 +122,21 @@ struct dvb_device ngene_dvbdev_ci = {
 
 static void swap_buffer(u32 *p, u32 len)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		*p = swab32(*p);
 		p++;
 		len -= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/dvb/ngene/ngene-core.c b/media/dvb/ngene/ngene-core.c
--- a/media/dvb/ngene/ngene-core.c
+++ b/media/dvb/ngene/ngene-core.c
@@ -75,7 +75,12 @@ static void event_tasklet(unsigned long
 {
 	struct ngene *dev = (struct ngene *)data;
 
-	while (dev->EventQueueReadIndex != dev->EventQueueWriteIndex) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (dev->EventQueueReadIndex != dev->EventQueueWriteIndex) {
 		struct EVENT_BUFFER Event =
 			dev->EventQueue[dev->EventQueueReadIndex];
 		dev->EventQueueReadIndex =
@@ -86,6 +91,12 @@ static void event_tasklet(unsigned long
 		if ((Event.UARTStatus & 0x02) && (dev->RxEventNotify))
 			dev->RxEventNotify(dev, Event.TimeStamp,
 					   Event.RXCharacter);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/media/dvb/siano/smssdio.c b/media/dvb/siano/smssdio.c
--- a/media/dvb/siano/smssdio.c
+++ b/media/dvb/siano/smssdio.c
@@ -87,7 +87,12 @@ static int smssdio_sendrequest(void *con
 
 	sdio_claim_host(smsdev->func);
 
-	while (size >= smsdev->func->cur_blksize) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (size >= smsdev->func->cur_blksize) {
 		ret = sdio_memcpy_toio(smsdev->func, SMSSDIO_DATA,
 					buffer, smsdev->func->cur_blksize);
 		if (ret)
@@ -95,6 +100,12 @@ static int smssdio_sendrequest(void *con
 
 		buffer += smsdev->func->cur_blksize;
 		size -= smsdev->func->cur_blksize;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (size) {
@@ -198,7 +209,12 @@ static void smssdio_interrupt(struct sdi
 		 * problem with the "increase address" bit)
 		 */
 		if (ret == -EINVAL) {
-			while (size) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (size) {
 				ret = sdio_memcpy_fromio(smsdev->func,
 						  buffer, SMSSDIO_DATA,
 						  smsdev->func->cur_blksize);
@@ -214,6 +230,12 @@ static void smssdio_interrupt(struct sdi
 					size -= smsdev->func->cur_blksize;
 				else
 					size = 0;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 		}
 	}
diff -u -p a/media/dvb/siano/smscoreapi.c b/media/dvb/siano/smscoreapi.c
--- a/media/dvb/siano/smscoreapi.c
+++ b/media/dvb/siano/smscoreapi.c
@@ -267,9 +267,20 @@ static void smscore_notify_clients(struc
 	struct smscore_client_t *client;
 
 	/* the client must call smscore_unregister_client from remove handler */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&coredev->clients)) {
 		client = (struct smscore_client_t *) coredev->clients.next;
 		client->onremove_handler(client->context);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -697,11 +708,22 @@ void smscore_unregister_device(struct sm
 	 * onresponse must no longer be called */
 
 	while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!list_empty(&coredev->buffers)) {
 			cb = (struct smscore_buffer_t *) coredev->buffers.next;
 			list_del(&cb->entry);
 			kfree(cb);
 			num_buffers++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (num_buffers == coredev->num_buffers)
 			break;
@@ -1233,11 +1255,22 @@ void smscore_unregister_client(struct sm
 	spin_lock_irqsave(&coredev->clientslock, flags);
 
 
-	while (!list_empty(&client->idlist)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&client->idlist)) {
 		struct smscore_idlist_t *identry =
 			(struct smscore_idlist_t *) client->idlist.next;
 		list_del(&identry->entry);
 		kfree(identry);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sms_info("%p", client->context);
@@ -1612,6 +1645,11 @@ static int __init smscore_module_init(vo
 static void __exit smscore_module_exit(void)
 {
 	kmutex_lock(&g_smscore_deviceslock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&g_smscore_notifyees)) {
 		struct smscore_device_notifyee_t *notifyee =
 			(struct smscore_device_notifyee_t *)
@@ -1619,10 +1657,21 @@ static void __exit smscore_module_exit(v
 
 		list_del(&notifyee->entry);
 		kfree(notifyee);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	kmutex_unlock(&g_smscore_deviceslock);
 
 	kmutex_lock(&g_smscore_registrylock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&g_smscore_registry)) {
 		struct smscore_registry_entry_t *entry =
 			(struct smscore_registry_entry_t *)
@@ -1630,6 +1679,12 @@ static void __exit smscore_module_exit(v
 
 		list_del(&entry->entry);
 		kfree(entry);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	kmutex_unlock(&g_smscore_registrylock);
 
diff -u -p a/media/dvb/ttpci/av7110_av.c b/media/dvb/ttpci/av7110_av.c
--- a/media/dvb/ttpci/av7110_av.c
+++ b/media/dvb/ttpci/av7110_av.c
@@ -602,6 +602,11 @@ static int find_pes_header(u8 const *buf
 
 	*frags = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (c < length - 3 && !found) {
 		if (buf[c] == 0x00 && buf[c + 1] == 0x00 &&
 		    buf[c + 2] == 0x01) {
@@ -626,6 +631,12 @@ static int find_pes_header(u8 const *buf
 			}
 		} else
 			c++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	if (c == length - 3 && !found) {
 		if (buf[length - 1] == 0x00)
@@ -714,6 +725,11 @@ void av7110_p2t_write(u8 const *buf, lon
 	}
 
 	add = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (c < length) {
 		c2 = find_pes_header(buf + c + add, length - c - add, &p->frags);
 		if (c2 >= 0) {
@@ -734,6 +750,12 @@ void av7110_p2t_write(u8 const *buf, lon
 			p->pos = rest;
 			c = length;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -802,6 +824,11 @@ static void p_to_t(u8 const *buf, long i
 				break;
 		}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (c < length) {
 		memset(obuf, 0, TS_SIZE);
 		if (length - c >= (TS_SIZE - 4)){
@@ -817,6 +844,12 @@ static void p_to_t(u8 const *buf, long i
 		}
 		feed->cb.ts(obuf, 188, NULL, 0, &feed->feed.ts, DMX_OK);
 		pes_start = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/dvb/ttpci/av7110_ipack.c b/media/dvb/ttpci/av7110_ipack.c
--- a/media/dvb/ttpci/av7110_ipack.c
+++ b/media/dvb/ttpci/av7110_ipack.c
@@ -370,6 +370,11 @@ int av7110_ipack_instant_repack (const u
 
 			}
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (c < count && p->found < p->plength + 6) {
 				l = count - c;
 				if (l + p->found > p->plength + 6)
@@ -377,6 +382,12 @@ int av7110_ipack_instant_repack (const u
 				write_ipack(p, buf + c, l);
 				p->found += l;
 				c += l;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			break;
 		}
diff -u -p a/media/dvb/ttusb-dec/ttusb_dec.c b/media/dvb/ttusb-dec/ttusb_dec.c
--- a/media/dvb/ttusb-dec/ttusb_dec.c
+++ b/media/dvb/ttusb-dec/ttusb_dec.c
@@ -608,7 +608,12 @@ static void ttusb_dec_process_urb_frame(
 {
 	swap_bytes(b, length);
 
-	while (length) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (length) {
 		switch (dec->packet_state) {
 
 		case 0:
@@ -729,6 +734,12 @@ static void ttusb_dec_process_urb_frame(
 			       __func__);
 			dec->packet_state = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -739,7 +750,12 @@ static void ttusb_dec_process_urb_frame_
 	struct urb_frame *frame;
 	unsigned long flags;
 
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		spin_lock_irqsave(&dec->urb_frame_list_lock, flags);
 		if ((item = dec->urb_frame_list.next) != &dec->urb_frame_list) {
 			frame = list_entry(item, struct urb_frame,
@@ -754,6 +770,12 @@ static void ttusb_dec_process_urb_frame_
 
 		ttusb_dec_process_urb_frame(dec, frame->data, frame->length);
 		kfree(frame);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -909,9 +931,20 @@ static int ttusb_dec_start_iso_xfer(stru
 				printk("%s: failed urb submission %d: "
 				       "error %d\n", __func__, i, result);
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (i) {
 					usb_kill_urb(dec->iso_urb[i - 1]);
 					i--;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 
 				mutex_unlock(&dec->iso_mutex);
@@ -1581,10 +1614,21 @@ static void ttusb_dec_exit_tasklet(struc
 
 	tasklet_kill(&dec->urb_tasklet);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((item = dec->urb_frame_list.next) != &dec->urb_frame_list) {
 		frame = list_entry(item, struct urb_frame, urb_frame_list);
 		list_del(&frame->urb_frame_list);
 		kfree(frame);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1599,10 +1643,21 @@ static void ttusb_dec_exit_filters(struc
 	struct list_head *item;
 	struct filter_info *finfo;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((item = dec->filter_info_list.next) != &dec->filter_info_list) {
 		finfo = list_entry(item, struct filter_info, filter_info_list);
 		list_del(&finfo->filter_info_list);
 		kfree(finfo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/dvb/dvb-usb/ec168.c b/media/dvb/dvb-usb/ec168.c
--- a/media/dvb/dvb-usb/ec168.c
+++ b/media/dvb/dvb-usb/ec168.c
@@ -136,6 +136,11 @@ static int ec168_i2c_xfer(struct i2c_ada
 	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
 		return -EAGAIN;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < num) {
 		if (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {
 			if (msg[i].addr == ec168_ec100_config.demod_address) {
@@ -173,6 +178,12 @@ static int ec168_i2c_xfer(struct i2c_ada
 		if (ret)
 			goto error;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	ret = i;
 
diff -u -p a/media/dvb/dvb-usb/af9015.c b/media/dvb/dvb-usb/af9015.c
--- a/media/dvb/dvb-usb/af9015.c
+++ b/media/dvb/dvb-usb/af9015.c
@@ -270,6 +270,11 @@ Due to that the only way to select corre
 	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
 		return -EAGAIN;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < num) {
 		if (msg[i].addr == af9015_af9013_config[0].demod_address ||
 		    msg[i].addr == af9015_af9013_config[1].demod_address) {
@@ -342,6 +347,12 @@ Due to that the only way to select corre
 		if (ret)
 			goto error;
 
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	ret = i;
 
diff -u -p a/media/dvb/dvb-usb/usb-urb.c b/media/dvb/dvb-usb/usb-urb.c
--- a/media/dvb/dvb-usb/usb-urb.c
+++ b/media/dvb/dvb-usb/usb-urb.c
@@ -93,12 +93,23 @@ int usb_urb_submit(struct usb_data_strea
 static int usb_free_stream_buffers(struct usb_data_stream *stream)
 {
 	if (stream->state & USB_STATE_URB_BUF) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (stream->buf_num) {
 			stream->buf_num--;
 			deb_mem("freeing buffer %d\n",stream->buf_num);
 			usb_free_coherent(stream->udev, stream->buf_size,
 					  stream->buf_list[stream->buf_num],
 					  stream->dma_addr[stream->buf_num]);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/media/dvb/dvb-usb/m920x.c b/media/dvb/dvb-usb/m920x.c
--- a/media/dvb/dvb-usb/m920x.c
+++ b/media/dvb/dvb-usb/m920x.c
@@ -71,7 +71,12 @@ static int m920x_init(struct dvb_usb_dev
 	/* Remote controller init. */
 	if (d->props.rc.legacy.rc_query) {
 		deb("Initialising remote control\n");
-		while (rc_seq->address) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (rc_seq->address) {
 			if ((ret = m920x_write(d->udev, M9206_CORE,
 					       rc_seq->data,
 					       rc_seq->address)) != 0) {
@@ -80,6 +85,12 @@ static int m920x_init(struct dvb_usb_dev
 			}
 
 			rc_seq++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		deb("Initialising remote control success\n");
diff -u -p a/media/dvb/ddbridge/ddbridge-core.c b/media/dvb/ddbridge/ddbridge-core.c
--- a/media/dvb/ddbridge/ddbridge-core.c
+++ b/media/dvb/ddbridge/ddbridge-core.c
@@ -516,6 +516,11 @@ static ssize_t ddb_input_read(struct ddb
 
 	idx = (stat >> 11) & 0x1f;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (left) {
 		if (input->cbuf == idx)
 			return count - left;
@@ -534,6 +539,12 @@ static ssize_t ddb_input_read(struct ddb
 		left -= free;
 		ddbwritel((input->cbuf << 11) | (input->coff >> 7),
 			  DMA_BUFFER_ACK(input->nr));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return count;
 }
@@ -1006,7 +1017,12 @@ static void input_tasklet(unsigned long
 	if (input->port->class == DDB_PORT_TUNER) {
 		if (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))
 			printk(KERN_ERR "Overflow input %d\n", input->nr);
-		while (input->cbuf != ((input->stat >> 11) & 0x1f)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (input->cbuf != ((input->stat >> 11) & 0x1f)
 		       || (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))) {
 			dvb_dmx_swfilter_packets(&input->demux,
 						 input->vbuf[input->cbuf],
@@ -1016,7 +1032,13 @@ static void input_tasklet(unsigned long
 			ddbwritel((input->cbuf << 11),
 				  DMA_BUFFER_ACK(input->nr));
 			input->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));
-		       }
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
+		}
 	}
 	if (input->port->class == DDB_PORT_CI)
 		wake_up(&input->wq);
@@ -1363,11 +1385,22 @@ static int flashio(struct ddb *dev, u8 *
 
 	data = 0;
 	shift = ((4 - wlen) * 8);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (wlen) {
 		data <<= 8;
 		data |= *wbuf;
 		wlen--;
 		wbuf++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (shift)
 		data <<= shift;
diff -u -p a/media/dvb/firewire/firedtv-avc.c b/media/dvb/firewire/firedtv-avc.c
--- a/media/dvb/firewire/firedtv-avc.c
+++ b/media/dvb/firewire/firedtv-avc.c
@@ -1163,6 +1163,11 @@ int avc_ca_pmt(struct firedtv *fdtv, cha
 		read_pos += program_info_length;
 		write_pos += program_info_length;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (read_pos < length) {
 		c->operand[write_pos++] = msg[read_pos++];
 		c->operand[write_pos++] = msg[read_pos++];
@@ -1185,6 +1190,12 @@ int avc_ca_pmt(struct firedtv *fdtv, cha
 			read_pos += es_info_length;
 			write_pos += es_info_length;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	write_pos += 4; /* CRC */
 
diff -u -p a/media/dvb/mantis/mantis_dma.c b/media/dvb/mantis/mantis_dma.c
--- a/media/dvb/mantis/mantis_dma.c
+++ b/media/dvb/mantis/mantis_dma.c
@@ -223,12 +223,23 @@ void mantis_dma_xfer(unsigned long data)
 	struct mantis_pci *mantis = (struct mantis_pci *) data;
 	struct mantis_hwconfig *config = mantis->hwconfig;
 
-	while (mantis->last_block != mantis->busy_block) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (mantis->last_block != mantis->busy_block) {
 		dprintk(MANTIS_DEBUG, 1, "last block=[%d] finished block=[%d]",
 			mantis->last_block, mantis->busy_block);
 
 		(config->ts_size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)
 		(&mantis->demux, &mantis->buf_cpu[mantis->last_block * MANTIS_BLOCK_BYTES], MANTIS_BLOCK_BYTES);
 		mantis->last_block = (mantis->last_block + 1) % MANTIS_BLOCK_COUNT;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
diff -u -p a/media/dvb/dvb-core/dvb_frontend.c b/media/dvb/dvb-core/dvb_frontend.c
--- a/media/dvb/dvb-core/dvb_frontend.c
+++ b/media/dvb/dvb-core/dvb_frontend.c
@@ -285,6 +285,11 @@ static int dvb_frontend_swzigzag_autotun
 			 (fepriv->parameters_in.inversion == INVERSION_AUTO));
 
 	/* setup parameters correctly */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(!ready) {
 		/* calculate the lnb_drift */
 		fepriv->lnb_drift = fepriv->auto_step * fepriv->step_size;
@@ -333,6 +338,12 @@ static int dvb_frontend_swzigzag_autotun
 		}
 
 		if (!ready) fepriv->auto_sub_step++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* if this attempt would hit where we started, indicate a complete
diff -u -p a/media/dvb/dvb-core/dvb_ca_en50221.c b/media/dvb/dvb-core/dvb_ca_en50221.c
--- a/media/dvb/dvb-core/dvb_ca_en50221.c
+++ b/media/dvb/dvb-core/dvb_ca_en50221.c
@@ -983,6 +983,11 @@ static int dvb_ca_en50221_thread(void *d
 	dvb_ca_en50221_thread_update_delay(ca);
 
 	/* main loop */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		/* sleep for a bit */
 		if (!ca->wakeup) {
@@ -999,6 +1004,11 @@ static int dvb_ca_en50221_thread(void *d
 			mutex_lock(&ca->slot_info[slot].slot_lock);
 
 			// check the cam status + deal with CAMCHANGEs
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (dvb_ca_en50221_check_camstatus(ca, slot)) {
 				/* clear down an old CI slot if necessary */
 				if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE)
@@ -1012,6 +1022,12 @@ static int dvb_ca_en50221_thread(void *d
 				/* we've handled one CAMCHANGE */
 				dvb_ca_en50221_thread_update_delay(ca);
 				atomic_dec(&ca->slot_info[slot].camchange_count);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 			}
 
 			// CAM state machine
@@ -1160,6 +1176,12 @@ static int dvb_ca_en50221_thread(void *d
 
 			mutex_unlock(&ca->slot_info[slot].slot_lock);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1304,6 +1326,11 @@ static ssize_t dvb_ca_en50221_io_write(s
 		return -EINVAL;
 
 	/* fragment the packets & store in the buffer */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fragpos < count) {
 		fraglen = ca->slot_info[slot].link_buf_size - 2;
 		if ((count - fragpos) < fraglen)
@@ -1344,6 +1371,12 @@ static ssize_t dvb_ca_en50221_io_write(s
 		}
 
 		fragpos += fraglen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	status = count + 2;
 
@@ -1367,6 +1400,11 @@ static int dvb_ca_en50221_io_read_condit
 	u8 hdr[2];
 
 	slot = ca->next_read_slot;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((slot_count < ca->slot_count) && (!found)) {
 		if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
 			goto nextslot;
@@ -1392,6 +1430,12 @@ static int dvb_ca_en50221_io_read_condit
 nextslot:
 		slot = (slot + 1) % ca->slot_count;
 		slot_count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ca->next_read_slot = slot;
diff -u -p a/media/dvb/dvb-core/dvb_filter.c b/media/dvb/dvb-core/dvb_filter.c
--- a/media/dvb/dvb-core/dvb_filter.c
+++ b/media/dvb/dvb-core/dvb_filter.c
@@ -350,6 +350,11 @@ int dvb_filter_get_ac3info(u8 *mbuf, int
 	u8 frame = 0;
 	int fr = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ( !found  && c < count){
 		u8 *b = mbuf+c;
 
@@ -358,6 +363,12 @@ int dvb_filter_get_ac3info(u8 *mbuf, int
 		else {
 			c++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!found) return -1;
diff -u -p a/media/radio/radio-wl1273.c b/media/radio/radio-wl1273.c
--- a/media/radio/radio-wl1273.c
+++ b/media/radio/radio-wl1273.c
@@ -1209,6 +1209,11 @@ static ssize_t wl1273_fm_fops_read(struc
 	}
 
 	/* block if no new data available */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (radio->wr_index == radio->rd_index) {
 		if (file->f_flags & O_NONBLOCK) {
 			r = -EWOULDBLOCK;
@@ -1222,6 +1227,12 @@ static ssize_t wl1273_fm_fops_read(struc
 			r = -EINTR;
 			goto out;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* calculate block count from byte count */
diff -u -p a/media/radio/si470x/radio-si470x-common.c b/media/radio/si470x/radio-si470x-common.c
--- a/media/radio/si470x/radio-si470x-common.c
+++ b/media/radio/si470x/radio-si470x-common.c
@@ -468,6 +468,11 @@ static ssize_t si470x_fops_read(struct f
 		si470x_rds_on(radio);
 
 	/* block if no new data available */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (radio->wr_index == radio->rd_index) {
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EWOULDBLOCK;
@@ -478,6 +483,12 @@ static ssize_t si470x_fops_read(struct f
 			retval = -EINTR;
 			goto done;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* calculate block count from byte count */
diff -u -p a/media/radio/wl128x/fmdrv_common.c b/media/radio/wl128x/fmdrv_common.c
--- a/media/radio/wl128x/fmdrv_common.c
+++ b/media/radio/wl128x/fmdrv_common.c
@@ -269,7 +269,12 @@ static void recv_tasklet(unsigned long a
 	fmdev = (struct fmdev *)arg;
 	irq_info = &fmdev->irq_info;
 	/* Process all packets in the RX queue */
-	while ((skb = skb_dequeue(&fmdev->rx_q))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((skb = skb_dequeue(&fmdev->rx_q))) {
 		if (skb->len < sizeof(struct fm_event_msg_hdr)) {
 			fmerr("skb(%p) has only %d bytes, "
 				"at least need %zu bytes to decode\n", skb,
@@ -337,6 +342,12 @@ static void recv_tasklet(unsigned long a
 		if (num_fm_hci_cmds && atomic_read(&fmdev->tx_cnt))
 			if (!skb_queue_empty(&fmdev->tx_q))
 				tasklet_schedule(&fmdev->tx_task);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 	}
 }
 
diff -u -p a/media/video/pwc/pwc-if.c b/media/video/pwc/pwc-if.c
--- a/media/video/pwc/pwc-if.c
+++ b/media/video/pwc/pwc-if.c
@@ -523,13 +523,24 @@ static void pwc_isoc_cleanup(struct pwc_
  */
 static void pwc_cleanup_queued_bufs(struct pwc_device *pdev)
 {
-	while (!list_empty(&pdev->queued_bufs)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&pdev->queued_bufs)) {
 		struct pwc_frame_buf *buf;
 
 		buf = list_entry(pdev->queued_bufs.next, struct pwc_frame_buf,
 				 list);
 		list_del(&buf->list);
 		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/media/video/pwc/pwc-dec23.c b/media/video/pwc/pwc-dec23.c
--- a/media/video/pwc/pwc-dec23.c
+++ b/media/video/pwc/pwc-dec23.c
@@ -594,11 +594,22 @@ static void copy_image_block_RedBlue(con
  *                 contains at least n bits. bits returned is discarded.
  */
 #define fill_nbits(pdec, nbits_wanted) do { \
-   while (pdec->nbits_in_reservoir<(nbits_wanted)) \
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (pdec->nbits_in_reservoir<(nbits_wanted)) \
     { \
       pdec->reservoir |= (*(pdec->stream)++) << (pdec->nbits_in_reservoir); \
       pdec->nbits_in_reservoir += 8; \
-    } \
+    if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	} \
 }  while(0);
 
 #define skip_nbits(pdec, nbits_to_skip) do { \
@@ -747,11 +758,22 @@ static void DecompressBand23(struct pwc_
 	ptable8004 = pdec->table_8004_pass1[compression_index];
 
 	/* Each block decode a square of 4x4 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_Y(pdec->temp_colors, planar_y, real_image_width, pdec->scalebits);
 		planar_y += 4;
 		nblocks--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* pass 2: uncompress UV component */
@@ -761,6 +783,11 @@ static void DecompressBand23(struct pwc_
 	ptable8004 = pdec->table_8004_pass2[compression_index];
 
 	/* Each block decode a square of 4x4 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_CrCb(pdec->temp_colors, planar_u, real_image_width/2, pdec->scalebits);
@@ -771,6 +798,12 @@ static void DecompressBand23(struct pwc_
 		planar_v += 8;
 		planar_u += 8;
 		nblocks -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 }
@@ -812,11 +845,22 @@ static void DecompressBandBayer(struct p
 	dest = rgbbayer;
 
 	/* Each block decode a square of 4x4 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_RedBlue(pdec->temp_colors, rgbbayer, real_image_width, pdec->scalebits);
 		dest += 8;
 		nblocks--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* pass 2: uncompress G component */
@@ -826,6 +870,11 @@ static void DecompressBandBayer(struct p
 	ptable8004 = pdec->table_8004_pass2[compression_index];
 
 	/* Each block decode a square of 4x4 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nblocks) {
 		decode_block(pdec, ptable0004, ptable8004);
 		copy_image_block_Green(pdec->temp_colors, rgbbayer+1, real_image_width, pdec->scalebits);
@@ -835,6 +884,12 @@ static void DecompressBandBayer(struct p
 
 		rgbbayer += 16;
 		nblocks -= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 #endif
diff -u -p a/media/video/uvc/uvc_queue.c b/media/video/uvc/uvc_queue.c
--- a/media/video/uvc/uvc_queue.c
+++ b/media/video/uvc/uvc_queue.c
@@ -586,12 +586,23 @@ void uvc_queue_cancel(struct uvc_video_q
 	unsigned long flags;
 
 	spin_lock_irqsave(&queue->irqlock, flags);
-	while (!list_empty(&queue->irqqueue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&queue->irqqueue)) {
 		buf = list_first_entry(&queue->irqqueue, struct uvc_buffer,
 				       queue);
 		list_del(&buf->queue);
 		buf->state = UVC_BUF_STATE_ERROR;
 		wake_up(&buf->wait);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* This must be protected by the irqlock spinlock to avoid race
 	 * conditions between uvc_queue_buffer and the disconnection event that
diff -u -p a/media/video/uvc/uvc_driver.c b/media/video/uvc/uvc_driver.c
--- a/media/video/uvc/uvc_driver.c
+++ b/media/video/uvc/uvc_driver.c
@@ -242,9 +242,20 @@ uint32_t uvc_fraction_to_interval(uint32
 	 * algorithm please let me know.
 	 */
 	multiplier = 10000000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (numerator > ((uint32_t)-1)/multiplier) {
 		multiplier /= 2;
 		denominator /= 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return denominator ? numerator * multiplier / denominator : 0;
diff -u -p a/media/video/cx18/cx18-queue.c b/media/video/cx18/cx18-queue.c
--- a/media/video/cx18/cx18-queue.c
+++ b/media/video/cx18/cx18-queue.c
@@ -218,6 +218,11 @@ static void cx18_queue_flush(struct cx18
 
 	spin_lock(&q_src->lock);
 	spin_lock(&q_dst->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&q_src->list)) {
 		mdl = list_first_entry(&q_src->list, struct cx18_mdl, list);
 		list_move_tail(&mdl->list, &q_dst->list);
@@ -227,6 +232,12 @@ static void cx18_queue_flush(struct cx18
 		mdl->skipped = 0;
 		mdl->curr_buf = NULL;
 		atomic_inc(&q_dst->depth);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	cx18_queue_init(q_src);
 	spin_unlock(&q_src->lock);
@@ -257,12 +268,23 @@ void cx18_unload_queues(struct cx18_stre
 	/* Reset MDL id's and move all buffers back to the stream's buf_pool */
 	spin_lock(&q_idle->lock);
 	list_for_each_entry(mdl, &q_idle->list, list) {
-		while (!list_empty(&mdl->buf_list)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!list_empty(&mdl->buf_list)) {
 			buf = list_first_entry(&mdl->buf_list,
 					       struct cx18_buffer, list);
 			list_move_tail(&buf->list, &s->buf_pool);
 			buf->bytesused = 0;
 			buf->readpos = 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		mdl->id = s->mdl_base_idx; /* reset id to a "safe" value */
 		/* all other mdl fields were cleared by cx18_queue_flush() */
@@ -431,7 +453,12 @@ void cx18_stream_free(struct cx18_stream
 		kfree(mdl);
 
 	/* empty buf_pool */
-	while (!list_empty(&s->buf_pool)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&s->buf_pool)) {
 		buf = list_first_entry(&s->buf_pool, struct cx18_buffer, list);
 		list_del_init(&buf->list);
 
@@ -439,5 +466,11 @@ void cx18_stream_free(struct cx18_stream
 				s->buf_size, s->dma);
 		kfree(buf->buf);
 		kfree(buf);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
diff -u -p a/media/video/cx88/cx88-core.c b/media/video/cx88/cx88-core.c
--- a/media/video/cx88/cx88-core.c
+++ b/media/video/cx88/cx88-core.c
@@ -86,9 +86,20 @@ static __le32* cx88_risc_field(__le32 *r
 	/* scan lines */
 	sg = sglist;
 	for (line = 0; line < lines; line++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (lpi && line>0 && !(line % lpi))
 			sol = RISC_SOL | RISC_IRQ1 | RISC_CNT_INC;
@@ -108,12 +119,23 @@ static __le32* cx88_risc_field(__le32 *r
 			todo -= (sg_dma_len(sg)-offset);
 			offset = 0;
 			sg++;
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++)=cpu_to_le32(RISC_WRITE|
 						    sg_dma_len(sg));
 				*(rp++)=cpu_to_le32(sg_dma_address(sg));
 				todo -= sg_dma_len(sg);
 				sg++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			*(rp++)=cpu_to_le32(RISC_WRITE|RISC_EOL|todo);
 			*(rp++)=cpu_to_le32(sg_dma_address(sg));
diff -u -p a/media/video/cx88/cx88-video.c b/media/video/cx88/cx88-video.c
--- a/media/video/cx88/cx88-video.c
+++ b/media/video/cx88/cx88-video.c
@@ -1626,6 +1626,11 @@ static void cx8800_vid_timeout(unsigned
 	cx_clear(VID_CAPTURE_CONTROL, 0x06);
 
 	spin_lock_irqsave(&dev->slock,flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -1633,6 +1638,12 @@ static void cx8800_vid_timeout(unsigned
 		wake_up(&buf->vb.done);
 		printk("%s/0: [%p/%d] timeout - dma=0x%08lx\n", core->name,
 		       buf, buf->vb.i, (unsigned long)buf->risc.dma);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	restart_video_queue(dev,q);
 	spin_unlock_irqrestore(&dev->slock,flags);
diff -u -p a/media/video/cx88/cx88-mpeg.c b/media/video/cx88/cx88-mpeg.c
--- a/media/video/cx88/cx88-mpeg.c
+++ b/media/video/cx88/cx88-mpeg.c
@@ -328,6 +328,11 @@ static void do_cancel_buffers(struct cx8
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->slock,flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -335,6 +340,12 @@ static void do_cancel_buffers(struct cx8
 		wake_up(&buf->vb.done);
 		dprintk(1,"[%p/%d] %s - dma=0x%08lx\n",
 			buf, buf->vb.i, reason, (unsigned long)buf->risc.dma);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (restart)
 	{
diff -u -p a/media/video/cx88/cx88-vbi.c b/media/video/cx88/cx88-vbi.c
--- a/media/video/cx88/cx88-vbi.c
+++ b/media/video/cx88/cx88-vbi.c
@@ -126,6 +126,11 @@ void cx8800_vbi_timeout(unsigned long da
 	cx_clear(VID_CAPTURE_CONTROL, 0x18);
 
 	spin_lock_irqsave(&dev->slock,flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -133,6 +138,12 @@ void cx8800_vbi_timeout(unsigned long da
 		wake_up(&buf->vb.done);
 		printk("%s/0: [%p/%d] timeout - dma=0x%08lx\n", dev->core->name,
 		       buf, buf->vb.i, (unsigned long)buf->risc.dma);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	cx8800_restart_vbi_queue(dev,q);
 	spin_unlock_irqrestore(&dev->slock,flags);
diff -u -p a/media/video/ivtv/ivtv-streams.c b/media/video/ivtv/ivtv-streams.c
--- a/media/video/ivtv/ivtv-streams.c
+++ b/media/video/ivtv/ivtv-streams.c
@@ -807,10 +807,21 @@ int ivtv_stop_v4l2_encode_stream(struct
 			set_current_state(TASK_INTERRUPTIBLE);
 
 			/* wait 2s for EOS interrupt */
-			while (!test_bit(IVTV_F_I_EOS, &itv->i_flags) &&
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!test_bit(IVTV_F_I_EOS, &itv->i_flags) &&
 				time_before(jiffies,
 					    then + msecs_to_jiffies(2000))) {
 				schedule_timeout(msecs_to_jiffies(10));
+				if (_cur < timeout) {
+		rdstcll(_cur);
+				}
+				else {
+		break;
+				}
 			}
 
 			/* To convert jiffies to ms, we must multiply by 1000
diff -u -p a/media/video/ivtv/ivtvfb.c b/media/video/ivtv/ivtvfb.c
--- a/media/video/ivtv/ivtvfb.c
+++ b/media/video/ivtv/ivtvfb.c
@@ -1137,8 +1137,19 @@ static int ivtvfb_init_io(struct ivtv *i
 		/* Find the largest power of two that maps the whole buffer */
 		int size_shift = 31;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(oi->video_buffer_size & (1 << size_shift))) {
 			size_shift--;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		size_shift++;
 		oi->fb_start_aligned_physaddr = oi->video_pbase & ~((1 << size_shift) - 1);
diff -u -p a/media/video/ivtv/ivtv-ioctl.c b/media/video/ivtv/ivtv-ioctl.c
--- a/media/video/ivtv/ivtv-ioctl.c
+++ b/media/video/ivtv/ivtv-ioctl.c
@@ -1720,6 +1720,11 @@ static int ivtv_decoder_ioctls(struct fi
 		memset(ev, 0, sizeof(*ev));
 		set_bit(IVTV_F_I_EV_VSYNC_ENABLED, &itv->i_flags);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (1) {
 			if (test_and_clear_bit(IVTV_F_I_EV_DEC_STOPPED, &itv->i_flags))
 				ev->type = VIDEO_EVENT_DECODER_STOPPED;
@@ -1752,6 +1757,12 @@ static int ivtv_decoder_ioctls(struct fi
 				IVTV_DEBUG_INFO("User stopped wait for event\n");
 				return -EINTR;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	}
diff -u -p a/media/video/ivtv/ivtv-mailbox.c b/media/video/ivtv/ivtv-mailbox.c
--- a/media/video/ivtv/ivtv-mailbox.c
+++ b/media/video/ivtv/ivtv-mailbox.c
@@ -301,6 +301,11 @@ static int ivtv_api_call(struct ivtv *it
 				break;
 		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(readl(&mbox->flags) & IVTV_MBOX_FIRMWARE_DONE)) {
 		if (time_after(jiffies, then + api_timeout)) {
 			IVTV_DEBUG_WARN("Could not get result (%s)\n", api_info[cmd].name);
@@ -313,6 +318,12 @@ static int ivtv_api_call(struct ivtv *it
 			mdelay(1);
 		else
 			ivtv_msleep_timeout(1, 0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	if (time_after(jiffies, then + msecs_to_jiffies(100)))
 		IVTV_DEBUG_WARN("%s took %u jiffies\n",
diff -u -p a/media/video/ivtv/ivtv-queue.c b/media/video/ivtv/ivtv-queue.c
--- a/media/video/ivtv/ivtv-queue.c
+++ b/media/video/ivtv/ivtv-queue.c
@@ -141,6 +141,11 @@ int ivtv_queue_move(struct ivtv_stream *
 		spin_unlock_irqrestore(&s->qlock, flags);
 		return -ENOMEM;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bytes_available < needed_bytes) {
 		struct ivtv_buffer *buf = list_entry(steal->list.prev, struct ivtv_buffer, list);
 		u16 dma_xfer_cnt = buf->dma_xfer_cnt;
@@ -163,19 +168,47 @@ int ivtv_queue_move(struct ivtv_stream *
 				break;
 			buf = list_entry(steal->list.prev, struct ivtv_buffer, list);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (from_free) {
 		u32 old_length = to->length;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (to->length - old_length < needed_bytes) {
 			ivtv_queue_move_buf(s, from, to, 1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	else {
 		u32 old_bytesused = to->bytesused;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (to->bytesused - old_bytesused < needed_bytes) {
 			ivtv_queue_move_buf(s, from, to, to_free);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	spin_unlock_irqrestore(&s->qlock, flags);
@@ -270,12 +303,23 @@ void ivtv_stream_free(struct ivtv_stream
 	ivtv_flush_queues(s);
 
 	/* empty q_free */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((buf = ivtv_dequeue(s, &s->q_free))) {
 		if (ivtv_might_use_dma(s))
 			pci_unmap_single(s->itv->pdev, buf->dma_handle,
 				s->buf_size + 256, s->dma);
 		kfree(buf->buf);
 		kfree(buf);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Free SG Array/Lists */
diff -u -p a/media/video/davinci/vpif_display.c b/media/video/davinci/vpif_display.c
--- a/media/video/davinci/vpif_display.c
+++ b/media/video/davinci/vpif_display.c
@@ -1706,6 +1706,11 @@ static __init int vpif_probe(struct plat
 	}
 
 	k = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, k))) {
 		for (i = res->start; i <= res->end; i++) {
 			if (request_irq(i, vpif_channel_isr, IRQF_DISABLED,
@@ -1716,6 +1721,12 @@ static __init int vpif_probe(struct plat
 			}
 		}
 		k++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
@@ -1897,11 +1908,22 @@ static void vpif_cleanup(void)
 
 	pdev = container_of(vpif_dev, struct platform_device, dev);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i))) {
 		for (irq_num = res->start; irq_num <= res->end; irq_num++)
 			free_irq(irq_num,
 				 (void *)(&vpif_obj.dev[i]->channel_id));
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	platform_driver_unregister(&vpif_driver);
diff -u -p a/media/video/davinci/vpif_capture.c b/media/video/davinci/vpif_capture.c
--- a/media/video/davinci/vpif_capture.c
+++ b/media/video/davinci/vpif_capture.c
@@ -2178,6 +2178,11 @@ static __init int vpif_probe(struct plat
 	}
 
 	k = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, k))) {
 		for (i = res->start; i <= res->end; i++) {
 			if (request_irq(i, vpif_channel_isr, IRQF_DISABLED,
@@ -2189,6 +2194,12 @@ static __init int vpif_probe(struct plat
 			}
 		}
 		k++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
@@ -2393,11 +2404,22 @@ static void vpif_cleanup(void)
 	int i = 0;
 
 	pdev = container_of(vpif_dev, struct platform_device, dev);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i))) {
 		for (irq_num = res->start; irq_num <= res->end; irq_num++)
 			free_irq(irq_num,
 				 (void *)(&vpif_obj.dev[i]->channel_id));
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	platform_driver_unregister(&vpif_driver);
diff -u -p a/media/video/msp3400-kthreads.c b/media/video/msp3400-kthreads.c
--- a/media/video/msp3400-kthreads.c
+++ b/media/video/msp3400-kthreads.c
@@ -679,12 +679,23 @@ no_second:
 		/* monitor tv audio mode, the first time don't wait
 		   so long to get a quick stereo/bilingual result */
 		count = 3;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (state->watch_stereo) {
 			if (msp_sleep(state, count ? 1000 : 5000))
 				goto restart;
 			if (count)
 				count--;
 			watch_stereo(client);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	v4l_dbg(1, msp_debug, client, "thread: exit\n");
@@ -842,12 +853,23 @@ restart:
 		/* monitor tv audio mode, the first time don't wait
 		   so long to get a quick stereo/bilingual result */
 		count = 3;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (state->watch_stereo) {
 			if (msp_sleep(state, count ? 1000 : 5000))
 				goto restart;
 			if (count)
 				count--;
 			watch_stereo(client);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	v4l_dbg(1, msp_debug, client, "thread: exit\n");
@@ -1078,10 +1100,21 @@ unmute:
 		/* monitor tv audio mode, the first time don't wait
 		   in order to get a quick stereo/SAP update */
 		watch_stereo(client);
-		while (state->watch_stereo) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while (state->watch_stereo) {
 			watch_stereo(client);
 			if (msp_sleep(state, 5000))
 				goto restart;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 	}
 	v4l_dbg(1, msp_debug, client, "thread: exit\n");
diff -u -p a/media/video/pvrusb2/pvrusb2-io.c b/media/video/pvrusb2/pvrusb2-io.c
--- a/media/video/pvrusb2/pvrusb2-io.c
+++ b/media/video/pvrusb2/pvrusb2-io.c
@@ -328,6 +328,11 @@ static int pvr2_stream_buffer_count(stru
 			sp->buffers = nb;
 			sp->buffer_slot_count = scnt;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sp->buffer_total_count < cnt) {
 			struct pvr2_buffer *bp;
 			bp = kmalloc(sizeof(*bp),GFP_KERNEL);
@@ -340,8 +345,19 @@ static int pvr2_stream_buffer_count(stru
 			sp->buffers[sp->buffer_total_count] = bp;
 			(sp->buffer_total_count)++;
 			pvr2_buffer_set_idle(bp);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sp->buffer_total_count > cnt) {
 			struct pvr2_buffer *bp;
 			bp = sp->buffers[sp->buffer_total_count - 1];
@@ -350,6 +366,12 @@ static int pvr2_stream_buffer_count(stru
 			(sp->buffer_total_count)--;
 			pvr2_buffer_done(bp);
 			kfree(bp);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (scnt < sp->buffer_slot_count) {
 			struct pvr2_buffer **nb = NULL;
@@ -399,6 +421,11 @@ static void pvr2_stream_internal_flush(s
 {
 	struct list_head *lp;
 	struct pvr2_buffer *bp1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((lp = sp->queued_list.next) != &sp->queued_list) {
 		bp1 = list_entry(lp,struct pvr2_buffer,list_overhead);
 		pvr2_buffer_wipe(bp1);
@@ -409,6 +436,12 @@ static void pvr2_stream_internal_flush(s
 		   here first. */
 		if (bp1->state != pvr2_buffer_state_queued) continue;
 		pvr2_buffer_set_idle(bp1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (sp->buffer_total_count != sp->buffer_target_count) {
 		pvr2_stream_achieve_buffer_count(sp);
diff -u -p a/media/video/pvrusb2/pvrusb2-dvb.c b/media/video/pvrusb2/pvrusb2-dvb.c
--- a/media/video/pvrusb2/pvrusb2-dvb.c
+++ b/media/video/pvrusb2/pvrusb2-dvb.c
@@ -94,9 +94,20 @@ static int pvr2_dvb_feed_thread(void *da
 {
 	int stat = pvr2_dvb_feed_func(data);
 	/* from videobuf-dvb.c: */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return stat;
 }
diff -u -p a/media/video/pvrusb2/pvrusb2-hdw.c b/media/video/pvrusb2/pvrusb2-hdw.c
--- a/media/video/pvrusb2/pvrusb2-hdw.c
+++ b/media/video/pvrusb2/pvrusb2-hdw.c
@@ -2002,9 +2002,20 @@ static unsigned int pvr2_copy_i2c_addr_l
 {
 	unsigned int cnt = 0;
 	if (!src) return 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (src[cnt] && (cnt + 1) < dst_max) {
 		dst[cnt] = src[cnt];
 		cnt++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dst[cnt] = I2C_CLIENT_END;
 	return cnt;
@@ -3866,8 +3877,19 @@ static int pvr2_send_request_ex(struct p
 
 	/* Now wait for all I/O to complete */
 	hdw->cmd_debug_state = 4;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hdw->ctl_write_pend_flag || hdw->ctl_read_pend_flag) {
 		wait_for_completion(&hdw->ctl_done);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	hdw->cmd_debug_state = 5;
 
@@ -5033,6 +5055,11 @@ static void pvr2_hdw_state_log_state(str
 	}
 	ccnt = pvr2_hdw_report_clients(hdw, buf, sizeof(buf));
 	ucnt = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ucnt < ccnt) {
 		lcnt = 0;
 		while ((lcnt + ucnt < ccnt) && (buf[lcnt + ucnt] != '\n')) {
@@ -5040,6 +5067,12 @@ static void pvr2_hdw_state_log_state(str
 		}
 		printk(KERN_INFO "%s %.*s\n", hdw->name, lcnt, buf + ucnt);
 		ucnt += lcnt + 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/pvrusb2/pvrusb2-debugifc.c b/media/video/pvrusb2/pvrusb2-debugifc.c
--- a/media/video/pvrusb2/pvrusb2-debugifc.c
+++ b/media/video/pvrusb2/pvrusb2-debugifc.c
@@ -308,6 +308,11 @@ int pvr2_debugifc_docmd(struct pvr2_hdw
 	unsigned int bcnt = 0;
 	int ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		for (bcnt = 0; bcnt < count; bcnt++) {
 			if (buf[bcnt] == '\n') break;
@@ -318,6 +323,12 @@ int pvr2_debugifc_docmd(struct pvr2_hdw
 		if (bcnt < count) bcnt++;
 		buf += bcnt;
 		count -= bcnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/media/video/pvrusb2/pvrusb2-std.c b/media/video/pvrusb2/pvrusb2-std.c
--- a/media/video/pvrusb2/pvrusb2-std.c
+++ b/media/video/pvrusb2/pvrusb2-std.c
@@ -142,6 +142,11 @@ int pvr2_std_str_to_id(v4l2_std_id *idPt
 	char ch;
 	const struct std_name *sp;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bufSize) {
 		if (!mMode) {
 			cnt = 0;
@@ -176,6 +181,12 @@ int pvr2_std_str_to_id(v4l2_std_id *idPt
 		if (cnt < bufSize) cnt++;
 		bufPtr += cnt;
 		bufSize -= cnt;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (idPtr) *idPtr = id;
diff -u -p a/media/video/pvrusb2/pvrusb2-i2c-core.c b/media/video/pvrusb2/pvrusb2-i2c-core.c
--- a/media/video/pvrusb2/pvrusb2-i2c-core.c
+++ b/media/video/pvrusb2/pvrusb2-i2c-core.c
@@ -418,6 +418,11 @@ static int pvr2_i2c_xfer(struct i2c_adap
 			   but to break apart the reads. */
 			tcnt = msgs[0].len;
 			offs = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (tcnt) {
 				bcnt = tcnt;
 				if (bcnt > sizeof(hdw->cmd_buffer)-1) {
@@ -430,6 +435,12 @@ static int pvr2_i2c_xfer(struct i2c_adap
 				}
 				offs += bcnt;
 				tcnt -= bcnt;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			ret = 1;
 			goto done;
@@ -459,6 +470,11 @@ static int pvr2_i2c_xfer(struct i2c_adap
 			tcnt = msgs[1].len;
 			wcnt = msgs[0].len;
 			offs = 0;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (tcnt || wcnt) {
 				bcnt = tcnt;
 				if (bcnt > sizeof(hdw->cmd_buffer)-1) {
@@ -473,6 +489,12 @@ static int pvr2_i2c_xfer(struct i2c_adap
 				offs += bcnt;
 				tcnt -= bcnt;
 				wcnt = 0;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			ret = 2;
 			goto done;
diff -u -p a/media/video/pvrusb2/pvrusb2-encoder.c b/media/video/pvrusb2/pvrusb2-encoder.c
--- a/media/video/pvrusb2/pvrusb2-encoder.c
+++ b/media/video/pvrusb2/pvrusb2-encoder.c
@@ -56,6 +56,11 @@ static int pvr2_encoder_write_words(stru
 	adjusted accordingly.
 
 	*/
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dlen) {
 		chunkCnt = 8;
 		if (chunkCnt > dlen) chunkCnt = dlen;
@@ -77,6 +82,12 @@ static int pvr2_encoder_write_words(stru
 		data += chunkCnt;
 		dlen -= chunkCnt;
 		offs += chunkCnt;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
@@ -101,6 +112,11 @@ static int pvr2_encoder_read_words(struc
 
 	*/
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dlen) {
 		chunkCnt = 16;
 		if (chunkCnt > dlen) chunkCnt = dlen;
@@ -127,6 +143,12 @@ static int pvr2_encoder_read_words(struc
 		data += chunkCnt;
 		dlen -= chunkCnt;
 		offs += chunkCnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/media/video/cx231xx/cx231xx-417.c b/media/video/cx231xx/cx231xx-417.c
--- a/media/video/cx231xx/cx231xx-417.c
+++ b/media/video/cx231xx/cx231xx-417.c
@@ -327,6 +327,11 @@ static int waitForMciComplete(struct cx2
 	u8 count = 0;
 	getITVCReg(dev, gpio_driection, &gpio);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(gpio&0x020000)) {
 		msleep(10);
 
@@ -336,6 +341,12 @@ static int waitForMciComplete(struct cx2
 			dprintk(3, "ERROR: Timeout - gpio=%x\n", gpio);
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/media/video/cx231xx/cx231xx-vbi.c b/media/video/cx231xx/cx231xx-vbi.c
--- a/media/video/cx231xx/cx231xx-vbi.c
+++ b/media/video/cx231xx/cx231xx-vbi.c
@@ -137,7 +137,12 @@ static inline int cx231xx_isoc_vbi_copy(
 		/* Now parse data that is completely in this buffer */
 		dma_q->is_partial_line = 0;
 
-		while (bytes_parsed < buffer_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bytes_parsed < buffer_size) {
 			u32 bytes_used = 0;
 
 			sav_eav = cx231xx_find_next_SAV_EAV(
@@ -154,6 +159,12 @@ static inline int cx231xx_isoc_vbi_copy(
 					p_buffer+bytes_parsed, /* p_buffer */
 					buffer_size-bytes_parsed);/*buf size*/
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Save the last four bytes of the buffer so we can
diff -u -p a/media/video/cx231xx/cx231xx-video.c b/media/video/cx231xx/cx231xx-video.c
--- a/media/video/cx231xx/cx231xx-video.c
+++ b/media/video/cx231xx/cx231xx-video.c
@@ -399,7 +399,12 @@ static inline int cx231xx_isoc_copy(stru
 		/* Now parse data that is completely in this buffer */
 		/* dma_q->is_partial_line = 0;  */
 
-		while (bytes_parsed < buffer_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bytes_parsed < buffer_size) {
 			u32 bytes_used = 0;
 
 			sav_eav = cx231xx_find_next_SAV_EAV(
@@ -416,6 +421,12 @@ static inline int cx231xx_isoc_copy(stru
 					p_buffer + bytes_parsed,/* p_buffer */
 					buffer_size - bytes_parsed);/*buf size*/
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Save the last four bytes of the buffer so we can check the
@@ -485,7 +496,12 @@ static inline int cx231xx_bulk_copy(stru
 		/* Now parse data that is completely in this buffer */
 		/* dma_q->is_partial_line = 0;  */
 
-		while (bytes_parsed < buffer_size) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (bytes_parsed < buffer_size) {
 			u32 bytes_used = 0;
 
 			sav_eav = cx231xx_find_next_SAV_EAV(
@@ -502,6 +518,12 @@ static inline int cx231xx_bulk_copy(stru
 					p_buffer + bytes_parsed,/* p_buffer */
 					buffer_size - bytes_parsed);/*buf size*/
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Save the last four bytes of the buffer so we can check the
diff -u -p a/media/video/cx23885/cx23885-video.c b/media/video/cx23885/cx23885-video.c
--- a/media/video/cx23885/cx23885-video.c
+++ b/media/video/cx23885/cx23885-video.c
@@ -1514,7 +1514,12 @@ static void cx23885_vid_timeout(unsigned
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->slock, flags);
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next,
 			struct cx23885_buffer, vb.queue);
 		list_del(&buf->vb.queue);
@@ -1523,6 +1528,12 @@ static void cx23885_vid_timeout(unsigned
 		printk(KERN_ERR "%s: [%p/%d] timeout - dma=0x%08lx\n",
 			dev->name, buf, buf->vb.i,
 			(unsigned long)buf->risc.dma);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	cx23885_restart_video_queue(dev, q);
 	spin_unlock_irqrestore(&dev->slock, flags);
diff -u -p a/media/video/cx23885/cx23885-vbi.c b/media/video/cx23885/cx23885-vbi.c
--- a/media/video/cx23885/cx23885-vbi.c
+++ b/media/video/cx23885/cx23885-vbi.c
@@ -166,7 +166,12 @@ void cx23885_vbi_timeout(unsigned long d
 	cx_clear(VID_A_DMA_CTL, 0x22);
 
 	spin_lock_irqsave(&dev->slock, flags);
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx23885_buffer,
 			vb.queue);
 		list_del(&buf->vb.queue);
@@ -174,6 +179,12 @@ void cx23885_vbi_timeout(unsigned long d
 		wake_up(&buf->vb.done);
 		printk("%s/0: [%p/%d] timeout - dma=0x%08lx\n", dev->name,
 		       buf, buf->vb.i, (unsigned long)buf->risc.dma);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	cx23885_restart_vbi_queue(dev, q);
 	spin_unlock_irqrestore(&dev->slock, flags);
diff -u -p a/media/video/cx23885/cx23885-input.c b/media/video/cx23885/cx23885-input.c
--- a/media/video/cx23885/cx23885-input.c
+++ b/media/video/cx23885/cx23885-input.c
@@ -224,12 +224,23 @@ static void cx23885_input_ir_stop(struct
 	 */
 	atomic_set(&dev->ir_input_stopping, 1);
 	v4l2_subdev_call(dev->sd_ir, ir, rx_g_parameters, &params);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (params.shutdown == false) {
 		params.enable = false;
 		params.interrupt_enable = false;
 		params.shutdown = true;
 		v4l2_subdev_call(dev->sd_ir, ir, rx_s_parameters, &params);
 		v4l2_subdev_call(dev->sd_ir, ir, rx_g_parameters, &params);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	flush_work_sync(&dev->cx25840_work);
 	flush_work_sync(&dev->ir_rx_work);
diff -u -p a/media/video/cx23885/cx23885-core.c b/media/video/cx23885/cx23885-core.c
--- a/media/video/cx23885/cx23885-core.c
+++ b/media/video/cx23885/cx23885-core.c
@@ -1094,9 +1094,20 @@ static __le32 *cx23885_risc_field(__le32
 	/* scan lines */
 	sg = sglist;
 	for (line = 0; line < lines; line++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (lpi && line > 0 && !(line % lpi))
@@ -1120,13 +1131,24 @@ static __le32 *cx23885_risc_field(__le32
 			todo -= (sg_dma_len(sg)-offset);
 			offset = 0;
 			sg++;
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++) = cpu_to_le32(RISC_WRITE|
 						    sg_dma_len(sg));
 				*(rp++) = cpu_to_le32(sg_dma_address(sg));
 				*(rp++) = cpu_to_le32(0); /* bits 63-32 */
 				todo -= sg_dma_len(sg);
 				sg++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			*(rp++) = cpu_to_le32(RISC_WRITE|RISC_EOL|todo);
 			*(rp++) = cpu_to_le32(sg_dma_address(sg));
@@ -1627,7 +1649,12 @@ static void do_cancel_buffers(struct cx2
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->slock, flags);
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf = list_entry(q->active.next, struct cx23885_buffer,
 				 vb.queue);
 		list_del(&buf->vb.queue);
@@ -1635,6 +1662,12 @@ static void do_cancel_buffers(struct cx2
 		wake_up(&buf->vb.done);
 		dprintk(1, "[%p/%d] %s - dma=0x%08lx\n",
 			buf, buf->vb.i, reason, (unsigned long)buf->risc.dma);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (restart) {
 		dprintk(1, "restarting queue\n");
diff -u -p a/media/video/cx25821/cx25821-core.c b/media/video/cx25821/cx25821-core.c
--- a/media/video/cx25821/cx25821-core.c
+++ b/media/video/cx25821/cx25821-core.c
@@ -1094,9 +1094,20 @@ static __le32 *cx25821_risc_field(__le32
 	/* scan lines */
 	sg = sglist;
 	for (line = 0; line < lines; line++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (bpl <= sg_dma_len(sg) - offset) {
 			/* fits into current chunk */
@@ -1116,13 +1127,24 @@ static __le32 *cx25821_risc_field(__le32
 			todo -= (sg_dma_len(sg) - offset);
 			offset = 0;
 			sg++;
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++) =
 				    cpu_to_le32(RISC_WRITE | sg_dma_len(sg));
 				*(rp++) = cpu_to_le32(sg_dma_address(sg));
 				*(rp++) = cpu_to_le32(0);	/* bits 63-32 */
 				todo -= sg_dma_len(sg);
 				sg++;
+				if (_cur < timeout) {
+				    rdstcll(_cur);
+				}
+				else {
+				    break;
+				}
 			}
 			*(rp++) = cpu_to_le32(RISC_WRITE | RISC_EOL | todo);
 			*(rp++) = cpu_to_le32(sg_dma_address(sg));
@@ -1200,9 +1222,20 @@ static __le32 *cx25821_risc_field_audio(
 	/* scan lines */
 	sg = sglist;
 	for (line = 0; line < lines; line++) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (lpi && line > 0 && !(line % lpi))
@@ -1227,13 +1260,24 @@ static __le32 *cx25821_risc_field_audio(
 			todo -= (sg_dma_len(sg) - offset);
 			offset = 0;
 			sg++;
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++) = cpu_to_le32(RISC_WRITE |
 						      sg_dma_len(sg));
 				*(rp++) = cpu_to_le32(sg_dma_address(sg));
 				*(rp++) = cpu_to_le32(0);	/* bits 63-32 */
 				todo -= sg_dma_len(sg);
 				sg++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			*(rp++) = cpu_to_le32(RISC_WRITE | RISC_EOL | todo);
 			*(rp++) = cpu_to_le32(sg_dma_address(sg));
diff -u -p a/media/video/cx25821/cx25821-audio-upstream.c b/media/video/cx25821/cx25821-audio-upstream.c
--- a/media/video/cx25821/cx25821-audio-upstream.c
+++ b/media/video/cx25821/cx25821-audio-upstream.c
@@ -515,7 +515,12 @@ int cx25821_audio_upstream_irq(struct cx
 
 		spin_lock(&dev->slock);
 
-		while (prog_cnt != dev->_last_index_irq) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (prog_cnt != dev->_last_index_irq) {
 			/* Update _last_index_irq */
 			if (dev->_last_index_irq < (NUMBER_OF_PROGRAMS - 1))
 				dev->_last_index_irq++;
@@ -526,6 +531,12 @@ int cx25821_audio_upstream_irq(struct cx
 
 			queue_work(dev->_irq_audio_queues,
 				   &dev->_audio_work_entry);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (dev->_is_first_audio_frame) {
diff -u -p a/media/video/cx25821/cx25821-video.c b/media/video/cx25821/cx25821-video.c
--- a/media/video/cx25821/cx25821-video.c
+++ b/media/video/cx25821/cx25821-video.c
@@ -374,13 +374,24 @@ void cx25821_vid_timeout(unsigned long d
 	cx_clear(channel->dma_ctl, 0x11);
 
 	spin_lock_irqsave(&dev->slock, flags);
-	while (!list_empty(&q->active)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&q->active)) {
 		buf =
 		    list_entry(q->active.next, struct cx25821_buffer, vb.queue);
 		list_del(&buf->vb.queue);
 
 		buf->vb.state = VIDEOBUF_ERROR;
 		wake_up(&buf->vb.done);
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 
 	cx25821_restart_video_queue(dev, q, channel);
diff -u -p a/media/video/bt8xx/bttv-cards.c b/media/video/bt8xx/bttv-cards.c
--- a/media/video/bt8xx/bttv-cards.c
+++ b/media/video/bt8xx/bttv-cards.c
@@ -4854,13 +4854,24 @@ void __init bttv_check_chipset(void)
 	}
 	if (UNSET != latency)
 		pr_info("pci latency fixup [%d]\n", latency);
-	while ((dev = pci_get_device(PCI_VENDOR_ID_INTEL,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((dev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_82441, dev))) {
 		unsigned char b;
 		pci_read_config_byte(dev, 0x53, &b);
 		if (bttv_debug)
 			pr_info("Host bridge: 82441FX Natoma, bufcon=0x%02x\n",
 				b);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/media/video/bt8xx/bttv-driver.c b/media/video/bt8xx/bttv-driver.c
--- a/media/video/bt8xx/bttv-driver.c
+++ b/media/video/bt8xx/bttv-driver.c
@@ -3903,17 +3903,39 @@ static void bttv_irq_timeout(unsigned lo
 	bttv_irq_wakeup_vbi(btv, ovbi, VIDEOBUF_ERROR);
 
 	/* cancel all outstanding capture / vbi requests */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&btv->capture)) {
 		item = list_entry(btv->capture.next, struct bttv_buffer, vb.queue);
 		list_del(&item->vb.queue);
 		item->vb.state = VIDEOBUF_ERROR;
 		wake_up(&item->vb.done);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&btv->vcapture)) {
 		item = list_entry(btv->vcapture.next, struct bttv_buffer, vb.queue);
 		list_del(&item->vb.queue);
 		item->vb.state = VIDEOBUF_ERROR;
 		wake_up(&item->vb.done);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	btv->errors++;
diff -u -p a/media/video/bt8xx/bttv-risc.c b/media/video/bt8xx/bttv-risc.c
--- a/media/video/bt8xx/bttv-risc.c
+++ b/media/video/bt8xx/bttv-risc.c
@@ -82,9 +82,20 @@ bttv_risc_packed(struct bttv *btv, struc
 		if ((btv->opt_vcr_hack) &&
 		    (line >= (store_lines - VCR_HACK_LINES)))
 			continue;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (offset && offset >= sg_dma_len(sg)) {
 			offset -= sg_dma_len(sg);
 			sg++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (bpl <= sg_dma_len(sg)-offset) {
 			/* fits into current chunk */
@@ -101,12 +112,23 @@ bttv_risc_packed(struct bttv *btv, struc
 			todo -= (sg_dma_len(sg)-offset);
 			offset = 0;
 			sg++;
-			while (todo > sg_dma_len(sg)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (todo > sg_dma_len(sg)) {
 				*(rp++)=cpu_to_le32(BT848_RISC_WRITE|
 						    sg_dma_len(sg));
 				*(rp++)=cpu_to_le32(sg_dma_address(sg));
 				todo -= sg_dma_len(sg);
 				sg++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			*(rp++)=cpu_to_le32(BT848_RISC_WRITE|BT848_RISC_EOL|
 					    todo);
@@ -185,17 +207,50 @@ bttv_risc_planar(struct bttv *btv, struc
 
 		for (todo = ybpl; todo > 0; todo -= ylen) {
 			/* go to next sg entry if needed */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (yoffset && yoffset >= sg_dma_len(ysg)) {
 				yoffset -= sg_dma_len(ysg);
 				ysg++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (uoffset && uoffset >= sg_dma_len(usg)) {
 				uoffset -= sg_dma_len(usg);
 				usg++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (voffset && voffset >= sg_dma_len(vsg)) {
 				voffset -= sg_dma_len(vsg);
 				vsg++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			/* calculate max number of bytes we can write */
diff -u -p a/media/video/cpia2/cpia2_v4l.c b/media/video/cpia2/cpia2_v4l.c
--- a/media/video/cpia2/cpia2_v4l.c
+++ b/media/video/cpia2/cpia2_v4l.c
@@ -367,6 +367,11 @@ static int sync(struct camera_data *cam,
 {
 	struct framebuf *frame = &cam->buffers[frame_nr];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (frame->status == FRAME_READY)
 			return 0;
@@ -386,6 +391,12 @@ static int sync(struct camera_data *cam,
 			return -ERESTARTSYS;
 		if(!cam->present)
 			return -ENOTTY;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/media/video/gspca/conex.c b/media/video/gspca/conex.c
--- a/media/video/gspca/conex.c
+++ b/media/video/gspca/conex.c
@@ -265,9 +265,20 @@ static void cx11646_fw(struct gspca_dev*
 	int i = 0;
 
 	reg_w_val(gspca_dev, 0x006a, 0x02);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cx11646_fw1[i][1]) {
 		reg_w(gspca_dev, 0x006b, cx11646_fw1[i], 3);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	reg_w_val(gspca_dev, 0x006a, 0x00);
 }
@@ -801,6 +812,11 @@ static void cx11646_init1(struct gspca_d
 /*	reg_w_val(gspca_dev, 0x003d, 0x60); */
 	reg_r(gspca_dev, 0x0099, 1);			/* ->0x07 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cx_sensor_init[i][0]) {
 		reg_w_val(gspca_dev, 0x00e5, cx_sensor_init[i][0]);
 		reg_r(gspca_dev, 0x00e8, 1);		/* -> 0x00 */
@@ -809,6 +825,12 @@ static void cx11646_init1(struct gspca_d
 			reg_r(gspca_dev, 0x00ed, 1);	/* -> 0x01 */
 		}
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	reg_w_val(gspca_dev, 0x00c3, 0x00);
 }
diff -u -p a/media/video/gspca/zc3xx.c b/media/video/gspca/zc3xx.c
--- a/media/video/gspca/zc3xx.c
+++ b/media/video/gspca/zc3xx.c
@@ -5759,7 +5759,12 @@ static u8 i2c_write(struct gspca_dev *gs
 static void usb_exchange(struct gspca_dev *gspca_dev,
 			const struct usb_action *action)
 {
-	while (action->req) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (action->req) {
 		switch (action->req) {
 		case 0xa0:	/* write register */
 			reg_w(gspca_dev, action->val, action->idx);
@@ -5786,6 +5791,12 @@ static void usb_exchange(struct gspca_de
 		}
 		action++;
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/gspca/sq905.c b/media/video/gspca/sq905.c
--- a/media/video/gspca/sq905.c
+++ b/media/video/gspca/sq905.c
@@ -232,6 +232,11 @@ static void sq905_dostream(struct work_s
 	frame_sz = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].sizeimage
 			+ FRAME_HEADER_LEN;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (gspca_dev->present && gspca_dev->streaming) {
 		/* request some data and then read it until we have
 		 * a complete frame. */
@@ -282,7 +287,13 @@ static void sq905_dostream(struct work_s
 			if (ret < 0)
 				goto quit_stream;
 		}
-	}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+}
 quit_stream:
 	if (gspca_dev->present) {
 		mutex_lock(&gspca_dev->usb_lock);
diff -u -p a/media/video/gspca/spca561.c b/media/video/gspca/spca561.c
--- a/media/video/gspca/spca561.c
+++ b/media/video/gspca/spca561.c
@@ -396,20 +396,42 @@ static int i2c_read(struct gspca_dev *gs
 static void sensor_mapwrite(struct gspca_dev *gspca_dev,
 			    const __u16 (*sensormap)[2])
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((*sensormap)[0]) {
 		gspca_dev->usb_buf[0] = (*sensormap)[1];
 		gspca_dev->usb_buf[1] = (*sensormap)[1] >> 8;
 		reg_w_buf(gspca_dev, (*sensormap)[0], 2);
 		sensormap++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
 static void write_sensor_72a(struct gspca_dev *gspca_dev,
 			    const __u16 (*sensor)[2])
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((*sensor)[0]) {
 		i2c_write(gspca_dev, (*sensor)[1], (*sensor)[0]);
 		sensor++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/gspca/stv06xx/stv06xx.c b/media/video/gspca/stv06xx/stv06xx.c
--- a/media/video/gspca/stv06xx/stv06xx.c
+++ b/media/video/gspca/stv06xx/stv06xx.c
@@ -376,6 +376,11 @@ static void stv06xx_pkt_scan(struct gspc
 
 	/* A packet may contain several frames
 	   loop until the whole packet is reached */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		int id, chunk_len;
 
@@ -478,6 +483,12 @@ frame_data:
 		}
 		data    += chunk_len;
 		len     -= chunk_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/gspca/sq905c.c b/media/video/gspca/sq905c.c
--- a/media/video/gspca/sq905c.c
+++ b/media/video/gspca/sq905c.c
@@ -150,7 +150,12 @@ static void sq905c_dostream(struct work_
 		goto quit_stream;
 	}
 
-	while (gspca_dev->present && gspca_dev->streaming) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (gspca_dev->present && gspca_dev->streaming) {
 		/* Request the header, which tells the size to download */
 		ret = usb_bulk_msg(gspca_dev->dev,
 				usb_rcvbulkpipe(gspca_dev->dev, 0x81),
@@ -189,7 +194,13 @@ static void sq905c_dostream(struct work_
 			gspca_frame_add(gspca_dev, packet_type,
 					buffer, data_len);
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 quit_stream:
 	if (gspca_dev->present) {
 		mutex_lock(&gspca_dev->usb_lock);
diff -u -p a/media/video/zoran/videocodec.c b/media/video/zoran/videocodec.c
--- a/media/video/zoran/videocodec.c
+++ b/media/video/zoran/videocodec.c
@@ -97,6 +97,11 @@ videocodec_attach (struct videocodec_mas
 		return NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (h) {
 		// attach only if the slave has at least the flags
 		// expected by the master
@@ -153,6 +158,12 @@ videocodec_attach (struct videocodec_mas
 			}
 		}
 		h = h->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dprintk(1, KERN_ERR "videocodec_attach: no codec found!\n");
@@ -187,9 +198,19 @@ videocodec_detach (struct videocodec *co
 		return -ENXIO;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (h) {
 		a = h->list;
 		prev = NULL;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (a) {
 			if (codec == a->codec) {
 				res = a->codec->unset(a->codec);
@@ -222,8 +243,20 @@ videocodec_detach (struct videocodec *co
 			}
 			prev = a;
 			a = a->next;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		h = h->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dprintk(1, KERN_ERR "videocodec_detach: given codec not found!\n");
@@ -286,7 +319,12 @@ videocodec_unregister (const struct vide
 		return -ENXIO;
 	}
 
-	while (h) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (h) {
 		if (codec == h->codec) {
 			if (h->attached) {
 				dprintk(1,
@@ -311,6 +349,12 @@ videocodec_unregister (const struct vide
 		}
 		prev = h;
 		h = h->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dprintk(1,
@@ -329,12 +373,22 @@ static int proc_videocodecs_show(struct
 	seq_printf(m, "(connected as)\n");
 
 	h = codeclist_top;
-	while (h) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (h) {
 		seq_printf(m, "S %32s %04x %08lx %08lx (TEMPLATE)\n",
 			      h->codec->name, h->codec->type,
 			      h->codec->flags, h->codec->magic);
 		a = h->list;
-		while (a) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (a) {
 			seq_printf(m, "M %32s %04x %08lx %08lx (%s)\n",
 				      a->codec->master_data->name,
 				      a->codec->master_data->type,
@@ -342,8 +396,20 @@ static int proc_videocodecs_show(struct
 				      a->codec->master_data->magic,
 				      a->codec->name);
 			a = a->next;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		h = h->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/media/video/zoran/zoran_driver.c b/media/video/zoran/zoran_driver.c
--- a/media/video/zoran/zoran_driver.c
+++ b/media/video/zoran/zoran_driver.c
@@ -172,9 +172,20 @@ zoran_v4l2_calc_bufsize (struct zoran_jp
 	__u32 result = 2;
 
 	num--;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num) {
 		num >>= 1;
 		result <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (result > jpg_bufsize)
diff -u -p a/media/video/zoran/zoran_device.c b/media/video/zoran/zoran_device.c
--- a/media/video/zoran/zoran_device.c
+++ b/media/video/zoran/zoran_device.c
@@ -113,8 +113,19 @@ post_office_wait (struct zoran *zr)
 	u32 por;
 
 //      while (((por = btread(ZR36057_POR)) & (ZR36057_POR_POPen | ZR36057_POR_POTime)) == ZR36057_POR_POPen) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((por = btread(ZR36057_POR)) & ZR36057_POR_POPen) {
 		/* wait for something to happen */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if ((por & ZR36057_POR_POTime) && !zr->card.gws_not_connected) {
 		/* In LML33/BUZ \GWS line is not connected, so it has always timeout set */
@@ -1156,6 +1167,11 @@ zoran_reap_stat_com (struct zoran *zr)
 	if (zr->codec_mode == BUZ_MODE_MOTION_DECOMPRESS) {
 		zr->jpg_seq_num++;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (zr->jpg_dma_tail < zr->jpg_dma_head) {
 		if (zr->jpg_settings.TmpDcm == 1)
 			i = (zr->jpg_dma_tail -
@@ -1190,6 +1206,12 @@ zoran_reap_stat_com (struct zoran *zr)
 		buffer->state = BUZ_STATE_DONE;
 
 		zr->jpg_dma_tail++;
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 }
 
@@ -1355,7 +1377,12 @@ zoran_irq (int             irq,
 	if (zr->testing) {
 		/* Testing interrupts */
 		spin_lock_irqsave(&zr->spinlock, flags);
-		while ((stat = count_reset_interrupt(zr))) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((stat = count_reset_interrupt(zr))) {
 			if (count++ > 100) {
 				btand(~ZR36057_ICR_IntPinEn, ZR36057_ICR);
 				dprintk(1,
@@ -1364,6 +1391,12 @@ zoran_irq (int             irq,
 					ZR_DEVNAME(zr), stat);
 				wake_up_interruptible(&zr->test_q);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		zr->last_isr = stat;
 		spin_unlock_irqrestore(&zr->spinlock, flags);
diff -u -p a/media/video/zoran/zoran_procfs.c b/media/video/zoran/zoran_procfs.c
--- a/media/video/zoran/zoran_procfs.c
+++ b/media/video/zoran/zoran_procfs.c
@@ -162,6 +162,11 @@ static ssize_t zoran_write(struct file *
 	ldelim = " \t\n";
 	tdelim = "=";
 	line = strpbrk(sp, ldelim);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (line) {
 		*line = 0;
 		svar = strpbrk(sp, tdelim);
@@ -173,6 +178,12 @@ static ssize_t zoran_write(struct file *
 		}
 		sp = line + 1;
 		line = strpbrk(sp, ldelim);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	vfree(string);
 
diff -u -p a/media/video/zoran/zr36050.c b/media/video/zoran/zr36050.c
--- a/media/video/zoran/zr36050.c
+++ b/media/video/zoran/zr36050.c
@@ -221,8 +221,19 @@ zr36050_pushit (struct zr36050 *ptr,
 
 	dprintk(4, "%s: write data block to 0x%04x (len=%d)\n", ptr->name,
 		startreg, len);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len) {
 		zr36050_write(ptr, startreg++, data[i++]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return i;
diff -u -p a/media/video/zoran/zr36060.c b/media/video/zoran/zr36060.c
--- a/media/video/zoran/zr36060.c
+++ b/media/video/zoran/zr36060.c
@@ -212,8 +212,19 @@ zr36060_pushit (struct zr36060 *ptr,
 
 	dprintk(4, "%s: write data block to 0x%04x (len=%d)\n", ptr->name,
 		startreg, len);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < len) {
 		zr36060_write(ptr, startreg++, data[i++]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return i;
diff -u -p a/media/video/saa7164/saa7164-bus.c b/media/video/saa7164/saa7164-bus.c
--- a/media/video/saa7164/saa7164-bus.c
+++ b/media/video/saa7164/saa7164-bus.c
@@ -190,6 +190,11 @@ int saa7164_bus_set(struct saa7164_dev *
 	dprintk(DBGLVL_BUS, "%s() curr_swp = %x\n", __func__, curr_swp);
 
 	/* Process the msg and write the content onto the bus */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bytes_to_write >= free_write_space) {
 
 		if (timeout-- == 0) {
@@ -214,6 +219,12 @@ int saa7164_bus_set(struct saa7164_dev *
 			free_write_space = (curr_srp + bus->m_dwSizeSetRing) -
 				curr_swp;
 
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 	}
 
 	/* Calculate the new write position */
diff -u -p a/media/video/saa7164/saa7164-fw.c b/media/video/saa7164/saa7164-fw.c
--- a/media/video/saa7164/saa7164-fw.c
+++ b/media/video/saa7164/saa7164-fw.c
@@ -56,7 +56,12 @@ int saa7164_dl_wait_ack(struct saa7164_d
 int saa7164_dl_wait_clr(struct saa7164_dev *dev, u32 reg)
 {
 	u32 timeout = SAA_DEVICE_TIMEOUT;
-	while (saa7164_readl(reg) & 0x01) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (saa7164_readl(reg) & 0x01) {
 		timeout -= 10;
 		if (timeout == 0) {
 			printk(KERN_ERR "%s() timeout (no d/l clr)\n",
@@ -64,6 +69,12 @@ int saa7164_dl_wait_clr(struct saa7164_d
 			return -EBUSY;
 		}
 		msleep(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/media/video/w9966.c b/media/video/w9966.c
--- a/media/video/w9966.c
+++ b/media/video/w9966.c
@@ -267,9 +267,20 @@ static int w9966_i2c_setscl(struct w9966
 	/* we go to high, we also expect the peripheral to ack. */
 	if (state) {
 		timeout = jiffies + 100;
-		while (!w9966_i2c_getscl(cam)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+	while (!w9966_i2c_getscl(cam)) {
 			if (time_after(jiffies, timeout))
 				return -1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 	return 0;
diff -u -p a/media/video/omap3isp/isp.c b/media/video/omap3isp/isp.c
--- a/media/video/omap3isp/isp.c
+++ b/media/video/omap3isp/isp.c
@@ -564,9 +564,20 @@ static int isp_pipeline_pm_use_count(str
 
 	media_entity_graph_walk_start(&graph, entity);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((entity = media_entity_graph_walk_next(&graph))) {
 		if (media_entity_type(entity) == MEDIA_ENT_T_DEVNODE)
 			use += entity->use_count;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return use;
@@ -812,9 +823,20 @@ static int isp_pipeline_wait(struct isp_
 {
 	unsigned long timeout = jiffies + ISP_STOP_TIMEOUT;
 
-	while (!time_after(jiffies, timeout)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (!time_after(jiffies, timeout)) {
 		if (!busy(isp))
 			return 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 1;
@@ -1018,6 +1040,11 @@ static int isp_suspend_modules(struct is
 	isp_suspend_module_pipeline(&isp->isp_ccp2.subdev.entity);
 
 	timeout = jiffies + ISP_STOP_TIMEOUT;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (omap3isp_stat_busy(&isp->isp_af)
 	    || omap3isp_stat_busy(&isp->isp_aewb)
 	    || omap3isp_stat_busy(&isp->isp_hist)
@@ -1029,6 +1056,12 @@ static int isp_suspend_modules(struct is
 			return 1;
 		}
 		msleep(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1062,13 +1095,24 @@ static int isp_reset(struct isp_device *
 		       isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG)
 		       | ISP_SYSCONFIG_SOFTRESET,
 		       OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);
-	while (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN,
 			       ISP_SYSSTATUS) & 0x1)) {
 		if (timeout++ > 10000) {
 			dev_alert(isp->dev, "cannot reset ISP\n");
 			return -ETIMEDOUT;
 		}
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/media/video/bw-qcam.c b/media/video/bw-qcam.c
--- a/media/video/bw-qcam.c
+++ b/media/video/bw-qcam.c
@@ -176,6 +176,11 @@ static int qc_waithand(struct qcam *q, i
 	int runs = 0;
 
 	if (val) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!((status = read_lpstatus(q)) & 8)) {
 			/* 1000 is enough spins on the I/O for all normal
 			   cases, at that point we start to poll slowly
@@ -188,8 +193,19 @@ static int qc_waithand(struct qcam *q, i
 				msleep_interruptible(5);
 			if (runs > (maxpoll + 1000)) /* 5 seconds */
 				return -1;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	} else {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (((status = read_lpstatus(q)) & 8)) {
 			/* 1000 is enough spins on the I/O for all normal
 			   cases, at that point we start to poll slowly
@@ -202,6 +218,12 @@ static int qc_waithand(struct qcam *q, i
 				msleep_interruptible(5);
 			if (runs++ > (maxpoll + 1000)) /* 5 seconds */
 				return -1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 
diff -u -p a/media/video/fsl-viu.c b/media/video/fsl-viu.c
--- a/media/video/fsl-viu.c
+++ b/media/video/fsl-viu.c
@@ -385,12 +385,23 @@ static void viu_vid_timeout(unsigned lon
 	struct viu_buf *buf;
 	struct viu_dmaqueue *vidq = &dev->vidq;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&vidq->active)) {
 		buf = list_entry(vidq->active.next, struct viu_buf, vb.queue);
 		list_del(&buf->vb.queue);
 		buf->vb.state = VIDEOBUF_ERROR;
 		wake_up(&buf->vb.done);
 		dprintk(1, "viu/0: [%p/%d] timeout\n", buf, buf->vb.i);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	restart_video_queue(vidq);
diff -u -p a/media/video/omap24xxcam.c b/media/video/omap24xxcam.c
--- a/media/video/omap24xxcam.c
+++ b/media/video/omap24xxcam.c
@@ -238,6 +238,11 @@ static void omap24xxcam_vbq_free_mmap_bu
 		return;
 
 	i = dma->sglen;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i) {
 		i--;
 		alloc_size = sg_dma_len(&dma->sglist[i]);
@@ -247,6 +252,12 @@ static void omap24xxcam_vbq_free_mmap_bu
 		} while (alloc_size -= PAGE_SIZE);
 		__free_pages(sg_page(&dma->sglist[i]),
 			     get_order(sg_dma_len(&dma->sglist[i])));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(dma->sglist);
@@ -299,6 +310,11 @@ static int omap24xxcam_vbq_alloc_mmap_bu
 		goto out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		order = get_order(size);
 		/*
@@ -335,6 +351,12 @@ static int omap24xxcam_vbq_alloc_mmap_bu
 		do {
 			SetPageReserved(page++);
 		} while (alloc_size -= PAGE_SIZE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * REVISIT: not fully correct to assign nr_pages == sglen but
@@ -371,9 +393,20 @@ static int omap24xxcam_vbq_alloc_mmap_bu
 
 	return 0;
 out:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i) {
 		i--;
 		omap24xxcam_vbq_free_mmap_buffer(vbq->bufs[i]);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&vbq->vb_lock);
diff -u -p a/media/video/saa6588.c b/media/video/saa6588.c
--- a/media/video/saa6588.c
+++ b/media/video/saa6588.c
@@ -193,13 +193,24 @@ static void read_from_buf(struct saa6588
 	if (!a->buffer)
 		return;
 
-	while (!s->data_available_for_read) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!s->data_available_for_read) {
 		int ret = wait_event_interruptible(s->read_queue,
 					     s->data_available_for_read);
 		if (ret == -ERESTARTSYS) {
 			a->result = -EINTR;
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_lock_irqsave(&s->lock, flags);
diff -u -p a/media/video/saa717x.c b/media/video/saa717x.c
--- a/media/video/saa717x.c
+++ b/media/video/saa717x.c
@@ -124,9 +124,20 @@ static int saa717x_write(struct v4l2_sub
 
 static void saa717x_write_regs(struct v4l2_subdev *sd, u32 *data)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (data[0] || data[1]) {
 		saa717x_write(sd, data[0], data[1]);
 		data += 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/tlg2300/pd-video.c b/media/video/tlg2300/pd-video.c
--- a/media/video/tlg2300/pd-video.c
+++ b/media/video/tlg2300/pd-video.c
@@ -244,6 +244,11 @@ static void copy_video_data(struct video
 		count -= len; \
 	 } while (0)
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count && count >= video->lines_size) {
 		if (video->prev_left) {
 			copy_data(video->prev_left);
@@ -251,6 +256,12 @@ static void copy_video_data(struct video
 			continue;
 		}
 		copy_data(video->lines_size);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (count && count < video->lines_size) {
 		memcpy(video->dst, src, count);
diff -u -p a/media/video/sh_mobile_ceu_camera.c b/media/video/sh_mobile_ceu_camera.c
--- a/media/video/sh_mobile_ceu_camera.c
+++ b/media/video/sh_mobile_ceu_camera.c
@@ -1317,6 +1317,11 @@ static int client_s_crop(struct soc_came
 	 * Loop as long as sensor is not covering the requested rectangle and
 	 * is still within its bounds
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!ret && (is_smaller(cam_rect, rect) ||
 			is_inside(cam_rect, rect)) &&
 	       (cap.bounds.width > width || cap.bounds.height > height)) {
@@ -1355,6 +1360,12 @@ static int client_s_crop(struct soc_came
 		dev_geo(dev, "Camera S_CROP %d for %dx%d@%d:%d\n", ret,
 			cam_rect->width, cam_rect->height,
 			cam_rect->left, cam_rect->top);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	/* S_CROP must not modify the rectangle */
@@ -1424,6 +1435,11 @@ static int client_s_fmt(struct soc_camer
 	tmp_h = mf->height;
 
 	/* width <= max_width && height <= max_height - guaranteed by try_fmt */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((width > tmp_w || height > tmp_h) &&
 	       tmp_w < max_width && tmp_h < max_height) {
 		tmp_w = min(2 * tmp_w, max_width);
@@ -1440,7 +1456,13 @@ static int client_s_fmt(struct soc_camer
 			dev_err(dev, "Client failed to set format: %d\n", ret);
 			return ret;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 update_cache:
 	/* Update cache */
diff -u -p a/media/video/omap24xxcam-dma.c b/media/video/omap24xxcam-dma.c
--- a/media/video/omap24xxcam-dma.c
+++ b/media/video/omap24xxcam-dma.c
@@ -450,6 +450,11 @@ void omap24xxcam_sgdma_process(struct om
 	sgslot = (sgdma->next_sgdma + sgdma->free_sgdma) % NUM_SG_DMA;
 	while (queued_sgdma > 0) {
 		sg_state = sgdma->sg_state + sgslot;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((sg_state->next_sglist < sg_state->sglen) &&
 		       !(sg_state->csr & csr_error)) {
 			const struct scatterlist *sglist;
@@ -486,6 +491,12 @@ void omap24xxcam_sgdma_process(struct om
 				expires = jiffies + HZ;
 				mod_timer(&sgdma->reset_timer, expires);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		queued_sgdma--;
 		sgslot = (sgslot + 1) % NUM_SG_DMA;
diff -u -p a/media/video/s5p-mfc/s5p_mfc.c b/media/video/s5p-mfc/s5p_mfc.c
--- a/media/video/s5p-mfc/s5p_mfc.c
+++ b/media/video/s5p-mfc/s5p_mfc.c
@@ -169,7 +169,12 @@ static void s5p_mfc_handle_frame_all_ext
 
 	ctx->state = MFCINST_FINISHED;
 	ctx->sequence++;
-	while (!list_empty(&ctx->dst_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ctx->dst_queue)) {
 		dst_buf = list_entry(ctx->dst_queue.next,
 				     struct s5p_mfc_buf, list);
 		mfc_debug(2, "Cleaning up buffer: %d\n",
@@ -188,6 +193,12 @@ static void s5p_mfc_handle_frame_all_ext
 
 		ctx->dec_dst_flag &= ~(1 << dst_buf->b->v4l2_buf.index);
 		vb2_buffer_done(dst_buf->b, VB2_BUF_STATE_DONE);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -664,6 +675,11 @@ static int s5p_mfc_open(struct file *fil
 	ctx->dst_queue_cnt = 0;
 	/* Get context number */
 	ctx->num = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dev->ctx[ctx->num]) {
 		ctx->num++;
 		if (ctx->num >= MFC_NUM_CONTEXTS) {
@@ -671,6 +687,12 @@ static int s5p_mfc_open(struct file *fil
 			ret = -EBUSY;
 			goto err_no_ctx;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Mark context as idle */
 	spin_lock_irqsave(&dev->condlock, flags);
diff -u -p a/media/video/s5p-mfc/s5p_mfc_enc.c b/media/video/s5p-mfc/s5p_mfc_enc.c
--- a/media/video/s5p-mfc/s5p_mfc_enc.c
+++ b/media/video/s5p-mfc/s5p_mfc_enc.c
@@ -596,7 +596,12 @@ static void cleanup_ref_queue(struct s5p
 	unsigned long mb_y_addr, mb_c_addr;
 
 	/* move buffers in ref queue to src queue */
-	while (!list_empty(&ctx->ref_queue)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&ctx->ref_queue)) {
 		mb_entry = list_entry((&ctx->ref_queue)->next,
 						struct s5p_mfc_buf, list);
 		mb_y_addr = vb2_dma_contig_plane_dma_addr(mb_entry->b, 0);
@@ -605,6 +610,12 @@ static void cleanup_ref_queue(struct s5p
 		ctx->ref_queue_cnt--;
 		list_add_tail(&mb_entry->list, &ctx->src_queue);
 		ctx->src_queue_cnt++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	mfc_debug(2, "enc src count: %d, enc ref count: %d\n",
 		  ctx->src_queue_cnt, ctx->ref_queue_cnt);
diff -u -p a/media/video/s5p-mfc/s5p_mfc_opr.c b/media/video/s5p-mfc/s5p_mfc_opr.c
--- a/media/video/s5p-mfc/s5p_mfc_opr.c
+++ b/media/video/s5p-mfc/s5p_mfc_opr.c
@@ -1095,6 +1095,11 @@ static int s5p_mfc_get_new_ctx(struct s5
 	spin_lock_irqsave(&dev->condlock, flags);
 	new_ctx = (dev->curr_ctx + 1) % MFC_NUM_CONTEXTS;
 	cnt = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!test_bit(new_ctx, &dev->ctx_work_bits)) {
 		new_ctx = (new_ctx + 1) % MFC_NUM_CONTEXTS;
 		if (++cnt > MFC_NUM_CONTEXTS) {
@@ -1102,6 +1107,12 @@ static int s5p_mfc_get_new_ctx(struct s5
 			spin_unlock_irqrestore(&dev->condlock, flags);
 			return -EAGAIN;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&dev->condlock, flags);
 	return new_ctx;
@@ -1386,12 +1397,23 @@ void s5p_mfc_cleanup_queue(struct list_h
 	struct s5p_mfc_buf *b;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(lh)) {
 		b = list_entry(lh->next, struct s5p_mfc_buf, list);
 		for (i = 0; i < b->b->num_planes; i++)
 			vb2_set_plane_payload(b->b, i, 0);
 		vb2_buffer_done(b->b, VB2_BUF_STATE_ERROR);
 		list_del(&b->list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/media/video/s5p-fimc/fimc-mdevice.c b/media/video/s5p-fimc/fimc-mdevice.c
--- a/media/video/s5p-fimc/fimc-mdevice.c
+++ b/media/video/s5p-fimc/fimc-mdevice.c
@@ -45,6 +45,11 @@ void fimc_pipeline_prepare(struct fimc_d
 
 	media_entity_graph_walk_start(&graph, me);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((me = media_entity_graph_walk_next(&graph))) {
 		if (media_entity_type(me) != MEDIA_ENT_T_V4L2_SUBDEV)
 			continue;
@@ -54,6 +59,12 @@ void fimc_pipeline_prepare(struct fimc_d
 			fimc->pipeline.sensor = sd;
 		else if (sd->grp_id == CSIS_GROUP_ID)
 			fimc->pipeline.csis = sd;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/media/video/s5p-fimc/fimc-capture.c b/media/video/s5p-fimc/fimc-capture.c
--- a/media/video/s5p-fimc/fimc-capture.c
+++ b/media/video/s5p-fimc/fimc-capture.c
@@ -85,17 +85,39 @@ static int fimc_capture_state_cleanup(st
 		fimc->state &= ~(1 << ST_CAPT_PEND | 1 << ST_CAPT_SUSPENDED);
 
 	/* Release unused buffers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!suspend && !list_empty(&cap->pending_buf_q)) {
 		buf = fimc_pending_queue_pop(cap);
 		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* If suspending put unused buffers onto pending queue */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&cap->active_buf_q)) {
 		buf = fimc_active_queue_pop(cap);
 		if (suspend)
 			fimc_pending_queue_add(cap, buf);
 		else
 			vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	set_bit(ST_CAPT_SUSPENDED, &fimc->state);
 
diff -u -p a/media/video/v4l2-int-device.c b/media/video/v4l2-int-device.c
--- a/media/video/v4l2-int-device.c
+++ b/media/video/v4l2-int-device.c
@@ -119,6 +119,11 @@ static v4l2_int_ioctl_func *find_ioctl(s
 	const struct v4l2_int_ioctl_desc *last =
 		first + slave->num_ioctls - 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (first <= last) {
 		const struct v4l2_int_ioctl_desc *mid;
 
@@ -130,6 +135,12 @@ static v4l2_int_ioctl_func *find_ioctl(s
 			last = mid - 1;
 		else
 			return mid->func;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return no_such_ioctl;
diff -u -p a/media/video/vino.c b/media/video/vino.c
--- a/media/video/vino.c
+++ b/media/video/vino.c
@@ -2382,6 +2382,11 @@ static irqreturn_t vino_interrupt(int ir
 
 	spin_lock(&vino_drvdata->vino_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((intr = vino->intr_status)) {
 		fc_a = vino->a.field_counter >> 1;
 		fc_b = vino->b.field_counter >> 1;
@@ -2506,6 +2511,12 @@ static irqreturn_t vino_interrupt(int ir
 		loop++;
 #endif
 		spin_lock(&vino_drvdata->vino_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock(&vino_drvdata->vino_lock);
diff -u -p a/media/video/vivi.c b/media/video/vivi.c
--- a/media/video/vivi.c
+++ b/media/video/vivi.c
@@ -639,12 +639,23 @@ static void vivi_stop_generating(struct
 	 */
 
 	/* Release all active buffers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&dma_q->active)) {
 		struct vivi_buffer *buf;
 		buf = list_entry(dma_q->active.next, struct vivi_buffer, list);
 		list_del(&buf->list);
 		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
 		dprintk(dev, 2, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 /* ------------------------------------------------------------------
@@ -1233,7 +1244,12 @@ static int vivi_release(void)
 	struct vivi_dev *dev;
 	struct list_head *list;
 
-	while (!list_empty(&vivi_devlist)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&vivi_devlist)) {
 		list = vivi_devlist.next;
 		list_del(list);
 		dev = list_entry(list, struct vivi_dev, vivi_devlist);
@@ -1244,6 +1260,12 @@ static int vivi_release(void)
 		v4l2_device_unregister(&dev->v4l2_dev);
 		v4l2_ctrl_handler_free(&dev->ctrl_handler);
 		kfree(dev);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
diff -u -p a/media/video/videobuf-dvb.c b/media/video/videobuf-dvb.c
--- a/media/video/videobuf-dvb.c
+++ b/media/video/videobuf-dvb.c
@@ -84,9 +84,20 @@ static int videobuf_dvb_thread(void *dat
 	dprintk("dvb thread stopped\n");
 
 	/* Hmm, linux becomes *very* unhappy without this ... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/media/video/tvp5150.c b/media/video/tvp5150.c
--- a/media/video/tvp5150.c
+++ b/media/video/tvp5150.c
@@ -85,6 +85,11 @@ static void dump_reg_range(struct v4l2_s
 {
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (init != (u8)(end + 1)) {
 		if ((i % max_line) == 0) {
 			if (i > 0)
@@ -95,6 +100,12 @@ static void dump_reg_range(struct v4l2_s
 
 		init++;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	printk("\n");
 }
diff -u -p a/media/video/c-qcam.c b/media/video/c-qcam.c
--- a/media/video/c-qcam.c
+++ b/media/video/c-qcam.c
@@ -307,6 +307,11 @@ static unsigned int qcam_read_bytes(stru
 	qcam_set_ack(qcam, 0);
 	if (qcam->bidirectional) {
 		/* It's a bidirectional port */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bytes < nbytes) {
 			unsigned int lo1, hi1, lo2, hi2;
 			unsigned char r, g, b;
@@ -333,12 +338,23 @@ static unsigned int qcam_read_bytes(stru
 				buf[bytes++] = g;
 				buf[bytes++] = r;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		/* It's a unidirectional port */
 		int i = 0, n = bytes;
 		unsigned char rgb[3];
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bytes < nbytes) {
 			unsigned int hi, lo;
 
@@ -364,6 +380,12 @@ get_fragment:
 					buf[n++] = rgb[0];
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (i) {
 			i = 0;
diff -u -p a/media/common/tuners/xc4000.c b/media/common/tuners/xc4000.c
--- a/media/common/tuners/xc4000.c
+++ b/media/common/tuners/xc4000.c
@@ -338,7 +338,12 @@ static int xc_load_i2c_sequence(struct d
 			buf[0] = i2c_sequence[index];
 			buf[1] = i2c_sequence[index + 1];
 			pos = 2;
-			while (pos < len) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (pos < len) {
 				if ((len - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)
 					nbytes_to_send =
 						XC_MAX_I2C_WRITE_LENGTH;
@@ -355,6 +360,12 @@ static int xc_load_i2c_sequence(struct d
 					return result;
 
 				pos += nbytes_to_send - 2;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			index += len;
 		}
@@ -767,7 +778,12 @@ static int xc4000_fwupload(struct dvb_fr
 	priv->firm_size = n_array;
 
 	n = -1;
-	while (p < endp) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (p < endp) {
 		__u32 type, size;
 		v4l2_std_id id;
 		__u16 int_freq = 0;
@@ -827,6 +843,12 @@ static int xc4000_fwupload(struct dvb_fr
 		priv->firm[n].int_freq = int_freq;
 
 		p += size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (n + 1 != priv->firm_size) {
diff -u -p a/media/common/tuners/xc5000.c b/media/common/tuners/xc5000.c
--- a/media/common/tuners/xc5000.c
+++ b/media/common/tuners/xc5000.c
@@ -349,7 +349,12 @@ static int xc_load_i2c_sequence(struct d
 			buf[0] = i2c_sequence[index];
 			buf[1] = i2c_sequence[index + 1];
 			pos = 2;
-			while (pos < len) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (pos < len) {
 				if ((len - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)
 					nbytes_to_send =
 						XC_MAX_I2C_WRITE_LENGTH;
@@ -366,6 +371,12 @@ static int xc_load_i2c_sequence(struct d
 					return result;
 
 				pos += nbytes_to_send - 2;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			index += len;
 		}
diff -u -p a/media/common/tuners/mxl5007t.c b/media/common/tuners/mxl5007t.c
--- a/media/common/tuners/mxl5007t.c
+++ b/media/common/tuners/mxl5007t.c
@@ -177,6 +177,11 @@ static void set_reg_bits(struct reg_pair
 {
 	unsigned int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_pair[i].reg || reg_pair[i].val) {
 		if (reg_pair[i].reg == reg) {
 			reg_pair[i].val &= ~mask;
@@ -184,6 +189,12 @@ static void set_reg_bits(struct reg_pair
 		}
 		i++;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return;
 }
@@ -195,6 +206,11 @@ static void copy_reg_bits(struct reg_pai
 
 	i = j = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_pair1[i].reg || reg_pair1[i].val) {
 		while (reg_pair2[j].reg || reg_pair2[j].val) {
 			if (reg_pair1[i].reg != reg_pair2[j].reg) {
@@ -205,6 +221,12 @@ static void copy_reg_bits(struct reg_pai
 			break;
 		}
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return;
 }
diff -u -p a/media/common/tuners/tda18271-maps.c b/media/common/tuners/tda18271-maps.c
--- a/media/common/tuners/tda18271-maps.c
+++ b/media/common/tuners/tda18271-maps.c
@@ -1022,6 +1022,11 @@ int tda18271_lookup_rf_band(struct dvb_f
 	struct tda18271_rf_tracking_filter_cal *map = priv->rf_cal_state;
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((map[i].rfmax * 1000) < *freq) {
 		if (tda18271_debug & DBG_ADV)
 			tda_map("(%d) rfmax = %d < freq = %d, "
@@ -1037,6 +1042,12 @@ int tda18271_lookup_rf_band(struct dvb_f
 		if (map[i].rfmax == 0)
 			return -EINVAL;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (rf_band)
 		*rf_band = map[i].rfband;
diff -u -p a/media/media-entity.c b/media/media-entity.c
--- a/media/media-entity.c
+++ b/media/media-entity.c
@@ -167,6 +167,11 @@ media_entity_graph_walk_next(struct medi
 	 * top of the stack until no more entities on the level can be
 	 * found.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (link_top(graph) < stack_top(graph)->num_links) {
 		struct media_entity *entity = stack_top(graph);
 		struct media_link *link = &entity->links[link_top(graph)];
@@ -190,6 +195,12 @@ media_entity_graph_walk_next(struct medi
 		/* Push the new entity to stack and start over. */
 		link_top(graph)++;
 		stack_push(graph, next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return stack_pop(graph);
@@ -224,10 +235,21 @@ void media_entity_pipeline_start(struct
 
 	media_entity_graph_walk_start(&graph, entity);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((entity = media_entity_graph_walk_next(&graph))) {
 		entity->stream_count++;
 		WARN_ON(entity->pipe && entity->pipe != pipe);
 		entity->pipe = pipe;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&mdev->graph_mutex);
@@ -255,10 +277,21 @@ void media_entity_pipeline_stop(struct m
 
 	media_entity_graph_walk_start(&graph, entity);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((entity = media_entity_graph_walk_next(&graph))) {
 		entity->stream_count--;
 		if (entity->stream_count == 0)
 			entity->pipe = NULL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	mutex_unlock(&mdev->graph_mutex);
diff -u -p a/nubus/proc.c b/nubus/proc.c
--- a/nubus/proc.c
+++ b/nubus/proc.c
@@ -33,7 +33,12 @@ nubus_devices_proc_show(struct seq_file
 {
 	struct nubus_dev *dev = nubus_devices;
 
-	while (dev) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (dev) {
 		seq_printf(m, "%x\t%04x %04x %04x %04x",
 			      dev->board->slot,
 			      dev->category,
@@ -42,6 +47,12 @@ nubus_devices_proc_show(struct seq_file
 			      dev->dr_hw);
 		seq_printf(m, "\t%08lx\n", dev->board->slot_addr);
 		dev = dev->next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return 0;
 }
diff -u -p a/nubus/nubus.c b/nubus/nubus.c
--- a/nubus/nubus.c
+++ b/nubus/nubus.c
@@ -87,6 +87,11 @@ static unsigned long nubus_get_rom(unsig
 	unsigned long v = 0;
 	unsigned char *p = *ptr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len)
 	{
 		v <<= 8;
@@ -94,6 +99,12 @@ static unsigned long nubus_get_rom(unsig
 			p++;
 		v |= *p++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*ptr = p;
 	return v;
@@ -106,6 +117,11 @@ static void nubus_rewind(unsigned char *
 	/* Sanity check */
 	if(len > 65536)
 		printk(KERN_ERR "rewind of 0x%08x!\n", len);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len)
 	{
 		do
@@ -114,6 +130,12 @@ static void nubus_rewind(unsigned char *
 		}
 		while(not_useful(p, map));
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*ptr=p;
 }
@@ -123,12 +145,23 @@ static void nubus_advance(unsigned char
 	unsigned char *p = *ptr;
 	if(len>65536)
 		printk(KERN_ERR "advance of 0x%08x!\n", len);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len)
 	{
 		while(not_useful(p,map))
 			p++;
 		p++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*ptr = p;
 }
@@ -182,10 +215,21 @@ void nubus_get_rsrc_mem(void *dest, cons
 {
 	unsigned char *t = (unsigned char *)dest;
 	unsigned char *p = nubus_dirptr(dirent);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(len)
 	{
 		*t++ = nubus_get_rom(&p, 1, dirent->mask);
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL(nubus_get_rsrc_mem);
@@ -303,6 +347,11 @@ nubus_find_device(unsigned short categor
 	struct nubus_dev* itor =
 		from ? from->next : nubus_devices;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (itor) {
 		if (itor->category == category
 		    && itor->type == type
@@ -310,6 +359,12 @@ nubus_find_device(unsigned short categor
 		    && itor->dr_sw == dr_sw)
 			return itor;
 		itor = itor->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -323,11 +378,22 @@ nubus_find_type(unsigned short category,
 	struct nubus_dev* itor =
 		from ? from->next : nubus_devices;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (itor) {
 		if (itor->category == category
 		    && itor->type == type)
 			return itor;
 		itor = itor->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -340,10 +406,21 @@ nubus_find_slot(unsigned int slot,
 	struct nubus_dev* itor =
 		from ? from->next : nubus_devices;
 	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (itor) {
 		if (itor->board->slot == slot)
 			return itor;
 		itor = itor->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/power/test_power.c b/power/test_power.c
--- a/power/test_power.c
+++ b/power/test_power.c
@@ -240,10 +240,21 @@ static int map_get_value(struct battery_
 	if (buf[cr] == '\n')
 		buf[cr] = '\0';
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (map->key) {
 		if (strncasecmp(map->key, buf, MAX_KEYLENGTH) == 0)
 			return map->value;
 		map++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return def_val;
@@ -253,10 +264,21 @@ static int map_get_value(struct battery_
 static const char *map_get_key(struct battery_property_map *map, int value,
 				const char *def_key)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (map->key) {
 		if (map->value == value)
 			return map->key;
 		map++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return def_key;
diff -u -p a/video/aty/aty128fb.c b/video/aty/aty128fb.c
--- a/video/aty/aty128fb.c
+++ b/video/aty/aty128fb.c
@@ -1412,9 +1412,20 @@ static int aty128_ddafifo(struct aty128_
 	DBG("x %x\n", x);
 
 	b = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (x) {
 		x >>= 1;
 		b++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	p = b + 1;
 
diff -u -p a/video/aty/mach64_gx.c b/video/aty/mach64_gx.c
--- a/video/aty/mach64_gx.c
+++ b/video/aty/mach64_gx.c
@@ -520,9 +520,20 @@ static int aty_var_to_pll_1703(const str
 			mhz100 = mach64MaxFreq;
 
 		divider = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (mhz100 < (mach64MinFreq << 3)) {
 			mhz100 <<= 1;
 			divider += 0x20;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		temp = (unsigned int) (mhz100);
@@ -640,9 +651,20 @@ static int aty_var_to_pll_8398(const str
 
 		longMHz100 = mhz100 * 256 / 100;	/* 8 bit scale this */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (mhz100 < (mach64MinFreq << 3)) {
 			mhz100 <<= 1;
 			k++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		twoToKth = 1 << k;
@@ -759,9 +781,20 @@ static int aty_var_to_pll_408(const stru
 		if (mhz100 > mach64MaxFreq)
 			mhz100 = mach64MaxFreq;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (mhz100 < (mach64MinFreq << 3)) {
 			mhz100 <<= 1;
 			divider += 0x40;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		temp = (unsigned int) mhz100;
diff -u -p a/video/aty/radeon_monitor.c b/video/aty/radeon_monitor.c
--- a/video/aty/radeon_monitor.c
+++ b/video/aty/radeon_monitor.c
@@ -977,6 +977,11 @@ int  radeon_match_mode(struct radeonfb_i
 	}
 
 	/* Now look for a mode in the database */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (db) {
 		for (i = 0; i < dbsize; i++) {
 			int d;
@@ -1001,6 +1006,12 @@ int  radeon_match_mode(struct radeonfb_i
 			dbsize = 34;
 			native_db = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If we have found a match, return it */
diff -u -p a/video/aty/atyfb_base.c b/video/aty/atyfb_base.c
--- a/video/aty/atyfb_base.c
+++ b/video/aty/atyfb_base.c
@@ -193,9 +193,20 @@ static void ATIReduceRatio(int *Numerato
 	Multiplier = *Numerator;
 	Divider = *Denominator;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((Remainder = Multiplier % Divider)) {
 		Multiplier = Divider;
 		Divider = Remainder;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*Numerator /= Divider;
diff -u -p a/video/sis/sis_main.c b/video/sis/sis_main.c
--- a/video/sis/sis_main.c
+++ b/video/sis/sis_main.c
@@ -3347,6 +3347,11 @@ sisfb_poh_free(struct SIS_HEAP *memheap,
 
 	pohThis = memheap->oh_free.poh_next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(pohThis != &memheap->oh_free) {
 		if(pohThis->offset == ulUpper) {
 			poh_next = pohThis;
@@ -3354,6 +3359,12 @@ sisfb_poh_free(struct SIS_HEAP *memheap,
 			poh_prev = pohThis;
 		}
 		pohThis = pohThis->poh_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sisfb_delete_node(poh_freed);
diff -u -p a/video/sis/init301.c b/video/sis/init301.c
--- a/video/sis/init301.c
+++ b/video/sis/init301.c
@@ -8771,9 +8771,20 @@ SiS_SetTrumpionBlock(struct SiS_Private
 
   SiS_SetSwitchDDC2(SiS_Pr);
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while(*dataptr) {
      dataptr = SiS_SetTrumpBlockLoop(SiS_Pr, dataptr);
      if(!dataptr) return false;
+     if (_cur < timeout) {
+       rdstcll(_cur);
+     }
+     else {
+       break;
+     }
   }
   return true;
 }
diff -u -p a/video/via/hw.c b/video/via/hw.c
--- a/video/via/hw.c
+++ b/video/via/hw.c
@@ -916,6 +916,11 @@ u32 via_parse_odev(char *input, char **e
 	bool next = true;
 	int i, len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next) {
 		next = false;
 		for (i = 0; i < ARRAY_SIZE(device_mapping); i++) {
@@ -929,6 +934,12 @@ u32 via_parse_odev(char *input, char **e
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*end = ptr;
diff -u -p a/video/i810/i810_main.c b/video/i810/i810_main.c
--- a/video/i810/i810_main.c
+++ b/video/i810/i810_main.c
@@ -726,6 +726,11 @@ static void i810_calc_dclk(u32 freq, u32
 	}
 
 	n_reg = m_reg = n_target = 3;	
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (diff_min && mod_min && (n_target < n_target_max)) {
 		f_out = (p_divisor * n_reg * 1000000)/(4 * 24 * m_reg);
 		mod = (p_divisor * n_reg * 1000000) % (4 * 24 * m_reg);
@@ -750,6 +755,12 @@ static void i810_calc_dclk(u32 freq, u32
 			n_best = n_target;
 			m_best = m_target;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	} 
 	if (m) *m = (m_best - 2) & 0x3FF;
 	if (n) *n = (n_best - 2) & 0x3FF;
diff -u -p a/video/kyro/fbdev.c b/video/kyro/fbdev.c
--- a/video/kyro/fbdev.c
+++ b/video/kyro/fbdev.c
@@ -563,6 +563,11 @@ static int __init kyrofb_setup(char *opt
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -577,6 +582,12 @@ static int __init kyrofb_setup(char *opt
 		} else {
 			mode_option = this_opt;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/kyro/STG4000OverlayDevice.c b/video/kyro/STG4000OverlayDevice.c
--- a/video/kyro/STG4000OverlayDevice.c
+++ b/video/kyro/STG4000OverlayDevice.c
@@ -303,11 +303,22 @@ static u32 Overlap(u32 ulBits, u32 ulPat
 {
 	u32 ulCount = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ulBits) {
 		if (!(ulPattern & 1))
 			ulCount++;
 		ulBits--;
 		ulPattern = ulPattern >> 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ulCount;
diff -u -p a/video/omap/dispc.c b/video/omap/dispc.c
--- a/video/omap/dispc.c
+++ b/video/omap/dispc.c
@@ -1416,6 +1416,11 @@ static int omap_dispc_init(struct omapfb
 		/* Soft reset */
 		MOD_REG_FLD(DISPC_SYSCONFIG, 1 << 1, 1 << 1);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(dispc_read_reg(DISPC_SYSSTATUS) & 1)) {
 			if (!--tmo) {
 				dev_err(dispc.fbdev->dev, "soft reset failed\n");
@@ -1423,6 +1428,12 @@ static int omap_dispc_init(struct omapfb
 				enable_digit_clocks(0);
 				goto fail1;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		enable_digit_clocks(0);
diff -u -p a/video/omap/sossi.c b/video/omap/sossi.c
--- a/video/omap/sossi.c
+++ b/video/omap/sossi.c
@@ -305,10 +305,21 @@ static void send_data(const void *data,
 		len -= 2;
 		data += 2;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		sossi_write_reg8(SOSSI_FIFO_REG, *(const u8 *) data);
 		len--;
 		data++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -546,10 +557,21 @@ static void sossi_read_data(void *data,
 		len -= 2;
 		data += 2;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		*(u8 *) data = sossi_read_reg8(SOSSI_FIFO_REG);
 		len--;
 		data++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	sossi_stop_transfer();
 	clk_disable(sossi.fck);
diff -u -p a/video/omap/hwa742.c b/video/omap/hwa742.c
--- a/video/omap/hwa742.c
+++ b/video/omap/hwa742.c
@@ -282,7 +282,12 @@ static void process_pending_requests(voi
 
 	spin_lock_irqsave(&hwa742.req_lock, flags);
 
-	while (!list_empty(&hwa742.pending_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&hwa742.pending_req_list)) {
 		struct hwa742_request *req;
 		void (*complete)(void *);
 		void *complete_data;
@@ -302,6 +307,12 @@ static void process_pending_requests(voi
 			complete(complete_data);
 
 		spin_lock_irqsave(&hwa742.req_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&hwa742.req_lock, flags);
diff -u -p a/video/omap/blizzard.c b/video/omap/blizzard.c
--- a/video/omap/blizzard.c
+++ b/video/omap/blizzard.c
@@ -410,7 +410,12 @@ static void process_pending_requests(voi
 
 	spin_lock_irqsave(&blizzard.req_lock, flags);
 
-	while (!list_empty(&blizzard.pending_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&blizzard.pending_req_list)) {
 		struct blizzard_request *req;
 		void (*complete)(void *);
 		void *complete_data;
@@ -430,6 +435,12 @@ static void process_pending_requests(voi
 			complete(complete_data);
 
 		spin_lock_irqsave(&blizzard.req_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&blizzard.req_lock, flags);
diff -u -p a/video/pxafb.c b/video/pxafb.c
--- a/video/pxafb.c
+++ b/video/pxafb.c
@@ -1266,6 +1266,11 @@ static int pxafb_smart_thread(void *arg)
 	pr_debug("%s(): task starting\n", __func__);
 
 	set_freezable();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 
 		if (try_to_freeze())
@@ -1282,6 +1287,12 @@ static int pxafb_smart_thread(void *arg)
 
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(30 * HZ / 1000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_debug("%s(): task ending\n", __func__);
diff -u -p a/video/console/fbcon.c b/video/console/fbcon.c
--- a/video/console/fbcon.c
+++ b/video/console/fbcon.c
@@ -1800,6 +1800,11 @@ static inline void fbcon_softback_note(s
 		return;
 	p = (unsigned short *) (vc->vc_origin + t * vc->vc_size_row);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		scr_memcpyw((u16 *) softback_in, p, vc->vc_size_row);
 		count--;
@@ -1812,6 +1817,12 @@ static inline void fbcon_softback_note(s
 			if (softback_top == softback_end)
 				softback_top = softback_buf;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	softback_curr = softback_in;
 }
diff -u -p a/video/console/fbcon_ccw.c b/video/console/fbcon_ccw.c
--- a/video/console/fbcon_ccw.c
+++ b/video/console/fbcon_ccw.c
@@ -160,7 +160,12 @@ static void ccw_putcs(struct vc_data *vc
 
 	s += count - 1;
 
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -178,6 +183,12 @@ static void ccw_putcs(struct vc_data *vc
 		image.dy += image.height;
 		count -= cnt;
 		s -= cnt;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* buf is always NULL except when in monochrome mode, so in this case
diff -u -p a/video/console/fbcon_cw.c b/video/console/fbcon_cw.c
--- a/video/console/fbcon_cw.c
+++ b/video/console/fbcon_cw.c
@@ -144,7 +144,12 @@ static void cw_putcs(struct vc_data *vc,
 			return;
 	}
 
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -162,6 +167,12 @@ static void cw_putcs(struct vc_data *vc,
 		image.dy += image.height;
 		count -= cnt;
 		s += cnt;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* buf is always NULL except when in monochrome mode, so in this case
diff -u -p a/video/console/fbcon_ud.c b/video/console/fbcon_ud.c
--- a/video/console/fbcon_ud.c
+++ b/video/console/fbcon_ud.c
@@ -183,7 +183,12 @@ static void ud_putcs(struct vc_data *vc,
 
 	s += count - 1;
 
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -209,6 +214,12 @@ static void ud_putcs(struct vc_data *vc,
 		count -= cnt;
 		s -= cnt;
 		xx += cnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* buf is always NULL except when in monochrome mode, so in this case
diff -u -p a/video/console/sticore.c b/video/console/sticore.c
--- a/video/console/sticore.c
+++ b/video/console/sticore.c
@@ -248,11 +248,22 @@ static void __devinit sti_rom_copy(unsig
 		base += 4;
 		dest += 4;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		count--;
 		*(u8 *)dest = gsc_readb(base);
 		base++;
 		dest++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sti_flush(dest_start, (unsigned long)dest);
@@ -603,6 +614,11 @@ sti_cook_fonts(struct sti_cooked_rom *co
 	font_start = raw_font;
 	cooked_font->raw = raw_font;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (raw_font->next_font) {
 		raw_font = ((void *)font_start) + (raw_font->next_font);
 
@@ -613,6 +629,12 @@ sti_cook_fonts(struct sti_cooked_rom *co
 		cooked_font = cooked_font->next_font;
 
 		cooked_font->raw = raw_font;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	cooked_font->next_font = NULL;
@@ -660,11 +682,22 @@ sti_bmode_rom_copy(unsigned long base, u
 {
 	unsigned long dest_start = (unsigned long) dest;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		count--;
 		*(u8 *)dest = gsc_readl(base);
 		base += 4;
 		dest++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sti_flush(dest_start, (unsigned long)dest);
@@ -698,9 +731,20 @@ sti_get_bmode_rom (unsigned long address
 		raw_font = ((void *)raw) + raw->font_start;
 		font_start = raw_font;
 		
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (raw_font->next_font) {
 			BMODE_RELOCATE (raw_font->next_font);
 			raw_font = ((void *)font_start) + raw_font->next_font;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return raw;
diff -u -p a/video/console/bitblit.c b/video/console/bitblit.c
--- a/video/console/bitblit.c
+++ b/video/console/bitblit.c
@@ -167,7 +167,12 @@ static void bit_putcs(struct vc_data *vc
 			return;
 	}
 
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (count) {
 		if (count > maxcnt)
 			cnt = maxcnt;
 		else
@@ -192,6 +197,12 @@ static void bit_putcs(struct vc_data *vc
 		image.dx += cnt * vc->vc_font.width;
 		count -= cnt;
 		s += cnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* buf is always NULL except when in monochrome mode, so in this case
diff -u -p a/video/geode/gx1fb_core.c b/video/geode/gx1fb_core.c
--- a/video/geode/gx1fb_core.c
+++ b/video/geode/gx1fb_core.c
@@ -412,6 +412,11 @@ static void __init gx1fb_setup(char *opt
 	if (!options || !*options)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -424,6 +429,12 @@ static void __init gx1fb_setup(char *opt
 			strlcpy(panel_option, this_opt + 6, sizeof(panel_option));
 		else
 			strlcpy(mode_option, this_opt, sizeof(mode_option));
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 #endif
diff -u -p a/video/omap2/dss/dsi.c b/video/omap2/dss/dsi.c
--- a/video/omap2/dss/dsi.c
+++ b/video/omap2/dss/dsi.c
@@ -415,9 +415,20 @@ static inline int wait_for_bit_change(st
 {
 	int t = 100000;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (REG_GET(dsidev, idx, bitnum, bitnum) != value) {
 		if (--t == 0)
 			return !value;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return value;
@@ -1252,13 +1263,24 @@ static int dsi_pll_power(struct platform
 	REG_FLD_MOD(dsidev, DSI_CLK_CTRL, state, 31, 30);
 
 	/* PLL_PWR_STATUS */
-	while (FLD_GET(dsi_read_reg(dsidev, DSI_CLK_CTRL), 29, 28) != state) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (FLD_GET(dsi_read_reg(dsidev, DSI_CLK_CTRL), 29, 28) != state) {
 		if (++t > 1000) {
 			DSSERR("Failed to set DSI PLL power mode to %d\n",
 					state);
 			return -ENODEV;
 		}
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -2016,7 +2038,12 @@ static int dsi_cio_power(struct platform
 	REG_FLD_MOD(dsidev, DSI_COMPLEXIO_CFG1, state, 28, 27);
 
 	/* PWR_STATUS */
-	while (FLD_GET(dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1),
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (FLD_GET(dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1),
 			26, 25) != state) {
 		if (++t > 1000) {
 			DSSERR("failed to set complexio power state to "
@@ -2024,6 +2051,12 @@ static int dsi_cio_power(struct platform
 			return -ENODEV;
 		}
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -2818,6 +2851,11 @@ EXPORT_SYMBOL(omapdss_dsi_vc_enable_hs);
 
 static void dsi_vc_flush_long_data(struct platform_device *dsidev, int channel)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {
 		u32 val;
 		val = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));
@@ -2826,6 +2864,12 @@ static void dsi_vc_flush_long_data(struc
 				(val >> 8) & 0xff,
 				(val >> 16) & 0xff,
 				(val >> 24) & 0xff);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2870,6 +2914,11 @@ static u16 dsi_vc_flush_receive_data(str
 		int channel)
 {
 	/* RX_FIFO_NOT_EMPTY */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {
 		u32 val;
 		u8 dt;
@@ -2892,6 +2941,12 @@ static u16 dsi_vc_flush_receive_data(str
 		} else {
 			DSSERR("\tunknown datatype 0x%02x\n", dt);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/video/omap2/dss/dss.c b/video/omap2/dss/dss.c
--- a/video/omap2/dss/dss.c
+++ b/video/omap2/dss/dss.c
@@ -172,11 +172,22 @@ int dss_sdi_enable(void)
 
 	/* Waiting for PLL lock request to complete */
 	timeout = jiffies + msecs_to_jiffies(500);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dss_read_reg(DSS_SDI_STATUS) & (1 << 6)) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("PLL lock request timed out\n");
 			goto err1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Clearing PLL_GO bit */
@@ -184,22 +195,44 @@ int dss_sdi_enable(void)
 
 	/* Waiting for PLL to lock */
 	timeout = jiffies + msecs_to_jiffies(500);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 5))) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("PLL lock timed out\n");
 			goto err1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	dispc_lcd_enable_signal(1);
 
 	/* Waiting for SDI reset to complete */
 	timeout = jiffies + msecs_to_jiffies(500);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 2))) {
 		if (time_after_eq(jiffies, timeout)) {
 			DSSERR("SDI reset timed out\n");
 			goto err2;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/omap2/dss/overlay.c b/video/omap2/dss/overlay.c
--- a/video/omap2/dss/overlay.c
+++ b/video/omap2/dss/overlay.c
@@ -808,13 +808,24 @@ void dss_uninit_overlays(struct platform
 {
 	struct omap_overlay *ovl;
 
-	while (!list_empty(&overlay_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&overlay_list)) {
 		ovl = list_first_entry(&overlay_list,
 				struct omap_overlay, list);
 		list_del(&ovl->list);
 		kobject_del(&ovl->kobj);
 		kobject_put(&ovl->kobj);
 		kfree(ovl);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	num_overlays = 0;
diff -u -p a/video/omap2/dss/ti_hdmi_4xxx_ip.c b/video/omap2/dss/ti_hdmi_4xxx_ip.c
--- a/video/omap2/dss/ti_hdmi_4xxx_ip.c
+++ b/video/omap2/dss/ti_hdmi_4xxx_ip.c
@@ -75,10 +75,21 @@ static inline int hdmi_wait_for_bit_chan
 				int b2, int b1, u32 val)
 {
 	u32 t = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (val != REG_GET(base_addr, idx, b2, b1)) {
 		udelay(1);
 		if (t++ > 10000)
 			return !val;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return val;
 }
diff -u -p a/video/omap2/dss/manager.c b/video/omap2/dss/manager.c
--- a/video/omap2/dss/manager.c
+++ b/video/omap2/dss/manager.c
@@ -1611,13 +1611,24 @@ void dss_uninit_overlay_managers(struct
 {
 	struct omap_overlay_manager *mgr;
 
-	while (!list_empty(&manager_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&manager_list)) {
 		mgr = list_first_entry(&manager_list,
 				struct omap_overlay_manager, list);
 		list_del(&mgr->list);
 		kobject_del(&mgr->kobj);
 		kobject_put(&mgr->kobj);
 		kfree(mgr);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	num_managers = 0;
diff -u -p a/video/omap2/dss/venc.c b/video/omap2/dss/venc.c
--- a/video/omap2/dss/venc.c
+++ b/video/omap2/dss/venc.c
@@ -370,12 +370,23 @@ static void venc_reset(void)
 	int t = 1000;
 
 	venc_write_reg(VENC_F_CONTROL, 1<<8);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (venc_read_reg(VENC_F_CONTROL) & (1<<8)) {
 		if (--t == 0) {
 			DSSERR("Failed to reset venc\n");
 			return;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 #ifdef CONFIG_OMAP2_DSS_SLEEP_AFTER_VENC_RESET
 	/* the magical sleep that makes things work */
diff -u -p a/video/omap2/displays/panel-picodlp.c b/video/omap2/displays/panel-picodlp.c
--- a/video/omap2/displays/panel-picodlp.c
+++ b/video/omap2/displays/panel-picodlp.c
@@ -357,13 +357,24 @@ static int picodlp_panel_power_on(struct
 	msleep(1);
 	gpio_set_value(picodlp_pdata->pwrgood_gpio, 1);
 
-	while (!gpio_get_value(picodlp_pdata->emu_done_gpio)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!gpio_get_value(picodlp_pdata->emu_done_gpio)) {
 		if (!trial--) {
 			dev_err(&dssdev->dev, "emu_done signal not"
 						" going high\n");
 			return -ETIMEDOUT;
 		}
 		msleep(5);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/*
 	 * As per dpp2600 programming guide,
diff -u -p a/video/omap2/omapfb/omapfb-sysfs.c b/video/omap2/omapfb/omapfb-sysfs.c
--- a/video/omap2/omapfb/omapfb-sysfs.c
+++ b/video/omap2/omapfb/omapfb-sysfs.c
@@ -216,6 +216,11 @@ static ssize_t store_overlays(struct dev
 		char *p = (char *)buf;
 		int ovlnum;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (p < buf + len) {
 			int found;
 			if (num_ovls == OMAPFB_MAX_OVL_PER_FB) {
@@ -241,6 +246,12 @@ static ssize_t store_overlays(struct dev
 				ovls[num_ovls++] = fbdev->overlays[ovlnum];
 
 			p++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -375,6 +386,11 @@ static ssize_t store_overlays_rotate(str
 	if (len > 0) {
 		char *p = (char *)buf;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (p < buf + len) {
 			int rot;
 
@@ -395,6 +411,12 @@ static ssize_t store_overlays_rotate(str
 			rotation[num_ovls++] = rot;
 
 			p++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/video/acornfb.c b/video/acornfb.c
--- a/video/acornfb.c
+++ b/video/acornfb.c
@@ -1196,6 +1196,11 @@ free_unused_pages(unsigned int virtual_s
 	virtual_start = PAGE_ALIGN(virtual_start);
 	virtual_end = PAGE_ALIGN(virtual_end);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (virtual_start < virtual_end) {
 		struct page *page;
 
@@ -1211,6 +1216,12 @@ free_unused_pages(unsigned int virtual_s
 
 		virtual_start += PAGE_SIZE;
 		mb_freed += PAGE_SIZE / 1024;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	printk("acornfb: freed %dK memory\n", mb_freed);
diff -u -p a/video/mb862xx/mb862xxfb_accel.c b/video/mb862xx/mb862xxfb_accel.c
--- a/video/mb862xx/mb862xxfb_accel.c
+++ b/video/mb862xx/mb862xxfb_accel.c
@@ -32,6 +32,11 @@ static void mb862xxfb_write_fifo(u32 cou
 	static u32 free;
 
 	u32 total = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (total < count) {
 		if (free) {
 			outreg(geo, GDC_GEO_REG_INPUT_FIFO, data[total]);
@@ -40,6 +45,12 @@ static void mb862xxfb_write_fifo(u32 cou
 		} else {
 			free = (u32) inreg(draw, GDC_REG_FIFO_COUNT);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -102,6 +113,11 @@ static void mb86290fb_imageblit1(u32 *cm
 	cmd[7] = (dy << 16) | dx;
 	cmd[8] = (height << 16) | width;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < height) {
 		memcpy(&cmd[9 + i * step], line, step << 2);
 #ifdef __LITTLE_ENDIAN
@@ -114,6 +130,12 @@ static void mb86290fb_imageblit1(u32 *cm
 #endif
 		line += bytes;
 		i++;
+		if (_cur < timeout) {
+				    rdstcll(_cur);
+		}
+		else {
+				    break;
+		}
 	}
 }
 
@@ -139,6 +161,11 @@ static void mb86290fb_imageblit8(u32 *cm
 	line = ptr = image->data;
 	bytes = image->width;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < height) {
 		ptr = line;
 		for (j = 0; j < step; j++) {
@@ -153,6 +180,12 @@ static void mb86290fb_imageblit8(u32 *cm
 
 		line += bytes;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -178,10 +211,21 @@ static void mb86290fb_imageblit16(u32 *c
 	cmd[1] = (dy << 16) | dx;
 	cmd[2] = (height << 16) | width;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < height) {
 		memcpy(&cmd[3 + i * step], line, step);
 		line += bytes;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/mb862xx/mb862xxfbdrv.c b/video/mb862xx/mb862xxfbdrv.c
--- a/video/mb862xx/mb862xxfbdrv.c
+++ b/video/mb862xx/mb862xxfbdrv.c
@@ -913,12 +913,23 @@ static int init_dram_ctrl(struct mb862xx
 	outreg(dram_ctrl, GC_DCTL_RSV0_STATES, GC_EVB_DCTL_RSV0_STATES);
 
 	/* DLL reset done? */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((inreg(dram_ctrl, GC_DCTL_RSV0_STATES) & GC_DCTL_STATES_MSK)) {
 		udelay(GC_DCTL_INIT_WAIT_INTERVAL);
 		if (i++ > GC_DCTL_INIT_WAIT_CNT) {
 			dev_err(par->dev, "VRAM init failed.\n");
 			return -EINVAL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	outreg(dram_ctrl, GC_DCTL_MODE_ADD, GC_EVB_DCTL_MODE_ADD_AFT_RST);
 	outreg(dram_ctrl, GC_DCTL_RSV0_STATES, GC_EVB_DCTL_RSV0_STATES_AFT_RST);
diff -u -p a/video/macfb.c b/video/macfb.c
--- a/video/macfb.c
+++ b/video/macfb.c
@@ -676,6 +676,11 @@ static int __init macfb_init(void)
 	 * code is really broken :-)
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ndev = nubus_find_type(NUBUS_CAT_DISPLAY,
 				       NUBUS_TYPE_VIDEO, ndev)))
 	{
@@ -708,6 +713,12 @@ static int __init macfb_init(void)
 			strcpy(macfb_fix.id, "Generic NuBus");
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* If it's not a NuBus card, it must be internal video */
diff -u -p a/video/fbmon.c b/video/fbmon.c
--- a/video/fbmon.c
+++ b/video/fbmon.c
@@ -1007,6 +1007,11 @@ void fb_edid_add_monspecs(unsigned char
 
 	DPRINTK("  Short Video Descriptors\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pos < edid[2]) {
 		u8 len = edid[pos] & 0x1f, type = (edid[pos] >> 5) & 7;
 		pr_debug("Data block %u of %u bytes\n", type, len);
@@ -1018,6 +1023,12 @@ void fb_edid_add_monspecs(unsigned char
 					 edid[pos + i] & 0x80 ? "" : "on-n", idx);
 			}
 		pos += len + 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	block = edid + edid[2];
diff -u -p a/video/pvr2fb.c b/video/pvr2fb.c
--- a/video/pvr2fb.c
+++ b/video/pvr2fb.c
@@ -1030,6 +1030,11 @@ static int __init pvr2fb_setup(char *opt
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -1046,6 +1051,12 @@ static int __init pvr2fb_setup(char *opt
 		} else {
 			mode_option = this_opt;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (*cable_arg)
diff -u -p a/video/tridentfb.c b/video/tridentfb.c
--- a/video/tridentfb.c
+++ b/video/tridentfb.c
@@ -289,6 +289,11 @@ static void xp_wait_engine(struct triden
 	int count = 0;
 	int timeout = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (t_inb(par, STATUS) & 0x80) {
 		count++;
 		if (count == 10000000) {
@@ -302,6 +307,12 @@ static void xp_wait_engine(struct triden
 			}
 		}
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/broadsheetfb.c b/video/broadsheetfb.c
--- a/video/broadsheetfb.c
+++ b/video/broadsheetfb.c
@@ -693,7 +693,12 @@ static int broadsheet_write_spiflash(str
 		break;
 	}
 
-	while (bytecount) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (bytecount) {
 		cur_addr = wfm_addr + offset;
 		maxlen = roundup(cur_addr, sector_size) - cur_addr;
 		writecount = min(bytecount, maxlen);
@@ -705,6 +710,12 @@ static int broadsheet_write_spiflash(str
 
 		offset += writecount;
 		bytecount -= writecount;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/tmiofb.c b/video/tmiofb.c
--- a/video/tmiofb.c
+++ b/video/tmiofb.c
@@ -365,7 +365,12 @@ tmiofb_acc_wait(struct fb_info *info, un
 	 */
 	if (irqs_disabled() || par->use_polling) {
 		int i = 0;
-		while (tmio_ioread16(par->lcr + LCR_CCS) > ccs) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (tmio_ioread16(par->lcr + LCR_CCS) > ccs) {
 			udelay(1);
 			i++;
 			if (i > 10000) {
@@ -374,6 +379,12 @@ tmiofb_acc_wait(struct fb_info *info, un
 				return -ETIMEDOUT;
 			}
 			tmiofb_irq(-1, info);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		if (!wait_event_interruptible_timeout(par->wait_acc,
@@ -421,6 +432,11 @@ static int tmiofb_sync(struct fb_info *f
 
 	ret = tmiofb_acc_wait(fbi, 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmio_ioread16(par->lcr + LCR_BBES) & 2) { /* blit active */
 		udelay(1);
 		i++ ;
@@ -428,6 +444,12 @@ static int tmiofb_sync(struct fb_info *f
 			printk(KERN_ERR "timeout waiting for blit to end!\n");
 			return -ETIMEDOUT;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
diff -u -p a/video/tgafb.c b/video/tgafb.c
--- a/video/tgafb.c
+++ b/video/tgafb.c
@@ -1573,6 +1573,11 @@ tgafb_setup(char *arg)
 	char *this_opt;
 
 	if (arg && *arg) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((this_opt = strsep(&arg, ","))) {
 			if (!*this_opt)
 				continue;
@@ -1582,6 +1587,12 @@ tgafb_setup(char *arg)
 				printk(KERN_ERR
 				       "tgafb: unknown parameter %s\n",
 				       this_opt);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 
diff -u -p a/video/sstfb.c b/video/sstfb.c
--- a/video/sstfb.c
+++ b/video/sstfb.c
@@ -218,6 +218,11 @@ static int __sst_wait_idle(u8 __iomem *v
 
 	/* if (doFBINOP) __sst_write(vbase, NOPCMD, 0); */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(1) {
 		if (__sst_read(vbase, STATUS) & STATUS_FBI_BUSY) {
 			f_dddprintk("status: busy\n");
@@ -231,6 +236,12 @@ static int __sst_wait_idle(u8 __iomem *v
 		}
 		if (count >= 5) return 1;
 /* XXX  do something to avoid hanging the machine if the voodoo is out */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/udlfb.c b/video/udlfb.c
--- a/video/udlfb.c
+++ b/video/udlfb.c
@@ -428,6 +428,11 @@ static void dlfb_compress_hline(
 	uint8_t *cmd = *command_buffer_ptr;
 	const int bpp = 2;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((pixel_end > pixel) &&
 	       (cmd_buffer_end - MIN_RLX_CMD_BYTES > cmd)) {
 		uint8_t *raw_pixels_count_byte = 0;
@@ -455,6 +460,11 @@ static void dlfb_compress_hline(
 
 		prefetch_range((void *) pixel, (cmd_pixel_end - pixel) * bpp);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (pixel < cmd_pixel_end) {
 			const uint16_t * const repeating_pixel = pixel;
 
@@ -468,9 +478,20 @@ static void dlfb_compress_hline(
 				*raw_pixels_count_byte = ((repeating_pixel -
 						raw_pixel_start) + 1) & 0xFF;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while ((pixel < cmd_pixel_end)
 				       && (*pixel == *repeating_pixel)) {
 					pixel++;
+					if (_cur < timeout) {
+									rdstcll(_cur);
+					}
+					else {
+									break;
+					}
 				}
 
 				/* immediately after raw data is repeat byte */
@@ -480,6 +501,12 @@ static void dlfb_compress_hline(
 				raw_pixel_start = pixel;
 				raw_pixels_count_byte = cmd++;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (pixel > raw_pixel_start) {
@@ -489,6 +516,12 @@ static void dlfb_compress_hline(
 
 		*cmd_pixels_count_byte = (pixel - cmd_pixel_start) & 0xFF;
 		dev_addr += (pixel - cmd_pixel_start) * bpp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (cmd_buffer_end <= MIN_RLX_CMD_BYTES + cmd) {
@@ -544,7 +577,12 @@ static int dlfb_render_hline(struct dlfb
 		       byte_width);
 	}
 
-	while (next_pixel < line_end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (next_pixel < line_end) {
 
 		dlfb_compress_hline((const uint16_t **) &next_pixel,
 			     (const uint16_t *) line_end, &dev_addr,
@@ -562,6 +600,12 @@ static int dlfb_render_hline(struct dlfb
 			cmd = urb->transfer_buffer;
 			cmd_end = &cmd[urb->transfer_buffer_length];
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	*urb_buf_ptr = cmd;
@@ -1533,6 +1577,11 @@ static int dlfb_parse_vendor_descriptor(
 		desc_end = desc + total_len;
 		desc += 5; /* the fixed header we've already parsed */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (desc < desc_end) {
 			u8 length;
 			u16 key;
@@ -1555,6 +1604,12 @@ static int dlfb_parse_vendor_descriptor(
 				break;
 			}
 			desc += length;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		pr_info("vendor descriptor not available (%d)\n", total_len);
diff -u -p a/video/matrox/matroxfb_crtc2.c b/video/matrox/matroxfb_crtc2.c
--- a/video/matrox/matroxfb_crtc2.c
+++ b/video/matrox/matroxfb_crtc2.c
@@ -141,8 +141,19 @@ static void matroxfb_dh_restore(struct m
 			unsigned int nl;
 			unsigned int lastl = 0;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while ((nl = mga_inl(0x3C48) & 0xFFF) >= lastl) {
 				lastl = nl;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
diff -u -p a/video/matrox/matroxfb_base.c b/video/matrox/matroxfb_base.c
--- a/video/matrox/matroxfb_base.c
+++ b/video/matrox/matroxfb_base.c
@@ -591,6 +591,11 @@ static int matroxfb_decode_var(const str
 			unsigned int m2 = PAGE_SIZE;	/* or 128 if you do not need PAGE ALIGNED address */
 			unsigned int max_yres;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (m1) {
 				int t;
 
@@ -598,6 +603,12 @@ static int matroxfb_decode_var(const str
 				t = m1;
 				m1 = m2;
 				m2 = t;
+				if (_cur < timeout) {
+				      rdstcll(_cur);
+				}
+				else {
+				      break;
+				}
 			}
 			m2 = linelen * PAGE_SIZE / m2;
 			*ydstorg = m2 = 0x400000 % m2;
diff -u -p a/video/matrox/g450_pll.c b/video/matrox/g450_pll.c
--- a/video/matrox/g450_pll.c
+++ b/video/matrox/g450_pll.c
@@ -121,9 +121,20 @@ static unsigned int g450_firstpll(const
 
 		p = 3;
 		tvco = g450_f2vco(p, fout);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (p && (tvco > vcomax)) {
 			p--;
 			tvco >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (tvco < pi->vcomin) {
 			tvco = pi->vcomin;
@@ -275,6 +286,11 @@ static inline unsigned int g450_findwork
 			}
 			*sptr = mnp;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sptr >= sarray) {
 			unsigned int mnp = *sptr--;
 		
@@ -291,6 +307,12 @@ static inline unsigned int g450_findwork
 				mnpfound = mnp;
 				found = 1;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	g450_setpll(minfo, mnpfound, pll);
diff -u -p a/video/matrox/matroxfb_misc.c b/video/matrox/matroxfb_misc.c
--- a/video/matrox/matroxfb_misc.c
+++ b/video/matrox/matroxfb_misc.c
@@ -244,12 +244,23 @@ int matroxfb_vgaHWinit(struct matrox_fb_
 	/* do it for 4bpp (because of (4bpp >> 1(interleaved))/4 == 0) */
 	/* using 16 or more pixels per unit can save us */
 	divider = minfo->curr.final_bppShift;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (divider & 3) {
 		hd >>= 1;
 		hs >>= 1;
 		he >>= 1;
 		ht >>= 1;
 		divider <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	divider = divider / 4;
 	/* divider can be from 1 to 8 */
diff -u -p a/video/svgalib.c b/video/svgalib.c
--- a/video/svgalib.c
+++ b/video/svgalib.c
@@ -27,12 +27,23 @@ void svga_wcrt_multi(void __iomem *regba
 	while (regset->regnum != VGA_REGSET_END_VAL) {
 		regval = vga_rcrt(regbase, regset->regnum);
 		bitnum = regset->lowbit;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bitnum <= regset->highbit) {
 			bitval = 1 << bitnum;
 			regval = regval & ~bitval;
 			if (value & 1) regval = regval | bitval;
 			bitnum ++;
 			value = value >> 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		vga_wcrt(regbase, regset->regnum, regval);
 		regset ++;
@@ -47,12 +58,23 @@ void svga_wseq_multi(void __iomem *regba
 	while (regset->regnum != VGA_REGSET_END_VAL) {
 		regval = vga_rseq(regbase, regset->regnum);
 		bitnum = regset->lowbit;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (bitnum <= regset->highbit) {
 			bitval = 1 << bitnum;
 			regval = regval & ~bitval;
 			if (value & 1) regval = regval | bitval;
 			bitnum ++;
 			value = value >> 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		vga_wseq(regbase, regset->regnum, regval);
 		regset ++;
@@ -395,9 +417,20 @@ int svga_compute_pll(const struct svga_p
 	/* It is usually better to have greater VCO clock
 	   because of better frequency stability.
 	   So first try r_max, then r smaller. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ar > pll->r_min) && (f_vco > pll->f_vco_max)) {
 		ar--;
 		f_vco = f_vco >> 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* VCO bounds check */
@@ -412,6 +445,11 @@ int svga_compute_pll(const struct svga_p
 	am = pll->m_min;
 	an = pll->n_min;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((am <= pll->m_max) && (an <= pll->n_max)) {
 		f_current = (pll->f_base * am) / an;
 		delta_current = abs_diff (f_current, f_vco);
@@ -427,6 +465,12 @@ int svga_compute_pll(const struct svga_p
 		} else {
 			an ++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	f_current = (pll->f_base * *m) / *n;
diff -u -p a/video/arcfb.c b/video/arcfb.c
--- a/video/arcfb.c
+++ b/video/arcfb.c
@@ -266,6 +266,11 @@ static void arcfb_lcd_update_page(struct
 
 	bitmask=1;
 	rightshift=0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (left <= right) {
 		val = 0;
 		for (i = 0; i < 8; i++) {
@@ -287,6 +292,12 @@ static void arcfb_lcd_update_page(struct
 			bitmask <<= 1;
 			rightshift++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/pxa3xx-gcu.c b/video/pxa3xx-gcu.c
--- a/video/pxa3xx-gcu.c
+++ b/video/pxa3xx-gcu.c
@@ -202,11 +202,22 @@ flush_running(struct pxa3xx_gcu_priv *pr
 	struct pxa3xx_gcu_batch *running = priv->running;
 	struct pxa3xx_gcu_batch *next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (running) {
 		next = running->next;
 		running->next = priv->free;
 		priv->free = running;
 		running = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	priv->running = NULL;
@@ -225,10 +236,21 @@ run_ready(struct pxa3xx_gcu_priv *priv)
 
 	shared->buffer[num++] = 0x05000000;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ready) {
 		shared->buffer[num++] = 0x00000001;
 		shared->buffer[num++] = ready->phys;
 		ready = ready->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	shared->buffer[num++] = 0x05000000;
@@ -563,7 +585,12 @@ free_buffers(struct platform_device *dev
 {
 	struct pxa3xx_gcu_batch *next, *buffer = priv->free;
 
-	while (buffer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (buffer) {
 		next = buffer->next;
 
 		dma_free_coherent(&dev->dev, PXA3XX_GCU_BATCH_WORDS * 4,
@@ -572,6 +599,12 @@ free_buffers(struct platform_device *dev
 		kfree(buffer);
 
 		buffer = next;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	priv->free = NULL;
diff -u -p a/video/atafb.c b/video/atafb.c
--- a/video/atafb.c
+++ b/video/atafb.c
@@ -572,10 +572,21 @@ static int get_video_mode(char *vname)
 		name = *name_list++;
 		if (!name || !*name)
 			break;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (*name) {
 			if (!strcmp(vname, *name))
 				return i + 1;
 			name++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 0;
diff -u -p a/video/vermilion/vermilion.c b/video/vermilion/vermilion.c
--- a/video/vermilion/vermilion.c
+++ b/video/vermilion/vermilion.c
@@ -1106,6 +1106,11 @@ int vmlfb_register_subsys(struct vml_sys
 	 */
 
 	list = global_no_mode.next;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (list != &global_no_mode) {
 		list_del_init(list);
 		entry = list_entry(list, struct vml_info, head);
@@ -1144,6 +1149,12 @@ int vmlfb_register_subsys(struct vml_sys
 		}
 		vmlfb_blank_locked(entry);
 		list = global_no_mode.next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&vml_mutex);
 
diff -u -p a/video/pm2fb.c b/video/pm2fb.c
--- a/video/pm2fb.c
+++ b/video/pm2fb.c
@@ -1352,9 +1352,20 @@ static int pm2vfb_cursor(struct fb_info
 			}
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (pos < (1024 + PM2VI_RD_CURSOR_PATTERN)) {
 			pm2_WR(par, PM2VR_RD_INDEX_HIGH, pos >> 8);
 			pm2v_RDAC_WR(par, pos++, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		pm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);
diff -u -p a/video/intelfb/intelfbdrv.c b/video/intelfb/intelfbdrv.c
--- a/video/intelfb/intelfbdrv.c
+++ b/video/intelfb/intelfbdrv.c
@@ -351,6 +351,11 @@ static int __init intelfb_setup(char *op
 	 *    video=intelfb:1024x768-16@75,accel=0
 	 */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -370,6 +375,12 @@ static int __init intelfb_setup(char *op
 			mode = get_opt_string(this_opt, "mode=");
 		else
 			mode = this_opt;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
@@ -803,6 +814,11 @@ static int __devinit intelfb_pci_registe
 		dinfo->fixed_mode = 1;
 		WRN_MSG("Non-CRT device is enabled ( ");
 		i = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (dvo) {
 			if (dvo & 1) {
 				s = intelfbhw_dvo_to_string(1 << i);
@@ -811,6 +827,12 @@ static int __devinit intelfb_pci_registe
 			}
 			dvo >>= 1;
 			++i;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		printk(").  Disabling mode switching.\n");
 	}
diff -u -p a/video/ps3fb.c b/video/ps3fb.c
--- a/video/ps3fb.c
+++ b/video/ps3fb.c
@@ -898,6 +898,11 @@ static int ps3fbd(void *arg)
 	struct fb_info *info = arg;
 
 	set_freezable();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		try_to_freeze();
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -908,6 +913,12 @@ static int ps3fbd(void *arg)
 			console_unlock();
 		}
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/video/smscufx.c b/video/smscufx.c
--- a/video/smscufx.c
+++ b/video/smscufx.c
@@ -860,6 +860,11 @@ int ufx_handle_damage(struct ufx_data *d
 	if (!atomic_read(&dev->usb_active))
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start_line < height) {
 		struct urb *urb = ufx_get_urb(dev);
 		if (!urb) {
@@ -885,6 +890,12 @@ int ufx_handle_damage(struct ufx_data *d
 		check_warn_return(status, "Error submitting URB");
 
 		start_line += urb_lines;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/sh_mobile_meram.c b/video/sh_mobile_meram.c
--- a/video/sh_mobile_meram.c
+++ b/video/sh_mobile_meram.c
@@ -225,10 +225,21 @@ static inline void meram_unmark(struct s
 	pattern = MERAM_CACHE_SET(icb->meram_offset, icb->meram_size);
 	for (i = 0; i < priv->used_meram_cache_regions; i++) {
 		if (priv->used_meram_cache[i] == pattern) {
-			while (i < priv->used_meram_cache_regions - 1) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (i < priv->used_meram_cache_regions - 1) {
 				priv->used_meram_cache[i] =
 					priv->used_meram_cache[i + 1] ;
 				i++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			priv->used_meram_cache[i] = 0;
 			priv->used_meram_cache_regions--;
diff -u -p a/vhost/net.c b/vhost/net.c
--- a/vhost/net.c
+++ b/vhost/net.c
@@ -76,6 +76,11 @@ static int move_iovec_hdr(struct iovec *
 	int seg = 0;
 	size_t size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len && seg < iov_count) {
 		size = min(from->iov_len, len);
 		to->iov_base = from->iov_base;
@@ -86,6 +91,12 @@ static int move_iovec_hdr(struct iovec *
 		++from;
 		++to;
 		++seg;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return seg;
 }
@@ -96,6 +107,11 @@ static void copy_iovec_hdr(const struct
 	int seg = 0;
 	size_t size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len && seg < iovcount) {
 		size = min(from->iov_len, len);
 		to->iov_base = from->iov_base;
@@ -104,6 +120,12 @@ static void copy_iovec_hdr(const struct
 		++from;
 		++to;
 		++seg;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/vlynq/vlynq.c b/vlynq/vlynq.c
--- a/vlynq/vlynq.c
+++ b/vlynq/vlynq.c
@@ -224,11 +224,22 @@ static irqreturn_t vlynq_irq(int irq, vo
 	if (unlikely(!status))
 		spurious_interrupt();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status) {
 		if (status & 1)
 			do_IRQ(dev->irq_start + virq);
 		status >>= 1;
 		virq++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return IRQ_HANDLED;
@@ -326,7 +337,12 @@ static int vlynq_device_match(struct dev
 	struct vlynq_driver *vdrv = to_vlynq_driver(drv);
 	struct vlynq_device_id *ids = vdrv->id_table;
 
-	while (ids->id) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (ids->id) {
 		if (ids->id == vdev->dev_id) {
 			vdev->divisor = ids->divisor;
 			vlynq_set_drvdata(vdev, ids);
@@ -337,6 +353,12 @@ static int vlynq_device_match(struct dev
 		printk(KERN_DEBUG "Not using the %08x VLYNQ device's driver"
 			" for VLYNQ device: %08x\n", ids->id, vdev->dev_id);
 		ids++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return 0;
 }
diff -u -p a/zorro/zorro.c b/zorro/zorro.c
--- a/zorro/zorro.c
+++ b/zorro/zorro.c
@@ -96,13 +96,24 @@ static void __init mark_region(unsigned
 		return;
 	start = start < Z2RAM_START ? 0x00000000 : start-Z2RAM_START;
 	end = end > Z2RAM_END ? Z2RAM_SIZE : end-Z2RAM_START;
-	while (start < end) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (start < end) {
 		u32 chunk = start>>Z2RAM_CHUNKSHIFT;
 		if (flag)
 			set_bit(chunk, zorro_unused_z2ram);
 		else
 			clear_bit(chunk, zorro_unused_z2ram);
 		start += Z2RAM_CHUNKSIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/zorro/zorro-driver.c b/zorro/zorro-driver.c
--- a/zorro/zorro-driver.c
+++ b/zorro/zorro-driver.c
@@ -30,10 +30,21 @@ const struct zorro_device_id *
 zorro_match_device(const struct zorro_device_id *ids,
 		   const struct zorro_dev *z)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ids->id) {
 		if (ids->id == ZORRO_WILDCARD || ids->id == z->id)
 			return ids;
 		ids++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
@@ -132,10 +143,21 @@ static int zorro_bus_match(struct device
 	if (!ids)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ids->id) {
 		if (ids->id == ZORRO_WILDCARD || ids->id == z->id)
 			return 1;
 		ids++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/zorro/gen-devlist.c b/zorro/gen-devlist.c
--- a/zorro/gen-devlist.c
+++ b/zorro/gen-devlist.c
@@ -16,12 +16,23 @@
 static void
 pq(FILE *f, const char *c)
 {
-	while (*c) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*c) {
 		if (*c == '"')
 			fprintf(f, "\\\"");
 		else
 			fputc(*c, f);
 		c++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -41,6 +52,11 @@ main(void)
 		return 1;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fgets(line, sizeof(line)-1, stdin)) {
 		lino++;
 		if ((c = strchr(line, '\n')))
@@ -94,6 +110,12 @@ main(void)
 			fprintf(stderr, "Line %d: Syntax error in mode %d: %s\n", lino, mode, line);
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	fputs("ENDMANUF()\n\
 \n\
diff -u -p a/connector/cn_queue.c b/connector/cn_queue.c
--- a/connector/cn_queue.c
+++ b/connector/cn_queue.c
@@ -148,10 +148,21 @@ void cn_queue_free_dev(struct cn_queue_d
 		list_del(&cbq->callback_entry);
 	spin_unlock_bh(&dev->queue_lock);
 
-	while (atomic_read(&dev->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&dev->refcnt)) {
 		printk(KERN_INFO "Waiting for %s to become free: refcnt=%d.\n",
 		       dev->name, atomic_read(&dev->refcnt));
 		msleep(1000);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	kfree(dev);
diff -u -p a/message/i2o/iop.c b/message/i2o/iop.c
--- a/message/i2o/iop.c
+++ b/message/i2o/iop.c
@@ -65,13 +65,24 @@ struct i2o_message *i2o_msg_get_wait(str
 	unsigned long timeout = jiffies + wait * HZ;
 	struct i2o_message *msg;
 
-	while (IS_ERR(msg = i2o_msg_get(c))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (IS_ERR(msg = i2o_msg_get(c))) {
 		if (time_after(jiffies, timeout)) {
 			osm_debug("%s: Timeout waiting for message frame.\n",
 				  c->name);
 			return ERR_PTR(-ETIMEDOUT);
 		}
 		schedule_timeout_uninterruptible(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return msg;
@@ -546,6 +557,11 @@ static int i2o_iop_reset(struct i2o_cont
 		osm_debug("%s: Reset in progress, waiting for reboot...\n",
 			  c->name);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (IS_ERR(msg = i2o_msg_get_wait(c, I2O_TIMEOUT_RESET))) {
 			if (time_after(jiffies, timeout)) {
 				osm_err("%s: IOP reset timeout.\n", c->name);
@@ -553,6 +569,12 @@ static int i2o_iop_reset(struct i2o_cont
 				goto exit;
 			}
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		i2o_msg_nop(c, msg);
 
diff -u -p a/message/i2o/i2o_proc.c b/message/i2o/i2o_proc.c
--- a/message/i2o/i2o_proc.c
+++ b/message/i2o/i2o_proc.c
@@ -1888,13 +1888,24 @@ static int i2o_proc_create_entries(struc
 {
 	struct proc_dir_entry *tmp;
 
-	while (i2o_pe->name) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i2o_pe->name) {
 		tmp = proc_create_data(i2o_pe->name, i2o_pe->mode, dir,
 				       i2o_pe->fops, data);
 		if (!tmp)
 			return -1;
 
 		i2o_pe++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1911,11 +1922,22 @@ static void i2o_proc_subdir_remove(struc
 {
 	struct proc_dir_entry *pe, *tmp;
 	pe = dir->subdir;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pe) {
 		tmp = pe->next;
 		i2o_proc_subdir_remove(pe);
 		remove_proc_entry(pe->name, dir);
 		pe = tmp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 };
 
@@ -2007,6 +2029,11 @@ static void i2o_proc_iop_remove(struct p
 	struct proc_dir_entry *pe, *tmp;
 
 	pe = dir->subdir;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pe) {
 		tmp = pe->next;
 		if (pe->data == c) {
@@ -2015,6 +2042,12 @@ static void i2o_proc_iop_remove(struct p
 		}
 		osm_debug("removing IOP /proc/i2o/%s\n", c->name);
 		pe = tmp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/message/fusion/mptbase.c b/message/fusion/mptbase.c
--- a/message/fusion/mptbase.c
+++ b/message/fusion/mptbase.c
@@ -3191,10 +3191,21 @@ GetIocFacts(MPT_ADAPTER *ioc, int sleepF
 		r = sz = facts->BlockSize;
 		vv = ((63 / (sz * 4)) + 1) & 0x03;
 		ioc->NB_for_64_byte_frame = vv;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ( sz )
 		{
 			shiftFactor++;
 			sz = sz >> 1;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		ioc->NBShiftFactor  = shiftFactor;
 		dinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT
@@ -3751,6 +3762,11 @@ mpt_downloadboot(MPT_ADAPTER *ioc, MpiFw
 	}
 
 	nextImage = pFwHeader->NextImageHeaderOffset;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nextImage) {
 		pExtImage = (MpiExtImageHeader_t *) ((char *)pFwHeader + nextImage);
 
@@ -3767,6 +3783,12 @@ mpt_downloadboot(MPT_ADAPTER *ioc, MpiFw
 			CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);
 		}
 		nextImage = pExtImage->NextImageHeaderOffset;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Write the IopResetVectorRegAddr */
diff -u -p a/message/fusion/mptctl.c b/message/fusion/mptctl.c
--- a/message/fusion/mptctl.c
+++ b/message/fusion/mptctl.c
@@ -1189,6 +1189,11 @@ kfree_sgl(MptSge_t *sgl, dma_addr_t sgl_
 		dir = PCI_DMA_FROMDEVICE;
 
 	nib = (sg->FlagsLength & 0xF0000000) >> 28;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (! (nib & 0x4)) { /* eob */
 		/* skip ignore/chain. */
 		if (nib == 0 || nib == 3) {
@@ -1208,6 +1213,12 @@ kfree_sgl(MptSge_t *sgl, dma_addr_t sgl_
 		sg++;
 		bl++;
 		nib = (le32_to_cpu(sg->FlagsLength) & 0xF0000000) >> 28;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* we're at eob! */
diff -u -p a/message/fusion/mptlan.c b/message/fusion/mptlan.c
--- a/message/fusion/mptlan.c
+++ b/message/fusion/mptlan.c
@@ -1170,7 +1170,12 @@ mpt_lan_post_receive_buckets(struct mpt_
 	max = (mpt_dev->req_sz - MPT_LAN_RECEIVE_POST_REQUEST_SIZE) /
 			(MPT_LAN_TRANSACTION32_SIZE + sizeof(SGESimple64_t));
 
-	while (buckets) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (buckets) {
 		mf = mpt_get_msg_frame(LanCtx, mpt_dev);
 		if (mf == NULL) {
 			printk (KERN_ERR "%s: Unable to alloc request frame\n",
@@ -1282,7 +1287,13 @@ mpt_lan_post_receive_buckets(struct mpt_
 		priv->total_posted += i;
 		buckets -= i;
 		atomic_add(i, &priv->buckets_out);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	dioprintk((KERN_INFO MYNAM "/%s: End_buckets = %u, priv->buckets_out = %u\n",
diff -u -p a/message/fusion/mptsas.c b/message/fusion/mptsas.c
--- a/message/fusion/mptsas.c
+++ b/message/fusion/mptsas.c
@@ -3878,6 +3878,11 @@ retry_page:
 			continue;
 		found_expander = 0;
 		handle = 0xFFFF;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!mptsas_sas_expander_pg0(ioc, &buffer,
 		    (MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<
 		     MPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle) &&
@@ -3889,6 +3894,12 @@ retry_page:
 				found_expander = 1;
 			}
 			kfree(buffer.phy_info);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (!found_expander) {
@@ -3912,7 +3923,12 @@ mptsas_probe_expanders(MPT_ADAPTER *ioc)
 	int i;
 
 	handle = 0xFFFF;
-	while (!mptsas_sas_expander_pg0(ioc, &buffer,
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!mptsas_sas_expander_pg0(ioc, &buffer,
 	    (MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<
 	     MPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle)) {
 
@@ -3950,6 +3966,12 @@ mptsas_probe_expanders(MPT_ADAPTER *ioc)
 		    "sas_addr (0x%llx)\n", ioc->name, port_info->num_phys,
 	    (unsigned long long)buffer.phy_info[0].identify.sas_address);
 		mptsas_expander_refresh(ioc, port_info);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -3961,6 +3983,11 @@ mptsas_probe_devices(MPT_ADAPTER *ioc)
 	struct mptsas_phyinfo *phy_info;
 
 	handle = 0xFFFF;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(mptsas_sas_device_pg0(ioc, &sas_device,
 	    MPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE, handle))) {
 
@@ -3987,6 +4014,12 @@ mptsas_probe_devices(MPT_ADAPTER *ioc)
 			continue;
 
 		mptsas_add_end_device(ioc, phy_info);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/hv/storvsc_drv.c b/staging/hv/storvsc_drv.c
--- a/staging/hv/storvsc_drv.c
+++ b/staging/hv/storvsc_drv.c
@@ -858,6 +858,11 @@ static unsigned int copy_from_bounce_buf
 			(unsigned long)kmap_atomic(sg_page((&bounce_sgl[j])),
 							KM_IRQ0);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (destlen) {
 			src = bounce_addr + bounce_sgl[j].offset;
 			srclen = bounce_sgl[j].length - bounce_sgl[j].offset;
@@ -884,6 +889,12 @@ static unsigned int copy_from_bounce_buf
 				/* unmap the last bounce that is < PAGE_SIZE */
 				kunmap_atomic((void *)bounce_addr, KM_IRQ0);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kunmap_atomic((void *)(dest_addr - orig_sgl[i].offset),
@@ -923,6 +934,11 @@ static unsigned int copy_to_bounce_buffe
 			(unsigned long)kmap_atomic(sg_page((&bounce_sgl[j])),
 						KM_IRQ0);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (srclen) {
 			/* assume bounce offset always == 0 */
 			dest = bounce_addr + bounce_sgl[j].length;
@@ -951,6 +967,12 @@ static unsigned int copy_to_bounce_buffe
 				/* unmap the last bounce that is < PAGE_SIZE */
 				kunmap_atomic((void *)bounce_addr, KM_IRQ0);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kunmap_atomic((void *)(src_addr - orig_sgl[i].offset), KM_IRQ0);
diff -u -p a/staging/hv/netvsc.c b/staging/hv/netvsc.c
--- a/staging/hv/netvsc.c
+++ b/staging/hv/netvsc.c
@@ -361,11 +361,22 @@ int netvsc_device_remove(struct hv_devic
 	spin_unlock_irqrestore(&device->channel->inbound_lock, flags);
 
 	/* Wait for all send completions */
-	while (atomic_read(&net_device->num_outstanding_sends)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&net_device->num_outstanding_sends)) {
 		dev_info(&device->device,
 			"waiting for %d requests to complete...\n",
 			atomic_read(&net_device->num_outstanding_sends));
 		udelay(100);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	netvsc_disconnect_vsp(net_device);
diff -u -p a/staging/bcm/Qos.c b/staging/bcm/Qos.c
--- a/staging/bcm/Qos.c
+++ b/staging/bcm/Qos.c
@@ -406,6 +406,11 @@ VOID flush_all_queues(PMINI_ADAPTER Adap
 		struct net_device_stats *netstats = &Adapter->dev->stats;
 
 		spin_lock_bh(&Adapter->PackInfo[iQIndex].SFQueueLock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(Adapter->PackInfo[iQIndex].FirstTxQueue)
 		{
 			PacketToDrop = Adapter->PackInfo[iQIndex].FirstTxQueue;
@@ -435,6 +440,12 @@ VOID flush_all_queues(PMINI_ADAPTER Adap
 					Adapter->PackInfo[iQIndex].uiDroppedCountBytes,
 					Adapter->PackInfo[iQIndex].uiDroppedCountPackets);
 			atomic_dec(&Adapter->TotalPacketCount);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		spin_unlock_bh(&Adapter->PackInfo[iQIndex].SFQueueLock);
 	}
diff -u -p a/staging/bcm/HandleControlPacket.c b/staging/bcm/HandleControlPacket.c
--- a/staging/bcm/HandleControlPacket.c
+++ b/staging/bcm/HandleControlPacket.c
@@ -151,6 +151,11 @@ int control_packet_handler  (PMINI_ADAPT
 	//struct timeval tv ;
 	//int *puiBuffer = NULL ;
 	BCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL, "Entering to make thread wait on control packet event!");
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(1)
 	{
 		wait_event_interruptible(Adapter->process_rx_cntrlpkt,
@@ -178,6 +183,11 @@ int control_packet_handler  (PMINI_ADAPT
 			continue;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(atomic_read(&Adapter->cntrlpktCnt))
 		{
 			spin_lock_irqsave(&Adapter->control_queue_lock, flags);
@@ -191,9 +201,21 @@ int control_packet_handler  (PMINI_ADAPT
 			spin_unlock_irqrestore (&Adapter->control_queue_lock, flags);
 		 	handle_rx_control_packet(Adapter, ctrl_packet);
 			atomic_dec(&Adapter->cntrlpktCnt);
+			if (_cur < timeout) {
+		 	rdstcll(_cur);
+			}
+			else {
+		 	break;
+			}
 		}
 
 		SetUpTargetDsxBuffers(Adapter);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return STATUS_SUCCESS;
 }
diff -u -p a/staging/bcm/nvm.c b/staging/bcm/nvm.c
--- a/staging/bcm/nvm.c
+++ b/staging/bcm/nvm.c
@@ -1196,6 +1196,11 @@ static INT BeceemFlashBulkWrite(
 	{
 		index = 0;
 		uiTemp = uiNumSectTobeRead ;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(uiTemp)
 		{
 			 if(IsOffsetWritable(Adapter, uiOffsetFromSectStart + index * Adapter->uiSectorSize ) == FALSE)
@@ -1207,6 +1212,12 @@ static INT BeceemFlashBulkWrite(
 			 }
 			 uiTemp = uiTemp - 1;
 			 index = index + 1 ;
+			 if (_cur < timeout) {
+				rdstcll(_cur);
+			 }
+			 else {
+				break;
+			 }
 		}
 	}
 	Adapter->SelectedChip = RESET_CHIP_SELECT;
@@ -1410,6 +1421,11 @@ static INT BeceemFlashBulkWriteStatus(
 	{
 		index = 0;
 		uiTemp = uiNumSectTobeRead ;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(uiTemp)
 		{
 			 if(IsOffsetWritable(Adapter,uiOffsetFromSectStart + index * Adapter->uiSectorSize ) == FALSE)
@@ -1421,10 +1437,21 @@ static INT BeceemFlashBulkWriteStatus(
 			 }
 			 uiTemp = uiTemp - 1;
 			 index = index + 1 ;
+			 if (_cur < timeout) {
+				rdstcll(_cur);
+			 }
+			 else {
+				break;
+			 }
 		}
 	}
 
 	Adapter->SelectedChip = RESET_CHIP_SELECT;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(uiNumSectTobeRead)
 	{
 		uiPartOffset = (uiSectAlignAddr & (FLASH_PART_SIZE - 1)) + GetFlashBaseAddr(Adapter);
@@ -1505,7 +1532,13 @@ static INT BeceemFlashBulkWriteStatus(
 		uiSectBoundary += Adapter->uiSectorSize;
 		uiOffsetFromSectStart += Adapter->uiSectorSize;
 		uiNumSectTobeRead--;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 //
 // Cleanup.
 //
@@ -1698,6 +1731,11 @@ static INT BeceemEEPROMReadBackandVerify
 	UINT uiData  	= 0;
 	UINT auiData[4] = {0};
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(uiNumBytes)
 	{
 		if(Adapter->device_removed )
@@ -1757,6 +1795,12 @@ static INT BeceemEEPROMReadBackandVerify
 			uiNumBytes = 0;
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -1972,6 +2016,11 @@ INT BeceemEEPROMBulkWrite(
 
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(uiBytesToCopy)
 	{
 		if(Adapter->device_removed)
@@ -2003,6 +2052,12 @@ INT BeceemEEPROMBulkWrite(
 			uiBytesToCopy = 0;
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/staging/bcm/Misc.c b/staging/bcm/Misc.c
--- a/staging/bcm/Misc.c
+++ b/staging/bcm/Misc.c
@@ -113,9 +113,20 @@ VOID AdapterFree(PMINI_ADAPTER Adapter)
 	unregister_networkdev(Adapter);
 
 	/* FIXME: use proper wait_event and refcounting */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (atomic_read(&Adapter->ApplicationRunning)) {
 		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Waiting for Application to close.. %d\n", atomic_read(&Adapter->ApplicationRunning));
 		msleep(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	unregister_control_device_interface(Adapter);
 	kfree(Adapter->pstargetparams);
@@ -1600,6 +1611,11 @@ void flush_queue(PMINI_ADAPTER Adapter,
 	struct net_device_stats *netstats = &Adapter->dev->stats;
 	spin_lock_bh(&Adapter->PackInfo[iQIndex].SFQueueLock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (Adapter->PackInfo[iQIndex].FirstTxQueue && atomic_read(&Adapter->TotalPacketCount)) {
 		PacketToDrop = Adapter->PackInfo[iQIndex].FirstTxQueue;
 		if (PacketToDrop && PacketToDrop->len) {
@@ -1614,6 +1630,12 @@ void flush_queue(PMINI_ADAPTER Adapter,
 			dev_kfree_skb(PacketToDrop);
 			atomic_dec(&Adapter->TotalPacketCount);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_bh(&Adapter->PackInfo[iQIndex].SFQueueLock);
 }
diff -u -p a/staging/bcm/InterfaceInit.c b/staging/bcm/InterfaceInit.c
--- a/staging/bcm/InterfaceInit.c
+++ b/staging/bcm/InterfaceInit.c
@@ -40,10 +40,21 @@ static void InterfaceAdapterFree(PS_INTE
 	 * worst case time taken by the RDM/WRM will be 5 sec. will check after every 100 ms
 	 * to accertain the device is not being accessed. After this No RDM/WRM should be made.
 	 */
-	while (psIntfAdapter->psAdapter->DeviceAccess) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (psIntfAdapter->psAdapter->DeviceAccess) {
 		BCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,
 			"Device is being accessed.\n");
 		msleep(100);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	/* Free interrupt URB */
 	/* psIntfAdapter->psAdapter->device_removed = TRUE; */
diff -u -p a/staging/bcm/InterfaceRx.c b/staging/bcm/InterfaceRx.c
--- a/staging/bcm/InterfaceRx.c
+++ b/staging/bcm/InterfaceRx.c
@@ -247,6 +247,11 @@ BOOLEAN InterfaceRx (PS_INTERFACE_ADAPTE
 
 //	RxDescCount = psIntfAdapter->psAdapter->CurrNumRecvDescs -
 //				psIntfAdapter->psAdapter->PrevNumRecvDescs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(RxDescCount)
 	{
 		pRcb = GetBulkInRcb(psIntfAdapter);
@@ -258,7 +263,13 @@ BOOLEAN InterfaceRx (PS_INTERFACE_ADAPTE
 		//atomic_inc(&psIntfAdapter->uNumRcbUsed);
 		ReceiveRcb(psIntfAdapter, pRcb);
 		RxDescCount--;
-    }
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+	}
 	return TRUE;
 }
 
diff -u -p a/staging/bcm/InterfaceDld.c b/staging/bcm/InterfaceDld.c
--- a/staging/bcm/InterfaceDld.c
+++ b/staging/bcm/InterfaceDld.c
@@ -110,6 +110,11 @@ int InterfaceFileReadbackFromChip(PVOID
 		} else {
 			len -= 4;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (len) {
 				if (*(unsigned int *)&buff_readback[len] != *(unsigned int *)&buff[len]) {
 					BCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Firmware Download is not proper %d", fw_down);
@@ -119,6 +124,12 @@ int InterfaceFileReadbackFromChip(PVOID
 					goto exit;
 				}
 				len -= 4;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		on_chip_loc += MAX_TRANSFER_CTRL_BYTE_USB;
diff -u -p a/staging/bcm/Bcmchar.c b/staging/bcm/Bcmchar.c
--- a/staging/bcm/Bcmchar.c
+++ b/staging/bcm/Bcmchar.c
@@ -76,10 +76,21 @@ static int bcm_char_release(struct inode
 	}
 
 	pkt = pTarang->RxAppControlHead;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pkt) {
 		npkt = pkt->next;
 		kfree_skb(pkt);
 		pkt = npkt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	up(&Adapter->RxAppControlQueuelock);
diff -u -p a/staging/iio/industrialio-buffer.c b/staging/iio/industrialio-buffer.c
--- a/staging/iio/industrialio-buffer.c
+++ b/staging/iio/industrialio-buffer.c
@@ -561,10 +561,21 @@ static unsigned long *iio_scan_mask_matc
 {
 	if (bitmap_empty(mask, masklength))
 		return NULL;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*av_masks) {
 		if (bitmap_subset(mask, av_masks, masklength))
 			return av_masks;
 		av_masks += BITS_TO_LONGS(masklength);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/staging/iio/light/tsl2563.c b/staging/iio/light/tsl2563.c
--- a/staging/iio/light/tsl2563.c
+++ b/staging/iio/light/tsl2563.c
@@ -329,7 +329,12 @@ static int tsl2563_get_adc(struct tsl256
 		}
 	}
 
-	while (retry) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (retry) {
 		ret = i2c_smbus_read_word_data(client,
 				TSL2563_CMD | TSL2563_REG_DATA0LOW);
 		if (ret < 0)
@@ -343,6 +348,12 @@ static int tsl2563_get_adc(struct tsl256
 		adc1 = ret;
 
 		retry = tsl2563_adjust_gainlevel(chip, adc0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	chip->data0 = normalize_adc(adc0, chip->gainlevel->gaintime);
diff -u -p a/staging/iio/ring_sw.c b/staging/iio/ring_sw.c
--- a/staging/iio/ring_sw.c
+++ b/staging/iio/ring_sw.c
@@ -206,10 +206,21 @@ static int iio_read_first_n_sw_rb(struct
 	initial_write_p = ring->write_p;
 
 	/* Need a consistent pair */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((initial_read_p != ring->read_p)
 	       || (initial_write_p != ring->write_p)) {
 		initial_read_p = ring->read_p;
 		initial_write_p = ring->write_p;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (initial_write_p == initial_read_p) {
 		/* No new data available.*/
diff -u -p a/staging/iio/Documentation/generic_buffer.c b/staging/iio/Documentation/generic_buffer.c
--- a/staging/iio/Documentation/generic_buffer.c
+++ b/staging/iio/Documentation/generic_buffer.c
@@ -42,6 +42,11 @@ int size_from_channelarray(struct iio_ch
 {
 	int bytes = 0;
 	int i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < num_channels) {
 		if (bytes % channels[i].bytes == 0)
 			channels[i].location = bytes;
@@ -50,6 +55,12 @@ int size_from_channelarray(struct iio_ch
 				+ channels[i].bytes;
 		bytes = channels[i].location + channels[i].bytes;
 		i++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return bytes;
 }
diff -u -p a/staging/sep/sep_driver.c b/staging/sep/sep_driver.c
--- a/staging/sep/sep_driver.c
+++ b/staging/sep/sep_driver.c
@@ -1243,7 +1243,12 @@ static void sep_build_lli_table(struct s
 	dev_dbg(&sep->pdev->dev, "build lli table table_data_size is %x\n", table_data_size);
 
 	/* Fill the table till table size reaches the needed amount */
-	while (curr_table_data_size < table_data_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (curr_table_data_size < table_data_size) {
 		/* Update the number of entries in table */
 		(*num_table_entries_ptr)++;
 
@@ -1291,6 +1296,12 @@ static void sep_build_lli_table(struct s
 
 		/* Move to the next entry in table */
 		lli_table_ptr++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Set the info entry to default */
@@ -1547,7 +1558,12 @@ static int sep_prepare_input_dma_table(s
 	sep_lli_entries = sep->dma_res_arr[sep->nr_dcb_creat].in_num_pages;
 
 	/* Loop till all the entries in in array are not processed */
-	while (current_entry < sep_lli_entries) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (current_entry < sep_lli_entries) {
 
 		/* Set the new input and output tables */
 		in_lli_table_ptr =
@@ -1614,6 +1630,12 @@ static int sep_prepare_input_dma_table(s
 		}
 		/* Save the pointer to the info entry of the current tables */
 		info_entry_ptr = in_lli_table_ptr + num_entries_in_table - 1;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	/* Print input tables */
 	sep_debug_print_lli_tables(sep, (struct sep_lli_entry *)
@@ -1705,7 +1727,12 @@ static int sep_construct_dma_tables_from
 		SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP)));
 
 	/* Loop till all the entries in in array are not processed */
-	while (current_in_entry < sep_in_lli_entries) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (current_in_entry < sep_in_lli_entries) {
 		/* Set the new input and output tables */
 		in_lli_table_ptr =
 			(struct sep_lli_entry *)lli_table_alloc_addr;
@@ -1855,6 +1882,12 @@ static int sep_construct_dma_tables_from
 		dev_dbg(&sep->pdev->dev,
 			"output info_out_entry_ptr is %lx\n",
 			(unsigned long)info_out_entry_ptr);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Print input tables */
diff -u -p a/staging/nvec/nvec.c b/staging/nvec/nvec.c
--- a/staging/nvec/nvec.c
+++ b/staging/nvec/nvec.c
@@ -328,6 +328,11 @@ static void nvec_request_master(struct w
 	struct nvec_msg *msg;
 
 	spin_lock_irqsave(&nvec->tx_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&nvec->tx_data)) {
 		msg = list_first_entry(&nvec->tx_data, struct nvec_msg, node);
 		spin_unlock_irqrestore(&nvec->tx_lock, flags);
@@ -347,6 +352,12 @@ static void nvec_request_master(struct w
 			list_del_init(&msg->node);
 			nvec_msg_free(nvec, msg);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&nvec->tx_lock, flags);
 }
@@ -392,6 +403,11 @@ static void nvec_dispatch(struct work_st
 	struct nvec_msg *msg;
 
 	spin_lock_irqsave(&nvec->rx_lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&nvec->rx_data)) {
 		msg = list_first_entry(&nvec->rx_data, struct nvec_msg, node);
 		list_del_init(&msg->node);
@@ -408,6 +424,12 @@ static void nvec_dispatch(struct work_st
 			nvec_msg_free(nvec, msg);
 		}
 		spin_lock_irqsave(&nvec->rx_lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&nvec->rx_lock, flags);
 }
diff -u -p a/staging/serqt_usb2/serqt_usb2.c b/staging/serqt_usb2/serqt_usb2.c
--- a/staging/serqt_usb2/serqt_usb2.c
+++ b/staging/serqt_usb2/serqt_usb2.c
@@ -1026,6 +1026,11 @@ static void qt_block_until_empty(struct
 	int wait = 30;
 	int count;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 
 		count = qt_chars_in_buffer(tty);
@@ -1042,6 +1047,12 @@ static void qt_block_until_empty(struct
 		} else {
 			wait = 30;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/quickstart/quickstart.c b/staging/quickstart/quickstart.c
--- a/staging/quickstart/quickstart.c
+++ b/staging/quickstart/quickstart.c
@@ -185,6 +185,11 @@ static void quickstart_btnlst_del(struct
 	if (!data)
 		return;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*ptr) {
 		if (*ptr == data) {
 			*ptr = (*ptr)->next;
@@ -192,6 +197,12 @@ static void quickstart_btnlst_del(struct
 			return;
 		}
 		ptr = &((*ptr)->next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return;
@@ -202,11 +213,22 @@ static void quickstart_btnlst_free(void)
 	struct quickstart_btn *ptr = quickstart_data.btn_lst;
 	struct quickstart_btn *lptr = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ptr) {
 		lptr = ptr;
 		ptr = ptr->next;
 		kfree(lptr->name);
 		kfree(lptr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return;
@@ -385,11 +407,22 @@ static int __init quickstart_init_input(
 	quickstart_input->name = "Quickstart ACPI Buttons";
 	quickstart_input->id.bustype = BUS_HOST;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*ptr) {
 		count++;
 		set_bit(EV_KEY, quickstart_input->evbit);
 		set_bit((*ptr)->id, quickstart_input->keybit);
 		ptr = &((*ptr)->next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = input_register_device(quickstart_input);
diff -u -p a/staging/keucr/scsiglue.c b/staging/keucr/scsiglue.c
--- a/staging/keucr/scsiglue.c
+++ b/staging/keucr/scsiglue.c
@@ -420,7 +420,12 @@ unsigned int usb_stor_access_xfer_buf(st
 		sg = scsi_sglist(srb);
 
 	cnt = 0;
-	while (cnt < buflen && sg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt < buflen && sg) {
 		struct page *page = sg_page(sg) +
 					((sg->offset + *offset) >> PAGE_SHIFT);
 		unsigned int poff = (sg->offset + *offset) & (PAGE_SIZE-1);
@@ -453,6 +458,12 @@ unsigned int usb_stor_access_xfer_buf(st
 			cnt += plen;
 			sglen -= plen;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*sgptr = sg;
 
diff -u -p a/staging/keucr/smilecc.c b/staging/keucr/smilecc.c
--- a/staging/keucr/smilecc.c
+++ b/staging/keucr/smilecc.c
@@ -174,10 +174,21 @@ BYTE correct_data(BYTE *data, BYTE *eccd
 	i = 0; /* Clear count */
 	d &= 0x00ffffffL; /* Masking */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (d) { /* If d=0 finish counting */
 		if (d&BIT0)
 			++i; /* Count number of 1 bit */
 		d >>= 1; /* Right shift */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (i == 1) { /* If ECC error */
diff -u -p a/staging/media/lirc/lirc_sir.c b/staging/media/lirc/lirc_sir.c
--- a/staging/media/lirc/lirc_sir.c
+++ b/staging/media/lirc/lirc_sir.c
@@ -565,6 +565,11 @@ static irqreturn_t sir_interrupt(int irq
 	 * Deal with any receive errors first.  The bytes in error may be
 	 * the only bytes in the receive FIFO, so we do this first.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & UTSR0_EIF) {
 		int bstat;
 
@@ -583,6 +588,12 @@ static irqreturn_t sir_interrupt(int irq
 		bstat = Ser2UTDR;
 		n++;
 		status = Ser2UTSR0;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (status & (UTSR0_RFS | UTSR0_RID)) {
@@ -616,6 +627,11 @@ static irqreturn_t sir_interrupt(int irq
 	unsigned long flags;
 	int iir, lsr;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((iir = inb(io + UART_IIR) & UART_IIR_ID)) {
 		switch (iir&UART_IIR_ID) { /* FIXME toto treba preriedit */
 		case UART_IIR_MSI:
@@ -695,7 +711,13 @@ static irqreturn_t sir_interrupt(int irq
 		default:
 			break;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 #endif
 	return IRQ_RETVAL(IRQ_HANDLED);
 }
diff -u -p a/staging/media/lirc/lirc_serial.c b/staging/media/lirc/lirc_serial.c
--- a/staging/media/lirc/lirc_serial.c
+++ b/staging/media/lirc/lirc_serial.c
@@ -500,6 +500,11 @@ static long send_pulse_homebrew_softcarr
 	 * The i2c code has the result of a lot of bit-banging work, I wonder if
 	 * there's something there which could be helpful here.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((now - start) < length) {
 		/* Delay till flip time */
 		do {
@@ -516,6 +521,12 @@ static long send_pulse_homebrew_softcarr
 			target += pulse_width;
 		}
 		flag = !flag;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	rdtscl(now);
 	return ((now - start) - length) / conv_us_to_clocks;
@@ -538,6 +549,11 @@ static long send_pulse_homebrew_softcarr
 	length <<= 8;
 
 	actual = 0; target = 0; flag = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (actual < length) {
 		if (flag) {
 			off();
@@ -555,6 +571,12 @@ static long send_pulse_homebrew_softcarr
 		udelay(d);
 		actual += (d << 8) + LIRC_SERIAL_TRANSMITTER_LATENCY;
 		flag = !flag;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return (actual-length) >> 8;
 }
diff -u -p a/staging/media/lirc/lirc_igorplugusb.c b/staging/media/lirc/lirc_igorplugusb.c
--- a/staging/media/lirc/lirc_igorplugusb.c
+++ b/staging/media/lirc/lirc_igorplugusb.c
@@ -282,7 +282,12 @@ static void send_fragment(struct igorplu
 	int code;
 
 	/* MODE2: pulse/space (PULSE_BIT) in 1us units */
-	while (i < max) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (i < max) {
 		/* 1 Igor-tick = 85.333333 us */
 		code = (unsigned int)ir->buf_in[i] * 85 +
 			(unsigned int)ir->buf_in[i] / 3;
@@ -293,6 +298,12 @@ static void send_fragment(struct igorplu
 		/* 1 chunk = CODE_LENGTH bytes */
 		ir->in_space ^= 1;
 		++i;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/media/solo6x10/v4l2-enc.c b/staging/media/solo6x10/v4l2-enc.c
--- a/staging/media/solo6x10/v4l2-enc.c
+++ b/staging/media/solo6x10/v4l2-enc.c
@@ -481,9 +481,20 @@ static void write_ue(u8 **out, unsigned
 {
 	uint32_t max = 0, cnt = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (value > max) {
 		max = (max + 2) * 2 - 2;
 		cnt++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	write_bits(out, bits, 1, cnt + 1);
 	write_bits(out, bits, ~(max - value), cnt);
@@ -836,7 +847,12 @@ void solo_enc_v4l2_isr(struct solo_dev *
 
 	reg_mpeg_size = ((solo_reg_read(solo_dev, SOLO_VE_STATE(0)) & 0xFFFFF) + 64 + 8) & ~7;
 
-	while (solo_dev->enc_idx != cur_q) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (solo_dev->enc_idx != cur_q) {
 		mpeg_current = solo_reg_read(solo_dev,
 					SOLO_VE_MPEG4_QUE(solo_dev->enc_idx));
 		jpeg_current = solo_reg_read(solo_dev,
@@ -895,6 +911,12 @@ void solo_enc_v4l2_isr(struct solo_dev *
 					SOLO_NR_RING_BUFS;
 
 		wake_up_interruptible(&solo_dev->v4l2_enc[ch]->thread_wait);
+		if (_cur < timeout) {
+					rdstcll(_cur);
+		}
+		else {
+					break;
+		}
 	}
 
 	return;
diff -u -p a/staging/media/easycap/easycap_ioctl.c b/staging/media/easycap/easycap_ioctl.c
--- a/staging/media/easycap/easycap_ioctl.c
+++ b/staging/media/easycap/easycap_ioctl.c
@@ -1033,6 +1033,11 @@ long easycap_unlocked_ioctl(struct file
 			k[i] = 0;
 		p2 = &version[0];
 		i = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (*p2) {
 			p1 = p2;
 			while (*p2 && ('.' != *p2))
@@ -1050,6 +1055,12 @@ long easycap_unlocked_ioctl(struct file
 				k[i] = (int)lng;
 			}
 			i++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		memset(&v4l2_capability, 0, sizeof(struct v4l2_capability));
diff -u -p a/staging/media/easycap/easycap_sound.c b/staging/media/easycap/easycap_sound.c
--- a/staging/media/easycap/easycap_sound.c
+++ b/staging/media/easycap/easycap_sound.c
@@ -168,6 +168,11 @@ easycap_alsa_complete(struct urb *purb)
 		 *  8-BIT MONO TO 16-BIT SIGNED
 		 *  LITTLE-ENDIAN SAMPLES IF NECESSARY
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (more) {
 			much = dma_bytes - peasycap->dma_fill;
 			if (0 > much) {
@@ -249,7 +254,13 @@ easycap_alsa_complete(struct urb *purb)
 					snd_pcm_period_elapsed(pss);
 				}
 			}
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+}
 
 #ifdef UPSAMPLE
 		peasycap->oldaudio = oldaudio;
diff -u -p a/staging/media/easycap/easycap_testcard.c b/staging/media/easycap/easycap_testcard.c
--- a/staging/media/easycap/easycap_testcard.c
+++ b/staging/media/easycap/easycap_testcard.c
@@ -108,17 +108,33 @@ easycap_testcard(struct easycap *peasyca
 			uyvy[3] =  0xFF & y ;
 
 			p1 = &bfbar[0];
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (p1 < &bfbar[barwidth]) {
 				*p1++ = uyvy[0] ;
 				*p1++ = uyvy[1] ;
 				*p1++ = uyvy[2] ;
 				*p1++ = uyvy[3] ;
 				total += 4;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 
 			p1 = &bfbar[0];
 			more = barwidth;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (more) {
 				if ((FIELD_BUFFER_SIZE/PAGE_SIZE) <= m) {
 					SAM("ERROR:  bad m reached\n");
@@ -148,6 +164,12 @@ easycap_testcard(struct easycap *peasyca
 					m++;
 					n = 0;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
diff -u -p a/staging/media/dt3155v4l/dt3155v4l.c b/staging/media/dt3155v4l/dt3155v4l.c
--- a/staging/media/dt3155v4l/dt3155v4l.c
+++ b/staging/media/dt3155v4l/dt3155v4l.c
@@ -274,10 +274,21 @@ dt3155_stop_streaming(struct vb2_queue *
 	struct vb2_buffer *vb;
 
 	spin_lock_irq(&pd->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&pd->dmaq)) {
 		vb = list_first_entry(&pd->dmaq, typeof(*vb), done_entry);
 		list_del(&vb->done_entry);
 		vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irq(&pd->lock);
 	msleep(45); /* irq hendler will stop the hardware */
diff -u -p a/staging/panel/panel.c b/staging/panel/panel.c
--- a/staging/panel/panel.c
+++ b/staging/panel/panel.c
@@ -1942,7 +1942,12 @@ static int input_name2mask(char *name, p
 	pmask_t m, v;
 
 	om = im = m = v = 0ULL;
-	while (*name) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (*name) {
 		int in, out, bit, neg;
 		for (in = 0; (in < sizeof(sigtab)) &&
 			     (sigtab[in] != *name); in++)
@@ -1968,6 +1973,12 @@ static int input_name2mask(char *name, p
 		if (!neg)
 			v |= 1ULL << bit;
 		name++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*mask = m;
 	*value = v;
diff -u -p a/staging/usbip/usbip_event.c b/staging/usbip/usbip_event.c
--- a/staging/usbip/usbip_event.c
+++ b/staging/usbip/usbip_event.c
@@ -29,6 +29,11 @@ static int event_handler(struct usbip_de
 	/*
 	 * Events are handled by only this thread.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (usbip_event_happened(ud)) {
 		usbip_dbg_eh("pending event %lx\n", ud->event);
 
@@ -56,6 +61,12 @@ static int event_handler(struct usbip_de
 		/* Stop the error handler. */
 		if (ud->event & USBIP_EH_BYE)
 			return -1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/staging/usbip/stub_main.c b/staging/usbip/stub_main.c
--- a/staging/usbip/stub_main.c
+++ b/staging/usbip/stub_main.c
@@ -229,6 +229,11 @@ void stub_device_cleanup_urbs(struct stu
 
 	dev_dbg(&sdev->udev->dev, "free sdev %p\n", sdev);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((priv = stub_priv_pop(sdev))) {
 		urb = priv->urb;
 		dev_dbg(&sdev->udev->dev, "free urb %p\n", urb);
@@ -239,6 +244,12 @@ void stub_device_cleanup_urbs(struct stu
 		kfree(urb->transfer_buffer);
 		kfree(urb->setup_packet);
 		usb_free_urb(urb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/usbip/vhci_hcd.c b/staging/usbip/vhci_hcd.c
--- a/staging/usbip/vhci_hcd.c
+++ b/staging/usbip/vhci_hcd.c
@@ -98,6 +98,11 @@ static void dump_port_status_diff(u32 pr
 	u32 bit = 1;
 
 	pr_debug("status prev -> new: %08x -> %08x\n", prev_status, new_status);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bit) {
 		u32 prev = prev_status & bit;
 		u32 new = new_status & bit;
@@ -114,6 +119,12 @@ static void dump_port_status_diff(u32 pr
 			pr_debug(" %c%s\n", change, bit_desc[i]);
 		bit <<= 1;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	pr_debug("\n");
 }
diff -u -p a/staging/rtl8192e/rtllib_softmac.c b/staging/rtl8192e/rtllib_softmac.c
--- a/staging/rtl8192e/rtllib_softmac.c
+++ b/staging/rtl8192e/rtllib_softmac.c
@@ -535,6 +535,11 @@ void rtllib_softmac_scan_syncro(struct r
 
 	down(&ieee->scan_sem);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		do {
 			ch++;
@@ -576,7 +581,13 @@ void rtllib_softmac_scan_syncro(struct r
 		 * need to wait for a syncro scan to end..
 		 */
 		msleep_interruptible_rsl(RTLLIB_SOFTMAC_SCAN_TIME);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	ieee->actscanning = false;
 	ieee->sync_scan_hurryup = 0;
@@ -2555,6 +2566,11 @@ void rtllib_wake_queue(struct rtllib_dev
 	ieee->queue_stop = 0;
 
 	if (ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))) {
 
 			header = (struct rtllib_hdr_3addr  *) skb->data;
@@ -2568,6 +2584,12 @@ void rtllib_wake_queue(struct rtllib_dev
 
 			ieee->softmac_data_hard_start_xmit(skb, ieee->dev,
 							   ieee->basic_rate);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (!ieee->queue_stop && ieee->tx_pending.txb)
diff -u -p a/staging/rtl8192e/rtl819x_TSProc.c b/staging/rtl8192e/rtl819x_TSProc.c
--- a/staging/rtl8192e/rtl819x_TSProc.c
+++ b/staging/rtl8192e/rtl819x_TSProc.c
@@ -432,7 +432,12 @@ static void RemoveTsEntry(struct rtllib_
 		if (timer_pending(&pRxTS->RxPktPendingTimer))
 			del_timer_sync(&pRxTS->RxPktPendingTimer);
 
-		while (!list_empty(&pRxTS->RxPendingPktList)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (!list_empty(&pRxTS->RxPendingPktList)) {
 			pRxReorderEntry = (struct rx_reorder_entry *)
 					list_entry(pRxTS->RxPendingPktList.prev,
 					struct rx_reorder_entry, List);
@@ -452,6 +457,12 @@ static void RemoveTsEntry(struct rtllib_
 			}
 			list_add_tail(&pRxReorderEntry->List,
 				      &ieee->RxReorder_Unused_List);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		struct tx_ts_record *pTxTS = (struct tx_ts_record *)pTs;
diff -u -p a/staging/rtl8192e/r8192E_phy.c b/staging/rtl8192e/r8192E_phy.c
--- a/staging/rtl8192e/r8192E_phy.c
+++ b/staging/rtl8192e/r8192E_phy.c
@@ -296,11 +296,22 @@ static u32 phy_FwRFSerialRead(struct net
 			break;
 	}
 	write_nic_dword(dev, QPNR, Data);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (read_nic_dword(dev, QPNR) & 0x80000000) {
 		if (time++ < 100)
 			udelay(10);
 		else
 			return 0;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	retValue = read_nic_dword(dev, RF_DATA);
 
diff -u -p a/staging/rtl8192e/rtl_core.c b/staging/rtl8192e/rtl_core.c
--- a/staging/rtl8192e/rtl_core.c
+++ b/staging/rtl8192e/rtl_core.c
@@ -342,7 +342,12 @@ bool MgntActSet_RF_State(struct net_devi
 					 "progress! Wait to set..StateToSet"
 					 "(%d).\n", StateToSet);
 
-				while (priv->RFChangeInProgress) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (priv->RFChangeInProgress) {
 					RFWaitCounter++;
 					RT_TRACE((COMP_PS | COMP_RF),
 						 "MgntActSet_RF_State(): Wait 1"
@@ -356,6 +361,12 @@ bool MgntActSet_RF_State(struct net_devi
 							 "logn to set RF\n");
 						return false;
 					}
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			} else {
 				priv->RFChangeInProgress = true;
@@ -1846,6 +1857,11 @@ static void rtl8192_free_tx_ring(struct
 	struct r8192_priv *priv = rtllib_priv(dev);
 	struct rtl8192_tx_ring *ring = &priv->tx_ring[prio];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb_queue_len(&ring->queue)) {
 		struct tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb = __skb_dequeue(&ring->queue);
@@ -1854,6 +1870,12 @@ static void rtl8192_free_tx_ring(struct
 			skb->len, PCI_DMA_TODEVICE);
 		kfree_skb(skb);
 		ring->idx = (ring->idx + 1) % ring->entries;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	pci_free_consistent(priv->pdev, sizeof(*ring->desc)*ring->entries,
@@ -1950,6 +1972,11 @@ static void rtl8192_tx_isr(struct net_de
 
 	struct rtl8192_tx_ring *ring = &priv->tx_ring[prio];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (skb_queue_len(&ring->queue)) {
 		struct tx_desc *entry = &ring->desc[ring->idx];
 		struct sk_buff *skb;
@@ -1965,6 +1992,12 @@ static void rtl8192_tx_isr(struct net_de
 		skb->len, PCI_DMA_TODEVICE);
 
 		kfree_skb(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (prio != BEACON_QUEUE)
 		tasklet_schedule(&priv->irq_tx_tasklet);
@@ -2200,7 +2233,12 @@ void rtl8192_pci_resetdescring(struct ne
 		if (priv->tx_ring[i].desc) {
 			struct rtl8192_tx_ring *ring = &priv->tx_ring[i];
 
-			while (skb_queue_len(&ring->queue)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (skb_queue_len(&ring->queue)) {
 				struct tx_desc *entry = &ring->desc[ring->idx];
 				struct sk_buff *skb =
 						 __skb_dequeue(&ring->queue);
@@ -2210,6 +2248,12 @@ void rtl8192_pci_resetdescring(struct ne
 						 skb->len, PCI_DMA_TODEVICE);
 				kfree_skb(skb);
 				ring->idx = (ring->idx + 1) % ring->entries;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			ring->idx = 0;
 		}
diff -u -p a/staging/rtl8192u/r819xU_phy.c b/staging/rtl8192u/r819xU_phy.c
--- a/staging/rtl8192u/r819xU_phy.c
+++ b/staging/rtl8192u/r819xU_phy.c
@@ -408,6 +408,11 @@ phy_FwRFSerialRead(
 	// 7. Execute read operation.
 	write_nic_dword(dev, QPNR, Data);
 	// 8. Check if firmawre send back RF content.
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (read_nic_dword(dev, QPNR)&0x80000000)
 	{
 		// If FW can not finish RF-R/W for more than ?? times. We must reset FW.
@@ -418,6 +423,12 @@ phy_FwRFSerialRead(
 		}
 		else
 			return	(0);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	retValue = read_nic_dword(dev, RF_DATA);
 
diff -u -p a/staging/rtl8192u/ieee80211/rtl819x_TSProc.c b/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
--- a/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
+++ b/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
@@ -492,6 +492,11 @@ void RemoveTsEntry(
 		if(timer_pending(&pRxTS->RxPktPendingTimer))
 			del_timer_sync(&pRxTS->RxPktPendingTimer);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(!list_empty(&pRxTS->RxPendingPktList))
 		{
 		//      PlatformAcquireSpinLock(Adapter, RT_RX_SPINLOCK);
@@ -516,6 +521,12 @@ void RemoveTsEntry(
 			list_add_tail(&pRxReorderEntry->List,&ieee->RxReorder_Unused_List);
 			//PlatformReleaseSpinLock(Adapter, RT_RX_SPINLOCK);
 			spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 //#endif
diff -u -p a/staging/rtl8192u/ieee80211/scatterwalk.c b/staging/rtl8192u/ieee80211/scatterwalk.c
--- a/staging/rtl8192u/ieee80211/scatterwalk.c
+++ b/staging/rtl8192u/ieee80211/scatterwalk.c
@@ -106,6 +106,11 @@ int scatterwalk_copychunks(void *buf, st
 			   size_t nbytes, int out)
 {
 	if (buf != walk->data) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (nbytes > walk->len_this_page) {
 			memcpy_dir(buf, walk->data, walk->len_this_page, out);
 			buf += walk->len_this_page;
@@ -114,6 +119,12 @@ int scatterwalk_copychunks(void *buf, st
 			crypto_kunmap(walk->data, out);
 			scatterwalk_pagedone(walk, out, 1);
 			scatterwalk_map(walk, out);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		memcpy_dir(buf, walk->data, nbytes, out);
diff -u -p a/staging/rtl8192u/ieee80211/ieee80211_softmac.c b/staging/rtl8192u/ieee80211/ieee80211_softmac.c
--- a/staging/rtl8192u/ieee80211/ieee80211_softmac.c
+++ b/staging/rtl8192u/ieee80211/ieee80211_softmac.c
@@ -431,6 +431,11 @@ void ieee80211_softmac_scan_syncro(struc
 	memcpy(channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER+1);
 	down(&ieee->scan_sem);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(1)
 	{
 
@@ -477,7 +482,13 @@ void ieee80211_softmac_scan_syncro(struc
 
 		msleep_interruptible_rsl(IEEE80211_SOFTMAC_SCAN_TIME);
 
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	if(ieee->state < IEEE80211_LINKED){
 		ieee->actscanning = false;
@@ -2240,6 +2251,11 @@ void ieee80211_wake_queue(struct ieee802
 	ieee->queue_stop = 0;
 
 	if(ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE){
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){
 
 			header = (struct ieee80211_hdr_3addr  *) skb->data;
@@ -2253,6 +2269,12 @@ void ieee80211_wake_queue(struct ieee802
 
 			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
 			//dev_kfree_skb_any(skb);//edit by thomas
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (!ieee->queue_stop && ieee->tx_pending.txb)
diff -u -p a/staging/rtl8192u/r8192U_core.c b/staging/rtl8192u/r8192U_core.c
--- a/staging/rtl8192u/r8192U_core.c
+++ b/staging/rtl8192u/r8192U_core.c
@@ -1041,6 +1041,11 @@ void rtl8192_rtx_disable(struct net_devi
 	force_pci_posting(dev);
 	mdelay(10);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = __skb_dequeue(&priv->rx_queue))) {
 		info = (struct rtl8192_rx_info *) skb->cb;
 		if (!info->urb)
@@ -1048,6 +1053,12 @@ void rtl8192_rtx_disable(struct net_devi
 
 		usb_kill_urb(info->urb);
 		kfree_skb(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (skb_queue_len(&priv->skb_queue)) {
diff -u -p a/staging/wlags49_h2/dhf.c b/staging/wlags49_h2/dhf.c
--- a/staging/wlags49_h2/dhf.c
+++ b/staging/wlags49_h2/dhf.c
@@ -278,9 +278,20 @@ int				i;
 		for (i = 0; fw->p[i]; i++)
 			fw->p[i] = ((char *)fw->p[i] + (hcf_32)fw);
 		p = fw->codep;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (p->len) {
 			p->host_addr = (char *)p->host_addr + (hcf_32)fw;
 			p++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 	}
 	return rc;
diff -u -p a/staging/wlags49_h2/hcf.c b/staging/wlags49_h2/hcf.c
--- a/staging/wlags49_h2/hcf.c
+++ b/staging/wlags49_h2/hcf.c
@@ -966,10 +966,21 @@ hcf_cntl( IFBP ifbp, hcf_16 cmd )
 						put_frame_lst( ifbp, ifbp->IFB_FirstDesc[DMA_RX]->next_desc_addr, DMA_RX );
 					}
 				} else {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
 					while ( p ) {
 						//p->buf_cntl.cntl_stat |= DESC_DMA_OWNED;
 						p->BUF_CNT |= DESC_DMA_OWNED;
 						p = p->next_desc_addr;
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
 					}
 					// a rx chain is available so hand it over to the DMA engine
 					p = ifbp->IFB_FirstDesc[DMA_RX];
diff -u -p a/staging/pohmelfs/crypto.c b/staging/pohmelfs/crypto.c
--- a/staging/pohmelfs/crypto.c
+++ b/staging/pohmelfs/crypto.c
@@ -289,6 +289,11 @@ static int pohmelfs_trans_iter(struct ne
 	struct scatterlist sg_src, sg_dst;
 	int err;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		cmd = data;
 		cmd_cmd = __be16_to_cpu(cmd->cmd);
@@ -312,6 +317,12 @@ static int pohmelfs_trans_iter(struct ne
 		err = iterator(e, &sg_dst, &sg_src);
 		if (err)
 			return err;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!pages)
@@ -568,6 +579,11 @@ static int pohmelfs_crypto_thread_func(v
 
 static void pohmelfs_crypto_flush(struct pohmelfs_sb *psb, struct list_head *head)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(head)) {
 		struct pohmelfs_crypto_thread *t = NULL;
 
@@ -580,15 +596,32 @@ static void pohmelfs_crypto_flush(struct
 
 		if (t)
 			pohmelfs_sys_crypto_exit_one(t);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
 static void pohmelfs_sys_crypto_exit(struct pohmelfs_sb *psb)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&psb->crypto_active_list) || !list_empty(&psb->crypto_ready_list)) {
 		dprintk("%s: crypto_thread_num: %u.\n", __func__, psb->crypto_thread_num);
 		pohmelfs_crypto_flush(psb, &psb->crypto_active_list);
 		pohmelfs_crypto_flush(psb, &psb->crypto_ready_list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -784,7 +817,12 @@ static int pohmelfs_crypto_thread_get(st
 	struct pohmelfs_crypto_thread *t = NULL;
 	int err;
 
-	while (!t) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!t) {
 		err = wait_event_interruptible_timeout(psb->wait,
 				!list_empty(&psb->crypto_ready_list),
 				psb->wait_on_page_timeout);
@@ -805,6 +843,12 @@ static int pohmelfs_crypto_thread_get(st
 
 		}
 		mutex_unlock(&psb->crypto_thread_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return err;
diff -u -p a/staging/pohmelfs/net.c b/staging/pohmelfs/net.c
--- a/staging/pohmelfs/net.c
+++ b/staging/pohmelfs/net.c
@@ -84,6 +84,11 @@ static int pohmelfs_data_recv(struct net
 	unsigned int mask = err_mask | POLLIN;
 	int err = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size && !err) {
 		revents = netfs_state_poll(st);
 
@@ -148,6 +153,12 @@ static int pohmelfs_data_recv(struct net
 					"should_stop: %d, size: %u, err: %d.\n",
 				__func__, st->socket, st->read_socket,
 				revents, revents & err_mask, kthread_should_stop(), size, err);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return err;
@@ -859,6 +870,11 @@ static int pohmelfs_recv(void *data)
 	struct netfs_state *st = data;
 	struct netfs_cmd *cmd = &st->cmd;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		/*
 		 * If socket will be reset after this statement, then
@@ -969,6 +985,12 @@ static int pohmelfs_recv(void *data)
 				netfs_state_reset(st);
 				break;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	while (!kthread_should_stop())
diff -u -p a/staging/pohmelfs/path_entry.c b/staging/pohmelfs/path_entry.c
--- a/staging/pohmelfs/path_entry.c
+++ b/staging/pohmelfs/path_entry.c
@@ -105,9 +105,20 @@ rename_retry:
 	if (!IS_ROOT(d) && d_unhashed(d))
 		len += UNHASHED_OBSCURE_STRING_SIZE; /* Obscure " (deleted)" string */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (d && d != root && !IS_ROOT(d)) {
 		len += d->d_name.len + 1; /* Plus slash */
 		d = d->d_parent;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	rcu_read_unlock();
 	if (read_seqretry(&rename_lock, seq))
diff -u -p a/staging/quatech_usb2/quatech_usb2.c b/staging/quatech_usb2/quatech_usb2.c
--- a/staging/quatech_usb2/quatech_usb2.c
+++ b/staging/quatech_usb2/quatech_usb2.c
@@ -918,7 +918,12 @@ static int qt2_ioctl(struct tty_struct *
 		prev_msr_value = port_extra->shadowMSR  & QT2_SERIAL_MSR_MASK;
 		barrier();
 		__set_current_state(TASK_INTERRUPTIBLE);
-		while (1) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (1) {
 			add_wait_queue(&port_extra->wait, &wait);
 			schedule();
 			dbg("%s(): port %d, cmd == TIOCMIWAIT here\n",
@@ -948,6 +953,12 @@ static int qt2_ioctl(struct tty_struct *
 				__set_current_state(TASK_RUNNING);
 				return 0;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		} /* end inifinite while */
 		/* FIXME: This while loop needs a way to break out if the device
 		 * is disconnected while a process is waiting for the MSR to
diff -u -p a/staging/rtl8712/rtl871x_xmit.c b/staging/rtl8712/rtl871x_xmit.c
--- a/staging/rtl8712/rtl871x_xmit.c
+++ b/staging/rtl8712/rtl871x_xmit.c
@@ -863,10 +863,21 @@ void r8712_free_xmitframe_queue(struct x
 	spin_lock_irqsave(&(pframequeue->lock), irqL);
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (end_of_queue_search(phead, plist) == false) {
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 		plist = get_next(plist);
 		r8712_free_xmitframe(pxmitpriv, pxmitframe);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&(pframequeue->lock), irqL);
 }
diff -u -p a/staging/rtl8712/rtl871x_sta_mgt.c b/staging/rtl8712/rtl871x_sta_mgt.c
--- a/staging/rtl8712/rtl871x_sta_mgt.c
+++ b/staging/rtl8712/rtl871x_sta_mgt.c
@@ -85,9 +85,20 @@ static void mfree_all_stainfo(struct sta
 	spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
 	phead = get_list_head(&pstapriv->free_sta_queue);
 	plist = get_next(phead);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((end_of_queue_search(phead, plist)) == false) {
 		psta = LIST_CONTAINOR(plist, struct sta_info, list);
 		plist = get_next(plist);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
@@ -228,12 +239,23 @@ void r8712_free_all_stainfo(struct _adap
 	for (index = 0; index < NUM_STA; index++) {
 		phead = &(pstapriv->sta_hash[index]);
 		plist = get_next(phead);
-		while ((end_of_queue_search(phead, plist)) == false) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((end_of_queue_search(phead, plist)) == false) {
 			psta = LIST_CONTAINOR(plist,
 					      struct sta_info, hash_list);
 			plist = get_next(plist);
 			if (pbcmc_stainfo != psta)
 				r8712_free_stainfo(padapter , psta);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 		}
 	}
 	spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
diff -u -p a/staging/rtl8712/rtl8712_recv.c b/staging/rtl8712/rtl8712_recv.c
--- a/staging/rtl8712/rtl8712_recv.c
+++ b/staging/rtl8712/rtl8712_recv.c
@@ -231,6 +231,11 @@ static union recv_frame *recvframe_defra
 	plist = get_list_head(defrag_q);
 	plist = get_next(plist);
 	data = get_recvframe_data(prframe);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (end_of_queue_search(phead, plist) == false) {
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pnfhdr = &pnextrframe->u.hdr;
@@ -254,6 +259,12 @@ static union recv_frame *recvframe_defra
 		recvframe_put(prframe, pnfhdr->len);
 		pfhdr->attrib.icv_len = pnfhdr->attrib.icv_len;
 		plist = get_next(plist);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* free the defrag_q queue and return the prframe */
 	r8712_free_recvframe_queue(defrag_q, pfree_recv_queue);
diff -u -p a/staging/rtl8712/rtl8712_efuse.c b/staging/rtl8712/rtl8712_efuse.c
--- a/staging/rtl8712/rtl8712_efuse.c
+++ b/staging/rtl8712/rtl8712_efuse.c
@@ -222,6 +222,11 @@ u16 r8712_efuse_get_current_size(struct
 	u8 hoffset = 0, hworden = 0;
 	u8 efuse_data, word_cnts = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (bContinual && efuse_one_byte_read(padapter, efuse_addr,
 	       &efuse_data) && (efuse_addr < efuse_available_max_size)) {
 		if (efuse_data != 0xFF) {
@@ -232,6 +237,12 @@ u16 r8712_efuse_get_current_size(struct
 			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
 		} else
 			bContinual = false ;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return efuse_addr;
 }
diff -u -p a/staging/rtl8712/rtl8712_xmit.c b/staging/rtl8712/rtl8712_xmit.c
--- a/staging/rtl8712/rtl8712_xmit.c
+++ b/staging/rtl8712/rtl8712_xmit.c
@@ -213,7 +213,12 @@ static struct xmit_frame *dequeue_xframe
 		phwxmit = phwxmit_i + inx[i];
 		sta_phead = get_list_head(phwxmit->sta_queue);
 		sta_plist = get_next(sta_phead);
-		while ((end_of_queue_search(sta_phead, sta_plist)) == false) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while ((end_of_queue_search(sta_phead, sta_plist)) == false) {
 			ptxservq = LIST_CONTAINOR(sta_plist, struct tx_servq,
 				  tx_pending);
 			pframe_queue = &ptxservq->sta_pending;
@@ -229,6 +234,12 @@ static struct xmit_frame *dequeue_xframe
 				/*must be done after get_next and before break*/
 				list_delete(&ptxservq->tx_pending);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 exit_dequeue_xframe_ex:
diff -u -p a/staging/rtl8712/rtl871x_mlme.c b/staging/rtl8712/rtl871x_mlme.c
--- a/staging/rtl8712/rtl871x_mlme.c
+++ b/staging/rtl8712/rtl871x_mlme.c
@@ -174,10 +174,21 @@ static void _free_network_queue(struct _
 	spin_lock_irqsave(&scanned_queue->lock, irqL);
 	phead = get_list_head(scanned_queue);
 	plist = get_next(phead);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (end_of_queue_search(phead, plist) == false) {
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		plist = get_next(plist);
 		_free_network(pmlmepriv, pnetwork);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&scanned_queue->lock, irqL);
 }
@@ -1147,6 +1158,11 @@ int r8712_select_and_join_from_scan(stru
 	queue = &pmlmepriv->scanned_queue;
 	phead = get_list_head(queue);
 	pmlmepriv->pscanned = get_next(phead);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (end_of_queue_search(phead, pmlmepriv->pscanned) == true) {
 			if ((pmlmepriv->assoc_by_rssi == true) &&
@@ -1206,6 +1222,12 @@ int r8712_select_and_join_from_scan(stru
 				goto ask_for_joinbss;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return _FAIL;
 ask_for_joinbss:
diff -u -p a/staging/rtl8712/ieee80211.c b/staging/rtl8712/ieee80211.c
--- a/staging/rtl8712/ieee80211.c
+++ b/staging/rtl8712/ieee80211.c
@@ -377,6 +377,11 @@ int r8712_get_sec_ie(u8 *in_ie, uint in_
 	/*Search required WPA or WPA2 IE and copy to sec_ie[ ]*/
 	cnt = (_TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_);
 	sec_idx = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt < in_len) {
 		authmode = in_ie[cnt];
 		if ((authmode == _WPA_IE_ID_) &&
@@ -393,6 +398,12 @@ int r8712_get_sec_ie(u8 *in_ie, uint in_
 			} else
 				cnt += in_ie[cnt+1] + 2;   /*get next*/
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return *rsn_len + *wpa_len;
 }
diff -u -p a/staging/rtl8712/rtl871x_recv.c b/staging/rtl8712/rtl871x_recv.c
--- a/staging/rtl8712/rtl871x_recv.c
+++ b/staging/rtl8712/rtl871x_recv.c
@@ -147,10 +147,21 @@ void r8712_free_recvframe_queue(struct
 	spin_lock(&pframequeue->lock);
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (end_of_queue_search(phead, plist) == false) {
 		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		plist = get_next(plist);
 		r8712_free_recvframe(precvframe, pfree_recv_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock(&pframequeue->lock);
 }
diff -u -p a/staging/rts5139/rts51x_scsi.c b/staging/rts5139/rts51x_scsi.c
--- a/staging/rts5139/rts51x_scsi.c
+++ b/staging/rts5139/rts51x_scsi.c
@@ -941,6 +941,11 @@ static int read_format_capacity(struct s
 		desc_cnt = 1;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (desc_cnt) {
 		if (check_card_ready(chip, lun)) {
 			buf[i++] = (unsigned char)((chip->capacity[lun]) >> 24);
@@ -971,6 +976,12 @@ static int read_format_capacity(struct s
 		buf[i++] = 0x00;
 
 		desc_cnt--;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	buf_len = min(scsi_bufflen(srb), buf_len);
diff -u -p a/staging/rts5139/rts51x_transport.c b/staging/rts5139/rts51x_transport.c
--- a/staging/rts5139/rts51x_transport.c
+++ b/staging/rts5139/rts51x_transport.c
@@ -75,7 +75,12 @@ unsigned int rts51x_access_sglist(unsign
 	 * the *offset and **sgptr values for the next loop.
 	 */
 	cnt = 0;
-	while (cnt < buflen && sg) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (cnt < buflen && sg) {
 		struct page *page = sg_page(sg) +
 		    ((sg->offset + *offset) >> PAGE_SHIFT);
 		unsigned int poff = (sg->offset + *offset) & (PAGE_SIZE - 1);
@@ -113,6 +118,12 @@ unsigned int rts51x_access_sglist(unsign
 			cnt += plen;
 			sglen -= plen;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	*sgptr = sg;
 
@@ -619,6 +630,11 @@ int rts51x_sg_wait(struct usb_sg_request
 	/* queue the urbs.  */
 	spin_lock_irq(&io->lock);
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < entries && !io->status) {
 		int retval;
 
@@ -661,6 +677,12 @@ int rts51x_sg_wait(struct usb_sg_request
 		spin_lock_irq(&io->lock);
 		if (retval && (io->status == 0 || io->status == -ECONNRESET))
 			io->status = retval;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+		}
 	}
 	io->count -= entries - i;
 	if (io->count == 0)
diff -u -p a/staging/slicoss/slicoss.c b/staging/slicoss/slicoss.c
--- a/staging/slicoss/slicoss.c
+++ b/staging/slicoss/slicoss.c
@@ -886,7 +886,12 @@ static bool slic_mac_filter(struct adapt
 		if (opts & MAC_MCAST) {
 			struct mcast_address *mcaddr = adapter->mcastaddrs;
 
-			while (mcaddr) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (mcaddr) {
 				if (!compare_ether_addr(mcaddr->address,
 							ether_frame->ether_dhost)) {
 					adapter->rcv_multicasts++;
@@ -894,6 +899,12 @@ static bool slic_mac_filter(struct adapt
 					return true;
 				}
 				mcaddr = mcaddr->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			return false;
 		} else {
@@ -1553,6 +1564,11 @@ static void slic_cmdq_free(struct adapte
 	struct slic_hostcmd *cmd;
 
 	cmd = adapter->cmdq_all.head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cmd) {
 		if (cmd->busy) {
 			struct sk_buff *tempskb;
@@ -1564,6 +1580,12 @@ static void slic_cmdq_free(struct adapte
 			}
 		}
 		cmd = cmd->next_all;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	memset(&adapter->cmdq_all, 0, sizeof(struct slic_cmdqueue));
 	memset(&adapter->cmdq_free, 0, sizeof(struct slic_cmdqueue));
@@ -1679,6 +1701,11 @@ static void slic_cmdq_reset(struct adapt
 	outstanding = adapter->cmdq_all.count - adapter->cmdq_done.count;
 	outstanding -= adapter->cmdq_free.count;
 	hcmd = adapter->cmdq_all.head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hcmd) {
 		if (hcmd->busy) {
 			skb = hcmd->skb;
@@ -1688,6 +1715,12 @@ static void slic_cmdq_reset(struct adapt
 			dev_kfree_skb_irq(skb);
 		}
 		hcmd = hcmd->next_all;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	adapter->cmdq_free.count = 0;
 	adapter->cmdq_free.head = NULL;
@@ -1697,10 +1730,21 @@ static void slic_cmdq_reset(struct adapt
 	adapter->cmdq_done.tail = NULL;
 	adapter->cmdq_free.head = adapter->cmdq_all.head;
 	hcmd = adapter->cmdq_all.head;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hcmd) {
 		adapter->cmdq_free.count++;
 		hcmd->next = hcmd->next_all;
 		hcmd = hcmd->next_all;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (adapter->cmdq_free.count != adapter->cmdq_all.count) {
 		dev_err(&adapter->netdev->dev,
@@ -1869,10 +1913,21 @@ static void slic_rcvqueue_free(struct ad
 	struct slic_rcvqueue *rcvq = &adapter->rcvqueue;
 	struct sk_buff *skb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rcvq->head) {
 		skb = rcvq->head;
 		rcvq->head = rcvq->head->next;
 		dev_kfree_skb(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	rcvq->tail = NULL;
 	rcvq->head = NULL;
@@ -1892,9 +1947,20 @@ static int slic_rcvqueue_init(struct ada
 	rcvq->count = 0;
 	i = (SLIC_RCVQ_ENTRIES / SLIC_RCVQ_FILLENTRIES);
 	count = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i) {
 		count += slic_rcvqueue_fill(adapter);
 		i--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (rcvq->count < SLIC_RCVQ_MINENTRIES) {
 		slic_rcvqueue_free(adapter);
@@ -2498,10 +2564,21 @@ static int slic_mcast_add_list(struct ad
 
 	/* Check to see if it already exists */
 	mlist = adapter->mcastaddrs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mlist) {
 		if (!compare_ether_addr(mlist->address, address))
 			return 0;
 		mlist = mlist->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Doesn't already exist.  Allocate a structure to hold it */
@@ -3209,10 +3286,21 @@ static void __devexit slic_entry_remove(
 	iounmap((void __iomem *)dev->base_addr);
 	/* free multicast addresses */
 	mlist = adapter->mcastaddrs;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mlist) {
 		mcaddr = mlist;
 		mlist = mlist->next;
 		kfree(mcaddr);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ASSERT(adapter->card);
 	card = adapter->card;
diff -u -p a/staging/speakup/speakup_dtlk.c b/staging/speakup/speakup_dtlk.c
--- a/staging/speakup/speakup_dtlk.c
+++ b/staging/speakup/speakup_dtlk.c
@@ -246,6 +246,11 @@ static void do_catch_up(struct spk_synth
 static const char *synth_immediate(struct spk_synth *synth, const char *buf)
 {
 	u_char ch;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ch = (u_char)*buf)) {
 		if (synth_full())
 			return buf;
@@ -253,6 +258,12 @@ static const char *synth_immediate(struc
 			ch = PROCSPEECH;
 		spk_out(ch);
 		buf++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/staging/speakup/speakup_dectlk.c b/staging/speakup/speakup_dectlk.c
--- a/staging/speakup/speakup_dectlk.c
+++ b/staging/speakup/speakup_dectlk.c
@@ -224,11 +224,22 @@ static void do_catch_up(struct spk_synth
 	while (!kthread_should_stop()) {
 		/* if no ctl-a in 4, send data anyway */
 		spin_lock_irqsave(&flush_lock, flags);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (is_flushing && timeout) {
 			prepare_to_wait(&flush, &wait, TASK_INTERRUPTIBLE);
 			spin_unlock_irqrestore(&flush_lock, flags);
 			timeout = schedule_timeout(timeout);
 			spin_lock_irqsave(&flush_lock, flags);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		finish_wait(&flush, &wait);
 		is_flushing = 0;
diff -u -p a/staging/speakup/speakup_acntpc.c b/staging/speakup/speakup_acntpc.c
--- a/staging/speakup/speakup_acntpc.c
+++ b/staging/speakup/speakup_acntpc.c
@@ -152,19 +152,41 @@ static inline bool synth_full(void)
 static const char *synth_immediate(struct spk_synth *synth, const char *buf)
 {
 	u_char ch;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ch = *buf)) {
 		int timeout = SPK_XMITR_TIMEOUT;
 		if (ch == '\n')
 			ch = PROCSPEECH;
 		if (synth_full())
 			return buf;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (synth_writable()) {
 			if (!--timeout)
 				return buf;
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		outb_p(ch, speakup_info.port_tts);
 		buf++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/staging/speakup/i18n.c b/staging/speakup/i18n.c
--- a/staging/speakup/i18n.c
+++ b/staging/speakup/i18n.c
@@ -510,6 +510,11 @@ static int fmt_validate(char *template,
 	char *template_ptr = template;
 	char *user_ptr = user;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (still_comparing && valid) {
 		template_ptr = next_specifier(template_ptr);
 		user_ptr = next_specifier(user_ptr);
@@ -523,6 +528,12 @@ static int fmt_validate(char *template,
 			if (template_ptr || user_ptr)
 				valid = 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return valid;
 }
diff -u -p a/staging/speakup/synth.c b/staging/speakup/synth.c
--- a/staging/speakup/synth.c
+++ b/staging/speakup/synth.c
@@ -136,7 +136,12 @@ EXPORT_SYMBOL_GPL(spk_do_catch_up);
 const char *spk_synth_immediate(struct spk_synth *synth, const char *buff)
 {
 	u_char ch;
-	while ((ch = *buff)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((ch = *buff)) {
 		if (ch == '\n')
 			ch = synth->procspeech;
 		if (wait_for_xmitr())
@@ -144,6 +149,12 @@ const char *spk_synth_immediate(struct s
 		else
 			return buff;
 		buff++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/staging/speakup/main.c b/staging/speakup/main.c
--- a/staging/speakup/main.c
+++ b/staging/speakup/main.c
@@ -691,6 +691,11 @@ static void spell_word(struct vc_data *v
 	u_char ch;
 	if (!get_word(vc))
 		return;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ch = (u_char) *cp)) {
 		if (cp != buf)
 			synth_printf(" %s ", delay_str[spell_delay]);
@@ -719,6 +724,12 @@ static void spell_word(struct vc_data *v
 		}
 		synth_printf("%s", cp1);
 		cp++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (str_cap != str_caps_stop)
 		synth_printf("%s", str_caps_stop);
@@ -929,11 +940,22 @@ static void speakup_win_say(struct vc_da
 	}
 	start = vc->vc_origin + (win_top * vc->vc_size_row);
 	end = vc->vc_origin + (win_bottom * vc->vc_size_row);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start <= end) {
 		from = start + (win_left * 2);
 		to = start + (win_right * 2);
 		say_from_to(vc, from, to, 1);
 		start += vc->vc_size_row;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1205,11 +1227,22 @@ int set_key_info(const u_char *key_info,
 		shift_table[ch] = i;
 	}
 	keymap_flags = *cp1++;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ch = *cp1)) {
 		if (ch >= MAX_KEY)
 			return -4;
 		our_keys[ch] = cp1;
 		cp1 += states + 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/staging/speakup/serialio.c b/staging/speakup/serialio.c
--- a/staging/speakup/serialio.c
+++ b/staging/speakup/serialio.c
@@ -81,12 +81,23 @@ static irqreturn_t synth_readbuf_handler
 /*pr_warn("in IRQ\n"); */
 	int c;
 	spk_lock(flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR) {
 
 		c = inb_p(speakup_info.port_tts+UART_RX);
 		synth->read_buff_add((u_char) c);
 /*printk(KERN_ERR "c = %d\n", c); */
 /*pr_warn("C = %d\n", c); */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spk_unlock(flags);
 	return IRQ_HANDLED;
@@ -145,6 +156,11 @@ int wait_for_xmitr(void)
 		timeouts = 0;
 		return 0;
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (spk_serial_tx_busy()) {
 		if (--tmout == 0) {
 			pr_warn("%s: timed out (tx busy)\n", synth->long_name);
@@ -152,8 +168,19 @@ int wait_for_xmitr(void)
 			return 0;
 		}
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	tmout = SPK_CTS_TIMEOUT;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!((inb_p(speakup_info.port_tts + UART_MSR)) & UART_MSR_CTS)) {
 		/* CTS */
 		if (--tmout == 0) {
@@ -163,6 +190,12 @@ int wait_for_xmitr(void)
 			return 0;
 		}
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	timeouts = 0;
 	return 1;
@@ -172,12 +205,23 @@ unsigned char spk_serial_in(void)
 {
 	int tmout = SPK_SERIAL_TIMEOUT;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR)) {
 		if (--tmout == 0) {
 			pr_warn("time out while waiting for input.\n");
 			return 0xff;
 		}
 		udelay(1);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return inb_p(speakup_info.port_tts + UART_RX);
 }
diff -u -p a/staging/speakup/speakup_decpc.c b/staging/speakup/speakup_decpc.c
--- a/staging/speakup/speakup_decpc.c
+++ b/staging/speakup/speakup_decpc.c
@@ -437,12 +437,23 @@ static void do_catch_up(struct spk_synth
 static const char *synth_immediate(struct spk_synth *synth, const char *buf)
 {
 	u_char ch;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ch = *buf)) {
 		if (ch == '\n')
 			ch = PROCSPEECH;
 		if (dt_sendchar(ch))
 			return buf;
 		buf++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/staging/speakup/varhandlers.c b/staging/speakup/varhandlers.c
--- a/staging/speakup/varhandlers.c
+++ b/staging/speakup/varhandlers.c
@@ -364,6 +364,11 @@ char *xlate(char *s)
 	static const char hx[] = "0123456789abcdefABCDEF";
 	char *p = s, *p1, *p2, c;
 	int num;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((p = strchr(p, '\\'))) {
 		p1 = p+1;
 		p2 = strchr(finds, *p1);
@@ -399,6 +404,12 @@ char *xlate(char *s)
 		while (*p1)
 			*p2++ = *p1++;
 		*p2 = '\0';
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return s;
 }
diff -u -p a/staging/speakup/speakup_keypc.c b/staging/speakup/speakup_keypc.c
--- a/staging/speakup/speakup_keypc.c
+++ b/staging/speakup/speakup_keypc.c
@@ -155,6 +155,11 @@ static const char *synth_immediate(struc
 {
 	u_char ch;
 	int timeout;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ch = *buf)) {
 		if (ch == '\n')
 			ch = PROCSPEECH;
@@ -167,6 +172,12 @@ static const char *synth_immediate(struc
 		outb_p(ch, synth_port);
 		udelay(70);
 		buf++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return 0;
 }
diff -u -p a/staging/spectra/lld_mtd.c b/staging/spectra/lld_mtd.c
--- a/staging/spectra/lld_mtd.c
+++ b/staging/spectra/lld_mtd.c
@@ -232,7 +232,12 @@ u16 mtd_Write_Page_Main(u8 *write_data,
 		       (unsigned int)Page, (unsigned int)PageCount);
 
 
-	while (PageCount) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (PageCount) {
 		ret = spectra_mtd->write(spectra_mtd,
 					 (Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),
 					 DeviceInfo.wPageDataSize, &retlen, write_data);
@@ -243,6 +248,12 @@ u16 mtd_Write_Page_Main(u8 *write_data,
 		write_data += DeviceInfo.wPageDataSize;
 		Page++;
 		PageCount--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	nand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",
@@ -282,7 +293,12 @@ u16 mtd_Read_Page_Main(u8 *read_data, u3
 		       (unsigned int)Page, (unsigned int)PageCount);
 
 
-	while (PageCount) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (PageCount) {
 		ret = spectra_mtd->read(spectra_mtd,
 					(Block * spectra_mtd->erasesize) + (Page * spectra_mtd->writesize),
 					DeviceInfo.wPageDataSize, &retlen, read_data);
@@ -293,6 +309,12 @@ u16 mtd_Read_Page_Main(u8 *read_data, u3
 		read_data += DeviceInfo.wPageDataSize;
 		Page++;
 		PageCount--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	nand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",
@@ -336,6 +358,11 @@ u16 mtd_Read_Page_Main_Spare(u8 *read_da
 		       (unsigned int)Block, (unsigned int)Page);
 
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (PageCount) {
 		struct mtd_oob_ops ops;
 		int ret;
@@ -357,6 +384,12 @@ u16 mtd_Read_Page_Main_Spare(u8 *read_da
 		read_data += DeviceInfo.wPageSize;
 		Page++;
 		PageCount--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return PASS;
@@ -396,6 +429,11 @@ u16 mtd_Write_Page_Main_Spare(u8 *write_
 		       (unsigned int)page_count,
 		       (unsigned int)Block, (unsigned int)Page);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (page_count) {
 		struct mtd_oob_ops ops;
 		int ret;
@@ -417,6 +455,12 @@ u16 mtd_Write_Page_Main_Spare(u8 *write_
 		write_data += DeviceInfo.wPageSize;
 		Page++;
 		page_count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return PASS;
@@ -469,6 +513,11 @@ u16 mtd_Read_Page_Spare(u8 *read_data, u
 		       "block %u page %u (%u pages)\n",
 		       (unsigned int)Block, (unsigned int)Page, PageCount);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (PageCount) {
 		struct mtd_oob_ops ops;
 		int ret;
@@ -491,6 +540,12 @@ u16 mtd_Read_Page_Spare(u8 *read_data, u
 		read_data += DeviceInfo.wPageSize;
 		Page++;
 		PageCount--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return PASS;
diff -u -p a/staging/spectra/ffsport.c b/staging/spectra/ffsport.c
--- a/staging/spectra/ffsport.c
+++ b/staging/spectra/ffsport.c
@@ -426,6 +426,11 @@ static int spectra_trans_thread(void *ar
 	current->flags |= PF_MEMALLOC;
 
 	spin_lock_irq(rq->queue_lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		int res;
 
@@ -450,6 +455,12 @@ static int spectra_trans_thread(void *ar
 
 		if (!__blk_end_request_cur(req, res))
 			req = NULL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (req)
diff -u -p a/staging/comedi/drivers.c b/staging/comedi/drivers.c
--- a/staging/comedi/drivers.c
+++ b/staging/comedi/drivers.c
@@ -708,7 +708,12 @@ void comedi_buf_memcpy_to(struct comedi_
 	if (write_ptr >= async->prealloc_bufsz)
 		write_ptr %= async->prealloc_bufsz;
 
-	while (num_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (num_bytes) {
 		unsigned int block_size;
 
 		if (write_ptr + num_bytes > async->prealloc_bufsz)
@@ -722,6 +727,12 @@ void comedi_buf_memcpy_to(struct comedi_
 		num_bytes -= block_size;
 
 		write_ptr = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL(comedi_buf_memcpy_to);
@@ -735,7 +746,12 @@ void comedi_buf_memcpy_from(struct comed
 	if (read_ptr >= async->prealloc_bufsz)
 		read_ptr %= async->prealloc_bufsz;
 
-	while (nbytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nbytes) {
 		unsigned int block_size;
 
 		src = async->prealloc_buf + read_ptr;
@@ -749,6 +765,12 @@ void comedi_buf_memcpy_from(struct comed
 		nbytes -= block_size;
 		dest += block_size;
 		read_ptr = 0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 EXPORT_SYMBOL(comedi_buf_memcpy_from);
diff -u -p a/staging/comedi/drivers/aio_aio12_8.c b/staging/comedi/drivers/aio_aio12_8.c
--- a/staging/comedi/drivers/aio_aio12_8.c
+++ b/staging/comedi/drivers/aio_aio12_8.c
@@ -107,11 +107,22 @@ static int aio_aio12_8_ai_read(struct co
 		outb(control, dev->iobase + AIO12_8_ADC);
 
 		/*  Wait for conversion to complete */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (timeout &&
 		       !(inb(dev->iobase + AIO12_8_STATUS) & STATUS_ADC_EOC)) {
 			timeout--;
 			printk(KERN_ERR "timeout %d\n", timeout);
 			udelay(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (timeout == 0) {
 			comedi_error(dev, "ADC timeout");
diff -u -p a/staging/comedi/drivers/das6402.c b/staging/comedi/drivers/das6402.c
--- a/staging/comedi/drivers/das6402.c
+++ b/staging/comedi/drivers/das6402.c
@@ -212,10 +212,21 @@ static void das6402_ai_fifo_read(struct
 static void das6402_ai_fifo_dregs(struct comedi_device *dev,
 				  struct comedi_subdevice *s)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (!(inb(dev->iobase + 8) & 0x01))
 			return;
 		comedi_buf_put(s->async, inw(dev->iobase));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/comedi/drivers/adl_pci9111.c b/staging/comedi/drivers/adl_pci9111.c
--- a/staging/comedi/drivers/adl_pci9111.c
+++ b/staging/comedi/drivers/adl_pci9111.c
@@ -1046,6 +1046,11 @@ static irqreturn_t pci9111_interrupt(int
 				int position = 0;
 				int to_read;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (position < num_samples) {
 					if (dev_private->chunk_counter <
 					    dev_private->chanlist_len) {
@@ -1086,6 +1091,12 @@ static irqreturn_t pci9111_interrupt(int
 					if (dev_private->chunk_counter >=
 					    dev_private->chunk_num_samples)
 						dev_private->chunk_counter = 0;
+						if (_cur < timeout) {
+							    rdstcll(_cur);
+						}
+						else {
+							    break;
+						}
 				}
 			}
 
diff -u -p a/staging/comedi/drivers/ni_mio_common.c b/staging/comedi/drivers/ni_mio_common.c
--- a/staging/comedi/drivers/ni_mio_common.c
+++ b/staging/comedi/drivers/ni_mio_common.c
@@ -1489,6 +1489,11 @@ static void ni_handle_fifo_dregs(struct
 		}
 	} else if (boardtype.reg_type == ni_reg_6143) {
 		i = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ni_readl(AIFIFO_Status_6143) & 0x04) {
 			dl = ni_readl(AIFIFO_Data_6143);
 
@@ -1497,6 +1502,12 @@ static void ni_handle_fifo_dregs(struct
 			data[1] = (dl & 0xffff);
 			cfc_write_array_to_buffer(s, data, sizeof(data));
 			i += 2;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		/*  Check if stranded sample is present */
 		if (ni_readl(AIFIFO_Status_6143) & 0x01) {
@@ -4014,6 +4025,11 @@ static int ni_serial_hw_readwrite8(struc
 	devpriv->dio_control &= ~DIO_HW_Serial_Start;
 
 	/* Wait until STC says we're done, but don't loop infinitely. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status1 =
 		devpriv->stc_readw(dev,
 				   Joint_Status_1_Register)) &
@@ -4026,6 +4042,12 @@ static int ni_serial_hw_readwrite8(struc
 			err = -ETIME;
 			goto Error;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Delay for last bit. This delay is absolutely necessary, because
diff -u -p a/staging/comedi/drivers/usbdux.c b/staging/comedi/drivers/usbdux.c
--- a/staging/comedi/drivers/usbdux.c
+++ b/staging/comedi/drivers/usbdux.c
@@ -1257,9 +1257,20 @@ static int usbdux_ai_cmd(struct comedi_d
 		 */
 		this_usbduxsub->ai_interval = 1;
 		/* find a power of 2 for the interval */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((this_usbduxsub->ai_interval) < (cmd->chanlist_len)) {
 			this_usbduxsub->ai_interval =
 			    (this_usbduxsub->ai_interval) * 2;
+			    if (_cur < timeout) {
+			rdstcll(_cur);
+			    }
+			    else {
+			break;
+			    }
 		}
 		this_usbduxsub->ai_timer = cmd->scan_begin_arg / (125000 *
 							  (this_usbduxsub->
diff -u -p a/staging/comedi/drivers/ni_pcidio.c b/staging/comedi/drivers/ni_pcidio.c
--- a/staging/comedi/drivers/ni_pcidio.c
+++ b/staging/comedi/drivers/ni_pcidio.c
@@ -559,7 +559,12 @@ static irqreturn_t nidio_interrupt(int i
 
 		if (flags & TransferReady) {
 			/* DPRINTK("TransferReady\n"); */
-			while (flags & TransferReady) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (flags & TransferReady) {
 				work++;
 				if (work > 100) {
 					DPRINTK("too much work in interrupt\n");
@@ -579,6 +584,12 @@ static irqreturn_t nidio_interrupt(int i
 				/* DPRINTK("read:%d, %d\n",data1,data2); */
 				flags = readb(devpriv->mite->daq_io_addr +
 					      Group_1_Flags);
+				if (_cur < timeout) {
+				    rdstcll(_cur);
+				}
+				else {
+				    break;
+				}
 			}
 			/* DPRINTK("buf_int_count: %d\n",
 				async->buf_int_count); */
@@ -700,9 +711,20 @@ static void debug_int(struct comedi_devi
 			(int)tv.tv_usec);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (b & 1) {
 		writew(0xff, devpriv->mite->daq_io_addr + Group_1_FIFO);
 		b = readb(devpriv->mite->daq_io_addr + Group_1_Flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	b = readb(devpriv->mite->daq_io_addr + Group_1_Flags);
diff -u -p a/staging/cxt1e1/hwprobe.c b/staging/cxt1e1/hwprobe.c
--- a/staging/cxt1e1/hwprobe.c
+++ b/staging/cxt1e1/hwprobe.c
@@ -305,12 +305,23 @@ c4hw_attach_all (void)
     error_flag = 0;
     prep_hdw_info ();
     /*** scan PCI bus for all possible boards */
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while ((pdev = pci_get_device (PCI_VENDOR_ID_CONEXANT,
                                     PCI_DEVICE_ID_CN8474,
                                     pdev)))
     {
         if (c4_hdw_init (pdev, found))
             found++;
+            if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
     if (!found)
     {
diff -u -p a/staging/cxt1e1/pmcc4_drv.c b/staging/cxt1e1/pmcc4_drv.c
--- a/staging/cxt1e1/pmcc4_drv.c
+++ b/staging/cxt1e1/pmcc4_drv.c
@@ -551,6 +551,11 @@ c4_cleanup (void)
     int         portnum, j;
 
     ci = c4_list;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (ci)
     {
         next = ci->next;            /* protect <next> from upcoming <free> */
@@ -569,6 +574,12 @@ c4_cleanup (void)
         OS_kfree (ci->iqd_p_saved);
         OS_kfree (ci);
         ci = next;                  /* cleanup next board, if any */
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
 }
 
diff -u -p a/staging/et131x/et131x.c b/staging/et131x/et131x.c
--- a/staging/et131x/et131x.c
+++ b/staging/et131x/et131x.c
@@ -2643,13 +2643,24 @@ void et131x_rx_dma_memory_free(struct et
 	/* Free RFDs and associated packet descriptors */
 	WARN_ON(rx_ring->num_ready_recv != rx_ring->num_rfd);
 
-	while (!list_empty(&rx_ring->recv_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&rx_ring->recv_list)) {
 		rfd = (struct rfd *) list_entry(rx_ring->recv_list.next,
 				struct rfd, list_node);
 
 		list_del(&rfd->list_node);
 		rfd->skb = NULL;
 		kmem_cache_free(adapter->rx_ring.recv_lookaside, rfd);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Free Free Buffer Ring 1 */
@@ -3760,6 +3771,11 @@ void et131x_handle_send_interrupt(struct
 
 	tcb = adapter->tx_ring.send_head;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tcb &&
 	       ((serviced ^ tcb->index) & ET_DMA10_WRAP) &&
 	       index < INDEX10(tcb->index)) {
@@ -3774,7 +3790,18 @@ void et131x_handle_send_interrupt(struct
 
 		/* Goto the next packet */
 		tcb = adapter->tx_ring.send_head;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tcb &&
 	       !((serviced ^ tcb->index) & ET_DMA10_WRAP)
 	       && index > (tcb->index & ET_DMA10_MASK)) {
@@ -3789,6 +3816,12 @@ void et131x_handle_send_interrupt(struct
 
 		/* Goto the next packet */
 		tcb = adapter->tx_ring.send_head;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Wake up the queue when we hit a low-water mark */
diff -u -p a/staging/ft1000/ft1000-pcmcia/ft1000_hw.c b/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
--- a/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
+++ b/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
@@ -804,6 +804,11 @@ static void ft1000_send_cmd (struct net_
     // Make sure SLOWQ doorbell is clear
     tempword = ft1000_read_reg(dev, FT1000_REG_DOORBELL);
     i=0;
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (tempword & FT1000_DB_DPRAM_TX) {
         mdelay(10);
         i++;
@@ -812,7 +817,13 @@ static void ft1000_send_cmd (struct net_
             return;
         }
         tempword = ft1000_read_reg(dev, FT1000_REG_DOORBELL);
-    }
+        if (_cur < timeout) {
+            rdstcll(_cur);
+		}
+		else {
+            break;
+		}
+	}
 
 	if (info->AsicID == ELECTRABUZZ_ID) {
 		ft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,
@@ -1998,6 +2009,11 @@ static irqreturn_t ft1000_interrupt(int
 	inttype = ft1000_read_reg(dev, FT1000_REG_SUP_ISR);
 
     // Make sure we process all interrupt before leaving the ISR due to the edge trigger interrupt type
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (inttype) {
 	if (inttype & ISR_DOORBELL_PEND) {
 		ft1000_parse_dpram_msg(dev);
@@ -2033,7 +2049,13 @@ static irqreturn_t ft1000_interrupt(int
         // Read interrupt type
         inttype = ft1000_read_reg (dev, FT1000_REG_SUP_ISR);
         DEBUG(1,"ft1000_hw: interrupt status register after clear = 0x%x\n",inttype);
-    }
+        if (_cur < timeout) {
+		rdstcll(_cur);
+        }
+        else {
+		break;
+        }
+	}
 	ft1000_enable_interrupts(dev);
 	return IRQ_HANDLED;
 }
diff -u -p a/staging/ft1000/ft1000-usb/ft1000_usb.c b/staging/ft1000/ft1000-usb/ft1000_usb.c
--- a/staging/ft1000/ft1000-usb/ft1000_usb.c
+++ b/staging/ft1000/ft1000-usb/ft1000_usb.c
@@ -41,6 +41,11 @@ int ft1000_poll_thread(void *arg)
 {
 	int ret = STATUS_SUCCESS;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		msleep(10);
 		if (!gPollingfailed) {
@@ -50,6 +55,12 @@ int ft1000_poll_thread(void *arg)
 				gPollingfailed = TRUE;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return STATUS_SUCCESS;
 }
@@ -183,6 +194,11 @@ static int ft1000_probe(struct usb_inter
 
 	msleep(500);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!pft1000info->CardReady) {
 		if (gPollingfailed) {
 			ret = -EIO;
@@ -190,6 +206,12 @@ static int ft1000_probe(struct usb_inter
 		}
 		msleep(100);
 		DEBUG("ft1000_probe::Waiting for Card Ready\n");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	DEBUG("ft1000_probe::Card Ready!!!! Registering network device\n");
diff -u -p a/staging/ft1000/ft1000-usb/ft1000_hw.c b/staging/ft1000/ft1000-usb/ft1000_hw.c
--- a/staging/ft1000/ft1000-usb/ft1000_hw.c
+++ b/staging/ft1000/ft1000-usb/ft1000_hw.c
@@ -1388,6 +1388,11 @@ static int ft1000_dsp_prov(void *arg)
 			break;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (tempword & FT1000_DB_DPRAM_TX) {
 			mdelay(10);
 			i++;
@@ -1397,6 +1402,12 @@ static int ft1000_dsp_prov(void *arg)
 			}
 			ft1000_read_register(dev, &tempword,
 					     FT1000_REG_DOORBELL);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (!(tempword & FT1000_DB_DPRAM_TX)) {
diff -u -p a/staging/gma500/mdfld_dsi_pkg_sender.c b/staging/gma500/mdfld_dsi_pkg_sender.c
--- a/staging/gma500/mdfld_dsi_pkg_sender.c
+++ b/staging/gma500/mdfld_dsi_pkg_sender.c
@@ -611,12 +611,23 @@ static void process_pkg_list(struct mdfl
 
 	spin_lock_irqsave(&sender->lock, flags);
 
-	while (!list_empty(&sender->pkg_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&sender->pkg_list)) {
 		pkg = list_first_entry(&sender->pkg_list,
 					struct mdfld_dsi_pkg, entry);
 		send_pkg(sender, pkg);
 		list_del_init(&pkg->entry);
 		pkg_sender_put_pkg_locked(sender, pkg);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	spin_unlock_irqrestore(&sender->lock, flags);
@@ -778,9 +789,20 @@ static int __read_panel_data(struct mdfl
 	pkg_sender_put_pkg_locked(sender, pkg);
 
 	/*polling read data avail interrupt*/
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retry && !(REG_READ(sender->mipi_intr_stat_reg) & (1 << 29))) {
 		udelay(100);
 		retry--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!retry) {
@@ -1081,10 +1103,21 @@ int mdfld_dsi_send_dcs(struct mdfld_dsi_
 		 * if not wait it becoming empty
 		 */
 		retry = MDFLD_DSI_DBI_FIFO_TIMEOUT;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (retry &&
 		    !(REG_READ(sender->mipi_gen_fifo_stat_reg) & (1 << 27))) {
 			udelay(500);
 			retry--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* If DBI FIFO timeout, drop this frame */
@@ -1100,10 +1133,21 @@ int mdfld_dsi_send_dcs(struct mdfld_dsi_
 					cb_phy | (1 << 0) | (1 << 1));
 
 		retry = MDFLD_DSI_DBI_FIFO_TIMEOUT;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (retry &&
 			(REG_READ(sender->mipi_cmd_addr_reg) & (1 << 0))) {
 			udelay(1);
 			retry--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 
 		spin_unlock(&sender->lock);
diff -u -p a/staging/gma500/mmu.c b/staging/gma500/mmu.c
--- a/staging/gma500/mmu.c
+++ b/staging/gma500/mmu.c
@@ -361,6 +361,11 @@ struct psb_mmu_pt *psb_mmu_pt_alloc_map_
 
 	spin_lock(lock);
 	pt = pd->tables[index];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!pt) {
 		spin_unlock(lock);
 		pt = psb_mmu_alloc_pt(pd);
@@ -386,6 +391,12 @@ struct psb_mmu_pt *psb_mmu_pt_alloc_map_
 			psb_mmu_clflush(pd->driver, (void *) &v[index]);
 			atomic_set(&pd->driver->needs_tlbflush, 1);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	pt->v = kmap_atomic(pt->p, KM_USER0);
 	return pt;
diff -u -p a/staging/gma500/accel_2d.c b/staging/gma500/accel_2d.c
--- a/staging/gma500/accel_2d.c
+++ b/staging/gma500/accel_2d.c
@@ -86,12 +86,23 @@ static int psb_2d_wait_available(struct
 	uint32_t avail = PSB_RSGX32(PSB_CR_2D_SOCIF);
 	unsigned long t = jiffies + HZ;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (avail < size) {
 		avail = PSB_RSGX32(PSB_CR_2D_SOCIF);
 		if (time_after(jiffies, t)) {
 			psb_spank(dev_priv);
 			return -EIO;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/staging/gma500/intel_bios.c b/staging/gma500/intel_bios.c
--- a/staging/gma500/intel_bios.c
+++ b/staging/gma500/intel_bios.c
@@ -39,6 +39,11 @@ static void *find_section(struct bdb_hea
 	total = bdb->bdb_size;
 
 	/* walk the sections looking for section_id */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (index < total) {
 		current_id = *(base + index);
 		index++;
@@ -47,6 +52,12 @@ static void *find_section(struct bdb_hea
 		if (current_id == section_id)
 			return base + index;
 		index += current_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
diff -u -p a/staging/gma500/mrst_hdmi.c b/staging/gma500/mrst_hdmi.c
--- a/staging/gma500/mrst_hdmi.c
+++ b/staging/gma500/mrst_hdmi.c
@@ -138,6 +138,11 @@ static void scu_busy_loop(void *scu_base
 	u32 loop_count = 0;
 
 	status = readl(scu_base + 0x04);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & 1) {
 		udelay(1); /* scu processing time is in few u secods */
 		status = readl(scu_base + 0x04);
@@ -147,6 +152,12 @@ static void scu_busy_loop(void *scu_base
 			DRM_DEBUG_KMS("SCU IPC timed out");
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/sbe-2t3e3/intr.c b/staging/sbe-2t3e3/intr.c
--- a/staging/sbe-2t3e3/intr.c
+++ b/staging/sbe-2t3e3/intr.c
@@ -60,6 +60,11 @@ void dc_intr(struct channel *sc)
 	/* grrr this clears interrupt summary bits !!! */
 	dc_write(sc->addr, SBE_2T3E3_21143_REG_INTERRUPT_ENABLE, 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((val = dc_read(sc->addr, SBE_2T3E3_21143_REG_STATUS)) &
 	       (SBE_2T3E3_21143_VAL_RECEIVE_PROCESS_STOPPED |
 		SBE_2T3E3_21143_VAL_RECEIVE_BUFFER_UNAVAILABLE |
@@ -107,6 +112,12 @@ void dc_intr(struct channel *sc)
 					"Transmit process stopped\n");
 			dc_intr_tx(sc);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* enable ethernet interrupts */
@@ -129,7 +140,12 @@ void dc_intr_rx(struct channel *sc)
 
 	/* when ethernet loopback is set, ignore framer signals */
 	if ((sc->p.loopback != SBE_2T3E3_LOOPBACK_ETHERNET) && sc->s.OOF) {
-		while (!(sc->ether.rx_ring[current_read].rdes0 &
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (!(sc->ether.rx_ring[current_read].rdes0 &
 			 SBE_2T3E3_RX_DESC_21143_OWN)) {
 			current_desc = &sc->ether.rx_ring[current_read];
 			current_desc->rdes1 &= SBE_2T3E3_RX_DESC_END_OF_RING |
@@ -137,12 +153,23 @@ void dc_intr_rx(struct channel *sc)
 			current_desc->rdes1 |= SBE_2T3E3_MTU;
 			current_desc->rdes0 = SBE_2T3E3_RX_DESC_21143_OWN;
 			current_read = (current_read + 1) % SBE_2T3E3_RX_DESC_RING_SIZE;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		sc->ether.rx_ring_current_read = current_read;
 		return;
 	}
 
-	while (!(sc->ether.rx_ring[current_read].rdes0 &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(sc->ether.rx_ring[current_read].rdes0 &
 		 SBE_2T3E3_RX_DESC_21143_OWN)) {
 		current_desc = &sc->ether.rx_ring[current_read];
 
@@ -281,6 +308,12 @@ void dc_intr_rx(struct channel *sc)
 		}
 		current_desc->rdes0 = SBE_2T3E3_RX_DESC_21143_OWN;
 		current_read = (current_read + 1) % SBE_2T3E3_RX_DESC_RING_SIZE;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sc->ether.rx_ring_current_read = current_read;
diff -u -p a/staging/rts_pstor/spi.c b/staging/rts_pstor/spi.c
--- a/staging/rts_pstor/spi.c
+++ b/staging/rts_pstor/spi.c
@@ -509,6 +509,11 @@ int spi_read_flash(struct scsi_cmnd *srb
 	if (buf == NULL)
 		TRACE_RET(chip, STATUS_ERROR);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		u16 pagelen = SF_PAGE_LEN - (u8)addr;
 
@@ -553,6 +558,12 @@ int spi_read_flash(struct scsi_cmnd *srb
 
 		addr += pagelen;
 		len -= pagelen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	scsi_set_resid(srb, 0);
@@ -588,6 +599,11 @@ int spi_write_flash(struct scsi_cmnd *sr
 		if (!buf)
 			TRACE_RET(chip, STATUS_ERROR);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			retval = sf_enable_write(chip, SPI_WREN);
 			if (retval != STATUS_SUCCESS) {
@@ -619,6 +635,12 @@ int spi_write_flash(struct scsi_cmnd *sr
 
 			addr++;
 			len--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kfree(buf);
@@ -634,6 +656,11 @@ int spi_write_flash(struct scsi_cmnd *sr
 		if (!buf)
 			TRACE_RET(chip, STATUS_ERROR);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			rtsx_stor_access_xfer_buf(buf, 1, srb, &index, &offset, FROM_XFER_BUF);
 
@@ -663,6 +690,12 @@ int spi_write_flash(struct scsi_cmnd *sr
 			}
 
 			len--;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kfree(buf);
@@ -679,6 +712,11 @@ int spi_write_flash(struct scsi_cmnd *sr
 		if (!buf)
 			TRACE_RET(chip, STATUS_NOMEM);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			u16 pagelen = SF_PAGE_LEN - (u8)addr;
 
@@ -716,6 +754,12 @@ int spi_write_flash(struct scsi_cmnd *sr
 
 			addr += pagelen;
 			len -= pagelen;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		kfree(buf);
diff -u -p a/staging/rts_pstor/rtsx_transport.c b/staging/rts_pstor/rtsx_transport.c
--- a/staging/rts_pstor/rtsx_transport.c
+++ b/staging/rts_pstor/rtsx_transport.c
@@ -80,7 +80,12 @@ unsigned int rtsx_stor_access_xfer_buf(u
 		 * and the starting offset within the page, and update
 		 * the *offset and *index values for the next loop. */
 		cnt = 0;
-		while (cnt < buflen && *index < scsi_sg_count(srb)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (cnt < buflen && *index < scsi_sg_count(srb)) {
 			struct page *page = sg_page(sg) +
 					((sg->offset + *offset) >> PAGE_SHIFT);
 			unsigned int poff =
@@ -120,6 +125,12 @@ unsigned int rtsx_stor_access_xfer_buf(u
 				cnt += plen;
 				sglen -= plen;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/staging/rts_pstor/rtsx_scsi.c b/staging/rts_pstor/rtsx_scsi.c
--- a/staging/rts_pstor/rtsx_scsi.c
+++ b/staging/rts_pstor/rtsx_scsi.c
@@ -856,6 +856,11 @@ static int read_format_capacity(struct s
 		desc_cnt = 1;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (desc_cnt) {
 		if (check_card_ready(chip, lun)) {
 			card_size = get_card_size(chip, lun);
@@ -887,6 +892,12 @@ static int read_format_capacity(struct s
 		buf[i++] = 0x00;
 
 		desc_cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	buf_len = min(scsi_bufflen(srb), buf_len);
diff -u -p a/staging/octeon/cvmx-helper-util.c b/staging/octeon/cvmx-helper-util.c
--- a/staging/octeon/cvmx-helper-util.c
+++ b/staging/octeon/cvmx-helper-util.c
@@ -129,7 +129,12 @@ int cvmx_helper_dump_packet(cvmx_wqe_t *
 		buffer_ptr = work->packet_ptr;
 	remaining_bytes = work->len;
 
-	while (remaining_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (remaining_bytes) {
 		start_of_buffer =
 		    ((buffer_ptr.s.addr >> 7) - buffer_ptr.s.back) << 7;
 		cvmx_dprintf("    Buffer Start:%llx\n",
@@ -163,6 +168,12 @@ int cvmx_helper_dump_packet(cvmx_wqe_t *
 		if (remaining_bytes)
 			buffer_ptr = *(union cvmx_buf_ptr *)
 				cvmx_phys_to_ptr(buffer_ptr.s.addr - 8);
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 	}
 	return 0;
 }
diff -u -p a/staging/octeon/ethernet-tx.c b/staging/octeon/ethernet-tx.c
--- a/staging/octeon/ethernet-tx.c
+++ b/staging/octeon/ethernet-tx.c
@@ -123,10 +123,21 @@ void cvm_oct_free_tx_skbs(struct net_dev
 			}
 			spin_unlock_irqrestore(&priv->tx_free_list[qos].lock, flags);
 			/* Do the actual freeing outside of the lock. */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (to_free_list) {
 				struct sk_buff *t = to_free_list;
 				to_free_list = to_free_list->next;
 				dev_kfree_skb_any(t);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		total_remaining += skb_queue_len(&priv->tx_free_list[qos]);
@@ -479,10 +490,21 @@ skip_xmit:
 	spin_unlock_irqrestore(&priv->tx_free_list[qos].lock, flags);
 
 	/* Do the actual freeing outside of the lock. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (to_free_list) {
 		struct sk_buff *t = to_free_list;
 		to_free_list = to_free_list->next;
 		dev_kfree_skb_any(t);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (USE_ASYNC_IOBDMA) {
diff -u -p a/staging/octeon/cvmx-spi.c b/staging/octeon/cvmx-spi.c
--- a/staging/octeon/cvmx-spi.c
+++ b/staging/octeon/cvmx-spi.c
@@ -326,6 +326,11 @@ int cvmx_spi_calendar_setup_cb(int inter
 		/* SRX0 Calendar Table. This round robbins through all ports */
 		port = 0;
 		index = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (port < num_ports) {
 			union cvmx_srxx_spi4_calx srxx_spi4_calx;
 			srxx_spi4_calx.u64 = 0;
@@ -338,6 +343,12 @@ int cvmx_spi_calendar_setup_cb(int inter
 			cvmx_write_csr(CVMX_SRXX_SPI4_CALX(index, interface),
 				       srxx_spi4_calx.u64);
 			index++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		srxx_spi4_stat.u64 = 0;
 		srxx_spi4_stat.s.len = num_ports;
@@ -389,6 +400,11 @@ int cvmx_spi_calendar_setup_cb(int inter
 		/* STX0 Calendar Table. This round robbins through all ports */
 		port = 0;
 		index = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (port < num_ports) {
 			union cvmx_stxx_spi4_calx stxx_spi4_calx;
 			stxx_spi4_calx.u64 = 0;
@@ -401,6 +417,12 @@ int cvmx_spi_calendar_setup_cb(int inter
 			cvmx_write_csr(CVMX_STXX_SPI4_CALX(index, interface),
 				       stxx_spi4_calx.u64);
 			index++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		stxx_spi4_stat.u64 = 0;
 		stxx_spi4_stat.s.len = num_ports;
diff -u -p a/staging/serial/68360serial.c b/staging/serial/68360serial.c
--- a/staging/serial/68360serial.c
+++ b/staging/serial/68360serial.c
@@ -1477,6 +1477,11 @@ static int rs_360_ioctl(struct tty_struc
 			/* note the counters on entry */
 			cprev = info->state->icount;
 			local_irq_enable();
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (1) {
 				interruptible_sleep_on(&info->delta_msr_wait);
 				/* see if a signal did it */
@@ -1495,7 +1500,13 @@ static int rs_360_ioctl(struct tty_struc
 					return 0;
 				}
 				cprev = cnow;
-			}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
+}
 			/* NOTREACHED */
 #else
 			return 0;
diff -u -p a/staging/tidspbridge/gen/gh.c b/staging/tidspbridge/gen/gh.c
--- a/staging/tidspbridge/gen/gh.c
+++ b/staging/tidspbridge/gen/gh.c
@@ -186,9 +186,20 @@ void gh_iterate(struct gh_t_hash_tab *ha
 	if (hash_tab && hash_tab->buckets)
 		for (i = 0; i < hash_tab->max_bucket; i++) {
 			elem = hash_tab->buckets[i];
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (elem) {
 				callback(&elem->data, user_data);
 				elem = elem->next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 }
diff -u -p a/staging/tidspbridge/core/tiomap3430.c b/staging/tidspbridge/core/tiomap3430.c
--- a/staging/tidspbridge/core/tiomap3430.c
+++ b/staging/tidspbridge/core/tiomap3430.c
@@ -1232,6 +1232,11 @@ static int bridge_brd_mem_map(struct bri
 	 * spread across several VMAs. So loop through and check if the entire
 	 * user buffer is covered
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((vma) && (ul_mpu_addr + ul_num_bytes > vma->vm_end)) {
 		/* jump to the next VMA region */
 		vma = find_vma(mm, vma->vm_end + 1);
@@ -1240,6 +1245,12 @@ static int bridge_brd_mem_map(struct bri
 			"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n", ul_mpu_addr,
 			ul_num_bytes, vma->vm_start, vma->vm_end,
 			vma->vm_flags);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	if (!vma) {
 		pr_err("%s: Failed to get VMA region for 0x%x (%d)\n",
@@ -1383,6 +1394,11 @@ static int bridge_brd_mem_un_map(struct
 		"pte_addr_l1 %x\n", __func__, dev_ctxt, virt_addr,
 		ul_num_bytes, l1_base_va, pte_addr_l1);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rem_bytes && !status) {
 		u32 va_curr_orig = va_curr;
 		/* Find whether the L1 PTE points to a valid L2 PT */
@@ -1527,7 +1543,13 @@ skip_coarse_page:
 			status = -EPERM;
 			goto EXIT_LOOP;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 	/*
 	 * It is better to flush the TLB here, so that any stale old entries
 	 * get flushed
@@ -1589,6 +1611,11 @@ static int pte_update(struct bridge_dev_
 		HW_PAGE_SIZE64KB, HW_PAGE_SIZE4KB
 	};
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num_bytes && !status) {
 		/* To find the max. page size with which both PA & VA are
 		 * aligned */
@@ -1610,6 +1637,12 @@ static int pte_update(struct bridge_dev_
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return status;
diff -u -p a/staging/tidspbridge/core/chnl_sm.c b/staging/tidspbridge/core/chnl_sm.c
--- a/staging/tidspbridge/core/chnl_sm.c
+++ b/staging/tidspbridge/core/chnl_sm.c
@@ -475,7 +475,12 @@ int bridge_chnl_flush_io(struct chnl_obj
 		    && (pchnl->chnl_type == CHNL_PCPY)) {
 			/* Wait for IO completions, up to the specified
 			 * timeout: */
-			while (!list_empty(&pchnl->io_requests) && !status) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (!list_empty(&pchnl->io_requests) && !status) {
 				status = bridge_chnl_get_ioc(chnl_obj,
 						timeout, &chnl_ioc_obj);
 				if (status)
@@ -484,6 +489,12 @@ int bridge_chnl_flush_io(struct chnl_obj
 				if (chnl_ioc_obj.status & CHNL_IOCSTATTIMEOUT)
 					status = -ETIMEDOUT;
 
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 			}
 		} else {
 			status = bridge_chnl_cancel_io(chnl_obj);
diff -u -p a/staging/tidspbridge/core/io_sm.c b/staging/tidspbridge/core/io_sm.c
--- a/staging/tidspbridge/core/io_sm.c
+++ b/staging/tidspbridge/core/io_sm.c
@@ -468,7 +468,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 	map_attrs |= DSP_MAPELEMSIZE32;
 	map_attrs |= DSP_MAPDONOTLOCK;
 
-	while (num_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_bytes) {
 		/*
 		 * To find the max. page size with which both PA & VA are
 		 * aligned.
@@ -501,6 +506,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	pa_curr += ul_pad_size;
 	va_curr += ul_pad_size;
@@ -509,7 +520,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 	/* Configure the TLB entries for the next cacheable segment */
 	num_bytes = ul_seg_size;
 	va_curr = ul_dsp_va * hio_mgr->word_size;
-	while (num_bytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (num_bytes) {
 		/*
 		 * To find the max. page size with which both PA & VA are
 		 * aligned.
@@ -573,6 +589,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 			 */
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -636,7 +658,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 
 	/* Map the L4 peripherals */
 	i = 0;
-	while (l4_peripheral_table[i].phys_addr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (l4_peripheral_table[i].phys_addr) {
 		status = hio_mgr->intf_fxns->brd_mem_map
 		    (hio_mgr->bridge_context, l4_peripheral_table[i].phys_addr,
 		     l4_peripheral_table[i].dsp_virt_addr, HW_PAGE_SIZE4KB,
@@ -644,6 +671,12 @@ int bridge_io_on_loaded(struct io_mgr *h
 		if (status)
 			goto func_end;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	for (i = ndx; i < BRDIOCTL_NUMOFMMUTLB; i++) {
@@ -1857,7 +1890,12 @@ int print_dsp_trace_buffer(struct bridge
 			str_beg = trace_end;
 			ul_num_bytes = buf_end - str_beg;
 
-			while (str_beg < buf_end) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (str_beg < buf_end) {
 				new_line = strnchr(str_beg, ul_num_bytes,
 								'\n');
 				if (new_line && new_line < buf_end) {
@@ -1877,6 +1915,12 @@ int print_dsp_trace_buffer(struct bridge
 					str_beg = buf_end;
 					ul_num_bytes = 0;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			/*
 			 * Search buffer for a nNewLine and replace it
@@ -1886,6 +1930,11 @@ int print_dsp_trace_buffer(struct bridge
 			str_beg = psz_buf;
 			ul_num_bytes = trace_end - str_beg;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (str_beg < trace_end) {
 				new_line = strnchr(str_beg, ul_num_bytes, '\n');
 				if (new_line != NULL && new_line < trace_end) {
@@ -1905,6 +1954,12 @@ int print_dsp_trace_buffer(struct bridge
 					str_beg = trace_end;
 					ul_num_bytes = 0;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		pr_info("\n=======================\n"
diff -u -p a/staging/tidspbridge/core/msg_sm.c b/staging/tidspbridge/core/msg_sm.c
--- a/staging/tidspbridge/core/msg_sm.c
+++ b/staging/tidspbridge/core/msg_sm.c
@@ -221,12 +221,23 @@ void bridge_msg_delete_queue(struct msg_
 	msg_queue_obj->done = true;
 	/*  Unblock all threads blocked in MSG_Get() or MSG_Put(). */
 	io_msg_pend = msg_queue_obj->io_msg_pend;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (io_msg_pend) {
 		/* Unblock thread */
 		sync_set_event(msg_queue_obj->sync_done);
 		/* Wait for acknowledgement */
 		sync_wait_on_event(msg_queue_obj->sync_done_ack, SYNC_INFINITE);
 		io_msg_pend = msg_queue_obj->io_msg_pend;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* Remove message queue from hmsg_mgr->queue_list */
 	spin_lock_bh(&hmsg_mgr->msg_mgr_lock);
diff -u -p a/staging/tidspbridge/pmgr/dmm.c b/staging/tidspbridge/pmgr/dmm.c
--- a/staging/tidspbridge/pmgr/dmm.c
+++ b/staging/tidspbridge/pmgr/dmm.c
@@ -374,6 +374,11 @@ int dmm_un_reserve_memory(struct dmm_obj
 	if (!status) {
 		/* Free all the mapped pages for this reserved region */
 		i = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (i < chunk->region_size) {
 			if (chunk[i].mapped) {
 				/* Remove mapping from the page tables. */
@@ -384,6 +389,12 @@ int dmm_un_reserve_memory(struct dmm_obj
 				i += chunk_size;
 			} else
 				i++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 		/* Clear the flags (mark the region 'free') */
 		chunk->reserved = false;
diff -u -p a/staging/tidspbridge/pmgr/dbll.c b/staging/tidspbridge/pmgr/dbll.c
--- a/staging/tidspbridge/pmgr/dbll.c
+++ b/staging/tidspbridge/pmgr/dbll.c
@@ -878,9 +878,20 @@ static u16 name_hash(void *key, u16 max_
 
 	hash = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*name) {
 		hash <<= 1;
 		hash ^= *name++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = hash % max_bucket;
diff -u -p a/staging/tidspbridge/rmgr/rmm.c b/staging/tidspbridge/rmgr/rmm.c
--- a/staging/tidspbridge/rmgr/rmm.c
+++ b/staging/tidspbridge/rmgr/rmm.c
@@ -264,10 +264,21 @@ void rmm_delete(struct rmm_target_obj *t
 		/* Free elements on freelist */
 		for (i = 0; i < target->num_segs; i++) {
 			hptr = next = target->free_list[i];
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (next) {
 				hptr = next;
 				next = hptr->next;
 				kfree(hptr);
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 		kfree(target->free_list);
diff -u -p a/staging/tidspbridge/rmgr/nldr.c b/staging/tidspbridge/rmgr/nldr.c
--- a/staging/tidspbridge/rmgr/nldr.c
+++ b/staging/tidspbridge/rmgr/nldr.c
@@ -612,30 +612,74 @@ void nldr_delete(struct nldr_object *nld
 		for (i = 0; i < nldr_obj->ovly_nodes; i++) {
 			ovly_section =
 			    nldr_obj->ovly_table[i].create_sects_list;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			ovly_section =
 			    nldr_obj->ovly_table[i].delete_sects_list;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			ovly_section =
 			    nldr_obj->ovly_table[i].execute_sects_list;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 			ovly_section = nldr_obj->ovly_table[i].other_sects_list;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (ovly_section) {
 				next = ovly_section->next_sect;
 				kfree(ovly_section);
 				ovly_section = next;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 		kfree(nldr_obj->ovly_table);
@@ -1122,7 +1166,12 @@ static void free_sects(struct nldr_objec
 	u16 i = 0;
 	bool ret;
 
-	while (ovly_section && i < alloc_num) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ovly_section && i < alloc_num) {
 		/* 'Deallocate' */
 		/* segid - page not supported yet */
 		/* Reserved memory */
@@ -1132,6 +1181,12 @@ static void free_sects(struct nldr_objec
 		DBC_ASSERT(ret);
 		ovly_section = ovly_section->next_sect;
 		i++;
+		if (_cur < timeout) {
+		    rdstcll(_cur);
+		}
+		else {
+		    break;
+		}
 	}
 }
 
@@ -1550,7 +1605,12 @@ static int load_ovly(struct nldr_nodeobj
 		if (!status) {
 			/* Load sections for this phase */
 			ovly_section = phase_sects;
-			while (ovly_section && !status) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (ovly_section && !status) {
 				bytes =
 				    (*nldr_obj->ovly_fxn) (nldr_node_obj->
 							   priv_ref,
@@ -1564,6 +1624,12 @@ static int load_ovly(struct nldr_nodeobj
 					status = -EPERM;
 
 				ovly_section = ovly_section->next_sect;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
@@ -1571,7 +1637,12 @@ static int load_ovly(struct nldr_nodeobj
 		if (!status) {
 			/* Load other sections (create phase) */
 			ovly_section = other_sects_list;
-			while (ovly_section && !status) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while (ovly_section && !status) {
 				bytes =
 				    (*nldr_obj->ovly_fxn) (nldr_node_obj->
 							   priv_ref,
@@ -1585,6 +1656,12 @@ static int load_ovly(struct nldr_nodeobj
 					status = -EPERM;
 
 				ovly_section = ovly_section->next_sect;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
diff -u -p a/staging/tidspbridge/rmgr/proc.c b/staging/tidspbridge/rmgr/proc.c
--- a/staging/tidspbridge/rmgr/proc.c
+++ b/staging/tidspbridge/rmgr/proc.c
@@ -639,6 +639,11 @@ static int build_dma_sg(struct dmm_map_o
 	int ret = 0, i = 0;
 	struct scatterlist *sg = map_obj->dma_info.sg;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		page = get_mapping_page(map_obj, pg_i);
 		if (!page) {
@@ -660,6 +665,12 @@ static int build_dma_sg(struct dmm_map_o
 		len -= rest;
 		start += rest;
 		pg_i++, i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (i != map_obj->dma_info.num_pages) {
diff -u -p a/staging/tidspbridge/dynload/reloc.c b/staging/tidspbridge/dynload/reloc.c
--- a/staging/tidspbridge/dynload/reloc.c
+++ b/staging/tidspbridge/dynload/reloc.c
@@ -61,10 +61,21 @@ rvalue dload_unpack(struct dload_state *
 		direction = 1;
 	objval = *dp >> offset;
 	shift = TGTAU_BITS - offset;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (shift <= fieldsz) {
 		dp += direction;
 		objval += (rvalue) *dp << shift;
 		shift += TGTAU_BITS;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* * sign or zero extend the value appropriately */
@@ -123,11 +134,22 @@ int dload_repack(struct dload_state *dlt
 	objval >>= shift;
 	mask >>= shift;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mask) {
 		dp += direction;
 		*dp = (*dp & ~mask) + objval;
 		objval >>= TGTAU_BITS;
 		mask >>= TGTAU_BITS;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -190,6 +212,11 @@ void dload_relocate(struct dload_state *
 							   image_packet_t));
 
 	rx = HASH_FUNC(rp->TYPE);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rop_map1[rx] != rp->TYPE) {
 		rx = HASH_L(rop_map2[rx]);
 		if (rx < 0) {
@@ -210,6 +237,12 @@ void dload_relocate(struct dload_state *
 #endif
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	rx = HASH_I(rop_map2[rx]);
 	if ((rx < (sizeof(rop_action) / sizeof(u16)))
diff -u -p a/staging/vt6655/80211mgr.c b/staging/vt6655/80211mgr.c
--- a/staging/vt6655/80211mgr.c
+++ b/staging/vt6655/80211mgr.c
@@ -141,6 +141,11 @@ vMgrDecodeBeacon(
     // Information elements
     pItem = (PWLAN_IE)((unsigned char *)(WLAN_HDR_A3_DATA_PTR(&(pFrame->pHdr->sA3)))
                        + WLAN_BEACON_OFF_SSID);
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while( ((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len) ){
 
         switch (pItem->byElementID) {
@@ -224,6 +229,12 @@ vMgrDecodeBeacon(
 
         }
         pItem = (PWLAN_IE)(((unsigned char *)pItem) + 2 + pItem->len);
+        if (_cur < timeout) {
+                rdstcll(_cur);
+        }
+        else {
+                break;
+        }
     }
 
     return;
@@ -386,6 +397,11 @@ vMgrDecodeAssocRequest(
     pItem = (PWLAN_IE)(WLAN_HDR_A3_DATA_PTR(&(pFrame->pHdr->sA3))
                             + WLAN_ASSOCREQ_OFF_SSID);
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len)) {
         switch (pItem->byElementID){
             case WLAN_EID_SSID:
@@ -419,6 +435,12 @@ vMgrDecodeAssocRequest(
                 break;
         }
         pItem = (PWLAN_IE)(((unsigned char *)pItem) + 2 + pItem->len);
+        if (_cur < timeout) {
+                rdstcll(_cur);
+        }
+        else {
+                break;
+        }
     }
     return;
 }
@@ -565,6 +587,11 @@ vMgrDecodeReassocRequest(
     pItem = (PWLAN_IE)(WLAN_HDR_A3_DATA_PTR(&(pFrame->pHdr->sA3))
                        + WLAN_REASSOCREQ_OFF_SSID);
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while(((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID){
@@ -599,6 +626,12 @@ vMgrDecodeReassocRequest(
                 break;
         }
         pItem = (PWLAN_IE)(((unsigned char *)pItem) + 2 + pItem->len);
+        if (_cur < timeout) {
+                rdstcll(_cur);
+        }
+        else {
+                break;
+        }
     }
     return;
 }
@@ -650,6 +683,11 @@ vMgrDecodeProbeRequest(
     // Information elements
     pItem = (PWLAN_IE)(WLAN_HDR_A3_DATA_PTR(&(pFrame->pHdr->sA3)));
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while( ((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len) ) {
 
         switch (pItem->byElementID) {
@@ -674,6 +712,12 @@ vMgrDecodeProbeRequest(
         }
 
         pItem = (PWLAN_IE)(((unsigned char *)pItem) + 2 +  pItem->len);
+        if (_cur < timeout) {
+                rdstcll(_cur);
+        }
+        else {
+                break;
+        }
     }
     return;
 }
@@ -747,6 +791,11 @@ vMgrDecodeProbeResponse(
     pItem = (PWLAN_IE)(WLAN_HDR_A3_DATA_PTR(&(pFrame->pHdr->sA3))
                        + WLAN_PROBERESP_OFF_SSID);
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while( ((unsigned char *)pItem) < (pFrame->pBuf + pFrame->len) ) {
         switch (pItem->byElementID) {
             case WLAN_EID_SSID:
@@ -823,6 +872,12 @@ vMgrDecodeProbeResponse(
         }
 
         pItem = (PWLAN_IE)(((unsigned char *)pItem) + 2 +  pItem->len);
+        if (_cur < timeout) {
+                rdstcll(_cur);
+        }
+        else {
+                break;
+        }
     }
     return;
 }
diff -u -p a/staging/vt6656/main_usb.c b/staging/vt6656/main_usb.c
--- a/staging/vt6656/main_usb.c
+++ b/staging/vt6656/main_usb.c
@@ -1340,11 +1340,22 @@ static unsigned char *kstrstr(const unsi
   int str1_len = strlen(str1);
   int str2_len = strlen(str2);
 
-  while (str1_len >= str2_len) {
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+      unsigned long long timeout;
+      timeout = rdstcll(start) + delta;
+      while (str1_len >= str2_len) {
        str1_len--;
       if(memcmp(str1,str2,str2_len)==0)
 	return (unsigned char *) str1;
         str1++;
+        if (_cur < timeout) {
+          rdstcll(_cur);
+        }
+        else {
+          break;
+        }
   }
   return NULL;
 }
diff -u -p a/staging/vt6656/wcmd.c b/staging/vt6656/wcmd.c
--- a/staging/vt6656/wcmd.c
+++ b/staging/vt6656/wcmd.c
@@ -450,9 +450,20 @@ void vRunCommand(void *hDeviceContext)
                 }
                 pMgmt->uScanChannel++;
 
-                while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
+                unsigned long long delta = (cpu / khz / HZ) * 2;
+                unsigned long long _start = 0;
+                unsigned long long _cur = 0;
+                unsigned long long timeout;
+                    timeout = rdstcll(start) + delta;
+                    while (!ChannelValid(pDevice->byZoneType, pMgmt->uScanChannel) &&
                         pMgmt->uScanChannel <= pDevice->byMaxChannel ){
                     pMgmt->uScanChannel++;
+                    if (_cur < timeout) {
+                    rdstcll(_cur);
+                    }
+                    else {
+                    break;
+                    }
                 }
 
                 if (pMgmt->uScanChannel > pDevice->byMaxChannel) {
diff -u -p a/staging/vt6656/80211mgr.c b/staging/vt6656/80211mgr.c
--- a/staging/vt6656/80211mgr.c
+++ b/staging/vt6656/80211mgr.c
@@ -141,6 +141,11 @@ vMgrDecodeBeacon(
     /* Information elements */
     pItem = (PWLAN_IE)((PBYTE)(WLAN_HDR_A3_DATA_PTR(&(pFrame->pHdr->sA3)))
                        + WLAN_BEACON_OFF_SSID);
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID) {
@@ -223,6 +228,12 @@ vMgrDecodeBeacon(
 
         }
         pItem = (PWLAN_IE)(((PBYTE)pItem) + 2 + pItem->len);
+        if (_cur < timeout) {
+                rdstcll(_cur);
+        }
+        else {
+                break;
+        }
     }
 
     return;
@@ -385,6 +396,11 @@ vMgrDecodeAssocRequest(
     pItem = (PWLAN_IE)(WLAN_HDR_A3_DATA_PTR(&(pFrame->pHdr->sA3))
                             + WLAN_ASSOCREQ_OFF_SSID);
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
         switch (pItem->byElementID) {
         case WLAN_EID_SSID:
@@ -417,6 +433,12 @@ vMgrDecodeAssocRequest(
             break;
         }
         pItem = (PWLAN_IE)(((PBYTE)pItem) + 2 + pItem->len);
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
     return;
 }
@@ -561,6 +583,11 @@ vMgrDecodeReassocRequest(
     pItem = (PWLAN_IE)(WLAN_HDR_A3_DATA_PTR(&(pFrame->pHdr->sA3))
                        + WLAN_REASSOCREQ_OFF_SSID);
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID) {
@@ -594,6 +621,12 @@ vMgrDecodeReassocRequest(
             break;
         }
         pItem = (PWLAN_IE)(((PBYTE)pItem) + 2 + pItem->len);
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
     return;
 }
@@ -645,6 +678,11 @@ vMgrDecodeProbeRequest(
     /* Information elements */
     pItem = (PWLAN_IE)(WLAN_HDR_A3_DATA_PTR(&(pFrame->pHdr->sA3)));
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
 
         switch (pItem->byElementID) {
@@ -669,6 +707,12 @@ vMgrDecodeProbeRequest(
         }
 
         pItem = (PWLAN_IE)(((PBYTE)pItem) + 2 +  pItem->len);
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
     return;
 }
@@ -742,6 +786,11 @@ vMgrDecodeProbeResponse(
     pItem = (PWLAN_IE)(WLAN_HDR_A3_DATA_PTR(&(pFrame->pHdr->sA3))
                        + WLAN_PROBERESP_OFF_SSID);
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while (((PBYTE)pItem) < (pFrame->pBuf + pFrame->len)) {
         switch (pItem->byElementID) {
         case WLAN_EID_SSID:
@@ -817,6 +866,12 @@ vMgrDecodeProbeResponse(
         }
 
         pItem = (PWLAN_IE)(((PBYTE)pItem) + 2 +  pItem->len);
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
     return;
 }
diff -u -p a/staging/frontier/alphatrack.c b/staging/frontier/alphatrack.c
--- a/staging/frontier/alphatrack.c
+++ b/staging/frontier/alphatrack.c
@@ -498,7 +498,12 @@ static ssize_t usb_alphatrack_read(struc
 		goto unlock_exit;
 	}
 
-	while (dev->ring_head == dev->ring_tail) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (dev->ring_head == dev->ring_tail) {
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EAGAIN;
 			goto unlock_exit;
@@ -509,6 +514,12 @@ static ssize_t usb_alphatrack_read(struc
 					     dev->interrupt_in_done);
 		if (retval < 0)
 			goto unlock_exit;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	alphatrack_ocmd_info(&dev->intf->dev,
@@ -516,6 +527,11 @@ static ssize_t usb_alphatrack_read(struc
 			     ": copying to userspace");
 
 	c = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((c < count) && (dev->ring_tail != dev->ring_head)) {
 		if (copy_to_user
 		    (&buffer[c], &(*dev->ring_buffer)[dev->ring_tail],
@@ -527,6 +543,12 @@ static ssize_t usb_alphatrack_read(struc
 		c += INPUT_CMD_SIZE;
 		dbg_info(&dev->intf->dev, "%s: head, tail are %x, %x\n",
 			 __func__, dev->ring_head, dev->ring_tail);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	retval = c;
 
diff -u -p a/staging/zcache/zcache-main.c b/staging/zcache/zcache-main.c
--- a/staging/zcache/zcache-main.c
+++ b/staging/zcache/zcache-main.c
@@ -1001,7 +1001,12 @@ static int zcache_do_preload(struct tmem
 		goto out;
 	preempt_disable();
 	kp = &__get_cpu_var(zcache_preloads);
-	while (kp->nr < ARRAY_SIZE(kp->objnodes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (kp->nr < ARRAY_SIZE(kp->objnodes)) {
 		preempt_enable_no_resched();
 		objnode = kmem_cache_alloc(zcache_objnode_cache,
 				ZCACHE_GFP_MASK);
@@ -1015,6 +1020,12 @@ static int zcache_do_preload(struct tmem
 			kp->objnodes[kp->nr++] = objnode;
 		else
 			kmem_cache_free(zcache_objnode_cache, objnode);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	preempt_enable_no_resched();
 	obj = kmem_cache_alloc(zcache_obj_cache, ZCACHE_GFP_MASK);
@@ -1334,11 +1345,22 @@ static int zcache_cpu_notifier(struct no
 		kfree(per_cpu(zcache_workmem, cpu));
 		per_cpu(zcache_workmem, cpu) = NULL;
 		kp = &per_cpu(zcache_preloads, cpu);
-		while (kp->nr) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (kp->nr) {
 			kmem_cache_free(zcache_objnode_cache,
 					kp->objnodes[kp->nr - 1]);
 			kp->objnodes[kp->nr - 1] = NULL;
 			kp->nr--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if (kp->obj) {
 			kmem_cache_free(zcache_obj_cache, kp->obj);
diff -u -p a/staging/zcache/tmem.c b/staging/zcache/tmem.c
--- a/staging/zcache/tmem.c
+++ b/staging/zcache/tmem.c
@@ -80,6 +80,11 @@ static struct tmem_obj *tmem_obj_find(st
 	struct tmem_obj *obj;
 
 	rbnode = hb->obj_rb_root.rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rbnode) {
 		BUG_ON(RB_EMPTY_NODE(rbnode));
 		obj = rb_entry(rbnode, struct tmem_obj, rb_tree_node);
@@ -93,6 +98,12 @@ static struct tmem_obj *tmem_obj_find(st
 			rbnode = rbnode->rb_right;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	obj = NULL;
 out:
@@ -144,6 +155,11 @@ static void tmem_obj_init(struct tmem_ob
 	obj->pampd_count = 0;
 	(*tmem_pamops.new_obj)(obj);
 	SET_SENTINEL(obj, OBJ);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*new) {
 		BUG_ON(RB_EMPTY_NODE(*new));
 		this = rb_entry(*new, struct tmem_obj, rb_tree_node);
@@ -159,6 +175,12 @@ static void tmem_obj_init(struct tmem_ob
 			new = &(*new)->rb_right;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	rb_link_node(&obj->rb_tree_node, parent, new);
 	rb_insert_color(&obj->rb_tree_node, root);
@@ -433,6 +455,11 @@ static void *tmem_pampd_delete_from_obj(
 	} while (height > 0);
 	if (slot == NULL)
 		goto out;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (pathp->objnode) {
 		pathp->objnode->slots[pathp->offset] = NULL;
 		pathp->objnode->slots_in_use--;
@@ -456,6 +483,12 @@ static void *tmem_pampd_delete_from_obj(
 		}
 		tmem_objnode_free(pathp->objnode); /* 0 slots used, free it */
 		pathp--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	obj->objnode_tree_height = 0;
 	obj->objnode_tree_root = NULL;
diff -u -p a/staging/asus_oled/asus_oled.c b/staging/asus_oled/asus_oled.c
--- a/staging/asus_oled/asus_oled.c
+++ b/staging/asus_oled/asus_oled.c
@@ -563,6 +563,11 @@ static ssize_t odev_set_picture(struct a
 
 	max_offs = odev->width * odev->height;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (offs < count && odev->buf_offs < max_offs) {
 		int ret = 0;
 
@@ -588,6 +593,12 @@ static ssize_t odev_set_picture(struct a
 		}
 
 		offs++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	if (odev->buf_offs >= max_offs)
diff -u -p a/staging/winbond/mds.c b/staging/winbond/mds.c
--- a/staging/winbond/mds.c
+++ b/staging/winbond/mds.c
@@ -209,6 +209,11 @@ static u16 Mds_BodyCopy(struct wbsoft_pr
 	buf_index = pDes->buffer_start_index;
 
 	pT00 = (struct T00_descriptor *)buffer;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (SizeLeft) {
 		pT00 = (struct T00_descriptor *)buffer;
 		CopySize = SizeLeft;
@@ -235,6 +240,11 @@ static u16 Mds_BodyCopy(struct wbsoft_pr
 		stmp &= ~0x03; /* 4n Alignment */
 		Size += stmp; /* Current 4n offset of mpdu */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (CopySize) {
 			/* Copy body */
 			src_buffer = pDes->buffer_address[buf_index];
@@ -255,6 +265,12 @@ static u16 Mds_BodyCopy(struct wbsoft_pr
 			memcpy(buffer, src_buffer, CopyLeft);
 			buffer += CopyLeft;
 			CopySize -= CopyLeft;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* 931130.5.n */
@@ -280,6 +296,12 @@ static u16 Mds_BodyCopy(struct wbsoft_pr
 		}
 
 		FragmentCount++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pT00->T00_last_mpdu = 1;
diff -u -p a/staging/winbond/wb35reg.c b/staging/winbond/wb35reg.c
--- a/staging/winbond/wb35reg.c
+++ b/staging/winbond/wb35reg.c
@@ -505,6 +505,11 @@ void Wb35Reg_destroy(struct hw_data *pHw
 	/* Release all the data in RegQueue */
 	spin_lock_irq(&reg->EP0VM_spin_lock);
 	reg_queue = reg->reg_first;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_queue) {
 		if (reg_queue == reg->reg_last)
 			reg->reg_last = NULL;
@@ -521,6 +526,12 @@ void Wb35Reg_destroy(struct hw_data *pHw
 		spin_lock_irq(&reg->EP0VM_spin_lock);
 
 		reg_queue = reg->reg_first;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irq(&reg->EP0VM_spin_lock);
 }
diff -u -p a/staging/wlan-ng/prism2fw.c b/staging/wlan-ng/prism2fw.c
--- a/staging/wlan-ng/prism2fw.c
+++ b/staging/wlan-ng/prism2fw.c
@@ -589,6 +589,11 @@ int mkpdrlist(struct pda *pda)
 
 	pda->nrec = 0;
 	curroff = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (curroff < (HFA384x_PDA_LEN_MAX / 2) &&
 	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
 		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
@@ -623,6 +628,12 @@ int mkpdrlist(struct pda *pda)
 		(pda->nrec)++;
 		curroff += le16_to_cpu(pda16[curroff]) + 1;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (curroff >= (HFA384x_PDA_LEN_MAX / 2)) {
 		printk(KERN_ERR
@@ -862,6 +873,11 @@ int read_fwfile(const struct ihex_binrec
 
 	pr_debug("Reading fw file ...\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (record) {
 
 		rcnt++;
@@ -957,6 +973,12 @@ int read_fwfile(const struct ihex_binrec
 			break;
 		}
 		record = ihex_next_binrec(record);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/staging/wlan-ng/p80211netdev.c b/staging/wlan-ng/p80211netdev.c
--- a/staging/wlan-ng/p80211netdev.c
+++ b/staging/wlan-ng/p80211netdev.c
@@ -268,6 +268,11 @@ static void p80211netdev_rx_bh(unsigned
 	u16 fc;
 
 	/* Let's empty our our queue */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&wlandev->nsd_rxq))) {
 		if (wlandev->state == WLAN_DEVICE_OPEN) {
 
@@ -323,6 +328,12 @@ static void p80211netdev_rx_bh(unsigned
 			}
 		}
 		dev_kfree_skb(skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/wlan-ng/prism2sta.c b/staging/wlan-ng/prism2sta.c
--- a/staging/wlan-ng/prism2sta.c
+++ b/staging/wlan-ng/prism2sta.c
@@ -1209,9 +1209,20 @@ void prism2sta_processing_defer(struct w
 		struct sk_buff *skb;
 		hfa384x_InfFrame_t *inf;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((skb = skb_dequeue(&hw->authq))) {
 			inf = (hfa384x_InfFrame_t *) skb->data;
 			prism2sta_inf_authreq_defer(wlandev, inf);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	}
diff -u -p a/staging/intel_sst/intel_sst_stream_encoded.c b/staging/intel_sst/intel_sst_stream_encoded.c
--- a/staging/intel_sst/intel_sst_stream_encoded.c
+++ b/staging/intel_sst/intel_sst_stream_encoded.c
@@ -1106,7 +1106,12 @@ int sst_decode(int str_id, struct snd_ss
 	str_info->decode_ibuf_type = dbufs->ibufs->type;
 	str_info->decode_obuf_type = dbufs->obufs->type;
 
-	while ((copy_out_done == false) && (copy_in_done == false)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((copy_out_done == false) && (copy_in_done == false)) {
 		in_copied = 0;
 		new_entry_flag = false;
 		retval = sst_prepare_input_buffers(str_info,\
@@ -1199,7 +1204,12 @@ int sst_decode(int str_id, struct snd_ss
 							bytes_left);
 					if (new_entry_flag == true)
 						input_index--;
-					while (bytes_left) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+						unsigned long long timeout;
+						timeout = rdstcll(start) + delta;
+						while (bytes_left) {
 						struct snd_sst_buffs *ibufs;
 						struct snd_sst_buff_entry
 								*buff_entry;
@@ -1227,6 +1237,12 @@ int sst_decode(int str_id, struct snd_ss
 							input_index_valid_size =
 									0;
 						}
+						if (_cur < timeout) {
+									rdstcll(_cur);
+						}
+						else {
+									break;
+						}
 					}
 
 				}
@@ -1260,7 +1276,13 @@ int sst_decode(int str_id, struct snd_ss
 
 		pr_debug("copy_out = %d, copy_in = %d\n",
 				copy_out_done, copy_in_done);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 finish:
 	dbufs->input_bytes_consumed = total_input;
diff -u -p a/staging/intel_sst/intel_sst_drv_interface.c b/staging/intel_sst/intel_sst_drv_interface.c
--- a/staging/intel_sst/intel_sst_drv_interface.c
+++ b/staging/intel_sst/intel_sst_drv_interface.c
@@ -97,6 +97,11 @@ int sst_stalled(void)
 	int retry = 1000;
 	int retval = -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retry) {
 		if (!sst_drv_ctx->lpe_stalled)
 			return 0;
@@ -104,6 +109,12 @@ int sst_stalled(void)
 		msleep(1);
 
 		retry--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	pr_debug("in Stalled State\n");
 	return retval;
diff -u -p a/staging/crystalhd/crystalhd_hw.c b/staging/crystalhd/crystalhd_hw.c
--- a/staging/crystalhd/crystalhd_hw.c
+++ b/staging/crystalhd/crystalhd_hw.c
@@ -884,6 +884,11 @@ static enum BC_STATUS crystalhd_stop_tx_
 	BCMLOG(BCMLOG_DBG, "Cleared the DMA Start bit\n");
 
 	/* Poll for 3seconds (30 * 100ms) on both the lists..*/
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((l1 || l2) && cnt) {
 
 		if (l1) {
@@ -899,6 +904,12 @@ static enum BC_STATUS crystalhd_stop_tx_
 		msleep_interruptible(100);
 
 		cnt--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!cnt) {
@@ -1129,6 +1140,11 @@ static void crystalhd_stop_rx_dma_engine
 	}
 
 	/* Poll for 3seconds (30 * 100ms) on both the lists..*/
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((l0y || l0uv || l1y || l1uv) && count) {
 
 		if (l0y) {
@@ -1160,6 +1176,12 @@ static void crystalhd_stop_rx_dma_engine
 		}
 		msleep_interruptible(100);
 		count--;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	hw->rx_list_post_index = 0;
@@ -1650,6 +1672,11 @@ enum BC_STATUS crystalhd_download_fw(str
 	cnt = 1000;
 	msleep_interruptible(10);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (reg_data != BC_BIT(4)) {
 		reg_data = crystalhd_reg_rd(adp, DCI_STATUS);
 		reg_data &= BC_BIT(4);
@@ -1657,6 +1684,12 @@ enum BC_STATUS crystalhd_download_fw(str
 			BCMLOG_ERR("Firmware Download RDY Timeout.\n");
 			return BC_STS_TIMEOUT;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	msleep_interruptible(10);
diff -u -p a/staging/rtl8187se/r8185b_init.c b/staging/rtl8187se/r8185b_init.c
--- a/staging/rtl8187se/r8185b_init.c
+++ b/staging/rtl8187se/r8185b_init.c
@@ -1419,6 +1419,11 @@ MgntActSet_RF_State(
 		if (priv->RFChangeInProgress)	{
 			spin_unlock_irqrestore(&priv->rf_ps_lock, flag);
 			/*  Set RF after the previous action is done.	*/
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (priv->RFChangeInProgress)	{
 				RFWaitCounter++;
 				udelay(1000); /* 1 ms	*/
@@ -1429,6 +1434,12 @@ MgntActSet_RF_State(
 					/* TODO: Reset RF state?	*/
 					return false;
 				}
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}	else	{
 			priv->RFChangeInProgress = true;
diff -u -p a/staging/rtl8187se/ieee80211/ieee80211_softmac.c b/staging/rtl8187se/ieee80211/ieee80211_softmac.c
--- a/staging/rtl8187se/ieee80211/ieee80211_softmac.c
+++ b/staging/rtl8187se/ieee80211/ieee80211_softmac.c
@@ -445,6 +445,11 @@ void ieee80211_softmac_scan_syncro(struc
 	down(&ieee->scan_sem);
 //	printk("==================> Sync scan\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(1)
 	{
 
@@ -492,7 +497,13 @@ void ieee80211_softmac_scan_syncro(struc
 
 		msleep_interruptible_rtl(IEEE80211_SOFTMAC_SCAN_TIME);
 
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	ieee->sync_scan_hurryup = 0;
 	up(&ieee->scan_sem);
@@ -515,7 +526,12 @@ void ieee80211_softmac_ips_scan_syncro(s
 //   		goto out;
 //  	}
 //	printk("=======hh===============>ips scan\n");
-     	while(1)
+     	unsigned long long delta = (cpu / khz / HZ) * 2;
+     	unsigned long long _start = 0;
+     	unsigned long long _cur = 0;
+        unsigned long long timeout;
+        timeout = rdstcll(start) + delta;
+        while(1)
         {
                 /* this function can be called in two situations
                  * 1- We have switched to ad-hoc mode and we are
@@ -564,7 +580,13 @@ void ieee80211_softmac_ips_scan_syncro(s
 
 			ieee->current_network.channel = (ieee->current_network.channel + 1)%MAX_CHANNEL_NUMBER;
 		}while(!channel_map[ieee->current_network.channel]);
-        }
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 out:
 	//ieee->sync_scan_hurryup = 0;
    	//ieee->set_chan(ieee->dev, ch);
@@ -2063,6 +2085,11 @@ void ieee80211_rtl_wake_queue(struct iee
 	ieee->queue_stop = 0;
 
 	if(ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE){
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){
 
 			header = (struct ieee80211_hdr_3addr  *) skb->data;
@@ -2077,6 +2104,12 @@ void ieee80211_rtl_wake_queue(struct iee
 			//printk(KERN_ALERT "ieee80211_wake_queue \n");
 			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
 			dev_kfree_skb_any(skb);//edit by thomas
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	if (!ieee->queue_stop && ieee->tx_pending.txb)
diff -u -p a/staging/rtl8187se/r8180_core.c b/staging/rtl8187se/r8180_core.c
--- a/staging/rtl8187se/r8180_core.c
+++ b/staging/rtl8187se/r8180_core.c
@@ -1466,6 +1466,11 @@ void rtl8180_rx(struct net_device *dev)
 	}
 
 	/* while there are filled descriptors */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(*(priv->rxringtail) & (1<<31))) {
 		if (*(priv->rxringtail) & (1<<26))
 			DMESGW("RX buffer overflow");
@@ -1730,6 +1735,12 @@ drop: /* this is used when we have not e
 			priv->rxringtail = priv->rxring;
 
 		priv->rxbuffer = (priv->rxbuffer->next);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/firewire/core-transaction.c b/firewire/core-transaction.c
--- a/firewire/core-transaction.c
+++ b/firewire/core-transaction.c
@@ -286,10 +286,21 @@ static int allocate_tlabel(struct fw_car
 	int tlabel;
 
 	tlabel = card->current_tlabel;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (card->tlabel_mask & (1ULL << tlabel)) {
 		tlabel = (tlabel + 1) & 0x3f;
 		if (tlabel == card->current_tlabel)
 			return -EBUSY;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	card->current_tlabel = (tlabel + 1) & 0x3f;
diff -u -p a/firewire/core-device.c b/firewire/core-device.c
--- a/firewire/core-device.c
+++ b/firewire/core-device.c
@@ -66,12 +66,23 @@ static const u32 *search_leaf(const u32
 	int last_key = 0, key, value;
 
 	fw_csr_iterator_init(&ci, directory);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fw_csr_iterator_next(&ci, &key, &value)) {
 		if (last_key == search_key &&
 		    key == (CSR_DESCRIPTOR | CSR_LEAF))
 			return ci.p - 1 + value;
 
 		last_key = key;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
@@ -133,6 +144,11 @@ static void get_ids(const u32 *directory
 	int key, value;
 
 	fw_csr_iterator_init(&ci, directory);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fw_csr_iterator_next(&ci, &key, &value)) {
 		switch (key) {
 		case CSR_VENDOR:	id[0] = value; break;
@@ -140,6 +156,12 @@ static void get_ids(const u32 *directory
 		case CSR_SPECIFIER_ID:	id[2] = value; break;
 		case CSR_VERSION:	id[3] = value; break;
 		}
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -407,7 +429,12 @@ static int units_sprintf(char *buf, cons
 	int version = 0;
 
 	fw_csr_iterator_init(&ci, directory);
-	while (fw_csr_iterator_next(&ci, &key, &value)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (fw_csr_iterator_next(&ci, &key, &value)) {
 		switch (key) {
 		case CSR_SPECIFIER_ID:
 			specifier_id = value;
@@ -416,6 +443,12 @@ static int units_sprintf(char *buf, cons
 			version = value;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return sprintf(buf, "0x%06x:0x%06x ", specifier_id, version);
@@ -662,6 +695,11 @@ static void create_units(struct fw_devic
 
 	i = 0;
 	fw_csr_iterator_init(&ci, &device->config_rom[5]);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fw_csr_iterator_next(&ci, &key, &value)) {
 		if (key != (CSR_UNIT | CSR_DIRECTORY))
 			continue;
@@ -696,6 +734,12 @@ static void create_units(struct fw_devic
 
 	skip_unit:
 		kfree(unit);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/firewire/core-topology.c b/firewire/core-topology.c
--- a/firewire/core-topology.c
+++ b/firewire/core-topology.c
@@ -63,7 +63,12 @@ static u32 *count_ports(u32 *sid, int *t
 	q = *sid;
 	seq = 0;
 
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		port_type = (q >> shift) & 0x03;
 		switch (port_type) {
 		case SELFID_PORT_CHILD:
@@ -97,6 +102,12 @@ static u32 *count_ports(u32 *sid, int *t
 
 			seq++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -201,6 +212,11 @@ static struct fw_node *build_tree(struct
 	gap_count = SELF_ID_GAP_COUNT(*sid);
 	beta_repeaters_present = false;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sid < end) {
 		next_sid = count_ports(sid, &port_count, &child_port_count);
 
@@ -309,6 +325,12 @@ static struct fw_node *build_tree(struct
 
 		sid = next_sid;
 		phy_id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	card->root_node = node;
@@ -434,6 +456,11 @@ static void update_tree(struct fw_card *
 	node0 = fw_node(list0.next);
 	node1 = fw_node(list1.next);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (&node0->link != &list0) {
 		WARN_ON(node0->port_count != node1->port_count);
 
@@ -498,6 +525,12 @@ static void update_tree(struct fw_card *
 		next1 = fw_node(node1->link.next);
 		fw_node_put(node1);
 		node1 = next1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/firewire/ohci.c b/firewire/ohci.c
--- a/firewire/ohci.c
+++ b/firewire/ohci.c
@@ -772,11 +772,22 @@ static void ar_sync_buffers_for_cpu(stru
 	unsigned int i;
 
 	i = ar_first_buffer_index(ctx);
-	while (i != end_buffer_index) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i != end_buffer_index) {
 		dma_sync_single_for_cpu(ctx->ohci->card.device,
 					ar_buffer_bus(ctx, i),
 					PAGE_SIZE, DMA_FROM_DEVICE);
 		i = ar_next_buffer_index(i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	if (end_buffer_offset > 0)
 		dma_sync_single_for_cpu(ctx->ohci->card.device,
@@ -893,11 +904,22 @@ static void *handle_ar_packets(struct ar
 {
 	void *next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p < end) {
 		next = handle_ar_packet(ctx, p);
 		if (!next)
 			return p;
 		p = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return p;
@@ -908,12 +930,23 @@ static void ar_recycle_buffers(struct ar
 	unsigned int i;
 
 	i = ar_first_buffer_index(ctx);
-	while (i != end_buffer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i != end_buffer) {
 		dma_sync_single_for_device(ctx->ohci->card.device,
 					   ar_buffer_bus(ctx, i),
 					   PAGE_SIZE, DMA_FROM_DEVICE);
 		ar_context_link_page(ctx, i);
 		i = ar_next_buffer_index(i);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -2036,11 +2069,22 @@ static irqreturn_t irq_handler(int irq,
 		iso_event = reg_read(ohci, OHCI1394_IsoRecvIntEventClear);
 		reg_write(ohci, OHCI1394_IsoRecvIntEventClear, iso_event);
 
-		while (iso_event) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (iso_event) {
 			i = ffs(iso_event) - 1;
 			tasklet_schedule(
 				&ohci->ir_context_list[i].context.tasklet);
 			iso_event &= ~(1 << i);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -2048,11 +2092,22 @@ static irqreturn_t irq_handler(int irq,
 		iso_event = reg_read(ohci, OHCI1394_IsoXmitIntEventClear);
 		reg_write(ohci, OHCI1394_IsoXmitIntEventClear, iso_event);
 
-		while (iso_event) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (iso_event) {
 			i = ffs(iso_event) - 1;
 			tasklet_schedule(
 				&ohci->it_context_list[i].context.tasklet);
 			iso_event &= ~(1 << i);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
@@ -2714,6 +2769,11 @@ static int handle_ir_packet_per_buffer(s
 		/* Descriptor(s) not done yet, stop iteration */
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(d->control & cpu_to_le16(DESCRIPTOR_BRANCH_ALWAYS))) {
 		d++;
 		buffer_dma = le32_to_cpu(d->data_address);
@@ -2722,6 +2782,12 @@ static int handle_ir_packet_per_buffer(s
 					      buffer_dma & ~PAGE_MASK,
 					      le16_to_cpu(d->req_count),
 					      DMA_FROM_DEVICE);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	p = last + 1;
diff -u -p a/firewire/sbp2.c b/firewire/sbp2.c
--- a/firewire/sbp2.c
+++ b/firewire/sbp2.c
@@ -1018,7 +1018,12 @@ static int sbp2_scan_unit_dir(struct sbp
 	int key, value;
 
 	fw_csr_iterator_init(&ci, directory);
-	while (fw_csr_iterator_next(&ci, &key, &value)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (fw_csr_iterator_next(&ci, &key, &value)) {
 		switch (key) {
 
 		case CSR_DEPENDENT_INFO | CSR_OFFSET:
@@ -1054,6 +1059,12 @@ static int sbp2_scan_unit_dir(struct sbp
 				return -ENOMEM;
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/firmware/dmi-sysfs.c b/firmware/dmi-sysfs.c
--- a/firmware/dmi-sysfs.c
+++ b/firmware/dmi-sysfs.c
@@ -364,10 +364,21 @@ static ssize_t dmi_sel_raw_read_io(struc
 
 	sel_io_reader io_reader = sel_io_readers[sel->access_method];
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count && pos < sel->area_length) {
 		count--;
 		*(buf++) = io_reader(sel, pos++);
 		wrote++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return wrote;
@@ -384,10 +395,21 @@ static ssize_t dmi_sel_raw_read_phys32(s
 	if (!mapped)
 		return -EIO;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count && pos < sel->area_length) {
 		count--;
 		*(buf++) = readb(mapped + pos++);
 		wrote++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	iounmap(mapped);
diff -u -p a/firmware/efivars.c b/firmware/efivars.c
--- a/firmware/efivars.c
+++ b/firmware/efivars.c
@@ -191,6 +191,11 @@ utf16_strsize(efi_char16_t *data, unsign
 static inline int
 utf16_strncmp(const efi_char16_t *a, const efi_char16_t *b, size_t len)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (len == 0)
 			return 0;
@@ -203,6 +208,12 @@ utf16_strncmp(const efi_char16_t *a, con
 		a++;
 		b++;
 		len--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -729,6 +740,11 @@ static ssize_t efi_pstore_read(u64 *id,
 	unsigned int part, size;
 	unsigned long time;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (&efivars->walk_entry->list != &efivars->list) {
 		if (!efi_guidcmp(efivars->walk_entry->var.VendorGuid,
 				 vendor)) {
@@ -753,6 +769,12 @@ static ssize_t efi_pstore_read(u64 *id,
 		}
 		efivars->walk_entry = list_entry(efivars->walk_entry->list.next,
 						 struct efivar_entry, list);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/firmware/dell_rbu.c b/firmware/dell_rbu.c
--- a/firmware/dell_rbu.c
+++ b/firmware/dell_rbu.c
@@ -159,7 +159,12 @@ static int create_packet(void *data, siz
 		goto out_alloc_packet;
 	}
 
-	while (!packet_data_temp_buf) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!packet_data_temp_buf) {
 		packet_data_temp_buf = (unsigned char *)
 			__get_free_pages(GFP_KERNEL, ordernum);
 		if (!packet_data_temp_buf) {
@@ -180,6 +185,12 @@ static int create_packet(void *data, siz
 			invalid_addr_packet_array[idx++] = packet_data_temp_buf;
 			packet_data_temp_buf = NULL;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_lock(&rbu_data.lock);
 
@@ -238,6 +249,11 @@ static int packetize_data(const u8 *data
 	temp = (u8 *) data;
 
 	/* packetize the hunk */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!done) {
 		if ((temp + rbu_data.packetsize) < end)
 			packet_length = rbu_data.packetsize;
@@ -252,6 +268,12 @@ static int packetize_data(const u8 *data
 
 		pr_debug("%p:%td\n", temp, (end - temp));
 		temp += packet_length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	rbu_data.imagesize = length;
@@ -338,7 +360,12 @@ static void packet_empty_list(void)
 	struct packet_data *newpacket;
 
 	ptemp_list = (&packet_data_head.list)->next;
-	while (!list_empty(ptemp_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(ptemp_list)) {
 		newpacket =
 			list_entry(ptemp_list, struct packet_data, list);
 		pnext_list = ptemp_list->next;
@@ -352,6 +379,12 @@ static void packet_empty_list(void)
 		free_pages((unsigned long) newpacket->data,
 			newpacket->ordernum);
 		kfree(newpacket);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	rbu_data.packet_read_count = 0;
 	rbu_data.num_packets = 0;
diff -u -p a/firmware/dmi_scan.c b/firmware/dmi_scan.c
--- a/firmware/dmi_scan.c
+++ b/firmware/dmi_scan.c
@@ -80,6 +80,11 @@ static void dmi_table(u8 *buf, int len,
 	 *	Stop when we see all the items the table claimed to have
 	 *	OR we run off the end of the table (also happens)
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((i < num) && (data - buf + sizeof(struct dmi_header)) <= len) {
 		const struct dmi_header *dm = (const struct dmi_header *)data;
 
@@ -95,6 +100,12 @@ static void dmi_table(u8 *buf, int len,
 			decode(dm, private_data);
 		data += 2;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/crypto/amcc/crypto4xx_core.c b/crypto/amcc/crypto4xx_core.c
--- a/crypto/amcc/crypto4xx_core.c
+++ b/crypto/amcc/crypto4xx_core.c
@@ -551,7 +551,12 @@ static void crypto4xx_copy_pkt_to_dst(st
 	offset = 0;
 	i = 0;
 
-	while (nbytes) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (nbytes) {
 		sg = &dst[i];
 		sg_len = sg->length;
 		addr = dma_map_page(dev->core_dev->device, sg_page(sg),
@@ -583,6 +588,12 @@ static void crypto4xx_copy_pkt_to_dst(st
 			}
 			i++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -957,6 +968,11 @@ u32 crypto4xx_build_pd(struct crypto_asy
 			nbytes -= PPC4XX_SD_BUFFER_SIZE;
 		else
 			nbytes = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (nbytes) {
 			sd_idx = get_next_sd(sd_idx);
 			sd = crypto4xx_get_sdp(dev, &sd_dma, sd_idx);
@@ -971,6 +987,12 @@ u32 crypto4xx_build_pd(struct crypto_asy
 				 * which is more than nbytes, so done.
 				 */
 				nbytes = 0;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 		}
 	}
 
diff -u -p a/crypto/caam/caamalg.c b/crypto/caam/caamalg.c
--- a/crypto/caam/caamalg.c
+++ b/crypto/caam/caamalg.c
@@ -1049,12 +1049,23 @@ static struct link_tbl_entry *sg_to_link
 					     int sg_count, struct link_tbl_entry
 					     *link_tbl_ptr, u32 offset)
 {
-	while (sg_count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (sg_count) {
 		sg_to_link_tbl_one(link_tbl_ptr, sg_dma_address(sg),
 				   sg_dma_len(sg), offset);
 		link_tbl_ptr++;
 		sg = sg_next(sg);
 		sg_count--;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	return link_tbl_ptr - 1;
 }
diff -u -p a/crypto/picoxcell_crypto.c b/crypto/picoxcell_crypto.c
--- a/crypto/picoxcell_crypto.c
+++ b/crypto/picoxcell_crypto.c
@@ -675,7 +675,12 @@ static void spacc_push(struct spacc_engi
 {
 	struct spacc_req *req;
 
-	while (!list_empty(&engine->pending) &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&engine->pending) &&
 	       engine->in_flight + 1 <= engine->fifo_sz) {
 
 		++engine->in_flight;
@@ -684,6 +689,12 @@ static void spacc_push(struct spacc_engi
 		list_move_tail(&req->list, &engine->in_progress);
 
 		req->result = spacc_req_submit(req);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -1156,7 +1167,12 @@ static void spacc_process_done(struct sp
 
 	spin_lock_irqsave(&engine->hw_lock, flags);
 
-	while (!spacc_fifo_stat_empty(engine)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!spacc_fifo_stat_empty(engine)) {
 		req = list_first_entry(&engine->in_progress, struct spacc_req,
 				       list);
 		list_move_tail(&req->list, &engine->completed);
@@ -1190,6 +1206,12 @@ static void spacc_process_done(struct sp
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	tasklet_schedule(&engine->complete);
diff -u -p a/crypto/omap-sham.c b/crypto/omap-sham.c
--- a/crypto/omap-sham.c
+++ b/crypto/omap-sham.c
@@ -190,9 +190,20 @@ static inline int omap_sham_wait(struct
 {
 	unsigned long timeout = jiffies + DEFAULT_TIMEOUT_INTERVAL;
 
-	while (!(omap_sham_read(dd, offset) & bit)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while (!(omap_sham_read(dd, offset) & bit)) {
 		if (time_is_before_jiffies(timeout))
 			return -ETIMEDOUT;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
diff -u -p a/crypto/geode-aes.c b/crypto/geode-aes.c
--- a/crypto/geode-aes.c
+++ b/crypto/geode-aes.c
@@ -317,6 +317,11 @@ geode_cbc_decrypt(struct blkcipher_desc
 	err = blkcipher_walk_virt(desc, &walk);
 	op->iv = walk.iv;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -328,6 +333,12 @@ geode_cbc_decrypt(struct blkcipher_desc
 
 		nbytes -= ret;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return err;
@@ -349,6 +360,11 @@ geode_cbc_encrypt(struct blkcipher_desc
 	err = blkcipher_walk_virt(desc, &walk);
 	op->iv = walk.iv;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -359,6 +375,12 @@ geode_cbc_encrypt(struct blkcipher_desc
 		ret = geode_aes_crypt(op);
 		nbytes -= ret;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return err;
@@ -429,6 +451,11 @@ geode_ecb_decrypt(struct blkcipher_desc
 	blkcipher_walk_init(&walk, dst, src, nbytes);
 	err = blkcipher_walk_virt(desc, &walk);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -439,6 +466,12 @@ geode_ecb_decrypt(struct blkcipher_desc
 		ret = geode_aes_crypt(op);
 		nbytes -= ret;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return err;
@@ -459,6 +492,11 @@ geode_ecb_encrypt(struct blkcipher_desc
 	blkcipher_walk_init(&walk, dst, src, nbytes);
 	err = blkcipher_walk_virt(desc, &walk);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((nbytes = walk.nbytes)) {
 		op->src = walk.src.virt.addr,
 		op->dst = walk.dst.virt.addr;
@@ -469,6 +507,12 @@ geode_ecb_encrypt(struct blkcipher_desc
 		ret = geode_aes_crypt(op);
 		nbytes -= ret;
 		ret =  blkcipher_walk_done(desc, &walk, nbytes);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return err;
diff -u -p a/crypto/omap-aes.c b/crypto/omap-aes.c
--- a/crypto/omap-aes.c
+++ b/crypto/omap-aes.c
@@ -165,11 +165,22 @@ static int omap_aes_wait(struct omap_aes
 {
 	unsigned long timeout = jiffies + DEFAULT_TIMEOUT;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(omap_aes_read(dd, offset) & bit)) {
 		if (time_is_before_jiffies(timeout)) {
 			dev_err(dd->dev, "omap-aes timeout\n");
 			return -ETIMEDOUT;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -396,6 +407,11 @@ static int sg_copy(struct scatterlist **
 {
 	unsigned int count, off = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (buflen && total) {
 		count = min((*sg)->length - *offset, total);
 		count = min(count, buflen);
@@ -422,6 +438,12 @@ static int sg_copy(struct scatterlist **
 			else
 				total = 0;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return off;
diff -u -p a/crypto/talitos.c b/crypto/talitos.c
--- a/crypto/talitos.c
+++ b/crypto/talitos.c
@@ -424,12 +424,23 @@ static u32 current_desc_hdr(struct devic
 
 	cur_desc = in_be32(priv->reg + TALITOS_CDPR_LO(ch));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (priv->chan[ch].fifo[tail].dma_desc != cur_desc) {
 		tail = (tail + 1) & (priv->fifo_len - 1);
 		if (tail == priv->chan[ch].tail) {
 			dev_err(dev, "couldn't locate current descriptor\n");
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return priv->chan[ch].fifo[tail].desc->hdr;
@@ -813,10 +824,22 @@ static int talitos_map_sg(struct device
 			  unsigned int nents, enum dma_data_direction dir,
 			  int chained)
 {
-	if (unlikely(chained))
-		while (sg) {
-			dma_map_sg(dev, sg, 1, dir);
-			sg = scatterwalk_sg_next(sg);
+	if (unlikely(chained)) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (sg) {
+				dma_map_sg(dev, sg, 1, dir);
+				sg = scatterwalk_sg_next(sg);
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
+			}
 		}
 	else
 		dma_map_sg(dev, sg, nents, dir);
@@ -826,9 +849,20 @@ static int talitos_map_sg(struct device
 static void talitos_unmap_sg_chain(struct device *dev, struct scatterlist *sg,
 				   enum dma_data_direction dir)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sg) {
 		dma_unmap_sg(dev, sg, 1, dir);
 		sg = scatterwalk_sg_next(sg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -985,12 +1019,23 @@ static int sg_to_link_tbl(struct scatter
 
 	/* adjust (decrease) last one (or two) entry's len to cryptlen */
 	link_tbl_ptr--;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (be16_to_cpu(link_tbl_ptr->len) <= (-cryptlen)) {
 		/* Empty this entry, and move to previous one */
 		cryptlen += be16_to_cpu(link_tbl_ptr->len);
 		link_tbl_ptr->len = 0;
 		sg_count--;
 		link_tbl_ptr--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	link_tbl_ptr->len = cpu_to_be16(be16_to_cpu(link_tbl_ptr->len)
 					+ cryptlen);
@@ -1171,6 +1216,11 @@ static size_t sg_copy_end_to_buffer(stru
 
 	local_irq_save(flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (sg_miter_next(&miter) && offset < total_buffer) {
 		unsigned int len;
 		unsigned int ignore;
@@ -1193,6 +1243,12 @@ static size_t sg_copy_end_to_buffer(stru
 			boffset += len;
 		}
 		offset += miter.length;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sg_miter_stop(&miter);
diff -u -p a/crypto/padlock-aes.c b/crypto/padlock-aes.c
--- a/crypto/padlock-aes.c
+++ b/crypto/padlock-aes.c
@@ -354,12 +354,23 @@ static int ecb_aes_encrypt(struct blkcip
 	err = blkcipher_walk_virt(desc, &walk);
 
 	ts_state = irq_ts_save();
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		padlock_xcrypt_ecb(walk.src.virt.addr, walk.dst.virt.addr,
 				   ctx->E, &ctx->cword.encrypt,
 				   nbytes / AES_BLOCK_SIZE);
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	irq_ts_restore(ts_state);
 
@@ -383,12 +394,23 @@ static int ecb_aes_decrypt(struct blkcip
 	err = blkcipher_walk_virt(desc, &walk);
 
 	ts_state = irq_ts_save();
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		padlock_xcrypt_ecb(walk.src.virt.addr, walk.dst.virt.addr,
 				   ctx->D, &ctx->cword.decrypt,
 				   nbytes / AES_BLOCK_SIZE);
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	irq_ts_restore(ts_state);
 
@@ -434,7 +456,12 @@ static int cbc_aes_encrypt(struct blkcip
 	err = blkcipher_walk_virt(desc, &walk);
 
 	ts_state = irq_ts_save();
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		u8 *iv = padlock_xcrypt_cbc(walk.src.virt.addr,
 					    walk.dst.virt.addr, ctx->E,
 					    walk.iv, &ctx->cword.encrypt,
@@ -442,6 +469,12 @@ static int cbc_aes_encrypt(struct blkcip
 		memcpy(walk.iv, iv, AES_BLOCK_SIZE);
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	irq_ts_restore(ts_state);
 
@@ -465,12 +498,23 @@ static int cbc_aes_decrypt(struct blkcip
 	err = blkcipher_walk_virt(desc, &walk);
 
 	ts_state = irq_ts_save();
-	while ((nbytes = walk.nbytes)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((nbytes = walk.nbytes)) {
 		padlock_xcrypt_cbc(walk.src.virt.addr, walk.dst.virt.addr,
 				   ctx->D, walk.iv, &ctx->cword.decrypt,
 				   nbytes / AES_BLOCK_SIZE);
 		nbytes &= AES_BLOCK_SIZE - 1;
 		err = blkcipher_walk_done(desc, &walk, nbytes);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	irq_ts_restore(ts_state);
diff -u -p a/crypto/ixp4xx_crypto.c b/crypto/ixp4xx_crypto.c
--- a/crypto/ixp4xx_crypto.c
+++ b/crypto/ixp4xx_crypto.c
@@ -330,6 +330,11 @@ static struct crypt_ctl *get_crypt_desc_
 
 static void free_buf_chain(struct device *dev, struct buffer_desc *buf,u32 phys)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (buf) {
 		struct buffer_desc *buf1;
 		u32 phys1;
@@ -340,6 +345,12 @@ static void free_buf_chain(struct device
 		dma_pool_free(buffer_pool, buf, phys);
 		buf = buf1;
 		phys = phys1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/crypto/hifn_795x.c b/crypto/hifn_795x.c
--- a/crypto/hifn_795x.c
+++ b/crypto/hifn_795x.c
@@ -1378,6 +1378,11 @@ static int hifn_setup_dma(struct hifn_de
 	unsigned int n, len;
 
 	n = nbytes;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (n) {
 		spage = sg_page(src);
 		soff = src->offset;
@@ -1387,10 +1392,21 @@ static int hifn_setup_dma(struct hifn_de
 
 		src++;
 		n -= len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	t = &rctx->walk.cache[0];
 	n = nbytes;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (n) {
 		if (t->length && rctx->walk.flags & ASYNC_FLAGS_MISALIGNED) {
 			BUG_ON(!sg_page(t));
@@ -1410,6 +1426,12 @@ static int hifn_setup_dma(struct hifn_de
 		dst++;
 		t++;
 		n -= len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	hifn_setup_cmd_desc(dev, ctx, rctx, priv, nbytes);
@@ -1466,7 +1488,12 @@ static int ablkcipher_add(unsigned int *
 	if (drest < size || size > nbytes)
 		return -EINVAL;
 
-	while (size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size) {
 		copy = min3(drest, size, dst->length);
 
 		size -= copy;
@@ -1478,6 +1505,12 @@ static int ablkcipher_add(unsigned int *
 
 		dst++;
 		idx++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	*nbytesp = nbytes;
@@ -1495,6 +1528,11 @@ static int hifn_cipher_walk(struct ablkc
 
 	tidx = idx = 0;
 	offset = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nbytes) {
 		if (idx >= w->num && (w->flags & ASYNC_FLAGS_MISALIGNED))
 			return -EINVAL;
@@ -1567,6 +1605,12 @@ static int hifn_cipher_walk(struct ablkc
 		}
 
 		tidx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return tidx;
@@ -1587,6 +1631,11 @@ static int hifn_setup_session(struct abl
 
 	rctx->walk.flags = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nbytes) {
 		dst = &req->dst[idx];
 		dlen = min(dst->length, nbytes);
@@ -1597,6 +1646,12 @@ static int hifn_setup_session(struct abl
 
 		nbytes -= dlen;
 		idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (rctx->walk.flags & ASYNC_FLAGS_MISALIGNED) {
@@ -1728,6 +1783,11 @@ static int ablkcipher_get(void *saddr, u
 	if (srest < size || size > nbytes)
 		return -EINVAL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size) {
 		copy = min3(srest, dst->length, size);
 
@@ -1746,6 +1806,12 @@ static int ablkcipher_get(void *saddr, u
 
 		dst++;
 		idx++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	*nbytesp = nbytes;
@@ -2033,6 +2099,11 @@ static void hifn_flush(struct hifn_devic
 	}
 
 	spin_lock_irqsave(&dev->lock, flags);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((async_req = crypto_dequeue_request(&dev->queue))) {
 		req = container_of(async_req, struct ablkcipher_request, base);
 		spin_unlock_irqrestore(&dev->lock, flags);
@@ -2040,6 +2111,12 @@ static void hifn_flush(struct hifn_devic
 		hifn_process_ready(req, -ENODEV);
 
 		spin_lock_irqsave(&dev->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&dev->lock, flags);
 }
diff -u -p a/crypto/mv_cesa.c b/crypto/mv_cesa.c
--- a/crypto/mv_cesa.c
+++ b/crypto/mv_cesa.c
@@ -189,6 +189,11 @@ static void copy_src_to_buf(struct req_p
 	void *sbuf;
 	int copy_len;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		if (!p->sg_src_left) {
 			ret = sg_miter_next(&p->src_sg_it);
@@ -207,6 +212,12 @@ static void copy_src_to_buf(struct req_p
 
 		len -= copy_len;
 		dbuf += copy_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/watchdog/max63xx_wdt.c b/watchdog/max63xx_wdt.c
--- a/watchdog/max63xx_wdt.c
+++ b/watchdog/max63xx_wdt.c
@@ -102,6 +102,11 @@ static struct max63xx_timeout *current_t
 static struct max63xx_timeout *
 max63xx_select_timeout(struct max63xx_timeout *table, int value)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (table->twd) {
 		if (value <= table->twd) {
 			if (nodelay && table->tdelay == 0)
@@ -112,6 +117,12 @@ max63xx_select_timeout(struct max63xx_ti
 		}
 
 		table++;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return NULL;
diff -u -p a/parisc/ccio-dma.c b/parisc/ccio-dma.c
--- a/parisc/ccio-dma.c
+++ b/parisc/ccio-dma.c
@@ -635,10 +635,21 @@ ccio_clear_io_tlb(struct ioc *ioc, dma_a
 	iovp &= IOVP_MASK;	/* clear offset bits, just want pagenum */
 	byte_cnt += chain_size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(byte_cnt > chain_size) {
 		WRITE_U32(CMD_TLB_PURGE | iovp, &ioc->ioc_regs->io_command);
 		iovp += chain_size;
 		byte_cnt -= chain_size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1192,9 +1203,20 @@ void ccio_cujo20_fixup(struct parisc_dev
 	res_ptr = ioc->res_map;
 	idx = PDIR_INDEX(iovp) >> 3;
 
-	while (idx < ioc->res_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (idx < ioc->res_size) {
  		res_ptr[idx] |= 0xff;
 		idx += PDIR_INDEX(CUJO_20_STEP) >> 3;
+		if (_cur < timeout) {
+ 		rdstcll(_cur);
+		}
+		else {
+ 		break;
+		}
 	}
 }
 
diff -u -p a/parisc/sba_iommu.c b/parisc/sba_iommu.c
--- a/parisc/sba_iommu.c
+++ b/parisc/sba_iommu.c
@@ -233,10 +233,20 @@ sba_check_pdir(struct ioc *ioc, char *ms
 	u64 *pptr = ioc->pdir_base;	/* pdir ptr */
 	uint pide = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (rptr < rptr_end) {
 		u32 rval = *rptr;
 		int rcnt = 32;	/* number of bits we might check */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (rcnt) {
 			/* Get last byte and highest bit from that */
 			u32 pde = ((u32) (((char *)pptr)[7])) << 24;
@@ -253,8 +263,20 @@ sba_check_pdir(struct ioc *ioc, char *ms
 			rval <<= 1;	/* try the next bit */
 			pptr++;
 			pide++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		rptr++;	/* look at next word of res_map */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	/* It'd be nice if we always got here :^) */
 	return 0;
@@ -1161,11 +1183,22 @@ sba_alloc_pdir(unsigned int pdir_size)
 			pdir_base = new_pdir;
 
 			/* release excess */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (pdir_order < (19-12)) {
 				new_pdir += pdir_size;
 				free_pages(new_pdir, pdir_order);
 				pdir_order +=1;
 				pdir_size <<=1;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	} else {
diff -u -p a/parisc/hppb.c b/parisc/hppb.c
--- a/parisc/hppb.c
+++ b/parisc/hppb.c
@@ -50,8 +50,19 @@ static int hppb_probe(struct parisc_devi
 	int status;
 	struct hppb_card *card = &hppb_card_head;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(card->next) {
 		card = card->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if(card->hpa) {
diff -u -p a/parisc/ccio-rm-dma.c b/parisc/ccio-rm-dma.c
--- a/parisc/ccio-rm-dma.c
+++ b/parisc/ccio-rm-dma.c
@@ -117,11 +117,22 @@ static int ccio_map_sg(struct pci_dev *d
 	int tmp = nents;
 
         /* KISS: map each buffer separately. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nents) {
 		sg_dma_address(sglist) = ccio_map_single(dev, sglist->address, sglist->length, direction);
 		sg_dma_len(sglist) = sglist->length;
 		nents--;
 		sglist++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return tmp;
diff -u -p a/pcmcia/ds.c b/pcmcia/ds.c
--- a/pcmcia/ds.c
+++ b/pcmcia/ds.c
@@ -53,6 +53,11 @@ static void pcmcia_check_driver(struct p
 		printk(KERN_DEBUG "pcmcia: %s lacks a requisite callback "
 		       "function\n", p_drv->name);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (did && did->match_flags) {
 		for (i = 0; i < 4; i++) {
 			if (!did->prod_id[i])
@@ -71,6 +76,12 @@ static void pcmcia_check_driver(struct p
 				"details\n");
 		}
 		did++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return;
@@ -905,6 +916,11 @@ static int pcmcia_bus_match(struct devic
 	}
 	mutex_unlock(&p_drv->dynids.lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (did && did->match_flags) {
 		dev_dbg(dev, "trying to match to %s\n", drv->name);
 		if (pcmcia_devmatch(p_dev, did)) {
@@ -912,6 +928,12 @@ static int pcmcia_bus_match(struct devic
 			return 1;
 		}
 		did++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/pcmcia/m8xx_pcmcia.c b/pcmcia/m8xx_pcmcia.c
--- a/pcmcia/m8xx_pcmcia.c
+++ b/pcmcia/m8xx_pcmcia.c
@@ -566,11 +566,22 @@ static irqreturn_t m8xx_interrupt(int ir
 		e = &s->events[0];
 		events = 0;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (e->regbit) {
 			if (pscr & e->regbit)
 				events |= e->eventbit;
 
 			e++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/*
diff -u -p a/pcmcia/cistpl.c b/pcmcia/cistpl.c
--- a/pcmcia/cistpl.c
+++ b/pcmcia/cistpl.c
@@ -180,6 +180,11 @@ int pcmcia_read_cis_mem(struct pcmcia_so
 		}
 
 		card_offset = addr & ~(s->map_size-1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			sys = set_cis_map(s, card_offset, flags);
 			if (!sys) {
@@ -196,6 +201,12 @@ int pcmcia_read_cis_mem(struct pcmcia_so
 			}
 			card_offset += s->map_size;
 			addr = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	dev_dbg(&s->dev, "  %#2.2x %#2.2x %#2.2x %#2.2x ...\n",
@@ -254,6 +265,11 @@ int pcmcia_write_cis_mem(struct pcmcia_s
 		}
 
 		card_offset = addr & ~(s->map_size-1);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (len) {
 			sys = set_cis_map(s, card_offset, flags);
 			if (!sys) {
@@ -270,6 +286,12 @@ int pcmcia_write_cis_mem(struct pcmcia_s
 			}
 			card_offset += s->map_size;
 			addr = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 0;
@@ -919,6 +941,11 @@ static u_char *parse_power(u_char *p, u_
 				return NULL;
 			pwr->param[i] = POWER_CVT(*p);
 			scale = POWER_SCALE(*p);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (*p & 0x80) {
 				if (++p == q)
 					return NULL;
@@ -933,6 +960,12 @@ static u_char *parse_power(u_char *p, u_
 					pwr->flags |= CISTPL_POWER_HIGHZ_REQ;
 				else
 					return NULL;
+					if (_cur < timeout) {
+					rdstcll(_cur);
+					}
+					else {
+					break;
+					}
 			}
 			p++;
 		}
diff -u -p a/pcmcia/pxa2xx_palmtc.c b/pcmcia/pxa2xx_palmtc.c
--- a/pcmcia/pxa2xx_palmtc.c
+++ b/pcmcia/pxa2xx_palmtc.c
@@ -81,10 +81,21 @@ static int palmtc_wifi_powerup(void)
 	gpio_set_value(GPIO_NR_PALMTC_PCMCIA_POWER2, 1);
 
 	/* Wait till the card is ready */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!gpio_get_value(GPIO_NR_PALMTC_PCMCIA_PWRREADY) &&
 		timeout) {
 		mdelay(1);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Power down the WiFi in case of error */
diff -u -p a/target/iscsi/iscsi_target_nego.c b/target/iscsi/iscsi_target_nego.c
--- a/target/iscsi/iscsi_target_nego.c
+++ b/target/iscsi/iscsi_target_nego.c
@@ -685,7 +685,12 @@ static int iscsi_target_do_login(struct
 	login_req = (struct iscsi_login_req *) login->req;
 	login_rsp = (struct iscsi_login_rsp *) login->rsp;
 
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		if (++pdu_count > MAX_LOGIN_PDUS) {
 			pr_err("MAX_LOGIN_PDUS count reached.\n");
 			iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
@@ -726,6 +731,12 @@ static int iscsi_target_do_login(struct
 			login_rsp->flags &= ~ISCSI_FLAG_LOGIN_TRANSIT;
 			login_rsp->flags &= ~ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -798,6 +809,11 @@ static int iscsi_target_locate_portal(
 	 * Locate the initial keys expected from the Initiator node in
 	 * the first login request in order to progress with the login phase.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start < end) {
 		if (iscsi_extract_key_value(start, &key, &value) < 0) {
 			ret = -1;
@@ -812,6 +828,12 @@ static int iscsi_target_locate_portal(
 			t_buf = value;
 
 		start += strlen(key) + strlen(value) + 2;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/target/iscsi/iscsi_target_util.c b/target/iscsi/iscsi_target_util.c
--- a/target/iscsi/iscsi_target_util.c
+++ b/target/iscsi/iscsi_target_util.c
@@ -1339,6 +1339,11 @@ send_hdr:
 	/*
 	 * Perform sendpage() for each page in the scatterlist
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (data_len) {
 		u32 space = (sg->length - offset);
 		u32 sub_len = min_t(u32, data_len, space);
@@ -1360,7 +1365,13 @@ send_pg:
 		data_len -= sub_len;
 		offset = 0;
 		sg = sg_next(sg);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 send_padding:
 	if (cmd->padding) {
@@ -1463,7 +1474,12 @@ static int iscsit_do_rx_data(
 	iov_p = count->iov;
 	iov_len	= count->iov_count;
 
-	while (total_rx < data) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (total_rx < data) {
 		rx_loop = kernel_recvmsg(conn->sock, &msg, iov_p, iov_len,
 					(data - total_rx), MSG_WAITALL);
 		if (rx_loop <= 0) {
@@ -1474,6 +1490,12 @@ static int iscsit_do_rx_data(
 		total_rx += rx_loop;
 		pr_debug("rx_loop: %d, total_rx: %d, data: %d\n",
 				rx_loop, total_rx, data);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return total_rx;
@@ -1500,7 +1522,12 @@ static int iscsit_do_tx_data(
 	iov_p = count->iov;
 	iov_len = count->iov_count;
 
-	while (total_tx < data) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (total_tx < data) {
 		tx_loop = kernel_sendmsg(conn->sock, &msg, iov_p, iov_len,
 					(data - total_tx));
 		if (tx_loop <= 0) {
@@ -1511,6 +1538,12 @@ static int iscsit_do_tx_data(
 		total_tx += tx_loop;
 		pr_debug("tx_loop: %d, total_tx: %d, data: %d\n",
 					tx_loop, total_tx, data);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return total_tx;
diff -u -p a/target/iscsi/iscsi_target_parameters.c b/target/iscsi/iscsi_target_parameters.c
--- a/target/iscsi/iscsi_target_parameters.c
+++ b/target/iscsi/iscsi_target_parameters.c
@@ -1559,6 +1559,11 @@ int iscsi_decode_text_input(
 	start = tmpbuf;
 	end = (start + length);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (start < end) {
 		char *key, *value;
 		struct iscsi_param *param;
@@ -1607,6 +1612,12 @@ int iscsi_decode_text_input(
 			}
 			SET_PSTATE_ACCEPTOR(param);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(tmpbuf);
diff -u -p a/target/iscsi/iscsi_target_tq.c b/target/iscsi/iscsi_target_tq.c
--- a/target/iscsi/iscsi_target_tq.c
+++ b/target/iscsi/iscsi_target_tq.c
@@ -145,6 +145,11 @@ extern void iscsi_deallocate_thread_sets
 	u32 released_count = 0;
 	struct iscsi_thread_set *ts = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ts = iscsi_get_ts_from_inactive_list())) {
 
 		spin_lock_bh(&ts->ts_state_lock);
@@ -169,6 +174,12 @@ extern void iscsi_deallocate_thread_sets
 
 		released_count++;
 		kfree(ts);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (released_count)
diff -u -p a/target/iscsi/iscsi_target_erl1.c b/target/iscsi/iscsi_target_erl1.c
--- a/target/iscsi/iscsi_target_erl1.c
+++ b/target/iscsi/iscsi_target_erl1.c
@@ -63,7 +63,12 @@ int iscsit_dump_data_payload(
 	}
 	memset(&iov, 0, sizeof(struct kvec));
 
-	while (offset < buf_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (offset < buf_len) {
 		size = ((offset + length) > buf_len) ?
 			(buf_len - offset) : length;
 
@@ -77,6 +82,12 @@ int iscsit_dump_data_payload(
 		}
 
 		offset += size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!dump_padding_digest)
@@ -176,6 +187,11 @@ static int iscsit_handle_r2t_snack(
 	} else
 		last_r2tsn = cmd->r2t_sn;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (begrun < last_r2tsn) {
 		r2t = iscsit_get_holder_for_r2tsn(cmd, begrun);
 		if (!r2t)
@@ -184,6 +200,12 @@ static int iscsit_handle_r2t_snack(
 			return -1;
 
 		begrun++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
@@ -332,18 +354,34 @@ int iscsit_create_recovery_datain_values
 			 * sequence's next_burst_len;
 			 */
 			if (conn->sess->sess_ops->DataPDUInOrder) {
-				while (data_sn < begrun) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+					unsigned long long timeout;
+					timeout = rdstcll(start) + delta;
+					while (data_sn < begrun) {
 					seq->pdu_send_order++;
 					read_data_done +=
 						conn->conn_ops->MaxRecvDataSegmentLength;
 					seq->next_burst_len +=
 						conn->conn_ops->MaxRecvDataSegmentLength;
 					data_sn++;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			} else {
 				int j;
 				struct iscsi_pdu *pdu;
 
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while (data_sn < begrun) {
 					seq->pdu_send_order++;
 
@@ -358,6 +396,12 @@ int iscsit_create_recovery_datain_values
 						}
 					}
 					data_sn++;
+					if (_cur < timeout) {
+						rdstcll(_cur);
+					}
+					else {
+						break;
+					}
 				}
 			}
 			continue;
@@ -522,6 +566,11 @@ int iscsit_handle_status_snack(
 
 	last_statsn = (!runlength) ? conn->stat_sn : (begrun + runlength);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (begrun < last_statsn) {
 		found_cmd = 0;
 
@@ -558,6 +607,12 @@ int iscsit_handle_status_snack(
 		cmd->i_state = ISTATE_SEND_STATUS_RECOVERY;
 		iscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);
 		begrun++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/target/iscsi/iscsi_target_erl2.c b/target/iscsi/iscsi_target_erl2.c
--- a/target/iscsi/iscsi_target_erl2.c
+++ b/target/iscsi/iscsi_target_erl2.c
@@ -44,7 +44,12 @@ void iscsit_create_conn_recovery_datain_
 	cmd->next_burst_len = 0;
 	cmd->read_data_done = 0;
 
-	while (exp_data_sn > data_sn) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (exp_data_sn > data_sn) {
 		if ((cmd->next_burst_len +
 		     conn->conn_ops->MaxRecvDataSegmentLength) <
 		     conn->sess->sess_ops->MaxBurstLength) {
@@ -59,6 +64,12 @@ void iscsit_create_conn_recovery_datain_
 			cmd->next_burst_len = 0;
 		}
 		data_sn++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/target/iscsi/iscsi_target_seq_pdu_list.c b/target/iscsi/iscsi_target_seq_pdu_list.c
--- a/target/iscsi/iscsi_target_seq_pdu_list.c
+++ b/target/iscsi/iscsi_target_seq_pdu_list.c
@@ -225,6 +225,11 @@ static void iscsit_determine_counts_for_
 			conn->sess->sess_ops->FirstBurstLength) ?
 			conn->sess->sess_ops->FirstBurstLength : cmd->data_length;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (offset < cmd->data_length) {
 		*pdu_count += 1;
 
@@ -278,6 +283,12 @@ static void iscsit_determine_counts_for_
 
 		burstlength += conn->conn_ops->MaxRecvDataSegmentLength;
 		offset += conn->conn_ops->MaxRecvDataSegmentLength;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -310,6 +321,11 @@ static int iscsit_build_pdu_and_seq_list
 			conn->sess->sess_ops->FirstBurstLength) ?
 			conn->sess->sess_ops->FirstBurstLength : cmd->data_length;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (offset < cmd->data_length) {
 		pdu_count++;
 		if (!datapduinorder) {
@@ -446,6 +462,12 @@ static int iscsit_build_pdu_and_seq_list
 		}
 		burstlength += conn->conn_ops->MaxRecvDataSegmentLength;
 		offset += conn->conn_ops->MaxRecvDataSegmentLength;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!datasequenceinorder) {
diff -u -p a/target/target_core_transport.c b/target/target_core_transport.c
--- a/target/target_core_transport.c
+++ b/target/target_core_transport.c
@@ -1223,12 +1223,23 @@ transport_set_vpd_ident(struct t10_vpd *
 	case 0x01: /* Binary */
 		vpd->device_identifier[j++] =
 				hex_str[vpd->device_identifier_type];
-		while (i < (4 + page_83[3])) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (i < (4 + page_83[3])) {
 			vpd->device_identifier[j++] =
 				hex_str[(page_83[i] & 0xf0) >> 4];
 			vpd->device_identifier[j++] =
 				hex_str[page_83[i] & 0x0f];
 			i++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		break;
 	case 0x02: /* ASCII */
@@ -3310,6 +3321,11 @@ static void transport_free_dev_tasks(str
 	}
 	spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&dispose_list)) {
 		task = list_first_entry(&dispose_list, struct se_task, t_list);
 
@@ -3320,6 +3336,12 @@ static void transport_free_dev_tasks(str
 		list_del(&task->t_list);
 
 		cmd->se_dev->transport->free_task(task);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -3502,6 +3524,11 @@ transport_generic_get_mem(struct se_cmd
 	cmd->t_data_nents = nents;
 	sg_init_table(cmd->t_data_sg, nents);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (length) {
 		u32 page_len = min_t(u32, length, PAGE_SIZE);
 		page = alloc_page(GFP_KERNEL | __GFP_ZERO);
@@ -3511,6 +3538,12 @@ transport_generic_get_mem(struct se_cmd
 		sg_set_page(&cmd->t_data_sg[i], page, page_len, 0);
 		length -= page_len;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 
@@ -4124,7 +4157,12 @@ static void __transport_clear_lun_from_s
 	 * Initiator Port.
 	 */
 	spin_lock_irqsave(&lun->lun_cmd_lock, lun_flags);
-	while (!list_empty(&lun->lun_cmd_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&lun->lun_cmd_list)) {
 		cmd = list_first_entry(&lun->lun_cmd_list,
 		       struct se_cmd, se_lun_node);
 		list_del(&cmd->se_lun_node);
@@ -4212,6 +4250,12 @@ check_cond:
 
 		spin_unlock_irqrestore(&cmd->t_state_lock, cmd_flags);
 		spin_lock_irqsave(&lun->lun_cmd_lock, lun_flags);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	spin_unlock_irqrestore(&lun->lun_cmd_lock, lun_flags);
 }
@@ -4666,7 +4710,12 @@ static int transport_processing_thread(v
 	struct se_cmd *cmd;
 	struct se_device *dev = (struct se_device *) param;
 
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		ret = wait_event_interruptible(dev->dev_queue_obj.thread_wq,
 				atomic_read(&dev->dev_queue_obj.queue_cnt) ||
 				kthread_should_stop());
@@ -4724,7 +4773,13 @@ get_cmd:
 		}
 
 		goto get_cmd;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	WARN_ON(!list_empty(&dev->state_task_list));
diff -u -p a/target/target_core_tmr.c b/target/target_core_tmr.c
--- a/target/target_core_tmr.c
+++ b/target/target_core_tmr.c
@@ -231,6 +231,11 @@ static void core_tmr_drain_task_list(
 	}
 	spin_unlock_irqrestore(&dev->execute_task_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&drain_task_list)) {
 		task = list_entry(drain_task_list.next, struct se_task, t_state_list);
 		list_del(&task->t_state_list);
@@ -293,6 +298,12 @@ static void core_tmr_drain_task_list(
 		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 
 		core_tmr_handle_tas_abort(tmr_nacl, cmd, tas, fe_count);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -337,6 +348,11 @@ static void core_tmr_drain_cmd_list(
 	}
 	spin_unlock_irqrestore(&qobj->cmd_queue_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&drain_cmd_list)) {
 		cmd = list_entry(drain_cmd_list.next, struct se_cmd, se_queue_node);
 		list_del_init(&cmd->se_queue_node);
@@ -348,6 +364,12 @@ static void core_tmr_drain_cmd_list(
 
 		core_tmr_handle_tas_abort(tmr_nacl, cmd, tas,
 				atomic_read(&cmd->t_fe_count));
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
diff -u -p a/target/target_core_pscsi.c b/target/target_core_pscsi.c
--- a/target/target_core_pscsi.c
+++ b/target/target_core_pscsi.c
@@ -1053,11 +1053,22 @@ static int pscsi_map_sg(struct se_task *
 
 	return task->task_sg_nents;
 fail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*hbio) {
 		bio = *hbio;
 		*hbio = (*hbio)->bi_next;
 		bio->bi_next = NULL;
 		bio_endio(bio, 0);	/* XXX: should be error */
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	cmd->scsi_sense_reason = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 	return -ENOMEM;
@@ -1126,11 +1137,22 @@ static int pscsi_do_task(struct se_task
 	return 0;
 
 fail:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hbio) {
 		struct bio *bio = hbio;
 		hbio = hbio->bi_next;
 		bio->bi_next = NULL;
 		bio_endio(bio, 0);	/* XXX: should be error */
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	cmd->scsi_sense_reason = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 	return -ENOMEM;
diff -u -p a/target/target_core_iblock.c b/target/target_core_iblock.c
--- a/target/target_core_iblock.c
+++ b/target/target_core_iblock.c
@@ -573,12 +573,23 @@ static int iblock_do_task(struct se_task
 		 *	length of the S/G list entry this will cause and
 		 *	endless loop.  Better hope no driver uses huge pages.
 		 */
-		while (bio_add_page(bio, sg_page(sg), sg->length, sg->offset)
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (bio_add_page(bio, sg_page(sg), sg->length, sg->offset)
 				!= sg->length) {
 			bio = iblock_get_bio(task, block_lba, sg_num);
 			if (!bio)
 				goto fail;
 			bio_list_add(&list, bio);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Always in 512 byte units for Linux/Block */
diff -u -p a/target/tcm_fc/tfc_io.c b/target/tcm_fc/tfc_io.c
--- a/target/tcm_fc/tfc_io.c
+++ b/target/tcm_fc/tfc_io.c
@@ -106,6 +106,11 @@ int ft_queue_data_in(struct se_cmd *se_c
 	/* no scatter/gather in skb for odd word length due to fc_seq_send() */
 	use_sg = !(remaining % 4);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (remaining) {
 		if (!mem_len) {
 			sg = sg_next(sg);
@@ -183,6 +188,12 @@ int ft_queue_data_in(struct se_cmd *se_c
 						__func__, fp, ep->xid,
 						remaining, lport->lso_max);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return ft_queue_status(se_cmd);
 }
@@ -278,6 +289,11 @@ void ft_recv_write_data(struct ft_cmd *c
 		page = sg_page(sg);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (frame_len) {
 		if (!mem_len) {
 			sg = sg_next(sg);
@@ -310,7 +326,13 @@ void ft_recv_write_data(struct ft_cmd *c
 		mem_off += tlen;
 		mem_len -= tlen;
 		cmd->write_data_len += tlen;
-	}
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+}
 last_frame:
 	if (cmd->write_data_len == se_cmd->data_length)
 		transport_generic_handle_data(se_cmd);
diff -u -p a/target/target_core_rd.c b/target/target_core_rd.c
--- a/target/target_core_rd.c
+++ b/target/target_core_rd.c
@@ -158,7 +158,12 @@ static int rd_build_device_space(struct
 	rd_dev->sg_table_array = sg_table;
 	rd_dev->sg_table_count = sg_tables;
 
-	while (total_sg_needed) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
 			max_sg_per_table : total_sg_needed;
 
@@ -191,6 +196,12 @@ static int rd_build_device_space(struct
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_debug("CORE_RD[%u] - Built Ramdisk Device ID: %u space of"
@@ -367,6 +378,11 @@ static int rd_MEMCPY(struct rd_request *
 	src_len = PAGE_SIZE - rd_offset;
 	sg_miter_start(&m, task->task_sg, task->task_sg_nents,
 			read_rd ? SG_MITER_TO_SG : SG_MITER_FROM_SG);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (req->rd_size) {
 		u32 len;
 		void *rd_addr;
@@ -409,6 +425,12 @@ static int rd_MEMCPY(struct rd_request *
 
 		/* since we increment, the first sg entry is correct */
 		rd_sg = table->sg_table;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	sg_miter_stop(&m);
 	return 0;
diff -u -p a/target/target_core_alua.c b/target/target_core_alua.c
--- a/target/target_core_alua.c
+++ b/target/target_core_alua.c
@@ -231,6 +231,11 @@ int target_emulate_set_target_port_group
 
 	ptr = &buf[4]; /* Skip over RESERVED area in header */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len < cmd->data_length) {
 		alua_access_state = (ptr[0] & 0x0f);
 		/*
@@ -348,7 +353,13 @@ int target_emulate_set_target_port_group
 
 		ptr += 4;
 		len += 4;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 out:
 	transport_kunmap_data_sg(cmd);
diff -u -p a/virtio/virtio_ring.c b/virtio/virtio_ring.c
--- a/virtio/virtio_ring.c
+++ b/virtio/virtio_ring.c
@@ -285,9 +285,20 @@ static void detach_buf(struct vring_virt
 	if (vq->vring.desc[i].flags & VRING_DESC_F_INDIRECT)
 		kfree(phys_to_virt(vq->vring.desc[i].addr));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (vq->vring.desc[i].flags & VRING_DESC_F_NEXT) {
 		i = vq->vring.desc[i].next;
 		vq->num_free++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	vq->vring.desc[i].next = vq->free_head;
diff -u -p a/virtio/virtio_balloon.c b/virtio/virtio_balloon.c
--- a/virtio/virtio_balloon.c
+++ b/virtio/virtio_balloon.c
@@ -255,7 +255,12 @@ static int balloon(void *_vballoon)
 	struct virtio_balloon *vb = _vballoon;
 
 	set_freezable();
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		s64 diff;
 
 		try_to_freeze();
@@ -277,6 +282,12 @@ static int balloon(void *_vballoon)
 		 * and always have work to do.  Be nice if preempt disabled.
 		 */
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/telephony/ixj.c b/telephony/ixj.c
--- a/telephony/ixj.c
+++ b/telephony/ixj.c
@@ -1413,12 +1413,23 @@ static int ixj_status_wait(IXJ *j)
 	unsigned long jif;
 
 	jif = jiffies + ((60 * hertz) / 100);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!IsStatusReady(j)) {
 		ixj_perfmon(j->statuswait);
 		if (time_after(jiffies, jif)) {
 			ixj_perfmon(j->statuswaitfail);
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1428,12 +1439,23 @@ static int ixj_PCcontrol_wait(IXJ *j)
 	unsigned long jif;
 
 	jif = jiffies + ((60 * hertz) / 100);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!IsPCControlReady(j)) {
 		ixj_perfmon(j->pcontrolwait);
 		if (time_after(jiffies, jif)) {
 			ixj_perfmon(j->pcontrolwaitfail);
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -1451,6 +1473,11 @@ static int ixj_WriteDSPCommand(unsigned
 	bytes.high = (cmd & 0xFF00) >> 8;
 	bytes.low = cmd & 0x00FF;
 	jif = jiffies + ((60 * hertz) / 100);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!IsControlReady(j)) {
 		ixj_perfmon(j->iscontrolready);
 		if (time_after(jiffies, jif)) {
@@ -1464,6 +1491,12 @@ static int ixj_WriteDSPCommand(unsigned
 			}
 			return -1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	outb(bytes.low, j->DSPbase + 6);
 	outb(bytes.high, j->DSPbase + 7);
@@ -2758,6 +2791,11 @@ static ssize_t ixj_read(struct file * fi
 	set_current_state(TASK_INTERRUPTIBLE);
 	mb();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!j->read_buffer_ready || (j->dtmf_state && j->flags.dtmf_oob)) {
 		++j->read_wait;
 		if (file_p->f_flags & O_NONBLOCK) {
@@ -2779,6 +2817,12 @@ static ssize_t ixj_read(struct file * fi
 			j->flags.inread = 0;
 			return -EINTR;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	remove_wait_queue(&j->read_q, &wait);
@@ -2839,6 +2883,11 @@ static ssize_t ixj_write(struct file *fi
 	mb();
 
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!j->write_buffers_empty) {
 		++j->write_wait;
 		if (file_p->f_flags & O_NONBLOCK) {
@@ -2860,6 +2909,12 @@ static ssize_t ixj_write(struct file *fi
 			j->flags.inwrite = 0;
 			return -EINTR;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&j->write_q, &wait);
@@ -5018,6 +5073,11 @@ static int ixj_daa_cid_read(IXJ *j)
 	pIn = CID;
 	pOut = j->m_DAAShadowRegs.CAO_REGS.CAO.CallerID;
 	mContinue = true;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mContinue) {
 		if ((pIn[1] & 0x03) == 0x01) {
 			pOut[0] = pIn[0];
@@ -5034,6 +5094,12 @@ static int ixj_daa_cid_read(IXJ *j)
 			mContinue = false;
 		}
 		pIn += 5, pOut += 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	memset(&j->cid, 0, sizeof(PHONE_CID));
 	pOut = j->m_DAAShadowRegs.CAO_REGS.CAO.CallerID;
diff -u -p a/platform/x86/thinkpad_acpi.c b/platform/x86/thinkpad_acpi.c
--- a/platform/x86/thinkpad_acpi.c
+++ b/platform/x86/thinkpad_acpi.c
@@ -480,6 +480,11 @@ static unsigned long __init tpacpi_check
 			const struct tpacpi_quirk *qlist,
 			unsigned int qlist_size)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (qlist_size) {
 		if ((qlist->vendor == thinkpad_id.vendor ||
 				qlist->vendor == TPACPI_MATCH_ANY) &&
@@ -491,6 +496,12 @@ static unsigned long __init tpacpi_check
 
 		qlist_size--;
 		qlist++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -575,6 +586,11 @@ static int acpi_evalf(acpi_handle handle
 	params.pointer = &in_objs[0];
 
 	va_start(ap, fmt);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*fmt) {
 		char c = *(fmt++);
 		switch (c) {
@@ -589,6 +605,12 @@ static int acpi_evalf(acpi_handle handle
 			va_end(ap);
 			return 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	va_end(ap);
 
@@ -1397,6 +1419,11 @@ static int tpacpi_rfk_procfs_write(const
 	if (id >= TPACPI_RFK_SW_MAX)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "enable") == 0)
 			status = TPACPI_RFK_RADIO_ON;
@@ -1404,6 +1431,12 @@ static int tpacpi_rfk_procfs_write(const
 			status = TPACPI_RFK_RADIO_OFF;
 		else
 			return -EINVAL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	if (status != -1) {
@@ -1590,10 +1623,21 @@ static int __init tpacpi_create_driver_a
 
 	i = 0;
 	res = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!res && i < ARRAY_SIZE(tpacpi_driver_attributes)) {
 		res = driver_create_file(drv, tpacpi_driver_attributes[i]);
 		i++;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 #ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES
 	if (!res && dbg_wlswemul)
@@ -3667,6 +3711,11 @@ static void hotkey_notify(struct ibm_str
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		if (!acpi_evalf(hkey_handle, &hkey, "MHKP", "d")) {
 			pr_err("failed to retrieve HKEY event\n");
@@ -3758,6 +3807,12 @@ static void hotkey_notify(struct ibm_str
 					dev_name(&ibm->acpi->device->dev),
 					event, hkey);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -3842,6 +3897,11 @@ static int hotkey_write(char *buf)
 	mask = hotkey_user_mask;
 
 	res = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "enable") == 0) {
 			hotkey_enabledisable_warn(1);
@@ -3859,6 +3919,12 @@ static int hotkey_write(char *buf)
 			res = -EINVAL;
 			goto errexit;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!res) {
@@ -4704,6 +4770,11 @@ static int video_write(char *buf)
 	enable = 0;
 	disable = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "lcd_enable") == 0) {
 			enable |= TP_ACPI_VIDEO_S_LCD;
@@ -4737,6 +4808,12 @@ static int video_write(char *buf)
 				return res;
 		} else
 			return -EINVAL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	if (enable || disable) {
@@ -4911,6 +4988,11 @@ static int light_write(char *buf)
 	if (!tp_features.light)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "on") == 0) {
 			newstatus = 1;
@@ -4918,6 +5000,12 @@ static int light_write(char *buf)
 			newstatus = 0;
 		} else
 			return -EINVAL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return light_set_status(newstatus);
@@ -4997,7 +5085,12 @@ static int cmos_write(char *buf)
 	char *cmd;
 	int cmos_cmd, res;
 
-	while ((cmd = next_cmd(&buf))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((cmd = next_cmd(&buf))) {
 		if (sscanf(cmd, "%u", &cmos_cmd) == 1 &&
 		    cmos_cmd >= 0 && cmos_cmd <= 21) {
 			/* cmos_cmd set */
@@ -5007,6 +5100,12 @@ static int cmos_write(char *buf)
 		res = issue_thinkpad_cmos_command(cmos_cmd);
 		if (res)
 			return res;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -5407,6 +5506,11 @@ static int led_write(char *buf)
 	if (!led_supported)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cmd = next_cmd(&buf))) {
 		if (sscanf(cmd, "%d", &led) != 1 || led < 0 || led > 15)
 			return -EINVAL;
@@ -5424,6 +5528,12 @@ static int led_write(char *buf)
 		rc = led_set_status(led, s);
 		if (rc < 0)
 			return rc;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return 0;
@@ -5488,7 +5598,12 @@ static int beep_write(char *buf)
 	if (!beep_handle)
 		return -ENODEV;
 
-	while ((cmd = next_cmd(&buf))) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((cmd = next_cmd(&buf))) {
 		if (sscanf(cmd, "%u", &beep_cmd) == 1 &&
 		    beep_cmd >= 0 && beep_cmd <= 17) {
 			/* beep_cmd set */
@@ -5503,6 +5618,12 @@ static int beep_write(char *buf)
 					beep_cmd))
 				return -EIO;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return 0;
@@ -6380,6 +6501,11 @@ static int brightness_write(char *buf)
 	if (level < 0)
 		return level;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "up") == 0) {
 			if (level < bright_maxlvl)
@@ -6392,6 +6518,12 @@ static int brightness_write(char *buf)
 			/* new level set */
 		} else
 			return -EINVAL;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	tpacpi_disclose_usertask("procfs brightness",
@@ -7041,6 +7173,11 @@ static int volume_write(char *buf)
 	new_level = s & TP_EC_AUDIO_LVL_MSK;
 	new_mute  = s & TP_EC_AUDIO_MUTESW_MSK;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((cmd = next_cmd(&buf))) {
 		if (!tp_features.mixer_no_level_control) {
 			if (strlencmp(cmd, "up") == 0) {
@@ -7067,6 +7204,12 @@ static int volume_write(char *buf)
 			new_mute = 0;
 		else
 			return -EINVAL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (tp_features.mixer_no_level_control) {
@@ -8357,6 +8500,11 @@ static int fan_write(char *buf)
 	char *cmd;
 	int rc = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!rc && (cmd = next_cmd(&buf))) {
 		if (!((fan_control_commands & TPACPI_FAN_CMD_LEVEL) &&
 		      fan_write_cmd_level(cmd, &rc)) &&
@@ -8370,6 +8518,12 @@ static int fan_write(char *buf)
 			rc = -EINVAL;
 		else if (!rc)
 			fan_watchdog_reset();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	return rc;
diff -u -p a/platform/x86/toshiba_acpi.c b/platform/x86/toshiba_acpi.c
--- a/platform/x86/toshiba_acpi.c
+++ b/platform/x86/toshiba_acpi.c
@@ -610,6 +610,11 @@ static ssize_t video_proc_write(struct f
 	 *
 	 *  NOTE: to keep scanning simple, invalid fields are ignored
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (remain) {
 		if (sscanf(buffer, " lcd_out : %i", &value) == 1)
 			lcd_out = value & 1;
@@ -623,6 +628,12 @@ static ssize_t video_proc_write(struct f
 			--remain;
 		}
 		while (remain && *(buffer - 1) != ';');
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(cmd);
diff -u -p a/platform/x86/intel_scu_ipc.c b/platform/x86/intel_scu_ipc.c
--- a/platform/x86/intel_scu_ipc.c
+++ b/platform/x86/intel_scu_ipc.c
@@ -140,6 +140,11 @@ static inline int busy_loop(void) /* Wai
 	u32 loop_count = 0;
 
 	status = ipc_read_status();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & 1) {
 		udelay(1); /* scu processing time is in few u secods */
 		status = ipc_read_status();
@@ -149,6 +154,12 @@ static inline int busy_loop(void) /* Wai
 			dev_err(&ipcdev.pdev->dev, "IPC timed out");
 			return -ETIMEDOUT;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if ((status >> 1) & 1)
 		return -EIO;
diff -u -p a/parport/ieee1284_ops.c b/parport/ieee1284_ops.c
--- a/parport/ieee1284_ops.c
+++ b/parport/ieee1284_ops.c
@@ -521,6 +521,11 @@ size_t parport_ieee1284_ecp_read_data (s
 
 		/* Event 43: Peripheral sets nAck low. It can take as
                    long as it wants. */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (parport_wait_peripheral (port, PARPORT_STATUS_ACK, 0)) {
 			/* The peripheral hasn't given us data in
 			   35ms.  If we have data to give back to the
@@ -546,6 +551,12 @@ size_t parport_ieee1284_ecp_read_data (s
 			/* Is there a signal pending? */
 			if (signal_pending (current))
 				goto out;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Is this a command? */
diff -u -p a/parport/ieee1284.c b/parport/ieee1284.c
--- a/parport/ieee1284.c
+++ b/parport/ieee1284.c
@@ -198,6 +198,11 @@ int parport_wait_peripheral(struct parpo
 
 	/* 40ms of slow polling. */
 	deadline = jiffies + msecs_to_jiffies(40);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before (jiffies, deadline)) {
 		if (signal_pending (current))
 			return -EINTR;
@@ -217,6 +222,12 @@ int parport_wait_peripheral(struct parpo
 			 * Wait for another 10ms. */
 			schedule_timeout_interruptible(msecs_to_jiffies(10));
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 1;
diff -u -p a/parport/probe.c b/parport/probe.c
--- a/parport/probe.c
+++ b/parport/probe.c
@@ -61,6 +61,11 @@ static void parse_data(struct parport *p
 		return;
 	}
 	strcpy(txt, str);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (p) {
 		char *sep;
 		q = strchr(p, ';');
@@ -74,9 +79,20 @@ static void parse_data(struct parport *p
 			while (u >= p && *u == ' ')
 				*u-- = '\0';
 			u = p;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (*u) {
 				*u = toupper(*u);
 				u++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			if (!strcmp(p, "MFG") || !strcmp(p, "MANUFACTURER")) {
 				kfree(info->mfr);
@@ -117,6 +133,12 @@ static void parse_data(struct parport *p
 			p = q + 1;
 		else
 			p = NULL;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* If the device didn't tell us its class, maybe we have managed to
diff -u -p a/parport/daisy.c b/parport/daisy.c
--- a/parport/daisy.c
+++ b/parport/daisy.c
@@ -178,6 +178,11 @@ void parport_daisy_fini(struct parport *
 
 	spin_lock(&topology_lock);
 	p = &topology;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*p) {
 		struct daisydev *dev = *p;
 		if (dev->port != port) {
@@ -186,6 +191,12 @@ void parport_daisy_fini(struct parport *
 		}
 		*p = dev->next;
 		kfree(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Gaps in the numbering could be handled better.  How should
diff -u -p a/oprofile/buffer_sync.c b/oprofile/buffer_sync.c
--- a/oprofile/buffer_sync.c
+++ b/oprofile/buffer_sync.c
@@ -586,11 +586,22 @@ void oprofile_put_buff(unsigned long *bu
 	i = start;
 
 	mutex_lock(&buffer_mutex);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i != stop) {
 		add_event_entry(buf[i++]);
 
 		if (i >= max)
 			i = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	mutex_unlock(&buffer_mutex);
diff -u -p a/bluetooth/bluecard_cs.c b/bluetooth/bluecard_cs.c
--- a/bluetooth/bluecard_cs.c
+++ b/bluetooth/bluecard_cs.c
@@ -349,6 +349,11 @@ static int bluecard_read(unsigned int io
 	n = 0;
 	i = 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (n < len) {
 
 		if (i == 16) {
@@ -361,6 +366,12 @@ static int bluecard_read(unsigned int io
 		n++;
 		i++;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return len;
diff -u -p a/bluetooth/bt3c_cs.c b/bluetooth/bt3c_cs.c
--- a/bluetooth/bt3c_cs.c
+++ b/bluetooth/bt3c_cs.c
@@ -164,10 +164,21 @@ static int bt3c_write(unsigned int iobas
 	bt3c_address(iobase, 0x7080);
 
 	/* Fill FIFO with current frame */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (actual < len) {
 		/* Transmit next byte */
 		bt3c_put(iobase, buf[actual]);
 		actual++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bt3c_io_write(iobase, 0x7005, actual);
@@ -231,6 +242,11 @@ static void bt3c_receive(bt3c_info_t *in
 	//printk("bt3c_cs: receiving %d bytes\n", avail);
 
 	bt3c_address(iobase, 0x7480);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size < avail) {
 		size++;
 		info->hdev->stat.byte_rx++;
@@ -329,6 +345,12 @@ static void bt3c_receive(bt3c_info_t *in
 
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bt3c_io_write(iobase, 0x7006, 0x0000);
@@ -492,6 +514,11 @@ static int bt3c_load_firmware(bt3c_info_
 	udelay(17);
 
 	/* Load */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		if (ptr[0] != 'S') {
 			BT_ERR("Bad address in firmware");
@@ -536,6 +563,12 @@ static int bt3c_load_firmware(bt3c_info_
 
 		ptr   += (size * 2) + 6;
 		count -= (size * 2) + 6;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	udelay(17);
diff -u -p a/bluetooth/btsdio.c b/bluetooth/btsdio.c
--- a/bluetooth/btsdio.c
+++ b/bluetooth/btsdio.c
@@ -308,9 +308,20 @@ static int btsdio_probe(struct sdio_func
 
 	BT_DBG("func %p id %p class 0x%04x", func, id, func->class);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tuple) {
 		BT_DBG("code 0x%x size %d", tuple->code, tuple->size);
 		tuple = tuple->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	data = kzalloc(sizeof(*data), GFP_KERNEL);
diff -u -p a/bluetooth/hci_bcsp.c b/bluetooth/hci_bcsp.c
--- a/bluetooth/hci_bcsp.c
+++ b/bluetooth/hci_bcsp.c
@@ -558,6 +558,11 @@ static int bcsp_recv(struct hci_uart *hu
 		hu, count, bcsp->rx_state, bcsp->rx_count);
 
 	ptr = data;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		if (bcsp->rx_count) {
 			if (*ptr == 0xc0) {
@@ -660,6 +665,12 @@ static int bcsp_recv(struct hci_uart *hu
 			}
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return count;
 }
diff -u -p a/bluetooth/bfusb.c b/bluetooth/bfusb.c
--- a/bluetooth/bfusb.c
+++ b/bluetooth/bfusb.c
@@ -113,10 +113,21 @@ static void bfusb_unlink_urbs(struct bfu
 
 	BT_DBG("bfusb %p", data);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((skb = skb_dequeue(&data->pending_q))) {
 		urb = ((struct bfusb_data_scb *) skb->cb)->urb;
 		usb_kill_urb(urb);
 		skb_queue_tail(&data->completed_q, skb);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	while ((urb = bfusb_get_completed(data)))
@@ -362,6 +373,11 @@ static void bfusb_rx_complete(struct urb
 
 	skb_put(skb, count);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		hdr = buf[0] | (buf[1] << 8);
 
@@ -385,6 +401,12 @@ static void bfusb_rx_complete(struct urb
 
 		count -= len;
 		buf   += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	skb_unlink(skb, &data->pending_q);
@@ -511,6 +533,11 @@ static int bfusb_send_frame(struct sk_bu
 
 	nskb->dev = (void *) data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		size = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE);
 
@@ -523,6 +550,12 @@ static int bfusb_send_frame(struct sk_bu
 
 		sent  += size;
 		count -= size;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	/* Don't send frame with multiple size of bulk max packet */
@@ -587,7 +620,12 @@ static int bfusb_load_firmware(struct bf
 
 	pipe = usb_sndbulkpipe(data->udev, data->bulk_out_ep);
 
-	while (count) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (count) {
 		size = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE + 3);
 
 		memcpy(buf, firmware + sent, size);
@@ -602,6 +640,12 @@ static int bfusb_load_firmware(struct bf
 
 		sent  += size;
 		count -= size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	err = usb_bulk_msg(data->udev, pipe, NULL, 0,
diff -u -p a/bluetooth/bpa10x.c b/bluetooth/bpa10x.c
--- a/bluetooth/bpa10x.c
+++ b/bluetooth/bpa10x.c
@@ -76,6 +76,11 @@ static int bpa10x_recv(struct hci_dev *h
 
 	hdev->stat.byte_rx += count;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		struct sk_buff *skb = data->rx_skb[queue];
 		struct { __u8 type; int expect; } *scb;
@@ -159,6 +164,12 @@ static int bpa10x_recv(struct hci_dev *h
 		}
 
 		count -= len; buf += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/bluetooth/ath3k.c b/bluetooth/ath3k.c
--- a/bluetooth/ath3k.c
+++ b/bluetooth/ath3k.c
@@ -177,6 +177,11 @@ static int ath3k_load_firmware(struct us
 	sent += 20;
 	count -= 20;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		size = min_t(uint, count, BULK_SIZE);
 		pipe = usb_sndbulkpipe(udev, 0x02);
@@ -193,7 +198,13 @@ static int ath3k_load_firmware(struct us
 
 		sent  += size;
 		count -= size;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+}
 
 error:
 	kfree(send_buf);
@@ -253,6 +264,11 @@ static int ath3k_load_fwfile(struct usb_
 	sent += size;
 	count -= size;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		size = min_t(uint, count, BULK_SIZE);
 		pipe = usb_sndbulkpipe(udev, 0x02);
@@ -269,6 +285,12 @@ static int ath3k_load_fwfile(struct usb_
 		}
 		sent  += size;
 		count -= size;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	kfree(send_buf);
diff -u -p a/macintosh/adb-iop.c b/macintosh/adb-iop.c
--- a/macintosh/adb-iop.c
+++ b/macintosh/adb-iop.c
@@ -277,9 +277,20 @@ int adb_iop_reset_bus(void)
 	};
 
 	adb_iop_write(&req);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!req.complete) {
 		adb_iop_poll();
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/macintosh/adb.c b/macintosh/adb.c
--- a/macintosh/adb.c
+++ b/macintosh/adb.c
@@ -485,10 +485,21 @@ adb_unregister(int index)
 	mutex_lock(&adb_handler_mutex);
 	write_lock_irq(&adb_handler_lock);
 	if (adb_handler[index].handler) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while(adb_handler[index].busy) {
 			write_unlock_irq(&adb_handler_lock);
 			yield();
 			write_lock_irq(&adb_handler_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		ret = 0;
 		adb_handler[index].handler = NULL;
diff -u -p a/macintosh/smu.c b/macintosh/smu.c
--- a/macintosh/smu.c
+++ b/macintosh/smu.c
@@ -916,6 +916,11 @@ static int smu_read_datablock(u8 *dest,
 	 */
 	chunk = 0xe;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len) {
 		unsigned int clen = min(len, chunk);
 
@@ -946,6 +951,12 @@ static int smu_read_datablock(u8 *dest,
 		len -= clen;
 		addr += clen;
 		dest += clen;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/macintosh/windfarm_core.c b/macintosh/windfarm_core.c
--- a/macintosh/windfarm_core.c
+++ b/macintosh/windfarm_core.c
@@ -95,6 +95,11 @@ static int wf_thread_func(void *data)
 	DBG("wf: thread started\n");
 
 	set_freezable();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		try_to_freeze();
 
@@ -119,6 +124,12 @@ static int wf_thread_func(void *data)
 		delay = next - jiffies;
 		if (delay <= HZ)
 			schedule_timeout_interruptible(delay);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	DBG("wf: thread stopped\n");
diff -u -p a/macintosh/therm_pm72.c b/macintosh/therm_pm72.c
--- a/macintosh/therm_pm72.c
+++ b/macintosh/therm_pm72.c
@@ -1812,6 +1812,11 @@ static int main_control_loop(void *x)
 
 	mutex_unlock(&driver_lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (state == state_attached) {
 		unsigned long elapsed, start;
 
@@ -1871,6 +1876,12 @@ static int main_control_loop(void *x)
 		elapsed = jiffies - start;
 		if (elapsed < HZ)
 			schedule_timeout_interruptible(HZ - elapsed);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
  out:
diff -u -p a/macintosh/windfarm_smu_controls.c b/macintosh/windfarm_smu_controls.c
--- a/macintosh/windfarm_smu_controls.c
+++ b/macintosh/windfarm_smu_controls.c
@@ -313,10 +313,21 @@ static void __exit smu_controls_exit(voi
 {
 	struct smu_fan_control *fct;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&smu_fans)) {
 		fct = list_entry(smu_fans.next, struct smu_fan_control, link);
 		list_del(&fct->link);
 		wf_unregister_control(&fct->ctrl);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/macintosh/via-pmu68k.c b/macintosh/via-pmu68k.c
--- a/macintosh/via-pmu68k.c
+++ b/macintosh/via-pmu68k.c
@@ -197,6 +197,11 @@ pmu_init(void)
 
 	pmu_request((struct adb_request *) &req, NULL, 2, PMU_SET_INTR_MASK, PMU_INT_ADB);
 	timeout =  100000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_init: no response from PMU\n");
@@ -204,11 +209,22 @@ pmu_init(void)
 		}
 		udelay(10);
 		pmu_poll();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* ack all pending interrupts */
 	timeout = 100000;
 	interrupt_data[0] = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (interrupt_data[0] || pmu_state != idle) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_init: timed out acking intrs\n");
@@ -220,11 +236,22 @@ pmu_init(void)
 		}
 		pmu_poll();
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pmu_request((struct adb_request *) &req, NULL, 2, PMU_SET_INTR_MASK,
 			PMU_INT_ADB_AUTO|PMU_INT_SNDBRT|PMU_INT_ADB);
 	timeout =  100000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_init: no response from PMU\n");
@@ -232,6 +259,12 @@ pmu_init(void)
 		}
 		udelay(10);
 		pmu_poll();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	bright_req_1.complete = 1;
@@ -428,6 +461,11 @@ pmu_reset_bus(void)
 	while (!req.complete)
 		pmu_poll();
 	timeout = 100000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "pmu_adb_reset_bus (reset): no response from PMU\n");
@@ -435,6 +473,12 @@ pmu_reset_bus(void)
 		}
 		udelay(10);
 		pmu_poll();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (save_autopoll != 0)
@@ -590,12 +634,23 @@ pmu_interrupt(int irq, void *dev_id)
 		/* reset TREQ and wait for TACK to go high */
 		via2[B] |= TREQ;
 		timeout = 3200;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(via2[B] & TACK)) {
 			if (--timeout < 0) {
 				printk(KERN_ERR "PMU not responding (!ack)\n");
 				goto finish;
 			}
 			udelay(10);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 		}
 
 		switch (pmu_state) {
diff -u -p a/macintosh/mediabay.c b/macintosh/mediabay.c
--- a/macintosh/mediabay.c
+++ b/macintosh/mediabay.c
@@ -543,6 +543,11 @@ static int media_bay_task(void *x)
 {
 	int	i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		for (i = 0; i < media_bay_count; ++i) {
 			mutex_lock(&media_bays[i].lock);
@@ -552,6 +557,12 @@ static int media_bay_task(void *x)
 		}
 
 		msleep_interruptible(MB_POLL_DELAY);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/macintosh/therm_adt746x.c b/macintosh/therm_adt746x.c
--- a/macintosh/therm_adt746x.c
+++ b/macintosh/therm_adt746x.c
@@ -346,6 +346,11 @@ static int monitor_task(void *arg)
 	struct thermostat* th = arg;
 
 	set_freezable();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(!kthread_should_stop()) {
 		try_to_freeze();
 		msleep_interruptible(2000);
@@ -364,6 +369,12 @@ static int monitor_task(void *arg)
 		display_stats(th);
 #endif
 
+if (_cur < timeout) {
+	rdstcll(_cur);
+}
+else {
+	break;
+}
 	}
 
 	return 0;
diff -u -p a/macintosh/windfarm_smu_sensors.c b/macintosh/windfarm_smu_sensors.c
--- a/macintosh/windfarm_smu_sensors.c
+++ b/macintosh/windfarm_smu_sensors.c
@@ -466,10 +466,21 @@ static void __exit smu_sensors_exit(void
 		wf_unregister_sensor(&smu_cpu_power->sens);
 
 	/* dispose of basic sensors */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&smu_ads)) {
 		ads = list_entry(smu_ads.next, struct smu_ad_sensor, link);
 		list_del(&ads->link);
 		wf_unregister_sensor(&ads->sens);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/macintosh/via-macii.c b/macintosh/via-macii.c
--- a/macintosh/via-macii.c
+++ b/macintosh/via-macii.c
@@ -126,12 +126,23 @@ static int request_is_queued(struct adb_
 	unsigned long flags;
 	local_irq_save(flags);
 	cur = current_req;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cur) {
 		if (cur == req) {
 			local_irq_restore(flags);
 			return 1;
 		}
 		cur = cur->next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	local_irq_restore(flags);
 	return 0;
@@ -244,8 +255,19 @@ static int macii_send_request(struct adb
 	local_irq_restore(flags);
 
 	if (!err && sync) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!req->complete) {
 			macii_poll();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		BUG_ON(request_is_queued(req));
 	}
diff -u -p a/macintosh/via-pmu.c b/macintosh/via-pmu.c
--- a/macintosh/via-pmu.c
+++ b/macintosh/via-pmu.c
@@ -531,6 +531,11 @@ init_pmu(void)
 
 	pmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, pmu_intr_mask);
 	timeout =  100000;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!req.complete) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "init_pmu: no response from PMU\n");
@@ -538,11 +543,22 @@ init_pmu(void)
 		}
 		udelay(10);
 		pmu_poll();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* ack all pending interrupts */
 	timeout = 100000;
 	interrupt_data[0][0] = 1;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (interrupt_data[0][0] || pmu_state != idle) {
 		if (--timeout < 0) {
 			printk(KERN_ERR "init_pmu: timed out acking intrs\n");
@@ -552,6 +568,12 @@ init_pmu(void)
 			adb_int_pending = 1;
 		via_pmu_interrupt(0, NULL);
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Tell PMU we are ready.  */
@@ -2000,10 +2022,21 @@ static int powerbook_sleep_3400(void)
 	mtspr(SPRN_HID0, hid0);
 	local_irq_enable();
 	msr = mfmsr() | MSR_POW;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (asleep) {
 		mb();
 		mtmsr(msr);
 		isync();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	local_irq_disable();
 
diff -u -p a/memstick/core/memstick.c b/memstick/core/memstick.c
--- a/memstick/core/memstick.c
+++ b/memstick/core/memstick.c
@@ -51,10 +51,21 @@ static int memstick_bus_match(struct dev
 	struct memstick_device_id *ids = ms_drv->id_table;
 
 	if (ids) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ids->match_flags) {
 			if (memstick_dev_match(card, ids))
 				return 1;
 			++ids;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 0;
diff -u -p a/memstick/core/mspro_block.c b/memstick/core/mspro_block.c
--- a/memstick/core/mspro_block.c
+++ b/memstick/core/mspro_block.c
@@ -703,7 +703,12 @@ static int mspro_block_issue_req(struct
 	unsigned int count;
 
 try_again:
-	while (chunk) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (chunk) {
 		msb->current_page = 0;
 		msb->current_seg = 0;
 		msb->seg_count = blk_rq_map_sg(msb->block_req->q,
@@ -728,6 +733,12 @@ try_again:
 
 		memstick_new_req(card->host);
 		return 0;
+		if (_cur < timeout) {
+				    rdstcll(_cur);
+		}
+		else {
+				    break;
+		}
 	}
 
 	dev_dbg(&card->dev, "blk_fetch\n");
diff -u -p a/memstick/host/tifm_ms.c b/memstick/host/tifm_ms.c
--- a/memstick/host/tifm_ms.c
+++ b/memstick/host/tifm_ms.c
@@ -89,11 +89,22 @@ static unsigned int tifm_ms_read_data(st
 	struct tifm_dev *sock = host->dev;
 	unsigned int off = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (host->io_pos && length) {
 		buf[off++] = host->io_word & 0xff;
 		host->io_word >>= 8;
 		length--;
 		host->io_pos--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!length)
diff -u -p a/memstick/host/r592.c b/memstick/host/r592.c
--- a/memstick/host/r592.c
+++ b/memstick/host/r592.c
@@ -115,6 +115,11 @@ static int r592_wait_status(struct r592_
 	if ((reg & mask) == wanted_mask)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, timeout)) {
 
 		reg = r592_read_reg(dev, R592_STATUS);
@@ -126,6 +131,12 @@ static int r592_wait_status(struct r592_
 			return -EIO;
 
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -ETIME;
 }
@@ -567,6 +578,11 @@ static int r592_process_thread(void *dat
 	struct r592_device *dev = (struct r592_device *)data;
 	unsigned long flags;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		spin_lock_irqsave(&dev->io_thread_lock, flags);
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -589,6 +605,12 @@ static int r592_process_thread(void *dat
 			set_current_state(TASK_RUNNING);
 			r592_execute_tpc(dev);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -829,9 +851,20 @@ static void r592_remove(struct pci_dev *
 
 	r592_enable_device(dev, false);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!error && dev->req) {
 		dev->req->error = -ETIME;
 		error = memstick_next_req(dev->host, &dev->req);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	memstick_remove_host(dev->host);
 
diff -u -p a/memstick/host/jmb38x_ms.c b/memstick/host/jmb38x_ms.c
--- a/memstick/host/jmb38x_ms.c
+++ b/memstick/host/jmb38x_ms.c
@@ -159,11 +159,22 @@ static unsigned int jmb38x_ms_read_data(
 {
 	unsigned int off = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (host->io_pos && length) {
 		buf[off++] = host->io_word[0] & 0xff;
 		host->io_word[0] >>= 8;
 		length--;
 		host->io_pos--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!length)
@@ -208,11 +219,22 @@ static unsigned int jmb38x_ms_read_reg_d
 	if (!length)
 		return off;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (host->io_pos && length) {
 		buf[off++] = host->io_word[1] & 0xff;
 		host->io_word[1] >>= 8;
 		length--;
 		host->io_pos--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return off;