diff -u -p a/uwb/lc-rc.c b/uwb/lc-rc.c
--- a/uwb/lc-rc.c
+++ b/uwb/lc-rc.c
@@ -65,11 +65,22 @@ static int uwb_rc_new_index(void)
 {
 	int index = 0;
 
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+for (;;) {
 		if (!uwb_rc_find_by_index(index))
 			return index;
 		if (++index < 0)
 			index = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/video/aty/aty128fb.c b/video/aty/aty128fb.c
--- a/video/aty/aty128fb.c
+++ b/video/aty/aty128fb.c
@@ -607,6 +607,11 @@ static void do_wait_for_fifo(u16 entries
 {
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		for (i = 0; i < 2000000; i++) {
 			par->fifo_slots = aty_ld_le32(GUI_STAT) & 0x0fff;
@@ -614,6 +619,12 @@ static void do_wait_for_fifo(u16 entries
 				return;
 		}
 		aty128_reset_engine(par);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 }
 
@@ -624,6 +635,11 @@ static void wait_for_idle(struct aty128f
 
 	do_wait_for_fifo(64, par);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		for (i = 0; i < 2000000; i++) {
 			if (!(aty_ld_le32(GUI_STAT) & (1 << 31))) {
@@ -633,6 +649,12 @@ static void wait_for_idle(struct aty128f
 			}
 		}
 		aty128_reset_engine(par);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/infiniband/hw/ipath/ipath_cq.c b/infiniband/hw/ipath/ipath_cq.c
--- a/infiniband/hw/ipath/ipath_cq.c
+++ b/infiniband/hw/ipath/ipath_cq.c
@@ -175,6 +175,11 @@ static void send_complete(unsigned long
 	 * won't call us again until we return so we check triggered to
 	 * see if we need to call the handler again.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		u8 triggered = cq->triggered;
 
@@ -182,6 +187,12 @@ static void send_complete(unsigned long
 
 		if (cq->triggered == triggered)
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/infiniband/hw/qib/qib_cq.c b/infiniband/hw/qib/qib_cq.c
--- a/infiniband/hw/qib/qib_cq.c
+++ b/infiniband/hw/qib/qib_cq.c
@@ -174,6 +174,11 @@ static void send_complete(struct work_st
 	 * won't call us again until we return so we check triggered to
 	 * see if we need to call the handler again.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		u8 triggered = cq->triggered;
 
@@ -189,6 +194,12 @@ static void send_complete(struct work_st
 
 		if (cq->triggered == triggered)
 			return;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/scsi/aha152x.c b/scsi/aha152x.c
--- a/scsi/aha152x.c
+++ b/scsi/aha152x.c
@@ -1812,6 +1812,11 @@ static void seldi_run(struct Scsi_Host *
  */
 static void msgi_run(struct Scsi_Host *shpnt)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(;;) {
 		int sstat1 = GETPORT(SSTAT1);
 
@@ -1980,6 +1985,12 @@ static void msgi_run(struct Scsi_Host *s
 		}
 
 		MSGILEN=0;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/scsi/initio.c b/scsi/initio.c
--- a/scsi/initio.c
+++ b/scsi/initio.c
@@ -1102,6 +1102,11 @@ static int tulip_main(struct initio_host
 {
 	struct scsi_ctrl_blk *scb;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		tulip_scsi(host);	/* Call tulip_scsi              */
 
@@ -1166,6 +1171,12 @@ static int tulip_main(struct initio_host
 		/* Check pending SCB            */
 		if (initio_find_first_pend_scb(host) == NULL)
 			return 1;	/* return to OS, enable interrupt */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}			/* End of for loop */
 	/* statement won't reach here */
 }
@@ -1280,7 +1291,12 @@ static int initio_next_state(struct init
 	int next;
 
 	next = host->active->next_state;
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		switch (next) {
 		case 1:
 			next = initio_state_1(host);
@@ -1310,6 +1326,12 @@ static int initio_next_state(struct init
 		}
 		if (next <= 0)
 			return next;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
@@ -1414,6 +1436,11 @@ static int initio_state_3(struct initio_
 #if DEBUG_STATE
 	printk("-s3-");
 #endif
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		switch (host->phase) {
 		case CMD_OUT:	/* Command out phase            */
@@ -1462,6 +1489,12 @@ static int initio_state_3(struct initio_
 		default:
 			return initio_bad_seq(host);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1482,6 +1515,11 @@ static int initio_state_4(struct initio_
 	if ((scb->flags & SCF_DIR) == SCF_NO_XF) {
 		return 6;	/* Go to state 6 (After data) */
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		if (scb->buflen == 0)
 			return 6;
@@ -1525,6 +1563,12 @@ static int initio_state_4(struct initio_
 		default:
 			return initio_bad_seq(host);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1632,6 +1676,11 @@ static int initio_state_6(struct initio_
 #if DEBUG_STATE
 	printk("-s6-");
 #endif
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		switch (host->phase) {
 		case STATUS_IN:	/* Status phase                 */
@@ -1661,6 +1710,12 @@ static int initio_state_6(struct initio_
 		default:
 			return initio_bad_seq(host);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1763,7 +1818,12 @@ int initio_xpad_in(struct initio_host *
 
 	if ((scb->flags & SCF_DIR) != SCF_NO_DCHK)
 		scb->hastat = HOST_DO_DU;	/* over run             */
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		if (active_tc->js_period & TSC_WIDE_SCSI)
 			outl(2, host->addr + TUL_SCnt0);
 		else
@@ -1777,6 +1837,12 @@ int initio_xpad_in(struct initio_host *
 			return 6;
 		}
 		inb(host->addr + TUL_SFifo);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1787,7 +1853,12 @@ int initio_xpad_out(struct initio_host *
 
 	if ((scb->flags & SCF_DIR) != SCF_NO_DCHK)
 		scb->hastat = HOST_DO_DU;	/* over run             */
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 		if (active_tc->js_period & TSC_WIDE_SCSI)
 			outl(2, host->addr + TUL_SCnt0);
 		else
@@ -1802,6 +1873,12 @@ int initio_xpad_out(struct initio_host *
 			outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
 			return 6;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -2080,6 +2157,11 @@ static int initio_msgin(struct initio_ho
 {
 	struct target_control *active_tc;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
 
@@ -2122,6 +2204,12 @@ static int initio_msgin(struct initio_ho
 		}
 		if (host->phase != MSG_IN)
 			return host->phase;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	/* statement won't reach here */
 }
diff -u -p a/scsi/advansys.c b/scsi/advansys.c
--- a/scsi/advansys.c
+++ b/scsi/advansys.c
@@ -8509,6 +8509,11 @@ adv_get_sglist(struct asc_board *boardp,
 	prev_sg_block = NULL;
 	reqp->sgblkp = NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		/*
 		 * Allocate a 'adv_sgblk_t' structure from the board free
@@ -8588,6 +8593,12 @@ adv_get_sglist(struct asc_board *boardp,
 		}
 		sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
 		prev_sg_block = sg_block;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/rtl8192u/ieee80211/cipher.c b/staging/rtl8192u/ieee80211/cipher.c
--- a/staging/rtl8192u/ieee80211/cipher.c
+++ b/staging/rtl8192u/ieee80211/cipher.c
@@ -67,6 +67,11 @@ static int crypt(struct crypto_tfm *tfm,
 	scatterwalk_start(&walk_in, src);
 	scatterwalk_start(&walk_out, dst);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(;;) {
 		u8 *src_p, *dst_p;
 		int in_place;
@@ -93,6 +98,12 @@ static int crypt(struct crypto_tfm *tfm,
 			return 0;
 
 		crypto_yield(tfm);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/staging/slicoss/slicoss.c b/staging/slicoss/slicoss.c
--- a/staging/slicoss/slicoss.c
+++ b/staging/slicoss/slicoss.c
@@ -3507,6 +3507,11 @@ static int slic_card_init(struct sliccar
 
 		slic_config_get(adapter, phys_configl, phys_configh);
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (;;) {
 			if (adapter->pshmem->isr) {
 				if (adapter->pshmem->isr & ISR_UPC) {
@@ -3539,6 +3544,12 @@ static int slic_card_init(struct sliccar
 					return -EINVAL;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+		}
 		}
 
 		switch (adapter->devid) {
diff -u -p a/staging/comedi/drivers/addi-data/APCI1710_Chrono.c b/staging/comedi/drivers/addi-data/APCI1710_Chrono.c
--- a/staging/comedi/drivers/addi-data/APCI1710_Chrono.c
+++ b/staging/comedi/drivers/addi-data/APCI1710_Chrono.c
@@ -1388,7 +1388,12 @@ int i_APCI1710_ReadChronoValue(struct co
 
 				if (ui_TimeOut <= 65535UL) {
 
-					for (;;) {
+					unsigned long long delta = (cpu / khz / HZ) * 2;
+					unsigned long long _start = 0;
+					unsigned long long _cur = 0;
+					unsigned long long timeout;
+						timeout = rdstcll(start) + delta;
+						for (;;) {
 			  /*******************/
 						/* Read the status */
 			  /*******************/
@@ -1506,6 +1511,12 @@ int i_APCI1710_ReadChronoValue(struct co
 							mdelay(1000);
 
 						}
+						if (_cur < timeout) {
+							rdstcll(_cur);
+						}
+						else {
+							break;
+						}
 					}	/*  for (;;) */
 
 		       /*****************************/
diff -u -p a/staging/comedi/drivers/addi-data/APCI1710_Tor.c b/staging/comedi/drivers/addi-data/APCI1710_Tor.c
--- a/staging/comedi/drivers/addi-data/APCI1710_Tor.c
+++ b/staging/comedi/drivers/addi-data/APCI1710_Tor.c
@@ -1853,7 +1853,12 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 									<=
 									65535UL))
 							{
-								for (;;) {
+								unsigned long long delta = (cpu / khz / HZ) * 2;
+								unsigned long long _start = 0;
+								unsigned long long _cur = 0;
+								unsigned long long timeout;
+								timeout = rdstcll(start) + delta;
+									for (;;) {
 			     /*******************/
 									/* Read the status */
 			     /*******************/
@@ -1973,6 +1978,12 @@ int i_APCI1710_InsnBitsGetTorCounterProg
 
 										mdelay(1000);
 									}
+									if (_cur < timeout) {
+										rdstcll(_cur);
+									}
+									else {
+										break;
+									}
 								}	/*  for (;;) */
 
 			  /*************************/
diff -u -p a/tty/hvc/hvc_vio.c b/tty/hvc/hvc_vio.c
--- a/tty/hvc/hvc_vio.c
+++ b/tty/hvc/hvc_vio.c
@@ -378,6 +378,11 @@ static int udbg_hvc_getc_poll(void)
 static int udbg_hvc_getc(void)
 {
 	int ch;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		ch = udbg_hvc_getc_poll();
 		if (ch == -1) {
@@ -388,6 +393,12 @@ static int udbg_hvc_getc(void)
 		} else {
 			return ch;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/hvc/hvsi.c b/tty/hvc/hvsi.c
--- a/tty/hvc/hvsi.c
+++ b/tty/hvc/hvsi.c
@@ -551,6 +551,11 @@ static int __init poll_for_state(struct
 {
 	unsigned long end_jiffies = jiffies + HVSI_TIMEOUT;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		hvsi_interrupt(hp->virq, (void *)hp); /* get pending data */
 
@@ -560,6 +565,12 @@ static int __init poll_for_state(struct
 		mdelay(5);
 		if (time_after(jiffies, end_jiffies))
 			return -EIO;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/tty/hvc/hvc_opal.c b/tty/hvc/hvc_opal.c
--- a/tty/hvc/hvc_opal.c
+++ b/tty/hvc/hvc_opal.c
@@ -305,6 +305,11 @@ static int udbg_opal_getc_poll(void)
 static int udbg_opal_getc(void)
 {
 	int ch;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		ch = udbg_opal_getc_poll();
 		if (ch == -1) {
@@ -315,6 +320,12 @@ static int udbg_opal_getc(void)
 		} else {
 			return ch;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/n_hdlc.c b/tty/n_hdlc.c
--- a/tty/n_hdlc.c
+++ b/tty/n_hdlc.c
@@ -257,33 +257,77 @@ static void n_hdlc_release(struct n_hdlc
 		tty->disc_data = NULL;	/* Break the tty->n_hdlc link */
 
 	/* Release transmit and receive buffers */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(;;) {
 		buf = n_hdlc_buf_get(&n_hdlc->rx_free_buf_list);
 		if (buf) {
 			kfree(buf);
 		} else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(;;) {
 		buf = n_hdlc_buf_get(&n_hdlc->tx_free_buf_list);
 		if (buf) {
 			kfree(buf);
 		} else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(;;) {
 		buf = n_hdlc_buf_get(&n_hdlc->rx_buf_list);
 		if (buf) {
 			kfree(buf);
 		} else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for(;;) {
 		buf = n_hdlc_buf_get(&n_hdlc->tx_buf_list);
 		if (buf) {
 			kfree(buf);
 		} else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	kfree(n_hdlc->tbuf);
 	kfree(n_hdlc);
diff -u -p a/tty/serial/8250_early.c b/tty/serial/8250_early.c
--- a/tty/serial/8250_early.c
+++ b/tty/serial/8250_early.c
@@ -83,11 +83,22 @@ static void __init wait_for_xmitr(struct
 {
 	unsigned int status;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		status = serial_in(port, UART_LSR);
 		if ((status & BOTH_EMPTY) == BOTH_EMPTY)
 			return;
 		cpu_relax();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/tty/serial/68328serial.c b/tty/serial/68328serial.c
--- a/tty/serial/68328serial.c
+++ b/tty/serial/68328serial.c
@@ -616,7 +616,12 @@ static void rs_flush_chars(struct tty_st
 	if (serial_paranoia_check(info, tty->name, "rs_flush_chars"))
 		return;
 #ifndef USE_INTS
-	for(;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+for(;;) {
 #endif
 
 	/* Enable transmitter */
@@ -647,6 +652,12 @@ static void rs_flush_chars(struct tty_st
 
 #ifndef USE_INTS
 	while (!(uart->utx.w & UTX_TX_AVAIL)) udelay(5);
+	if (_cur < timeout) {
+	rdstcll(_cur);
+	}
+	else {
+	break;
+	}
 	}
 #endif
 	local_irq_restore(flags);
diff -u -p a/isdn/gigaset/bas-gigaset.c b/isdn/gigaset/bas-gigaset.c
--- a/isdn/gigaset/bas-gigaset.c
+++ b/isdn/gigaset/bas-gigaset.c
@@ -1310,6 +1310,11 @@ static void read_iso_tasklet(unsigned lo
 	int totleft, numbytes, offset, frame, rc;
 
 	/* loop while more completed URBs arrive in the meantime */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		/* retrieve URB */
 		spin_lock_irqsave(&ubc->isoinlock, flags);
@@ -1430,6 +1435,12 @@ error:
 			dump_urb(DEBUG_ISO, "resubmit isoc read", urb);
 			error_hangup(bcs);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/isdn/hisax/enternow_pci.c b/isdn/hisax/enternow_pci.c
--- a/isdn/hisax/enternow_pci.c
+++ b/isdn/hisax/enternow_pci.c
@@ -404,6 +404,11 @@ setup_enternow_pci(struct IsdnCard *card
 		return(0);
 	test_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for ( ;; )
 	{
 		if ((dev_netjet = hisax_find_pci_device(PCI_VENDOR_ID_TIGERJET,
@@ -418,7 +423,13 @@ setup_enternow_pci(struct IsdnCard *card
 
 		en_cs_init(card, cs);
 		break;
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+        }
 
         return en_cs_init_rest(card, cs);
 }
diff -u -p a/block/swim3.c b/block/swim3.c
--- a/block/swim3.c
+++ b/block/swim3.c
@@ -501,7 +501,12 @@ static inline void setup_transfer(struct
 
 static void act(struct floppy_state *fs)
 {
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (;;) {
 		swim3_dbg("  act loop, state=%d, req_cyl=%d, cur_cyl=%d\n",
 			  fs->state, fs->req_cyl, fs->cur_cyl);
 
@@ -565,6 +570,12 @@ static void act(struct floppy_state *fs)
 			swim3_err("Unknown state %d\n", fs->state);
 			return;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/block/pktcdvd.c b/block/pktcdvd.c
--- a/block/pktcdvd.c
+++ b/block/pktcdvd.c
@@ -1454,6 +1454,11 @@ static void pkt_run_state_machine(struct
 
 	VPRINTK("run_state_machine: pkt %d\n", pkt->id);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		switch (pkt->state) {
 		case PACKET_WAITING_STATE:
@@ -1505,6 +1510,12 @@ static void pkt_run_state_machine(struct
 			BUG();
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/gpu/drm/nouveau/nv50_display.c b/gpu/drm/nouveau/nv50_display.c
--- a/gpu/drm/nouveau/nv50_display.c
+++ b/gpu/drm/nouveau/nv50_display.c
@@ -884,6 +884,11 @@ nv50_display_bh(unsigned long data)
 {
 	struct drm_device *dev = (struct drm_device *)data;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		uint32_t intr0 = nv_rd32(dev, NV50_PDISPLAY_INTR_0);
 		uint32_t intr1 = nv_rd32(dev, NV50_PDISPLAY_INTR_1);
@@ -900,6 +905,12 @@ nv50_display_bh(unsigned long data)
 			nv50_display_unk40_handler(dev);
 		else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	nv_wr32(dev, NV03_PMC_INTR_EN_0, 1);
diff -u -p a/usb/serial/ftdi_sio.c b/usb/serial/ftdi_sio.c
--- a/usb/serial/ftdi_sio.c
+++ b/usb/serial/ftdi_sio.c
@@ -2526,6 +2526,11 @@ static int ftdi_ioctl(struct tty_struct
 	 */
 	case TIOCMIWAIT:
 		cprev = priv->icount;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (;;) {
 			interruptible_sleep_on(&port->delta_msr_wait);
 			/* see if a signal did it */
@@ -2543,6 +2548,12 @@ static int ftdi_ioctl(struct tty_struct
 				return 0;
 			}
 			cprev = cnow;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	case TIOCSERGETLSR:
 		return get_lsr_info(port, (struct serial_struct __user *)arg);
diff -u -p a/usb/serial/mct_u232.c b/usb/serial/mct_u232.c
--- a/usb/serial/mct_u232.c
+++ b/usb/serial/mct_u232.c
@@ -892,7 +892,12 @@ static int  mct_u232_ioctl(struct tty_st
 		spin_lock_irqsave(&mct_u232_port->lock, flags);
 		cprev = mct_u232_port->icount;
 		spin_unlock_irqrestore(&mct_u232_port->lock, flags);
-		for ( ; ; ) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			for ( ; ; ) {
 			prepare_to_wait(&port->delta_msr_wait,
 					&wait, TASK_INTERRUPTIBLE);
 			schedule();
@@ -917,6 +922,12 @@ static int  mct_u232_ioctl(struct tty_st
 				return 0;
 			}
 			cprev = cnow;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 	}
diff -u -p a/usb/serial/ark3116.c b/usb/serial/ark3116.c
--- a/usb/serial/ark3116.c
+++ b/usb/serial/ark3116.c
@@ -456,6 +456,11 @@ static int ark3116_ioctl(struct tty_stru
 			return -EFAULT;
 		return 0;
 	case TIOCMIWAIT:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (;;) {
 			struct async_icount prev = priv->icount;
 			interruptible_sleep_on(&port->delta_msr_wait);
@@ -480,6 +485,12 @@ static int ark3116_ioctl(struct tty_stru
 			    (arg & TIOCM_CTS &&
 			     (prev.cts != priv->icount.cts)))
 				return 0;
+				if (_cur < timeout) {
+			rdstcll(_cur);
+				}
+				else {
+			break;
+				}
 		}
 		break;
 	}
diff -u -p a/usb/serial/cypress_m8.c b/usb/serial/cypress_m8.c
--- a/usb/serial/cypress_m8.c
+++ b/usb/serial/cypress_m8.c
@@ -942,6 +942,11 @@ static int cypress_ioctl(struct tty_stru
 	switch (cmd) {
 	/* This code comes from drivers/char/serial.c and ftdi_sio.c */
 	case TIOCMIWAIT:
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		for (;;) {
 			interruptible_sleep_on(&port->delta_msr_wait);
 			/* see if a signal did it */
@@ -971,6 +976,12 @@ static int cypress_ioctl(struct tty_stru
 				 * more events.
 				 */
 			}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		return 0;
 	default:
diff -u -p a/usb/class/cdc-acm.c b/usb/class/cdc-acm.c
--- a/usb/class/cdc-acm.c
+++ b/usb/class/cdc-acm.c
@@ -104,6 +104,11 @@ static int acm_wb_alloc(struct acm *acm)
 
 	wbn = 0;
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		wb = &acm->wb[wbn];
 		if (!wb->use) {
@@ -113,6 +118,12 @@ static int acm_wb_alloc(struct acm *acm)
 		wbn = (wbn + 1) % ACM_NW;
 		if (++i >= ACM_NW)
 			return -1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 
diff -u -p a/usb/gadget/f_fs.c b/usb/gadget/f_fs.c
--- a/usb/gadget/f_fs.c
+++ b/usb/gadget/f_fs.c
@@ -1699,6 +1699,11 @@ static int __must_check ffs_do_descs(uns
 
 	ENTER();
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		int ret;
 
@@ -1725,6 +1730,12 @@ static int __must_check ffs_do_descs(uns
 		len -= ret;
 		data += ret;
 		++num;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/char/hpet.c b/char/hpet.c
--- a/char/hpet.c
+++ b/char/hpet.c
@@ -316,6 +316,11 @@ hpet_read(struct file *file, char __user
 
 	add_wait_queue(&devp->hd_waitqueue, &wait);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for ( ; ; ) {
 		set_current_state(TASK_INTERRUPTIBLE);
 
@@ -334,6 +339,12 @@ hpet_read(struct file *file, char __user
 			goto out;
 		}
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	retval = put_user(data, (unsigned long __user *)buf);
diff -u -p a/char/tile-srom.c b/char/tile-srom.c
--- a/char/tile-srom.c
+++ b/char/tile-srom.c
@@ -88,7 +88,12 @@ static ssize_t _srom_read(int hv_devhdl,
 			  loff_t off, size_t count)
 {
 	int retval, retries = SROM_MAX_WAIT_TRY_TIMES;
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (;;) {
 		retval = hv_dev_pread(hv_devhdl, 0, (HV_VirtAddr)buf,
 				      count, off);
 		if (retval >= 0)
@@ -101,6 +106,12 @@ static ssize_t _srom_read(int hv_devhdl,
 		}
 		pr_err("_srom_read: error %d\n", retval);
 		return -EIO;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -108,7 +119,12 @@ static ssize_t _srom_write(int hv_devhdl
 			   loff_t off, size_t count)
 {
 	int retval, retries = SROM_MAX_WAIT_TRY_TIMES;
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		for (;;) {
 		retval = hv_dev_pwrite(hv_devhdl, 0, (HV_VirtAddr)buf,
 				       count, off);
 		if (retval >= 0)
@@ -121,6 +137,12 @@ static ssize_t _srom_write(int hv_devhdl
 		}
 		pr_err("_srom_write: error %d\n", retval);
 		return -EIO;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/char/ipmi/ipmi_si_intf.c b/char/ipmi/ipmi_si_intf.c
--- a/char/ipmi/ipmi_si_intf.c
+++ b/char/ipmi/ipmi_si_intf.c
@@ -2674,6 +2674,11 @@ static int wait_for_msg_done(struct smi_
 	enum si_sm_result     smi_result;
 
 	smi_result = smi_info->handlers->event(smi_info->si_sm, 0);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	for (;;) {
 		if (smi_result == SI_SM_CALL_WITH_DELAY ||
 		    smi_result == SI_SM_CALL_WITH_TICK_DELAY) {
@@ -2685,6 +2690,12 @@ static int wait_for_msg_done(struct smi_
 				smi_info->si_sm, 0);
 		} else
 			break;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 	if (smi_result == SI_SM_HOSED)
 		/*
diff -u -p a/net/caif/caif_spi_slave.c b/net/caif/caif_spi_slave.c
--- a/net/caif/caif_spi_slave.c
+++ b/net/caif/caif_spi_slave.c
@@ -71,7 +71,12 @@ void cfspi_xfer(struct work_struct *work
 	/* Initialize state. */
 	cfspi->cmd = SPI_CMD_EOT;
 
-	for (;;) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		for (;;) {
 
 		cfspi_dbg_state(cfspi, CFSPI_STATE_WAITING);
 
@@ -243,6 +248,12 @@ void cfspi_xfer(struct work_struct *work
 			clear_bit(SPI_XFER, &cfspi->state);
 
 		spin_unlock_irqrestore(&cfspi->lock, flags);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
