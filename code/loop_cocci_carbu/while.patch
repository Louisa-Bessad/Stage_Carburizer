diff -u -p a/oprofile/buffer_sync.c b/oprofile/buffer_sync.c
--- a/oprofile/buffer_sync.c
+++ b/oprofile/buffer_sync.c
@@ -586,11 +586,22 @@ void oprofile_put_buff(unsigned long *bu
 	i = start;
 
 	mutex_lock(&buffer_mutex);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i != stop) {
 		add_event_entry(buf[i++]);
 
 		if (i >= max)
 			i = 0;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	mutex_unlock(&buffer_mutex);
diff -u -p a/virtio/virtio_ring.c b/virtio/virtio_ring.c
--- a/virtio/virtio_ring.c
+++ b/virtio/virtio_ring.c
@@ -285,9 +285,20 @@ static void detach_buf(struct vring_virt
 	if (vq->vring.desc[i].flags & VRING_DESC_F_INDIRECT)
 		kfree(phys_to_virt(vq->vring.desc[i].addr));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (vq->vring.desc[i].flags & VRING_DESC_F_NEXT) {
 		i = vq->vring.desc[i].next;
 		vq->num_free++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	vq->vring.desc[i].next = vq->free_head;
diff -u -p a/virtio/virtio_balloon.c b/virtio/virtio_balloon.c
--- a/virtio/virtio_balloon.c
+++ b/virtio/virtio_balloon.c
@@ -255,7 +255,12 @@ static int balloon(void *_vballoon)
 	struct virtio_balloon *vb = _vballoon;
 
 	set_freezable();
-	while (!kthread_should_stop()) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!kthread_should_stop()) {
 		s64 diff;
 
 		try_to_freeze();
@@ -277,6 +282,12 @@ static int balloon(void *_vballoon)
 		 * and always have work to do.  Be nice if preempt disabled.
 		 */
 		cond_resched();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/base/devtmpfs.c b/base/devtmpfs.c
--- a/base/devtmpfs.c
+++ b/base/devtmpfs.c
@@ -399,24 +399,57 @@ static int devtmpfsd(void *p)
 	sys_chdir("/.."); /* will traverse into overmounted root */
 	sys_chroot(".");
 	complete(&setup_done);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		spin_lock(&req_lock);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (requests) {
 			struct req *req = requests;
 			requests = NULL;
 			spin_unlock(&req_lock);
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (req) {
 				struct req *next = req->next;
 				req->err = handle(req->name, req->mode, req->dev);
 				complete(&req->done);
 				req = next;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			spin_lock(&req_lock);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock(&req_lock);
 		schedule();
 		__set_current_state(TASK_RUNNING);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 out:
diff -u -p a/base/devres.c b/base/devres.c
--- a/base/devres.c
+++ b/base/devres.c
@@ -337,6 +337,11 @@ static int remove_nodes(struct device *d
 	 * devres_group colors.
 	 */
 	cur = first;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cur != end) {
 		struct devres_node *node;
 		struct devres_group *grp;
@@ -356,6 +361,12 @@ static int remove_nodes(struct device *d
 			list_move_tail(&node->entry, todo);
 			cnt++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (!nr_groups)
@@ -368,6 +379,11 @@ static int remove_nodes(struct device *d
 	 * opening marker is enough for an open group.
 	 */
 	cur = first;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cur != end) {
 		struct devres_node *node;
 		struct devres_group *grp;
@@ -390,6 +406,12 @@ static int remove_nodes(struct device *d
 			list_move_tail(&grp->node[0].entry, todo);
 			list_del_init(&grp->node[1].entry);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return cnt;
diff -u -p a/base/isa.c b/base/isa.c
--- a/base/isa.c
+++ b/base/isa.c
@@ -102,10 +102,21 @@ void isa_unregister_driver(struct isa_dr
 {
 	struct device *dev = isa_driver->devices;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (dev) {
 		struct device *tmp = to_isa_dev(dev)->next;
 		device_unregister(dev);
 		dev = tmp;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	driver_unregister(&isa_driver->driver);
 }
diff -u -p a/base/class.c b/base/class.c
--- a/base/class.c
+++ b/base/class.c
@@ -330,6 +330,11 @@ struct device *class_dev_iter_next(struc
 	struct klist_node *knode;
 	struct device *dev;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (1) {
 		knode = klist_next(&iter->ki);
 		if (!knode)
@@ -337,6 +342,12 @@ struct device *class_dev_iter_next(struc
 		dev = container_of(knode, struct device, knode_class);
 		if (!iter->type || iter->type == dev->type)
 			return dev;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 EXPORT_SYMBOL_GPL(class_dev_iter_next);
diff -u -p a/base/platform.c b/base/platform.c
--- a/base/platform.c
+++ b/base/platform.c
@@ -309,12 +309,23 @@ int platform_device_add(struct platform_
 		return ret;
 
  failed:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (--i >= 0) {
 		struct resource *r = &pdev->resource[i];
 		unsigned long type = resource_type(r);
 
 		if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
 			release_resource(r);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return ret;
@@ -634,12 +645,23 @@ static const struct platform_device_id *
 			const struct platform_device_id *id,
 			struct platform_device *pdev)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (id->name[0]) {
 		if (strcmp(pdev->name, id->name) == 0) {
 			pdev->id_entry = id;
 			return id;
 		}
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/base/firmware_class.c b/base/firmware_class.c
--- a/base/firmware_class.c
+++ b/base/firmware_class.c
@@ -304,6 +304,11 @@ static ssize_t firmware_data_read(struct
 
 	ret_count = count;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		void *page_data;
 		int page_nr = offset >> PAGE_SHIFT;
@@ -318,6 +323,12 @@ static ssize_t firmware_data_read(struct
 		buffer += page_cnt;
 		offset += page_cnt;
 		count -= page_cnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 out:
 	mutex_unlock(&fw_lock);
@@ -349,7 +360,12 @@ static int fw_realloc_buffer(struct firm
 		fw_priv->page_array_size = new_array_size;
 	}
 
-	while (fw_priv->nr_pages < pages_needed) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (fw_priv->nr_pages < pages_needed) {
 		fw_priv->pages[fw_priv->nr_pages] =
 			alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
 
@@ -358,6 +374,12 @@ static int fw_realloc_buffer(struct firm
 			return -ENOMEM;
 		}
 		fw_priv->nr_pages++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -398,6 +420,11 @@ static ssize_t firmware_data_write(struc
 
 	retval = count;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		void *page_data;
 		int page_nr = offset >> PAGE_SHIFT;
@@ -412,6 +439,12 @@ static ssize_t firmware_data_write(struc
 		buffer += page_cnt;
 		offset += page_cnt;
 		count -= page_cnt;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	fw->size = max_t(size_t, offset, fw->size);
diff -u -p a/base/regmap/regcache-rbtree.c b/base/regmap/regcache-rbtree.c
--- a/base/regmap/regcache-rbtree.c
+++ b/base/regmap/regcache-rbtree.c
@@ -72,6 +72,11 @@ static struct regcache_rbtree_node *regc
 	}
 
 	node = rbtree_ctx->root.rb_node;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (node) {
 		rbnode = container_of(node, struct regcache_rbtree_node, node);
 		regcache_rbtree_get_base_top_reg(rbnode, &base_reg, &top_reg);
@@ -83,6 +88,12 @@ static struct regcache_rbtree_node *regc
 		} else if (reg < base_reg) {
 			node = node->rb_left;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return NULL;
@@ -98,7 +109,12 @@ static int regcache_rbtree_insert(struct
 
 	parent = NULL;
 	new = &root->rb_node;
-	while (*new) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (*new) {
 		rbnode_tmp = container_of(*new, struct regcache_rbtree_node,
 					  node);
 		/* base and top registers of the current rbnode */
@@ -115,6 +131,12 @@ static int regcache_rbtree_insert(struct
 			new = &((*new)->rb_right);
 		else if (base_reg < base_reg_tmp)
 			new = &((*new)->rb_left);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 	}
 
 	/* insert the node into the rbtree */
@@ -166,12 +188,23 @@ static int regcache_rbtree_exit(struct r
 
 	/* free up the rbtree */
 	next = rb_first(&rbtree_ctx->root);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (next) {
 		rbtree_node = rb_entry(next, struct regcache_rbtree_node, node);
 		next = rb_next(&rbtree_node->node);
 		rb_erase(&rbtree_node->node, &rbtree_ctx->root);
 		kfree(rbtree_node->block);
 		kfree(rbtree_node);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* release the resources */
diff -u -p a/base/power/wakeup.c b/base/power/wakeup.c
--- a/base/power/wakeup.c
+++ b/base/power/wakeup.c
@@ -82,12 +82,23 @@ void wakeup_source_destroy(struct wakeup
 		return;
 
 	spin_lock_irq(&ws->lock);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ws->active) {
 		spin_unlock_irq(&ws->lock);
 
 		schedule_timeout_interruptible(msecs_to_jiffies(TIMEOUT));
 
 		spin_lock_irq(&ws->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irq(&ws->lock);
 
diff -u -p a/base/power/trace.c b/base/power/trace.c
--- a/base/power/trace.c
+++ b/base/power/trace.c
@@ -133,8 +133,19 @@ static unsigned int read_magic_time(void
 static unsigned int hash_string(unsigned int seed, const char *data, unsigned int mod)
 {
 	unsigned char c;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((c = *data++) != 0) {
 		seed = (seed << 16) + (seed << 6) - seed + c;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return seed % mod;
 }
@@ -193,6 +204,11 @@ static int show_dev_hash(unsigned int va
 
 	device_pm_lock();
 	entry = dpm_list.prev;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (entry != &dpm_list) {
 		struct device * dev = to_device(entry);
 		unsigned int hash = hash_string(DEVSEED, dev_name(dev), DEVHASH);
@@ -201,6 +217,12 @@ static int show_dev_hash(unsigned int va
 			match++;
 		}
 		entry = entry->prev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	device_pm_unlock();
 	return match;
@@ -220,7 +242,12 @@ int show_trace_dev_match(char *buf, size
 	 */
 	device_pm_lock();
 	entry = dpm_list.prev;
-	while (size && entry != &dpm_list) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (size && entry != &dpm_list) {
 		struct device *dev = to_device(entry);
 		unsigned int hash = hash_string(DEVSEED, dev_name(dev),
 						DEVHASH);
@@ -234,6 +261,12 @@ int show_trace_dev_match(char *buf, size
 			size -= len;
 		}
 		entry = entry->prev;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	device_pm_unlock();
 	return ret;
diff -u -p a/base/power/main.c b/base/power/main.c
--- a/base/power/main.c
+++ b/base/power/main.c
@@ -460,6 +460,11 @@ void dpm_resume_noirq(pm_message_t state
 	ktime_t starttime = ktime_get();
 
 	mutex_lock(&dpm_list_mtx);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&dpm_noirq_list)) {
 		struct device *dev = to_device(dpm_noirq_list.next);
 		int error;
@@ -478,6 +483,12 @@ void dpm_resume_noirq(pm_message_t state
 
 		mutex_lock(&dpm_list_mtx);
 		put_device(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&dpm_list_mtx);
 	dpm_show_time(starttime, state, "early");
@@ -626,6 +637,11 @@ void dpm_resume(pm_message_t state)
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&dpm_suspended_list)) {
 		dev = to_device(dpm_suspended_list.next);
 		get_device(dev);
@@ -647,6 +663,12 @@ void dpm_resume(pm_message_t state)
 		if (!list_empty(&dev->power.entry))
 			list_move_tail(&dev->power.entry, &dpm_prepared_list);
 		put_device(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	mutex_unlock(&dpm_list_mtx);
 	async_synchronize_full();
@@ -698,6 +720,11 @@ void dpm_complete(pm_message_t state)
 
 	INIT_LIST_HEAD(&list);
 	mutex_lock(&dpm_list_mtx);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&dpm_prepared_list)) {
 		struct device *dev = to_device(dpm_prepared_list.prev);
 
@@ -710,6 +737,12 @@ void dpm_complete(pm_message_t state)
 
 		mutex_lock(&dpm_list_mtx);
 		put_device(dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	list_splice(&list, &dpm_list);
 	mutex_unlock(&dpm_list_mtx);
diff -u -p a/base/core.c b/base/core.c
--- a/base/core.c
+++ b/base/core.c
@@ -1733,7 +1733,12 @@ void device_shutdown(void)
 	 * Beware that device unplug events may also start pulling
 	 * devices offline, even as the system is shutting down.
 	 */
-	while (!list_empty(&devices_kset->list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&devices_kset->list)) {
 		dev = list_entry(devices_kset->list.prev, struct device,
 				kobj.entry);
 		get_device(dev);
@@ -1758,6 +1763,12 @@ void device_shutdown(void)
 		put_device(dev);
 
 		spin_lock(&devices_kset->list_lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock(&devices_kset->list_lock);
 	async_synchronize_full();
diff -u -p a/misc/arm-charlcd.c b/misc/arm-charlcd.c
--- a/misc/arm-charlcd.c
+++ b/misc/arm-charlcd.c
@@ -122,10 +122,21 @@ static u8 charlcd_4bit_read_char(struct
 	else {
 		i = 0;
 		val = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(val & CHAR_RAW_VALID) && i < 10) {
 			udelay(100);
 			val = readl(lcd->virtbase + CHAR_RAW);
 			i++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		writel(CHAR_RAW_CLEAR, lcd->virtbase + CHAR_RAW);
@@ -141,10 +152,21 @@ static u8 charlcd_4bit_read_char(struct
 	 */
 	i = 0;
 	val = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!(val & CHAR_RAW_VALID) && i < 10) {
 		udelay(100);
 		val = readl(lcd->virtbase + CHAR_RAW);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	writel(CHAR_RAW_CLEAR, lcd->virtbase + CHAR_RAW);
 	msleep(1);
diff -u -p a/misc/sgi-gru/grufault.c b/misc/sgi-gru/grufault.c
--- a/misc/sgi-gru/grufault.c
+++ b/misc/sgi-gru/grufault.c
@@ -337,7 +337,12 @@ static void gru_preload_tlb(struct gru_s
 	vaddr &= PAGE_MASK;
 	vaddr = min(vaddr, fault_vaddr + tlb_preload_count * PAGE_SIZE);
 
-	while (vaddr > fault_vaddr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+			while (vaddr > fault_vaddr) {
 		ret = gru_vtop(gts, vaddr, write, atomic, &gpa, &pageshift);
 		if (ret || tfh_write_only(tfh, gpa, GAA_RAM, vaddr, asid, write,
 					  GRU_PAGESIZE(pageshift)))
@@ -348,6 +353,12 @@ static void gru_preload_tlb(struct gru_s
 			vaddr, asid, write, pageshift, gpa);
 		vaddr -= PAGE_SIZE;
 		STAT(tlb_preload_page);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -627,7 +638,12 @@ static int gru_user_dropin(struct gru_th
 	int ret;
 
 	gts->ustats.upm_tlbmiss++;
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (1) {
 		wait_event(gms->ms_wait_queue,
 			   atomic_read(&gms->ms_range_active) == 0);
 		prefetchw(tfh);	/* Helps on hdw, required for emulator */
@@ -635,6 +651,12 @@ static int gru_user_dropin(struct gru_th
 		if (ret <= 0)
 			return ret;
 		STAT(call_os_wait_queue);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/misc/sgi-gru/grukservices.c b/misc/sgi-gru/grukservices.c
--- a/misc/sgi-gru/grukservices.c
+++ b/misc/sgi-gru/grukservices.c
@@ -173,9 +173,20 @@ static void gru_load_kernel_context(stru
 		kgts->ts_dsr_au_count = GRU_DS_BYTES_TO_AU(
 			GRU_NUM_KERNEL_DSR_BYTES * ncpus +
 				bs->bs_async_dsr_bytes);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!gru_assign_gru_context(kgts)) {
 			msleep(1);
 			gru_steal_context(kgts);
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
 		}
 		gru_load_context(kgts);
 		gru = bs->bs_kgts->ts_gru;
@@ -450,9 +461,20 @@ char *gru_get_cb_exception_detail_str(in
 
 static int gru_wait_idle_or_exception(struct gru_control_block_status *gen)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (gen->istatus >= CBS_ACTIVE) {
 		cpu_relax();
 		barrier();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return gen->istatus;
 }
@@ -874,10 +896,21 @@ void *gru_get_next_message(struct gru_me
 	int present = mhdr->present;
 
 	/* skip NOOP messages */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (present == MQS_NOOP) {
 		gru_free_message(mqd, mhdr);
 		mhdr = mq->next;
 		present = mhdr->present;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Wait for both halves of 2 line messages */
diff -u -p a/misc/sgi-gru/grumain.c b/misc/sgi-gru/grumain.c
--- a/misc/sgi-gru/grumain.c
+++ b/misc/sgi-gru/grumain.c
@@ -170,6 +170,11 @@ static unsigned long reserve_resources(u
 	unsigned long bits = 0;
 	int i;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (n--) {
 		i = find_first_bit(p, mmax);
 		if (i == mmax)
@@ -178,6 +183,12 @@ static unsigned long reserve_resources(u
 		__set_bit(i, &bits);
 		if (idx)
 			*idx++ = i;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return bits;
 }
@@ -461,9 +472,20 @@ static void gru_free_gru_context(struct
  */
 static void prefetch_data(void *p, int num, int stride)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num-- > 0) {
 		prefetchw(p);
 		p += stride;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/misc/ti-st/st_kim.c b/misc/ti-st/st_kim.c
--- a/misc/ti-st/st_kim.c
+++ b/misc/ti-st/st_kim.c
@@ -134,6 +134,11 @@ void kim_int_recv(struct kim_data_s *kim
 		return;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		if (kim_gdata->rx_count) {
 			len = min_t(unsigned int, kim_gdata->rx_count, count);
@@ -190,6 +195,12 @@ void kim_int_recv(struct kim_data_s *kim
 		kim_gdata->rx_skb->cb[0] = 4;
 		kim_gdata->rx_skb->cb[1] = 0;
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return;
 }
@@ -294,7 +305,12 @@ static long download_firmware(struct kim
 	ptr += sizeof(struct bts_header);
 	len -= sizeof(struct bts_header);
 
-	while (len > 0 && ptr) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (len > 0 && ptr) {
 		pr_debug(" action size %d, type %d ",
 			   ((struct bts_action *)ptr)->size,
 			   ((struct bts_action *)ptr)->type);
@@ -392,6 +408,12 @@ static long download_firmware(struct kim
 		ptr =
 		    ptr + sizeof(struct bts_action) +
 		    ((struct bts_action *)ptr)->size;
+		    if (_cur < timeout) {
+		    rdstcll(_cur);
+		    }
+		    else {
+		    break;
+		    }
 	}
 	/* fw download complete */
 	release_firmware(kim_gdata->fw_entry);
diff -u -p a/misc/ti-st/st_core.c b/misc/ti-st/st_core.c
--- a/misc/ti-st/st_core.c
+++ b/misc/ti-st/st_core.c
@@ -254,6 +254,11 @@ void st_int_recv(void *disc_data,
 
 	spin_lock_irqsave(&st_gdata->lock, flags);
 	/* Decode received bytes here */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count) {
 		if (st_gdata->rx_count) {
 			len = min_t(unsigned int, st_gdata->rx_count, count);
@@ -359,6 +364,12 @@ void st_int_recv(void *disc_data,
 		};
 		ptr++;
 		count--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 done:
 	spin_unlock_irqrestore(&st_gdata->lock, flags);
diff -u -p a/misc/enclosure.c b/misc/enclosure.c
--- a/misc/enclosure.c
+++ b/misc/enclosure.c
@@ -65,6 +65,11 @@ struct enclosure_device *enclosure_find(
 		struct device *parent = edev->edev.parent;
 		/* parent might not be immediate, so iterate up to
 		 * the root of the tree if necessary */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (parent) {
 			if (parent == dev) {
 				get_device(&edev->edev);
@@ -72,6 +77,12 @@ struct enclosure_device *enclosure_find(
 				return edev;
 			}
 			parent = parent->parent;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	mutex_unlock(&container_list_lock);
diff -u -p a/misc/carma/carma-fpga-program.c b/misc/carma/carma-fpga-program.c
--- a/misc/carma/carma-fpga-program.c
+++ b/misc/carma/carma-fpga-program.c
@@ -299,11 +299,22 @@ static int fpga_enable_power_supplies(st
 	}
 
 	iowrite8(PWR_CONTROL_ENABLE, priv->regs + CTL_PWR_CONTROL);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (time_before(jiffies, start + HZ)) {
 		if (fpga_power_good(priv))
 			return 0;
 
 		usleep_range(5000, 10000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return fpga_power_good(priv) ? 0 : -ETIMEDOUT;
@@ -357,6 +368,11 @@ static int fpga_program_block(struct fpg
 	/* enforce correct data length for the FIFO */
 	BUG_ON(count % 4 != 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count > 0) {
 
 		/* Get the size of the block to write (maximum is FIFO_SIZE) */
@@ -372,6 +388,11 @@ static int fpga_program_block(struct fpg
 		data += len / 4;
 
 		/* Wait for the fifo to empty */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (true) {
 
 			if (fpga_fifo_empty(priv->regs)) {
@@ -392,6 +413,18 @@ static int fpga_program_block(struct fpg
 			}
 
 			usleep_range(5000, 10000);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 
diff -u -p a/misc/carma/carma-fpga.c b/misc/carma/carma-fpga.c
--- a/misc/carma/carma-fpga.c
+++ b/misc/carma/carma-fpga.c
@@ -1093,6 +1093,11 @@ static ssize_t data_read(struct file *fi
 	spin_lock_irq(&priv->lock);
 
 	/* Block until there is at least one buffer on the used list */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (list_empty(used)) {
 		spin_unlock_irq(&priv->lock);
 
@@ -1104,6 +1109,12 @@ static ssize_t data_read(struct file *fi
 			return ret;
 
 		spin_lock_irq(&priv->lock);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Grab the first buffer off of the used list */
diff -u -p a/misc/tifm_core.c b/misc/tifm_core.c
--- a/misc/tifm_core.c
+++ b/misc/tifm_core.c
@@ -50,10 +50,21 @@ static int tifm_bus_match(struct device
 	struct tifm_device_id *ids = fm_drv->id_table;
 
 	if (ids) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (ids->type) {
 			if (tifm_dev_match(sock, ids))
 				return 1;
 			++ids;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 0;
diff -u -p a/misc/spear13xx_pcie_gadget.c b/misc/spear13xx_pcie_gadget.c
--- a/misc/spear13xx_pcie_gadget.c
+++ b/misc/spear13xx_pcie_gadget.c
@@ -269,9 +269,20 @@ static ssize_t pcie_gadget_store_int_typ
 	else if (sysfs_streq(buf, "MSI")) {
 		vector = config->requested_msi;
 		vec = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (vector > 1) {
 			vector /= 2;
 			vec++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		spear_dbi_write_reg(config, PCI_INTERRUPT_LINE, 1, 0);
 		cap = pci_find_own_capability(config, PCI_CAP_ID_MSI);
@@ -455,12 +466,23 @@ static ssize_t pcie_gadget_store_bar0_si
 	else {
 		pos = 0;
 		pos1 = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (pos < 21) {
 			pos = find_next_bit((ulong *)&size, 21, pos);
 			if (pos != 21)
 				pos1 = pos + 1;
 			pos++;
 			no_of_bit++;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (no_of_bit == 2)
 			pos1--;
diff -u -p a/misc/sgi-xp/xpc_uv.c b/misc/sgi-xp/xpc_uv.c
--- a/misc/sgi-xp/xpc_uv.c
+++ b/misc/sgi-xp/xpc_uv.c
@@ -1047,7 +1047,12 @@ xpc_make_first_contact_uv(struct xpc_par
 	xpc_send_activate_IRQ_part_uv(part, &msg, sizeof(msg),
 				      XPC_ACTIVATE_MQ_MSG_SYNC_ACT_STATE_UV);
 
-	while (!((part->sn.uv.remote_act_state == XPC_P_AS_ACTIVATING) ||
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!((part->sn.uv.remote_act_state == XPC_P_AS_ACTIVATING) ||
 		 (part->sn.uv.remote_act_state == XPC_P_AS_ACTIVE))) {
 
 		dev_dbg(xpc_part, "waiting to make first contact with "
@@ -1058,6 +1063,12 @@ xpc_make_first_contact_uv(struct xpc_par
 
 		if (part->act_state == XPC_P_AS_DEACTIVATING)
 			return part->reason;
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 	}
 
 	return xpSuccess;
@@ -1478,6 +1489,11 @@ xpc_handle_notify_IRQ_uv(int irq, void *
 	short partid;
 	struct xpc_partition *part;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((msg = gru_get_next_message(xpc_notify_mq_uv->gru_mq_desc)) !=
 	       NULL) {
 
@@ -1495,6 +1511,12 @@ xpc_handle_notify_IRQ_uv(int irq, void *
 		}
 
 		gru_free_message(xpc_notify_mq_uv->gru_mq_desc, msg);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return IRQ_HANDLED;
diff -u -p a/misc/sgi-xp/xpc_main.c b/misc/sgi-xp/xpc_main.c
--- a/misc/sgi-xp/xpc_main.c
+++ b/misc/sgi-xp/xpc_main.c
@@ -266,7 +266,12 @@ xpc_hb_checker(void *ignore)
 	xpc_hb_check_timeout = jiffies + (xpc_hb_check_interval * HZ);
 	xpc_start_hb_beater();
 
-	while (!xpc_exiting) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!xpc_exiting) {
 
 		dev_dbg(xpc_part, "woke up with %d ticks rem; %d IRQs have "
 			"been received\n",
@@ -303,6 +308,12 @@ xpc_hb_checker(void *ignore)
 						xpc_hb_check_timeout) ||
 						xpc_activate_IRQ_rcvd > 0 ||
 						xpc_exiting));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	xpc_stop_hb_beater();
@@ -346,6 +357,11 @@ xpc_initiate_discovery(void *ignore)
 static void
 xpc_channel_mgr(struct xpc_partition *part)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (part->act_state != XPC_P_AS_DEACTIVATING ||
 	       atomic_read(&part->nchannels_active) > 0 ||
 	       !xpc_partition_disengaged(part)) {
@@ -373,6 +389,12 @@ xpc_channel_mgr(struct xpc_partition *pa
 				 atomic_read(&part->nchannels_active) == 0 &&
 				 xpc_partition_disengaged(part))));
 		atomic_set(&part->channel_mgr_requests, 1);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 }
 
@@ -660,9 +682,20 @@ xpc_kthread_waitmsgs(struct xpc_partitio
 	do {
 		/* deliver messages to their intended recipients */
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (n_of_deliverable_payloads(ch) > 0 &&
 		       !(ch->flags & XPC_C_DISCONNECTING)) {
 			xpc_deliver_payload(ch);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (atomic_inc_return(&ch->kthreads_idle) >
diff -u -p a/misc/sgi-xp/xpc_sn2.c b/misc/sgi-xp/xpc_sn2.c
--- a/misc/sgi-xp/xpc_sn2.c
+++ b/misc/sgi-xp/xpc_sn2.c
@@ -1477,7 +1477,12 @@ xpc_make_first_contact_sn2(struct xpc_pa
 				  part_sn2->activate_IRQ_nasid,
 				  part_sn2->activate_IRQ_phys_cpuid);
 
-	while ((ret = xpc_pull_remote_vars_part_sn2(part)) != xpSuccess) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((ret = xpc_pull_remote_vars_part_sn2(part)) != xpSuccess) {
 		if (ret != xpRetry) {
 			XPC_DEACTIVATE_PARTITION(part, ret);
 			return ret;
@@ -1491,6 +1496,12 @@ xpc_make_first_contact_sn2(struct xpc_pa
 
 		if (part->act_state == XPC_P_AS_DEACTIVATING)
 			return part->reason;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return xpSuccess;
@@ -1711,6 +1722,11 @@ xpc_notify_senders_sn2(struct xpc_channe
 	u8 notify_type;
 	s64 get = ch->sn.sn2.w_remote_GP.get - 1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (++get < put && atomic_read(&ch->n_to_notify) > 0) {
 
 		notify = &ch->sn.sn2.notify_queue[get % ch->local_nentries];
@@ -1743,6 +1759,12 @@ xpc_notify_senders_sn2(struct xpc_channe
 				" msg_number=%lld partid=%d channel=%d\n",
 				(void *)notify, get, ch->partid, ch->number);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1923,6 +1945,11 @@ xpc_pull_remote_msg_sn2(struct xpc_chann
 		return NULL;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (get >= ch_sn2->next_msg_to_pull) {
 
 		/* pull as many messages as are ready and able to be pulled */
@@ -1957,6 +1984,12 @@ xpc_pull_remote_msg_sn2(struct xpc_chann
 		}
 
 		ch_sn2->next_msg_to_pull += nmsgs;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&ch_sn2->msg_to_pull_mutex);
diff -u -p a/misc/ad525x_dpot-spi.c b/misc/ad525x_dpot-spi.c
--- a/misc/ad525x_dpot-spi.c
+++ b/misc/ad525x_dpot-spi.c
@@ -113,10 +113,21 @@ static const struct ad_dpot_bus_ops bops
 static const struct ad_dpot_id *dpot_match_id(const struct ad_dpot_id *id,
 						char *name)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (id->name && id->name[0]) {
 		if (strcmp(name, id->name) == 0)
 			return id;
 		id++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return NULL;
 }
diff -u -p a/misc/ibmasm/remote.c b/misc/ibmasm/remote.c
--- a/misc/ibmasm/remote.c
+++ b/misc/ibmasm/remote.c
@@ -190,7 +190,12 @@ void ibmasm_handle_mouse_interrupt(struc
 	reader = get_queue_reader(sp);
 	writer = get_queue_writer(sp);
 
-	while (reader != writer) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (reader != writer) {
 		memcpy_fromio(&input, get_queue_entry(sp, reader),
 				sizeof(struct remote_input));
 
@@ -204,6 +209,12 @@ void ibmasm_handle_mouse_interrupt(struc
 
 		reader = advance_queue_reader(sp, reader);
 		writer = get_queue_writer(sp);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/misc/ibmasm/event.c b/misc/ibmasm/event.c
--- a/misc/ibmasm/event.c
+++ b/misc/ibmasm/event.c
@@ -108,9 +108,20 @@ int ibmasm_get_next_event(struct service
 
 	index = buffer->next_index;
 	event = &buffer->events[index];
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (event->serial_number < reader->next_serial_number) {
 		index = (index + 1) % IBMASM_NUM_EVENTS;
 		event = &buffer->events[index];
+		if (_cur < timeout) {
+	rdstcll(_cur);
+		}
+		else {
+	break;
+		}
 	}
 	memcpy(reader->data, event->data, event->data_size);
 	reader->data_size = event->data_size;
diff -u -p a/misc/kgdbts.c b/misc/kgdbts.c
--- a/misc/kgdbts.c
+++ b/misc/kgdbts.c
@@ -700,9 +700,20 @@ static void fill_get_buf(char *buf)
 
 	strcpy(get_buf, "$");
 	strcat(get_buf, buf);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((ch = buf[count])) {
 		checksum += ch;
 		count++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	strcat(get_buf, "#");
 	get_buf[count + 2] = hex_asc_hi(checksum);
@@ -723,6 +734,11 @@ static int validate_simple_test(char *pu
 	if (*put_str == '$')
 		put_str++;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (*chk_str != '\0' && *put_str != '\0') {
 		/* If someone does a * to match the rest of the string, allow
 		 * it, or stop if the received string is complete.
@@ -734,6 +750,12 @@ static int validate_simple_test(char *pu
 
 		chk_str++;
 		put_str++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	if (*chk_str == '\0' && (*put_str == '\0' || *put_str == '#'))
 		return 0;
diff -u -p a/misc/pch_phub.c b/misc/pch_phub.c
--- a/misc/pch_phub.c
+++ b/misc/pch_phub.c
@@ -323,12 +323,23 @@ static int pch_phub_write_serial_rom(str
 	iowrite32((word_data & mask) | (u32)data << pos, mem_addr);
 
 	i = 0;
-	while (ioread8(chip->pch_phub_extrom_base_address +
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (ioread8(chip->pch_phub_extrom_base_address +
 						PHUB_STATUS) != 0x00) {
 		msleep(1);
 		if (i == PHUB_TIMEOUT)
 			return -ETIMEDOUT;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	iowrite32(PCH_PHUB_ROM_WRITE_DISABLE,
diff -u -p a/misc/iwmc3200top/fw-download.c b/misc/iwmc3200top/fw-download.c
--- a/misc/iwmc3200top/fw-download.c
+++ b/misc/iwmc3200top/fw-download.c
@@ -115,6 +115,11 @@ static int iwmct_parse_next_section(stru
 
 	LOG_TRACE(priv, FW_DOWNLOAD, "-->\n");
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (parser->cur_pos + sizeof(struct iwmct_fw_sec_hdr)
 		<= parser->file_size) {
 
@@ -150,6 +155,12 @@ static int iwmct_parse_next_section(stru
 		parser->cur_pos += le32_to_cpu(sec_hdr->data_size);
 		LOG_INFO(priv, FW_DOWNLOAD,
 			"finished with section cur_pos=%zd\n", parser->cur_pos);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	LOG_TRACE(priv, INIT, "<--\n");
@@ -340,13 +351,24 @@ int iwmct_fw_load(struct iwmct_priv *pri
 	}
 
 	/* download firmware to device */
-	while (iwmct_parse_next_section(priv, &pdata, &len, &addr)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (iwmct_parse_next_section(priv, &pdata, &len, &addr)) {
 		ret = iwmct_download_section(priv, pdata, len, addr);
 		if (ret) {
 			LOG_ERROR(priv, FW_DOWNLOAD,
 				  "%s download section failed\n", fw_name);
 			goto exit;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	ret = iwmct_kick_fw(priv, !!(priv->barker & BARKER_DNLOAD_JUMP_MSK));
diff -u -p a/misc/iwmc3200top/main.c b/misc/iwmc3200top/main.c
--- a/misc/iwmc3200top/main.c
+++ b/misc/iwmc3200top/main.c
@@ -611,12 +611,23 @@ static void iwmct_remove(struct sdio_fun
 	sdio_release_host(func);
 
 	/* free read requests */
-	while (!list_empty(&priv->read_req_list)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!list_empty(&priv->read_req_list)) {
 		read_req = list_entry(priv->read_req_list.next,
 			struct iwmct_work_struct, list);
 
 		list_del(&read_req->list);
 		kfree(read_req);
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	kfree(priv);
diff -u -p a/misc/iwmc3200top/log.c b/misc/iwmc3200top/log.c
--- a/misc/iwmc3200top/log.c
+++ b/misc/iwmc3200top/log.c
@@ -224,6 +224,11 @@ ssize_t store_iwmct_log_level(struct dev
 
 	memcpy(str_buf, buf, count);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((token = strsep(&str_buf, ",")) != NULL) {
 		while (isspace(*token))
 			++token;
@@ -238,6 +243,12 @@ ssize_t store_iwmct_log_level(struct dev
 		mask  = val & 0xFF;
 		src = (val & 0XFF00) >> 8;
 		iwmct_log_set_filter(src, mask);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 exit:
diff -u -p a/misc/atmel_pwm.c b/misc/atmel_pwm.c
--- a/misc/atmel_pwm.c
+++ b/misc/atmel_pwm.c
@@ -283,6 +283,11 @@ static irqreturn_t pwm_irq(int id, void
 	/* ack irqs, then handle them */
 	irqstat = pwm_readl(pwm, PWM_ISR);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (irqstat) {
 		struct pwm_channel *ch;
 		void (*handler)(struct pwm_channel *ch);
@@ -297,6 +302,12 @@ static irqreturn_t pwm_irq(int id, void
 			spin_lock(&p->lock);
 			handled = IRQ_HANDLED;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock(&p->lock);
diff -u -p a/misc/altera-stapl/altera-jtag.c b/misc/altera-stapl/altera-jtag.c
--- a/misc/altera-stapl/altera-jtag.c
+++ b/misc/altera-stapl/altera-jtag.c
@@ -322,7 +322,12 @@ int altera_goto_jstate(struct altera_sta
 			alt_jtag_io(TMS_HIGH, TDI_LOW, IGNORE_TDO);
 
 	} else {
-		while ((js->jtag_state != state) && (count < 9)) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while ((js->jtag_state != state) && (count < 9)) {
 			/* Get TMS value to take a step toward desired state */
 			tms = (altera_jtag_path_map[js->jtag_state] &
 							(1 << state))
@@ -339,6 +344,12 @@ int altera_goto_jstate(struct altera_sta
 					altera_transitions[js->jtag_state].tms_low;
 
 			++count;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 	}
 
diff -u -p a/misc/altera-stapl/altera.c b/misc/altera-stapl/altera.c
--- a/misc/altera-stapl/altera.c
+++ b/misc/altera-stapl/altera.c
@@ -471,7 +471,12 @@ exit_done:
 		if (status == 0) {
 			int first_time = 1;
 			i = current_proc;
-			while ((i != 0) || first_time) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+				while ((i != 0) || first_time) {
 				first_time = 0;
 				/* check procedure attribute byte */
 				proc_attributes[i] =
@@ -488,6 +493,12 @@ exit_done:
 
 				i = get_unaligned_be32(&p[proc_table +
 							(13 * i) + 4]);
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 
 			/*
@@ -495,11 +506,22 @@ exit_done:
 			 * to be executed
 			 */
 			i = current_proc;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while ((i != 0) &&
 				((proc_attributes[i] == 1) ||
 				((proc_attributes[i] & 0xc0) == 0x40))) {
 				i = get_unaligned_be32(&p[proc_table +
 							(13 * i) + 4]);
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 
 			if ((i != 0) || ((i == 0) && (current_proc == 0) &&
@@ -520,6 +542,11 @@ exit_done:
 
 	msg_buff[0] = '\0';
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!done) {
 		opcode = (p[pc] & 0xff);
 		opcode_address = pc;
@@ -1363,7 +1390,12 @@ exit_done:
 
 				long_tmp = long_idx + long_count - 1;
 				long_idx2 = 0;
-				while (long_idx2 < long_count) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+						timeout = rdstcll(start) + delta;
+						while (long_idx2 < long_count) {
 					if (charptr_tmp2[long_tmp >> 3] &
 							(1 << (long_tmp & 7)))
 						charptr_tmp[long_idx2 >> 3] |=
@@ -1374,6 +1406,12 @@ exit_done:
 
 					--long_tmp;
 					++long_idx2;
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
 				}
 			}
 
@@ -2108,6 +2146,12 @@ exit_done:
 			done = 1;
 			*error_address = (s32)(opcode_address - code_sect);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	altera_free_buffers(astate);
@@ -2488,6 +2532,11 @@ int altera_init(struct altera_config *co
 						description);
 
 			procptr = proc_list;
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (procptr != NULL) {
 				if (procptr->attrs != 0)
 					printk(KERN_INFO "%s:    %s (%s)\n",
@@ -2499,6 +2548,12 @@ int altera_init(struct altera_config *co
 				proc_list = procptr->next;
 				kfree(procptr);
 				procptr = proc_list;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 
diff -u -p a/misc/altera-stapl/altera-comp.c b/misc/altera-stapl/altera-comp.c
--- a/misc/altera-stapl/altera-comp.c
+++ b/misc/altera-stapl/altera-comp.c
@@ -41,9 +41,20 @@ static u32 altera_bits_req(u32 n)
 		result = 1;
 	else {
 		/* Look for the highest non-zero bit position */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((n & (1 << (SHORT_BITS - 1))) == 0) {
 			n <<= 1;
 			--result;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
@@ -57,7 +68,12 @@ static u32 altera_read_packed(u8 *buffer
 	u32 shift = 0;
 	u32 databyte = 0;
 
-	while (bits > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (bits > 0) {
 		databyte = buffer[*in_index];
 		result |= (((databyte >> (CHAR_BITS - *bits_avail))
 			& (0xff >> (CHAR_BITS - *bits_avail))) << shift);
@@ -72,6 +88,12 @@ static u32 altera_read_packed(u8 *buffer
 			bits -= *bits_avail;
 			*bits_avail = CHAR_BITS;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return result;
@@ -106,6 +128,11 @@ u32 altera_shrink(u8 *in, u32 in_length,
 	}
 
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < data_length) {
 		/* A 0 bit indicates literal data. */
 		if (altera_read_packed(in, 1, &bits_avail,
@@ -136,6 +163,12 @@ u32 altera_shrink(u8 *in, u32 in_length,
 				}
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return data_length;
diff -u -p a/input/keyboard/jornada720_kbd.c b/input/keyboard/jornada720_kbd.c
--- a/input/keyboard/jornada720_kbd.c
+++ b/input/keyboard/jornada720_kbd.c
@@ -75,7 +75,12 @@ static irqreturn_t jornada720_kbd_interr
 		count = jornada_ssp_byte(TXDUMMY);
 
 		/* Lets drag them out one at a time */
-		while (count--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (count--) {
 			/* Exchange TxDummy for location (keymap[kbddata]) */
 			kbd_data = jornada_ssp_byte(TXDUMMY);
 			scan_code = kbd_data & 0x7f;
@@ -84,6 +89,12 @@ static irqreturn_t jornada720_kbd_interr
 			input_report_key(input, jornadakbd->keymap[scan_code],
 					 !(kbd_data & 0x80));
 			input_sync(input);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 
diff -u -p a/input/keyboard/qt2160.c b/input/keyboard/qt2160.c
--- a/input/keyboard/qt2160.c
+++ b/input/keyboard/qt2160.c
@@ -85,7 +85,12 @@ static int qt2160_read_block(struct i2c_
 		}
 	} else {
 
-		while (count--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (count--) {
 			int data;
 
 			error = i2c_smbus_write_byte(client, inireg + idx);
@@ -103,6 +108,12 @@ static int qt2160_read_block(struct i2c_
 			}
 
 			buffer[idx++] = data;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 
diff -u -p a/input/keyboard/gpio_keys.c b/input/keyboard/gpio_keys.c
--- a/input/keyboard/gpio_keys.c
+++ b/input/keyboard/gpio_keys.c
@@ -486,6 +486,11 @@ static int gpio_keys_get_devtree_pdata(s
 
 	pp = NULL;
 	i = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((pp = of_get_next_child(node, pp))) {
 		enum of_gpio_flags flags;
 
@@ -518,6 +523,12 @@ static int gpio_keys_get_devtree_pdata(s
 			buttons[i].debounce_interval = 5;
 
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pdata->buttons = buttons;
@@ -642,12 +653,23 @@ static int __devinit gpio_keys_probe(str
  fail3:
 	sysfs_remove_group(&pdev->dev.kobj, &gpio_keys_attr_group);
  fail2:
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (--i >= 0) {
 		free_irq(gpio_to_irq(pdata->buttons[i].gpio), &ddata->data[i]);
 		if (ddata->data[i].timer_debounce)
 			del_timer_sync(&ddata->data[i].timer);
 		cancel_work_sync(&ddata->data[i].work);
 		gpio_free(pdata->buttons[i].gpio);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	platform_set_drvdata(pdev, NULL);
diff -u -p a/input/keyboard/hil_kbd.c b/input/keyboard/hil_kbd.c
--- a/input/keyboard/hil_kbd.c
+++ b/input/keyboard/hil_kbd.c
@@ -248,6 +248,11 @@ static void hil_dev_handle_ptr_events(st
 		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (cnt < idx - 1) {
 		unsigned int btn = ptr->data[cnt++];
 		int up = btn & 1;
@@ -260,6 +265,12 @@ static void hil_dev_handle_ptr_events(st
 		btn = (btn - 0x80) >> 1;
 		btn = ptr->btnmap[btn];
 		input_report_key(dev, btn, !up);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	input_sync(dev);
diff -u -p a/input/keyboard/hilkbd.c b/input/keyboard/hilkbd.c
--- a/input/keyboard/hilkbd.c
+++ b/input/keyboard/hilkbd.c
@@ -190,10 +190,21 @@ static void hil_do(unsigned char cmd, un
 	while (hil_busy())
 		/* wait */;
 	hil_command(cmd);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len--) {
 		while (hil_busy())
 			/* wait */;
 		hil_write_data(*(data++));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	spin_unlock_irqrestore(&hil_dev.lock, flags);
 }
diff -u -p a/input/keyboard/lm8323.c b/input/keyboard/lm8323.c
--- a/input/keyboard/lm8323.c
+++ b/input/keyboard/lm8323.c
@@ -275,6 +275,11 @@ static void process_keys(struct lm8323_c
 	}
 	key_fifo[ret] = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((event = key_fifo[i++])) {
 		u8 key = lm8323_whichkey(event);
 		int isdown = lm8323_ispress(event);
@@ -293,6 +298,12 @@ static void process_keys(struct lm8323_c
 			lm->keys_down++;
 		else
 			lm->keys_down--;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+		else {
+			break;
+		}
 	}
 
 	/*
@@ -381,6 +392,11 @@ static irqreturn_t lm8323_irq(int irq, v
 
 	mutex_lock(&lm->lock);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((lm8323_read(lm, LM8323_CMD_READ_INT, &ints, 1) == 1) && ints) {
 		if (likely(ints & INT_KEYPAD))
 			process_keys(lm);
@@ -404,6 +420,12 @@ static irqreturn_t lm8323_irq(int irq, v
 				pwm_done(&lm->pwm[i]);
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&lm->lock);
@@ -491,12 +513,23 @@ static void lm8323_pwm_work(struct work_
 	else if (perstep > 63)
 		perstep = 63;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (steps) {
 		int s;
 
 		s = min(126, steps);
 		pwm_cmds[num_cmds++] = PWM_RAMP(div512, perstep, s, up);
 		steps -= s;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	lm8323_write_pwm(pwm, kill, num_cmds, pwm_cmds);
diff -u -p a/input/keyboard/tnetv107x-keypad.c b/input/keyboard/tnetv107x-keypad.c
--- a/input/keyboard/tnetv107x-keypad.c
+++ b/input/keyboard/tnetv107x-keypad.c
@@ -86,6 +86,11 @@ static irqreturn_t keypad_irq(int irq, v
 	for (i = 0; i < 3; i++) {
 		change = curr_keys[i] ^ kp->prev_keys[i];
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (change) {
 			bit     = fls(change) - 1;
 			change ^= BIT(bit);
@@ -98,6 +103,12 @@ static irqreturn_t keypad_irq(int irq, v
 			input_event(kp->input_dev, EV_MSC, MSC_SCAN, code);
 			input_report_key(kp->input_dev, kp->keycodes[code],
 					 val);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	input_sync(kp->input_dev);
diff -u -p a/input/misc/yealink.c b/input/misc/yealink.c
--- a/input/misc/yealink.c
+++ b/input/misc/yealink.c
@@ -311,6 +311,11 @@ static int yealink_set_ringtone(struct y
 
 	p->cmd = CMD_RING_NOTE;
 	ix = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size != ix) {
 		len = size - ix;
 		if (len > sizeof(p->data))
@@ -320,6 +325,12 @@ static int yealink_set_ringtone(struct y
 		memcpy(p->data, &buf[ix], len);
 		yealink_cmd(yld, p);
 		ix += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/input/misc/uinput.c b/input/misc/uinput.c
--- a/input/misc/uinput.c
+++ b/input/misc/uinput.c
@@ -477,6 +477,11 @@ static ssize_t uinput_read(struct file *
 		goto out;
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (udev->head != udev->tail && retval + input_event_size() <= count) {
 		if (input_event_to_user(buffer + retval, &udev->buff[udev->tail])) {
 			retval = -EFAULT;
@@ -484,6 +489,12 @@ static ssize_t uinput_read(struct file *
 		}
 		udev->tail = (udev->tail + 1) % UINPUT_BUFFER_SIZE;
 		retval += input_event_size();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
  out:
diff -u -p a/input/misc/keyspan_remote.c b/input/misc/keyspan_remote.c
--- a/input/misc/keyspan_remote.c
+++ b/input/misc/keyspan_remote.c
@@ -164,10 +164,21 @@ static int keyspan_load_tester(struct us
 	}
 
 	/* Load as much as we can into the tester. */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((dev->data.bits_left + 7 < (sizeof(dev->data.tester) * 8)) &&
 	       (dev->data.pos < dev->data.len)) {
 		dev->data.tester += (dev->data.buffer[dev->data.pos++] << dev->data.bits_left);
 		dev->data.bits_left += 8;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	return 0;
@@ -218,6 +229,11 @@ static void keyspan_check_data(struct us
 		remote->data.len += RECV_SIZE;
 
 		found = 0;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((remote->data.bits_left >= 14 || remote->data.pos < remote->data.len) && !found) {
 			for (i = 0; i < 8; ++i) {
 				if (keyspan_load_tester(remote, 14) != 0) {
@@ -235,6 +251,12 @@ static void keyspan_check_data(struct us
 					--remote->data.bits_left;
 				}
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		if (!found) {
diff -u -p a/input/misc/hp_sdc_rtc.c b/input/misc/hp_sdc_rtc.c
--- a/input/misc/hp_sdc_rtc.c
+++ b/input/misc/hp_sdc_rtc.c
@@ -91,7 +91,12 @@ static int hp_sdc_rtc_do_read_bbrtc (str
 	int i;
 	
 	i = 0;
-	while (i < 91) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (i < 91) {
 		tseq[i++] = HP_SDC_ACT_DATAREG |
 			HP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN;
 		tseq[i++] = 0x01;			/* write i8042[0x70] */
@@ -100,6 +105,12 @@ static int hp_sdc_rtc_do_read_bbrtc (str
 		tseq[i++] = HP_SDC_CMD_DO_RTCR;		/* Trigger command   */
 		tseq[i++] = 2;		/* expect 1 stat/dat pair back.   */
 		i++; i++;               /* buffer for stat/dat pair       */
+		if (_cur < timeout) {
+	  	rdstcll(_cur);
+		}
+		else {
+	  	break;
+		}
 	}
 	tseq[84] |= HP_SDC_ACT_SEMAPHORE;
 	t.endidx =		91;
@@ -139,10 +150,21 @@ static int hp_sdc_rtc_read_bbrtc (struct
 	if (hp_sdc_rtc_do_read_bbrtc(&tm_last)) return -1;
 	if (hp_sdc_rtc_do_read_bbrtc(&tm)) return -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (memcmp(&tm, &tm_last, sizeof(struct rtc_time))) {
 		if (i++ > 4) return -1;
 		memcpy(&tm_last, &tm, sizeof(struct rtc_time));
 		if (hp_sdc_rtc_do_read_bbrtc(&tm)) return -1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	memcpy(rtctm, &tm, sizeof(struct rtc_time));
diff -u -p a/input/serio/serio.c b/input/serio/serio.c
--- a/input/serio/serio.c
+++ b/input/serio/serio.c
@@ -90,6 +90,11 @@ static void serio_disconnect_driver(stru
 
 static int serio_match_port(const struct serio_device_id *ids, struct serio *serio)
 {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ids->type || ids->proto) {
 		if ((ids->type == SERIO_ANY || ids->type == serio->id.type) &&
 		    (ids->proto == SERIO_ANY || ids->proto == serio->id.proto) &&
@@ -97,6 +102,12 @@ static int serio_match_port(const struct
 		    (ids->id == SERIO_ANY || ids->id == serio->id.id))
 			return 1;
 		ids++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
@@ -220,7 +231,12 @@ static void serio_handle_event(struct wo
 
 	mutex_lock(&serio_mutex);
 
-	while ((event = serio_get_event())) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while ((event = serio_get_event())) {
 
 		switch (event->type) {
 
@@ -248,6 +264,12 @@ static void serio_handle_event(struct wo
 
 		serio_remove_duplicate_events(event->object, event->type);
 		serio_free_event(event);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&serio_mutex);
@@ -555,9 +577,20 @@ static void serio_destroy_port(struct se
 {
 	struct serio *child;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((child = serio_get_pending_child(serio)) != NULL) {
 		serio_remove_pending_events(child);
 		put_device(&child->dev);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (serio->stop)
@@ -650,6 +683,11 @@ static void serio_disconnect_port(struct
 	 * Children ports should be disconnected and destroyed
 	 * first; we travel the tree in depth-first order.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!list_empty(&serio->children)) {
 
 		/* Locate a leaf */
@@ -669,6 +707,12 @@ static void serio_disconnect_port(struct
 
 			s = parent;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/*
diff -u -p a/input/serio/ct82c710.c b/input/serio/ct82c710.c
--- a/input/serio/ct82c710.c
+++ b/input/serio/ct82c710.c
@@ -83,13 +83,24 @@ static int ct82c170_wait(void)
 {
 	int timeout = 60000;
 
-	while ((inb(CT82C710_STATUS) & (CT82C710_RX_FULL | CT82C710_TX_IDLE | CT82C710_DEV_IDLE))
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ((inb(CT82C710_STATUS) & (CT82C710_RX_FULL | CT82C710_TX_IDLE | CT82C710_DEV_IDLE))
 		       != (CT82C710_DEV_IDLE | CT82C710_TX_IDLE) && timeout) {
 
 		if (inb_p(CT82C710_STATUS) & CT82C710_RX_FULL) inb_p(CT82C710_DATA);
 
 		udelay(1);
 		timeout--;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 
 	return !timeout;
@@ -128,12 +139,23 @@ static int ct82c710_open(struct serio *s
 	status |= CT82C710_INTS_ON;
 	outb_p(status, CT82C710_STATUS);	/* Enable interrupts */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (ct82c170_wait()) {
 		printk(KERN_ERR "ct82c710: Device busy in open()\n");
 		status &= ~(CT82C710_ENABLE | CT82C710_INTS_ON);
 		outb_p(status, CT82C710_STATUS);
 		free_irq(CT82C710_IRQ, NULL);
 		return -EBUSY;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/input/serio/ambakmi.c b/input/serio/ambakmi.c
--- a/input/serio/ambakmi.c
+++ b/input/serio/ambakmi.c
@@ -43,10 +43,21 @@ static irqreturn_t amba_kmi_int(int irq,
 	unsigned int status = readb(KMIIR);
 	int handled = IRQ_NONE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & KMIIR_RXINTR) {
 		serio_interrupt(kmi->io, readb(KMIDATA), 0);
 		status = readb(KMIIR);
 		handled = IRQ_HANDLED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return handled;
diff -u -p a/input/serio/ams_delta_serio.c b/input/serio/ams_delta_serio.c
--- a/input/serio/ams_delta_serio.c
+++ b/input/serio/ams_delta_serio.c
@@ -75,6 +75,11 @@ static irqreturn_t ams_delta_serio_inter
 	 * Read data from the circular buffer, check it
 	 * and then pass it on the serio
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (fiq_buffer[FIQ_KEYS_CNT] > 0) {
 
 		data = circ_buff[fiq_buffer[FIQ_HEAD_OFFSET]++];
@@ -85,6 +90,12 @@ static irqreturn_t ams_delta_serio_inter
 		dfl = check_data(data);
 		scancode = (u8) (data >> 1) & 0xFF;
 		serio_interrupt(ams_delta_serio, scancode, dfl);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return IRQ_HANDLED;
 }
diff -u -p a/input/serio/altera_ps2.c b/input/serio/altera_ps2.c
--- a/input/serio/altera_ps2.c
+++ b/input/serio/altera_ps2.c
@@ -40,9 +40,20 @@ static irqreturn_t altera_ps2_rxint(int
 	unsigned int status;
 	int handled = IRQ_NONE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((status = readl(ps2if->base)) & 0xffff0000) {
 		serio_interrupt(ps2if->io, status & 0xff, 0);
 		handled = IRQ_HANDLED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return handled;
diff -u -p a/input/serio/gscps2.c b/input/serio/gscps2.c
--- a/input/serio/gscps2.c
+++ b/input/serio/gscps2.c
@@ -119,10 +119,21 @@ struct gscps2port {
 static int wait_TBE(char *addr)
 {
 	int timeout = 25000; /* device is expected to react within 250 msec */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (gscps2_readb_status(addr) & GSC_STAT_TBNE) {
 		if (!--timeout)
 			return 0;	/* This should not happen */
 		udelay(10);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 1;
 }
@@ -236,11 +247,22 @@ static irqreturn_t gscps2_interrupt(int
 	  unsigned long flags;
 	  spin_lock_irqsave(&ps2port->lock, flags);
 
-	  while ( (ps2port->buffer[ps2port->append].str =
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	  unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while ( (ps2port->buffer[ps2port->append].str =
 		   gscps2_readb_status(ps2port->addr)) & GSC_STAT_RBNE ) {
 		ps2port->buffer[ps2port->append].data =
 				gscps2_readb_input(ps2port->addr);
 		ps2port->append = ((ps2port->append+1) & BUFFER_SIZE);
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	  }
 
 	  spin_unlock_irqrestore(&ps2port->lock, flags);
@@ -251,6 +273,11 @@ static irqreturn_t gscps2_interrupt(int
 
 	list_for_each_entry(ps2port, &ps2port_list, node) {
 
+	  unsigned long long delta = (cpu / khz / HZ) * 2;
+	  unsigned long long _start = 0;
+	  unsigned long long _cur = 0;
+	  unsigned long long timeout;
+	  timeout = rdstcll(start) + delta;
 	  while (ps2port->act != ps2port->append) {
 
 	    unsigned int rxflags;
@@ -270,6 +297,12 @@ static irqreturn_t gscps2_interrupt(int
 
 	    serio_interrupt(ps2port->port, data, rxflags);
 
+	    if (_cur < timeout) {
+			rdstcll(_cur);
+	    }
+	    else {
+			break;
+	    }
 	  } /* while() */
 
 	} /* list_for_each_entry */
diff -u -p a/input/serio/rpckbd.c b/input/serio/rpckbd.c
--- a/input/serio/rpckbd.c
+++ b/input/serio/rpckbd.c
@@ -62,11 +62,22 @@ static irqreturn_t rpckbd_rx(int irq, vo
 	unsigned int byte;
 	int handled = IRQ_NONE;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (iomd_readb(IOMD_KCTRL) & (1 << 5)) {
 		byte = iomd_readb(IOMD_KARTRX);
 
 		serio_interrupt(port, byte, 0);
 		handled = IRQ_HANDLED;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return handled;
 }
diff -u -p a/input/serio/serio_raw.c b/input/serio/serio_raw.c
--- a/input/serio/serio_raw.c
+++ b/input/serio/serio_raw.c
@@ -180,10 +180,21 @@ static ssize_t serio_raw_read(struct fil
 	if (serio_raw->dead)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retval < count && serio_raw_fetch_byte(serio_raw, &c)) {
 		if (put_user(c, buffer++))
 			return -EFAULT;
 		retval++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return retval;
@@ -210,6 +221,11 @@ static ssize_t serio_raw_write(struct fi
 	if (count > 32)
 		count = 32;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (count--) {
 		if (get_user(c, buffer++)) {
 			retval = -EFAULT;
@@ -220,6 +236,12 @@ static ssize_t serio_raw_write(struct fi
 			goto out;
 		}
 		written++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	};
 
 out:
diff -u -p a/input/serio/hil_mlc.c b/input/serio/hil_mlc.c
--- a/input/serio/hil_mlc.c
+++ b/input/serio/hil_mlc.c
@@ -172,6 +172,11 @@ static void hil_mlc_send_polls(hil_mlc *
 	serio = did ? mlc->serio[mlc->di_map[did - 1]] : NULL;
 	drv = (serio != NULL) ? serio->drv : NULL;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (mlc->icount < 15 - i) {
 		hil_packet p;
 
@@ -199,6 +204,12 @@ static void hil_mlc_send_polls(hil_mlc *
 			drv->interrupt(serio, (p >> 8) & ~HIL_PKT_ADDR_MASK, 0);
 			drv->interrupt(serio, p & 0xff, 0);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -731,6 +742,11 @@ static int hilse_donode(hil_mlc *mlc)
 		doze++;
 #endif
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (nextidx & HILSEN_SCHED) {
 		struct timeval tv;
 
@@ -748,6 +764,12 @@ static int hilse_donode(hil_mlc *mlc)
 	sched:
 		tasklet_schedule(&hil_mlcs_tasklet);
 		break;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 
 	if (nextidx & HILSEN_DOWN)
@@ -771,13 +793,24 @@ static void hil_mlcs_process(unsigned lo
 	read_lock(&hil_mlcs_lock);
 	list_for_each(tmp, &hil_mlcs) {
 		struct hil_mlc *mlc = list_entry(tmp, hil_mlc, list);
-		while (hilse_donode(mlc) == 0) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (hilse_donode(mlc) == 0) {
 #ifdef HIL_MLC_DEBUG
 			if (mlc->seidx != 41 &&
 			    mlc->seidx != 42 &&
 			    mlc->seidx != 43)
 				printk(KERN_DEBUG PREFIX " + ");
 #endif
+if (_cur < timeout) {
+				rdstcll(_cur);
+}
+else {
+				break;
+}
 		}
 	}
 	read_unlock(&hil_mlcs_lock);
@@ -846,12 +879,23 @@ static int hil_mlc_serio_write(struct se
 	while ((last != idx) && (*last == 0))
 		last--;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (idx != last) {
 		drv->interrupt(serio, 0, 0);
 		drv->interrupt(serio, HIL_ERR_INT >> 16, 0);
 		drv->interrupt(serio, 0, 0);
 		drv->interrupt(serio, *idx, 0);
 		idx++;
+		if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
 	}
 	drv->interrupt(serio, 0, 0);
 	drv->interrupt(serio, HIL_ERR_INT >> 16, 0);
diff -u -p a/input/serio/hp_sdc.c b/input/serio/hp_sdc.c
--- a/input/serio/hp_sdc.c
+++ b/input/serio/hp_sdc.c
@@ -171,8 +171,19 @@ static inline void hp_sdc_spin_ibf(void)
 	}
 	read_unlock(lock);
 	write_lock(lock);
-	while (sdc_readb(hp_sdc.status_io) & HP_SDC_STATUS_IBF)
-		{ }
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (sdc_readb(hp_sdc.status_io) & HP_SDC_STATUS_IBF)
+		{ if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
+		}
 	hp_sdc.ibf = 0;
 	write_unlock_irqrestore(lock, flags);
 }
diff -u -p a/input/serio/i8042.c b/input/serio/i8042.c
--- a/input/serio/i8042.c
+++ b/input/serio/i8042.c
@@ -196,9 +196,20 @@ static int i8042_wait_read(void)
 {
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((~i8042_read_status() & I8042_STR_OBF) && (i < I8042_CTL_TIMEOUT)) {
 		udelay(50);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -(i == I8042_CTL_TIMEOUT);
 }
@@ -207,9 +218,20 @@ static int i8042_wait_write(void)
 {
 	int i = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((i8042_read_status() & I8042_STR_IBF) && (i < I8042_CTL_TIMEOUT)) {
 		udelay(50);
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return -(i == I8042_CTL_TIMEOUT);
 }
@@ -227,12 +249,23 @@ static int i8042_flush(void)
 
 	spin_lock_irqsave(&i8042_lock, flags);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (((str = i8042_read_status()) & I8042_STR_OBF) && (i < I8042_BUFFER_SIZE)) {
 		udelay(50);
 		data = i8042_read_data();
 		i++;
 		dbg("%02x <- i8042 (flush, %s)\n",
 		    data, str & I8042_STR_AUXDATA ? "aux" : "kbd");
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	spin_unlock_irqrestore(&i8042_lock, flags);
diff -u -p a/input/serio/sa1111ps2.c b/input/serio/sa1111ps2.c
--- a/input/serio/sa1111ps2.c
+++ b/input/serio/sa1111ps2.c
@@ -46,6 +46,11 @@ static irqreturn_t ps2_rxint(int irq, vo
 	unsigned int scancode, flag, status;
 
 	status = sa1111_readl(ps2if->base + SA1111_PS2STAT);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (status & PS2STAT_RXF) {
 		if (status & PS2STAT_STP)
 			sa1111_writel(PS2STAT_STP, ps2if->base + SA1111_PS2STAT);
@@ -61,6 +66,12 @@ static irqreturn_t ps2_rxint(int irq, vo
 		serio_interrupt(ps2if->io, scancode, flag);
 
 		status = sa1111_readl(ps2if->base + SA1111_PS2STAT);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
         }
 
         return IRQ_HANDLED;
diff -u -p a/input/evdev.c b/input/evdev.c
--- a/input/evdev.c
+++ b/input/evdev.c
@@ -403,6 +403,11 @@ static ssize_t evdev_read(struct file *f
 	if (!evdev->exist)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retval + input_event_size() <= count &&
 	       evdev_fetch_next_event(client, &event)) {
 
@@ -410,6 +415,12 @@ static ssize_t evdev_read(struct file *f
 			return -EFAULT;
 
 		retval += input_event_size();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return retval;
diff -u -p a/input/joystick/gf2k.c b/input/joystick/gf2k.c
--- a/input/joystick/gf2k.c
+++ b/input/joystick/gf2k.c
@@ -109,6 +109,11 @@ static int gf2k_read_packet(struct gamep
 	gameport_trigger(gameport);
 	v = gameport_read(gameport);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (t > 0 && i < length) {
 		t--; u = v;
 		v = gameport_read(gameport);
@@ -116,6 +121,12 @@ static int gf2k_read_packet(struct gamep
 			data[i++] = v >> 5;
 			t = p;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	local_irq_restore(flags);
diff -u -p a/input/joystick/grip_mp.c b/input/joystick/grip_mp.c
--- a/input/joystick/grip_mp.c
+++ b/input/joystick/grip_mp.c
@@ -330,6 +330,11 @@ static int dig_mode_start(struct gamepor
 	for (i = 0; i < 16; i++)            /* Wait for multiport to settle */
 		udelay(GRIP_INIT_DELAY);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tries < 64 && bads < 8) {    /* Reset multiport and try getting a packet */
 
 		flags = multiport_io(gameport, IO_RESET, 0x27, packet);
@@ -341,6 +346,12 @@ static int dig_mode_start(struct gamepor
 			tries++;
 		else
 			bads++;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return 0;
 }
@@ -480,9 +491,20 @@ static int multiport_init(struct grip_mp
 	u32 packet;
 
 	dig_mode = dig_mode_start(grip->gameport, &packet);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!dig_mode && tries < 4) {
 		dig_mode = dig_mode_start(grip->gameport, &packet);
 		tries++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (dig_mode)
diff -u -p a/input/joystick/analog.c b/input/joystick/analog.c
--- a/input/joystick/analog.c
+++ b/input/joystick/analog.c
@@ -291,6 +291,11 @@ static int analog_button_read(struct ana
 
 	port->buttons = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((~u & 0xf0) && (i < 16) && t) {
 		port->buttons |= 1 << analog_chf[(~u >> 4) & 0xf];
 		if (!saitek) return 0;
@@ -299,6 +304,12 @@ static int analog_button_read(struct ana
 		gameport_trigger(port->gameport);
 		while (((u = gameport_read(port->gameport)) & port->mask) && t) t--;
 		i++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return -(!t || (i == 16));
diff -u -p a/input/joystick/joydump.c b/input/joystick/joydump.c
--- a/input/joystick/joydump.c
+++ b/input/joystick/joydump.c
@@ -100,6 +100,11 @@ static int joydump_connect(struct gamepo
 
 	gameport_trigger(gameport);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < BUF_SIZE && t < timeout) {
 
 		dump->data = gameport_read(gameport);
@@ -111,6 +116,12 @@ static int joydump_connect(struct gamepo
 			dump++;
 		}
 		t++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	local_irq_restore(flags);
diff -u -p a/input/joystick/guillemot.c b/input/joystick/guillemot.c
--- a/input/joystick/guillemot.c
+++ b/input/joystick/guillemot.c
@@ -100,6 +100,11 @@ static int guillemot_read_packet(struct
 	gameport_trigger(gameport);
 	v = gameport_read(gameport);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (t > 0 && i < GUILLEMOT_MAX_LENGTH * 8) {
 		t--;
 		u = v; v = gameport_read(gameport);
@@ -108,6 +113,12 @@ static int guillemot_read_packet(struct
 			i++;
 			t = s;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	local_irq_restore(flags);
diff -u -p a/input/joystick/adi.c b/input/joystick/adi.c
--- a/input/joystick/adi.c
+++ b/input/joystick/adi.c
@@ -529,12 +529,23 @@ static int adi_connect(struct gameport *
 
 	return 0;
 
- fail3: while (--i >= 0) {
+ fail3: unsigned long long delta = (cpu / khz / HZ) * 2;
+ unsigned long long _start = 0;
+ unsigned long long _cur = 0;
+ unsigned long long timeout;
+ timeout = rdstcll(start) + delta;
+	while (--i >= 0) {
 		if (port->adi[i].length > 0) {
 			input_unregister_device(port->adi[i].dev);
 			port->adi[i].dev = NULL;
 		}
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
  fail2:	for (i = 0; i < 2; i++)
 		if (port->adi[i].dev)
 			input_free_device(port->adi[i].dev);
diff -u -p a/input/joystick/interact.c b/input/joystick/interact.c
--- a/input/joystick/interact.c
+++ b/input/joystick/interact.c
@@ -105,6 +105,11 @@ static int interact_read_packet(struct g
 	gameport_trigger(gameport);
 	v = gameport_read(gameport);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (t > 0 && i < length) {
 		t--;
 		u = v; v = gameport_read(gameport);
@@ -115,6 +120,12 @@ static int interact_read_packet(struct g
 			i++;
 			t = s;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	local_irq_restore(flags);
diff -u -p a/input/joystick/sidewinder.c b/input/joystick/sidewinder.c
--- a/input/joystick/sidewinder.c
+++ b/input/joystick/sidewinder.c
@@ -162,6 +162,11 @@ static int sw_read_packet(struct gamepor
 	if (bitout > 0)
 		bitout = strobe;				/* Extend time if not timed out */
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((timeout > 0 || bitout > 0) && (i < length)) {
 
 		timeout--;
@@ -190,6 +195,12 @@ static int sw_read_packet(struct gamepor
 			pending = 0;				/* Unmark schedule */
 			timeout = 0;				/* Switch from global to bit timeouts */
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	local_irq_restore(flags);					/* Done - relax */
@@ -222,12 +233,23 @@ static __u64 sw_get_bits(unsigned char *
 	int i   = pos / bits;
 	int bit = 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (num--) {
 		data |= (__u64)((buf[i] >> tri++) & 1) << bit++;	/* Transfer bit */
 		if (tri == bits) {
 			i++;						/* Next triplet */
 			tri = 0;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return data;
@@ -286,9 +308,20 @@ static int sw_check(__u64 t)
 	if ((t & 0x8080808080808080ULL) ^ 0x80)			/* Sync */
 		return -1;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (t) {						/* Sum */
 		sum += t & 0xf;
 		t >>= 4;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return sum & 0xf;
diff -u -p a/input/joystick/a3d.c b/input/joystick/a3d.c
--- a/input/joystick/a3d.c
+++ b/input/joystick/a3d.c
@@ -84,6 +84,11 @@ static int a3d_read_packet(struct gamepo
 	gameport_trigger(gameport);
 	v = gameport_read(gameport);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (t > 0 && i < length) {
 		t--;
 		u = v; v = gameport_read(gameport);
@@ -91,6 +96,12 @@ static int a3d_read_packet(struct gamepo
 			data[i++] = v >> 5;
 			t = s;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	local_irq_restore(flags);
diff -u -p a/input/joystick/tmdc.c b/input/joystick/tmdc.c
--- a/input/joystick/tmdc.c
+++ b/input/joystick/tmdc.c
@@ -398,11 +398,22 @@ static int tmdc_connect(struct gameport
 
 	return 0;
 
- fail3: while (--i >= 0) {
+ fail3: unsigned long long delta = (cpu / khz / HZ) * 2;
+ unsigned long long _start = 0;
+ unsigned long long _cur = 0;
+ unsigned long long timeout;
+ timeout = rdstcll(start) + delta;
+	while (--i >= 0) {
 		if (tmdc->port[i]) {
 			input_unregister_device(tmdc->port[i]->dev);
 			kfree(tmdc->port[i]);
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
  fail2:	gameport_close(gameport);
  fail1:	gameport_set_drvdata(gameport, NULL);
diff -u -p a/input/gameport/gameport.c b/input/gameport/gameport.c
--- a/input/gameport/gameport.c
+++ b/input/gameport/gameport.c
@@ -132,7 +132,18 @@ static int gameport_measure_speed(struct
 		return 0;
 
 	j = jiffies; while (j == jiffies);
-	j = jiffies; while (j == jiffies) { t++; gameport_read(gameport); }
+	j = jiffies; unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+	while (j == jiffies) { t++; gameport_read(gameport); if (_cur < timeout) {
+		rdstcll(_cur);
+		}
+		else {
+		break;
+		}
+	}
 
 	gameport_close(gameport);
 	return t * HZ / 1000;
diff -u -p a/input/gameport/lightning.c b/input/gameport/lightning.c
--- a/input/gameport/lightning.c
+++ b/input/gameport/lightning.c
@@ -229,9 +229,20 @@ static int __init l4_create_ports(int ca
 
 		if (!(l4->gameport = port = gameport_allocate_port())) {
 			printk(KERN_ERR "lightning: Memory allocation failed\n");
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (--i >= 0) {
 				gameport_free_port(l4->gameport);
 				l4->gameport = NULL;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 			return -ENOMEM;
 		}
diff -u -p a/input/tablet/gtco.c b/input/tablet/gtco.c
--- a/input/tablet/gtco.c
+++ b/input/tablet/gtco.c
@@ -231,6 +231,11 @@ static void parse_hid_report_descriptor(
 	dbg("======>>>>>>PARSE<<<<<<======");
 
 	/* Walk  this report and pull out the info we need */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i < length) {
 		prefix = report[i];
 
@@ -528,6 +533,12 @@ static void parse_hid_report_descriptor(
 
 			break;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/input/mouse/bcm5974.c b/input/mouse/bcm5974.c
--- a/input/mouse/bcm5974.c
+++ b/input/mouse/bcm5974.c
@@ -539,7 +539,12 @@ static int report_tp_state(struct bcm597
 			abs_w = int2bound(&c->w, raw_w);
 			abs_x = int2bound(&c->x, raw_x - c->x.devmin);
 			abs_y = int2bound(&c->y, c->y.devmax - raw_y);
-			while (raw_n--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while (raw_n--) {
 				ptest = int2bound(&c->p,
 						  raw2int(f->force_major));
 				if (ptest > PRESSURE_LOW)
@@ -547,6 +552,12 @@ static int report_tp_state(struct bcm597
 				if (ptest > PRESSURE_HIGH)
 					nmin++;
 				f++;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
diff -u -p a/input/mouse/synaptics.c b/input/mouse/synaptics.c
--- a/input/mouse/synaptics.c
+++ b/input/mouse/synaptics.c
@@ -1030,19 +1030,41 @@ static void synaptics_process_packet(str
 	if (hw.scroll) {
 		priv->scroll += hw.scroll;
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (priv->scroll >= 4) {
 			input_report_key(dev, BTN_BACK, !hw.down);
 			input_sync(dev);
 			input_report_key(dev, BTN_BACK, hw.down);
 			input_sync(dev);
 			priv->scroll -= 4;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (priv->scroll <= -4) {
 			input_report_key(dev, BTN_FORWARD, !hw.up);
 			input_sync(dev);
 			input_report_key(dev, BTN_FORWARD, hw.up);
 			input_sync(dev);
 			priv->scroll += 4;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		return;
 	}
diff -u -p a/input/mouse/psmouse-base.c b/input/mouse/psmouse-base.c
--- a/input/mouse/psmouse-base.c
+++ b/input/mouse/psmouse-base.c
@@ -1596,7 +1596,12 @@ static ssize_t psmouse_attr_set_protocol
 	if (!new_dev)
 		return -ENOMEM;
 
-	while (!list_empty(&serio->children)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (!list_empty(&serio->children)) {
 		if (++retry > 3) {
 			psmouse_warn(psmouse,
 				     "failed to destroy children ports, protocol change aborted.\n");
@@ -1617,6 +1622,12 @@ static ssize_t psmouse_attr_set_protocol
 			input_free_device(new_dev);
 			return count; /* switched by other thread */
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {
diff -u -p a/input/mouse/gpio_mouse.c b/input/mouse/gpio_mouse.c
--- a/input/mouse/gpio_mouse.c
+++ b/input/mouse/gpio_mouse.c
@@ -141,10 +141,21 @@ static int __devinit gpio_mouse_probe(st
 	platform_set_drvdata(pdev, NULL);
 
  out_free_gpios:
-	while (--i >= 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+ while (--i >= 0) {
 		pin = pdata->pins[i];
 		if (pin)
 			gpio_free(pin);
+			if (_cur < timeout) {
+	rdstcll(_cur);
+			}
+			else {
+	break;
+			}
 	}
  out:
 	return error;
diff -u -p a/input/mouse/vsxxxaa.c b/input/mouse/vsxxxaa.c
--- a/input/mouse/vsxxxaa.c
+++ b/input/mouse/vsxxxaa.c
@@ -401,11 +401,22 @@ static void vsxxxaa_parse_buffer(struct
 		 * data...) will get shifted out of the buffer after some
 		 * activity on the mouse.
 		 */
-		while (mouse->count > 0 && !IS_HDR_BYTE(buf[0])) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
+			while (mouse->count > 0 && !IS_HDR_BYTE(buf[0])) {
 			printk(KERN_ERR "%s on %s: Dropping a byte to regain "
 				"sync with mouse data stream...\n",
 				mouse->name, mouse->phys);
 			vsxxxaa_drop_bytes(mouse, 1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/*
diff -u -p a/input/touchscreen/usbtouchscreen.c b/input/touchscreen/usbtouchscreen.c
--- a/input/touchscreen/usbtouchscreen.c
+++ b/input/touchscreen/usbtouchscreen.c
@@ -1217,7 +1217,12 @@ static void usbtouch_process_multi(struc
 
 	/* loop over the received packet, process */
 	pos = 0;
-	while (pos < buf_len) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pos < buf_len) {
 		/* get packet len */
 		pkt_len = usbtouch->type->get_pkt_len(buffer + pos,
 							buf_len - pos);
@@ -1238,6 +1243,12 @@ static void usbtouch_process_multi(struc
 			return;
 		}
 		pos += pkt_len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out_flush_buf:
diff -u -p a/input/touchscreen/ucb1400_ts.c b/input/touchscreen/ucb1400_ts.c
--- a/input/touchscreen/ucb1400_ts.c
+++ b/input/touchscreen/ucb1400_ts.c
@@ -187,6 +187,11 @@ static int ucb1400_ts_thread(void *_ucb)
 	sched_setscheduler(tsk, SCHED_FIFO, &param);
 
 	set_freezable();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		unsigned int x, y, p;
 		long timeout;
@@ -231,6 +236,12 @@ static int ucb1400_ts_thread(void *_ucb)
 		wait_event_freezable_timeout(ucb->ts_wait,
 			ucb->irq_pending || ucb->ts_restart ||
 			kthread_should_stop(), timeout);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Send the "pen off" if we are stopping with the pen still active */
@@ -317,7 +328,12 @@ static int ucb1400_ts_detect_irq(struct
 
 	/* Wait for the conversion to complete. */
 	timeout = jiffies + HZ/2;
-	while (!(ucb1400_reg_read(ucb->ac97, UCB_ADC_DATA) &
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (!(ucb1400_reg_read(ucb->ac97, UCB_ADC_DATA) &
 						UCB_ADC_DAT_VALID)) {
 		cpu_relax();
 		if (time_after(jiffies, timeout)) {
@@ -325,6 +341,12 @@ static int ucb1400_ts_detect_irq(struct
 			probe_irq_off(mask);
 			return -ENODEV;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	ucb1400_reg_write(ucb->ac97, UCB_ADC_CR, 0);
 
diff -u -p a/input/touchscreen/stmpe-ts.c b/input/touchscreen/stmpe-ts.c
--- a/input/touchscreen/stmpe-ts.c
+++ b/input/touchscreen/stmpe-ts.c
@@ -108,10 +108,21 @@ static void stmpe_work(struct work_struc
 	 * touch_det keeps coming in after 4ms, while the FIFO contains no value
 	 * during the whole time.
 	 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((int_sta & (1 << STMPE_IRQ_TOUCH_DET)) && (timeout > 0)) {
 		timeout--;
 		int_sta = stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA);
 		udelay(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* reset the FIFO before we report release event */
diff -u -p a/input/touchscreen/ads7846.c b/input/touchscreen/ads7846.c
--- a/input/touchscreen/ads7846.c
+++ b/input/touchscreen/ads7846.c
@@ -721,6 +721,11 @@ static void ads7846_read_state(struct ad
 	int action;
 	int error;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (msg_idx < ts->msg_count) {
 
 		ts->wait_for_sync();
@@ -763,6 +768,12 @@ static void ads7846_read_state(struct ad
 		} else {
 			msg_idx++;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -879,6 +890,11 @@ static irqreturn_t ads7846_irq(int irq,
 	/* Start with a small delay before checking pendown state */
 	msleep(TS_POLL_DELAY);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!ts->stopped && get_pendown_state(ts)) {
 
 		/* pen is down, continue with the measurement */
@@ -889,6 +905,12 @@ static irqreturn_t ads7846_irq(int irq,
 
 		wait_event_timeout(ts->wait, ts->stopped,
 				   msecs_to_jiffies(TS_POLL_PERIOD));
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (ts->pendown) {
diff -u -p a/input/touchscreen/wm9705.c b/input/touchscreen/wm9705.c
--- a/input/touchscreen/wm9705.c
+++ b/input/touchscreen/wm9705.c
@@ -234,10 +234,21 @@ static int wm9705_poll_sample(struct wm9
 	poll_delay(delay);
 
 	/* wait for POLL to go low */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout == 0) {
diff -u -p a/input/touchscreen/wm9713.c b/input/touchscreen/wm9713.c
--- a/input/touchscreen/wm9713.c
+++ b/input/touchscreen/wm9713.c
@@ -284,10 +284,21 @@ static int wm9713_poll_sample(struct wm9
 	poll_delay(delay);
 
 	/* wait for POLL to go low */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((wm97xx_reg_read(wm, AC97_WM9713_DIG1) & WM9713_POLL) &&
 		timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout <= 0) {
@@ -349,10 +360,21 @@ static int wm9713_poll_coord(struct wm97
 	poll_delay(delay);
 	data->x = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);
 	/* wait for POLL to go low */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((wm97xx_reg_read(wm, AC97_WM9713_DIG1) & WM9713_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout <= 0) {
diff -u -p a/input/touchscreen/lpc32xx_ts.c b/input/touchscreen/lpc32xx_ts.c
--- a/input/touchscreen/lpc32xx_ts.c
+++ b/input/touchscreen/lpc32xx_ts.c
@@ -105,7 +105,12 @@ static irqreturn_t lpc32xx_ts_interrupt(
 	 * pen status check drop the samples.
 	 */
 	idx = 0;
-	while (idx < 4 &&
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (idx < 4 &&
 	       !(tsc_readl(tsc, LPC32XX_TSC_STAT) &
 			LPC32XX_TSC_STAT_FIFO_EMPTY)) {
 		tmp = tsc_readl(tsc, LPC32XX_TSC_FIFO);
@@ -115,6 +120,12 @@ static irqreturn_t lpc32xx_ts_interrupt(
 			LPC32XX_TSC_FIFO_NORMALIZE_Y_VAL(tmp);
 		rv[idx] = tmp;
 		idx++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	/* Data is only valid if pen is still down in last sample */
diff -u -p a/input/touchscreen/wm9712.c b/input/touchscreen/wm9712.c
--- a/input/touchscreen/wm9712.c
+++ b/input/touchscreen/wm9712.c
@@ -274,10 +274,21 @@ static int wm9712_poll_sample(struct wm9
 	poll_delay(delay);
 
 	/* wait for POLL to go low */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout <= 0) {
@@ -334,10 +345,21 @@ static int wm9712_poll_coord(struct wm97
 	poll_delay(delay);
 	data->x = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);
 	/* wait for POLL to go low */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)
 	       && timeout) {
 		udelay(AC97_LINK_FRAME);
 		timeout--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (timeout <= 0) {
diff -u -p a/input/touchscreen/tps6507x-ts.c b/input/touchscreen/tps6507x-ts.c
--- a/input/touchscreen/tps6507x-ts.c
+++ b/input/touchscreen/tps6507x-ts.c
@@ -152,12 +152,23 @@ static s32 tps6507x_adc_standby(struct t
 	if (ret)
 		return ret;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (val & TPS6507X_REG_TSC_INT) {
 		mdelay(10);
 		ret = tps6507x_read_u8(tsc, TPS6507X_REG_INT, &val);
 		if (ret)
 			return ret;
 		loops++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
diff -u -p a/input/touchscreen/atmel_mxt_ts.c b/input/touchscreen/atmel_mxt_ts.c
--- a/input/touchscreen/atmel_mxt_ts.c
+++ b/input/touchscreen/atmel_mxt_ts.c
@@ -977,7 +977,12 @@ static int mxt_load_fw(struct device *de
 	/* Unlock bootloader */
 	mxt_unlock_bootloader(client);
 
-	while (pos < fw->size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (pos < fw->size) {
 		ret = mxt_check_bootloader(client,
 						MXT_WAITING_FRAME_DATA);
 		if (ret)
@@ -1001,7 +1006,13 @@ static int mxt_load_fw(struct device *de
 		pos += frame_size;
 
 		dev_dbg(dev, "Updated %d bytes / %zd bytes\n", pos, fw->size);
-	}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
+		}
 
 out:
 	release_firmware(fw);
diff -u -p a/input/joydev.c b/input/joydev.c
--- a/input/joydev.c
+++ b/input/joydev.c
@@ -424,6 +424,11 @@ static ssize_t joydev_read(struct file *
 	if (!joydev->exist)
 		return -ENODEV;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retval + sizeof(struct js_event) <= count &&
 	       joydev_generate_startup_event(client, input, &event)) {
 
@@ -431,8 +436,19 @@ static ssize_t joydev_read(struct file *
 			return -EFAULT;
 
 		retval += sizeof(struct js_event);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retval + sizeof(struct js_event) <= count &&
 	       joydev_fetch_next_event(client, &event)) {
 
@@ -440,6 +456,12 @@ static ssize_t joydev_read(struct file *
 			return -EFAULT;
 
 		retval += sizeof(struct js_event);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return retval;
diff -u -p a/w1/w1.c b/w1/w1.c
--- a/w1/w1.c
+++ b/w1/w1.c
@@ -83,11 +83,22 @@ static void w1_slave_release(struct devi
 
 	dev_dbg(dev, "%s: Releasing %s.\n", __func__, sl->name);
 
-	while (atomic_read(&sl->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&sl->refcnt)) {
 		dev_dbg(dev, "Waiting for %s to become free: refcnt=%d.\n",
 				sl->name, atomic_read(&sl->refcnt));
 		if (msleep_interruptible(1000))
 			flush_signals(current);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	w1_family_put(sl->family);
diff -u -p a/w1/w1_family.c b/w1/w1_family.c
--- a/w1/w1_family.c
+++ b/w1/w1_family.c
@@ -78,12 +78,23 @@ void w1_unregister_family(struct w1_fami
 	/* deatch devices using this family code */
 	w1_reconnect_slaves(fent, 0);
 
-	while (atomic_read(&fent->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&fent->refcnt)) {
 		printk(KERN_INFO "Waiting for family %u to become free: refcnt=%d.\n",
 				fent->fid, atomic_read(&fent->refcnt));
 
 		if (msleep_interruptible(1000))
 			flush_signals(current);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 }
 
diff -u -p a/w1/w1_int.c b/w1/w1_int.c
--- a/w1/w1_int.c
+++ b/w1/w1_int.c
@@ -211,12 +211,23 @@ void __w1_remove_master_device(struct w1
 	mutex_unlock(&dev->mutex);
 	atomic_dec(&dev->refcnt);
 
-	while (atomic_read(&dev->refcnt)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (atomic_read(&dev->refcnt)) {
 		dev_info(&dev->dev, "Waiting for %s to become free: refcnt=%d.\n",
 				dev->name, atomic_read(&dev->refcnt));
 
 		if (msleep_interruptible(1000))
 			flush_signals(current);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 	memset(&msg, 0, sizeof(msg));
diff -u -p a/w1/slaves/w1_ds2431.c b/w1/slaves/w1_ds2431.c
--- a/w1/slaves/w1_ds2431.c
+++ b/w1/slaves/w1_ds2431.c
@@ -110,7 +110,12 @@ static ssize_t w1_f2d_read_bin(struct fi
 	mutex_lock(&sl->master->mutex);
 
 	/* read directly from the EEPROM in chunks of W1_F2D_READ_MAXLEN */
-	while (todo > 0) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (todo > 0) {
 		int block_read;
 
 		if (todo >= W1_F2D_READ_MAXLEN)
@@ -124,6 +129,12 @@ static ssize_t w1_f2d_read_bin(struct fi
 		todo -= W1_F2D_READ_MAXLEN;
 		buf += W1_F2D_READ_MAXLEN;
 		off += W1_F2D_READ_MAXLEN;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	mutex_unlock(&sl->master->mutex);
@@ -219,6 +230,11 @@ static ssize_t w1_f2d_write_bin(struct f
 	/* Can only write data in blocks of the size of the scratchpad */
 	addr = off;
 	len = count;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (len > 0) {
 
 		/* if len too short or addr not aligned */
@@ -256,6 +272,12 @@ static ssize_t w1_f2d_write_bin(struct f
 		buf += copy;
 		addr += copy;
 		len -= copy;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out_up:
diff -u -p a/w1/slaves/w1_ds2408.c b/w1/slaves/w1_ds2408.c
--- a/w1/slaves/w1_ds2408.c
+++ b/w1/slaves/w1_ds2408.c
@@ -171,6 +171,11 @@ static ssize_t w1_f29_write_output(
 	if (w1_reset_select_slave(sl))
 		goto error;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retries--) {
 		w1_buf[0] = W1_F29_FUNC_CHANN_ACCESS_WRITE;
 		w1_buf[1] = *buf;
@@ -205,6 +210,12 @@ static ssize_t w1_f29_write_output(
 				"mutex unlocked, retries:%d", retries);
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 error:
 	mutex_unlock(&sl->master->mutex);
@@ -233,6 +244,11 @@ static ssize_t w1_f29_write_activity(
 	if (w1_reset_select_slave(sl))
 		goto error;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retries--) {
 		w1_write_8(sl->master, W1_F29_FUNC_RESET_ACTIVITY_LATCHES);
 		if (w1_read_8(sl->master) == W1_F29_SUCCESS_CONFIRM_BYTE) {
@@ -241,6 +257,12 @@ static ssize_t w1_f29_write_activity(
 		}
 		if (w1_reset_resume_command(sl->master))
 			goto error;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 
 error:
@@ -268,6 +290,11 @@ static ssize_t w1_f29_write_status_contr
 	if (w1_reset_select_slave(sl))
 		goto error;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (retries--) {
 		w1_buf[0] = W1_F29_FUNC_WRITE_COND_SEARCH_REG;
 		w1_buf[1] = W1_F29_REG_CONTROL_AND_STATUS;
@@ -288,6 +315,12 @@ static ssize_t w1_f29_write_status_contr
 			mutex_unlock(&sl->master->mutex);
 			return 1;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 error:
 	mutex_unlock(&sl->master->mutex);
diff -u -p a/w1/slaves/w1_ds2433.c b/w1/slaves/w1_ds2433.c
--- a/w1/slaves/w1_ds2433.c
+++ b/w1/slaves/w1_ds2433.c
@@ -237,6 +237,11 @@ static ssize_t w1_f23_write_bin(struct f
 
 	/* Can only write data to one page at a time */
 	idx = 0;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (idx < count) {
 		addr = off + idx;
 		len = W1_PAGE_SIZE - (addr & W1_PAGE_MASK);
@@ -248,6 +253,12 @@ static ssize_t w1_f23_write_bin(struct f
 			goto out_up;
 		}
 		idx += len;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 out_up:
diff -u -p a/w1/masters/mxc_w1.c b/w1/masters/mxc_w1.c
--- a/w1/masters/mxc_w1.c
+++ b/w1/masters/mxc_w1.c
@@ -64,7 +64,12 @@ static u8 mxc_w1_ds2_reset_bus(void *dat
 
 	__raw_writeb(0x80, (dev->regs + MXC_W1_CONTROL));
 
-	while (1) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (1) {
 		reg_val = __raw_readb(dev->regs + MXC_W1_CONTROL);
 
 		if (((reg_val >> 7) & 0x1) == 0 ||
@@ -74,6 +79,12 @@ static u8 mxc_w1_ds2_reset_bus(void *dat
 			timeout_cnt++;
 
 		udelay(100);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return (reg_val >> 7) & 0x1;
 }
diff -u -p a/w1/masters/omap_hdq.c b/w1/masters/omap_hdq.c
--- a/w1/masters/omap_hdq.c
+++ b/w1/masters/omap_hdq.c
@@ -134,17 +134,39 @@ static int hdq_wait_for_flag(struct hdq_
 
 	if (flag_set == OMAP_HDQ_FLAG_CLEAR) {
 		/* wait for the flag clear */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (((*status = hdq_reg_in(hdq_data, offset)) & flag)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 		if (*status & flag)
 			ret = -ETIMEDOUT;
 	} else if (flag_set == OMAP_HDQ_FLAG_SET) {
 		/* wait for the flag set */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!((*status = hdq_reg_in(hdq_data, offset)) & flag)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (!(*status & flag))
 			ret = -ETIMEDOUT;
@@ -375,10 +397,21 @@ static int hdq_read_byte(struct hdq_data
 		 * triggers another interrupt before we
 		 * sleep. So we have to wait for RXCOMPLETE bit.
 		 */
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (!(hdq_data->hdq_irqstatus
 			& OMAP_HDQ_INT_STATUS_RXCOMPLETE)
 			&& time_before(jiffies, timeout)) {
 			schedule_timeout_uninterruptible(1);
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		hdq_reg_merge(hdq_data, OMAP_HDQ_CTRL_STATUS, 0,
 			OMAP_HDQ_CTRL_STATUS_DIR);
diff -u -p a/uwb/hwa-rc.c b/uwb/hwa-rc.c
--- a/uwb/hwa-rc.c
+++ b/uwb/hwa-rc.c
@@ -752,7 +752,12 @@ static int hwarc_get_version(struct uwb_
 		sizeof(usb_dev->config[0]);
 	itr = usb_dev->rawdescriptors[actconfig_idx];
 	itr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);
-	while (itr_size >= sizeof(*hdr)) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (itr_size >= sizeof(*hdr)) {
 		hdr = (struct usb_descriptor_header *) itr;
 		dev_dbg(dev, "Extra device descriptor: "
 			"type %02x/%u bytes @ %zu (%zu left)\n",
@@ -763,6 +768,12 @@ static int hwarc_get_version(struct uwb_
 			goto found;
 		itr += hdr->bLength;
 		itr_size -= hdr->bLength;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	dev_err(dev, "cannot find Radio Control Interface Class descriptor\n");
 	return -ENODEV;
diff -u -p a/uwb/i1480/dfu/mac.c b/uwb/i1480/dfu/mac.c
--- a/uwb/i1480/dfu/mac.c
+++ b/uwb/i1480/dfu/mac.c
@@ -49,10 +49,21 @@ void fw_hdrs_free(struct fw_hdr *hdr)
 {
 	struct fw_hdr *next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (hdr) {
 		next = hdr->next;
 		kfree(hdr);
 		hdr = next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -122,7 +133,12 @@ int fw_hdrs_load(struct i1480 *i1480, st
 	*phdr = NULL;
 	data_itr = data;
 	data_top = (u32 *) (_data + data_size);
-	while (data_itr < data_top) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+		while (data_itr < data_top) {
 		result = -ENOMEM;
 		hdr = kmalloc(sizeof(*hdr), GFP_KERNEL);
 		if (hdr == NULL) {
@@ -138,6 +154,12 @@ int fw_hdrs_load(struct i1480 *i1480, st
 		*prev_hdr = hdr;
 		prev_hdr = &hdr->next;
 		hdr_cnt++;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	};
 	*prev_hdr = NULL;
 	return 0;
@@ -172,6 +194,11 @@ ssize_t i1480_fw_cmp(struct i1480 *i1480
 	size_t chunk_size;
 	u8 *bin = (u8 *) hdr->bin;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (size > 0) {
 		chunk_size = size < i1480->buf_size ? size : i1480->buf_size;
 		result = i1480->read(i1480, hdr->address + src_itr, chunk_size);
@@ -194,6 +221,12 @@ ssize_t i1480_fw_cmp(struct i1480 *i1480
 		}
 		src_itr += result;
 		size -= result;
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	result = 0;
 error:
diff -u -p a/uwb/drp-avail.c b/uwb/drp-avail.c
--- a/uwb/drp-avail.c
+++ b/uwb/drp-avail.c
@@ -145,10 +145,21 @@ unsigned long get_val(u8 *array, size_t
 
 	BUG_ON(len > sizeof(val));
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (itr < top) {
 		val <<= 8;
 		val |= array[top - 1];
 		top--;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	val <<= 8 * (sizeof(val) - len); /* padding */
 	return val;
@@ -207,12 +218,23 @@ void buffer_to_bmp(unsigned long *bmp_it
 	unsigned long val;
 
 	itr = 0;
-	while (itr < buffer_size) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+		while (itr < buffer_size) {
 		len = buffer_size - itr >= sizeof(val) ?
 			sizeof(val) : buffer_size - itr;
 		val = get_val(buffer, itr, len);
 		bmp_itr[itr / sizeof(val)] = val;
 		itr += sizeof(val);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
diff -u -p a/video/sis/sis_main.c b/video/sis/sis_main.c
--- a/video/sis/sis_main.c
+++ b/video/sis/sis_main.c
@@ -332,12 +332,23 @@ sisfb_search_specialtiming(const char *n
 			printk(KERN_WARNING "sisfb: Invalid SpecialTiming parameter, valid are:");
 			printk(KERN_WARNING "\t\"none\" (to disable special timings)\n");
 			i = 0;
-			while(mycustomttable[i].chipID != 0) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
+				while(mycustomttable[i].chipID != 0) {
 				printk(KERN_WARNING "\t\"%s\" (for %s %s)\n",
 					mycustomttable[i].optionName,
 					mycustomttable[i].vendorName,
 					mycustomttable[i].cardName);
 				i++;
+				if (_cur < timeout) {
+				rdstcll(_cur);
+				}
+				else {
+				break;
+				}
 			}
 		}
 	}
@@ -3347,6 +3358,11 @@ sisfb_poh_free(struct SIS_HEAP *memheap,
 
 	pohThis = memheap->oh_free.poh_next;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while(pohThis != &memheap->oh_free) {
 		if(pohThis->offset == ulUpper) {
 			poh_next = pohThis;
@@ -3354,6 +3370,12 @@ sisfb_poh_free(struct SIS_HEAP *memheap,
 			poh_prev = pohThis;
 		}
 		pohThis = pohThis->poh_next;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	sisfb_delete_node(poh_freed);
@@ -3783,9 +3805,20 @@ sisfb_set_TVyposoffset(struct sis_video_
 			p2_01 += val;
 			p2_02 += val;
 			if(!(ivideo->currentvbflags & (TV_HIVISION | TV_YPBPR))) {
+				unsigned long long delta = (cpu / khz / HZ) * 2;
+				unsigned long long _start = 0;
+				unsigned long long _cur = 0;
+				unsigned long long timeout;
+				timeout = rdstcll(start) + delta;
 				while((p2_01 <= 0) || (p2_02 <= 0)) {
 					p2_01 += 2;
 					p2_02 += 2;
+					if (_cur < timeout) {
+							rdstcll(_cur);
+					}
+					else {
+							break;
+					}
 				}
 			}
 			SiS_SetReg(SISPART2, 0x01, p2_01);
@@ -3972,6 +4005,11 @@ static int __init sisfb_setup(char *opti
 	if(!options || !(*options))
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while((this_opt = strsep(&options, ",")) != NULL) {
 
 		if(!(*this_opt)) continue;
@@ -4055,6 +4093,12 @@ static int __init sisfb_setup(char *opti
 			printk(KERN_INFO "sisfb: Invalid option %s\n", this_opt);
 		}
 
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return 0;
diff -u -p a/video/sis/init301.c b/video/sis/init301.c
--- a/video/sis/init301.c
+++ b/video/sis/init301.c
@@ -453,8 +453,19 @@ SiS_GenericDelay(struct SiS_Private *SiS
 static void
 SiS_LongDelay(struct SiS_Private *SiS_Pr, unsigned short delay)
 {
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    while(delay--) {
       SiS_GenericDelay(SiS_Pr, 6623);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
+         break;
+      }
    }
 }
 #endif
@@ -463,8 +474,19 @@ SiS_LongDelay(struct SiS_Private *SiS_Pr
 static void
 SiS_ShortDelay(struct SiS_Private *SiS_Pr, unsigned short delay)
 {
+   unsigned long long delta = (cpu / khz / HZ) * 2;
+   unsigned long long _start = 0;
+   unsigned long long _cur = 0;
+   unsigned long long timeout;
+   timeout = rdstcll(start) + delta;
    while(delay--) {
       SiS_GenericDelay(SiS_Pr, 66);
+      if (_cur < timeout) {
+         rdstcll(_cur);
+      }
+      else {
+         break;
+      }
    }
 }
 #endif
@@ -8771,9 +8793,20 @@ SiS_SetTrumpionBlock(struct SiS_Private
 
   SiS_SetSwitchDDC2(SiS_Pr);
 
+  unsigned long long delta = (cpu / khz / HZ) * 2;
+  unsigned long long _start = 0;
+  unsigned long long _cur = 0;
+  unsigned long long timeout;
+  timeout = rdstcll(start) + delta;
   while(*dataptr) {
      dataptr = SiS_SetTrumpBlockLoop(SiS_Pr, dataptr);
      if(!dataptr) return false;
+     if (_cur < timeout) {
+       rdstcll(_cur);
+     }
+     else {
+       break;
+     }
   }
   return true;
 }
diff -u -p a/video/imxfb.c b/video/imxfb.c
--- a/video/imxfb.c
+++ b/video/imxfb.c
@@ -931,11 +931,22 @@ static int imxfb_setup(void)
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
 		else
 			fb_mode = opt;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 #endif
 	return 0;
diff -u -p a/video/igafb.c b/video/igafb.c
--- a/video/igafb.c
+++ b/video/igafb.c
@@ -564,7 +564,18 @@ static int __init igafb_setup(char *opti
     if (!options || !*options)
         return 0;
 
+    unsigned long long delta = (cpu / khz / HZ) * 2;
+    unsigned long long _start = 0;
+    unsigned long long _cur = 0;
+    unsigned long long timeout;
+    timeout = rdstcll(start) + delta;
     while ((this_opt = strsep(&options, ",")) != NULL) {
+        if (_cur < timeout) {
+            rdstcll(_cur);
+        }
+        else {
+            break;
+        }
     }
     return 0;
 }
diff -u -p a/video/pm2fb.c b/video/pm2fb.c
--- a/video/pm2fb.c
+++ b/video/pm2fb.c
@@ -313,11 +313,22 @@ static void clear_palette(struct pm2fb_p
 	WAIT_FIFO(p, 1);
 	pm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, 0);
 	wmb();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (i--) {
 		WAIT_FIFO(p, 3);
 		pm2_WR(p, PM2R_RD_PALETTE_DATA, 0);
 		pm2_WR(p, PM2R_RD_PALETTE_DATA, 0);
 		pm2_WR(p, PM2R_RD_PALETTE_DATA, 0);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 }
 
@@ -1237,14 +1248,36 @@ static void pm2fb_imageblit(struct fb_in
 			PM2F_RENDER_SYNC_ON_BIT_MASK);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (height--) {
 		int width = ((image->width + 7) >> 3)
 				+ info->pixmap.scan_align - 1;
 		width >>= 2;
 		WAIT_FIFO(par, width);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (width--) {
 			pm2_WR(par, PM2R_BIT_MASK_PATTERN, *src);
 			src++;
+			if (_cur < timeout) {
+		rdstcll(_cur);
+			}
+			else {
+		break;
+			}
+		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
 		}
 	}
 	WAIT_FIFO(par, 3);
@@ -1352,9 +1385,20 @@ static int pm2vfb_cursor(struct fb_info
 			}
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (pos < (1024 + PM2VI_RD_CURSOR_PATTERN)) {
 			pm2_WR(par, PM2VR_RD_INDEX_HIGH, pos >> 8);
 			pm2v_RDAC_WR(par, pos++, 0);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		pm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);
@@ -1784,6 +1828,11 @@ static int __init pm2fb_setup(char *opti
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -1801,6 +1850,12 @@ static int __init pm2fb_setup(char *opti
 			noaccel = 1;
 		else
 			mode_option = this_opt;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return 0;
 }
diff -u -p a/video/ffb.c b/video/ffb.c
--- a/video/ffb.c
+++ b/video/ffb.c
@@ -581,6 +581,11 @@ static void ffb_imageblit(struct fb_info
 		upa_writel(32, &fbc->fontw);
 	}
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (width >= 32) {
 		const u8 *next_data = data + 4;
 
@@ -601,6 +606,12 @@ static void ffb_imageblit(struct fb_info
 
 		data = next_data;
 		width -= 32;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (width) {
diff -u -p a/video/valkyriefb.c b/video/valkyriefb.c
--- a/video/valkyriefb.c
+++ b/video/valkyriefb.c
@@ -564,6 +564,11 @@ int __init valkyriefb_setup(char *option
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "vmode:", 6)) {
 	    		int vmode = simple_strtoul(this_opt+6, NULL, 0);
@@ -582,6 +587,12 @@ int __init valkyriefb_setup(char *option
 				break;
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/video/tmiofb.c b/video/tmiofb.c
--- a/video/tmiofb.c
+++ b/video/tmiofb.c
@@ -365,7 +365,12 @@ tmiofb_acc_wait(struct fb_info *info, un
 	 */
 	if (irqs_disabled() || par->use_polling) {
 		int i = 0;
-		while (tmio_ioread16(par->lcr + LCR_CCS) > ccs) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (tmio_ioread16(par->lcr + LCR_CCS) > ccs) {
 			udelay(1);
 			i++;
 			if (i > 10000) {
@@ -374,6 +379,12 @@ tmiofb_acc_wait(struct fb_info *info, un
 				return -ETIMEDOUT;
 			}
 			tmiofb_irq(-1, info);
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	} else {
 		if (!wait_event_interruptible_timeout(par->wait_acc,
@@ -421,6 +432,11 @@ static int tmiofb_sync(struct fb_info *f
 
 	ret = tmiofb_acc_wait(fbi, 0);
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (tmio_ioread16(par->lcr + LCR_BBES) & 2) { /* blit active */
 		udelay(1);
 		i++ ;
@@ -428,6 +444,12 @@ static int tmiofb_sync(struct fb_info *f
 			printk(KERN_ERR "timeout waiting for blit to end!\n");
 			return -ETIMEDOUT;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	return ret;
@@ -1013,12 +1035,23 @@ static void __init tmiofb_setup(char *op
 	if (!options || !*options)
 		return;
 
-	while ((this_opt = strsep(&options, ",")) != NULL) {
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
+while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
 		/*
 		 * FIXME
 		 */
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 }
 #endif
diff -u -p a/video/sgivwfb.c b/video/sgivwfb.c
--- a/video/sgivwfb.c
+++ b/video/sgivwfb.c
@@ -731,6 +731,11 @@ int __init sgivwfb_setup(char *options)
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "monitor:", 8)) {
 			if (!strncmp(this_opt + 8, "crt", 3))
@@ -738,6 +743,12 @@ int __init sgivwfb_setup(char *options)
 			else if (!strncmp(this_opt + 8, "1600sw", 6))
 				flatpanel_id = FLATPANEL_SGI_1600SW;
 		}
+		if (_cur < timeout) {
+				rdstcll(_cur);
+		}
+		else {
+				break;
+		}
 	}
 	return 0;
 }
diff -u -p a/video/sysimgblt.c b/video/sysimgblt.c
--- a/video/sysimgblt.c
+++ b/video/sysimgblt.c
@@ -73,7 +73,12 @@ static void color_imageblit(const struct
 			val = *dst & start_mask;
 			shift = start_index;
 		}
-		while (n--) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
+			while (n--) {
 			if (p->fix.visual == FB_VISUAL_TRUECOLOR ||
 			    p->fix.visual == FB_VISUAL_DIRECTCOLOR )
 				color = palette[*src];
@@ -90,6 +95,12 @@ static void color_imageblit(const struct
 			shift += bpp;
 			shift &= (32 - 1);
 			src++;
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
 		}
 		if (shift) {
 			u32 end_mask = FB_SHIFT_HIGH(p, ~(u32)0, shift);
@@ -139,6 +150,11 @@ static void slow_imageblit(const struct
 			shift = start_index;
 		}
 
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (j--) {
 			l--;
 			color = (*s & (1 << l)) ? fgcolor : bgcolor;
@@ -153,7 +169,13 @@ static void slow_imageblit(const struct
 			shift += bpp;
 			shift &= (32 - 1);
 			if (!l) { l = 8; s++; };
-		}
+			if (_cur < timeout) {
+					rdstcll(_cur);
+			}
+			else {
+					break;
+			}
+ 		}
 
 		/* write trailing bits */
  		if (shift) {
diff -u -p a/video/au1200fb.c b/video/au1200fb.c
--- a/video/au1200fb.c
+++ b/video/au1200fb.c
@@ -781,8 +781,19 @@ static void au1200_setpanel (struct pane
 	if (lcd->screen & LCD_SCREEN_SEN) {
 		/* Wait for vertical sync period */
 		lcd->intstatus = LCD_INT_SS;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((lcd->intstatus & LCD_INT_SS) == 0) {
 			au_sync();
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		lcd->screen &= ~LCD_SCREEN_SEN;	/*disable the controller*/
@@ -1768,6 +1779,11 @@ static int au1200fb_setup(void)
 	fb_get_options(DRIVER_NAME, &options);
 
 	if (options) {
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while ((this_opt = strsep(&options,",")) != NULL) {
 			/* Panel option - can be panel name,
 			 * "bs" for board-switch, or number/index */
@@ -1830,6 +1846,12 @@ static int au1200fb_setup(void)
 			else {
 				print_warn("Unsupported option \"%s\"", this_opt);
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	return 0;
diff -u -p a/video/s3fb.c b/video/s3fb.c
--- a/video/s3fb.c
+++ b/video/s3fb.c
@@ -1515,6 +1515,11 @@ static int  __init s3fb_setup(char *opti
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((opt = strsep(&options, ",")) != NULL) {
 
 		if (!*opt)
@@ -1527,6 +1532,12 @@ static int  __init s3fb_setup(char *opti
 			fasttext = simple_strtoul(opt + 9, NULL, 0);
 		else
 			mode_option = opt;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 
 	return 0;
diff -u -p a/video/ps3fb.c b/video/ps3fb.c
--- a/video/ps3fb.c
+++ b/video/ps3fb.c
@@ -898,6 +898,11 @@ static int ps3fbd(void *arg)
 	struct fb_info *info = arg;
 
 	set_freezable();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 		try_to_freeze();
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -908,6 +913,12 @@ static int ps3fbd(void *arg)
 			console_unlock();
 		}
 		schedule();
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/video/matrox/matroxfb_accel.c b/video/matrox/matroxfb_accel.c
--- a/video/matrox/matroxfb_accel.c
+++ b/video/matrox/matroxfb_accel.c
@@ -459,26 +459,53 @@ static void matroxfb_1bpp_imageblit(stru
 			mga_memcpy_toio(mmio, chardata, charcell);
 		} else if (step == 1) {
 			/* Special case for 1..8bit widths */
-			while (height--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (height--) {
 #if defined(__BIG_ENDIAN)
 				fb_writel((*chardata) << 24, mmio.vaddr);
 #else
 				fb_writel(*chardata, mmio.vaddr);
 #endif
 				chardata++;
+				if (_cur < timeout) {
+						rdstcll(_cur);
+				}
+				else {
+						break;
+				}
 			}
 		} else if (step == 2) {
 			/* Special case for 9..15bit widths */
-			while (height--) {
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+unsigned long long timeout;
+timeout = rdstcll(start) + delta;
+while (height--) {
 #if defined(__BIG_ENDIAN)
 				fb_writel((*(u_int16_t*)chardata) << 16, mmio.vaddr);
 #else
 				fb_writel(*(u_int16_t*)chardata, mmio.vaddr);
 #endif
 				chardata += 2;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		} else {
 			/* Tell... well, why bother... */
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (height--) {
 				size_t i;
 				
@@ -487,6 +514,12 @@ static void matroxfb_1bpp_imageblit(stru
 					fb_writel(get_unaligned((u_int32_t*)(chardata + i)),mmio.vaddr);
 				}
 				chardata += step;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
diff -u -p a/video/matrox/matroxfb_crtc2.c b/video/matrox/matroxfb_crtc2.c
--- a/video/matrox/matroxfb_crtc2.c
+++ b/video/matrox/matroxfb_crtc2.c
@@ -141,8 +141,19 @@ static void matroxfb_dh_restore(struct m
 			unsigned int nl;
 			unsigned int lastl = 0;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while ((nl = mga_inl(0x3C48) & 0xFFF) >= lastl) {
 				lastl = nl;
+				if (_cur < timeout) {
+					rdstcll(_cur);
+				}
+				else {
+					break;
+				}
 			}
 		}
 	}
diff -u -p a/video/matrox/matroxfb_misc.c b/video/matrox/matroxfb_misc.c
--- a/video/matrox/matroxfb_misc.c
+++ b/video/matrox/matroxfb_misc.c
@@ -244,21 +244,43 @@ int matroxfb_vgaHWinit(struct matrox_fb_
 	/* do it for 4bpp (because of (4bpp >> 1(interleaved))/4 == 0) */
 	/* using 16 or more pixels per unit can save us */
 	divider = minfo->curr.final_bppShift;
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (divider & 3) {
 		hd >>= 1;
 		hs >>= 1;
 		he >>= 1;
 		ht >>= 1;
 		divider <<= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	divider = divider / 4;
 	/* divider can be from 1 to 8 */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (divider > 8) {
 		hd <<= 1;
 		hs <<= 1;
 		he <<= 1;
 		ht <<= 1;
 		divider >>= 1;
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	hd = hd - 1;
 	hs = hs - 1;
diff -u -p a/video/matrox/matroxfb_base.c b/video/matrox/matroxfb_base.c
--- a/video/matrox/matroxfb_base.c
+++ b/video/matrox/matroxfb_base.c
@@ -591,6 +591,11 @@ static int matroxfb_decode_var(const str
 			unsigned int m2 = PAGE_SIZE;	/* or 128 if you do not need PAGE ALIGNED address */
 			unsigned int max_yres;
 
+			unsigned long long delta = (cpu / khz / HZ) * 2;
+			unsigned long long _start = 0;
+			unsigned long long _cur = 0;
+			unsigned long long timeout;
+			timeout = rdstcll(start) + delta;
 			while (m1) {
 				int t;
 
@@ -598,6 +603,12 @@ static int matroxfb_decode_var(const str
 				t = m1;
 				m1 = m2;
 				m2 = t;
+				if (_cur < timeout) {
+				      rdstcll(_cur);
+				}
+				else {
+				      break;
+				}
 			}
 			m2 = linelen * PAGE_SIZE / m2;
 			*ydstorg = m2 = 0x400000 % m2;
@@ -2297,6 +2308,11 @@ static int __init matroxfb_setup(char *o
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt) continue;
 
@@ -2424,6 +2440,12 @@ static int __init matroxfb_setup(char *o
 				strlcpy(videomode, this_opt, sizeof(videomode));
 			}
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/video/matrox/g450_pll.c b/video/matrox/g450_pll.c
--- a/video/matrox/g450_pll.c
+++ b/video/matrox/g450_pll.c
@@ -121,9 +121,20 @@ static unsigned int g450_firstpll(const
 
 		p = 3;
 		tvco = g450_f2vco(p, fout);
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (p && (tvco > vcomax)) {
 			p--;
 			tvco >>= 1;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		if (tvco < pi->vcomin) {
 			tvco = pi->vcomin;
@@ -275,6 +286,11 @@ static inline unsigned int g450_findwork
 			}
 			*sptr = mnp;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (sptr >= sarray) {
 			unsigned int mnp = *sptr--;
 		
@@ -291,6 +307,12 @@ static inline unsigned int g450_findwork
 				mnpfound = mnp;
 				found = 1;
 			}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 	}
 	g450_setpll(minfo, mnpfound, pll);
diff -u -p a/video/cirrusfb.c b/video/cirrusfb.c
--- a/video/cirrusfb.c
+++ b/video/cirrusfb.c
@@ -2356,6 +2356,11 @@ static int __init cirrusfb_setup(char *o
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt)
 			continue;
@@ -2366,6 +2371,12 @@ static int __init cirrusfb_setup(char *o
 			mode_option = this_opt + 5;
 		else
 			mode_option = this_opt;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 	}
 	return 0;
 }
@@ -2848,6 +2859,11 @@ static void cirrusfb_dbg_print_regs(stru
 	va_start(list, reg_class);
 
 	name = va_arg(list, char *);
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (name != NULL) {
 		reg = va_arg(list, int);
 
@@ -2867,6 +2883,12 @@ static void cirrusfb_dbg_print_regs(stru
 		dev_dbg(info->device, "%8s = 0x%02X\n", name, val);
 
 		name = va_arg(list, char *);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	va_end(list);
diff -u -p a/video/cyber2000fb.c b/video/cyber2000fb.c
--- a/video/cyber2000fb.c
+++ b/video/cyber2000fb.c
@@ -1498,6 +1498,11 @@ static int cyber2000fb_setup(char *optio
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
@@ -1512,6 +1517,12 @@ static int cyber2000fb_setup(char *optio
 		}
 
 		printk(KERN_ERR "CyberPro20x0: unknown parameter: %s\n", opt);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 	return 0;
 }
diff -u -p a/video/pvr2fb.c b/video/pvr2fb.c
--- a/video/pvr2fb.c
+++ b/video/pvr2fb.c
@@ -1030,6 +1030,11 @@ static int __init pvr2fb_setup(char *opt
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
@@ -1046,6 +1051,12 @@ static int __init pvr2fb_setup(char *opt
 		} else {
 			mode_option = this_opt;
 		}
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	if (*cable_arg)
diff -u -p a/video/sysfillrect.c b/video/sysfillrect.c
--- a/video/sysfillrect.c
+++ b/video/sysfillrect.c
@@ -50,6 +50,11 @@ bitfill_aligned(struct fb_info *p, unsig
 
 		/* Main chunk */
 		n /= bits;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (n >= 8) {
 			*dst++ = pat;
 			*dst++ = pat;
@@ -60,6 +65,12 @@ bitfill_aligned(struct fb_info *p, unsig
 			*dst++ = pat;
 			*dst++ = pat;
 			n -= 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		while (n--)
 			*dst++ = pat;
@@ -106,6 +117,11 @@ bitfill_unaligned(struct fb_info *p, uns
 
 		/* Main chunk */
 		n /= bits;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (n >= 4) {
 			*dst++ = pat;
 			pat = pat << left | pat >> right;
@@ -116,10 +132,27 @@ bitfill_unaligned(struct fb_info *p, uns
 			*dst++ = pat;
 			pat = pat << left | pat >> right;
 			n -= 4;
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (n--) {
 			*dst++ = pat;
 			pat = pat << left | pat >> right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Trailing bits */
@@ -160,6 +193,11 @@ bitfill_aligned_rev(struct fb_info *p, u
 
 		/* Main chunk */
 		n /= bits;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (n >= 8) {
 			*dst++ ^= val;
 			*dst++ ^= val;
@@ -170,6 +208,12 @@ bitfill_aligned_rev(struct fb_info *p, u
 			*dst++ ^= val;
 			*dst++ ^= val;
 			n -= 8;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 		while (n--)
 			*dst++ ^= val;
@@ -218,6 +262,11 @@ bitfill_unaligned_rev(struct fb_info *p,
 
 		/* Main chunk */
 		n /= bits;
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (n >= 4) {
 			*dst++ ^= pat;
 			pat = pat << left | pat >> right;
@@ -228,10 +277,27 @@ bitfill_unaligned_rev(struct fb_info *p,
 			*dst++ ^= pat;
 			pat = pat << left | pat >> right;
 			n -= 4;
-		}
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
+		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (n--) {
 			*dst ^= pat;
 			pat = pat << left | pat >> right;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 		}
 
 		/* Trailing bits */
@@ -285,11 +351,22 @@ void sys_fillrect(struct fb_info *p, con
 			fill_op32 = bitfill_aligned;
 			break;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (height--) {
 			dst += dst_idx >> (ffs(bits) - 1);
 			dst_idx &= (bits - 1);
 			fill_op32(p, dst, dst_idx, pat, width*bpp, bits);
 			dst_idx += p->fix.line_length*8;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	} else {
 		int right, r;
@@ -315,6 +392,11 @@ void sys_fillrect(struct fb_info *p, con
 			fill_op = bitfill_unaligned;
 			break;
 		}
+		unsigned long long delta = (cpu / khz / HZ) * 2;
+		unsigned long long _start = 0;
+		unsigned long long _cur = 0;
+		unsigned long long timeout;
+		timeout = rdstcll(start) + delta;
 		while (height--) {
 			dst += dst_idx / bits;
 			dst_idx &= (bits - 1);
@@ -324,6 +406,12 @@ void sys_fillrect(struct fb_info *p, con
 			fill_op(p, dst, dst_idx, pat2, left, right,
 				width*bpp, bits);
 			dst_idx += p->fix.line_length*8;
+			if (_cur < timeout) {
+			rdstcll(_cur);
+			}
+			else {
+			break;
+			}
 		}
 	}
 }
diff -u -p a/video/gbefb.c b/video/gbefb.c
--- a/video/gbefb.c
+++ b/video/gbefb.c
@@ -1105,6 +1105,11 @@ static int __devinit gbefb_setup(char *o
 	if (!options || !*options)
 		return 0;
 
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!strncmp(this_opt, "monitor:", 8)) {
 			if (!strncmp(this_opt + 8, "crt", 3)) {
@@ -1125,6 +1130,12 @@ static int __devinit gbefb_setup(char *o
 				gbe_mem_size = TILE_SIZE;
 		} else
 			mode_option = this_opt;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
diff -u -p a/video/pxafb.c b/video/pxafb.c
--- a/video/pxafb.c
+++ b/video/pxafb.c
@@ -1266,6 +1266,11 @@ static int pxafb_smart_thread(void *arg)
 	pr_debug("%s(): task starting\n", __func__);
 
 	set_freezable();
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while (!kthread_should_stop()) {
 
 		if (try_to_freeze())
@@ -1282,6 +1287,12 @@ static int pxafb_smart_thread(void *arg)
 
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(30 * HZ / 1000);
+		if (_cur < timeout) {
+			rdstcll(_cur);
+		}
+		else {
+			break;
+		}
 	}
 
 	pr_debug("%s(): task ending\n", __func__);
@@ -2019,10 +2030,21 @@ static int __devinit pxafb_parse_options
 	dev_dbg(dev, "options are \"%s\"\n", options ? options : "null");
 
 	/* could be made table driven or similar?... */
+	unsigned long long delta = (cpu / khz / HZ) * 2;
+	unsigned long long _start = 0;
+	unsigned long long _cur = 0;
+	unsigned long long timeout;
+	timeout = rdstcll(start) + delta;
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		ret = parse_opt(dev, this_opt);
 		if (ret)
 			return ret;
+			if (_cur < timeout) {
+				rdstcll(_cur);
+			}
+			else {
+				break;
+			}
 	}
 	return 0;
 }
